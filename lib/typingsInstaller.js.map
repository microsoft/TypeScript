{"version":3,"sources":["../../compiler/types.ts","../../compiler/performance.ts","../../compiler/core.ts","../../compiler/sys.ts","../../compiler/diagnosticInformationMap.generated.ts","../../compiler/utilities.ts","../../compiler/scanner.ts","../../compiler/parser.ts","../../compiler/commandLineParser.ts","../../compiler/moduleNameResolver.ts","../../services/semver.ts","../../services/jsTyping.ts","../shared.ts","typingsInstaller.ts","nodeTypingsInstaller.ts","../types.ts"],"names":[],"mappings":"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G,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAG,CAAC;IAC5kG,IAAM,wBAAwB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAG,CAAC;IAwBvlI,IAAM,yBAAyB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAG,CAAC;IACljJ,IAAM,wBAAwB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,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","file":"typingsInstaller.js","sourcesContent":["namespace ts {\r\n    /**\r\n     * Type of objects whose values are all of the same type.\r\n     * The `in` and `for-in` operators can *not* be safely used,\r\n     * since `Object.prototype` may be modified by outside code.\r\n     */\r\n    export interface MapLike<T> {\r\n        [index: string]: T;\r\n    }\r\n\r\n    /** ES6 Map interface, only read methods included. */\r\n    export interface ReadonlyMap<T> {\r\n        get(key: string): T | undefined;\r\n        has(key: string): boolean;\r\n        forEach(action: (value: T, key: string) => void): void;\r\n        readonly size: number;\r\n        keys(): Iterator<string>;\r\n        values(): Iterator<T>;\r\n        entries(): Iterator<[string, T]>;\r\n    }\r\n\r\n    /** ES6 Map interface. */\r\n    export interface Map<T> extends ReadonlyMap<T> {\r\n        set(key: string, value: T): this;\r\n        delete(key: string): boolean;\r\n        clear(): void;\r\n    }\r\n\r\n    /** ES6 Iterator type. */\r\n    export interface Iterator<T> {\r\n        next(): { value: T, done: false } | { value: never, done: true };\r\n    }\r\n\r\n    /** Array that is only intended to be pushed to, never read. */\r\n    export interface Push<T> {\r\n        push(...values: T[]): void;\r\n    }\r\n\r\n    /* @internal */\r\n    export type EqualityComparer<T> = (a: T, b: T) => boolean;\r\n\r\n    /* @internal */\r\n    export type Comparer<T> = (a: T, b: T) => Comparison;\r\n\r\n    /* @internal */\r\n    export const enum Comparison {\r\n        LessThan    = -1,\r\n        EqualTo     = 0,\r\n        GreaterThan = 1\r\n    }\r\n\r\n    // branded string type used to store absolute, normalized and canonicalized paths\r\n    // arbitrary file name can be converted to Path via toPath function\r\n    export type Path = string & { __pathBrand: any };\r\n\r\n    export interface TextRange {\r\n        pos: number;\r\n        end: number;\r\n    }\r\n\r\n    export type JsDocSyntaxKind =\r\n        | SyntaxKind.EndOfFileToken\r\n        | SyntaxKind.WhitespaceTrivia\r\n        | SyntaxKind.AtToken\r\n        | SyntaxKind.NewLineTrivia\r\n        | SyntaxKind.AsteriskToken\r\n        | SyntaxKind.OpenBraceToken\r\n        | SyntaxKind.CloseBraceToken\r\n        | SyntaxKind.LessThanToken\r\n        | SyntaxKind.OpenBracketToken\r\n        | SyntaxKind.CloseBracketToken\r\n        | SyntaxKind.EqualsToken\r\n        | SyntaxKind.CommaToken\r\n        | SyntaxKind.DotToken\r\n        | SyntaxKind.Identifier\r\n        | SyntaxKind.NoSubstitutionTemplateLiteral\r\n        | SyntaxKind.Unknown;\r\n\r\n    export type JsxTokenSyntaxKind =\r\n        | SyntaxKind.LessThanSlashToken\r\n        | SyntaxKind.EndOfFileToken\r\n        | SyntaxKind.ConflictMarkerTrivia\r\n        | SyntaxKind.JsxText\r\n        | SyntaxKind.JsxTextAllWhiteSpaces\r\n        | SyntaxKind.OpenBraceToken\r\n        | SyntaxKind.LessThanToken;\r\n\r\n    // token > SyntaxKind.Identifier => token is a keyword\r\n    // Also, If you add a new SyntaxKind be sure to keep the `Markers` section at the bottom in sync\r\n    export const enum SyntaxKind {\r\n        Unknown,\r\n        EndOfFileToken,\r\n        SingleLineCommentTrivia,\r\n        MultiLineCommentTrivia,\r\n        NewLineTrivia,\r\n        WhitespaceTrivia,\r\n        // We detect and preserve #! on the first line\r\n        ShebangTrivia,\r\n        // We detect and provide better error recovery when we encounter a git merge marker.  This\r\n        // allows us to edit files with git-conflict markers in them in a much more pleasant manner.\r\n        ConflictMarkerTrivia,\r\n        // Literals\r\n        NumericLiteral,\r\n        StringLiteral,\r\n        JsxText,\r\n        JsxTextAllWhiteSpaces,\r\n        RegularExpressionLiteral,\r\n        NoSubstitutionTemplateLiteral,\r\n        // Pseudo-literals\r\n        TemplateHead,\r\n        TemplateMiddle,\r\n        TemplateTail,\r\n        // Punctuation\r\n        OpenBraceToken,\r\n        CloseBraceToken,\r\n        OpenParenToken,\r\n        CloseParenToken,\r\n        OpenBracketToken,\r\n        CloseBracketToken,\r\n        DotToken,\r\n        DotDotDotToken,\r\n        SemicolonToken,\r\n        CommaToken,\r\n        LessThanToken,\r\n        LessThanSlashToken,\r\n        GreaterThanToken,\r\n        LessThanEqualsToken,\r\n        GreaterThanEqualsToken,\r\n        EqualsEqualsToken,\r\n        ExclamationEqualsToken,\r\n        EqualsEqualsEqualsToken,\r\n        ExclamationEqualsEqualsToken,\r\n        EqualsGreaterThanToken,\r\n        PlusToken,\r\n        MinusToken,\r\n        AsteriskToken,\r\n        AsteriskAsteriskToken,\r\n        SlashToken,\r\n        PercentToken,\r\n        PlusPlusToken,\r\n        MinusMinusToken,\r\n        LessThanLessThanToken,\r\n        GreaterThanGreaterThanToken,\r\n        GreaterThanGreaterThanGreaterThanToken,\r\n        AmpersandToken,\r\n        BarToken,\r\n        CaretToken,\r\n        ExclamationToken,\r\n        TildeToken,\r\n        AmpersandAmpersandToken,\r\n        BarBarToken,\r\n        QuestionToken,\r\n        ColonToken,\r\n        AtToken,\r\n        // Assignments\r\n        EqualsToken,\r\n        PlusEqualsToken,\r\n        MinusEqualsToken,\r\n        AsteriskEqualsToken,\r\n        AsteriskAsteriskEqualsToken,\r\n        SlashEqualsToken,\r\n        PercentEqualsToken,\r\n        LessThanLessThanEqualsToken,\r\n        GreaterThanGreaterThanEqualsToken,\r\n        GreaterThanGreaterThanGreaterThanEqualsToken,\r\n        AmpersandEqualsToken,\r\n        BarEqualsToken,\r\n        CaretEqualsToken,\r\n        // Identifiers\r\n        Identifier,\r\n        // Reserved words\r\n        BreakKeyword,\r\n        CaseKeyword,\r\n        CatchKeyword,\r\n        ClassKeyword,\r\n        ConstKeyword,\r\n        ContinueKeyword,\r\n        DebuggerKeyword,\r\n        DefaultKeyword,\r\n        DeleteKeyword,\r\n        DoKeyword,\r\n        ElseKeyword,\r\n        EnumKeyword,\r\n        ExportKeyword,\r\n        ExtendsKeyword,\r\n        FalseKeyword,\r\n        FinallyKeyword,\r\n        ForKeyword,\r\n        FunctionKeyword,\r\n        IfKeyword,\r\n        ImportKeyword,\r\n        InKeyword,\r\n        InstanceOfKeyword,\r\n        NewKeyword,\r\n        NullKeyword,\r\n        ReturnKeyword,\r\n        SuperKeyword,\r\n        SwitchKeyword,\r\n        ThisKeyword,\r\n        ThrowKeyword,\r\n        TrueKeyword,\r\n        TryKeyword,\r\n        TypeOfKeyword,\r\n        VarKeyword,\r\n        VoidKeyword,\r\n        WhileKeyword,\r\n        WithKeyword,\r\n        // Strict mode reserved words\r\n        ImplementsKeyword,\r\n        InterfaceKeyword,\r\n        LetKeyword,\r\n        PackageKeyword,\r\n        PrivateKeyword,\r\n        ProtectedKeyword,\r\n        PublicKeyword,\r\n        StaticKeyword,\r\n        YieldKeyword,\r\n        // Contextual keywords\r\n        AbstractKeyword,\r\n        AsKeyword,\r\n        AnyKeyword,\r\n        AsyncKeyword,\r\n        AwaitKeyword,\r\n        BooleanKeyword,\r\n        ConstructorKeyword,\r\n        DeclareKeyword,\r\n        GetKeyword,\r\n        InferKeyword,\r\n        IsKeyword,\r\n        KeyOfKeyword,\r\n        ModuleKeyword,\r\n        NamespaceKeyword,\r\n        NeverKeyword,\r\n        ReadonlyKeyword,\r\n        RequireKeyword,\r\n        NumberKeyword,\r\n        ObjectKeyword,\r\n        SetKeyword,\r\n        StringKeyword,\r\n        SymbolKeyword,\r\n        TypeKeyword,\r\n        UndefinedKeyword,\r\n        UniqueKeyword,\r\n        FromKeyword,\r\n        GlobalKeyword,\r\n        OfKeyword, // LastKeyword and LastToken and LastContextualKeyword\r\n\r\n        // Parse tree nodes\r\n\r\n        // Names\r\n        QualifiedName,\r\n        ComputedPropertyName,\r\n        // Signature elements\r\n        TypeParameter,\r\n        Parameter,\r\n        Decorator,\r\n        // TypeMember\r\n        PropertySignature,\r\n        PropertyDeclaration,\r\n        MethodSignature,\r\n        MethodDeclaration,\r\n        Constructor,\r\n        GetAccessor,\r\n        SetAccessor,\r\n        CallSignature,\r\n        ConstructSignature,\r\n        IndexSignature,\r\n        // Type\r\n        TypePredicate,\r\n        TypeReference,\r\n        FunctionType,\r\n        ConstructorType,\r\n        TypeQuery,\r\n        TypeLiteral,\r\n        ArrayType,\r\n        TupleType,\r\n        UnionType,\r\n        IntersectionType,\r\n        ConditionalType,\r\n        InferType,\r\n        ParenthesizedType,\r\n        ThisType,\r\n        TypeOperator,\r\n        IndexedAccessType,\r\n        MappedType,\r\n        LiteralType,\r\n        ImportType,\r\n        // Binding patterns\r\n        ObjectBindingPattern,\r\n        ArrayBindingPattern,\r\n        BindingElement,\r\n        // Expression\r\n        ArrayLiteralExpression,\r\n        ObjectLiteralExpression,\r\n        PropertyAccessExpression,\r\n        ElementAccessExpression,\r\n        CallExpression,\r\n        NewExpression,\r\n        TaggedTemplateExpression,\r\n        TypeAssertionExpression,\r\n        ParenthesizedExpression,\r\n        FunctionExpression,\r\n        ArrowFunction,\r\n        DeleteExpression,\r\n        TypeOfExpression,\r\n        VoidExpression,\r\n        AwaitExpression,\r\n        PrefixUnaryExpression,\r\n        PostfixUnaryExpression,\r\n        BinaryExpression,\r\n        ConditionalExpression,\r\n        TemplateExpression,\r\n        YieldExpression,\r\n        SpreadElement,\r\n        ClassExpression,\r\n        OmittedExpression,\r\n        ExpressionWithTypeArguments,\r\n        AsExpression,\r\n        NonNullExpression,\r\n        MetaProperty,\r\n\r\n        // Misc\r\n        TemplateSpan,\r\n        SemicolonClassElement,\r\n        // Element\r\n        Block,\r\n        VariableStatement,\r\n        EmptyStatement,\r\n        ExpressionStatement,\r\n        IfStatement,\r\n        DoStatement,\r\n        WhileStatement,\r\n        ForStatement,\r\n        ForInStatement,\r\n        ForOfStatement,\r\n        ContinueStatement,\r\n        BreakStatement,\r\n        ReturnStatement,\r\n        WithStatement,\r\n        SwitchStatement,\r\n        LabeledStatement,\r\n        ThrowStatement,\r\n        TryStatement,\r\n        DebuggerStatement,\r\n        VariableDeclaration,\r\n        VariableDeclarationList,\r\n        FunctionDeclaration,\r\n        ClassDeclaration,\r\n        InterfaceDeclaration,\r\n        TypeAliasDeclaration,\r\n        EnumDeclaration,\r\n        ModuleDeclaration,\r\n        ModuleBlock,\r\n        CaseBlock,\r\n        NamespaceExportDeclaration,\r\n        ImportEqualsDeclaration,\r\n        ImportDeclaration,\r\n        ImportClause,\r\n        NamespaceImport,\r\n        NamedImports,\r\n        ImportSpecifier,\r\n        ExportAssignment,\r\n        ExportDeclaration,\r\n        NamedExports,\r\n        ExportSpecifier,\r\n        MissingDeclaration,\r\n\r\n        // Module references\r\n        ExternalModuleReference,\r\n\r\n        // JSX\r\n        JsxElement,\r\n        JsxSelfClosingElement,\r\n        JsxOpeningElement,\r\n        JsxClosingElement,\r\n        JsxFragment,\r\n        JsxOpeningFragment,\r\n        JsxClosingFragment,\r\n        JsxAttribute,\r\n        JsxAttributes,\r\n        JsxSpreadAttribute,\r\n        JsxExpression,\r\n\r\n        // Clauses\r\n        CaseClause,\r\n        DefaultClause,\r\n        HeritageClause,\r\n        CatchClause,\r\n\r\n        // Property assignments\r\n        PropertyAssignment,\r\n        ShorthandPropertyAssignment,\r\n        SpreadAssignment,\r\n\r\n        // Enum\r\n        EnumMember,\r\n        // Top-level nodes\r\n        SourceFile,\r\n        Bundle,\r\n\r\n        // JSDoc nodes\r\n        JSDocTypeExpression,\r\n        // The * type\r\n        JSDocAllType,\r\n        // The ? type\r\n        JSDocUnknownType,\r\n        JSDocNullableType,\r\n        JSDocNonNullableType,\r\n        JSDocOptionalType,\r\n        JSDocFunctionType,\r\n        JSDocVariadicType,\r\n        JSDocComment,\r\n        JSDocTypeLiteral,\r\n        JSDocTag,\r\n        JSDocAugmentsTag,\r\n        JSDocClassTag,\r\n        JSDocParameterTag,\r\n        JSDocReturnTag,\r\n        JSDocTypeTag,\r\n        JSDocTemplateTag,\r\n        JSDocTypedefTag,\r\n        JSDocPropertyTag,\r\n\r\n        // Synthesized list\r\n        SyntaxList,\r\n\r\n        // Transformation nodes\r\n        NotEmittedStatement,\r\n        PartiallyEmittedExpression,\r\n        CommaListExpression,\r\n        MergeDeclarationMarker,\r\n        EndOfDeclarationMarker,\r\n\r\n        // Enum value count\r\n        Count,\r\n\r\n        // Markers\r\n        FirstAssignment = EqualsToken,\r\n        LastAssignment = CaretEqualsToken,\r\n        FirstCompoundAssignment = PlusEqualsToken,\r\n        LastCompoundAssignment = CaretEqualsToken,\r\n        FirstReservedWord = BreakKeyword,\r\n        LastReservedWord = WithKeyword,\r\n        FirstKeyword = BreakKeyword,\r\n        LastKeyword = OfKeyword,\r\n        FirstFutureReservedWord = ImplementsKeyword,\r\n        LastFutureReservedWord = YieldKeyword,\r\n        FirstTypeNode = TypePredicate,\r\n        LastTypeNode = ImportType,\r\n        FirstPunctuation = OpenBraceToken,\r\n        LastPunctuation = CaretEqualsToken,\r\n        FirstToken = Unknown,\r\n        LastToken = LastKeyword,\r\n        FirstTriviaToken = SingleLineCommentTrivia,\r\n        LastTriviaToken = ConflictMarkerTrivia,\r\n        FirstLiteralToken = NumericLiteral,\r\n        LastLiteralToken = NoSubstitutionTemplateLiteral,\r\n        FirstTemplateToken = NoSubstitutionTemplateLiteral,\r\n        LastTemplateToken = TemplateTail,\r\n        FirstBinaryOperator = LessThanToken,\r\n        LastBinaryOperator = CaretEqualsToken,\r\n        FirstNode = QualifiedName,\r\n        FirstJSDocNode = JSDocTypeExpression,\r\n        LastJSDocNode = JSDocPropertyTag,\r\n        FirstJSDocTagNode = JSDocTag,\r\n        LastJSDocTagNode = JSDocPropertyTag,\r\n        /* @internal */ FirstContextualKeyword = AbstractKeyword,\r\n        /* @internal */ LastContextualKeyword = OfKeyword,\r\n    }\r\n\r\n    export const enum NodeFlags {\r\n        None               = 0,\r\n        Let                = 1 << 0,  // Variable declaration\r\n        Const              = 1 << 1,  // Variable declaration\r\n        NestedNamespace    = 1 << 2,  // Namespace declaration\r\n        Synthesized        = 1 << 3,  // Node was synthesized during transformation\r\n        Namespace          = 1 << 4,  // Namespace declaration\r\n        ExportContext      = 1 << 5,  // Export context (initialized by binding)\r\n        ContainsThis       = 1 << 6,  // Interface contains references to \"this\"\r\n        HasImplicitReturn  = 1 << 7,  // If function implicitly returns on one of codepaths (initialized by binding)\r\n        HasExplicitReturn  = 1 << 8,  // If function has explicit reachable return on one of codepaths (initialized by binding)\r\n        GlobalAugmentation = 1 << 9,  // Set if module declaration is an augmentation for the global scope\r\n        HasAsyncFunctions  = 1 << 10, // If the file has async functions (initialized by binding)\r\n        DisallowInContext  = 1 << 11, // If node was parsed in a context where 'in-expressions' are not allowed\r\n        YieldContext       = 1 << 12, // If node was parsed in the 'yield' context created when parsing a generator\r\n        DecoratorContext   = 1 << 13, // If node was parsed as part of a decorator\r\n        AwaitContext       = 1 << 14, // If node was parsed in the 'await' context created when parsing an async function\r\n        ThisNodeHasError   = 1 << 15, // If the parser encountered an error when parsing the code that created this node\r\n        JavaScriptFile     = 1 << 16, // If node was parsed in a JavaScript\r\n        ThisNodeOrAnySubNodesHasError = 1 << 17, // If this node or any of its children had an error\r\n        HasAggregatedChildData = 1 << 18, // If we've computed data from children and cached it in this node\r\n\r\n        // These flags will be set when the parser encounters a dynamic import expression or 'import.meta' to avoid\r\n        // walking the tree if the flags are not set. However, these flags are just a approximation\r\n        // (hence why it's named \"PossiblyContainsDynamicImport\") because once set, the flags never get cleared.\r\n        // During editing, if a dynamic import is removed, incremental parsing will *NOT* clear this flag.\r\n        // This means that the tree will always be traversed during module resolution, or when looking for external module indicators.\r\n        // However, the removal operation should not occur often and in the case of the\r\n        // removal, it is likely that users will add the import anyway.\r\n        // The advantage of this approach is its simplicity. For the case of batch compilation,\r\n        // we guarantee that users won't have to pay the price of walking the tree if a dynamic import isn't used.\r\n        /* @internal */ PossiblyContainsDynamicImport = 1 << 19,\r\n        /* @internal */ PossiblyContainsImportMeta    = 1 << 20,\r\n\r\n        JSDoc                                         = 1 << 21, // If node was parsed inside jsdoc\r\n        /* @internal */ Ambient                       = 1 << 22, // If node was inside an ambient context -- a declaration file, or inside something with the `declare` modifier.\r\n        /* @internal */ InWithStatement               = 1 << 23, // If any ancestor of node was the `statement` of a WithStatement (not the `expression`)\r\n\r\n        BlockScoped = Let | Const,\r\n\r\n        ReachabilityCheckFlags = HasImplicitReturn | HasExplicitReturn,\r\n        ReachabilityAndEmitFlags = ReachabilityCheckFlags | HasAsyncFunctions,\r\n\r\n        // Parsing context flags\r\n        ContextFlags = DisallowInContext | YieldContext | DecoratorContext | AwaitContext | JavaScriptFile | InWithStatement | Ambient,\r\n\r\n        // Exclude these flags when parsing a Type\r\n        TypeExcludesFlags = YieldContext | AwaitContext,\r\n\r\n        // Represents all flags that are potentially set once and\r\n        // never cleared on SourceFiles which get re-used in between incremental parses.\r\n        // See the comment above on `PossiblyContainsDynamicImport` and `PossiblyContainsImportMeta`.\r\n        /* @internal */ PermanentlySetIncrementalFlags = PossiblyContainsDynamicImport | PossiblyContainsImportMeta,\r\n    }\r\n\r\n    export const enum ModifierFlags {\r\n        None =               0,\r\n        Export =             1 << 0,  // Declarations\r\n        Ambient =            1 << 1,  // Declarations\r\n        Public =             1 << 2,  // Property/Method\r\n        Private =            1 << 3,  // Property/Method\r\n        Protected =          1 << 4,  // Property/Method\r\n        Static =             1 << 5,  // Property/Method\r\n        Readonly =           1 << 6,  // Property/Method\r\n        Abstract =           1 << 7,  // Class/Method/ConstructSignature\r\n        Async =              1 << 8,  // Property/Method/Function\r\n        Default =            1 << 9,  // Function/Class (export default declaration)\r\n        Const =              1 << 11, // Variable declaration\r\n        HasComputedFlags =   1 << 29, // Modifier flags have been computed\r\n\r\n        AccessibilityModifier = Public | Private | Protected,\r\n        // Accessibility modifiers and 'readonly' can be attached to a parameter in a constructor to make it a property.\r\n        ParameterPropertyModifier = AccessibilityModifier | Readonly,\r\n        NonPublicAccessibilityModifier = Private | Protected,\r\n\r\n        TypeScriptModifier = Ambient | Public | Private | Protected | Readonly | Abstract | Const,\r\n        ExportDefault = Export | Default,\r\n        All = Export | Ambient | Public | Private | Protected | Static | Readonly | Abstract | Async | Default | Const\r\n    }\r\n\r\n    export const enum JsxFlags {\r\n        None = 0,\r\n        /** An element from a named property of the JSX.IntrinsicElements interface */\r\n        IntrinsicNamedElement = 1 << 0,\r\n        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */\r\n        IntrinsicIndexedElement = 1 << 1,\r\n\r\n        IntrinsicElement = IntrinsicNamedElement | IntrinsicIndexedElement,\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum RelationComparisonResult {\r\n        Succeeded = 1, // Should be truthy\r\n        Failed = 2,\r\n        FailedAndReported = 3\r\n    }\r\n\r\n    export interface Node extends TextRange {\r\n        kind: SyntaxKind;\r\n        flags: NodeFlags;\r\n        /* @internal */ modifierFlagsCache?: ModifierFlags;\r\n        /* @internal */ transformFlags?: TransformFlags;\r\n        decorators?: NodeArray<Decorator>;                    // Array of decorators (in document order)\r\n        modifiers?: ModifiersArray;                           // Array of modifiers\r\n        /* @internal */ id?: number;                          // Unique id (used to look up NodeLinks)\r\n        parent?: Node;                                        // Parent node (initialized by binding)\r\n        /* @internal */ original?: Node;                      // The original node if this is an updated node.\r\n        /* @internal */ symbol?: Symbol;                      // Symbol declared by node (initialized by binding)\r\n        /* @internal */ locals?: SymbolTable;                 // Locals associated with node (initialized by binding)\r\n        /* @internal */ nextContainer?: Node;                 // Next container in declaration order (initialized by binding)\r\n        /* @internal */ localSymbol?: Symbol;                 // Local symbol declared by node (initialized by binding only for exported nodes)\r\n        /* @internal */ flowNode?: FlowNode;                  // Associated FlowNode (initialized by binding)\r\n        /* @internal */ emitNode?: EmitNode;                  // Associated EmitNode (initialized by transforms)\r\n        /* @internal */ contextualType?: Type;                // Used to temporarily assign a contextual type during overload resolution\r\n        /* @internal */ contextualMapper?: TypeMapper;        // Mapper for contextual type\r\n    }\r\n\r\n    export interface JSDocContainer {\r\n        /* @internal */ jsDoc?: JSDoc[];                      // JSDoc that directly precedes this node\r\n        /* @internal */ jsDocCache?: ReadonlyArray<JSDocTag>; // Cache for getJSDocTags\r\n    }\r\n\r\n    export type HasJSDoc =\r\n        | ParameterDeclaration\r\n        | CallSignatureDeclaration\r\n        | ConstructSignatureDeclaration\r\n        | MethodSignature\r\n        | PropertySignature\r\n        | ArrowFunction\r\n        | ParenthesizedExpression\r\n        | SpreadAssignment\r\n        | ShorthandPropertyAssignment\r\n        | PropertyAssignment\r\n        | FunctionExpression\r\n        | LabeledStatement\r\n        | ExpressionStatement\r\n        | VariableStatement\r\n        | FunctionDeclaration\r\n        | ConstructorDeclaration\r\n        | MethodDeclaration\r\n        | PropertyDeclaration\r\n        | AccessorDeclaration\r\n        | ClassLikeDeclaration\r\n        | InterfaceDeclaration\r\n        | TypeAliasDeclaration\r\n        | EnumMember\r\n        | EnumDeclaration\r\n        | ModuleDeclaration\r\n        | ImportEqualsDeclaration\r\n        | IndexSignatureDeclaration\r\n        | FunctionTypeNode\r\n        | ConstructorTypeNode\r\n        | JSDocFunctionType\r\n        | EndOfFileToken;\r\n\r\n    export type HasType =\r\n        | SignatureDeclaration\r\n        | VariableDeclaration\r\n        | ParameterDeclaration\r\n        | PropertySignature\r\n        | PropertyDeclaration\r\n        | TypePredicateNode\r\n        | ParenthesizedTypeNode\r\n        | TypeOperatorNode\r\n        | MappedTypeNode\r\n        | AssertionExpression\r\n        | TypeAliasDeclaration\r\n        | JSDocTypeExpression\r\n        | JSDocNonNullableType\r\n        | JSDocNullableType\r\n        | JSDocOptionalType\r\n        | JSDocVariadicType;\r\n\r\n    export type HasInitializer =\r\n        | HasExpressionInitializer\r\n        | ForStatement\r\n        | ForInStatement\r\n        | ForOfStatement\r\n        | JsxAttribute;\r\n\r\n    export type HasExpressionInitializer =\r\n        | VariableDeclaration\r\n        | ParameterDeclaration\r\n        | BindingElement\r\n        | PropertySignature\r\n        | PropertyDeclaration\r\n        | PropertyAssignment\r\n        | EnumMember;\r\n\r\n    /* @internal */\r\n    export type MutableNodeArray<T extends Node> = NodeArray<T> & T[];\r\n\r\n    export interface NodeArray<T extends Node> extends ReadonlyArray<T>, TextRange {\r\n        hasTrailingComma?: boolean;\r\n        /* @internal */ transformFlags?: TransformFlags;\r\n    }\r\n\r\n    export interface Token<TKind extends SyntaxKind> extends Node {\r\n        kind: TKind;\r\n    }\r\n\r\n    export type DotDotDotToken = Token<SyntaxKind.DotDotDotToken>;\r\n    export type QuestionToken = Token<SyntaxKind.QuestionToken>;\r\n    export type ExclamationToken = Token<SyntaxKind.ExclamationToken>;\r\n    export type ColonToken = Token<SyntaxKind.ColonToken>;\r\n    export type EqualsToken = Token<SyntaxKind.EqualsToken>;\r\n    export type AsteriskToken = Token<SyntaxKind.AsteriskToken>;\r\n    export type EqualsGreaterThanToken = Token<SyntaxKind.EqualsGreaterThanToken>;\r\n    export type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;\r\n    export type AtToken = Token<SyntaxKind.AtToken>;\r\n    export type ReadonlyToken = Token<SyntaxKind.ReadonlyKeyword>;\r\n    export type AwaitKeywordToken = Token<SyntaxKind.AwaitKeyword>;\r\n    export type PlusToken = Token<SyntaxKind.PlusToken>;\r\n    export type MinusToken = Token<SyntaxKind.MinusToken>;\r\n\r\n    export type Modifier\r\n        = Token<SyntaxKind.AbstractKeyword>\r\n        | Token<SyntaxKind.AsyncKeyword>\r\n        | Token<SyntaxKind.ConstKeyword>\r\n        | Token<SyntaxKind.DeclareKeyword>\r\n        | Token<SyntaxKind.DefaultKeyword>\r\n        | Token<SyntaxKind.ExportKeyword>\r\n        | Token<SyntaxKind.PublicKeyword>\r\n        | Token<SyntaxKind.PrivateKeyword>\r\n        | Token<SyntaxKind.ProtectedKeyword>\r\n        | Token<SyntaxKind.ReadonlyKeyword>\r\n        | Token<SyntaxKind.StaticKeyword>\r\n        ;\r\n\r\n    export type ModifiersArray = NodeArray<Modifier>;\r\n\r\n    /*@internal*/\r\n    export const enum GeneratedIdentifierFlags {\r\n        // Kinds\r\n        None = 0,                           // Not automatically generated.\r\n        Auto = 1,                           // Automatically generated identifier.\r\n        Loop = 2,                           // Automatically generated identifier with a preference for '_i'.\r\n        Unique = 3,                         // Unique name based on the 'text' property.\r\n        Node = 4,                           // Unique name based on the node in the 'original' property.\r\n        KindMask = 7,                       // Mask to extract the kind of identifier from its flags.\r\n\r\n        // Flags\r\n        SkipNameGenerationScope = 1 << 3,   // Should skip a name generation scope when generating the name for this identifier\r\n        ReservedInNestedScopes = 1 << 4,    // Reserve the generated name in nested scopes\r\n        Optimistic = 1 << 5,                // First instance won't use '_#' if there's no conflict\r\n        FileLevel = 1 << 6,                 // Use only the file identifiers list and not generated names to search for conflicts\r\n    }\r\n\r\n    export interface Identifier extends PrimaryExpression, Declaration {\r\n        kind: SyntaxKind.Identifier;\r\n        /**\r\n         * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)\r\n         * Text of identifier, but if the identifier begins with two underscores, this will begin with three.\r\n         */\r\n        escapedText: __String;\r\n        originalKeywordKind?: SyntaxKind;                         // Original syntaxKind which get set so that we can report an error later\r\n        /*@internal*/ autoGenerateFlags?: GeneratedIdentifierFlags; // Specifies whether to auto-generate the text for an identifier.\r\n        /*@internal*/ autoGenerateId?: number;                    // Ensures unique generated identifiers get unique names, but clones get the same name.\r\n        isInJSDocNamespace?: boolean;                             // if the node is a member in a JSDoc namespace\r\n        /*@internal*/ typeArguments?: NodeArray<TypeNode | TypeParameterDeclaration>; // Only defined on synthesized nodes. Though not syntactically valid, used in emitting diagnostics, quickinfo, and signature help.\r\n        /*@internal*/ jsdocDotPos?: number;                       // Identifier occurs in JSDoc-style generic: Id.<T>\r\n    }\r\n\r\n    // Transient identifier node (marked by id === -1)\r\n    export interface TransientIdentifier extends Identifier {\r\n        resolvedSymbol: Symbol;\r\n    }\r\n\r\n    /*@internal*/\r\n    export interface GeneratedIdentifier extends Identifier {\r\n        autoGenerateFlags: GeneratedIdentifierFlags;\r\n    }\r\n\r\n    export interface QualifiedName extends Node {\r\n        kind: SyntaxKind.QualifiedName;\r\n        left: EntityName;\r\n        right: Identifier;\r\n        /*@internal*/ jsdocDotPos?: number;                      // QualifiedName occurs in JSDoc-style generic: Id1.Id2.<T>\r\n    }\r\n\r\n    export type EntityName = Identifier | QualifiedName;\r\n\r\n    export type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName;\r\n\r\n    export type DeclarationName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | BindingPattern;\r\n\r\n    export interface Declaration extends Node {\r\n        _declarationBrand: any;\r\n    }\r\n\r\n    export interface NamedDeclaration extends Declaration {\r\n        name?: DeclarationName;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface DynamicNamedDeclaration extends NamedDeclaration {\r\n        name: ComputedPropertyName;\r\n    }\r\n\r\n    /* @internal */\r\n    // A declaration that supports late-binding (used in checker)\r\n    export interface LateBoundDeclaration extends DynamicNamedDeclaration {\r\n        name: LateBoundName;\r\n    }\r\n\r\n    export interface DeclarationStatement extends NamedDeclaration, Statement {\r\n        name?: Identifier | StringLiteral | NumericLiteral;\r\n    }\r\n\r\n    export interface ComputedPropertyName extends Node {\r\n        kind: SyntaxKind.ComputedPropertyName;\r\n        expression: Expression;\r\n    }\r\n\r\n    /* @internal */\r\n    // A name that supports late-binding (used in checker)\r\n    export interface LateBoundName extends ComputedPropertyName {\r\n        expression: EntityNameExpression;\r\n    }\r\n\r\n    export interface Decorator extends Node {\r\n        kind: SyntaxKind.Decorator;\r\n        parent?: NamedDeclaration;\r\n        expression: LeftHandSideExpression;\r\n    }\r\n\r\n    export interface TypeParameterDeclaration extends NamedDeclaration {\r\n        kind: SyntaxKind.TypeParameter;\r\n        parent?: DeclarationWithTypeParameters | InferTypeNode;\r\n        name: Identifier;\r\n        constraint?: TypeNode;\r\n        default?: TypeNode;\r\n\r\n        // For error recovery purposes.\r\n        expression?: Expression;\r\n    }\r\n\r\n    export interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {\r\n        kind: SignatureDeclaration[\"kind\"];\r\n        name?: PropertyName;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        parameters: NodeArray<ParameterDeclaration>;\r\n        type: TypeNode | undefined;\r\n        /* @internal */ typeArguments?: NodeArray<TypeNode>; // Used for quick info, replaces typeParameters for instantiated signatures\r\n    }\r\n\r\n    export type SignatureDeclaration =\r\n        | CallSignatureDeclaration\r\n        | ConstructSignatureDeclaration\r\n        | MethodSignature\r\n        | IndexSignatureDeclaration\r\n        | FunctionTypeNode\r\n        | ConstructorTypeNode\r\n        | JSDocFunctionType\r\n        | FunctionDeclaration\r\n        | MethodDeclaration\r\n        | ConstructorDeclaration\r\n        | AccessorDeclaration\r\n        | FunctionExpression\r\n        | ArrowFunction;\r\n\r\n    export interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\r\n        kind: SyntaxKind.CallSignature;\r\n    }\r\n\r\n    export interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\r\n        kind: SyntaxKind.ConstructSignature;\r\n    }\r\n\r\n    export type BindingName = Identifier | BindingPattern;\r\n\r\n    export interface VariableDeclaration extends NamedDeclaration {\r\n        kind: SyntaxKind.VariableDeclaration;\r\n        parent?: VariableDeclarationList | CatchClause;\r\n        name: BindingName;                    // Declared variable name\r\n        exclamationToken?: ExclamationToken;  // Optional definite assignment assertion\r\n        type?: TypeNode;                      // Optional type annotation\r\n        initializer?: Expression;             // Optional initializer\r\n    }\r\n\r\n    export interface VariableDeclarationList extends Node {\r\n        kind: SyntaxKind.VariableDeclarationList;\r\n        parent?: VariableStatement | ForStatement | ForOfStatement | ForInStatement;\r\n        declarations: NodeArray<VariableDeclaration>;\r\n    }\r\n\r\n    export interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {\r\n        kind: SyntaxKind.Parameter;\r\n        parent?: SignatureDeclaration;\r\n        dotDotDotToken?: DotDotDotToken;    // Present on rest parameter\r\n        name: BindingName;                  // Declared parameter name.\r\n        questionToken?: QuestionToken;      // Present on optional parameter\r\n        type?: TypeNode;                    // Optional type annotation\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface BindingElement extends NamedDeclaration {\r\n        kind: SyntaxKind.BindingElement;\r\n        parent?: BindingPattern;\r\n        propertyName?: PropertyName;        // Binding property name (in object binding pattern)\r\n        dotDotDotToken?: DotDotDotToken;    // Present on rest element (in object binding pattern)\r\n        name: BindingName;                  // Declared binding element name\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    /*@internal*/\r\n    export type BindingElementGrandparent = BindingElement[\"parent\"][\"parent\"];\r\n\r\n    export interface PropertySignature extends TypeElement, JSDocContainer {\r\n        kind: SyntaxKind.PropertySignature;\r\n        name: PropertyName;                 // Declared property name\r\n        questionToken?: QuestionToken;      // Present on optional property\r\n        type?: TypeNode;                    // Optional type annotation\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface PropertyDeclaration extends ClassElement, JSDocContainer {\r\n        kind: SyntaxKind.PropertyDeclaration;\r\n        parent: ClassLikeDeclaration;\r\n        name: PropertyName;\r\n        questionToken?: QuestionToken;      // Present for use with reporting a grammar error\r\n        exclamationToken?: ExclamationToken;\r\n        type?: TypeNode;\r\n        initializer?: Expression;           // Optional initializer\r\n    }\r\n\r\n    export interface ObjectLiteralElement extends NamedDeclaration {\r\n        _objectLiteralBrandBrand: any;\r\n        name?: PropertyName;\r\n    }\r\n\r\n    export type ObjectLiteralElementLike\r\n        = PropertyAssignment\r\n        | ShorthandPropertyAssignment\r\n        | SpreadAssignment\r\n        | MethodDeclaration\r\n        | AccessorDeclaration\r\n        ;\r\n\r\n    export interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {\r\n        parent: ObjectLiteralExpression;\r\n        kind: SyntaxKind.PropertyAssignment;\r\n        name: PropertyName;\r\n        questionToken?: QuestionToken;\r\n        initializer: Expression;\r\n    }\r\n\r\n    export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {\r\n        parent: ObjectLiteralExpression;\r\n        kind: SyntaxKind.ShorthandPropertyAssignment;\r\n        name: Identifier;\r\n        questionToken?: QuestionToken;\r\n        // used when ObjectLiteralExpression is used in ObjectAssignmentPattern\r\n        // it is grammar error to appear in actual object initializer\r\n        equalsToken?: Token<SyntaxKind.EqualsToken>;\r\n        objectAssignmentInitializer?: Expression;\r\n    }\r\n\r\n    export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {\r\n        parent: ObjectLiteralExpression;\r\n        kind: SyntaxKind.SpreadAssignment;\r\n        expression: Expression;\r\n    }\r\n\r\n    export type VariableLikeDeclaration =\r\n        | VariableDeclaration\r\n        | ParameterDeclaration\r\n        | BindingElement\r\n        | PropertyDeclaration\r\n        | PropertyAssignment\r\n        | PropertySignature\r\n        | JsxAttribute\r\n        | ShorthandPropertyAssignment\r\n        | EnumMember\r\n        | JSDocPropertyTag\r\n        | JSDocParameterTag;\r\n\r\n    export interface PropertyLikeDeclaration extends NamedDeclaration {\r\n        name: PropertyName;\r\n    }\r\n\r\n    export interface ObjectBindingPattern extends Node {\r\n        kind: SyntaxKind.ObjectBindingPattern;\r\n        parent?: VariableDeclaration | ParameterDeclaration | BindingElement;\r\n        elements: NodeArray<BindingElement>;\r\n    }\r\n\r\n    export interface ArrayBindingPattern extends Node {\r\n        kind: SyntaxKind.ArrayBindingPattern;\r\n        parent?: VariableDeclaration | ParameterDeclaration | BindingElement;\r\n        elements: NodeArray<ArrayBindingElement>;\r\n    }\r\n\r\n    export type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;\r\n\r\n    export type ArrayBindingElement = BindingElement | OmittedExpression;\r\n\r\n    /**\r\n     * Several node kinds share function-like features such as a signature,\r\n     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.\r\n     * Examples:\r\n     * - FunctionDeclaration\r\n     * - MethodDeclaration\r\n     * - AccessorDeclaration\r\n     */\r\n    export interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {\r\n        _functionLikeDeclarationBrand: any;\r\n\r\n        asteriskToken?: AsteriskToken;\r\n        questionToken?: QuestionToken;\r\n        body?: Block | Expression;\r\n    }\r\n\r\n    export type FunctionLikeDeclaration =\r\n        | FunctionDeclaration\r\n        | MethodDeclaration\r\n        | GetAccessorDeclaration\r\n        | SetAccessorDeclaration\r\n        | ConstructorDeclaration\r\n        | FunctionExpression\r\n        | ArrowFunction;\r\n    /** @deprecated Use SignatureDeclaration */\r\n    export type FunctionLike = SignatureDeclaration;\r\n\r\n    export interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement {\r\n        kind: SyntaxKind.FunctionDeclaration;\r\n        name?: Identifier;\r\n        body?: FunctionBody;\r\n    }\r\n\r\n    export interface MethodSignature extends SignatureDeclarationBase, TypeElement {\r\n        kind: SyntaxKind.MethodSignature;\r\n        parent?: ObjectTypeDeclaration;\r\n        name: PropertyName;\r\n    }\r\n\r\n    // Note that a MethodDeclaration is considered both a ClassElement and an ObjectLiteralElement.\r\n    // Both the grammars for ClassDeclaration and ObjectLiteralExpression allow for MethodDeclarations\r\n    // as child elements, and so a MethodDeclaration satisfies both interfaces.  This avoids the\r\n    // alternative where we would need separate kinds/types for ClassMethodDeclaration and\r\n    // ObjectLiteralMethodDeclaration, which would look identical.\r\n    //\r\n    // Because of this, it may be necessary to determine what sort of MethodDeclaration you have\r\n    // at later stages of the compiler pipeline.  In that case, you can either check the parent kind\r\n    // of the method, or use helpers like isObjectLiteralMethodDeclaration\r\n    export interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\r\n        kind: SyntaxKind.MethodDeclaration;\r\n        parent?: ClassLikeDeclaration | ObjectLiteralExpression;\r\n        name: PropertyName;\r\n        body?: FunctionBody;\r\n    }\r\n\r\n    export interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer {\r\n        kind: SyntaxKind.Constructor;\r\n        parent?: ClassLikeDeclaration;\r\n        body?: FunctionBody;\r\n        /* @internal */ returnFlowNode?: FlowNode;\r\n    }\r\n\r\n    /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */\r\n    export interface SemicolonClassElement extends ClassElement {\r\n        kind: SyntaxKind.SemicolonClassElement;\r\n        parent?: ClassLikeDeclaration;\r\n    }\r\n\r\n    // See the comment on MethodDeclaration for the intuition behind GetAccessorDeclaration being a\r\n    // ClassElement and an ObjectLiteralElement.\r\n    export interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\r\n        kind: SyntaxKind.GetAccessor;\r\n        parent?: ClassLikeDeclaration | ObjectLiteralExpression;\r\n        name: PropertyName;\r\n        body?: FunctionBody;\r\n    }\r\n\r\n    // See the comment on MethodDeclaration for the intuition behind SetAccessorDeclaration being a\r\n    // ClassElement and an ObjectLiteralElement.\r\n    export interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\r\n        kind: SyntaxKind.SetAccessor;\r\n        parent?: ClassLikeDeclaration | ObjectLiteralExpression;\r\n        name: PropertyName;\r\n        body?: FunctionBody;\r\n    }\r\n\r\n    export type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;\r\n\r\n    export interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement {\r\n        kind: SyntaxKind.IndexSignature;\r\n        parent?: ObjectTypeDeclaration;\r\n    }\r\n\r\n    export interface TypeNode extends Node {\r\n        _typeNodeBrand: any;\r\n    }\r\n\r\n    export interface KeywordTypeNode extends TypeNode {\r\n        kind: SyntaxKind.AnyKeyword\r\n            | SyntaxKind.NumberKeyword\r\n            | SyntaxKind.ObjectKeyword\r\n            | SyntaxKind.BooleanKeyword\r\n            | SyntaxKind.StringKeyword\r\n            | SyntaxKind.SymbolKeyword\r\n            | SyntaxKind.ThisKeyword\r\n            | SyntaxKind.VoidKeyword\r\n            | SyntaxKind.UndefinedKeyword\r\n            | SyntaxKind.NullKeyword\r\n            | SyntaxKind.NeverKeyword;\r\n    }\r\n\r\n    export interface ImportTypeNode extends NodeWithTypeArguments {\r\n        kind: SyntaxKind.ImportType;\r\n        isTypeOf?: boolean;\r\n        argument: TypeNode;\r\n        qualifier?: EntityName;\r\n    }\r\n\r\n    /* @internal */\r\n    export type LiteralImportTypeNode = ImportTypeNode & { argument: LiteralTypeNode & { literal: StringLiteral } };\r\n\r\n    export interface ThisTypeNode extends TypeNode {\r\n        kind: SyntaxKind.ThisType;\r\n    }\r\n\r\n    export type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;\r\n\r\n    export interface FunctionTypeNode extends TypeNode, SignatureDeclarationBase {\r\n        kind: SyntaxKind.FunctionType;\r\n    }\r\n\r\n    export interface ConstructorTypeNode extends TypeNode, SignatureDeclarationBase {\r\n        kind: SyntaxKind.ConstructorType;\r\n    }\r\n\r\n    export interface NodeWithTypeArguments extends TypeNode {\r\n        typeArguments?: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;\r\n\r\n    export interface TypeReferenceNode extends NodeWithTypeArguments {\r\n        kind: SyntaxKind.TypeReference;\r\n        typeName: EntityName;\r\n    }\r\n\r\n    export interface TypePredicateNode extends TypeNode {\r\n        kind: SyntaxKind.TypePredicate;\r\n        parent?: SignatureDeclaration;\r\n        parameterName: Identifier | ThisTypeNode;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface TypeQueryNode extends TypeNode {\r\n        kind: SyntaxKind.TypeQuery;\r\n        exprName: EntityName;\r\n    }\r\n\r\n    // A TypeLiteral is the declaration node for an anonymous symbol.\r\n    export interface TypeLiteralNode extends TypeNode, Declaration {\r\n        kind: SyntaxKind.TypeLiteral;\r\n        members: NodeArray<TypeElement>;\r\n    }\r\n\r\n    export interface ArrayTypeNode extends TypeNode {\r\n        kind: SyntaxKind.ArrayType;\r\n        elementType: TypeNode;\r\n    }\r\n\r\n    export interface TupleTypeNode extends TypeNode {\r\n        kind: SyntaxKind.TupleType;\r\n        elementTypes: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;\r\n\r\n    export interface UnionTypeNode extends TypeNode {\r\n        kind: SyntaxKind.UnionType;\r\n        types: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export interface IntersectionTypeNode extends TypeNode {\r\n        kind: SyntaxKind.IntersectionType;\r\n        types: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export interface ConditionalTypeNode extends TypeNode {\r\n        kind: SyntaxKind.ConditionalType;\r\n        checkType: TypeNode;\r\n        extendsType: TypeNode;\r\n        trueType: TypeNode;\r\n        falseType: TypeNode;\r\n    }\r\n\r\n    export interface InferTypeNode extends TypeNode {\r\n        kind: SyntaxKind.InferType;\r\n        typeParameter: TypeParameterDeclaration;\r\n    }\r\n\r\n    export interface ParenthesizedTypeNode extends TypeNode {\r\n        kind: SyntaxKind.ParenthesizedType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface TypeOperatorNode extends TypeNode {\r\n        kind: SyntaxKind.TypeOperator;\r\n        operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword;\r\n        type: TypeNode;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface UniqueTypeOperatorNode extends TypeOperatorNode {\r\n        operator: SyntaxKind.UniqueKeyword;\r\n    }\r\n\r\n    export interface IndexedAccessTypeNode extends TypeNode {\r\n        kind: SyntaxKind.IndexedAccessType;\r\n        objectType: TypeNode;\r\n        indexType: TypeNode;\r\n    }\r\n\r\n    export interface MappedTypeNode extends TypeNode, Declaration {\r\n        kind: SyntaxKind.MappedType;\r\n        readonlyToken?: ReadonlyToken | PlusToken | MinusToken;\r\n        typeParameter: TypeParameterDeclaration;\r\n        questionToken?: QuestionToken | PlusToken | MinusToken;\r\n        type?: TypeNode;\r\n    }\r\n\r\n    export interface LiteralTypeNode extends TypeNode {\r\n        kind: SyntaxKind.LiteralType;\r\n        literal: BooleanLiteral | LiteralExpression | PrefixUnaryExpression;\r\n    }\r\n\r\n    export interface StringLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.StringLiteral;\r\n        /* @internal */ textSourceNode?: Identifier | StringLiteralLike | NumericLiteral; // Allows a StringLiteral to get its text from another node (used by transforms).\r\n        /** Note: this is only set when synthesizing a node, not during parsing. */\r\n        /* @internal */ singleQuote?: boolean;\r\n    }\r\n\r\n    export type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;\r\n\r\n    // Note: 'brands' in our syntax nodes serve to give us a small amount of nominal typing.\r\n    // Consider 'Expression'.  Without the brand, 'Expression' is actually no different\r\n    // (structurally) than 'Node'.  Because of this you can pass any Node to a function that\r\n    // takes an Expression without any error.  By using the 'brands' we ensure that the type\r\n    // checker actually thinks you have something of the right type.  Note: the brands are\r\n    // never actually given values.  At runtime they have zero cost.\r\n\r\n    export interface Expression extends Node {\r\n        _expressionBrand: any;\r\n    }\r\n\r\n    export interface OmittedExpression extends Expression {\r\n        kind: SyntaxKind.OmittedExpression;\r\n    }\r\n\r\n    // Represents an expression that is elided as part of a transformation to emit comments on a\r\n    // not-emitted node. The 'expression' property of a PartiallyEmittedExpression should be emitted.\r\n    export interface PartiallyEmittedExpression extends LeftHandSideExpression {\r\n        kind: SyntaxKind.PartiallyEmittedExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface UnaryExpression extends Expression {\r\n        _unaryExpressionBrand: any;\r\n    }\r\n\r\n    /** Deprecated, please use UpdateExpression */\r\n    export type IncrementExpression = UpdateExpression;\r\n    export interface UpdateExpression extends UnaryExpression {\r\n        _updateExpressionBrand: any;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-UpdateExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-UnaryExpression\r\n    export type PrefixUnaryOperator\r\n        = SyntaxKind.PlusPlusToken\r\n        | SyntaxKind.MinusMinusToken\r\n        | SyntaxKind.PlusToken\r\n        | SyntaxKind.MinusToken\r\n        | SyntaxKind.TildeToken\r\n        | SyntaxKind.ExclamationToken;\r\n\r\n    export interface PrefixUnaryExpression extends UpdateExpression {\r\n        kind: SyntaxKind.PrefixUnaryExpression;\r\n        operator: PrefixUnaryOperator;\r\n        operand: UnaryExpression;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-UpdateExpression\r\n    export type PostfixUnaryOperator\r\n        = SyntaxKind.PlusPlusToken\r\n        | SyntaxKind.MinusMinusToken\r\n        ;\r\n\r\n    export interface PostfixUnaryExpression extends UpdateExpression {\r\n        kind: SyntaxKind.PostfixUnaryExpression;\r\n        operand: LeftHandSideExpression;\r\n        operator: PostfixUnaryOperator;\r\n    }\r\n\r\n    export interface LeftHandSideExpression extends UpdateExpression {\r\n        _leftHandSideExpressionBrand: any;\r\n    }\r\n\r\n    export interface MemberExpression extends LeftHandSideExpression {\r\n        _memberExpressionBrand: any;\r\n    }\r\n\r\n    export interface PrimaryExpression extends MemberExpression {\r\n        _primaryExpressionBrand: any;\r\n    }\r\n\r\n    export interface NullLiteral extends PrimaryExpression, TypeNode {\r\n        kind: SyntaxKind.NullKeyword;\r\n    }\r\n\r\n    export interface BooleanLiteral extends PrimaryExpression, TypeNode {\r\n        kind: SyntaxKind.TrueKeyword | SyntaxKind.FalseKeyword;\r\n    }\r\n\r\n    export interface ThisExpression extends PrimaryExpression, KeywordTypeNode {\r\n        kind: SyntaxKind.ThisKeyword;\r\n    }\r\n\r\n    export interface SuperExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.SuperKeyword;\r\n    }\r\n\r\n    export interface ImportExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.ImportKeyword;\r\n    }\r\n\r\n    export interface DeleteExpression extends UnaryExpression {\r\n        kind: SyntaxKind.DeleteExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface TypeOfExpression extends UnaryExpression {\r\n        kind: SyntaxKind.TypeOfExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface VoidExpression extends UnaryExpression {\r\n        kind: SyntaxKind.VoidExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface AwaitExpression extends UnaryExpression {\r\n        kind: SyntaxKind.AwaitExpression;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export interface YieldExpression extends Expression {\r\n        kind: SyntaxKind.YieldExpression;\r\n        asteriskToken?: AsteriskToken;\r\n        expression?: Expression;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-ExponentiationExpression\r\n    export type ExponentiationOperator\r\n        = SyntaxKind.AsteriskAsteriskToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-MultiplicativeOperator\r\n    export type MultiplicativeOperator\r\n        = SyntaxKind.AsteriskToken\r\n        | SyntaxKind.SlashToken\r\n        | SyntaxKind.PercentToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-MultiplicativeExpression\r\n    export type MultiplicativeOperatorOrHigher\r\n        = ExponentiationOperator\r\n        | MultiplicativeOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AdditiveExpression\r\n    export type AdditiveOperator\r\n        = SyntaxKind.PlusToken\r\n        | SyntaxKind.MinusToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AdditiveExpression\r\n    export type AdditiveOperatorOrHigher\r\n        = MultiplicativeOperatorOrHigher\r\n        | AdditiveOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-ShiftExpression\r\n    export type ShiftOperator\r\n        = SyntaxKind.LessThanLessThanToken\r\n        | SyntaxKind.GreaterThanGreaterThanToken\r\n        | SyntaxKind.GreaterThanGreaterThanGreaterThanToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-ShiftExpression\r\n    export type ShiftOperatorOrHigher\r\n        = AdditiveOperatorOrHigher\r\n        | ShiftOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-RelationalExpression\r\n    export type RelationalOperator\r\n        = SyntaxKind.LessThanToken\r\n        | SyntaxKind.LessThanEqualsToken\r\n        | SyntaxKind.GreaterThanToken\r\n        | SyntaxKind.GreaterThanEqualsToken\r\n        | SyntaxKind.InstanceOfKeyword\r\n        | SyntaxKind.InKeyword\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-RelationalExpression\r\n    export type RelationalOperatorOrHigher\r\n        = ShiftOperatorOrHigher\r\n        | RelationalOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-EqualityExpression\r\n    export type EqualityOperator\r\n        = SyntaxKind.EqualsEqualsToken\r\n        | SyntaxKind.EqualsEqualsEqualsToken\r\n        | SyntaxKind.ExclamationEqualsEqualsToken\r\n        | SyntaxKind.ExclamationEqualsToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-EqualityExpression\r\n    export type EqualityOperatorOrHigher\r\n        = RelationalOperatorOrHigher\r\n        | EqualityOperator;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseXORExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseORExpression\r\n    export type BitwiseOperator\r\n        = SyntaxKind.AmpersandToken\r\n        | SyntaxKind.BarToken\r\n        | SyntaxKind.CaretToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseXORExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-BitwiseORExpression\r\n    export type BitwiseOperatorOrHigher\r\n        = EqualityOperatorOrHigher\r\n        | BitwiseOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalORExpression\r\n    export type LogicalOperator\r\n        = SyntaxKind.AmpersandAmpersandToken\r\n        | SyntaxKind.BarBarToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalANDExpression\r\n    // see: https://tc39.github.io/ecma262/#prod-LogicalORExpression\r\n    export type LogicalOperatorOrHigher\r\n        = BitwiseOperatorOrHigher\r\n        | LogicalOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AssignmentOperator\r\n    export type CompoundAssignmentOperator\r\n        = SyntaxKind.PlusEqualsToken\r\n        | SyntaxKind.MinusEqualsToken\r\n        | SyntaxKind.AsteriskAsteriskEqualsToken\r\n        | SyntaxKind.AsteriskEqualsToken\r\n        | SyntaxKind.SlashEqualsToken\r\n        | SyntaxKind.PercentEqualsToken\r\n        | SyntaxKind.AmpersandEqualsToken\r\n        | SyntaxKind.BarEqualsToken\r\n        | SyntaxKind.CaretEqualsToken\r\n        | SyntaxKind.LessThanLessThanEqualsToken\r\n        | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken\r\n        | SyntaxKind.GreaterThanGreaterThanEqualsToken\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AssignmentExpression\r\n    export type AssignmentOperator\r\n        = SyntaxKind.EqualsToken\r\n        | CompoundAssignmentOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-AssignmentExpression\r\n    export type AssignmentOperatorOrHigher\r\n        = LogicalOperatorOrHigher\r\n        | AssignmentOperator\r\n        ;\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-Expression\r\n    export type BinaryOperator\r\n        = AssignmentOperatorOrHigher\r\n        | SyntaxKind.CommaToken\r\n        ;\r\n\r\n    export type BinaryOperatorToken = Token<BinaryOperator>;\r\n\r\n    export interface BinaryExpression extends Expression, Declaration {\r\n        kind: SyntaxKind.BinaryExpression;\r\n        left: Expression;\r\n        operatorToken: BinaryOperatorToken;\r\n        right: Expression;\r\n    }\r\n\r\n    export type AssignmentOperatorToken = Token<AssignmentOperator>;\r\n\r\n    export interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {\r\n        left: LeftHandSideExpression;\r\n        operatorToken: TOperator;\r\n    }\r\n\r\n    export interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {\r\n        left: ObjectLiteralExpression;\r\n    }\r\n\r\n    export interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {\r\n        left: ArrayLiteralExpression;\r\n    }\r\n\r\n    export type DestructuringAssignment\r\n        = ObjectDestructuringAssignment\r\n        | ArrayDestructuringAssignment\r\n        ;\r\n\r\n    export type BindingOrAssignmentElement\r\n        = VariableDeclaration\r\n        | ParameterDeclaration\r\n        | BindingElement\r\n        | PropertyAssignment // AssignmentProperty\r\n        | ShorthandPropertyAssignment // AssignmentProperty\r\n        | SpreadAssignment // AssignmentRestProperty\r\n        | OmittedExpression // Elision\r\n        | SpreadElement // AssignmentRestElement\r\n        | ArrayLiteralExpression // ArrayAssignmentPattern\r\n        | ObjectLiteralExpression // ObjectAssignmentPattern\r\n        | AssignmentExpression<EqualsToken> // AssignmentElement\r\n        | Identifier // DestructuringAssignmentTarget\r\n        | PropertyAccessExpression // DestructuringAssignmentTarget\r\n        | ElementAccessExpression // DestructuringAssignmentTarget\r\n        ;\r\n\r\n    export type BindingOrAssignmentElementRestIndicator\r\n        = DotDotDotToken // from BindingElement\r\n        | SpreadElement // AssignmentRestElement\r\n        | SpreadAssignment // AssignmentRestProperty\r\n        ;\r\n\r\n    export type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;\r\n\r\n    export type ObjectBindingOrAssignmentPattern\r\n        = ObjectBindingPattern\r\n        | ObjectLiteralExpression // ObjectAssignmentPattern\r\n        ;\r\n\r\n    export type ArrayBindingOrAssignmentPattern\r\n        = ArrayBindingPattern\r\n        | ArrayLiteralExpression // ArrayAssignmentPattern\r\n        ;\r\n\r\n    export type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;\r\n\r\n    export type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;\r\n\r\n    export interface ConditionalExpression extends Expression {\r\n        kind: SyntaxKind.ConditionalExpression;\r\n        condition: Expression;\r\n        questionToken: QuestionToken;\r\n        whenTrue: Expression;\r\n        colonToken: ColonToken;\r\n        whenFalse: Expression;\r\n    }\r\n\r\n    export type FunctionBody = Block;\r\n    export type ConciseBody = FunctionBody | Expression;\r\n\r\n    export interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer {\r\n        kind: SyntaxKind.FunctionExpression;\r\n        name?: Identifier;\r\n        body: FunctionBody;  // Required, whereas the member inherited from FunctionDeclaration is optional\r\n    }\r\n\r\n    export interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer {\r\n        kind: SyntaxKind.ArrowFunction;\r\n        equalsGreaterThanToken: EqualsGreaterThanToken;\r\n        body: ConciseBody;\r\n        name: never;\r\n    }\r\n\r\n    // The text property of a LiteralExpression stores the interpreted value of the literal in text form. For a StringLiteral,\r\n    // or any literal of a template, this means quotes have been removed and escapes have been converted to actual characters.\r\n    // For a NumericLiteral, the stored value is the toString() representation of the number. For example 1, 1.00, and 1e0 are all stored as just \"1\".\r\n    export interface LiteralLikeNode extends Node {\r\n        text: string;\r\n        isUnterminated?: boolean;\r\n        hasExtendedUnicodeEscape?: boolean;\r\n    }\r\n\r\n    // The text property of a LiteralExpression stores the interpreted value of the literal in text form. For a StringLiteral,\r\n    // or any literal of a template, this means quotes have been removed and escapes have been converted to actual characters.\r\n    // For a NumericLiteral, the stored value is the toString() representation of the number. For example 1, 1.00, and 1e0 are all stored as just \"1\".\r\n    export interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {\r\n        _literalExpressionBrand: any;\r\n    }\r\n\r\n    export interface RegularExpressionLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.RegularExpressionLiteral;\r\n    }\r\n\r\n    export interface NoSubstitutionTemplateLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum TokenFlags {\r\n        None = 0,\r\n        PrecedingLineBreak = 1 << 0,\r\n        PrecedingJSDocComment = 1 << 1,\r\n        Unterminated = 1 << 2,\r\n        ExtendedUnicodeEscape = 1 << 3,\r\n        Scientific = 1 << 4,        // e.g. `10e2`\r\n        Octal = 1 << 5,             // e.g. `0777`\r\n        HexSpecifier = 1 << 6,      // e.g. `0x00000000`\r\n        BinarySpecifier = 1 << 7,   // e.g. `0b0110010000000000`\r\n        OctalSpecifier = 1 << 8,    // e.g. `0o777`\r\n        ContainsSeparator = 1 << 9, // e.g. `0b1100_0101`\r\n        BinaryOrOctalSpecifier = BinarySpecifier | OctalSpecifier,\r\n        NumericLiteralFlags = Scientific | Octal | HexSpecifier | BinarySpecifier | OctalSpecifier | ContainsSeparator\r\n    }\r\n\r\n    export interface NumericLiteral extends LiteralExpression {\r\n        kind: SyntaxKind.NumericLiteral;\r\n        /* @internal */\r\n        numericLiteralFlags?: TokenFlags;\r\n    }\r\n\r\n    export interface TemplateHead extends LiteralLikeNode {\r\n        kind: SyntaxKind.TemplateHead;\r\n        parent?: TemplateExpression;\r\n    }\r\n\r\n    export interface TemplateMiddle extends LiteralLikeNode {\r\n        kind: SyntaxKind.TemplateMiddle;\r\n        parent?: TemplateSpan;\r\n    }\r\n\r\n    export interface TemplateTail extends LiteralLikeNode {\r\n        kind: SyntaxKind.TemplateTail;\r\n        parent?: TemplateSpan;\r\n    }\r\n\r\n    export type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;\r\n\r\n    export interface TemplateExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.TemplateExpression;\r\n        head: TemplateHead;\r\n        templateSpans: NodeArray<TemplateSpan>;\r\n    }\r\n\r\n    // Each of these corresponds to a substitution expression and a template literal, in that order.\r\n    // The template literal must have kind TemplateMiddleLiteral or TemplateTailLiteral.\r\n    export interface TemplateSpan extends Node {\r\n        kind: SyntaxKind.TemplateSpan;\r\n        parent?: TemplateExpression;\r\n        expression: Expression;\r\n        literal: TemplateMiddle | TemplateTail;\r\n    }\r\n\r\n    export interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {\r\n        kind: SyntaxKind.ParenthesizedExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface ArrayLiteralExpression extends PrimaryExpression {\r\n        kind: SyntaxKind.ArrayLiteralExpression;\r\n        elements: NodeArray<Expression>;\r\n        /* @internal */\r\n        multiLine?: boolean;\r\n    }\r\n\r\n    export interface SpreadElement extends Expression {\r\n        kind: SyntaxKind.SpreadElement;\r\n        parent?: ArrayLiteralExpression | CallExpression | NewExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    /**\r\n     * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to\r\n     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be\r\n     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type\r\n     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)\r\n     */\r\n    export interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {\r\n        properties: NodeArray<T>;\r\n    }\r\n\r\n    // An ObjectLiteralExpression is the declaration node for an anonymous symbol.\r\n    export interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike> {\r\n        kind: SyntaxKind.ObjectLiteralExpression;\r\n        /* @internal */\r\n        multiLine?: boolean;\r\n    }\r\n\r\n    export type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;\r\n    export type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;\r\n\r\n    export interface PropertyAccessExpression extends MemberExpression, NamedDeclaration {\r\n        kind: SyntaxKind.PropertyAccessExpression;\r\n        expression: LeftHandSideExpression;\r\n        name: Identifier;\r\n    }\r\n\r\n    export interface SuperPropertyAccessExpression extends PropertyAccessExpression {\r\n        expression: SuperExpression;\r\n    }\r\n\r\n    /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */\r\n    export interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {\r\n        _propertyAccessExpressionLikeQualifiedNameBrand?: any;\r\n        expression: EntityNameExpression;\r\n    }\r\n\r\n    export interface ElementAccessExpression extends MemberExpression {\r\n        kind: SyntaxKind.ElementAccessExpression;\r\n        expression: LeftHandSideExpression;\r\n        argumentExpression: Expression;\r\n    }\r\n\r\n    export interface SuperElementAccessExpression extends ElementAccessExpression {\r\n        expression: SuperExpression;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-SuperProperty\r\n    export type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;\r\n\r\n    export interface CallExpression extends LeftHandSideExpression, Declaration {\r\n        kind: SyntaxKind.CallExpression;\r\n        expression: LeftHandSideExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        arguments: NodeArray<Expression>;\r\n    }\r\n\r\n    // see: https://tc39.github.io/ecma262/#prod-SuperCall\r\n    export interface SuperCall extends CallExpression {\r\n        expression: SuperExpression;\r\n    }\r\n\r\n    export interface ImportCall extends CallExpression {\r\n        expression: ImportExpression;\r\n    }\r\n\r\n    export interface ExpressionWithTypeArguments extends NodeWithTypeArguments {\r\n        kind: SyntaxKind.ExpressionWithTypeArguments;\r\n        parent?: HeritageClause;\r\n        expression: LeftHandSideExpression;\r\n    }\r\n\r\n    export interface NewExpression extends PrimaryExpression, Declaration {\r\n        kind: SyntaxKind.NewExpression;\r\n        expression: LeftHandSideExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        arguments?: NodeArray<Expression>;\r\n    }\r\n\r\n    export interface TaggedTemplateExpression extends MemberExpression {\r\n        kind: SyntaxKind.TaggedTemplateExpression;\r\n        tag: LeftHandSideExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        template: TemplateLiteral;\r\n    }\r\n\r\n    export type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;\r\n\r\n    export interface AsExpression extends Expression {\r\n        kind: SyntaxKind.AsExpression;\r\n        expression: Expression;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface TypeAssertion extends UnaryExpression {\r\n        kind: SyntaxKind.TypeAssertionExpression;\r\n        type: TypeNode;\r\n        expression: UnaryExpression;\r\n    }\r\n\r\n    export type AssertionExpression = TypeAssertion | AsExpression;\r\n\r\n    export interface NonNullExpression extends LeftHandSideExpression {\r\n        kind: SyntaxKind.NonNullExpression;\r\n        expression: Expression;\r\n    }\r\n\r\n    // NOTE: MetaProperty is really a MemberExpression, but we consider it a PrimaryExpression\r\n    //       for the same reasons we treat NewExpression as a PrimaryExpression.\r\n    export interface MetaProperty extends PrimaryExpression {\r\n        kind: SyntaxKind.MetaProperty;\r\n        keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;\r\n        name: Identifier;\r\n    }\r\n\r\n    /// A JSX expression of the form <TagName attrs>...</TagName>\r\n    export interface JsxElement extends PrimaryExpression {\r\n        kind: SyntaxKind.JsxElement;\r\n        openingElement: JsxOpeningElement;\r\n        children: NodeArray<JsxChild>;\r\n        closingElement: JsxClosingElement;\r\n    }\r\n\r\n    /// Either the opening tag in a <Tag>...</Tag> pair or the lone <Tag /> in a self-closing form\r\n    export type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;\r\n\r\n    export type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;\r\n\r\n    export type JsxTagNameExpression = PrimaryExpression | PropertyAccessExpression;\r\n\r\n    export interface JsxAttributes extends ObjectLiteralExpressionBase<JsxAttributeLike> {\r\n        parent?: JsxOpeningLikeElement;\r\n    }\r\n\r\n    /// The opening element of a <Tag>...</Tag> JsxElement\r\n    export interface JsxOpeningElement extends Expression {\r\n        kind: SyntaxKind.JsxOpeningElement;\r\n        parent?: JsxElement;\r\n        tagName: JsxTagNameExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        attributes: JsxAttributes;\r\n    }\r\n\r\n    /// A JSX expression of the form <TagName attrs />\r\n    export interface JsxSelfClosingElement extends PrimaryExpression {\r\n        kind: SyntaxKind.JsxSelfClosingElement;\r\n        tagName: JsxTagNameExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        attributes: JsxAttributes;\r\n    }\r\n\r\n    /// A JSX expression of the form <>...</>\r\n    export interface JsxFragment extends PrimaryExpression {\r\n        kind: SyntaxKind.JsxFragment;\r\n        openingFragment: JsxOpeningFragment;\r\n        children: NodeArray<JsxChild>;\r\n        closingFragment: JsxClosingFragment;\r\n    }\r\n\r\n    /// The opening element of a <>...</> JsxFragment\r\n    export interface JsxOpeningFragment extends Expression {\r\n        kind: SyntaxKind.JsxOpeningFragment;\r\n        parent?: JsxFragment;\r\n    }\r\n\r\n    /// The closing element of a <>...</> JsxFragment\r\n    export interface JsxClosingFragment extends Expression {\r\n        kind: SyntaxKind.JsxClosingFragment;\r\n        parent?: JsxFragment;\r\n    }\r\n\r\n    export interface JsxAttribute extends ObjectLiteralElement {\r\n        kind: SyntaxKind.JsxAttribute;\r\n        parent?: JsxAttributes;\r\n        name: Identifier;\r\n        /// JSX attribute initializers are optional; <X y /> is sugar for <X y={true} />\r\n        initializer?: StringLiteral | JsxExpression;\r\n    }\r\n\r\n    export interface JsxSpreadAttribute extends ObjectLiteralElement {\r\n        kind: SyntaxKind.JsxSpreadAttribute;\r\n        parent?: JsxAttributes;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface JsxClosingElement extends Node {\r\n        kind: SyntaxKind.JsxClosingElement;\r\n        parent?: JsxElement;\r\n        tagName: JsxTagNameExpression;\r\n    }\r\n\r\n    export interface JsxExpression extends Expression {\r\n        kind: SyntaxKind.JsxExpression;\r\n        parent?: JsxElement | JsxAttributeLike;\r\n        dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;\r\n        expression?: Expression;\r\n    }\r\n\r\n    export interface JsxText extends Node {\r\n        kind: SyntaxKind.JsxText;\r\n        containsOnlyWhiteSpaces: boolean;\r\n        parent?: JsxElement;\r\n    }\r\n\r\n    export type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;\r\n\r\n    export interface Statement extends Node {\r\n        _statementBrand: any;\r\n    }\r\n\r\n    // Represents a statement that is elided as part of a transformation to emit comments on a\r\n    // not-emitted node.\r\n    export interface NotEmittedStatement extends Statement {\r\n        kind: SyntaxKind.NotEmittedStatement;\r\n    }\r\n\r\n    /**\r\n     * Marks the end of transformed declaration to properly emit exports.\r\n     */\r\n    /* @internal */\r\n    export interface EndOfDeclarationMarker extends Statement {\r\n        kind: SyntaxKind.EndOfDeclarationMarker;\r\n    }\r\n\r\n    /**\r\n     * A list of comma-seperated expressions. This node is only created by transformations.\r\n     */\r\n    export interface CommaListExpression extends Expression {\r\n        kind: SyntaxKind.CommaListExpression;\r\n        elements: NodeArray<Expression>;\r\n    }\r\n\r\n    /**\r\n     * Marks the beginning of a merged transformed declaration.\r\n     */\r\n    /* @internal */\r\n    export interface MergeDeclarationMarker extends Statement {\r\n        kind: SyntaxKind.MergeDeclarationMarker;\r\n    }\r\n\r\n    export interface EmptyStatement extends Statement {\r\n        kind: SyntaxKind.EmptyStatement;\r\n    }\r\n\r\n    export interface DebuggerStatement extends Statement {\r\n        kind: SyntaxKind.DebuggerStatement;\r\n    }\r\n\r\n    export interface MissingDeclaration extends DeclarationStatement {\r\n        kind: SyntaxKind.MissingDeclaration;\r\n        name?: Identifier;\r\n    }\r\n\r\n    export type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;\r\n\r\n    export interface Block extends Statement {\r\n        kind: SyntaxKind.Block;\r\n        statements: NodeArray<Statement>;\r\n        /*@internal*/ multiLine?: boolean;\r\n    }\r\n\r\n    export interface VariableStatement extends Statement, JSDocContainer {\r\n        kind: SyntaxKind.VariableStatement;\r\n        declarationList: VariableDeclarationList;\r\n    }\r\n\r\n    export interface ExpressionStatement extends Statement, JSDocContainer {\r\n        kind: SyntaxKind.ExpressionStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface PrologueDirective extends ExpressionStatement {\r\n        expression: StringLiteral;\r\n    }\r\n\r\n    export interface IfStatement extends Statement {\r\n        kind: SyntaxKind.IfStatement;\r\n        expression: Expression;\r\n        thenStatement: Statement;\r\n        elseStatement?: Statement;\r\n    }\r\n\r\n    export interface IterationStatement extends Statement {\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface DoStatement extends IterationStatement {\r\n        kind: SyntaxKind.DoStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface WhileStatement extends IterationStatement {\r\n        kind: SyntaxKind.WhileStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    export type ForInitializer = VariableDeclarationList | Expression;\r\n\r\n    export interface ForStatement extends IterationStatement {\r\n        kind: SyntaxKind.ForStatement;\r\n        initializer?: ForInitializer;\r\n        condition?: Expression;\r\n        incrementor?: Expression;\r\n    }\r\n\r\n    export type ForInOrOfStatement = ForInStatement | ForOfStatement;\r\n\r\n    export interface ForInStatement extends IterationStatement {\r\n        kind: SyntaxKind.ForInStatement;\r\n        initializer: ForInitializer;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface ForOfStatement extends IterationStatement {\r\n        kind: SyntaxKind.ForOfStatement;\r\n        awaitModifier?: AwaitKeywordToken;\r\n        initializer: ForInitializer;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface BreakStatement extends Statement {\r\n        kind: SyntaxKind.BreakStatement;\r\n        label?: Identifier;\r\n    }\r\n\r\n    export interface ContinueStatement extends Statement {\r\n        kind: SyntaxKind.ContinueStatement;\r\n        label?: Identifier;\r\n    }\r\n\r\n    export type BreakOrContinueStatement = BreakStatement | ContinueStatement;\r\n\r\n    export interface ReturnStatement extends Statement {\r\n        kind: SyntaxKind.ReturnStatement;\r\n        expression?: Expression;\r\n    }\r\n\r\n    export interface WithStatement extends Statement {\r\n        kind: SyntaxKind.WithStatement;\r\n        expression: Expression;\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface SwitchStatement extends Statement {\r\n        kind: SyntaxKind.SwitchStatement;\r\n        expression: Expression;\r\n        caseBlock: CaseBlock;\r\n        possiblyExhaustive?: boolean;\r\n    }\r\n\r\n    export interface CaseBlock extends Node {\r\n        kind: SyntaxKind.CaseBlock;\r\n        parent?: SwitchStatement;\r\n        clauses: NodeArray<CaseOrDefaultClause>;\r\n    }\r\n\r\n    export interface CaseClause extends Node {\r\n        kind: SyntaxKind.CaseClause;\r\n        parent?: CaseBlock;\r\n        expression: Expression;\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export interface DefaultClause extends Node {\r\n        kind: SyntaxKind.DefaultClause;\r\n        parent?: CaseBlock;\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export type CaseOrDefaultClause = CaseClause | DefaultClause;\r\n\r\n    export interface LabeledStatement extends Statement, JSDocContainer {\r\n        kind: SyntaxKind.LabeledStatement;\r\n        label: Identifier;\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface ThrowStatement extends Statement {\r\n        kind: SyntaxKind.ThrowStatement;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface TryStatement extends Statement {\r\n        kind: SyntaxKind.TryStatement;\r\n        tryBlock: Block;\r\n        catchClause?: CatchClause;\r\n        finallyBlock?: Block;\r\n    }\r\n\r\n    export interface CatchClause extends Node {\r\n        kind: SyntaxKind.CatchClause;\r\n        parent?: TryStatement;\r\n        variableDeclaration?: VariableDeclaration;\r\n        block: Block;\r\n    }\r\n\r\n    export type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;\r\n\r\n    export type DeclarationWithTypeParameters = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;\r\n\r\n    export interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {\r\n        kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;\r\n        name?: Identifier;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        heritageClauses?: NodeArray<HeritageClause>;\r\n        members: NodeArray<ClassElement>;\r\n    }\r\n\r\n    export interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {\r\n        kind: SyntaxKind.ClassDeclaration;\r\n        /** May be undefined in `export default class { ... }`. */\r\n        name?: Identifier;\r\n    }\r\n\r\n    export interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {\r\n        kind: SyntaxKind.ClassExpression;\r\n    }\r\n\r\n    export type ClassLikeDeclaration = ClassDeclaration | ClassExpression;\r\n\r\n    export interface ClassElement extends NamedDeclaration {\r\n        _classElementBrand: any;\r\n        name?: PropertyName;\r\n    }\r\n\r\n    export interface TypeElement extends NamedDeclaration {\r\n        _typeElementBrand: any;\r\n        name?: PropertyName;\r\n        questionToken?: QuestionToken;\r\n    }\r\n\r\n    export interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.InterfaceDeclaration;\r\n        name: Identifier;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        heritageClauses?: NodeArray<HeritageClause>;\r\n        members: NodeArray<TypeElement>;\r\n    }\r\n\r\n    export interface HeritageClause extends Node {\r\n        kind: SyntaxKind.HeritageClause;\r\n        parent?: InterfaceDeclaration | ClassLikeDeclaration;\r\n        token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;\r\n        types: NodeArray<ExpressionWithTypeArguments>;\r\n    }\r\n\r\n    export interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.TypeAliasDeclaration;\r\n        name: Identifier;\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface EnumMember extends NamedDeclaration, JSDocContainer {\r\n        kind: SyntaxKind.EnumMember;\r\n        parent?: EnumDeclaration;\r\n        // This does include ComputedPropertyName, but the parser will give an error\r\n        // if it parses a ComputedPropertyName in an EnumMember\r\n        name: PropertyName;\r\n        initializer?: Expression;\r\n    }\r\n\r\n    export interface EnumDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.EnumDeclaration;\r\n        name: Identifier;\r\n        members: NodeArray<EnumMember>;\r\n    }\r\n\r\n    export type ModuleName = Identifier | StringLiteral;\r\n\r\n    export type ModuleBody = NamespaceBody | JSDocNamespaceBody;\r\n\r\n    /* @internal */\r\n    export interface AmbientModuleDeclaration extends ModuleDeclaration { body?: ModuleBlock; }\r\n\r\n    export interface ModuleDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.ModuleDeclaration;\r\n        parent?: ModuleBody | SourceFile;\r\n        name: ModuleName;\r\n        body?: ModuleBody | JSDocNamespaceDeclaration;\r\n    }\r\n\r\n    export type NamespaceBody = ModuleBlock | NamespaceDeclaration;\r\n\r\n    export interface NamespaceDeclaration extends ModuleDeclaration {\r\n        name: Identifier;\r\n        body: NamespaceBody;\r\n    }\r\n\r\n    export type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;\r\n\r\n    export interface JSDocNamespaceDeclaration extends ModuleDeclaration {\r\n        name: Identifier;\r\n        body: JSDocNamespaceBody;\r\n    }\r\n\r\n    export interface ModuleBlock extends Node, Statement {\r\n        kind: SyntaxKind.ModuleBlock;\r\n        parent?: ModuleDeclaration;\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export type ModuleReference = EntityName | ExternalModuleReference;\r\n\r\n    /**\r\n     * One of:\r\n     * - import x = require(\"mod\");\r\n     * - import x = M.x;\r\n     */\r\n    export interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {\r\n        kind: SyntaxKind.ImportEqualsDeclaration;\r\n        parent?: SourceFile | ModuleBlock;\r\n        name: Identifier;\r\n\r\n        // 'EntityName' for an internal module reference, 'ExternalModuleReference' for an external\r\n        // module reference.\r\n        moduleReference: ModuleReference;\r\n    }\r\n\r\n    export interface ExternalModuleReference extends Node {\r\n        kind: SyntaxKind.ExternalModuleReference;\r\n        parent?: ImportEqualsDeclaration;\r\n        expression?: Expression;\r\n    }\r\n\r\n    // In case of:\r\n    // import \"mod\"  => importClause = undefined, moduleSpecifier = \"mod\"\r\n    // In rest of the cases, module specifier is string literal corresponding to module\r\n    // ImportClause information is shown at its declaration below.\r\n    export interface ImportDeclaration extends Statement {\r\n        kind: SyntaxKind.ImportDeclaration;\r\n        parent?: SourceFile | ModuleBlock;\r\n        importClause?: ImportClause;\r\n        /** If this is not a StringLiteral it will be a grammar error. */\r\n        moduleSpecifier: Expression;\r\n    }\r\n\r\n    export type NamedImportBindings = NamespaceImport | NamedImports;\r\n\r\n    // In case of:\r\n    // import d from \"mod\" => name = d, namedBinding = undefined\r\n    // import * as ns from \"mod\" => name = undefined, namedBinding: NamespaceImport = { name: ns }\r\n    // import d, * as ns from \"mod\" => name = d, namedBinding: NamespaceImport = { name: ns }\r\n    // import { a, b as x } from \"mod\" => name = undefined, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}\r\n    // import d, { a, b as x } from \"mod\" => name = d, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}\r\n    export interface ImportClause extends NamedDeclaration {\r\n        kind: SyntaxKind.ImportClause;\r\n        parent?: ImportDeclaration;\r\n        name?: Identifier; // Default binding\r\n        namedBindings?: NamedImportBindings;\r\n    }\r\n\r\n    export interface NamespaceImport extends NamedDeclaration {\r\n        kind: SyntaxKind.NamespaceImport;\r\n        parent?: ImportClause;\r\n        name: Identifier;\r\n    }\r\n\r\n    export interface NamespaceExportDeclaration extends DeclarationStatement {\r\n        kind: SyntaxKind.NamespaceExportDeclaration;\r\n        name: Identifier;\r\n    }\r\n\r\n    export interface ExportDeclaration extends DeclarationStatement {\r\n        kind: SyntaxKind.ExportDeclaration;\r\n        parent?: SourceFile | ModuleBlock;\r\n        /** Will not be assigned in the case of `export * from \"foo\";` */\r\n        exportClause?: NamedExports;\r\n        /** If this is not a StringLiteral it will be a grammar error. */\r\n        moduleSpecifier?: Expression;\r\n    }\r\n\r\n    export interface NamedImports extends Node {\r\n        kind: SyntaxKind.NamedImports;\r\n        parent?: ImportClause;\r\n        elements: NodeArray<ImportSpecifier>;\r\n    }\r\n\r\n    export interface NamedExports extends Node {\r\n        kind: SyntaxKind.NamedExports;\r\n        parent?: ExportDeclaration;\r\n        elements: NodeArray<ExportSpecifier>;\r\n    }\r\n\r\n    export type NamedImportsOrExports = NamedImports | NamedExports;\r\n\r\n    export interface ImportSpecifier extends NamedDeclaration {\r\n        kind: SyntaxKind.ImportSpecifier;\r\n        parent?: NamedImports;\r\n        propertyName?: Identifier;  // Name preceding \"as\" keyword (or undefined when \"as\" is absent)\r\n        name: Identifier;           // Declared name\r\n    }\r\n\r\n    export interface ExportSpecifier extends NamedDeclaration {\r\n        kind: SyntaxKind.ExportSpecifier;\r\n        parent?: NamedExports;\r\n        propertyName?: Identifier;  // Name preceding \"as\" keyword (or undefined when \"as\" is absent)\r\n        name: Identifier;           // Declared name\r\n    }\r\n\r\n    export type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;\r\n\r\n    /**\r\n     * This is either an `export =` or an `export default` declaration.\r\n     * Unless `isExportEquals` is set, this node was parsed as an `export default`.\r\n     */\r\n    export interface ExportAssignment extends DeclarationStatement {\r\n        kind: SyntaxKind.ExportAssignment;\r\n        parent?: SourceFile;\r\n        isExportEquals?: boolean;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface FileReference extends TextRange {\r\n        fileName: string;\r\n    }\r\n\r\n    export interface CheckJsDirective extends TextRange {\r\n        enabled: boolean;\r\n    }\r\n\r\n    export type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;\r\n\r\n    export interface CommentRange extends TextRange {\r\n        hasTrailingNewLine?: boolean;\r\n        kind: CommentKind;\r\n    }\r\n\r\n    export interface SynthesizedComment extends CommentRange {\r\n        text: string;\r\n        pos: -1;\r\n        end: -1;\r\n    }\r\n\r\n    // represents a top level: { type } expression in a JSDoc comment.\r\n    export interface JSDocTypeExpression extends TypeNode {\r\n        kind: SyntaxKind.JSDocTypeExpression;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface JSDocType extends TypeNode {\r\n        _jsDocTypeBrand: any;\r\n    }\r\n\r\n    export interface JSDocAllType extends JSDocType {\r\n        kind: SyntaxKind.JSDocAllType;\r\n    }\r\n\r\n    export interface JSDocUnknownType extends JSDocType {\r\n        kind: SyntaxKind.JSDocUnknownType;\r\n    }\r\n\r\n    export interface JSDocNonNullableType extends JSDocType {\r\n        kind: SyntaxKind.JSDocNonNullableType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface JSDocNullableType extends JSDocType {\r\n        kind: SyntaxKind.JSDocNullableType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface JSDocOptionalType extends JSDocType {\r\n        kind: SyntaxKind.JSDocOptionalType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase {\r\n        kind: SyntaxKind.JSDocFunctionType;\r\n    }\r\n\r\n    export interface JSDocVariadicType extends JSDocType {\r\n        kind: SyntaxKind.JSDocVariadicType;\r\n        type: TypeNode;\r\n    }\r\n\r\n    export type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;\r\n\r\n    export interface JSDoc extends Node {\r\n        kind: SyntaxKind.JSDocComment;\r\n        parent?: HasJSDoc;\r\n        tags: NodeArray<JSDocTag> | undefined;\r\n        comment: string | undefined;\r\n    }\r\n\r\n    export interface JSDocTag extends Node {\r\n        parent: JSDoc | JSDocTypeLiteral;\r\n        atToken: AtToken;\r\n        tagName: Identifier;\r\n        comment: string | undefined;\r\n    }\r\n\r\n    export interface JSDocUnknownTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocTag;\r\n    }\r\n\r\n    /**\r\n     * Note that `@extends` is a synonym of `@augments`.\r\n     * Both tags are represented by this interface.\r\n     */\r\n    export interface JSDocAugmentsTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocAugmentsTag;\r\n        class: ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression };\r\n    }\r\n\r\n    export interface JSDocClassTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocClassTag;\r\n    }\r\n\r\n    export interface JSDocTemplateTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocTemplateTag;\r\n        typeParameters: NodeArray<TypeParameterDeclaration>;\r\n    }\r\n\r\n    export interface JSDocReturnTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocReturnTag;\r\n        typeExpression: JSDocTypeExpression;\r\n    }\r\n\r\n    export interface JSDocTypeTag extends JSDocTag {\r\n        kind: SyntaxKind.JSDocTypeTag;\r\n        typeExpression: JSDocTypeExpression;\r\n    }\r\n\r\n    export interface JSDocTypedefTag extends JSDocTag, NamedDeclaration {\r\n        parent: JSDoc;\r\n        kind: SyntaxKind.JSDocTypedefTag;\r\n        fullName?: JSDocNamespaceDeclaration | Identifier;\r\n        name?: Identifier;\r\n        typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;\r\n    }\r\n\r\n    export interface JSDocPropertyLikeTag extends JSDocTag, Declaration {\r\n        parent: JSDoc;\r\n        name: EntityName;\r\n        typeExpression?: JSDocTypeExpression;\r\n        /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */\r\n        isNameFirst: boolean;\r\n        isBracketed: boolean;\r\n    }\r\n\r\n    export interface JSDocPropertyTag extends JSDocPropertyLikeTag {\r\n        kind: SyntaxKind.JSDocPropertyTag;\r\n    }\r\n\r\n    export interface JSDocParameterTag extends JSDocPropertyLikeTag {\r\n        kind: SyntaxKind.JSDocParameterTag;\r\n    }\r\n\r\n    export interface JSDocTypeLiteral extends JSDocType {\r\n        kind: SyntaxKind.JSDocTypeLiteral;\r\n        jsDocPropertyTags?: ReadonlyArray<JSDocPropertyLikeTag>;\r\n        /** If true, then this type literal represents an *array* of its type. */\r\n        isArrayType?: boolean;\r\n    }\r\n\r\n    export const enum FlowFlags {\r\n        Unreachable    = 1 << 0,  // Unreachable code\r\n        Start          = 1 << 1,  // Start of flow graph\r\n        BranchLabel    = 1 << 2,  // Non-looping junction\r\n        LoopLabel      = 1 << 3,  // Looping junction\r\n        Assignment     = 1 << 4,  // Assignment\r\n        TrueCondition  = 1 << 5,  // Condition known to be true\r\n        FalseCondition = 1 << 6,  // Condition known to be false\r\n        SwitchClause   = 1 << 7,  // Switch statement clause\r\n        ArrayMutation  = 1 << 8,  // Potential array mutation\r\n        Referenced     = 1 << 9,  // Referenced as antecedent once\r\n        Shared         = 1 << 10, // Referenced as antecedent more than once\r\n        PreFinally     = 1 << 11, // Injected edge that links pre-finally label and pre-try flow\r\n        AfterFinally   = 1 << 12, // Injected edge that links post-finally flow with the rest of the graph\r\n        Label = BranchLabel | LoopLabel,\r\n        Condition = TrueCondition | FalseCondition\r\n    }\r\n\r\n    export interface FlowLock {\r\n        locked?: boolean;\r\n    }\r\n\r\n    export interface AfterFinallyFlow extends FlowNodeBase, FlowLock {\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    export interface PreFinallyFlow extends FlowNodeBase {\r\n        antecedent: FlowNode;\r\n        lock: FlowLock;\r\n    }\r\n\r\n    export type FlowNode =\r\n        | AfterFinallyFlow | PreFinallyFlow | FlowStart | FlowLabel | FlowAssignment | FlowCondition | FlowSwitchClause | FlowArrayMutation;\r\n    export interface FlowNodeBase {\r\n        flags: FlowFlags;\r\n        id?: number;     // Node id used by flow type cache in checker\r\n    }\r\n\r\n    // FlowStart represents the start of a control flow. For a function expression or arrow\r\n    // function, the container property references the function (which in turn has a flowNode\r\n    // property for the containing control flow).\r\n    export interface FlowStart extends FlowNodeBase {\r\n        container?: FunctionExpression | ArrowFunction | MethodDeclaration;\r\n    }\r\n\r\n    // FlowLabel represents a junction with multiple possible preceding control flows.\r\n    export interface FlowLabel extends FlowNodeBase {\r\n        antecedents: FlowNode[];\r\n    }\r\n\r\n    // FlowAssignment represents a node that assigns a value to a narrowable reference,\r\n    // i.e. an identifier or a dotted name that starts with an identifier or 'this'.\r\n    export interface FlowAssignment extends FlowNodeBase {\r\n        node: Expression | VariableDeclaration | BindingElement;\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    // FlowCondition represents a condition that is known to be true or false at the\r\n    // node's location in the control flow.\r\n    export interface FlowCondition extends FlowNodeBase {\r\n        expression: Expression;\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    export interface FlowSwitchClause extends FlowNodeBase {\r\n        switchStatement: SwitchStatement;\r\n        clauseStart: number;   // Start index of case/default clause range\r\n        clauseEnd: number;     // End index of case/default clause range\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    // FlowArrayMutation represents a node potentially mutates an array, i.e. an\r\n    // operation of the form 'x.push(value)', 'x.unshift(value)' or 'x[n] = value'.\r\n    export interface FlowArrayMutation extends FlowNodeBase {\r\n        node: CallExpression | BinaryExpression;\r\n        antecedent: FlowNode;\r\n    }\r\n\r\n    export type FlowType = Type | IncompleteType;\r\n\r\n    // Incomplete types occur during control flow analysis of loops. An IncompleteType\r\n    // is distinguished from a regular type by a flags value of zero. Incomplete type\r\n    // objects are internal to the getFlowTypeOfRefecence function and never escape it.\r\n    export interface IncompleteType {\r\n        flags: TypeFlags;  // No flags set\r\n        type: Type;        // The type marked incomplete\r\n    }\r\n\r\n    export interface AmdDependency {\r\n        path: string;\r\n        name: string;\r\n    }\r\n\r\n    /* @internal */\r\n    /**\r\n     * Subset of properties from SourceFile that are used in multiple utility functions\r\n     */\r\n    export interface SourceFileLike {\r\n        readonly text: string;\r\n        lineMap?: ReadonlyArray<number>;\r\n    }\r\n\r\n\r\n    /* @internal */\r\n    export interface RedirectInfo {\r\n        /** Source file this redirects to. */\r\n        readonly redirectTarget: SourceFile;\r\n        /**\r\n         * Source file for the duplicate package. This will not be used by the Program,\r\n         * but we need to keep this around so we can watch for changes in underlying.\r\n         */\r\n        readonly unredirected: SourceFile;\r\n    }\r\n\r\n    // Source files are declarations when they are external modules.\r\n    export interface SourceFile extends Declaration {\r\n        kind: SyntaxKind.SourceFile;\r\n        statements: NodeArray<Statement>;\r\n        endOfFileToken: Token<SyntaxKind.EndOfFileToken>;\r\n\r\n        fileName: string;\r\n        /* @internal */ path: Path;\r\n        text: string;\r\n\r\n        /**\r\n         * If two source files are for the same version of the same package, one will redirect to the other.\r\n         * (See `createRedirectSourceFile` in program.ts.)\r\n         * The redirect will have this set. The redirected-to source file will be in `redirectTargetsSet`.\r\n         */\r\n        /* @internal */ redirectInfo?: RedirectInfo | undefined;\r\n\r\n        amdDependencies: ReadonlyArray<AmdDependency>;\r\n        moduleName: string;\r\n        referencedFiles: ReadonlyArray<FileReference>;\r\n        typeReferenceDirectives: ReadonlyArray<FileReference>;\r\n        languageVariant: LanguageVariant;\r\n        isDeclarationFile: boolean;\r\n\r\n        // this map is used by transpiler to supply alternative names for dependencies (i.e. in case of bundling)\r\n        /* @internal */\r\n        renamedDependencies?: ReadonlyMap<string>;\r\n\r\n        /**\r\n         * lib.d.ts should have a reference comment like\r\n         *\r\n         *  /// <reference no-default-lib=\"true\"/>\r\n         *\r\n         * If any other file has this comment, it signals not to include lib.d.ts\r\n         * because this containing file is intended to act as a default library.\r\n         */\r\n        hasNoDefaultLib: boolean;\r\n\r\n        languageVersion: ScriptTarget;\r\n        /* @internal */ scriptKind: ScriptKind;\r\n\r\n        /**\r\n         * The first \"most obvious\" node that makes a file an external module.\r\n         * This is intended to be the first top-level import/export,\r\n         * but could be arbitrarily nested (e.g. `import.meta`).\r\n         */\r\n        /* @internal */ externalModuleIndicator: Node;\r\n        // The first node that causes this file to be a CommonJS module\r\n        /* @internal */ commonJsModuleIndicator: Node;\r\n\r\n        /* @internal */ identifiers: Map<string>; // Map from a string to an interned string\r\n        /* @internal */ nodeCount: number;\r\n        /* @internal */ identifierCount: number;\r\n        /* @internal */ symbolCount: number;\r\n\r\n        // File-level diagnostics reported by the parser (includes diagnostics about /// references\r\n        // as well as code diagnostics).\r\n        /* @internal */ parseDiagnostics: Diagnostic[];\r\n\r\n        // File-level diagnostics reported by the binder.\r\n        /* @internal */ bindDiagnostics: Diagnostic[];\r\n\r\n        // File-level JSDoc diagnostics reported by the JSDoc parser\r\n        /* @internal */ jsDocDiagnostics?: Diagnostic[];\r\n\r\n        // Stores additional file-level diagnostics reported by the program\r\n        /* @internal */ additionalSyntacticDiagnostics?: ReadonlyArray<Diagnostic>;\r\n\r\n        // Stores a line map for the file.\r\n        // This field should never be used directly to obtain line map, use getLineMap function instead.\r\n        /* @internal */ lineMap: ReadonlyArray<number>;\r\n        /* @internal */ classifiableNames?: ReadonlyUnderscoreEscapedMap<true>;\r\n        // Stores a mapping 'external module reference text' -> 'resolved file name' | undefined\r\n        // It is used to resolve module names in the checker.\r\n        // Content of this field should never be used directly - use getResolvedModuleFileName/setResolvedModuleFileName functions instead\r\n        /* @internal */ resolvedModules: Map<ResolvedModuleFull | undefined>;\r\n        /* @internal */ resolvedTypeReferenceDirectiveNames: Map<ResolvedTypeReferenceDirective>;\r\n        /* @internal */ imports: ReadonlyArray<StringLiteralLike>;\r\n        // Identifier only if `declare global`\r\n        /* @internal */ moduleAugmentations: ReadonlyArray<StringLiteral | Identifier>;\r\n        /* @internal */ patternAmbientModules?: PatternAmbientModule[];\r\n        /* @internal */ ambientModuleNames: ReadonlyArray<string>;\r\n        /* @internal */ checkJsDirective: CheckJsDirective | undefined;\r\n        /* @internal */ version: string;\r\n        /* @internal */ pragmas: PragmaMap;\r\n        /* @internal */ localJsxNamespace?: __String;\r\n        /* @internal */ localJsxFactory?: EntityName;\r\n    }\r\n\r\n    export interface Bundle extends Node {\r\n        kind: SyntaxKind.Bundle;\r\n        sourceFiles: ReadonlyArray<SourceFile>;\r\n        /* @internal */ syntheticFileReferences?: ReadonlyArray<FileReference>;\r\n        /* @internal */ syntheticTypeReferences?: ReadonlyArray<FileReference>;\r\n        /* @internal */ hasNoDefaultLib?: boolean;\r\n    }\r\n\r\n    export interface JsonSourceFile extends SourceFile {\r\n        jsonObject?: ObjectLiteralExpression;\r\n        extendedSourceFiles?: string[];\r\n    }\r\n\r\n    export interface ScriptReferenceHost {\r\n        getCompilerOptions(): CompilerOptions;\r\n        getSourceFile(fileName: string): SourceFile | undefined;\r\n        getSourceFileByPath(path: Path): SourceFile | undefined;\r\n        getCurrentDirectory(): string;\r\n    }\r\n\r\n    export interface ParseConfigHost {\r\n        useCaseSensitiveFileNames: boolean;\r\n\r\n        readDirectory(rootDir: string, extensions: ReadonlyArray<string>, excludes: ReadonlyArray<string> | undefined, includes: ReadonlyArray<string>, depth?: number): string[];\r\n\r\n        /**\r\n         * Gets a value indicating whether the specified path exists and is a file.\r\n         * @param path The path to test.\r\n         */\r\n        fileExists(path: string): boolean;\r\n\r\n        readFile(path: string): string | undefined;\r\n    }\r\n\r\n    export type WriteFileCallback = (\r\n        fileName: string,\r\n        data: string,\r\n        writeByteOrderMark: boolean,\r\n        onError: ((message: string) => void) | undefined,\r\n        sourceFiles: ReadonlyArray<SourceFile>,\r\n    ) => void;\r\n\r\n    export class OperationCanceledException { }\r\n\r\n    export interface CancellationToken {\r\n        isCancellationRequested(): boolean;\r\n\r\n        /** @throws OperationCanceledException if isCancellationRequested is true */\r\n        throwIfCancellationRequested(): void;\r\n    }\r\n\r\n    export interface Program extends ScriptReferenceHost {\r\n\r\n        /**\r\n         * Get a list of root file names that were passed to a 'createProgram'\r\n         */\r\n        getRootFileNames(): ReadonlyArray<string>;\r\n\r\n        /**\r\n         * Get a list of files in the program\r\n         */\r\n        getSourceFiles(): ReadonlyArray<SourceFile>;\r\n\r\n        /**\r\n         * Get a list of file names that were passed to 'createProgram' or referenced in a\r\n         * program source file but could not be located.\r\n         */\r\n        /* @internal */\r\n        getMissingFilePaths(): ReadonlyArray<Path>;\r\n\r\n        /**\r\n         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then\r\n         * the JavaScript and declaration files will be produced for all the files in this program.\r\n         * If targetSourceFile is specified, then only the JavaScript and declaration for that\r\n         * specific file will be generated.\r\n         *\r\n         * If writeFile is not specified then the writeFile callback from the compiler host will be\r\n         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter\r\n         * will be invoked when writing the JavaScript and declaration files.\r\n         */\r\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\r\n\r\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): ReadonlyArray<Diagnostic>;\r\n        getConfigFileParsingDiagnostics(): ReadonlyArray<Diagnostic>;\r\n\r\n        /**\r\n         * Gets a type checker that can be used to semantically analyze source files in the program.\r\n         */\r\n        getTypeChecker(): TypeChecker;\r\n\r\n        /* @internal */ getCommonSourceDirectory(): string;\r\n\r\n        // For testing purposes only.  Should not be used by any other consumers (including the\r\n        // language service).\r\n        /* @internal */ getDiagnosticsProducingTypeChecker(): TypeChecker;\r\n        /* @internal */ dropDiagnosticsProducingTypeChecker(): void;\r\n\r\n        /* @internal */ getClassifiableNames(): UnderscoreEscapedMap<true>;\r\n\r\n        /* @internal */ getNodeCount(): number;\r\n        /* @internal */ getIdentifierCount(): number;\r\n        /* @internal */ getSymbolCount(): number;\r\n        /* @internal */ getTypeCount(): number;\r\n\r\n        /* @internal */ getFileProcessingDiagnostics(): DiagnosticCollection;\r\n        /* @internal */ getResolvedTypeReferenceDirectives(): Map<ResolvedTypeReferenceDirective>;\r\n        isSourceFileFromExternalLibrary(file: SourceFile): boolean;\r\n        /* @internal */ isSourceFileDefaultLibrary(file: SourceFile): boolean;\r\n\r\n        // For testing purposes only.\r\n        /* @internal */ structureIsReused?: StructureIsReused;\r\n\r\n        /* @internal */ getSourceFileFromReference(referencingFile: SourceFile, ref: FileReference): SourceFile | undefined;\r\n\r\n        /** Given a source file, get the name of the package it was imported from. */\r\n        /* @internal */ sourceFileToPackageName: Map<string>;\r\n        /** Set of all source files that some other source file redirects to. */\r\n        /* @internal */ redirectTargetsSet: Map<true>;\r\n        /** Is the file emitted file */\r\n        /* @internal */ isEmittedFile(file: string): boolean;\r\n\r\n        /* @internal */ getResolvedModuleWithFailedLookupLocationsFromCache(moduleName: string, containingFile: string): ResolvedModuleWithFailedLookupLocations | undefined;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum StructureIsReused {\r\n        Not         = 0,\r\n        SafeModules = 1 << 0,\r\n        Completely  = 1 << 1,\r\n    }\r\n\r\n    export interface CustomTransformers {\r\n        /** Custom transformers to evaluate before built-in transformations. */\r\n        before?: TransformerFactory<SourceFile>[];\r\n        /** Custom transformers to evaluate after built-in transformations. */\r\n        after?: TransformerFactory<SourceFile>[];\r\n    }\r\n\r\n    export interface SourceMapSpan {\r\n        /** Line number in the .js file. */\r\n        emittedLine: number;\r\n        /** Column number in the .js file. */\r\n        emittedColumn: number;\r\n        /** Line number in the .ts file. */\r\n        sourceLine: number;\r\n        /** Column number in the .ts file. */\r\n        sourceColumn: number;\r\n        /** Optional name (index into names array) associated with this span. */\r\n        nameIndex?: number;\r\n        /** .ts file (index into sources array) associated with this span */\r\n        sourceIndex: number;\r\n    }\r\n\r\n    export interface SourceMapData {\r\n        sourceMapFilePath: string;           // Where the sourcemap file is written\r\n        jsSourceMappingURL: string;          // source map URL written in the .js file\r\n        sourceMapFile: string;               // Source map's file field - .js file name\r\n        sourceMapSourceRoot: string;         // Source map's sourceRoot field - location where the sources will be present if not \"\"\r\n        sourceMapSources: string[];          // Source map's sources field - list of sources that can be indexed in this source map\r\n        sourceMapSourcesContent?: string[];  // Source map's sourcesContent field - list of the sources' text to be embedded in the source map\r\n        inputSourceFileNames: string[];      // Input source file (which one can use on program to get the file), 1:1 mapping with the sourceMapSources list\r\n        sourceMapNames?: string[];           // Source map's names field - list of names that can be indexed in this source map\r\n        sourceMapMappings: string;           // Source map's mapping field - encoded source map spans\r\n        sourceMapDecodedMappings: SourceMapSpan[];  // Raw source map spans that were encoded into the sourceMapMappings\r\n    }\r\n\r\n    /** Return code used by getEmitOutput function to indicate status of the function */\r\n    export enum ExitStatus {\r\n        // Compiler ran successfully.  Either this was a simple do-nothing compilation (for example,\r\n        // when -version or -help was provided, or this was a normal compilation, no diagnostics\r\n        // were produced, and all outputs were generated successfully.\r\n        Success = 0,\r\n\r\n        // Diagnostics were produced and because of them no code was generated.\r\n        DiagnosticsPresent_OutputsSkipped = 1,\r\n\r\n        // Diagnostics were produced and outputs were generated in spite of them.\r\n        DiagnosticsPresent_OutputsGenerated = 2,\r\n    }\r\n\r\n    export interface EmitResult {\r\n        emitSkipped: boolean;\r\n        /** Contains declaration emit diagnostics */\r\n        diagnostics: ReadonlyArray<Diagnostic>;\r\n        emittedFiles: string[]; // Array of files the compiler wrote to disk\r\n        /* @internal */ sourceMaps: SourceMapData[];  // Array of sourceMapData if compiler emitted sourcemaps\r\n    }\r\n\r\n    /* @internal */\r\n    export interface TypeCheckerHost {\r\n        getCompilerOptions(): CompilerOptions;\r\n\r\n        getSourceFiles(): ReadonlyArray<SourceFile>;\r\n        getSourceFile(fileName: string): SourceFile | undefined;\r\n        getResolvedTypeReferenceDirectives(): ReadonlyMap<ResolvedTypeReferenceDirective>;\r\n    }\r\n\r\n    export interface TypeChecker {\r\n        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;\r\n        getDeclaredTypeOfSymbol(symbol: Symbol): Type;\r\n        getPropertiesOfType(type: Type): Symbol[];\r\n        getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;\r\n        getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;\r\n        getSignaturesOfType(type: Type, kind: SignatureKind): Signature[];\r\n        getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;\r\n        getBaseTypes(type: InterfaceType): BaseType[];\r\n        getBaseTypeOfLiteralType(type: Type): Type;\r\n        getWidenedType(type: Type): Type;\r\n        getReturnTypeOfSignature(signature: Signature): Type;\r\n        /**\r\n         * Gets the type of a parameter at a given position in a signature.\r\n         * Returns `any` if the index is not valid.\r\n         */\r\n        /* @internal */ getParameterType(signature: Signature, parameterIndex: number): Type;\r\n        getNullableType(type: Type, flags: TypeFlags): Type;\r\n        getNonNullableType(type: Type): Type;\r\n\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        typeToTypeNode(type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): TypeNode;\r\n        /* @internal */ typeToTypeNode(type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker): TypeNode; // tslint:disable-line unified-signatures\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): SignatureDeclaration & {typeArguments?: NodeArray<TypeNode>} | undefined;\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, kind: IndexKind, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): IndexSignatureDeclaration | undefined;\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): EntityName | undefined;\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): Expression | undefined;\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): NodeArray<TypeParameterDeclaration> | undefined;\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): ParameterDeclaration | undefined;\r\n        /** Note that the resulting nodes cannot be checked. */\r\n        typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): TypeParameterDeclaration | undefined;\r\n\r\n        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];\r\n        getSymbolAtLocation(node: Node): Symbol | undefined;\r\n        getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];\r\n        /**\r\n         * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.\r\n         * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.\r\n         */\r\n        getShorthandAssignmentValueSymbol(location: Node): Symbol | undefined;\r\n        getExportSpecifierLocalTargetSymbol(location: ExportSpecifier): Symbol | undefined;\r\n        /**\r\n         * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.\r\n         * Otherwise returns its input.\r\n         * For example, at `export type T = number;`:\r\n         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.\r\n         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.\r\n         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.\r\n         */\r\n        getExportSymbolOfSymbol(symbol: Symbol): Symbol;\r\n        getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;\r\n        getTypeAtLocation(node: Node): Type;\r\n        getTypeFromTypeNode(node: TypeNode): Type;\r\n\r\n        signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;\r\n        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\r\n        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;\r\n        typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\r\n\r\n        /* @internal */ writeSignature(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind, writer?: EmitTextWriter): string;\r\n        /* @internal */ writeType(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;\r\n        /* @internal */ writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags, writer?: EmitTextWriter): string;\r\n        /* @internal */ writeTypePredicate(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;\r\n\r\n        /**\r\n         * @deprecated Use the createX factory functions or XToY typechecker methods and `createPrinter` or the `xToString` methods instead\r\n         * This will be removed in a future version.\r\n         */\r\n        getSymbolDisplayBuilder(): SymbolDisplayBuilder;\r\n        getFullyQualifiedName(symbol: Symbol): string;\r\n        getAugmentedPropertiesOfType(type: Type): Symbol[];\r\n        getRootSymbols(symbol: Symbol): Symbol[];\r\n        getContextualType(node: Expression): Type | undefined;\r\n        /* @internal */ getContextualTypeForArgumentAtIndex(call: CallLikeExpression, argIndex: number): Type;\r\n        /* @internal */ getContextualTypeForJsxAttribute(attribute: JsxAttribute | JsxSpreadAttribute): Type | undefined;\r\n        /* @internal */ isContextSensitive(node: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike): boolean;\r\n\r\n        /**\r\n         * returns unknownSignature in the case of an error.\r\n         * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.\r\n         */\r\n        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature;\r\n        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;\r\n        isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;\r\n        isUndefinedSymbol(symbol: Symbol): boolean;\r\n        isArgumentsSymbol(symbol: Symbol): boolean;\r\n        isUnknownSymbol(symbol: Symbol): boolean;\r\n        /* @internal */ getMergedSymbol(symbol: Symbol): Symbol;\r\n\r\n        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;\r\n        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;\r\n        /** Exclude accesses to private properties or methods with a `this` parameter that `type` doesn't satisfy. */\r\n        /* @internal */ isValidPropertyAccessForCompletions(node: PropertyAccessExpression | ImportTypeNode, type: Type, property: Symbol): boolean;\r\n        /** Follow all aliases to get the original symbol. */\r\n        getAliasedSymbol(symbol: Symbol): Symbol;\r\n        /** Follow a *single* alias to get the immediately aliased symbol. */\r\n        /* @internal */ getImmediateAliasedSymbol(symbol: Symbol): Symbol;\r\n        getExportsOfModule(moduleSymbol: Symbol): Symbol[];\r\n        /** Unlike `getExportsOfModule`, this includes properties of an `export =` value. */\r\n        /* @internal */ getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[];\r\n\r\n        getAllAttributesTypeFromJsxOpeningLikeElement(elementNode: JsxOpeningLikeElement): Type | undefined;\r\n        getJsxIntrinsicTagNamesAt(location: Node): Symbol[];\r\n        isOptionalParameter(node: ParameterDeclaration): boolean;\r\n        getAmbientModules(): Symbol[];\r\n\r\n        tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;\r\n        /**\r\n         * Unlike `tryGetMemberInModuleExports`, this includes properties of an `export =` value.\r\n         * Does *not* return properties of primitive types.\r\n         */\r\n        /* @internal */ tryGetMemberInModuleExportsAndProperties(memberName: string, moduleSymbol: Symbol): Symbol | undefined;\r\n        getApparentType(type: Type): Type;\r\n        getSuggestionForNonexistentProperty(node: Identifier, containingType: Type): string | undefined;\r\n        getSuggestionForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): string | undefined;\r\n        getSuggestionForNonexistentModule(node: Identifier, target: Symbol): string | undefined;\r\n        getBaseConstraintOfType(type: Type): Type | undefined;\r\n        getDefaultFromTypeParameter(type: Type): Type | undefined;\r\n\r\n        /* @internal */ getAnyType(): Type;\r\n        /* @internal */ getStringType(): Type;\r\n        /* @internal */ getNumberType(): Type;\r\n        /* @internal */ getBooleanType(): Type;\r\n        /* @internal */ getVoidType(): Type;\r\n        /* @internal */ getUndefinedType(): Type;\r\n        /* @internal */ getNullType(): Type;\r\n        /* @internal */ getESSymbolType(): Type;\r\n        /* @internal */ getNeverType(): Type;\r\n        /* @internal */ getUnionType(types: Type[], subtypeReduction?: UnionReduction): Type;\r\n        /* @internal */ createArrayType(elementType: Type): Type;\r\n        /* @internal */ createPromiseType(type: Type): Type;\r\n\r\n        /* @internal */ createAnonymousType(symbol: Symbol, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], stringIndexInfo: IndexInfo, numberIndexInfo: IndexInfo): Type;\r\n        /* @internal */ createSignature(\r\n            declaration: SignatureDeclaration,\r\n            typeParameters: TypeParameter[],\r\n            thisParameter: Symbol | undefined,\r\n            parameters: Symbol[],\r\n            resolvedReturnType: Type,\r\n            typePredicate: TypePredicate | undefined,\r\n            minArgumentCount: number,\r\n            hasRestParameter: boolean,\r\n            hasLiteralTypes: boolean,\r\n        ): Signature;\r\n        /* @internal */ createSymbol(flags: SymbolFlags, name: __String): TransientSymbol;\r\n        /* @internal */ createIndexInfo(type: Type, isReadonly: boolean, declaration?: SignatureDeclaration): IndexInfo;\r\n        /* @internal */ isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;\r\n        /* @internal */ tryFindAmbientModuleWithoutAugmentations(moduleName: string): Symbol | undefined;\r\n\r\n        /* @internal */ getSymbolWalker(accept?: (symbol: Symbol) => boolean): SymbolWalker;\r\n\r\n        // Should not be called directly.  Should only be accessed through the Program instance.\r\n        /* @internal */ getDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[];\r\n        /* @internal */ getGlobalDiagnostics(): Diagnostic[];\r\n        /* @internal */ getEmitResolver(sourceFile?: SourceFile, cancellationToken?: CancellationToken): EmitResolver;\r\n\r\n        /* @internal */ getNodeCount(): number;\r\n        /* @internal */ getIdentifierCount(): number;\r\n        /* @internal */ getSymbolCount(): number;\r\n        /* @internal */ getTypeCount(): number;\r\n\r\n        /**\r\n         * For a union, will include a property if it's defined in *any* of the member types.\r\n         * So for `{ a } | { b }`, this will include both `a` and `b`.\r\n         * Does not include properties of primitive types.\r\n         */\r\n        /* @internal */ isArrayLikeType(type: Type): boolean;\r\n        /* @internal */ getAllPossiblePropertiesOfTypes(type: ReadonlyArray<Type>): Symbol[];\r\n        /* @internal */ resolveName(name: string, location: Node, meaning: SymbolFlags, excludeGlobals: boolean): Symbol | undefined;\r\n        /* @internal */ getJsxNamespace(location?: Node): string;\r\n\r\n        /**\r\n         * Note that this will return undefined in the following case:\r\n         *     // a.ts\r\n         *     export namespace N { export class C { } }\r\n         *     // b.ts\r\n         *     <<enclosingDeclaration>>\r\n         * Where `C` is the symbol we're looking for.\r\n         * This should be called in a loop climbing parents of the symbol, so we'll get `N`.\r\n         */\r\n        /* @internal */ getAccessibleSymbolChain(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, useOnlyExternalAliasing: boolean): Symbol[] | undefined;\r\n        /* @internal */ getTypePredicateOfSignature(signature: Signature): TypePredicate;\r\n        /* @internal */ resolveExternalModuleSymbol(symbol: Symbol): Symbol;\r\n        /** @param node A location where we might consider accessing `this`. Not necessarily a ThisExpression. */\r\n        /* @internal */ tryGetThisTypeAt(node: Node): Type | undefined;\r\n        /* @internal */ getTypeArgumentConstraint(node: TypeNode): Type | undefined;\r\n\r\n        /**\r\n         * Does *not* get *all* suggestion diagnostics, just the ones that were convenient to report in the checker.\r\n         * Others are added in computeSuggestionDiagnostics.\r\n         */\r\n        /* @internal */ getSuggestionDiagnostics(file: SourceFile): ReadonlyArray<Diagnostic>;\r\n\r\n        /**\r\n         * Depending on the operation performed, it may be appropriate to throw away the checker\r\n         * if the cancellation token is triggered. Typically, if it is used for error checking\r\n         * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.\r\n         */\r\n        runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum UnionReduction {\r\n        None = 0,\r\n        Literal,\r\n        Subtype\r\n    }\r\n\r\n    export const enum NodeBuilderFlags {\r\n        None                                    = 0,\r\n        // Options\r\n        NoTruncation                            = 1 << 0,   // Don't truncate result\r\n        WriteArrayAsGenericType                 = 1 << 1,   // Write Array<T> instead T[]\r\n        // empty space\r\n        UseStructuralFallback                   = 1 << 3,   // When an alias cannot be named by its symbol, rather than report an error, fallback to a structural printout if possible\r\n        // empty space\r\n        WriteTypeArgumentsOfSignature           = 1 << 5,   // Write the type arguments instead of type parameters of the signature\r\n        UseFullyQualifiedType                   = 1 << 6,   // Write out the fully qualified type name (eg. Module.Type, instead of Type)\r\n        UseOnlyExternalAliasing                 = 1 << 7,   // Only use external aliases for a symbol\r\n        SuppressAnyReturnType                   = 1 << 8,   // If the return type is any-like, don't offer a return type.\r\n        WriteTypeParametersInQualifiedName      = 1 << 9,\r\n        MultilineObjectLiterals                 = 1 << 10,  // Always write object literals across multiple lines\r\n        WriteClassExpressionAsTypeLiteral       = 1 << 11,  // Write class {} as { new(): {} } - used for mixin declaration emit\r\n        UseTypeOfFunction                       = 1 << 12,  // Build using typeof instead of function type literal\r\n        OmitParameterModifiers                  = 1 << 13,  // Omit modifiers on parameters\r\n        UseAliasDefinedOutsideCurrentScope      = 1 << 14,  // Allow non-visible aliases\r\n\r\n        // Error handling\r\n        AllowThisInObjectLiteral                = 1 << 15,\r\n        AllowQualifedNameInPlaceOfIdentifier    = 1 << 16,\r\n        AllowAnonymousIdentifier                = 1 << 17,\r\n        AllowEmptyUnionOrIntersection           = 1 << 18,\r\n        AllowEmptyTuple                         = 1 << 19,\r\n        AllowUniqueESSymbolType                 = 1 << 20,\r\n        AllowEmptyIndexInfoType                 = 1 << 21,\r\n\r\n        IgnoreErrors = AllowThisInObjectLiteral | AllowQualifedNameInPlaceOfIdentifier | AllowAnonymousIdentifier | AllowEmptyUnionOrIntersection | AllowEmptyTuple | AllowEmptyIndexInfoType,\r\n\r\n        // State\r\n        InObjectTypeLiteral                     = 1 << 22,\r\n        InTypeAlias                             = 1 << 23,    // Writing type in type alias declaration\r\n        InInitialEntityName                     = 1 << 24,    // Set when writing the LHS of an entity name or entity name expression\r\n        InReverseMappedType                     = 1 << 25,\r\n    }\r\n\r\n    // Ensure the shared flags between this and `NodeBuilderFlags` stay in alignment\r\n    export const enum TypeFormatFlags {\r\n        None                                    = 0,\r\n        NoTruncation                            = 1 << 0,  // Don't truncate typeToString result\r\n        WriteArrayAsGenericType                 = 1 << 1,  // Write Array<T> instead T[]\r\n        // hole because there's a hole in node builder flags\r\n        UseStructuralFallback                   = 1 << 3,   // When an alias cannot be named by its symbol, rather than report an error, fallback to a structural printout if possible\r\n        // hole because there's a hole in node builder flags\r\n        WriteTypeArgumentsOfSignature           = 1 << 5,  // Write the type arguments instead of type parameters of the signature\r\n        UseFullyQualifiedType                   = 1 << 6,  // Write out the fully qualified type name (eg. Module.Type, instead of Type)\r\n        // hole because `UseOnlyExternalAliasing` is here in node builder flags, but functions which take old flags use `SymbolFormatFlags` instead\r\n        SuppressAnyReturnType                   = 1 << 8,  // If the return type is any-like, don't offer a return type.\r\n        // hole because `WriteTypeParametersInQualifiedName` is here in node builder flags, but functions which take old flags use `SymbolFormatFlags` for this instead\r\n        MultilineObjectLiterals                 = 1 << 10, // Always print object literals across multiple lines (only used to map into node builder flags)\r\n        WriteClassExpressionAsTypeLiteral       = 1 << 11, // Write a type literal instead of (Anonymous class)\r\n        UseTypeOfFunction                       = 1 << 12, // Write typeof instead of function type literal\r\n        OmitParameterModifiers                  = 1 << 13, // Omit modifiers on parameters\r\n        UseAliasDefinedOutsideCurrentScope      = 1 << 14, // For a `type T = ... ` defined in a different file, write `T` instead of its value,\r\n                                                           // even though `T` can't be accessed in the current scope.\r\n\r\n        // Error Handling\r\n        AllowUniqueESSymbolType                 = 1 << 20, // This is bit 20 to align with the same bit in `NodeBuilderFlags`\r\n\r\n        // TypeFormatFlags exclusive\r\n        AddUndefined                            = 1 << 17, // Add undefined to types of initialized, non-optional parameters\r\n        WriteArrowStyleSignature                = 1 << 18, // Write arrow style signature\r\n\r\n        // State\r\n        InArrayType                             = 1 << 19, // Writing an array element type\r\n        InElementType                           = 1 << 21, // Writing an array or union element type\r\n        InFirstTypeArgument                     = 1 << 22, // Writing first type argument of the instantiated type\r\n        InTypeAlias                             = 1 << 23, // Writing type in type alias declaration\r\n\r\n        /** @deprecated */ WriteOwnNameForAnyLike  = 0,  // Does nothing\r\n\r\n        NodeBuilderFlagsMask =\r\n            NoTruncation | WriteArrayAsGenericType | UseStructuralFallback | WriteTypeArgumentsOfSignature |\r\n            UseFullyQualifiedType | SuppressAnyReturnType | MultilineObjectLiterals | WriteClassExpressionAsTypeLiteral |\r\n            UseTypeOfFunction | OmitParameterModifiers | UseAliasDefinedOutsideCurrentScope | AllowUniqueESSymbolType | InTypeAlias,\r\n    }\r\n\r\n    export const enum SymbolFormatFlags {\r\n        None = 0x00000000,\r\n\r\n        // Write symbols's type argument if it is instantiated symbol\r\n        // eg. class C<T> { p: T }   <-- Show p as C<T>.p here\r\n        //     var a: C<number>;\r\n        //     var p = a.p; <--- Here p is property of C<number> so show it as C<number>.p instead of just C.p\r\n        WriteTypeParametersOrArguments = 0x00000001,\r\n\r\n        // Use only external alias information to get the symbol name in the given context\r\n        // eg.  module m { export class c { } } import x = m.c;\r\n        // When this flag is specified m.c will be used to refer to the class instead of alias symbol x\r\n        UseOnlyExternalAliasing = 0x00000002,\r\n\r\n        // Build symbol name using any nodes needed, instead of just components of an entity name\r\n        AllowAnyNodeKind = 0x00000004,\r\n\r\n        // Prefer aliases which are not directly visible\r\n        UseAliasDefinedOutsideCurrentScope = 0x00000008,\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SymbolWalker {\r\n        /** Note: Return values are not ordered. */\r\n        walkType(root: Type): { visitedTypes: ReadonlyArray<Type>, visitedSymbols: ReadonlyArray<Symbol> };\r\n        /** Note: Return values are not ordered. */\r\n        walkSymbol(root: Symbol): { visitedTypes: ReadonlyArray<Type>, visitedSymbols: ReadonlyArray<Symbol> };\r\n    }\r\n\r\n    /**\r\n     * @deprecated\r\n     */\r\n    export interface SymbolDisplayBuilder {\r\n        /** @deprecated */ buildTypeDisplay(type: Type, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        /** @deprecated */ buildSymbolDisplay(symbol: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): void;\r\n        /** @deprecated */ buildSignatureDisplay(signature: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): void;\r\n        /** @deprecated */ buildIndexSignatureDisplay(info: IndexInfo, writer: SymbolWriter, kind: IndexKind, enclosingDeclaration?: Node, globalFlags?: TypeFormatFlags, symbolStack?: Symbol[]): void;\r\n        /** @deprecated */ buildParameterDisplay(parameter: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        /** @deprecated */ buildTypeParameterDisplay(tp: TypeParameter, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        /** @deprecated */ buildTypePredicateDisplay(predicate: TypePredicate, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        /** @deprecated */ buildTypeParameterDisplayFromSymbol(symbol: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        /** @deprecated */ buildDisplayForParametersAndDelimiters(thisParameter: Symbol, parameters: Symbol[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        /** @deprecated */ buildDisplayForTypeParametersAndDelimiters(typeParameters: TypeParameter[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n        /** @deprecated */ buildReturnTypeDisplay(signature: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Migrate to other methods of generating symbol names, ex symbolToEntityName + a printer or symbolToString\r\n     */\r\n    export interface SymbolWriter extends SymbolTracker {\r\n        writeKeyword(text: string): void;\r\n        writeOperator(text: string): void;\r\n        writePunctuation(text: string): void;\r\n        writeSpace(text: string): void;\r\n        writeStringLiteral(text: string): void;\r\n        writeParameter(text: string): void;\r\n        writeProperty(text: string): void;\r\n        writeSymbol(text: string, symbol: Symbol): void;\r\n        writeLine(): void;\r\n        increaseIndent(): void;\r\n        decreaseIndent(): void;\r\n        clear(): void;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum SymbolAccessibility {\r\n        Accessible,\r\n        NotAccessible,\r\n        CannotBeNamed\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum SyntheticSymbolKind {\r\n        UnionOrIntersection,\r\n        Spread\r\n    }\r\n\r\n    export const enum TypePredicateKind {\r\n        This,\r\n        Identifier\r\n    }\r\n\r\n    export interface TypePredicateBase {\r\n        kind: TypePredicateKind;\r\n        type: Type;\r\n    }\r\n\r\n    export interface ThisTypePredicate extends TypePredicateBase {\r\n        kind: TypePredicateKind.This;\r\n    }\r\n\r\n    export interface IdentifierTypePredicate extends TypePredicateBase {\r\n        kind: TypePredicateKind.Identifier;\r\n        parameterName: string;\r\n        parameterIndex: number;\r\n    }\r\n\r\n    export type TypePredicate = IdentifierTypePredicate | ThisTypePredicate;\r\n\r\n    /* @internal */\r\n    export type AnyImportSyntax = ImportDeclaration | ImportEqualsDeclaration;\r\n\r\n    /* @internal */\r\n    export type AnyImportOrReExport = AnyImportSyntax | ExportDeclaration;\r\n\r\n    /* @internal */\r\n    export type AnyValidImportOrReExport =\r\n        | (ImportDeclaration | ExportDeclaration) & { moduleSpecifier: StringLiteral }\r\n        | ImportEqualsDeclaration & { moduleReference: ExternalModuleReference & { expression: StringLiteral } }\r\n        | RequireOrImportCall\r\n        | ImportTypeNode & { argument: LiteralType };\r\n\r\n    /* @internal */\r\n    export type RequireOrImportCall = CallExpression & { arguments: [StringLiteralLike] };\r\n\r\n    /* @internal */\r\n    export type LateVisibilityPaintedStatement = AnyImportSyntax | VariableStatement;\r\n\r\n    /* @internal */\r\n    export interface SymbolVisibilityResult {\r\n        accessibility: SymbolAccessibility;\r\n        aliasesToMakeVisible?: LateVisibilityPaintedStatement[]; // aliases that need to have this symbol visible\r\n        errorSymbolName?: string; // Optional symbol name that results in error\r\n        errorNode?: Node; // optional node that results in error\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SymbolAccessibilityResult extends SymbolVisibilityResult {\r\n        errorModuleName?: string; // If the symbol is not visible from module, module's name\r\n    }\r\n\r\n    /** Indicates how to serialize the name for a TypeReferenceNode when emitting decorator metadata */\r\n    /* @internal */\r\n    export enum TypeReferenceSerializationKind {\r\n        Unknown,                            // The TypeReferenceNode could not be resolved. The type name\r\n                                            // should be emitted using a safe fallback.\r\n        TypeWithConstructSignatureAndValue, // The TypeReferenceNode resolves to a type with a constructor\r\n                                            // function that can be reached at runtime (e.g. a `class`\r\n                                            // declaration or a `var` declaration for the static side\r\n                                            // of a type, such as the global `Promise` type in lib.d.ts).\r\n        VoidNullableOrNeverType,            // The TypeReferenceNode resolves to a Void-like, Nullable, or Never type.\r\n        NumberLikeType,                     // The TypeReferenceNode resolves to a Number-like type.\r\n        StringLikeType,                     // The TypeReferenceNode resolves to a String-like type.\r\n        BooleanType,                        // The TypeReferenceNode resolves to a Boolean-like type.\r\n        ArrayLikeType,                      // The TypeReferenceNode resolves to an Array-like type.\r\n        ESSymbolType,                       // The TypeReferenceNode resolves to the ESSymbol type.\r\n        Promise,                            // The TypeReferenceNode resolved to the global Promise constructor symbol.\r\n        TypeWithCallSignature,              // The TypeReferenceNode resolves to a Function type or a type\r\n                                            // with call signatures.\r\n        ObjectType,                         // The TypeReferenceNode resolves to any other type.\r\n    }\r\n\r\n    /* @internal */\r\n    export interface EmitResolver {\r\n        hasGlobalName(name: string): boolean;\r\n        getReferencedExportContainer(node: Identifier, prefixLocals?: boolean): SourceFile | ModuleDeclaration | EnumDeclaration;\r\n        getReferencedImportDeclaration(node: Identifier): Declaration;\r\n        getReferencedDeclarationWithCollidingName(node: Identifier): Declaration;\r\n        isDeclarationWithCollidingName(node: Declaration): boolean;\r\n        isValueAliasDeclaration(node: Node): boolean;\r\n        isReferencedAliasDeclaration(node: Node, checkChildren?: boolean): boolean;\r\n        isTopLevelValueImportEqualsWithEntityName(node: ImportEqualsDeclaration): boolean;\r\n        getNodeCheckFlags(node: Node): NodeCheckFlags;\r\n        isDeclarationVisible(node: Declaration | AnyImportSyntax): boolean;\r\n        isLateBound(node: Declaration): node is LateBoundDeclaration;\r\n        collectLinkedAliases(node: Identifier): Node[];\r\n        isImplementationOfOverload(node: FunctionLike): boolean | undefined;\r\n        isRequiredInitializedParameter(node: ParameterDeclaration): boolean;\r\n        isOptionalUninitializedParameterProperty(node: ParameterDeclaration): boolean;\r\n        createTypeOfDeclaration(declaration: AccessorDeclaration | VariableLikeDeclaration, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker, addUndefined?: boolean): TypeNode;\r\n        createReturnTypeOfSignatureDeclaration(signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker): TypeNode;\r\n        createTypeOfExpression(expr: Expression, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker): TypeNode;\r\n        createLiteralConstValue(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration): Expression;\r\n        isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;\r\n        isEntityNameVisible(entityName: EntityNameOrEntityNameExpression, enclosingDeclaration: Node): SymbolVisibilityResult;\r\n        // Returns the constant value this property access resolves to, or 'undefined' for a non-constant\r\n        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number;\r\n        getReferencedValueDeclaration(reference: Identifier): Declaration;\r\n        getTypeReferenceSerializationKind(typeName: EntityName, location?: Node): TypeReferenceSerializationKind;\r\n        isOptionalParameter(node: ParameterDeclaration): boolean;\r\n        moduleExportsSomeValue(moduleReferenceExpression: Expression): boolean;\r\n        isArgumentsLocalBinding(node: Identifier): boolean;\r\n        getExternalModuleFileFromDeclaration(declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration | ImportTypeNode): SourceFile;\r\n        getTypeReferenceDirectivesForEntityName(name: EntityNameOrEntityNameExpression): string[];\r\n        getTypeReferenceDirectivesForSymbol(symbol: Symbol, meaning?: SymbolFlags): string[];\r\n        isLiteralConstDeclaration(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration): boolean;\r\n        getJsxFactoryEntity(location?: Node): EntityName;\r\n    }\r\n\r\n    export const enum SymbolFlags {\r\n        None                    = 0,\r\n        FunctionScopedVariable  = 1 << 0,   // Variable (var) or parameter\r\n        BlockScopedVariable     = 1 << 1,   // A block-scoped variable (let or const)\r\n        Property                = 1 << 2,   // Property or enum member\r\n        EnumMember              = 1 << 3,   // Enum member\r\n        Function                = 1 << 4,   // Function\r\n        Class                   = 1 << 5,   // Class\r\n        Interface               = 1 << 6,   // Interface\r\n        ConstEnum               = 1 << 7,   // Const enum\r\n        RegularEnum             = 1 << 8,   // Enum\r\n        ValueModule             = 1 << 9,   // Instantiated module\r\n        NamespaceModule         = 1 << 10,  // Uninstantiated module\r\n        TypeLiteral             = 1 << 11,  // Type Literal or mapped type\r\n        ObjectLiteral           = 1 << 12,  // Object Literal\r\n        Method                  = 1 << 13,  // Method\r\n        Constructor             = 1 << 14,  // Constructor\r\n        GetAccessor             = 1 << 15,  // Get accessor\r\n        SetAccessor             = 1 << 16,  // Set accessor\r\n        Signature               = 1 << 17,  // Call, construct, or index signature\r\n        TypeParameter           = 1 << 18,  // Type parameter\r\n        TypeAlias               = 1 << 19,  // Type alias\r\n        ExportValue             = 1 << 20,  // Exported value marker (see comment in declareModuleMember in binder)\r\n        Alias                   = 1 << 21,  // An alias for another symbol (see comment in isAliasSymbolDeclaration in checker)\r\n        Prototype               = 1 << 22,  // Prototype property (no source representation)\r\n        ExportStar              = 1 << 23,  // Export * declaration\r\n        Optional                = 1 << 24,  // Optional property\r\n        Transient               = 1 << 25,  // Transient symbol (created during type check)\r\n        JSContainer             = 1 << 26,  // Contains Javascript special declarations\r\n\r\n        /* @internal */\r\n        All = FunctionScopedVariable | BlockScopedVariable | Property | EnumMember | Function | Class | Interface | ConstEnum | RegularEnum | ValueModule | NamespaceModule | TypeLiteral\r\n            | ObjectLiteral | Method | Constructor | GetAccessor | SetAccessor | Signature | TypeParameter | TypeAlias | ExportValue | Alias | Prototype | ExportStar | Optional | Transient,\r\n\r\n        Enum = RegularEnum | ConstEnum,\r\n        Variable = FunctionScopedVariable | BlockScopedVariable,\r\n        Value = Variable | Property | EnumMember | Function | Class | Enum | ValueModule | Method | GetAccessor | SetAccessor | JSContainer,\r\n        Type = Class | Interface | Enum | EnumMember | TypeLiteral | ObjectLiteral | TypeParameter | TypeAlias | JSContainer,\r\n        Namespace = ValueModule | NamespaceModule | Enum,\r\n        Module = ValueModule | NamespaceModule,\r\n        Accessor = GetAccessor | SetAccessor,\r\n\r\n        // Variables can be redeclared, but can not redeclare a block-scoped declaration with the\r\n        // same name, or any other value that is not a variable, e.g. ValueModule or Class\r\n        FunctionScopedVariableExcludes = Value & ~FunctionScopedVariable,\r\n\r\n        // Block-scoped declarations are not allowed to be re-declared\r\n        // they can not merge with anything in the value space\r\n        BlockScopedVariableExcludes = Value,\r\n\r\n        ParameterExcludes = Value,\r\n        PropertyExcludes = None,\r\n        EnumMemberExcludes = Value | Type,\r\n        FunctionExcludes = Value & ~(Function | ValueModule),\r\n        ClassExcludes = (Value | Type) & ~(ValueModule | Interface), // class-interface mergability done in checker.ts\r\n        InterfaceExcludes = Type & ~(Interface | Class),\r\n        RegularEnumExcludes = (Value | Type) & ~(RegularEnum | ValueModule), // regular enums merge only with regular enums and modules\r\n        ConstEnumExcludes = (Value | Type) & ~ConstEnum, // const enums merge only with const enums\r\n        ValueModuleExcludes = Value & ~(Function | Class | RegularEnum | ValueModule),\r\n        NamespaceModuleExcludes = 0,\r\n        MethodExcludes = Value & ~Method,\r\n        GetAccessorExcludes = Value & ~SetAccessor,\r\n        SetAccessorExcludes = Value & ~GetAccessor,\r\n        TypeParameterExcludes = Type & ~TypeParameter,\r\n        TypeAliasExcludes = Type,\r\n        AliasExcludes = Alias,\r\n\r\n        ModuleMember = Variable | Function | Class | Interface | Enum | Module | TypeAlias | Alias,\r\n\r\n        ExportHasLocal = Function | Class | Enum | ValueModule,\r\n\r\n        HasExports = Class | Enum | Module,\r\n        HasMembers = Class | Interface | TypeLiteral | ObjectLiteral,\r\n\r\n        BlockScoped = BlockScopedVariable | Class | Enum,\r\n\r\n        PropertyOrAccessor = Property | Accessor,\r\n\r\n        ClassMember = Method | Accessor | Property,\r\n\r\n        /* @internal */\r\n        // The set of things we consider semantically classifiable.  Used to speed up the LS during\r\n        // classification.\r\n        Classifiable = Class | Enum | TypeAlias | Interface | TypeParameter | Module | Alias,\r\n\r\n        /* @internal */\r\n        LateBindingContainer = Class | Interface | TypeLiteral | ObjectLiteral,\r\n    }\r\n\r\n    export interface Symbol {\r\n        flags: SymbolFlags;                     // Symbol flags\r\n        escapedName: __String;                  // Name of symbol\r\n        declarations?: Declaration[];           // Declarations associated with this symbol\r\n        valueDeclaration?: Declaration;         // First value declaration of the symbol\r\n        members?: SymbolTable;                  // Class, interface or object literal instance members\r\n        exports?: SymbolTable;                  // Module exports\r\n        globalExports?: SymbolTable;            // Conditional global UMD exports\r\n        /* @internal */ id?: number;            // Unique id (used to look up SymbolLinks)\r\n        /* @internal */ mergeId?: number;       // Merge id (used to look up merged symbol)\r\n        /* @internal */ parent?: Symbol;        // Parent symbol\r\n        /* @internal */ exportSymbol?: Symbol;  // Exported symbol associated with this symbol\r\n        /* @internal */ nameType?: Type;        // Type associated with a late-bound symbol\r\n        /* @internal */ constEnumOnlyModule?: boolean; // True if module contains only const enums or other modules with only const enums\r\n        /* @internal */ isReferenced?: SymbolFlags; // True if the symbol is referenced elsewhere. Keeps track of the meaning of a reference in case a symbol is both a type parameter and parameter.\r\n        /* @internal */ isReplaceableByMethod?: boolean; // Can this Javascript class property be replaced by a method symbol?\r\n        /* @internal */ isAssigned?: boolean;   // True if the symbol is a parameter with assignments\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SymbolLinks {\r\n        immediateTarget?: Symbol;           // Immediate target of an alias. May be another alias. Do not access directly, use `checker.getImmediateAliasedSymbol` instead.\r\n        target?: Symbol;                    // Resolved (non-alias) target of an alias\r\n        type?: Type;                        // Type of value symbol\r\n        uniqueESSymbolType?: Type;          // UniqueESSymbol type for a symbol\r\n        declaredType?: Type;                // Type of class, interface, enum, type alias, or type parameter\r\n        typeParameters?: TypeParameter[];   // Type parameters of type alias (undefined if non-generic)\r\n        outerTypeParameters?: TypeParameter[];  // Outer type parameters of anonymous object type\r\n        inferredClassType?: Type;           // Type of an inferred ES5 class\r\n        instantiations?: Map<Type>;         // Instantiations of generic type alias (undefined if non-generic)\r\n        mapper?: TypeMapper;                // Type mapper for instantiation alias\r\n        referenced?: boolean;               // True if alias symbol has been referenced as a value\r\n        containingType?: UnionOrIntersectionType; // Containing union or intersection type for synthetic property\r\n        leftSpread?: Symbol;                // Left source for synthetic spread property\r\n        rightSpread?: Symbol;               // Right source for synthetic spread property\r\n        syntheticOrigin?: Symbol;           // For a property on a mapped or spread type, points back to the original property\r\n        isDiscriminantProperty?: boolean;   // True if discriminant synthetic property\r\n        resolvedExports?: SymbolTable;      // Resolved exports of module or combined early- and late-bound static members of a class.\r\n        resolvedMembers?: SymbolTable;      // Combined early- and late-bound members of a symbol\r\n        exportsChecked?: boolean;           // True if exports of external module have been checked\r\n        typeParametersChecked?: boolean;    // True if type parameters of merged class and interface declarations have been checked.\r\n        isDeclarationWithCollidingName?: boolean;   // True if symbol is block scoped redeclaration\r\n        bindingElement?: BindingElement;    // Binding element associated with property symbol\r\n        exportsSomeValue?: boolean;         // True if module exports some value (not just types)\r\n        enumKind?: EnumKind;                // Enum declaration classification\r\n        originatingImport?: ImportDeclaration | ImportCall; // Import declaration which produced the symbol, present if the symbol is marked as uncallable but had call signatures in `resolveESModuleSymbol`\r\n        lateSymbol?: Symbol;                // Late-bound symbol for a computed property\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum EnumKind {\r\n        Numeric,                            // Numeric enum (each member has a TypeFlags.Enum type)\r\n        Literal                             // Literal enum (each member has a TypeFlags.EnumLiteral type)\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum CheckFlags {\r\n        Instantiated      = 1 << 0,         // Instantiated symbol\r\n        SyntheticProperty = 1 << 1,         // Property in union or intersection type\r\n        SyntheticMethod   = 1 << 2,         // Method in union or intersection type\r\n        Readonly          = 1 << 3,         // Readonly transient symbol\r\n        Partial           = 1 << 4,         // Synthetic property present in some but not all constituents\r\n        HasNonUniformType = 1 << 5,         // Synthetic property with non-uniform type in constituents\r\n        ContainsPublic    = 1 << 6,         // Synthetic property with public constituent(s)\r\n        ContainsProtected = 1 << 7,         // Synthetic property with protected constituent(s)\r\n        ContainsPrivate   = 1 << 8,         // Synthetic property with private constituent(s)\r\n        ContainsStatic    = 1 << 9,         // Synthetic property with static constituent(s)\r\n        Late              = 1 << 10,        // Late-bound symbol for a computed property with a dynamic name\r\n        ReverseMapped     = 1 << 11,        // property of reverse-inferred homomorphic mapped type.\r\n        Synthetic = SyntheticProperty | SyntheticMethod\r\n    }\r\n\r\n    /* @internal */\r\n    export interface TransientSymbol extends Symbol, SymbolLinks {\r\n        checkFlags: CheckFlags;\r\n        isRestParameter?: boolean;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface ReverseMappedSymbol extends TransientSymbol {\r\n        propertyType: Type;\r\n        mappedType: MappedType;\r\n    }\r\n\r\n    export const enum InternalSymbolName {\r\n        Call = \"__call\", // Call signatures\r\n        Constructor = \"__constructor\", // Constructor implementations\r\n        New = \"__new\", // Constructor signatures\r\n        Index = \"__index\", // Index signatures\r\n        ExportStar = \"__export\", // Module export * declarations\r\n        Global = \"__global\", // Global self-reference\r\n        Missing = \"__missing\", // Indicates missing symbol\r\n        Type = \"__type\", // Anonymous type literal symbol\r\n        Object = \"__object\", // Anonymous object literal declaration\r\n        JSXAttributes = \"__jsxAttributes\", // Anonymous JSX attributes object literal declaration\r\n        Class = \"__class\", // Unnamed class expression\r\n        Function = \"__function\", // Unnamed function expression\r\n        Computed = \"__computed\", // Computed property name declaration with dynamic name\r\n        Resolving = \"__resolving__\", // Indicator symbol used to mark partially resolved type aliases\r\n        ExportEquals = \"export=\", // Export assignment symbol\r\n        Default = \"default\", // Default export symbol (technically not wholly internal, but included here for usability)\r\n    }\r\n\r\n    /**\r\n     * This represents a string whose leading underscore have been escaped by adding extra leading underscores.\r\n     * The shape of this brand is rather unique compared to others we've used.\r\n     * Instead of just an intersection of a string and an object, it is that union-ed\r\n     * with an intersection of void and an object. This makes it wholly incompatible\r\n     * with a normal string (which is good, it cannot be misused on assignment or on usage),\r\n     * while still being comparable with a normal string via === (also good) and castable from a string.\r\n     */\r\n    export type __String = (string & { __escapedIdentifier: void }) | (void & { __escapedIdentifier: void }) | InternalSymbolName;\r\n\r\n    /** ReadonlyMap where keys are `__String`s. */\r\n    export interface ReadonlyUnderscoreEscapedMap<T> {\r\n        get(key: __String): T | undefined;\r\n        has(key: __String): boolean;\r\n        forEach(action: (value: T, key: __String) => void): void;\r\n        readonly size: number;\r\n        keys(): Iterator<__String>;\r\n        values(): Iterator<T>;\r\n        entries(): Iterator<[__String, T]>;\r\n    }\r\n\r\n    /** Map where keys are `__String`s. */\r\n    export interface UnderscoreEscapedMap<T> extends ReadonlyUnderscoreEscapedMap<T> {\r\n        set(key: __String, value: T): this;\r\n        delete(key: __String): boolean;\r\n        clear(): void;\r\n    }\r\n\r\n    /** SymbolTable based on ES6 Map interface. */\r\n    export type SymbolTable = UnderscoreEscapedMap<Symbol>;\r\n\r\n    /** Represents a \"prefix*suffix\" pattern. */\r\n    /* @internal */\r\n    export interface Pattern {\r\n        prefix: string;\r\n        suffix: string;\r\n    }\r\n\r\n    /** Used to track a `declare module \"foo*\"`-like declaration. */\r\n    /* @internal */\r\n    export interface PatternAmbientModule {\r\n        pattern: Pattern;\r\n        symbol: Symbol;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum NodeCheckFlags {\r\n        TypeChecked                         = 0x00000001,  // Node has been type checked\r\n        LexicalThis                         = 0x00000002,  // Lexical 'this' reference\r\n        CaptureThis                         = 0x00000004,  // Lexical 'this' used in body\r\n        CaptureNewTarget                    = 0x00000008,  // Lexical 'new.target' used in body\r\n        SuperInstance                       = 0x00000100,  // Instance 'super' reference\r\n        SuperStatic                         = 0x00000200,  // Static 'super' reference\r\n        ContextChecked                      = 0x00000400,  // Contextual types have been assigned\r\n        AsyncMethodWithSuper                = 0x00000800,  // An async method that reads a value from a member of 'super'.\r\n        AsyncMethodWithSuperBinding         = 0x00001000,  // An async method that assigns a value to a member of 'super'.\r\n        CaptureArguments                    = 0x00002000,  // Lexical 'arguments' used in body\r\n        EnumValuesComputed                  = 0x00004000,  // Values for enum members have been computed, and any errors have been reported for them.\r\n        LexicalModuleMergesWithClass        = 0x00008000,  // Instantiated lexical module declaration is merged with a previous class declaration.\r\n        LoopWithCapturedBlockScopedBinding  = 0x00010000,  // Loop that contains block scoped variable captured in closure\r\n        CapturedBlockScopedBinding          = 0x00020000,  // Block-scoped binding that is captured in some function\r\n        BlockScopedBindingInLoop            = 0x00040000,  // Block-scoped binding with declaration nested inside iteration statement\r\n        ClassWithBodyScopedClassBinding     = 0x00080000,  // Decorated class that contains a binding to itself inside of the class body.\r\n        BodyScopedClassBinding              = 0x00100000,  // Binding to a decorated class inside of the class's body.\r\n        NeedsLoopOutParameter               = 0x00200000,  // Block scoped binding whose value should be explicitly copied outside of the converted loop\r\n        AssignmentsMarked                   = 0x00400000,  // Parameter assignments have been marked\r\n        ClassWithConstructorReference       = 0x00800000,  // Class that contains a binding to its constructor inside of the class body.\r\n        ConstructorReferenceInClass         = 0x01000000,  // Binding to a class constructor inside of the class's body.\r\n    }\r\n\r\n    /* @internal */\r\n    export interface NodeLinks {\r\n        flags?: NodeCheckFlags;           // Set of flags specific to Node\r\n        resolvedType?: Type;              // Cached type of type node\r\n        resolvedSignature?: Signature;    // Cached signature of signature node or call expression\r\n        resolvedSymbol?: Symbol;          // Cached name resolution result\r\n        resolvedIndexInfo?: IndexInfo;    // Cached indexing info resolution result\r\n        maybeTypePredicate?: boolean;     // Cached check whether call expression might reference a type predicate\r\n        enumMemberValue?: string | number;  // Constant value of enum member\r\n        isVisible?: boolean;              // Is this node visible\r\n        containsArgumentsReference?: boolean; // Whether a function-like declaration contains an 'arguments' reference\r\n        hasReportedStatementInAmbientContext?: boolean;  // Cache boolean if we report statements in ambient context\r\n        jsxFlags?: JsxFlags;              // flags for knowing what kind of element/attributes we're dealing with\r\n        resolvedJsxElementAttributesType?: Type;  // resolved element attributes type of a JSX openinglike element\r\n        resolvedJsxElementAllAttributesType?: Type;  // resolved all element attributes type of a JSX openinglike element\r\n        hasSuperCall?: boolean;           // recorded result when we try to find super-call. We only try to find one if this flag is undefined, indicating that we haven't made an attempt.\r\n        superCall?: SuperCall;  // Cached first super-call found in the constructor. Used in checking whether super is called before this-accessing\r\n        switchTypes?: Type[];             // Cached array of switch case expression types\r\n    }\r\n\r\n    export const enum TypeFlags {\r\n        Any                     = 1 << 0,\r\n        String                  = 1 << 1,\r\n        Number                  = 1 << 2,\r\n        Boolean                 = 1 << 3,\r\n        Enum                    = 1 << 4,\r\n        StringLiteral           = 1 << 5,\r\n        NumberLiteral           = 1 << 6,\r\n        BooleanLiteral          = 1 << 7,\r\n        EnumLiteral             = 1 << 8,   // Always combined with StringLiteral, NumberLiteral, or Union\r\n        ESSymbol                = 1 << 9,   // Type of symbol primitive introduced in ES6\r\n        UniqueESSymbol          = 1 << 10,  // unique symbol\r\n        Void                    = 1 << 11,\r\n        Undefined               = 1 << 12,\r\n        Null                    = 1 << 13,\r\n        Never                   = 1 << 14,  // Never type\r\n        TypeParameter           = 1 << 15,  // Type parameter\r\n        Object                  = 1 << 16,  // Object type\r\n        Union                   = 1 << 17,  // Union (T | U)\r\n        Intersection            = 1 << 18,  // Intersection (T & U)\r\n        Index                   = 1 << 19,  // keyof T\r\n        IndexedAccess           = 1 << 20,  // T[K]\r\n        Conditional             = 1 << 21,  // T extends U ? X : Y\r\n        Substitution            = 1 << 22,  // Type parameter substitution\r\n        /* @internal */\r\n        FreshLiteral            = 1 << 23,  // Fresh literal or unique type\r\n        /* @internal */\r\n        ContainsWideningType    = 1 << 24,  // Type is or contains undefined or null widening type\r\n        /* @internal */\r\n        ContainsObjectLiteral   = 1 << 25,  // Type is or contains object literal type\r\n        /* @internal */\r\n        ContainsAnyFunctionType = 1 << 26,  // Type is or contains the anyFunctionType\r\n        NonPrimitive            = 1 << 27,  // intrinsic object type\r\n        /* @internal */\r\n        GenericMappedType       = 1 << 29,  // Flag used by maybeTypeOfKind\r\n\r\n        /* @internal */\r\n        Nullable = Undefined | Null,\r\n        Literal = StringLiteral | NumberLiteral | BooleanLiteral,\r\n        Unit = Literal | UniqueESSymbol | Nullable,\r\n        StringOrNumberLiteral = StringLiteral | NumberLiteral,\r\n        /* @internal */\r\n        StringOrNumberLiteralOrUnique = StringOrNumberLiteral | UniqueESSymbol,\r\n        /* @internal */\r\n        DefinitelyFalsy = StringLiteral | NumberLiteral | BooleanLiteral | Void | Undefined | Null,\r\n        PossiblyFalsy = DefinitelyFalsy | String | Number | Boolean,\r\n        /* @internal */\r\n        Intrinsic = Any | String | Number | Boolean | BooleanLiteral | ESSymbol | Void | Undefined | Null | Never | NonPrimitive,\r\n        /* @internal */\r\n        Primitive = String | Number | Boolean | Enum | EnumLiteral | ESSymbol | Void | Undefined | Null | Literal | UniqueESSymbol,\r\n        StringLike = String | StringLiteral,\r\n        NumberLike = Number | NumberLiteral | Enum,\r\n        BooleanLike = Boolean | BooleanLiteral,\r\n        EnumLike = Enum | EnumLiteral,\r\n        ESSymbolLike = ESSymbol | UniqueESSymbol,\r\n        VoidLike = Void | Undefined,\r\n        /* @internal */\r\n        DisjointDomains = NonPrimitive | StringLike | NumberLike | BooleanLike | ESSymbolLike | VoidLike | Null,\r\n        UnionOrIntersection = Union | Intersection,\r\n        StructuredType = Object | Union | Intersection,\r\n        TypeVariable = TypeParameter | IndexedAccess,\r\n        InstantiableNonPrimitive = TypeVariable | Conditional | Substitution,\r\n        InstantiablePrimitive = Index,\r\n        Instantiable = InstantiableNonPrimitive | InstantiablePrimitive,\r\n        StructuredOrInstantiable = StructuredType | Instantiable,\r\n\r\n        // 'Narrowable' types are types where narrowing actually narrows.\r\n        // This *should* be every type other than null, undefined, void, and never\r\n        Narrowable = Any | StructuredOrInstantiable | StringLike | NumberLike | BooleanLike | ESSymbol | UniqueESSymbol | NonPrimitive,\r\n        NotUnionOrUnit = Any | ESSymbol | Object | NonPrimitive,\r\n        /* @internal */\r\n        RequiresWidening = ContainsWideningType | ContainsObjectLiteral,\r\n        /* @internal */\r\n        PropagatingFlags = ContainsWideningType | ContainsObjectLiteral | ContainsAnyFunctionType,\r\n        // The following flags are used for different purposes during union and intersection type construction\r\n        /* @internal */\r\n        NonWideningType = ContainsWideningType,\r\n        /* @internal */\r\n        Wildcard = ContainsObjectLiteral,\r\n        /* @internal */\r\n        EmptyObject = ContainsAnyFunctionType,\r\n        /* @internal */\r\n        ConstructionFlags = NonWideningType | Wildcard | EmptyObject\r\n    }\r\n\r\n    export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;\r\n\r\n    // Properties common to all types\r\n    export interface Type {\r\n        flags: TypeFlags;                // Flags\r\n        /* @internal */ id: number;      // Unique ID\r\n        /* @internal */ checker: TypeChecker;\r\n        symbol?: Symbol;                 // Symbol associated with type (if any)\r\n        pattern?: DestructuringPattern;  // Destructuring pattern represented by type (if any)\r\n        aliasSymbol?: Symbol;            // Alias associated with type\r\n        aliasTypeArguments?: Type[];     // Alias type arguments (if any)\r\n        /* @internal */\r\n        wildcardInstantiation?: Type;    // Instantiation with type parameters mapped to wildcard type\r\n    }\r\n\r\n    /* @internal */\r\n    // Intrinsic types (TypeFlags.Intrinsic)\r\n    export interface IntrinsicType extends Type {\r\n        intrinsicName: string;        // Name of intrinsic type\r\n    }\r\n\r\n    // String literal types (TypeFlags.StringLiteral)\r\n    // Numeric literal types (TypeFlags.NumberLiteral)\r\n    export interface LiteralType extends Type {\r\n        value: string | number;     // Value of literal\r\n        freshType?: LiteralType;    // Fresh version of type\r\n        regularType?: LiteralType;  // Regular version of type\r\n    }\r\n\r\n    // Unique symbol types (TypeFlags.UniqueESSymbol)\r\n    export interface UniqueESSymbolType extends Type {\r\n        symbol: Symbol;\r\n    }\r\n\r\n    export interface StringLiteralType extends LiteralType {\r\n        value: string;\r\n    }\r\n\r\n    export interface NumberLiteralType extends LiteralType {\r\n        value: number;\r\n    }\r\n\r\n    // Enum types (TypeFlags.Enum)\r\n    export interface EnumType extends Type {\r\n    }\r\n\r\n    export const enum ObjectFlags {\r\n        Class            = 1 << 0,  // Class\r\n        Interface        = 1 << 1,  // Interface\r\n        Reference        = 1 << 2,  // Generic type reference\r\n        Tuple            = 1 << 3,  // Synthesized generic tuple type\r\n        Anonymous        = 1 << 4,  // Anonymous\r\n        Mapped           = 1 << 5,  // Mapped\r\n        Instantiated     = 1 << 6,  // Instantiated anonymous or mapped type\r\n        ObjectLiteral    = 1 << 7,  // Originates in an object literal\r\n        EvolvingArray    = 1 << 8,  // Evolving array type\r\n        ObjectLiteralPatternWithComputedProperties = 1 << 9,  // Object literal pattern with computed properties\r\n        ContainsSpread   = 1 << 10, // Object literal contains spread operation\r\n        ReverseMapped    = 1 << 11, // Object contains a property from a reverse-mapped type\r\n        JsxAttributes    = 1 << 12, // Jsx attributes type\r\n        MarkerType       = 1 << 13, // Marker type used for variance probing\r\n        ClassOrInterface = Class | Interface\r\n    }\r\n\r\n    // Object types (TypeFlags.ObjectType)\r\n    export interface ObjectType extends Type {\r\n        objectFlags: ObjectFlags;\r\n    }\r\n\r\n    /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */\r\n    export interface InterfaceType extends ObjectType {\r\n        typeParameters: TypeParameter[];           // Type parameters (undefined if non-generic)\r\n        outerTypeParameters: TypeParameter[];      // Outer type parameters (undefined if none)\r\n        localTypeParameters: TypeParameter[];      // Local type parameters (undefined if none)\r\n        thisType: TypeParameter;                   // The \"this\" type (undefined if none)\r\n        /* @internal */\r\n        resolvedBaseConstructorType?: Type;        // Resolved base constructor type of class\r\n        /* @internal */\r\n        resolvedBaseTypes: BaseType[];             // Resolved base types\r\n    }\r\n\r\n    // Object type or intersection of object types\r\n    export type BaseType = ObjectType | IntersectionType;\r\n\r\n    export interface InterfaceTypeWithDeclaredMembers extends InterfaceType {\r\n        declaredProperties: Symbol[];              // Declared members\r\n        declaredCallSignatures: Signature[];       // Declared call signatures\r\n        declaredConstructSignatures: Signature[];  // Declared construct signatures\r\n        declaredStringIndexInfo: IndexInfo;        // Declared string indexing info\r\n        declaredNumberIndexInfo: IndexInfo;        // Declared numeric indexing info\r\n    }\r\n\r\n    /**\r\n     * Type references (ObjectFlags.Reference). When a class or interface has type parameters or\r\n     * a \"this\" type, references to the class or interface are made using type references. The\r\n     * typeArguments property specifies the types to substitute for the type parameters of the\r\n     * class or interface and optionally includes an extra element that specifies the type to\r\n     * substitute for \"this\" in the resulting instantiation. When no extra argument is present,\r\n     * the type reference itself is substituted for \"this\". The typeArguments property is undefined\r\n     * if the class or interface has no type parameters and the reference isn't specifying an\r\n     * explicit \"this\" argument.\r\n     */\r\n    export interface TypeReference extends ObjectType {\r\n        target: GenericType;    // Type reference target\r\n        typeArguments?: Type[];  // Type reference type arguments (undefined if none)\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum Variance {\r\n        Invariant     = 0,  // Neither covariant nor contravariant\r\n        Covariant     = 1,  // Covariant\r\n        Contravariant = 2,  // Contravariant\r\n        Bivariant     = 3,  // Both covariant and contravariant\r\n        Independent   = 4,  // Unwitnessed type parameter\r\n    }\r\n\r\n    // Generic class and interface types\r\n    export interface GenericType extends InterfaceType, TypeReference {\r\n        /* @internal */\r\n        instantiations: Map<TypeReference>;  // Generic instantiation cache\r\n        /* @internal */\r\n        variances?: Variance[];  // Variance of each type parameter\r\n    }\r\n\r\n    export interface UnionOrIntersectionType extends Type {\r\n        types: Type[];                    // Constituent types\r\n        /* @internal */\r\n        propertyCache: SymbolTable;       // Cache of resolved properties\r\n        /* @internal */\r\n        resolvedProperties: Symbol[];\r\n        /* @internal */\r\n        resolvedIndexType: IndexType;\r\n        /* @internal */\r\n        resolvedStringIndexType: IndexType;\r\n        /* @internal */\r\n        resolvedBaseConstraint: Type;\r\n        /* @internal */\r\n        couldContainTypeVariables: boolean;\r\n    }\r\n\r\n    export interface UnionType extends UnionOrIntersectionType { }\r\n\r\n    export interface IntersectionType extends UnionOrIntersectionType {\r\n        /* @internal */\r\n        resolvedApparentType: Type;\r\n    }\r\n\r\n    export type StructuredType = ObjectType | UnionType | IntersectionType;\r\n\r\n    /* @internal */\r\n    // An instantiated anonymous type has a target and a mapper\r\n    export interface AnonymousType extends ObjectType {\r\n        target?: AnonymousType;  // Instantiation target\r\n        mapper?: TypeMapper;     // Instantiation mapper\r\n    }\r\n\r\n    /* @internal */\r\n    export interface MappedType extends AnonymousType {\r\n        declaration: MappedTypeNode;\r\n        typeParameter?: TypeParameter;\r\n        constraintType?: Type;\r\n        templateType?: Type;\r\n        modifiersType?: Type;\r\n    }\r\n\r\n    export interface EvolvingArrayType extends ObjectType {\r\n        elementType: Type;      // Element expressions of evolving array type\r\n        finalArrayType?: Type;  // Final array type of evolving array type\r\n    }\r\n\r\n    /* @internal */\r\n    export interface ReverseMappedType extends ObjectType {\r\n        source: Type;\r\n        mappedType: MappedType;\r\n    }\r\n\r\n    /* @internal */\r\n    // Resolved object, union, or intersection type\r\n    export interface ResolvedType extends ObjectType, UnionOrIntersectionType {\r\n        members: SymbolTable;              // Properties by name\r\n        properties: Symbol[];              // Properties\r\n        callSignatures: Signature[];       // Call signatures of type\r\n        constructSignatures: Signature[];  // Construct signatures of type\r\n        stringIndexInfo?: IndexInfo;       // String indexing info\r\n        numberIndexInfo?: IndexInfo;       // Numeric indexing info\r\n    }\r\n\r\n    /* @internal */\r\n    // Object literals are initially marked fresh. Freshness disappears following an assignment,\r\n    // before a type assertion, or when an object literal's type is widened. The regular\r\n    // version of a fresh type is identical except for the TypeFlags.FreshObjectLiteral flag.\r\n    export interface FreshObjectLiteralType extends ResolvedType {\r\n        regularType: ResolvedType;  // Regular version of fresh type\r\n    }\r\n\r\n    // Just a place to cache element types of iterables and iterators\r\n    /* @internal */\r\n    export interface IterableOrIteratorType extends ObjectType, UnionType {\r\n        iteratedTypeOfIterable?: Type;\r\n        iteratedTypeOfIterator?: Type;\r\n        iteratedTypeOfAsyncIterable?: Type;\r\n        iteratedTypeOfAsyncIterator?: Type;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface PromiseOrAwaitableType extends ObjectType, UnionType {\r\n        promiseTypeOfPromiseConstructor?: Type;\r\n        promisedTypeOfPromise?: Type;\r\n        awaitedTypeOfType?: Type;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface SyntheticDefaultModuleType extends Type {\r\n        syntheticType?: Type;\r\n    }\r\n\r\n    export interface InstantiableType extends Type {\r\n        /* @internal */\r\n        resolvedBaseConstraint?: Type;\r\n        /* @internal */\r\n        resolvedIndexType?: IndexType;\r\n        /* @internal */\r\n        resolvedStringIndexType?: IndexType;\r\n    }\r\n\r\n    // Type parameters (TypeFlags.TypeParameter)\r\n    export interface TypeParameter extends InstantiableType {\r\n        /** Retrieve using getConstraintFromTypeParameter */\r\n        /* @internal */\r\n        constraint?: Type;        // Constraint\r\n        /* @internal */\r\n        default?: Type;\r\n        /* @internal */\r\n        target?: TypeParameter;  // Instantiation target\r\n        /* @internal */\r\n        mapper?: TypeMapper;     // Instantiation mapper\r\n        /* @internal */\r\n        isThisType?: boolean;\r\n        /* @internal */\r\n        resolvedDefaultType?: Type;\r\n    }\r\n\r\n    // Indexed access types (TypeFlags.IndexedAccess)\r\n    // Possible forms are T[xxx], xxx[T], or xxx[keyof T], where T is a type variable\r\n    export interface IndexedAccessType extends InstantiableType {\r\n        objectType: Type;\r\n        indexType: Type;\r\n        constraint?: Type;\r\n    }\r\n\r\n    export type TypeVariable = TypeParameter | IndexedAccessType;\r\n\r\n    // keyof T types (TypeFlags.Index)\r\n    export interface IndexType extends InstantiableType {\r\n        type: InstantiableType | UnionOrIntersectionType;\r\n        /* @internal */\r\n        stringsOnly: boolean;\r\n    }\r\n\r\n    export interface ConditionalRoot {\r\n        node: ConditionalTypeNode;\r\n        checkType: Type;\r\n        extendsType: Type;\r\n        trueType: Type;\r\n        falseType: Type;\r\n        isDistributive: boolean;\r\n        inferTypeParameters: TypeParameter[];\r\n        outerTypeParameters?: TypeParameter[];\r\n        instantiations?: Map<Type>;\r\n        aliasSymbol: Symbol;\r\n        aliasTypeArguments: Type[];\r\n    }\r\n\r\n    // T extends U ? X : Y (TypeFlags.Conditional)\r\n    export interface ConditionalType extends InstantiableType {\r\n        root: ConditionalRoot;\r\n        checkType: Type;\r\n        extendsType: Type;\r\n        resolvedTrueType?: Type;\r\n        resolvedFalseType?: Type;\r\n        /* @internal */\r\n        resolvedDefaultConstraint?: Type;\r\n        /* @internal */\r\n        mapper?: TypeMapper;\r\n        /* @internal */\r\n        combinedMapper?: TypeMapper;\r\n    }\r\n\r\n    // Type parameter substitution (TypeFlags.Substitution)\r\n    // Substitution types are created for type parameters or indexed access types that occur in the\r\n    // true branch of a conditional type. For example, in 'T extends string ? Foo<T> : Bar<T>', the\r\n    // reference to T in Foo<T> is resolved as a substitution type that substitutes 'string & T' for T.\r\n    // Thus, if Foo has a 'string' constraint on its type parameter, T will satisfy it. Substitution\r\n    // types disappear upon instantiation (just like type parameters).\r\n    export interface SubstitutionType extends InstantiableType {\r\n        typeVariable: TypeVariable;  // Target type variable\r\n        substitute: Type;            // Type to substitute for type parameter\r\n    }\r\n\r\n    export const enum SignatureKind {\r\n        Call,\r\n        Construct,\r\n    }\r\n\r\n    export interface Signature {\r\n        declaration?: SignatureDeclaration; // Originating declaration\r\n        typeParameters?: TypeParameter[];   // Type parameters (undefined if non-generic)\r\n        parameters: Symbol[];               // Parameters\r\n        /* @internal */\r\n        thisParameter?: Symbol;             // symbol of this-type parameter\r\n        /* @internal */\r\n        // See comment in `instantiateSignature` for why these are set lazily.\r\n        resolvedReturnType: Type | undefined; // Lazily set by `getReturnTypeOfSignature`.\r\n        /* @internal */\r\n        // Lazily set by `getTypePredicateOfSignature`.\r\n        // `undefined` indicates a type predicate that has not yet been computed.\r\n        // Uses a special `noTypePredicate` sentinel value to indicate that there is no type predicate. This looks like a TypePredicate at runtime to avoid polymorphism.\r\n        resolvedTypePredicate: TypePredicate | undefined;\r\n        /* @internal */\r\n        minArgumentCount: number;           // Number of non-optional parameters\r\n        /* @internal */\r\n        hasRestParameter: boolean;          // True if last parameter is rest parameter\r\n        /* @internal */\r\n        hasLiteralTypes: boolean;           // True if specialized\r\n        /* @internal */\r\n        target?: Signature;                 // Instantiation target\r\n        /* @internal */\r\n        mapper?: TypeMapper;                // Instantiation mapper\r\n        /* @internal */\r\n        unionSignatures?: Signature[];      // Underlying signatures of a union signature\r\n        /* @internal */\r\n        erasedSignatureCache?: Signature;   // Erased version of signature (deferred)\r\n        /* @internal */\r\n        canonicalSignatureCache?: Signature; // Canonical version of signature (deferred)\r\n        /* @internal */\r\n        isolatedSignatureType?: ObjectType; // A manufactured type that just contains the signature for purposes of signature comparison\r\n        /* @internal */\r\n        instantiations?: Map<Signature>;    // Generic signature instantiation cache\r\n    }\r\n\r\n    export const enum IndexKind {\r\n        String,\r\n        Number,\r\n    }\r\n\r\n    export interface IndexInfo {\r\n        type: Type;\r\n        isReadonly: boolean;\r\n        declaration?: IndexSignatureDeclaration;\r\n    }\r\n\r\n    /* @internal */\r\n    export type TypeMapper = (t: TypeParameter) => Type;\r\n\r\n    export const enum InferencePriority {\r\n        NakedTypeVariable           = 1 << 0,  // Naked type variable in union or intersection type\r\n        HomomorphicMappedType       = 1 << 1,  // Reverse inference for homomorphic mapped type\r\n        MappedTypeConstraint        = 1 << 2,  // Reverse inference for mapped type\r\n        ReturnType                  = 1 << 3,  // Inference made from return type of generic function\r\n        LiteralKeyof                = 1 << 4,  // Inference made from a string literal to a keyof T\r\n        NoConstraints               = 1 << 5,  // Don't infer from constraints of instantiable types\r\n        AlwaysStrict                = 1 << 6,  // Always use strict rules for contravariant inferences\r\n\r\n        PriorityImpliesCombination  = ReturnType | MappedTypeConstraint | LiteralKeyof,  // These priorities imply that the resulting type should be a combination of all candidates\r\n    }\r\n\r\n    /* @internal */\r\n    export interface InferenceInfo {\r\n        typeParameter: TypeParameter;  // Type parameter for which inferences are being made\r\n        candidates: Type[];            // Candidates in covariant positions (or undefined)\r\n        contraCandidates: Type[];      // Candidates in contravariant positions (or undefined)\r\n        inferredType: Type;            // Cache for resolved inferred type\r\n        priority: InferencePriority;   // Priority of current inference set\r\n        topLevel: boolean;             // True if all inferences are to top level occurrences\r\n        isFixed: boolean;              // True if inferences are fixed\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum InferenceFlags {\r\n        None            =      0,  // No special inference behaviors\r\n        InferUnionTypes = 1 << 0,  // Infer union types for disjoint candidates (otherwise unknownType)\r\n        NoDefault       = 1 << 1,  // Infer unknownType for no inferences (otherwise anyType or emptyObjectType)\r\n        AnyDefault      = 1 << 2,  // Infer anyType for no inferences (otherwise emptyObjectType)\r\n    }\r\n\r\n    /**\r\n     * Ternary values are defined such that\r\n     * x & y is False if either x or y is False.\r\n     * x & y is Maybe if either x or y is Maybe, but neither x or y is False.\r\n     * x & y is True if both x and y are True.\r\n     * x | y is False if both x and y are False.\r\n     * x | y is Maybe if either x or y is Maybe, but neither x or y is True.\r\n     * x | y is True if either x or y is True.\r\n     */\r\n    /* @internal */\r\n    export const enum Ternary {\r\n        False = 0,\r\n        Maybe = 1,\r\n        True = -1\r\n    }\r\n\r\n    /* @internal */\r\n    export type TypeComparer = (s: Type, t: Type, reportErrors?: boolean) => Ternary;\r\n\r\n    /* @internal */\r\n    export interface InferenceContext extends TypeMapper {\r\n        typeParameters: TypeParameter[];    // Type parameters for which inferences are made\r\n        signature: Signature;               // Generic signature for which inferences are made (if any)\r\n        inferences: InferenceInfo[];        // Inferences made for each type parameter\r\n        flags: InferenceFlags;              // Inference flags\r\n        compareTypes: TypeComparer;         // Type comparer function\r\n    }\r\n\r\n    /* @internal */\r\n    export interface WideningContext {\r\n        parent?: WideningContext;       // Parent context\r\n        propertyName?: __String;        // Name of property in parent\r\n        siblings?: Type[];              // Types of siblings\r\n        resolvedProperties?: Symbol[];  // Properties occurring in sibling object literals\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum SpecialPropertyAssignmentKind {\r\n        None,\r\n        /// exports.name = expr\r\n        ExportsProperty,\r\n        /// module.exports = expr\r\n        ModuleExports,\r\n        /// className.prototype.name = expr\r\n        PrototypeProperty,\r\n        /// this.name = expr\r\n        ThisProperty,\r\n        // F.name = expr\r\n        Property,\r\n        // F.prototype = { ... }\r\n        Prototype,\r\n    }\r\n\r\n    export interface JsFileExtensionInfo {\r\n        extension: string;\r\n        isMixedContent: boolean;\r\n        scriptKind?: ScriptKind;\r\n    }\r\n\r\n    export interface DiagnosticMessage {\r\n        key: string;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n        message: string;\r\n        reportsUnnecessary?: {};\r\n    }\r\n\r\n    /**\r\n     * A linked list of formatted diagnostic messages to be used as part of a multiline message.\r\n     * It is built from the bottom up, leaving the head to be the \"main\" diagnostic.\r\n     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,\r\n     * the difference is that messages are all preformatted in DMC.\r\n     */\r\n    export interface DiagnosticMessageChain {\r\n        messageText: string;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n        next?: DiagnosticMessageChain;\r\n    }\r\n\r\n    export interface Diagnostic {\r\n        file: SourceFile | undefined;\r\n        start: number | undefined;\r\n        length: number | undefined;\r\n        messageText: string | DiagnosticMessageChain;\r\n        category: DiagnosticCategory;\r\n        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */\r\n        reportsUnnecessary?: {};\r\n        code: number;\r\n        source?: string;\r\n    }\r\n\r\n    export enum DiagnosticCategory {\r\n        Warning,\r\n        Error,\r\n        Suggestion,\r\n        Message\r\n    }\r\n    /* @internal */\r\n    export function diagnosticCategoryName(d: { category: DiagnosticCategory }, lowerCase = true): string {\r\n        const name = DiagnosticCategory[d.category];\r\n        return lowerCase ? name.toLowerCase() : name;\r\n    }\r\n\r\n    export enum ModuleResolutionKind {\r\n        Classic  = 1,\r\n        NodeJs   = 2\r\n    }\r\n\r\n    export interface PluginImport {\r\n        name: string;\r\n    }\r\n\r\n    export type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | null | undefined;\r\n\r\n    export interface CompilerOptions {\r\n        /*@internal*/ all?: boolean;\r\n        allowJs?: boolean;\r\n        /*@internal*/ allowNonTsExtensions?: boolean;\r\n        allowSyntheticDefaultImports?: boolean;\r\n        allowUnreachableCode?: boolean;\r\n        allowUnusedLabels?: boolean;\r\n        alwaysStrict?: boolean;  // Always combine with strict property\r\n        baseUrl?: string;\r\n        charset?: string;\r\n        checkJs?: boolean;\r\n        /* @internal */ configFilePath?: string;\r\n        /** configFile is set as non enumerable property so as to avoid checking of json source files */\r\n        /* @internal */ readonly configFile?: JsonSourceFile;\r\n        declaration?: boolean;\r\n        declarationMap?: boolean;\r\n        emitDeclarationOnly?: boolean;\r\n        declarationDir?: string;\r\n        /* @internal */ diagnostics?: boolean;\r\n        /* @internal */ extendedDiagnostics?: boolean;\r\n        disableSizeLimit?: boolean;\r\n        downlevelIteration?: boolean;\r\n        emitBOM?: boolean;\r\n        emitDecoratorMetadata?: boolean;\r\n        experimentalDecorators?: boolean;\r\n        forceConsistentCasingInFileNames?: boolean;\r\n        /*@internal*/help?: boolean;\r\n        importHelpers?: boolean;\r\n        /*@internal*/init?: boolean;\r\n        inlineSourceMap?: boolean;\r\n        inlineSources?: boolean;\r\n        isolatedModules?: boolean;\r\n        jsx?: JsxEmit;\r\n        keyofStringsOnly?: boolean;\r\n        lib?: string[];\r\n        /*@internal*/listEmittedFiles?: boolean;\r\n        /*@internal*/listFiles?: boolean;\r\n        locale?: string;\r\n        mapRoot?: string;\r\n        maxNodeModuleJsDepth?: number;\r\n        module?: ModuleKind;\r\n        moduleResolution?: ModuleResolutionKind;\r\n        newLine?: NewLineKind;\r\n        noEmit?: boolean;\r\n        /*@internal*/noEmitForJsFiles?: boolean;\r\n        noEmitHelpers?: boolean;\r\n        noEmitOnError?: boolean;\r\n        noErrorTruncation?: boolean;\r\n        noFallthroughCasesInSwitch?: boolean;\r\n        noImplicitAny?: boolean;  // Always combine with strict property\r\n        noImplicitReturns?: boolean;\r\n        noImplicitThis?: boolean;  // Always combine with strict property\r\n        noStrictGenericChecks?: boolean;\r\n        noUnusedLocals?: boolean;\r\n        noUnusedParameters?: boolean;\r\n        noImplicitUseStrict?: boolean;\r\n        noLib?: boolean;\r\n        noResolve?: boolean;\r\n        out?: string;\r\n        outDir?: string;\r\n        outFile?: string;\r\n        paths?: MapLike<string[]>;\r\n        /*@internal*/ plugins?: PluginImport[];\r\n        preserveConstEnums?: boolean;\r\n        preserveSymlinks?: boolean;\r\n        /* @internal */ preserveWatchOutput?: boolean;\r\n        project?: string;\r\n        /* @internal */ pretty?: boolean;\r\n        reactNamespace?: string;\r\n        jsxFactory?: string;\r\n        removeComments?: boolean;\r\n        rootDir?: string;\r\n        rootDirs?: string[];\r\n        skipLibCheck?: boolean;\r\n        skipDefaultLibCheck?: boolean;\r\n        sourceMap?: boolean;\r\n        sourceRoot?: string;\r\n        strict?: boolean;\r\n        strictFunctionTypes?: boolean;  // Always combine with strict property\r\n        strictNullChecks?: boolean;  // Always combine with strict property\r\n        strictPropertyInitialization?: boolean;  // Always combine with strict property\r\n        /* @internal */ stripInternal?: boolean;\r\n        suppressExcessPropertyErrors?: boolean;\r\n        suppressImplicitAnyIndexErrors?: boolean;\r\n        /* @internal */ suppressOutputPathCheck?: boolean;\r\n        target?: ScriptTarget;\r\n        traceResolution?: boolean;\r\n        types?: string[];\r\n        /** Paths used to compute primary types search locations */\r\n        typeRoots?: string[];\r\n        /*@internal*/ version?: boolean;\r\n        /*@internal*/ watch?: boolean;\r\n        esModuleInterop?: boolean;\r\n\r\n        [option: string]: CompilerOptionsValue | JsonSourceFile | undefined;\r\n    }\r\n\r\n    export interface TypeAcquisition {\r\n        /* @deprecated typingOptions.enableAutoDiscovery\r\n         * Use typeAcquisition.enable instead.\r\n         */\r\n        enableAutoDiscovery?: boolean;\r\n        enable?: boolean;\r\n        include?: string[];\r\n        exclude?: string[];\r\n        [option: string]: string[] | boolean | undefined;\r\n    }\r\n\r\n    export enum ModuleKind {\r\n        None = 0,\r\n        CommonJS = 1,\r\n        AMD = 2,\r\n        UMD = 3,\r\n        System = 4,\r\n        ES2015 = 5,\r\n        ESNext = 6\r\n    }\r\n\r\n    export const enum JsxEmit {\r\n        None = 0,\r\n        Preserve = 1,\r\n        React = 2,\r\n        ReactNative = 3\r\n    }\r\n\r\n    export const enum NewLineKind {\r\n        CarriageReturnLineFeed = 0,\r\n        LineFeed = 1\r\n    }\r\n\r\n    export interface LineAndCharacter {\r\n        /** 0-based. */\r\n        line: number;\r\n        /*\r\n         * 0-based. This value denotes the character position in line and is different from the 'column' because of tab characters.\r\n         */\r\n        character: number;\r\n    }\r\n\r\n    export const enum ScriptKind {\r\n        Unknown = 0,\r\n        JS = 1,\r\n        JSX = 2,\r\n        TS = 3,\r\n        TSX = 4,\r\n        External = 5,\r\n        JSON = 6\r\n    }\r\n\r\n    export const enum ScriptTarget {\r\n        ES3 = 0,\r\n        ES5 = 1,\r\n        ES2015 = 2,\r\n        ES2016 = 3,\r\n        ES2017 = 4,\r\n        ES2018 = 5,\r\n        ESNext = 6,\r\n        Latest = ESNext,\r\n    }\r\n\r\n    export const enum LanguageVariant {\r\n        Standard,\r\n        JSX,\r\n    }\r\n\r\n    /** Either a parsed command line or a parsed tsconfig.json */\r\n    export interface ParsedCommandLine {\r\n        options: CompilerOptions;\r\n        typeAcquisition?: TypeAcquisition;\r\n        fileNames: string[];\r\n        raw?: any;\r\n        errors: Diagnostic[];\r\n        wildcardDirectories?: MapLike<WatchDirectoryFlags>;\r\n        compileOnSave?: boolean;\r\n        /* @internal */ configFileSpecs?: ConfigFileSpecs;\r\n    }\r\n\r\n    export const enum WatchDirectoryFlags {\r\n        None = 0,\r\n        Recursive = 1 << 0,\r\n    }\r\n\r\n    /* @internal */\r\n    export interface ConfigFileSpecs {\r\n        filesSpecs: ReadonlyArray<string>;\r\n        /**\r\n         * Present to report errors (user specified specs), validatedIncludeSpecs are used for file name matching\r\n         */\r\n        includeSpecs: ReadonlyArray<string>;\r\n        /**\r\n         * Present to report errors (user specified specs), validatedExcludeSpecs are used for file name matching\r\n         */\r\n        excludeSpecs: ReadonlyArray<string>;\r\n        validatedIncludeSpecs: ReadonlyArray<string>;\r\n        validatedExcludeSpecs: ReadonlyArray<string>;\r\n        wildcardDirectories: MapLike<WatchDirectoryFlags>;\r\n    }\r\n\r\n    export interface ExpandResult {\r\n        fileNames: string[];\r\n        wildcardDirectories: MapLike<WatchDirectoryFlags>;\r\n        /* @internal */ spec: ConfigFileSpecs;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionBase {\r\n        name: string;\r\n        type: \"string\" | \"number\" | \"boolean\" | \"object\" | \"list\" | Map<number | string>;    // a value of a primitive type, or an object literal mapping named values to actual values\r\n        isFilePath?: boolean;                                   // True if option value is a path or fileName\r\n        shortName?: string;                                     // A short mnemonic for convenience - for instance, 'h' can be used in place of 'help'\r\n        description?: DiagnosticMessage;                        // The message describing what the command line switch does\r\n        paramType?: DiagnosticMessage;                          // The name to be used for a non-boolean option's parameter\r\n        isTSConfigOnly?: boolean;                               // True if option can only be specified via tsconfig.json file\r\n        isCommandLineOnly?: boolean;\r\n        showInSimplifiedHelpView?: boolean;\r\n        category?: DiagnosticMessage;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionOfPrimitiveType extends CommandLineOptionBase {\r\n        type: \"string\" | \"number\" | \"boolean\";\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionOfCustomType extends CommandLineOptionBase {\r\n        type: Map<number | string>;  // an object literal mapping named values to actual values\r\n    }\r\n\r\n    /* @internal */\r\n    export interface TsConfigOnlyOption extends CommandLineOptionBase {\r\n        type: \"object\";\r\n        elementOptions?: Map<CommandLineOption>;\r\n        extraKeyDiagnosticMessage?: DiagnosticMessage;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface CommandLineOptionOfListType extends CommandLineOptionBase {\r\n        type: \"list\";\r\n        element: CommandLineOptionOfCustomType | CommandLineOptionOfPrimitiveType | TsConfigOnlyOption;\r\n    }\r\n\r\n    /* @internal */\r\n    export type CommandLineOption = CommandLineOptionOfCustomType | CommandLineOptionOfPrimitiveType | TsConfigOnlyOption | CommandLineOptionOfListType;\r\n\r\n    /* @internal */\r\n    export const enum CharacterCodes {\r\n        nullCharacter = 0,\r\n        maxAsciiCharacter = 0x7F,\r\n\r\n        lineFeed = 0x0A,              // \\n\r\n        carriageReturn = 0x0D,        // \\r\r\n        lineSeparator = 0x2028,\r\n        paragraphSeparator = 0x2029,\r\n        nextLine = 0x0085,\r\n\r\n        // Unicode 3.0 space characters\r\n        space = 0x0020,   // \" \"\r\n        nonBreakingSpace = 0x00A0,   //\r\n        enQuad = 0x2000,\r\n        emQuad = 0x2001,\r\n        enSpace = 0x2002,\r\n        emSpace = 0x2003,\r\n        threePerEmSpace = 0x2004,\r\n        fourPerEmSpace = 0x2005,\r\n        sixPerEmSpace = 0x2006,\r\n        figureSpace = 0x2007,\r\n        punctuationSpace = 0x2008,\r\n        thinSpace = 0x2009,\r\n        hairSpace = 0x200A,\r\n        zeroWidthSpace = 0x200B,\r\n        narrowNoBreakSpace = 0x202F,\r\n        ideographicSpace = 0x3000,\r\n        mathematicalSpace = 0x205F,\r\n        ogham = 0x1680,\r\n\r\n        _ = 0x5F,\r\n        $ = 0x24,\r\n\r\n        _0 = 0x30,\r\n        _1 = 0x31,\r\n        _2 = 0x32,\r\n        _3 = 0x33,\r\n        _4 = 0x34,\r\n        _5 = 0x35,\r\n        _6 = 0x36,\r\n        _7 = 0x37,\r\n        _8 = 0x38,\r\n        _9 = 0x39,\r\n\r\n        a = 0x61,\r\n        b = 0x62,\r\n        c = 0x63,\r\n        d = 0x64,\r\n        e = 0x65,\r\n        f = 0x66,\r\n        g = 0x67,\r\n        h = 0x68,\r\n        i = 0x69,\r\n        j = 0x6A,\r\n        k = 0x6B,\r\n        l = 0x6C,\r\n        m = 0x6D,\r\n        n = 0x6E,\r\n        o = 0x6F,\r\n        p = 0x70,\r\n        q = 0x71,\r\n        r = 0x72,\r\n        s = 0x73,\r\n        t = 0x74,\r\n        u = 0x75,\r\n        v = 0x76,\r\n        w = 0x77,\r\n        x = 0x78,\r\n        y = 0x79,\r\n        z = 0x7A,\r\n\r\n        A = 0x41,\r\n        B = 0x42,\r\n        C = 0x43,\r\n        D = 0x44,\r\n        E = 0x45,\r\n        F = 0x46,\r\n        G = 0x47,\r\n        H = 0x48,\r\n        I = 0x49,\r\n        J = 0x4A,\r\n        K = 0x4B,\r\n        L = 0x4C,\r\n        M = 0x4D,\r\n        N = 0x4E,\r\n        O = 0x4F,\r\n        P = 0x50,\r\n        Q = 0x51,\r\n        R = 0x52,\r\n        S = 0x53,\r\n        T = 0x54,\r\n        U = 0x55,\r\n        V = 0x56,\r\n        W = 0x57,\r\n        X = 0x58,\r\n        Y = 0x59,\r\n        Z = 0x5a,\r\n\r\n        ampersand = 0x26,             // &\r\n        asterisk = 0x2A,              // *\r\n        at = 0x40,                    // @\r\n        backslash = 0x5C,             // \\\r\n        backtick = 0x60,              // `\r\n        bar = 0x7C,                   // |\r\n        caret = 0x5E,                 // ^\r\n        closeBrace = 0x7D,            // }\r\n        closeBracket = 0x5D,          // ]\r\n        closeParen = 0x29,            // )\r\n        colon = 0x3A,                 // :\r\n        comma = 0x2C,                 // ,\r\n        dot = 0x2E,                   // .\r\n        doubleQuote = 0x22,           // \"\r\n        equals = 0x3D,                // =\r\n        exclamation = 0x21,           // !\r\n        greaterThan = 0x3E,           // >\r\n        hash = 0x23,                  // #\r\n        lessThan = 0x3C,              // <\r\n        minus = 0x2D,                 // -\r\n        openBrace = 0x7B,             // {\r\n        openBracket = 0x5B,           // [\r\n        openParen = 0x28,             // (\r\n        percent = 0x25,               // %\r\n        plus = 0x2B,                  // +\r\n        question = 0x3F,              // ?\r\n        semicolon = 0x3B,             // ;\r\n        singleQuote = 0x27,           // '\r\n        slash = 0x2F,                 // /\r\n        tilde = 0x7E,                 // ~\r\n\r\n        backspace = 0x08,             // \\b\r\n        formFeed = 0x0C,              // \\f\r\n        byteOrderMark = 0xFEFF,\r\n        tab = 0x09,                   // \\t\r\n        verticalTab = 0x0B,           // \\v\r\n    }\r\n\r\n    export interface ModuleResolutionHost {\r\n        fileExists(fileName: string): boolean;\r\n        // readFile function is used to read arbitrary text files on disk, i.e. when resolution procedure needs the content of 'package.json'\r\n        // to determine location of bundled typings for node module\r\n        readFile(fileName: string): string | undefined;\r\n        trace?(s: string): void;\r\n        directoryExists?(directoryName: string): boolean;\r\n        /**\r\n         * Resolve a symbolic link.\r\n         * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options\r\n         */\r\n        realpath?(path: string): string;\r\n        getCurrentDirectory?(): string;\r\n        getDirectories?(path: string): string[];\r\n    }\r\n\r\n    /**\r\n     * Represents the result of module resolution.\r\n     * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.\r\n     * The Program will then filter results based on these flags.\r\n     *\r\n     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.\r\n     */\r\n    export interface ResolvedModule {\r\n        /** Path of the file the module was resolved to. */\r\n        resolvedFileName: string;\r\n        /** True if `resolvedFileName` comes from `node_modules`. */\r\n        isExternalLibraryImport?: boolean;\r\n    }\r\n\r\n    /**\r\n     * ResolvedModule with an explicitly provided `extension` property.\r\n     * Prefer this over `ResolvedModule`.\r\n     * If changing this, remember to change `moduleResolutionIsEqualTo`.\r\n     */\r\n    export interface ResolvedModuleFull extends ResolvedModule {\r\n        /* @internal */\r\n        readonly originalPath?: string;\r\n        /**\r\n         * Extension of resolvedFileName. This must match what's at the end of resolvedFileName.\r\n         * This is optional for backwards-compatibility, but will be added if not provided.\r\n         */\r\n        extension: Extension;\r\n        packageId?: PackageId;\r\n    }\r\n\r\n    /**\r\n     * Unique identifier with a package name and version.\r\n     * If changing this, remember to change `packageIdIsEqual`.\r\n     */\r\n    export interface PackageId {\r\n        /**\r\n         * Name of the package.\r\n         * Should not include `@types`.\r\n         * If accessing a non-index file, this should include its name e.g. \"foo/bar\".\r\n         */\r\n        name: string;\r\n        /**\r\n         * Name of a submodule within this package.\r\n         * May be \"\".\r\n         */\r\n        subModuleName: string;\r\n        /** Version of the package, e.g. \"1.2.3\" */\r\n        version: string;\r\n    }\r\n\r\n    export const enum Extension {\r\n        Ts = \".ts\",\r\n        Tsx = \".tsx\",\r\n        Dts = \".d.ts\",\r\n        Js = \".js\",\r\n        Jsx = \".jsx\",\r\n        Json = \".json\"\r\n    }\r\n\r\n    export interface ResolvedModuleWithFailedLookupLocations {\r\n        readonly resolvedModule: ResolvedModuleFull | undefined;\r\n        /* @internal */\r\n        readonly failedLookupLocations: ReadonlyArray<string>;\r\n    }\r\n\r\n    export interface ResolvedTypeReferenceDirective {\r\n        // True if the type declaration file was found in a primary lookup location\r\n        primary: boolean;\r\n        // The location of the .d.ts file we located, or undefined if resolution failed\r\n        resolvedFileName: string | undefined;\r\n        packageId?: PackageId;\r\n    }\r\n\r\n    export interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {\r\n        readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective;\r\n        readonly failedLookupLocations: ReadonlyArray<string>;\r\n    }\r\n\r\n    /* @internal */\r\n    export type HasInvalidatedResolution = (sourceFile: Path) => boolean;\r\n\r\n    export interface CompilerHost extends ModuleResolutionHost {\r\n        getSourceFile(fileName: string, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\r\n        getSourceFileByPath?(fileName: string, path: Path, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\r\n        getCancellationToken?(): CancellationToken;\r\n        getDefaultLibFileName(options: CompilerOptions): string;\r\n        getDefaultLibLocation?(): string;\r\n        writeFile: WriteFileCallback;\r\n        getCurrentDirectory(): string;\r\n        getDirectories(path: string): string[];\r\n        getCanonicalFileName(fileName: string): string;\r\n        useCaseSensitiveFileNames(): boolean;\r\n        getNewLine(): string;\r\n\r\n        /*\r\n         * CompilerHost must either implement resolveModuleNames (in case if it wants to be completely in charge of\r\n         * module name resolution) or provide implementation for methods from ModuleResolutionHost (in this case compiler\r\n         * will apply built-in module resolution logic and use members of ModuleResolutionHost to ask host specific questions).\r\n         * If resolveModuleNames is implemented then implementation for members from ModuleResolutionHost can be just\r\n         * 'throw new Error(\"NotImplemented\")'\r\n         */\r\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames?: string[]): (ResolvedModule | undefined)[];\r\n        /**\r\n         * This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files\r\n         */\r\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[], containingFile: string): (ResolvedTypeReferenceDirective | undefined)[];\r\n        getEnvironmentVariable?(name: string): string;\r\n        /* @internal */ onReleaseOldSourceFile?(oldSourceFile: SourceFile, oldOptions: CompilerOptions): void;\r\n        /* @internal */ hasInvalidatedResolution?: HasInvalidatedResolution;\r\n        /* @internal */ hasChangedAutomaticTypeDirectiveNames?: boolean;\r\n        createHash?(data: string): string;\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum TransformFlags {\r\n        None = 0,\r\n\r\n        // Facts\r\n        // - Flags used to indicate that a node or subtree contains syntax that requires transformation.\r\n        TypeScript = 1 << 0,\r\n        ContainsTypeScript = 1 << 1,\r\n        ContainsJsx = 1 << 2,\r\n        ContainsESNext = 1 << 3,\r\n        ContainsES2017 = 1 << 4,\r\n        ContainsES2016 = 1 << 5,\r\n        ES2015 = 1 << 6,\r\n        ContainsES2015 = 1 << 7,\r\n        Generator = 1 << 8,\r\n        ContainsGenerator = 1 << 9,\r\n        DestructuringAssignment = 1 << 10,\r\n        ContainsDestructuringAssignment = 1 << 11,\r\n\r\n        // Markers\r\n        // - Flags used to indicate that a subtree contains a specific transformation.\r\n        ContainsDecorators = 1 << 12,\r\n        ContainsPropertyInitializer = 1 << 13,\r\n        ContainsLexicalThis = 1 << 14,\r\n        ContainsCapturedLexicalThis = 1 << 15,\r\n        ContainsLexicalThisInComputedPropertyName = 1 << 16,\r\n        ContainsDefaultValueAssignments = 1 << 17,\r\n        ContainsParameterPropertyAssignments = 1 << 18,\r\n        ContainsSpread = 1 << 19,\r\n        ContainsObjectSpread = 1 << 20,\r\n        ContainsRest = ContainsSpread,\r\n        ContainsObjectRest = ContainsObjectSpread,\r\n        ContainsComputedPropertyName = 1 << 21,\r\n        ContainsBlockScopedBinding = 1 << 22,\r\n        ContainsBindingPattern = 1 << 23,\r\n        ContainsYield = 1 << 24,\r\n        ContainsHoistedDeclarationOrCompletion = 1 << 25,\r\n        ContainsDynamicImport = 1 << 26,\r\n        Super = 1 << 27,\r\n        ContainsSuper = 1 << 28,\r\n\r\n        // Please leave this as 1 << 29.\r\n        // It is the maximum bit we can set before we outgrow the size of a v8 small integer (SMI) on an x86 system.\r\n        // It is a good reminder of how much room we have left\r\n        HasComputedFlags = 1 << 29, // Transform flags have been computed.\r\n\r\n        // Assertions\r\n        // - Bitmasks that are used to assert facts about the syntax of a node and its subtree.\r\n        AssertTypeScript = TypeScript | ContainsTypeScript,\r\n        AssertJsx = ContainsJsx,\r\n        AssertESNext = ContainsESNext,\r\n        AssertES2017 = ContainsES2017,\r\n        AssertES2016 = ContainsES2016,\r\n        AssertES2015 = ES2015 | ContainsES2015,\r\n        AssertGenerator = Generator | ContainsGenerator,\r\n        AssertDestructuringAssignment = DestructuringAssignment | ContainsDestructuringAssignment,\r\n\r\n        // Scope Exclusions\r\n        // - Bitmasks that exclude flags from propagating out of a specific context\r\n        //   into the subtree flags of their container.\r\n        OuterExpressionExcludes = TypeScript | ES2015 | DestructuringAssignment | Generator | HasComputedFlags,\r\n        PropertyAccessExcludes = OuterExpressionExcludes | Super,\r\n        NodeExcludes = PropertyAccessExcludes | ContainsSuper,\r\n        ArrowFunctionExcludes = NodeExcludes | ContainsDecorators | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsParameterPropertyAssignments | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        FunctionExcludes = NodeExcludes | ContainsDecorators | ContainsDefaultValueAssignments | ContainsCapturedLexicalThis | ContainsLexicalThis | ContainsParameterPropertyAssignments | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        ConstructorExcludes = NodeExcludes | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        MethodOrAccessorExcludes = NodeExcludes | ContainsDefaultValueAssignments | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsYield | ContainsHoistedDeclarationOrCompletion | ContainsBindingPattern | ContainsObjectRest,\r\n        ClassExcludes = NodeExcludes | ContainsDecorators | ContainsPropertyInitializer | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsComputedPropertyName | ContainsParameterPropertyAssignments | ContainsLexicalThisInComputedPropertyName,\r\n        ModuleExcludes = NodeExcludes | ContainsDecorators | ContainsLexicalThis | ContainsCapturedLexicalThis | ContainsBlockScopedBinding | ContainsHoistedDeclarationOrCompletion,\r\n        TypeExcludes = ~ContainsTypeScript,\r\n        ObjectLiteralExcludes = NodeExcludes | ContainsDecorators | ContainsComputedPropertyName | ContainsLexicalThisInComputedPropertyName | ContainsObjectSpread,\r\n        ArrayLiteralOrCallOrNewExcludes = NodeExcludes | ContainsSpread,\r\n        VariableDeclarationListExcludes = NodeExcludes | ContainsBindingPattern | ContainsObjectRest,\r\n        ParameterExcludes = NodeExcludes,\r\n        CatchClauseExcludes = NodeExcludes | ContainsObjectRest,\r\n        BindingPatternExcludes = NodeExcludes | ContainsRest,\r\n\r\n        // Masks\r\n        // - Additional bitmasks\r\n        TypeScriptClassSyntaxMask = ContainsParameterPropertyAssignments | ContainsPropertyInitializer | ContainsDecorators,\r\n        ES2015FunctionSyntaxMask = ContainsCapturedLexicalThis | ContainsDefaultValueAssignments,\r\n    }\r\n\r\n    export interface SourceMapRange extends TextRange {\r\n        source?: SourceMapSource;\r\n    }\r\n\r\n    export interface SourceMapSource {\r\n        fileName: string;\r\n        text: string;\r\n        /* @internal */ lineMap: ReadonlyArray<number>;\r\n        skipTrivia?: (pos: number) => number;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface EmitNode {\r\n        annotatedNodes?: Node[];                 // Tracks Parse-tree nodes with EmitNodes for eventual cleanup.\r\n        flags?: EmitFlags;                       // Flags that customize emit\r\n        leadingComments?: SynthesizedComment[];  // Synthesized leading comments\r\n        trailingComments?: SynthesizedComment[]; // Synthesized trailing comments\r\n        commentRange?: TextRange;                // The text range to use when emitting leading or trailing comments\r\n        sourceMapRange?: SourceMapRange;         // The text range to use when emitting leading or trailing source mappings\r\n        tokenSourceMapRanges?: SourceMapRange[]; // The text range to use when emitting source mappings for tokens\r\n        constantValue?: string | number;         // The constant value of an expression\r\n        externalHelpersModuleName?: Identifier;  // The local name for an imported helpers module\r\n        helpers?: EmitHelper[];                  // Emit helpers for the node\r\n        startsOnNewLine?: boolean;               // If the node should begin on a new line\r\n    }\r\n\r\n    export const enum EmitFlags {\r\n        SingleLine = 1 << 0,                    // The contents of this node should be emitted on a single line.\r\n        AdviseOnEmitNode = 1 << 1,              // The printer should invoke the onEmitNode callback when printing this node.\r\n        NoSubstitution = 1 << 2,                // Disables further substitution of an expression.\r\n        CapturesThis = 1 << 3,                  // The function captures a lexical `this`\r\n        NoLeadingSourceMap = 1 << 4,            // Do not emit a leading source map location for this node.\r\n        NoTrailingSourceMap = 1 << 5,           // Do not emit a trailing source map location for this node.\r\n        NoSourceMap = NoLeadingSourceMap | NoTrailingSourceMap, // Do not emit a source map location for this node.\r\n        NoNestedSourceMaps = 1 << 6,            // Do not emit source map locations for children of this node.\r\n        NoTokenLeadingSourceMaps = 1 << 7,      // Do not emit leading source map location for token nodes.\r\n        NoTokenTrailingSourceMaps = 1 << 8,     // Do not emit trailing source map location for token nodes.\r\n        NoTokenSourceMaps = NoTokenLeadingSourceMaps | NoTokenTrailingSourceMaps, // Do not emit source map locations for tokens of this node.\r\n        NoLeadingComments = 1 << 9,             // Do not emit leading comments for this node.\r\n        NoTrailingComments = 1 << 10,           // Do not emit trailing comments for this node.\r\n        NoComments = NoLeadingComments | NoTrailingComments, // Do not emit comments for this node.\r\n        NoNestedComments = 1 << 11,\r\n        HelperName = 1 << 12,\r\n        ExportName = 1 << 13,                   // Ensure an export prefix is added for an identifier that points to an exported declaration with a local name (see SymbolFlags.ExportHasLocal).\r\n        LocalName = 1 << 14,                    // Ensure an export prefix is not added for an identifier that points to an exported declaration.\r\n        InternalName = 1 << 15,                 // The name is internal to an ES5 class body function.\r\n        Indented = 1 << 16,                     // Adds an explicit extra indentation level for class and function bodies when printing (used to match old emitter).\r\n        NoIndentation = 1 << 17,                // Do not indent the node.\r\n        AsyncFunctionBody = 1 << 18,\r\n        ReuseTempVariableScope = 1 << 19,       // Reuse the existing temp variable scope during emit.\r\n        CustomPrologue = 1 << 20,               // Treat the statement as if it were a prologue directive (NOTE: Prologue directives are *not* transformed).\r\n        NoHoisting = 1 << 21,                   // Do not hoist this declaration in --module system\r\n        HasEndOfDeclarationMarker = 1 << 22,    // Declaration has an associated NotEmittedStatement to mark the end of the declaration\r\n        Iterator = 1 << 23,                     // The expression to a `yield*` should be treated as an Iterator when down-leveling, not an Iterable.\r\n        NoAsciiEscaping = 1 << 24,              // When synthesizing nodes that lack an original node or textSourceNode, we want to write the text on the node with ASCII escaping substitutions.\r\n        /*@internal*/ TypeScriptClassWrapper = 1 << 25, // The node is an IIFE class wrapper created by the ts transform.\r\n        /*@internal*/ NeverApplyImportHelper = 1 << 26, // Indicates the node should never be wrapped with an import star helper (because, for example, it imports tslib itself)\r\n    }\r\n\r\n    export interface EmitHelper {\r\n        readonly name: string;                                          // A unique name for this helper.\r\n        readonly scoped: boolean;                                       // Indicates whether the helper MUST be emitted in the current scope.\r\n        readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);  // ES3-compatible raw script text, or a function yielding such a string\r\n        readonly priority?: number;                                     // Helpers with a higher priority are emitted earlier than other helpers on the node.\r\n    }\r\n\r\n    /* @internal */\r\n    export type UniqueNameHandler = (baseName: string, checkFn?: (name: string) => boolean, optimistic?: boolean) => string;\r\n\r\n    export type EmitHelperUniqueNameCallback = (name: string) => string;\r\n\r\n    /**\r\n     * Used by the checker, this enum keeps track of external emit helpers that should be type\r\n     * checked.\r\n     */\r\n    /* @internal */\r\n    export const enum ExternalEmitHelpers {\r\n        Extends = 1 << 0,               // __extends (used by the ES2015 class transformation)\r\n        Assign = 1 << 1,                // __assign (used by Jsx and ESNext object spread transformations)\r\n        Rest = 1 << 2,                  // __rest (used by ESNext object rest transformation)\r\n        Decorate = 1 << 3,              // __decorate (used by TypeScript decorators transformation)\r\n        Metadata = 1 << 4,              // __metadata (used by TypeScript decorators transformation)\r\n        Param = 1 << 5,                 // __param (used by TypeScript decorators transformation)\r\n        Awaiter = 1 << 6,               // __awaiter (used by ES2017 async functions transformation)\r\n        Generator = 1 << 7,             // __generator (used by ES2015 generator transformation)\r\n        Values = 1 << 8,                // __values (used by ES2015 for..of and yield* transformations)\r\n        Read = 1 << 9,                  // __read (used by ES2015 iterator destructuring transformation)\r\n        Spread = 1 << 10,               // __spread (used by ES2015 array spread and argument list spread transformations)\r\n        Await = 1 << 11,                // __await (used by ES2017 async generator transformation)\r\n        AsyncGenerator = 1 << 12,       // __asyncGenerator (used by ES2017 async generator transformation)\r\n        AsyncDelegator = 1 << 13,       // __asyncDelegator (used by ES2017 async generator yield* transformation)\r\n        AsyncValues = 1 << 14,          // __asyncValues (used by ES2017 for..await..of transformation)\r\n        ExportStar = 1 << 15,           // __exportStar (used by CommonJS/AMD/UMD module transformation)\r\n        MakeTemplateObject = 1 << 16,   // __makeTemplateObject (used for constructing template string array objects)\r\n        FirstEmitHelper = Extends,\r\n        LastEmitHelper = MakeTemplateObject,\r\n\r\n        // Helpers included by ES2015 for..of\r\n        ForOfIncludes = Values,\r\n\r\n        // Helpers included by ES2017 for..await..of\r\n        ForAwaitOfIncludes = AsyncValues,\r\n\r\n        // Helpers included by ES2017 async generators\r\n        AsyncGeneratorIncludes = Await | AsyncGenerator,\r\n\r\n        // Helpers included by yield* in ES2017 async generators\r\n        AsyncDelegatorIncludes = Await | AsyncDelegator | AsyncValues,\r\n\r\n        // Helpers included by ES2015 spread\r\n        SpreadIncludes = Read | Spread,\r\n\r\n    }\r\n\r\n    export const enum EmitHint {\r\n        SourceFile,          // Emitting a SourceFile\r\n        Expression,          // Emitting an Expression\r\n        IdentifierName,      // Emitting an IdentifierName\r\n        MappedTypeParameter, // Emitting a TypeParameterDeclaration inside of a MappedTypeNode\r\n        Unspecified,         // Emitting an otherwise unspecified node\r\n    }\r\n\r\n    /* @internal */\r\n    export interface EmitHost extends ScriptReferenceHost {\r\n        getSourceFiles(): ReadonlyArray<SourceFile>;\r\n\r\n        /* @internal */\r\n        isSourceFileFromExternalLibrary(file: SourceFile): boolean;\r\n\r\n        getCommonSourceDirectory(): string;\r\n        getCanonicalFileName(fileName: string): string;\r\n        getNewLine(): string;\r\n\r\n        isEmitBlocked(emitFileName: string): boolean;\r\n\r\n        writeFile: WriteFileCallback;\r\n    }\r\n\r\n    export interface TransformationContext {\r\n        /*@internal*/ getEmitResolver(): EmitResolver;\r\n        /*@internal*/ getEmitHost(): EmitHost;\r\n\r\n        /** Gets the compiler options supplied to the transformer. */\r\n        getCompilerOptions(): CompilerOptions;\r\n\r\n        /** Starts a new lexical environment. */\r\n        startLexicalEnvironment(): void;\r\n\r\n        /** Suspends the current lexical environment, usually after visiting a parameter list. */\r\n        suspendLexicalEnvironment(): void;\r\n\r\n        /** Resumes a suspended lexical environment, usually before visiting a function body. */\r\n        resumeLexicalEnvironment(): void;\r\n\r\n        /** Ends a lexical environment, returning any declarations. */\r\n        endLexicalEnvironment(): Statement[];\r\n\r\n        /** Hoists a function declaration to the containing scope. */\r\n        hoistFunctionDeclaration(node: FunctionDeclaration): void;\r\n\r\n        /** Hoists a variable declaration to the containing scope. */\r\n        hoistVariableDeclaration(node: Identifier): void;\r\n\r\n        /** Records a request for a non-scoped emit helper in the current context. */\r\n        requestEmitHelper(helper: EmitHelper): void;\r\n\r\n        /** Gets and resets the requested non-scoped emit helpers. */\r\n        readEmitHelpers(): EmitHelper[] | undefined;\r\n\r\n        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */\r\n        enableSubstitution(kind: SyntaxKind): void;\r\n\r\n        /** Determines whether expression substitutions are enabled for the provided node. */\r\n        isSubstitutionEnabled(node: Node): boolean;\r\n\r\n        /**\r\n         * Hook used by transformers to substitute expressions just before they\r\n         * are emitted by the pretty printer.\r\n         *\r\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\r\n         * before returning the `NodeTransformer` callback.\r\n         */\r\n        onSubstituteNode: (hint: EmitHint, node: Node) => Node;\r\n\r\n        /**\r\n         * Enables before/after emit notifications in the pretty printer for the provided\r\n         * SyntaxKind.\r\n         */\r\n        enableEmitNotification(kind: SyntaxKind): void;\r\n\r\n        /**\r\n         * Determines whether before/after emit notifications should be raised in the pretty\r\n         * printer when it emits a node.\r\n         */\r\n        isEmitNotificationEnabled(node: Node): boolean;\r\n\r\n        /**\r\n         * Hook used to allow transformers to capture state before or after\r\n         * the printer emits a node.\r\n         *\r\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\r\n         * before returning the `NodeTransformer` callback.\r\n         */\r\n        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;\r\n\r\n        /* @internal */ addDiagnostic(diag: Diagnostic): void;\r\n    }\r\n\r\n    export interface TransformationResult<T extends Node> {\r\n        /** Gets the transformed source files. */\r\n        transformed: T[];\r\n\r\n        /** Gets diagnostics for the transformation. */\r\n        diagnostics?: Diagnostic[];\r\n\r\n        /**\r\n         * Gets a substitute for a node, if one is available; otherwise, returns the original node.\r\n         *\r\n         * @param hint A hint as to the intended usage of the node.\r\n         * @param node The node to substitute.\r\n         */\r\n        substituteNode(hint: EmitHint, node: Node): Node;\r\n\r\n        /**\r\n         * Emits a node with possible notification.\r\n         *\r\n         * @param hint A hint as to the intended usage of the node.\r\n         * @param node The node to emit.\r\n         * @param emitCallback A callback used to emit the node.\r\n         */\r\n        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\r\n\r\n        /**\r\n         * Clean up EmitNode entries on any parse-tree nodes.\r\n         */\r\n        dispose(): void;\r\n    }\r\n\r\n    /**\r\n     * A function that is used to initialize and return a `Transformer` callback, which in turn\r\n     * will be used to transform one or more nodes.\r\n     */\r\n    export type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;\r\n\r\n    /**\r\n     * A function that transforms a node.\r\n     */\r\n    export type Transformer<T extends Node> = (node: T) => T;\r\n\r\n    /**\r\n     * A function that accepts and possibly transforms a node.\r\n     */\r\n    export type Visitor = (node: Node) => VisitResult<Node>;\r\n\r\n    export type VisitResult<T extends Node> = T | T[] | undefined;\r\n\r\n    export interface Printer {\r\n        /**\r\n         * Print a node and its subtree as-is, without any emit transformations.\r\n         * @param hint A value indicating the purpose of a node. This is primarily used to\r\n         * distinguish between an `Identifier` used in an expression position, versus an\r\n         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you\r\n         * should just pass `Unspecified`.\r\n         * @param node The node to print. The node and its subtree are printed as-is, without any\r\n         * emit transformations.\r\n         * @param sourceFile A source file that provides context for the node. The source text of\r\n         * the file is used to emit the original source content for literals and identifiers, while\r\n         * the identifiers of the source file are used when generating unique names to avoid\r\n         * collisions.\r\n         */\r\n        printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;\r\n        /**\r\n         * Prints a list of nodes using the given format flags\r\n         */\r\n        printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;\r\n        /**\r\n         * Prints a source file as-is, without any emit transformations.\r\n         */\r\n        printFile(sourceFile: SourceFile): string;\r\n        /**\r\n         * Prints a bundle of source files as-is, without any emit transformations.\r\n         */\r\n        printBundle(bundle: Bundle): string;\r\n        /*@internal*/ writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;\r\n        /*@internal*/ writeList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;\r\n        /*@internal*/ writeFile(sourceFile: SourceFile, writer: EmitTextWriter): void;\r\n        /*@internal*/ writeBundle(bundle: Bundle, writer: EmitTextWriter): void;\r\n    }\r\n\r\n    export interface PrintHandlers {\r\n        /**\r\n         * A hook used by the Printer when generating unique names to avoid collisions with\r\n         * globally defined names that exist outside of the current source file.\r\n         */\r\n        hasGlobalName?(name: string): boolean;\r\n        /**\r\n         * A hook used by the Printer to provide notifications prior to emitting a node. A\r\n         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and\r\n         * `node` values.\r\n         * @param hint A hint indicating the intended purpose of the node.\r\n         * @param node The node to emit.\r\n         * @param emitCallback A callback that, when invoked, will emit the node.\r\n         * @example\r\n         * ```ts\r\n         * var printer = createPrinter(printerOptions, {\r\n         *   onEmitNode(hint, node, emitCallback) {\r\n         *     // set up or track state prior to emitting the node...\r\n         *     emitCallback(hint, node);\r\n         *     // restore state after emitting the node...\r\n         *   }\r\n         * });\r\n         * ```\r\n         */\r\n        onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\r\n        /**\r\n         * A hook used by the Printer to perform just-in-time substitution of a node. This is\r\n         * primarily used by node transformations that need to substitute one node for another,\r\n         * such as replacing `myExportedVar` with `exports.myExportedVar`.\r\n         * @param hint A hint indicating the intended purpose of the node.\r\n         * @param node The node to emit.\r\n         * @example\r\n         * ```ts\r\n         * var printer = createPrinter(printerOptions, {\r\n         *   substituteNode(hint, node) {\r\n         *     // perform substitution if necessary...\r\n         *     return node;\r\n         *   }\r\n         * });\r\n         * ```\r\n         */\r\n        substituteNode?(hint: EmitHint, node: Node): Node;\r\n        /*@internal*/ onEmitSourceMapOfNode?: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;\r\n        /*@internal*/ onEmitSourceMapOfToken?: (node: Node, token: SyntaxKind, writer: (s: string) => void, pos: number, emitCallback: (token: SyntaxKind, writer: (s: string) => void, pos: number) => number) => number;\r\n        /*@internal*/ onEmitSourceMapOfPosition?: (pos: number) => void;\r\n        /*@internal*/ onSetSourceFile?: (node: SourceFile) => void;\r\n        /*@internal*/ onBeforeEmitNodeArray?: (nodes: NodeArray<any>) => void;\r\n        /*@internal*/ onAfterEmitNodeArray?: (nodes: NodeArray<any>) => void;\r\n        /*@internal*/ onBeforeEmitToken?: (node: Node) => void;\r\n        /*@internal*/ onAfterEmitToken?: (node: Node) => void;\r\n    }\r\n\r\n    export interface PrinterOptions {\r\n        removeComments?: boolean;\r\n        newLine?: NewLineKind;\r\n        omitTrailingSemicolon?: boolean;\r\n        noEmitHelpers?: boolean;\r\n        /*@internal*/ module?: CompilerOptions[\"module\"];\r\n        /*@internal*/ target?: CompilerOptions[\"target\"];\r\n        /*@internal*/ sourceMap?: boolean;\r\n        /*@internal*/ inlineSourceMap?: boolean;\r\n        /*@internal*/ extendedDiagnostics?: boolean;\r\n        /*@internal*/ onlyPrintJsDocStyle?: boolean;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface EmitTextWriter extends SymbolWriter {\r\n        write(s: string): void;\r\n        writeTextOfNode(text: string, node: Node): void;\r\n        getText(): string;\r\n        rawWrite(s: string): void;\r\n        writeLiteral(s: string): void;\r\n        getTextPos(): number;\r\n        getLine(): number;\r\n        getColumn(): number;\r\n        getIndent(): number;\r\n        isAtStartOfLine(): boolean;\r\n    }\r\n\r\n    /** @deprecated See comment on SymbolWriter */\r\n    // Note: this has non-deprecated internal uses.\r\n    export interface SymbolTracker {\r\n        // Called when the symbol writer encounters a symbol to write.  Currently only used by the\r\n        // declaration emitter to help determine if it should patch up the final declaration file\r\n        // with import statements it previously saw (but chose not to emit).\r\n        trackSymbol?(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): void;\r\n        reportInaccessibleThisError?(): void;\r\n        reportPrivateInBaseOfClassExpression?(propertyName: string): void;\r\n        reportInaccessibleUniqueSymbolError?(): void;\r\n    }\r\n\r\n    export interface TextSpan {\r\n        start: number;\r\n        length: number;\r\n    }\r\n\r\n    export interface TextChangeRange {\r\n        span: TextSpan;\r\n        newLength: number;\r\n    }\r\n\r\n    export interface SortedArray<T> extends Array<T> {\r\n        \" __sortedArrayBrand\": any;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface DiagnosticCollection {\r\n        // Adds a diagnostic to this diagnostic collection.\r\n        add(diagnostic: Diagnostic): void;\r\n\r\n        // Gets all the diagnostics that aren't associated with a file.\r\n        getGlobalDiagnostics(): Diagnostic[];\r\n\r\n        // If fileName is provided, gets all the diagnostics associated with that file name.\r\n        // Otherwise, returns all the diagnostics (global and file associated) in this collection.\r\n        getDiagnostics(fileName?: string): Diagnostic[];\r\n\r\n        reattachFileDiagnostics(newFile: SourceFile): void;\r\n    }\r\n\r\n    // SyntaxKind.SyntaxList\r\n    export interface SyntaxList extends Node {\r\n        _children: Node[];\r\n    }\r\n\r\n    export const enum ListFormat {\r\n        None = 0,\r\n\r\n        // Line separators\r\n        SingleLine = 0,                 // Prints the list on a single line (default).\r\n        MultiLine = 1 << 0,             // Prints the list on multiple lines.\r\n        PreserveLines = 1 << 1,         // Prints the list using line preservation if possible.\r\n        LinesMask = SingleLine | MultiLine | PreserveLines,\r\n\r\n        // Delimiters\r\n        NotDelimited = 0,               // There is no delimiter between list items (default).\r\n        BarDelimited = 1 << 2,          // Each list item is space-and-bar (\" |\") delimited.\r\n        AmpersandDelimited = 1 << 3,    // Each list item is space-and-ampersand (\" &\") delimited.\r\n        CommaDelimited = 1 << 4,        // Each list item is comma (\",\") delimited.\r\n        DelimitersMask = BarDelimited | AmpersandDelimited | CommaDelimited,\r\n\r\n        AllowTrailingComma = 1 << 5,    // Write a trailing comma (\",\") if present.\r\n\r\n        // Whitespace\r\n        Indented = 1 << 6,              // The list should be indented.\r\n        SpaceBetweenBraces = 1 << 7,    // Inserts a space after the opening brace and before the closing brace.\r\n        SpaceBetweenSiblings = 1 << 8,  // Inserts a space between each sibling node.\r\n\r\n        // Brackets/Braces\r\n        Braces = 1 << 9,                // The list is surrounded by \"{\" and \"}\".\r\n        Parenthesis = 1 << 10,          // The list is surrounded by \"(\" and \")\".\r\n        AngleBrackets = 1 << 11,        // The list is surrounded by \"<\" and \">\".\r\n        SquareBrackets = 1 << 12,       // The list is surrounded by \"[\" and \"]\".\r\n        BracketsMask = Braces | Parenthesis | AngleBrackets | SquareBrackets,\r\n\r\n        OptionalIfUndefined = 1 << 13,  // Do not emit brackets if the list is undefined.\r\n        OptionalIfEmpty = 1 << 14,      // Do not emit brackets if the list is empty.\r\n        Optional = OptionalIfUndefined | OptionalIfEmpty,\r\n\r\n        // Other\r\n        PreferNewLine = 1 << 15,        // Prefer adding a LineTerminator between synthesized nodes.\r\n        NoTrailingNewLine = 1 << 16,    // Do not emit a trailing NewLine for a MultiLine list.\r\n        NoInterveningComments = 1 << 17, // Do not emit comments between each node\r\n\r\n        NoSpaceIfEmpty = 1 << 18,       // If the literal is empty, do not add spaces between braces.\r\n        SingleElement = 1 << 19,\r\n\r\n        // Precomputed Formats\r\n        Modifiers = SingleLine | SpaceBetweenSiblings | NoInterveningComments,\r\n        HeritageClauses = SingleLine | SpaceBetweenSiblings,\r\n        SingleLineTypeLiteralMembers = SingleLine | SpaceBetweenBraces | SpaceBetweenSiblings,\r\n        MultiLineTypeLiteralMembers = MultiLine | Indented | OptionalIfEmpty,\r\n\r\n        TupleTypeElements = CommaDelimited | SpaceBetweenSiblings | SingleLine,\r\n        UnionTypeConstituents = BarDelimited | SpaceBetweenSiblings | SingleLine,\r\n        IntersectionTypeConstituents = AmpersandDelimited | SpaceBetweenSiblings | SingleLine,\r\n        ObjectBindingPatternElements = SingleLine | AllowTrailingComma | SpaceBetweenBraces | CommaDelimited | SpaceBetweenSiblings | NoSpaceIfEmpty,\r\n        ArrayBindingPatternElements = SingleLine | AllowTrailingComma | CommaDelimited | SpaceBetweenSiblings | NoSpaceIfEmpty,\r\n        ObjectLiteralExpressionProperties = PreserveLines | CommaDelimited | SpaceBetweenSiblings | SpaceBetweenBraces | Indented | Braces | NoSpaceIfEmpty,\r\n        ArrayLiteralExpressionElements = PreserveLines | CommaDelimited | SpaceBetweenSiblings | AllowTrailingComma | Indented | SquareBrackets,\r\n        CommaListElements = CommaDelimited | SpaceBetweenSiblings | SingleLine,\r\n        CallExpressionArguments = CommaDelimited | SpaceBetweenSiblings | SingleLine | Parenthesis,\r\n        NewExpressionArguments = CommaDelimited | SpaceBetweenSiblings | SingleLine | Parenthesis | OptionalIfUndefined,\r\n        TemplateExpressionSpans = SingleLine | NoInterveningComments,\r\n        SingleLineBlockStatements = SpaceBetweenBraces | SpaceBetweenSiblings | SingleLine,\r\n        MultiLineBlockStatements = Indented | MultiLine,\r\n        VariableDeclarationList = CommaDelimited | SpaceBetweenSiblings | SingleLine,\r\n        SingleLineFunctionBodyStatements = SingleLine | SpaceBetweenSiblings | SpaceBetweenBraces,\r\n        MultiLineFunctionBodyStatements = MultiLine,\r\n        ClassHeritageClauses = SingleLine,\r\n        ClassMembers = Indented | MultiLine,\r\n        InterfaceMembers = Indented | MultiLine,\r\n        EnumMembers = CommaDelimited | Indented | MultiLine,\r\n        CaseBlockClauses = Indented | MultiLine,\r\n        NamedImportsOrExportsElements = CommaDelimited | SpaceBetweenSiblings | AllowTrailingComma | SingleLine | SpaceBetweenBraces | NoSpaceIfEmpty,\r\n        JsxElementOrFragmentChildren = SingleLine | NoInterveningComments,\r\n        JsxElementAttributes = SingleLine | SpaceBetweenSiblings | NoInterveningComments,\r\n        CaseOrDefaultClauseStatements = Indented | MultiLine | NoTrailingNewLine | OptionalIfEmpty,\r\n        HeritageClauseTypes = CommaDelimited | SpaceBetweenSiblings | SingleLine,\r\n        SourceFileStatements = MultiLine | NoTrailingNewLine,\r\n        Decorators = MultiLine | Optional,\r\n        TypeArguments = CommaDelimited | SpaceBetweenSiblings | SingleLine | AngleBrackets | Optional,\r\n        TypeParameters = CommaDelimited | SpaceBetweenSiblings | SingleLine | AngleBrackets | Optional,\r\n        Parameters = CommaDelimited | SpaceBetweenSiblings | SingleLine | Parenthesis,\r\n        IndexSignatureParameters = CommaDelimited | SpaceBetweenSiblings | SingleLine | Indented | SquareBrackets,\r\n    }\r\n\r\n    /* @internal */\r\n    export const enum PragmaKindFlags {\r\n        None            =      0,\r\n        /**\r\n         * Triple slash comment of the form\r\n         * /// <pragma-name argname=\"value\" />\r\n         */\r\n        TripleSlashXML  = 1 << 0,\r\n        /**\r\n         * Single line comment of the form\r\n         * // @pragma-name argval1 argval2\r\n         * or\r\n         * /// @pragma-name argval1 argval2\r\n         */\r\n        SingleLine      = 1 << 1,\r\n        /**\r\n         * Multiline non-jsdoc pragma of the form\r\n         * /* @pragma-name argval1 argval2 * /\r\n         */\r\n        MultiLine       = 1 << 2,\r\n        All = TripleSlashXML | SingleLine | MultiLine,\r\n        Default = All,\r\n    }\r\n\r\n    /* @internal */\r\n    interface PragmaArgumentSpecification<TName extends string> {\r\n        name: TName; // Determines the name of the key in the resulting parsed type, type parameter to cause literal type inference\r\n        optional?: boolean;\r\n        captureSpan?: boolean;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface PragmaDefinition<T1 extends string = string, T2 extends string = string, T3 extends string = string> {\r\n        args?: [PragmaArgumentSpecification<T1>] | [PragmaArgumentSpecification<T1>, PragmaArgumentSpecification<T2>] | [PragmaArgumentSpecification<T1>, PragmaArgumentSpecification<T2>, PragmaArgumentSpecification<T3>];\r\n        // If not present, defaults to PragmaKindFlags.Default\r\n        kind?: PragmaKindFlags;\r\n    }\r\n\r\n    /**\r\n     * This function only exists to cause exact types to be inferred for all the literals within `commentPragmas`\r\n     */\r\n    /* @internal */\r\n    function _contextuallyTypePragmas<T extends {[name: string]: PragmaDefinition<K1, K2, K3>}, K1 extends string, K2 extends string, K3 extends string>(args: T): T {\r\n        return args;\r\n    }\r\n\r\n    // While not strictly a type, this is here because `PragmaMap` needs to be here to be used with `SourceFile`, and we don't\r\n    //  fancy effectively defining it twice, once in value-space and once in type-space\r\n    /* @internal */\r\n    export const commentPragmas = _contextuallyTypePragmas({\r\n        \"reference\": {\r\n            args: [\r\n                { name: \"types\", optional: true, captureSpan: true },\r\n                { name: \"path\", optional: true, captureSpan: true },\r\n                { name: \"no-default-lib\", optional: true }\r\n            ],\r\n            kind: PragmaKindFlags.TripleSlashXML\r\n        },\r\n        \"amd-dependency\": {\r\n            args: [{ name: \"path\" }, { name: \"name\", optional: true }],\r\n            kind: PragmaKindFlags.TripleSlashXML\r\n        },\r\n        \"amd-module\": {\r\n            args: [{ name: \"name\" }],\r\n            kind: PragmaKindFlags.TripleSlashXML\r\n        },\r\n        \"ts-check\": {\r\n            kind: PragmaKindFlags.SingleLine\r\n        },\r\n        \"ts-nocheck\": {\r\n            kind: PragmaKindFlags.SingleLine\r\n        },\r\n        \"jsx\": {\r\n            args: [{ name: \"factory\" }],\r\n            kind: PragmaKindFlags.MultiLine\r\n        },\r\n    });\r\n\r\n    /* @internal */\r\n    type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {captureSpan: true} ? {value: string, pos: number, end: number} : string;\r\n\r\n    /* @internal */\r\n    type PragmaArgTypeOptional<TDesc, TName extends string> =\r\n        TDesc extends {optional: true}\r\n            ? {[K in TName]?: PragmaArgTypeMaybeCapture<TDesc>}\r\n            : {[K in TName]: PragmaArgTypeMaybeCapture<TDesc>};\r\n\r\n    /**\r\n     * Maps a pragma definition into the desired shape for its arguments object\r\n     * Maybe the below is a good argument for types being iterable on struture in some way.\r\n     */\r\n    /* @internal */\r\n    type PragmaArgumentType<T extends PragmaDefinition> =\r\n        T extends { args: [PragmaArgumentSpecification<infer TName1>, PragmaArgumentSpecification<infer TName2>, PragmaArgumentSpecification<infer TName3>] }\r\n        ? PragmaArgTypeOptional<T[\"args\"][0], TName1> & PragmaArgTypeOptional<T[\"args\"][1], TName2> & PragmaArgTypeOptional<T[\"args\"][2], TName3>\r\n        : T extends { args: [PragmaArgumentSpecification<infer TName1>, PragmaArgumentSpecification<infer TName2>] }\r\n            ? PragmaArgTypeOptional<T[\"args\"][0], TName1> & PragmaArgTypeOptional<T[\"args\"][1], TName2>\r\n            : T extends { args: [PragmaArgumentSpecification<infer TName>] }\r\n                ? PragmaArgTypeOptional<T[\"args\"][0], TName>\r\n                : object;\r\n    // The above fallback to `object` when there's no args to allow `{}` (as intended), but not the number 2, for example\r\n    // TODO: Swap to `undefined` for a cleaner API once strictNullChecks is enabled\r\n\r\n    type ConcretePragmaSpecs = typeof commentPragmas;\r\n\r\n    /* @internal */\r\n    export type PragmaPsuedoMap = {[K in keyof ConcretePragmaSpecs]?: {arguments: PragmaArgumentType<ConcretePragmaSpecs[K]>, range: CommentRange}};\r\n\r\n    /* @internal */\r\n    export type PragmaPsuedoMapEntry = {[K in keyof PragmaPsuedoMap]: {name: K, args: PragmaPsuedoMap[K]}}[keyof PragmaPsuedoMap];\r\n\r\n    /**\r\n     * A strongly-typed es6 map of pragma entries, the values of which are either a single argument\r\n     * value (if only one was found), or an array of multiple argument values if the pragma is present\r\n     * in multiple places\r\n     */\r\n    /* @internal */\r\n    export interface PragmaMap extends Map<PragmaPsuedoMap[keyof PragmaPsuedoMap] | PragmaPsuedoMap[keyof PragmaPsuedoMap][]> {\r\n        set<TKey extends keyof PragmaPsuedoMap>(key: TKey, value: PragmaPsuedoMap[TKey] | PragmaPsuedoMap[TKey][]): this;\r\n        get<TKey extends keyof PragmaPsuedoMap>(key: TKey): PragmaPsuedoMap[TKey] | PragmaPsuedoMap[TKey][];\r\n        forEach(action: <TKey extends keyof PragmaPsuedoMap>(value: PragmaPsuedoMap[TKey] | PragmaPsuedoMap[TKey][], key: TKey) => void): void;\r\n    }\r\n}\r\n","/*@internal*/\r\nnamespace ts {\r\n    declare const performance: { now?(): number } | undefined;\r\n    /** Gets a timestamp with (at least) ms resolution */\r\n    export const timestamp = typeof performance !== \"undefined\" && performance.now ? () => performance.now() : Date.now ? Date.now : () => +(new Date());\r\n}\r\n\r\n/*@internal*/\r\n/** Performance measurements for the compiler. */\r\nnamespace ts.performance {\r\n    declare const onProfilerEvent: { (markName: string): void; profiler: boolean; };\r\n\r\n    // NOTE: cannot use ts.noop as core.ts loads after this\r\n    const profilerEvent: (markName: string) => void = typeof onProfilerEvent === \"function\" && onProfilerEvent.profiler === true ? onProfilerEvent : () => { /*empty*/ };\r\n\r\n    let enabled = false;\r\n    let profilerStart = 0;\r\n    let counts: Map<number>;\r\n    let marks: Map<number>;\r\n    let measures: Map<number>;\r\n\r\n    /**\r\n     * Marks a performance event.\r\n     *\r\n     * @param markName The name of the mark.\r\n     */\r\n    export function mark(markName: string) {\r\n        if (enabled) {\r\n            marks.set(markName, timestamp());\r\n            counts.set(markName, (counts.get(markName) || 0) + 1);\r\n            profilerEvent(markName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a performance measurement with the specified name.\r\n     *\r\n     * @param measureName The name of the performance measurement.\r\n     * @param startMarkName The name of the starting mark. If not supplied, the point at which the\r\n     *      profiler was enabled is used.\r\n     * @param endMarkName The name of the ending mark. If not supplied, the current timestamp is\r\n     *      used.\r\n     */\r\n    export function measure(measureName: string, startMarkName?: string, endMarkName?: string) {\r\n        if (enabled) {\r\n            const end = endMarkName && marks.get(endMarkName) || timestamp();\r\n            const start = startMarkName && marks.get(startMarkName) || profilerStart;\r\n            measures.set(measureName, (measures.get(measureName) || 0) + (end - start));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of times a marker was encountered.\r\n     *\r\n     * @param markName The name of the mark.\r\n     */\r\n    export function getCount(markName: string) {\r\n        return counts && counts.get(markName) || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the total duration of all measurements with the supplied name.\r\n     *\r\n     * @param measureName The name of the measure whose durations should be accumulated.\r\n     */\r\n    export function getDuration(measureName: string) {\r\n        return measures && measures.get(measureName) || 0;\r\n    }\r\n\r\n    /**\r\n     * Iterate over each measure, performing some action\r\n     *\r\n     * @param cb The action to perform for each measure\r\n     */\r\n    export function forEachMeasure(cb: (measureName: string, duration: number) => void) {\r\n        measures.forEach((measure, key) => {\r\n            cb(key, measure);\r\n        });\r\n    }\r\n\r\n    /** Enables (and resets) performance measurements for the compiler. */\r\n    export function enable() {\r\n        counts = createMap<number>();\r\n        marks = createMap<number>();\r\n        measures = createMap<number>();\r\n        enabled = true;\r\n        profilerStart = timestamp();\r\n    }\r\n\r\n    /** Disables performance measurements for the compiler. */\r\n    export function disable() {\r\n        enabled = false;\r\n    }\r\n}\r\n","namespace ts {\r\n    // WARNING: The script `configureNightly.ts` uses a regexp to parse out these values.\r\n    // If changing the text in this section, be sure to test `configureNightly` too.\r\n    export const versionMajorMinor = \"2.9\";\r\n    /** The version of the TypeScript compiler release */\r\n    export const version = `${versionMajorMinor}.0-dev`;\r\n}\r\n\r\nnamespace ts {\r\n    export function isExternalModuleNameRelative(moduleName: string): boolean {\r\n        // TypeScript 1.0 spec (April 2014): 11.2.1\r\n        // An external module name is \"relative\" if the first term is \".\" or \"..\".\r\n        // Update: We also consider a path like `C:\\foo.ts` \"relative\" because we do not search for it in `node_modules` or treat it as an ambient module.\r\n        return pathIsRelative(moduleName) || isRootedDiskPath(moduleName);\r\n    }\r\n\r\n    export function sortAndDeduplicateDiagnostics(diagnostics: ReadonlyArray<Diagnostic>): Diagnostic[] {\r\n        return sortAndDeduplicate(diagnostics, compareDiagnostics);\r\n    }\r\n}\r\n\r\n/* @internal */\r\nnamespace ts {\r\n    export const emptyArray: never[] = [] as never[];\r\n    export function closeFileWatcher(watcher: FileWatcher) {\r\n        watcher.close();\r\n    }\r\n\r\n    /** Create a MapLike with good performance. */\r\n    function createDictionaryObject<T>(): MapLike<T> {\r\n        const map = Object.create(/*prototype*/ null); // tslint:disable-line:no-null-keyword\r\n\r\n        // Using 'delete' on an object causes V8 to put the object in dictionary mode.\r\n        // This disables creation of hidden classes, which are expensive when an object is\r\n        // constantly changing shape.\r\n        map.__ = undefined;\r\n        delete map.__;\r\n\r\n        return map;\r\n    }\r\n\r\n    /** Create a new map. If a template object is provided, the map will copy entries from it. */\r\n    export function createMap<T>(): Map<T> {\r\n        return new MapCtr<T>();\r\n    }\r\n\r\n    /** Create a new escaped identifier map. */\r\n    export function createUnderscoreEscapedMap<T>(): UnderscoreEscapedMap<T> {\r\n        return new MapCtr<T>() as UnderscoreEscapedMap<T>;\r\n    }\r\n\r\n    export function createSymbolTable(symbols?: ReadonlyArray<Symbol>): SymbolTable {\r\n        const result = createMap<Symbol>() as SymbolTable;\r\n        if (symbols) {\r\n            for (const symbol of symbols) {\r\n                result.set(symbol.escapedName, symbol);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function createMapFromTemplate<T>(template?: MapLike<T>): Map<T> {\r\n        const map: Map<T> = new MapCtr<T>();\r\n\r\n        // Copies keys/values from template. Note that for..in will not throw if\r\n        // template is undefined, and instead will just exit the loop.\r\n        for (const key in template) {\r\n            if (hasOwnProperty.call(template, key)) {\r\n                map.set(key, template[key]);\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    // The global Map object. This may not be available, so we must test for it.\r\n    declare const Map: { new <T>(): Map<T> } | undefined;\r\n    // Internet Explorer's Map doesn't support iteration, so don't use it.\r\n    // tslint:disable-next-line no-in-operator variable-name\r\n    const MapCtr = typeof Map !== \"undefined\" && \"entries\" in Map.prototype ? Map : shimMap();\r\n\r\n    // Keep the class inside a function so it doesn't get compiled if it's not used.\r\n    function shimMap(): { new <T>(): Map<T> } {\r\n\r\n        class MapIterator<T, U extends (string | T | [string, T])> {\r\n            private data: MapLike<T>;\r\n            private keys: ReadonlyArray<string>;\r\n            private index = 0;\r\n            private selector: (data: MapLike<T>, key: string) => U;\r\n            constructor(data: MapLike<T>, selector: (data: MapLike<T>, key: string) => U) {\r\n                this.data = data;\r\n                this.selector = selector;\r\n                this.keys = Object.keys(data);\r\n            }\r\n\r\n            public next(): { value: U, done: false } | { value: never, done: true } {\r\n                const index = this.index;\r\n                if (index < this.keys.length) {\r\n                    this.index++;\r\n                    return { value: this.selector(this.data, this.keys[index]), done: false };\r\n                }\r\n                return { value: undefined as never, done: true };\r\n            }\r\n        }\r\n\r\n        return class <T> implements Map<T> {\r\n            private data = createDictionaryObject<T>();\r\n            public size = 0;\r\n\r\n            get(key: string): T {\r\n                return this.data[key];\r\n            }\r\n\r\n            set(key: string, value: T): this {\r\n                if (!this.has(key)) {\r\n                    this.size++;\r\n                }\r\n                this.data[key] = value;\r\n                return this;\r\n            }\r\n\r\n            has(key: string): boolean {\r\n                // tslint:disable-next-line:no-in-operator\r\n                return key in this.data;\r\n            }\r\n\r\n            delete(key: string): boolean {\r\n                if (this.has(key)) {\r\n                    this.size--;\r\n                    delete this.data[key];\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n\r\n            clear(): void {\r\n                this.data = createDictionaryObject<T>();\r\n                this.size = 0;\r\n            }\r\n\r\n            keys() {\r\n                return new MapIterator(this.data, (_data, key) => key);\r\n            }\r\n\r\n            values() {\r\n                return new MapIterator(this.data, (data, key) => data[key]);\r\n            }\r\n\r\n            entries() {\r\n                return new MapIterator(this.data, (data, key) => [key, data[key]] as [string, T]);\r\n            }\r\n\r\n            forEach(action: (value: T, key: string) => void): void {\r\n                for (const key in this.data) {\r\n                    action(this.data[key], key);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    export function toPath(fileName: string, basePath: string, getCanonicalFileName: (path: string) => string): Path {\r\n        const nonCanonicalizedPath = isRootedDiskPath(fileName)\r\n            ? normalizePath(fileName)\r\n            : getNormalizedAbsolutePath(fileName, basePath);\r\n        return <Path>getCanonicalFileName(nonCanonicalizedPath);\r\n    }\r\n\r\n    export function length(array: ReadonlyArray<any>) {\r\n        return array ? array.length : 0;\r\n    }\r\n\r\n    /**\r\n     * Iterates through 'array' by index and performs the callback on each element of array until the callback\r\n     * returns a truthy value, then returns that value.\r\n     * If no such value is found, the callback is applied to each element of array and undefined is returned.\r\n     */\r\n    export function forEach<T, U>(array: ReadonlyArray<T> | undefined, callback: (element: T, index: number) => U | undefined): U | undefined {\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const result = callback(array[i], i);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** Like `forEach`, but suitable for use with numbers and strings (which may be falsy). */\r\n    export function firstDefined<T, U>(array: ReadonlyArray<T> | undefined, callback: (element: T, index: number) => U | undefined): U | undefined {\r\n        if (array === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        for (let i = 0; i < array.length; i++) {\r\n            const result = callback(array[i], i);\r\n            if (result !== undefined) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function firstDefinedIterator<T, U>(iter: Iterator<T>, callback: (element: T) => U | undefined): U | undefined {\r\n        while (true) {\r\n            const { value, done } = iter.next();\r\n            if (done) {\r\n                return undefined;\r\n            }\r\n            const result = callback(value);\r\n            if (result !== undefined) {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterates through the parent chain of a node and performs the callback on each parent until the callback\r\n     * returns a truthy value, then returns that value.\r\n     * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns \"quit\"\r\n     * At that point findAncestor returns undefined.\r\n     */\r\n    export function findAncestor<T extends Node>(node: Node, callback: (element: Node) => element is T): T | undefined;\r\n    export function findAncestor(node: Node, callback: (element: Node) => boolean | \"quit\"): Node | undefined;\r\n    export function findAncestor(node: Node, callback: (element: Node) => boolean | \"quit\"): Node {\r\n        while (node) {\r\n            const result = callback(node);\r\n            if (result === \"quit\") {\r\n                return undefined;\r\n            }\r\n            else if (result) {\r\n                return node;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function zipWith<T, U, V>(arrayA: ReadonlyArray<T>, arrayB: ReadonlyArray<U>, callback: (a: T, b: U, index: number) => V): V[] {\r\n        const result: V[] = [];\r\n        Debug.assertEqual(arrayA.length, arrayB.length);\r\n        for (let i = 0; i < arrayA.length; i++) {\r\n            result.push(callback(arrayA[i], arrayB[i], i));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function zipToIterator<T, U>(arrayA: ReadonlyArray<T>, arrayB: ReadonlyArray<U>): Iterator<[T, U]> {\r\n        Debug.assertEqual(arrayA.length, arrayB.length);\r\n        let i = 0;\r\n        return {\r\n            next() {\r\n                if (i === arrayA.length) {\r\n                    return { value: undefined as never, done: true };\r\n                }\r\n                i++;\r\n                return { value: [arrayA[i - 1], arrayB[i - 1]], done: false };\r\n            }\r\n        };\r\n    }\r\n\r\n    export function zipToMap<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): Map<T> {\r\n        Debug.assert(keys.length === values.length);\r\n        const map = createMap<T>();\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            map.set(keys[i], values[i]);\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Iterates through `array` by index and performs the callback on each element of array until the callback\r\n     * returns a falsey value, then returns false.\r\n     * If no such value is found, the callback is applied to each element of array and `true` is returned.\r\n     */\r\n    export function every<T>(array: ReadonlyArray<T>, callback: (element: T, index: number) => boolean): boolean {\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                if (!callback(array[i], i)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** Works like Array.prototype.find, returning `undefined` if no element satisfying the predicate is found. */\r\n    export function find<T, U extends T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => element is U): U | undefined;\r\n    export function find<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): T | undefined;\r\n    export function find<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): T | undefined {\r\n        for (let i = 0; i < array.length; i++) {\r\n            const value = array[i];\r\n            if (predicate(value, i)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function findLast<T, U extends T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => element is U): U | undefined;\r\n    export function findLast<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): T | undefined;\r\n    export function findLast<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): T | undefined {\r\n        for (let i = array.length - 1; i >= 0; i--) {\r\n            const value = array[i];\r\n            if (predicate(value, i)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** Works like Array.prototype.findIndex, returning `-1` if no element satisfying the predicate is found. */\r\n    export function findIndex<T>(array: ReadonlyArray<T>, predicate: (element: T, index: number) => boolean): number {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (predicate(array[i], i)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the first truthy result of `callback`, or else fails.\r\n     * This is like `forEach`, but never returns undefined.\r\n     */\r\n    export function findMap<T, U>(array: ReadonlyArray<T>, callback: (element: T, index: number) => U | undefined): U {\r\n        for (let i = 0; i < array.length; i++) {\r\n            const result = callback(array[i], i);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        Debug.fail();\r\n    }\r\n\r\n    export function contains<T>(array: ReadonlyArray<T>, value: T, equalityComparer: EqualityComparer<T> = equateValues): boolean {\r\n        if (array) {\r\n            for (const v of array) {\r\n                if (equalityComparer(v, value)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function arraysEqual<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>, equalityComparer: EqualityComparer<T> = equateValues): boolean {\r\n        return a.length === b.length && a.every((x, i) => equalityComparer(x, b[i]));\r\n    }\r\n\r\n    export function indexOfAnyCharCode(text: string, charCodes: ReadonlyArray<number>, start?: number): number {\r\n        for (let i = start || 0; i < text.length; i++) {\r\n            if (contains(charCodes, text.charCodeAt(i))) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    export function countWhere<T>(array: ReadonlyArray<T>, predicate: (x: T, i: number) => boolean): number {\r\n        let count = 0;\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const v = array[i];\r\n                if (predicate(v, i)) {\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Filters an array by a predicate function. Returns the same array instance if the predicate is\r\n     * true for all elements, otherwise returns a new array instance containing the filtered subset.\r\n     */\r\n    export function filter<T, U extends T>(array: T[], f: (x: T) => x is U): U[];\r\n    export function filter<T>(array: T[], f: (x: T) => boolean): T[];\r\n    export function filter<T, U extends T>(array: ReadonlyArray<T>, f: (x: T) => x is U): ReadonlyArray<U>;\r\n    export function filter<T, U extends T>(array: ReadonlyArray<T>, f: (x: T) => boolean): ReadonlyArray<T>;\r\n    export function filter<T>(array: T[], f: (x: T) => boolean): T[] {\r\n        if (array) {\r\n            const len = array.length;\r\n            let i = 0;\r\n            while (i < len && f(array[i])) i++;\r\n            if (i < len) {\r\n                const result = array.slice(0, i);\r\n                i++;\r\n                while (i < len) {\r\n                    const item = array[i];\r\n                    if (f(item)) {\r\n                        result.push(item);\r\n                    }\r\n                    i++;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n\r\n    export function filterMutate<T>(array: T[], f: (x: T, i: number, array: T[]) => boolean): void {\r\n        let outIndex = 0;\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (f(array[i], i, array)) {\r\n                array[outIndex] = array[i];\r\n                outIndex++;\r\n            }\r\n        }\r\n        array.length = outIndex;\r\n    }\r\n\r\n    export function clear(array: {}[]): void {\r\n        array.length = 0;\r\n    }\r\n\r\n    export function map<T, U>(array: ReadonlyArray<T>, f: (x: T, i: number) => U): U[] {\r\n        let result: U[];\r\n        if (array) {\r\n            result = [];\r\n            for (let i = 0; i < array.length; i++) {\r\n                result.push(f(array[i], i));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    export function mapIterator<T, U>(iter: Iterator<T>, mapFn: (x: T) => U): Iterator<U> {\r\n        return {\r\n            next() {\r\n                const iterRes = iter.next();\r\n                return iterRes.done ? iterRes : { value: mapFn(iterRes.value), done: false };\r\n            }\r\n        };\r\n    }\r\n\r\n    // Maps from T to T and avoids allocation if all elements map to themselves\r\n    export function sameMap<T>(array: T[], f: (x: T, i: number) => T): T[];\r\n    export function sameMap<T>(array: ReadonlyArray<T>, f: (x: T, i: number) => T): ReadonlyArray<T>;\r\n    export function sameMap<T>(array: T[], f: (x: T, i: number) => T): T[] {\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                const mapped = f(item, i);\r\n                if (item !== mapped) {\r\n                    const result = array.slice(0, i);\r\n                    result.push(mapped);\r\n                    for (i++; i < array.length; i++) {\r\n                        result.push(f(array[i], i));\r\n                    }\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Flattens an array containing a mix of array or non-array elements.\r\n     *\r\n     * @param array The array to flatten.\r\n     */\r\n    export function flatten<T>(array: ReadonlyArray<T | ReadonlyArray<T>>): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            result = [];\r\n            for (const v of array) {\r\n                if (v) {\r\n                    if (isArray(v)) {\r\n                        addRange(result, v);\r\n                    }\r\n                    else {\r\n                        result.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Maps an array. If the mapped value is an array, it is spread into the result.\r\n     *\r\n     * @param array The array to map.\r\n     * @param mapfn The callback used to map the result into one or more values.\r\n     */\r\n    export function flatMap<T, U>(array: ReadonlyArray<T> | undefined, mapfn: (x: T, i: number) => U | ReadonlyArray<U> | undefined): U[] | undefined {\r\n        let result: U[];\r\n        if (array) {\r\n            result = [];\r\n            for (let i = 0; i < array.length; i++) {\r\n                const v = mapfn(array[i], i);\r\n                if (v) {\r\n                    if (isArray(v)) {\r\n                        addRange(result, v);\r\n                    }\r\n                    else {\r\n                        result.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function flatMapIterator<T, U>(iter: Iterator<T>, mapfn: (x: T) => U[] | Iterator<U> | undefined): Iterator<U> {\r\n        const first = iter.next();\r\n        if (first.done) {\r\n            return emptyIterator;\r\n        }\r\n        let currentIter = getIterator(first.value);\r\n        return {\r\n            next() {\r\n                while (true) {\r\n                    const currentRes = currentIter.next();\r\n                    if (!currentRes.done) {\r\n                        return currentRes;\r\n                    }\r\n                    const iterRes = iter.next();\r\n                    if (iterRes.done) {\r\n                        return iterRes;\r\n                    }\r\n                    currentIter = getIterator(iterRes.value);\r\n                }\r\n            },\r\n        };\r\n\r\n        function getIterator(x: T): Iterator<U> {\r\n            const res = mapfn(x);\r\n            return res === undefined ? emptyIterator : isArray(res) ? arrayIterator(res) : res;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maps an array. If the mapped value is an array, it is spread into the result.\r\n     * Avoids allocation if all elements map to themselves.\r\n     *\r\n     * @param array The array to map.\r\n     * @param mapfn The callback used to map the result into one or more values.\r\n     */\r\n    export function sameFlatMap<T>(array: T[], mapfn: (x: T, i: number) => T | ReadonlyArray<T>): T[];\r\n    export function sameFlatMap<T>(array: ReadonlyArray<T>, mapfn: (x: T, i: number) => T | ReadonlyArray<T>): ReadonlyArray<T>;\r\n    export function sameFlatMap<T>(array: T[], mapfn: (x: T, i: number) => T | T[]): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const item = array[i];\r\n                const mapped = mapfn(item, i);\r\n                if (result || item !== mapped || isArray(mapped)) {\r\n                    if (!result) {\r\n                        result = array.slice(0, i);\r\n                    }\r\n                    if (isArray(mapped)) {\r\n                        addRange(result, mapped);\r\n                    }\r\n                    else {\r\n                        result.push(mapped);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result || array;\r\n    }\r\n\r\n    export function mapAllOrFail<T, U>(array: ReadonlyArray<T>, mapFn: (x: T, i: number) => U | undefined): U[] | undefined {\r\n        const result: U[] = [];\r\n        for (let i = 0; i < array.length; i++) {\r\n            const mapped = mapFn(array[i], i);\r\n            if (mapped === undefined) {\r\n                return undefined;\r\n            }\r\n            result.push(mapped);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function mapDefined<T, U>(array: ReadonlyArray<T> | undefined, mapFn: (x: T, i: number) => U | undefined): U[] {\r\n        const result: U[] = [];\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const mapped = mapFn(array[i], i);\r\n                if (mapped !== undefined) {\r\n                    result.push(mapped);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function mapDefinedIterator<T, U>(iter: Iterator<T>, mapFn: (x: T) => U | undefined): Iterator<U> {\r\n        return {\r\n            next() {\r\n                while (true) {\r\n                    const res = iter.next();\r\n                    if (res.done) {\r\n                        return res;\r\n                    }\r\n                    const value = mapFn(res.value);\r\n                    if (value !== undefined) {\r\n                        return { value, done: false };\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    export const emptyIterator: Iterator<never> = { next: () => ({ value: undefined as never, done: true }) };\r\n\r\n    export function singleIterator<T>(value: T): Iterator<T> {\r\n        let done = false;\r\n        return {\r\n            next() {\r\n                const wasDone = done;\r\n                done = true;\r\n                return wasDone ? { value: undefined as never, done: true } : { value, done: false };\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Maps contiguous spans of values with the same key.\r\n     *\r\n     * @param array The array to map.\r\n     * @param keyfn A callback used to select the key for an element.\r\n     * @param mapfn A callback used to map a contiguous chunk of values to a single value.\r\n     */\r\n    export function spanMap<T, K, U>(array: ReadonlyArray<T>, keyfn: (x: T, i: number) => K, mapfn: (chunk: T[], key: K, start: number, end: number) => U): U[] {\r\n        let result: U[];\r\n        if (array) {\r\n            result = [];\r\n            const len = array.length;\r\n            let previousKey: K;\r\n            let key: K;\r\n            let start = 0;\r\n            let pos = 0;\r\n            while (start < len) {\r\n                while (pos < len) {\r\n                    const value = array[pos];\r\n                    key = keyfn(value, pos);\r\n                    if (pos === 0) {\r\n                        previousKey = key;\r\n                    }\r\n                    else if (key !== previousKey) {\r\n                        break;\r\n                    }\r\n\r\n                    pos++;\r\n                }\r\n\r\n                if (start < pos) {\r\n                    const v = mapfn(array.slice(start, pos), previousKey, start, pos);\r\n                    if (v) {\r\n                        result.push(v);\r\n                    }\r\n\r\n                    start = pos;\r\n                }\r\n\r\n                previousKey = key;\r\n                pos++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    export function mapEntries<T, U>(map: ReadonlyMap<T>, f: (key: string, value: T) => [string, U]): Map<U> {\r\n        if (!map) {\r\n            return undefined;\r\n        }\r\n\r\n        const result = createMap<U>();\r\n        map.forEach((value, key) => {\r\n            const [newKey, newValue] = f(key, value);\r\n            result.set(newKey, newValue);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    export function some<T>(array: ReadonlyArray<T>, predicate?: (value: T) => boolean): boolean {\r\n        if (array) {\r\n            if (predicate) {\r\n                for (const v of array) {\r\n                    if (predicate(v)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                return array.length > 0;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function concatenate<T>(array1: T[], array2: T[]): T[];\r\n    export function concatenate<T>(array1: ReadonlyArray<T>, array2: ReadonlyArray<T>): ReadonlyArray<T>;\r\n    export function concatenate<T>(array1: T[], array2: T[]): T[] {\r\n        if (!some(array2)) return array1;\r\n        if (!some(array1)) return array2;\r\n        return [...array1, ...array2];\r\n    }\r\n\r\n    function deduplicateRelational<T>(array: ReadonlyArray<T>, equalityComparer: EqualityComparer<T>, comparer: Comparer<T>) {\r\n        // Perform a stable sort of the array. This ensures the first entry in a list of\r\n        // duplicates remains the first entry in the result.\r\n        const indices = array.map((_, i) => i);\r\n        stableSortIndices(array, indices, comparer);\r\n\r\n        let last = array[indices[0]];\r\n        const deduplicated: number[] = [indices[0]];\r\n        for (let i = 1; i < indices.length; i++) {\r\n            const index = indices[i];\r\n            const item = array[index];\r\n            if (!equalityComparer(last, item)) {\r\n                deduplicated.push(index);\r\n                last = item;\r\n            }\r\n        }\r\n\r\n        // restore original order\r\n        deduplicated.sort();\r\n        return deduplicated.map(i => array[i]);\r\n    }\r\n\r\n    function deduplicateEquality<T>(array: ReadonlyArray<T>, equalityComparer: EqualityComparer<T>) {\r\n        const result: T[] = [];\r\n        for (const item of array) {\r\n            pushIfUnique(result, item, equalityComparer);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Deduplicates an unsorted array.\r\n     * @param equalityComparer An optional `EqualityComparer` used to determine if two values are duplicates.\r\n     * @param comparer An optional `Comparer` used to sort entries before comparison, though the\r\n     * result will remain in the original order in `array`.\r\n     */\r\n    export function deduplicate<T>(array: ReadonlyArray<T>, equalityComparer: EqualityComparer<T>, comparer?: Comparer<T>): T[] {\r\n        return !array ? undefined :\r\n            array.length === 0 ? [] :\r\n            array.length === 1 ? array.slice() :\r\n            comparer ? deduplicateRelational(array, equalityComparer, comparer) :\r\n            deduplicateEquality(array, equalityComparer);\r\n    }\r\n\r\n    /**\r\n     * Deduplicates an array that has already been sorted.\r\n     */\r\n    function deduplicateSorted<T>(array: ReadonlyArray<T>, comparer: EqualityComparer<T> | Comparer<T>) {\r\n        if (!array) return undefined;\r\n        if (array.length === 0) return [];\r\n\r\n        let last = array[0];\r\n        const deduplicated: T[] = [last];\r\n        for (let i = 1; i < array.length; i++) {\r\n            const next = array[i];\r\n            switch (comparer(next, last)) {\r\n                // equality comparison\r\n                case true:\r\n\r\n                // relational comparison\r\n                case Comparison.EqualTo:\r\n                    continue;\r\n\r\n                case Comparison.LessThan:\r\n                    // If `array` is sorted, `next` should **never** be less than `last`.\r\n                    return Debug.fail(\"Array is unsorted.\");\r\n            }\r\n\r\n            deduplicated.push(last = next);\r\n        }\r\n\r\n        return deduplicated;\r\n    }\r\n\r\n    export function insertSorted<T>(array: SortedArray<T>, insert: T, compare: Comparer<T>): void {\r\n        if (array.length === 0) {\r\n            array.push(insert);\r\n            return;\r\n        }\r\n\r\n        const insertIndex = binarySearch(array, insert, identity, compare);\r\n        if (insertIndex < 0) {\r\n            array.splice(~insertIndex, 0, insert);\r\n        }\r\n    }\r\n\r\n    export function sortAndDeduplicate<T>(array: ReadonlyArray<T>, comparer: Comparer<T>, equalityComparer?: EqualityComparer<T>) {\r\n        return deduplicateSorted(sort(array, comparer), equalityComparer || comparer);\r\n    }\r\n\r\n    export function arrayIsEqualTo<T>(array1: ReadonlyArray<T>, array2: ReadonlyArray<T>, equalityComparer: (a: T, b: T) => boolean = equateValues): boolean {\r\n        if (!array1 || !array2) {\r\n            return array1 === array2;\r\n        }\r\n\r\n        if (array1.length !== array2.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < array1.length; i++) {\r\n            if (!equalityComparer(array1[i], array2[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    export function changesAffectModuleResolution(oldOptions: CompilerOptions, newOptions: CompilerOptions): boolean {\r\n        return !oldOptions ||\r\n            (oldOptions.module !== newOptions.module) ||\r\n            (oldOptions.moduleResolution !== newOptions.moduleResolution) ||\r\n            (oldOptions.noResolve !== newOptions.noResolve) ||\r\n            (oldOptions.target !== newOptions.target) ||\r\n            (oldOptions.noLib !== newOptions.noLib) ||\r\n            (oldOptions.jsx !== newOptions.jsx) ||\r\n            (oldOptions.allowJs !== newOptions.allowJs) ||\r\n            (oldOptions.rootDir !== newOptions.rootDir) ||\r\n            (oldOptions.configFilePath !== newOptions.configFilePath) ||\r\n            (oldOptions.baseUrl !== newOptions.baseUrl) ||\r\n            (oldOptions.maxNodeModuleJsDepth !== newOptions.maxNodeModuleJsDepth) ||\r\n            !arrayIsEqualTo(oldOptions.lib, newOptions.lib) ||\r\n            !arrayIsEqualTo(oldOptions.typeRoots, newOptions.typeRoots) ||\r\n            !arrayIsEqualTo(oldOptions.rootDirs, newOptions.rootDirs) ||\r\n            !equalOwnProperties(oldOptions.paths, newOptions.paths);\r\n    }\r\n\r\n    /**\r\n     * Compacts an array, removing any falsey elements.\r\n     */\r\n    export function compact<T>(array: T[]): T[];\r\n    export function compact<T>(array: ReadonlyArray<T>): ReadonlyArray<T>;\r\n    export function compact<T>(array: T[]): T[] {\r\n        let result: T[];\r\n        if (array) {\r\n            for (let i = 0; i < array.length; i++) {\r\n                const v = array[i];\r\n                if (result || !v) {\r\n                    if (!result) {\r\n                        result = array.slice(0, i);\r\n                    }\r\n                    if (v) {\r\n                        result.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result || array;\r\n    }\r\n\r\n    /**\r\n     * Gets the relative complement of `arrayA` with respect to `arrayB`, returning the elements that\r\n     * are not present in `arrayA` but are present in `arrayB`. Assumes both arrays are sorted\r\n     * based on the provided comparer.\r\n     */\r\n    export function relativeComplement<T>(arrayA: T[] | undefined, arrayB: T[] | undefined, comparer: Comparer<T>): T[] | undefined {\r\n        if (!arrayB || !arrayA || arrayB.length === 0 || arrayA.length === 0) return arrayB;\r\n        const result: T[] = [];\r\n        loopB: for (let offsetA = 0, offsetB = 0; offsetB < arrayB.length; offsetB++) {\r\n            if (offsetB > 0) {\r\n                // Ensure `arrayB` is properly sorted.\r\n                Debug.assertGreaterThanOrEqual(comparer(arrayB[offsetB], arrayB[offsetB - 1]), Comparison.EqualTo);\r\n            }\r\n\r\n            loopA: for (const startA = offsetA; offsetA < arrayA.length; offsetA++) {\r\n                if (offsetA > startA) {\r\n                    // Ensure `arrayA` is properly sorted. We only need to perform this check if\r\n                    // `offsetA` has changed since we entered the loop.\r\n                    Debug.assertGreaterThanOrEqual(comparer(arrayA[offsetA], arrayA[offsetA - 1]), Comparison.EqualTo);\r\n                }\r\n\r\n                switch (comparer(arrayB[offsetB], arrayA[offsetA])) {\r\n                    case Comparison.LessThan:\r\n                        // If B is less than A, B does not exist in arrayA. Add B to the result and\r\n                        // move to the next element in arrayB without changing the current position\r\n                        // in arrayA.\r\n                        result.push(arrayB[offsetB]);\r\n                        continue loopB;\r\n                    case Comparison.EqualTo:\r\n                        // If B is equal to A, B exists in arrayA. Move to the next element in\r\n                        // arrayB without adding B to the result or changing the current position\r\n                        // in arrayA.\r\n                        continue loopB;\r\n                    case Comparison.GreaterThan:\r\n                        // If B is greater than A, we need to keep looking for B in arrayA. Move to\r\n                        // the next element in arrayA and recheck.\r\n                        continue loopA;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function sum<T extends Record<K, number>, K extends string>(array: ReadonlyArray<T>, prop: K): number {\r\n        let result = 0;\r\n        for (const v of array) {\r\n            result += v[prop];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Appends a value to an array, returning the array.\r\n     *\r\n     * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\r\n     * is created if `value` was appended.\r\n     * @param value The value to append to the array. If `value` is `undefined`, nothing is\r\n     * appended.\r\n     */\r\n    export function append<T>(to: T[] | undefined, value: T | undefined): T[] | undefined {\r\n        if (value === undefined) return to;\r\n        if (to === undefined) return [value];\r\n        to.push(value);\r\n        return to;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual offset into an array for a relative offset. Negative offsets indicate a\r\n     * position offset from the end of the array.\r\n     */\r\n    function toOffset(array: ReadonlyArray<any>, offset: number) {\r\n        return offset < 0 ? array.length + offset : offset;\r\n    }\r\n\r\n    /**\r\n     * Appends a range of value to an array, returning the array.\r\n     *\r\n     * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\r\n     * is created if `value` was appended.\r\n     * @param from The values to append to the array. If `from` is `undefined`, nothing is\r\n     * appended. If an element of `from` is `undefined`, that element is not appended.\r\n     * @param start The offset in `from` at which to start copying values.\r\n     * @param end The offset in `from` at which to stop copying values (non-inclusive).\r\n     */\r\n    export function addRange<T>(to: T[] | undefined, from: ReadonlyArray<T> | undefined, start?: number, end?: number): T[] | undefined {\r\n        if (from === undefined || from.length === 0) return to;\r\n        if (to === undefined) return from.slice(start, end);\r\n        start = start === undefined ? 0 : toOffset(from, start);\r\n        end = end === undefined ? from.length : toOffset(from, end);\r\n        for (let i = start; i < end && i < from.length; i++) {\r\n            if (from[i] !== undefined) {\r\n                to.push(from[i]);\r\n            }\r\n        }\r\n        return to;\r\n    }\r\n\r\n    /**\r\n     * @return Whether the value was added.\r\n     */\r\n    export function pushIfUnique<T>(array: T[], toAdd: T, equalityComparer?: EqualityComparer<T>): boolean {\r\n        if (contains(array, toAdd, equalityComparer)) {\r\n            return false;\r\n        }\r\n        else {\r\n            array.push(toAdd);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unlike `pushIfUnique`, this can take `undefined` as an input, and returns a new array.\r\n     */\r\n    export function appendIfUnique<T>(array: T[] | undefined, toAdd: T, equalityComparer?: EqualityComparer<T>): T[] {\r\n        if (array) {\r\n            pushIfUnique(array, toAdd, equalityComparer);\r\n            return array;\r\n        }\r\n        else {\r\n            return [toAdd];\r\n        }\r\n    }\r\n\r\n    function stableSortIndices<T>(array: ReadonlyArray<T>, indices: number[], comparer: Comparer<T>) {\r\n        // sort indices by value then position\r\n        indices.sort((x, y) => comparer(array[x], array[y]) || compareValues(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns a new sorted array.\r\n     */\r\n    export function sort<T>(array: ReadonlyArray<T>, comparer: Comparer<T>) {\r\n        return array.slice().sort(comparer);\r\n    }\r\n\r\n    export function best<T>(iter: Iterator<T>, isBetter: (a: T, b: T) => boolean): T | undefined {\r\n        const x = iter.next();\r\n        if (x.done) {\r\n            return undefined;\r\n        }\r\n        let best = x.value;\r\n        while (true) {\r\n            const { value, done } = iter.next();\r\n            if (done) {\r\n                return best;\r\n            }\r\n            if (isBetter(value, best)) {\r\n                best = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function arrayIterator<T>(array: ReadonlyArray<T>): Iterator<T> {\r\n        let i = 0;\r\n        return { next: () => {\r\n            if (i === array.length) {\r\n                return { value: undefined as never, done: true };\r\n            }\r\n            else {\r\n                i++;\r\n                return { value: array[i - 1], done: false };\r\n            }\r\n        }};\r\n    }\r\n\r\n    /**\r\n     * Stable sort of an array. Elements equal to each other maintain their relative position in the array.\r\n     */\r\n    export function stableSort<T>(array: ReadonlyArray<T>, comparer: Comparer<T>) {\r\n        const indices = array.map((_, i) => i);\r\n        stableSortIndices(array, indices, comparer);\r\n        return indices.map(i => array[i]);\r\n    }\r\n\r\n    export function rangeEquals<T>(array1: ReadonlyArray<T>, array2: ReadonlyArray<T>, pos: number, end: number) {\r\n        while (pos < end) {\r\n            if (array1[pos] !== array2[pos]) {\r\n                return false;\r\n            }\r\n            pos++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the element at a specific offset in an array if non-empty, `undefined` otherwise.\r\n     * A negative offset indicates the element should be retrieved from the end of the array.\r\n     */\r\n    export function elementAt<T>(array: ReadonlyArray<T> | undefined, offset: number): T | undefined {\r\n        if (array) {\r\n            offset = toOffset(array, offset);\r\n            if (offset < array.length) {\r\n                return array[offset];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the first element of an array if non-empty, `undefined` otherwise.\r\n     */\r\n    export function firstOrUndefined<T>(array: ReadonlyArray<T>): T | undefined {\r\n        return array.length === 0 ? undefined : array[0];\r\n    }\r\n\r\n    export function first<T>(array: ReadonlyArray<T>): T {\r\n        Debug.assert(array.length !== 0);\r\n        return array[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the last element of an array if non-empty, `undefined` otherwise.\r\n     */\r\n    export function lastOrUndefined<T>(array: ReadonlyArray<T>): T | undefined {\r\n        return array.length === 0 ? undefined : array[array.length - 1];\r\n    }\r\n\r\n    export function last<T>(array: ReadonlyArray<T>): T {\r\n        Debug.assert(array.length !== 0);\r\n        return array[array.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Returns the only element of an array if it contains only one element, `undefined` otherwise.\r\n     */\r\n    export function singleOrUndefined<T>(array: ReadonlyArray<T>): T | undefined {\r\n        return array && array.length === 1\r\n            ? array[0]\r\n            : undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the only element of an array if it contains only one element; otheriwse, returns the\r\n     * array.\r\n     */\r\n    export function singleOrMany<T>(array: T[]): T | T[];\r\n    export function singleOrMany<T>(array: ReadonlyArray<T>): T | ReadonlyArray<T>;\r\n    export function singleOrMany<T>(array: T[]): T | T[] {\r\n        return array && array.length === 1\r\n            ? array[0]\r\n            : array;\r\n    }\r\n\r\n    export function replaceElement<T>(array: ReadonlyArray<T>, index: number, value: T): T[] {\r\n        const result = array.slice(0);\r\n        result[index] = value;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Performs a binary search, finding the index at which `value` occurs in `array`.\r\n     * If no such index is found, returns the 2's-complement of first index at which\r\n     * `array[index]` exceeds `value`.\r\n     * @param array A sorted array whose first element must be no larger than number\r\n     * @param value The value to be searched for in the array.\r\n     * @param keySelector A callback used to select the search key from `value` and each element of\r\n     * `array`.\r\n     * @param keyComparer A callback used to compare two keys in a sorted array.\r\n     * @param offset An offset into `array` at which to start the search.\r\n     */\r\n    export function binarySearch<T, U>(array: ReadonlyArray<T>, value: T, keySelector: (v: T) => U, keyComparer: Comparer<U>, offset?: number): number {\r\n        if (!array || array.length === 0) {\r\n            return -1;\r\n        }\r\n\r\n        let low = offset || 0;\r\n        let high = array.length - 1;\r\n        const key = keySelector(value);\r\n        while (low <= high) {\r\n            const middle = low + ((high - low) >> 1);\r\n            const midKey = keySelector(array[middle]);\r\n            switch (keyComparer(midKey, key)) {\r\n                case Comparison.LessThan:\r\n                    low = middle + 1;\r\n                    break;\r\n                case Comparison.EqualTo:\r\n                    return middle;\r\n                case Comparison.GreaterThan:\r\n                    high = middle - 1;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return ~low;\r\n    }\r\n\r\n    export function reduceLeft<T, U>(array: ReadonlyArray<T>, f: (memo: U, value: T, i: number) => U, initial: U, start?: number, count?: number): U;\r\n    export function reduceLeft<T>(array: ReadonlyArray<T>, f: (memo: T, value: T, i: number) => T): T;\r\n    export function reduceLeft<T>(array: T[], f: (memo: T, value: T, i: number) => T, initial?: T, start?: number, count?: number): T {\r\n        if (array && array.length > 0) {\r\n            const size = array.length;\r\n            if (size > 0) {\r\n                let pos = start === undefined || start < 0 ? 0 : start;\r\n                const end = count === undefined || pos + count > size - 1 ? size - 1 : pos + count;\r\n                let result: T;\r\n                if (arguments.length <= 2) {\r\n                    result = array[pos];\r\n                    pos++;\r\n                }\r\n                else {\r\n                    result = initial;\r\n                }\r\n                while (pos <= end) {\r\n                    result = f(result, array[pos], pos);\r\n                    pos++;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return initial;\r\n    }\r\n\r\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    /**\r\n     * Indicates whether a map-like contains an own property with the specified key.\r\n     *\r\n     * @param map A map-like.\r\n     * @param key A property key.\r\n     */\r\n    export function hasProperty(map: MapLike<any>, key: string): boolean {\r\n        return hasOwnProperty.call(map, key);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of an owned property in a map-like.\r\n     *\r\n     * @param map A map-like.\r\n     * @param key A property key.\r\n     */\r\n    export function getProperty<T>(map: MapLike<T>, key: string): T | undefined {\r\n        return hasOwnProperty.call(map, key) ? map[key] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the owned, enumerable property keys of a map-like.\r\n     */\r\n    export function getOwnKeys<T>(map: MapLike<T>): string[] {\r\n        const keys: string[] = [];\r\n        for (const key in map) {\r\n            if (hasOwnProperty.call(map, key)) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n\r\n        return keys;\r\n    }\r\n\r\n    export function getOwnValues<T>(sparseArray: T[]): T[] {\r\n        const values: T[] = [];\r\n        for (const key in sparseArray) {\r\n            if (hasOwnProperty.call(sparseArray, key)) {\r\n                values.push(sparseArray[key]);\r\n            }\r\n        }\r\n\r\n        return values;\r\n    }\r\n\r\n    /** Shims `Array.from`. */\r\n    export function arrayFrom<T, U>(iterator: Iterator<T>, map: (t: T) => U): U[];\r\n    export function arrayFrom<T>(iterator: Iterator<T>): T[];\r\n    export function arrayFrom(iterator: Iterator<any>, map?: (t: any) => any): any[] {\r\n        const result: any[] = [];\r\n        for (let { value, done } = iterator.next(); !done; { value, done } = iterator.next()) {\r\n            result.push(map ? map(value) : value);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calls `callback` for each entry in the map, returning the first truthy result.\r\n     * Use `map.forEach` instead for normal iteration.\r\n     */\r\n    export function forEachEntry<T, U>(map: ReadonlyUnderscoreEscapedMap<T>, callback: (value: T, key: __String) => U | undefined): U | undefined;\r\n    export function forEachEntry<T, U>(map: ReadonlyMap<T>, callback: (value: T, key: string) => U | undefined): U | undefined;\r\n    export function forEachEntry<T, U>(map: ReadonlyUnderscoreEscapedMap<T> | ReadonlyMap<T>, callback: (value: T, key: (string & __String)) => U | undefined): U | undefined {\r\n        const iterator = map.entries();\r\n        for (let { value: pair, done } = iterator.next(); !done; { value: pair, done } = iterator.next()) {\r\n            const [key, value] = pair;\r\n            const result = callback(value, key as (string & __String));\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** `forEachEntry` for just keys. */\r\n    export function forEachKey<T>(map: ReadonlyUnderscoreEscapedMap<{}>, callback: (key: __String) => T | undefined): T | undefined;\r\n    export function forEachKey<T>(map: ReadonlyMap<{}>, callback: (key: string) => T | undefined): T | undefined;\r\n    export function forEachKey<T>(map: ReadonlyUnderscoreEscapedMap<{}> | ReadonlyMap<{}>, callback: (key: string & __String) => T | undefined): T | undefined {\r\n        const iterator = map.keys();\r\n        for (let { value: key, done } = iterator.next(); !done; { value: key, done } = iterator.next()) {\r\n            const result = callback(key as string & __String);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /** Copy entries from `source` to `target`. */\r\n    export function copyEntries<T>(source: ReadonlyUnderscoreEscapedMap<T>, target: UnderscoreEscapedMap<T>): void;\r\n    export function copyEntries<T>(source: ReadonlyMap<T>, target: Map<T>): void;\r\n    export function copyEntries<T, U extends UnderscoreEscapedMap<T> | Map<T>>(source: U, target: U): void {\r\n        (source as Map<T>).forEach((value, key) => {\r\n            (target as Map<T>).set(key, value);\r\n        });\r\n    }\r\n\r\n    export function assign<T extends object>(t: T, ...args: T[]) {\r\n        for (const arg of args) {\r\n            for (const p in arg) {\r\n                if (hasProperty(arg, p)) {\r\n                    t[p] = arg[p];\r\n                }\r\n            }\r\n        }\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Performs a shallow equality comparison of the contents of two map-likes.\r\n     *\r\n     * @param left A map-like whose properties should be compared.\r\n     * @param right A map-like whose properties should be compared.\r\n     */\r\n    export function equalOwnProperties<T>(left: MapLike<T>, right: MapLike<T>, equalityComparer: EqualityComparer<T> = equateValues) {\r\n        if (left === right) return true;\r\n        if (!left || !right) return false;\r\n        for (const key in left) {\r\n            if (hasOwnProperty.call(left, key)) {\r\n                if (!hasOwnProperty.call(right, key) === undefined) return false;\r\n                if (!equalityComparer(left[key], right[key])) return false;\r\n            }\r\n        }\r\n\r\n        for (const key in right) {\r\n            if (hasOwnProperty.call(right, key)) {\r\n                if (!hasOwnProperty.call(left, key)) return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a map from the elements of an array.\r\n     *\r\n     * @param array the array of input elements.\r\n     * @param makeKey a function that produces a key for a given element.\r\n     *\r\n     * This function makes no effort to avoid collisions; if any two elements produce\r\n     * the same key with the given 'makeKey' function, then the element with the higher\r\n     * index in the array will be the one associated with the produced key.\r\n     */\r\n    export function arrayToMap<T>(array: ReadonlyArray<T>, makeKey: (value: T) => string | undefined): Map<T>;\r\n    export function arrayToMap<T, U>(array: ReadonlyArray<T>, makeKey: (value: T) => string | undefined, makeValue: (value: T) => U): Map<U>;\r\n    export function arrayToMap<T, U>(array: ReadonlyArray<T>, makeKey: (value: T) => string | undefined, makeValue: (value: T) => T | U = identity): Map<T | U> {\r\n        const result = createMap<T | U>();\r\n        for (const value of array) {\r\n            const key = makeKey(value);\r\n            if (key !== undefined) result.set(key, makeValue(value));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function arrayToNumericMap<T>(array: ReadonlyArray<T>, makeKey: (value: T) => number): T[];\r\n    export function arrayToNumericMap<T, U>(array: ReadonlyArray<T>, makeKey: (value: T) => number, makeValue: (value: T) => U): U[];\r\n    export function arrayToNumericMap<T, U>(array: ReadonlyArray<T>, makeKey: (value: T) => number, makeValue: (value: T) => T | U = identity): (T | U)[] {\r\n        const result: (T | U)[] = [];\r\n        for (const value of array) {\r\n            result[makeKey(value)] = makeValue(value);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a set from the elements of an array.\r\n     *\r\n     * @param array the array of input elements.\r\n     */\r\n    export function arrayToSet(array: ReadonlyArray<string>): Map<true>;\r\n    export function arrayToSet<T>(array: ReadonlyArray<T>, makeKey: (value: T) => string | undefined): Map<true>;\r\n    export function arrayToSet<T>(array: ReadonlyArray<T>, makeKey: (value: T) => __String | undefined): UnderscoreEscapedMap<true>;\r\n    export function arrayToSet(array: ReadonlyArray<any>, makeKey?: (value: any) => string | __String | undefined): Map<true> | UnderscoreEscapedMap<true> {\r\n        return arrayToMap<any, true>(array, makeKey || (s => s), () => true);\r\n    }\r\n\r\n    export function arrayToMultiMap<T>(values: ReadonlyArray<T>, makeKey: (value: T) => string): MultiMap<T>;\r\n    export function arrayToMultiMap<T, U>(values: ReadonlyArray<T>, makeKey: (value: T) => string, makeValue: (value: T) => U): MultiMap<U>;\r\n    export function arrayToMultiMap<T, U>(values: ReadonlyArray<T>, makeKey: (value: T) => string, makeValue: (value: T) => T | U = identity): MultiMap<T | U> {\r\n        const result = createMultiMap<T | U>();\r\n        for (const value of values) {\r\n            result.add(makeKey(value), makeValue(value));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function group<T>(values: ReadonlyArray<T>, getGroupId: (value: T) => string): ReadonlyArray<ReadonlyArray<T>> {\r\n        return arrayFrom(arrayToMultiMap(values, getGroupId).values());\r\n    }\r\n\r\n    export function cloneMap(map: SymbolTable): SymbolTable;\r\n    export function cloneMap<T>(map: ReadonlyMap<T>): Map<T>;\r\n    export function cloneMap<T>(map: ReadonlyUnderscoreEscapedMap<T>): UnderscoreEscapedMap<T>;\r\n    export function cloneMap<T>(map: ReadonlyMap<T> | ReadonlyUnderscoreEscapedMap<T> | SymbolTable): Map<T> | UnderscoreEscapedMap<T> | SymbolTable {\r\n        const clone = createMap<T>();\r\n        copyEntries(map as Map<T>, clone);\r\n        return clone;\r\n    }\r\n\r\n    export function clone<T>(object: T): T {\r\n        const result: any = {};\r\n        for (const id in object) {\r\n            if (hasOwnProperty.call(object, id)) {\r\n                result[id] = (<any>object)[id];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function extend<T1, T2>(first: T1, second: T2): T1 & T2 {\r\n        const result: T1 & T2 = <any>{};\r\n        for (const id in second) {\r\n            if (hasOwnProperty.call(second, id)) {\r\n                (result as any)[id] = (second as any)[id];\r\n            }\r\n        }\r\n\r\n        for (const id in first) {\r\n            if (hasOwnProperty.call(first, id)) {\r\n                (result as any)[id] = (first as any)[id];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    export interface MultiMap<T> extends Map<T[]> {\r\n        /**\r\n         * Adds the value to an array of values associated with the key, and returns the array.\r\n         * Creates the array if it does not already exist.\r\n         */\r\n        add(key: string, value: T): T[];\r\n        /**\r\n         * Removes a value from an array of values associated with the key.\r\n         * Does not preserve the order of those values.\r\n         * Does nothing if `key` is not in `map`, or `value` is not in `map[key]`.\r\n         */\r\n        remove(key: string, value: T): void;\r\n    }\r\n\r\n    export function createMultiMap<T>(): MultiMap<T> {\r\n        const map = createMap<T[]>() as MultiMap<T>;\r\n        map.add = multiMapAdd;\r\n        map.remove = multiMapRemove;\r\n        return map;\r\n    }\r\n    function multiMapAdd<T>(this: MultiMap<T>, key: string, value: T) {\r\n        let values = this.get(key);\r\n        if (values) {\r\n            values.push(value);\r\n        }\r\n        else {\r\n            this.set(key, values = [value]);\r\n        }\r\n        return values;\r\n    }\r\n    function multiMapRemove<T>(this: MultiMap<T>, key: string, value: T) {\r\n        const values = this.get(key);\r\n        if (values) {\r\n            unorderedRemoveItem(values, value);\r\n            if (!values.length) {\r\n                this.delete(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests whether a value is an array.\r\n     */\r\n    export function isArray(value: any): value is ReadonlyArray<{}> {\r\n        return Array.isArray ? Array.isArray(value) : value instanceof Array;\r\n    }\r\n\r\n    export function toArray<T>(value: T | T[]): T[];\r\n    export function toArray<T>(value: T | ReadonlyArray<T>): ReadonlyArray<T>;\r\n    export function toArray<T>(value: T | T[]): T[] {\r\n        return isArray(value) ? value : [value];\r\n    }\r\n\r\n    /**\r\n     * Tests whether a value is string\r\n     */\r\n    export function isString(text: any): text is string {\r\n        return typeof text === \"string\";\r\n    }\r\n\r\n    export function tryCast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut | undefined {\r\n        return value !== undefined && test(value) ? value : undefined;\r\n    }\r\n\r\n    export function cast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut {\r\n        if (value !== undefined && test(value)) return value;\r\n\r\n        if (value && typeof (value as any).kind === \"number\") {\r\n            Debug.fail(`Invalid cast. The supplied ${Debug.showSyntaxKind(value as any as Node)} did not pass the test '${Debug.getFunctionName(test)}'.`);\r\n        }\r\n        else {\r\n            Debug.fail(`Invalid cast. The supplied value did not pass the test '${Debug.getFunctionName(test)}'.`);\r\n        }\r\n    }\r\n\r\n    /** Does nothing. */\r\n    export function noop(_?: {} | null | undefined): void { } // tslint:disable-line no-empty\r\n\r\n    /** Do nothing and return false */\r\n    export function returnFalse(): false { return false; }\r\n\r\n    /** Do nothing and return true */\r\n    export function returnTrue(): true { return true; }\r\n\r\n    /** Returns its argument. */\r\n    export function identity<T>(x: T) { return x; }\r\n\r\n    /** Returns lower case string */\r\n    export function toLowerCase(x: string) { return x.toLowerCase(); }\r\n\r\n    /** Throws an error because a function is not implemented. */\r\n    export function notImplemented(): never {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    export function memoize<T>(callback: () => T): () => T {\r\n        let value: T;\r\n        return () => {\r\n            if (callback) {\r\n                value = callback();\r\n                callback = undefined;\r\n            }\r\n            return value;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * High-order function, creates a function that executes a function composition.\r\n     * For example, `chain(a, b)` is the equivalent of `x => ((a', b') => y => b'(a'(y)))(a(x), b(x))`\r\n     *\r\n     * @param args The functions to chain.\r\n     */\r\n    export function chain<T, U>(...args: ((t: T) => (u: U) => U)[]): (t: T) => (u: U) => U;\r\n    export function chain<T, U>(a: (t: T) => (u: U) => U, b: (t: T) => (u: U) => U, c: (t: T) => (u: U) => U, d: (t: T) => (u: U) => U, e: (t: T) => (u: U) => U): (t: T) => (u: U) => U {\r\n        if (e) {\r\n            const args: ((t: T) => (u: U) => U)[] = [];\r\n            for (let i = 0; i < arguments.length; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n\r\n            return t => compose(...map(args, f => f(t)));\r\n        }\r\n        else if (d) {\r\n            return t => compose(a(t), b(t), c(t), d(t));\r\n        }\r\n        else if (c) {\r\n            return t => compose(a(t), b(t), c(t));\r\n        }\r\n        else if (b) {\r\n            return t => compose(a(t), b(t));\r\n        }\r\n        else if (a) {\r\n            return t => compose(a(t));\r\n        }\r\n        else {\r\n            return _ => u => u;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * High-order function, composes functions. Note that functions are composed inside-out;\r\n     * for example, `compose(a, b)` is the equivalent of `x => b(a(x))`.\r\n     *\r\n     * @param args The functions to compose.\r\n     */\r\n    export function compose<T>(...args: ((t: T) => T)[]): (t: T) => T;\r\n    export function compose<T>(a: (t: T) => T, b: (t: T) => T, c: (t: T) => T, d: (t: T) => T, e: (t: T) => T): (t: T) => T {\r\n        if (e) {\r\n            const args: ((t: T) => T)[] = [];\r\n            for (let i = 0; i < arguments.length; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n\r\n            return t => reduceLeft(args, (u, f) => f(u), t);\r\n        }\r\n        else if (d) {\r\n            return t => d(c(b(a(t))));\r\n        }\r\n        else if (c) {\r\n            return t => c(b(a(t)));\r\n        }\r\n        else if (b) {\r\n            return t => b(a(t));\r\n        }\r\n        else if (a) {\r\n            return t => a(t);\r\n        }\r\n        else {\r\n            return t => t;\r\n        }\r\n    }\r\n\r\n    export function formatStringFromArgs(text: string, args: ArrayLike<string>, baseIndex?: number): string {\r\n        baseIndex = baseIndex || 0;\r\n\r\n        return text.replace(/{(\\d+)}/g, (_match, index?: string) => Debug.assertDefined(args[+index + baseIndex]));\r\n    }\r\n\r\n    export let localizedDiagnosticMessages: MapLike<string>;\r\n\r\n    export function getLocaleSpecificMessage(message: DiagnosticMessage) {\r\n        return localizedDiagnosticMessages && localizedDiagnosticMessages[message.key] || message.message;\r\n    }\r\n\r\n    export function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage, ...args: (string | number)[]): Diagnostic;\r\n    export function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage): Diagnostic {\r\n        Debug.assertGreaterThanOrEqual(start, 0);\r\n        Debug.assertGreaterThanOrEqual(length, 0);\r\n\r\n        if (file) {\r\n            Debug.assertLessThanOrEqual(start, file.text.length);\r\n            Debug.assertLessThanOrEqual(start + length, file.text.length);\r\n        }\r\n\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 4) {\r\n            text = formatStringFromArgs(text, arguments, 4);\r\n        }\r\n\r\n        return {\r\n            file,\r\n            start,\r\n            length,\r\n\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code,\r\n            reportsUnnecessary: message.reportsUnnecessary,\r\n        };\r\n    }\r\n\r\n    /* internal */\r\n    export function formatMessage(_dummy: any, message: DiagnosticMessage): string {\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 2) {\r\n            text = formatStringFromArgs(text, arguments, 2);\r\n        }\r\n\r\n        return text;\r\n    }\r\n\r\n    export function createCompilerDiagnostic(message: DiagnosticMessage, ...args: (string | number)[]): Diagnostic;\r\n    export function createCompilerDiagnostic(message: DiagnosticMessage): Diagnostic {\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 1) {\r\n            text = formatStringFromArgs(text, arguments, 1);\r\n        }\r\n\r\n        return {\r\n            file: undefined,\r\n            start: undefined,\r\n            length: undefined,\r\n\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code,\r\n            reportsUnnecessary: message.reportsUnnecessary,\r\n        };\r\n    }\r\n\r\n    export function createCompilerDiagnosticFromMessageChain(chain: DiagnosticMessageChain): Diagnostic {\r\n        return {\r\n            file: undefined,\r\n            start: undefined,\r\n            length: undefined,\r\n\r\n            code: chain.code,\r\n            category: chain.category,\r\n            messageText: chain.next ? chain : chain.messageText,\r\n        };\r\n    }\r\n\r\n    export function chainDiagnosticMessages(details: DiagnosticMessageChain, message: DiagnosticMessage, ...args: string[]): DiagnosticMessageChain;\r\n    export function chainDiagnosticMessages(details: DiagnosticMessageChain, message: DiagnosticMessage): DiagnosticMessageChain {\r\n        let text = getLocaleSpecificMessage(message);\r\n\r\n        if (arguments.length > 2) {\r\n            text = formatStringFromArgs(text, arguments, 2);\r\n        }\r\n\r\n        return {\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code,\r\n\r\n            next: details\r\n        };\r\n    }\r\n\r\n    export function concatenateDiagnosticMessageChains(headChain: DiagnosticMessageChain, tailChain: DiagnosticMessageChain): DiagnosticMessageChain {\r\n        let lastChain = headChain;\r\n        while (lastChain.next) {\r\n            lastChain = lastChain.next;\r\n        }\r\n\r\n        lastChain.next = tailChain;\r\n        return headChain;\r\n    }\r\n\r\n    export function equateValues<T>(a: T, b: T) {\r\n        return a === b;\r\n    }\r\n\r\n    /**\r\n     * Compare the equality of two strings using a case-sensitive ordinal comparison.\r\n     *\r\n     * Case-sensitive comparisons compare both strings one code-point at a time using the integer\r\n     * value of each code-point after applying `toUpperCase` to each string. We always map both\r\n     * strings to their upper-case form as some unicode characters do not properly round-trip to\r\n     * lowercase (such as `` (German sharp capital s)).\r\n     */\r\n    export function equateStringsCaseInsensitive(a: string, b: string) {\r\n        return a === b\r\n            || a !== undefined\r\n            && b !== undefined\r\n            && a.toUpperCase() === b.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Compare the equality of two strings using a case-sensitive ordinal comparison.\r\n     *\r\n     * Case-sensitive comparisons compare both strings one code-point at a time using the\r\n     * integer value of each code-point.\r\n     */\r\n    export function equateStringsCaseSensitive(a: string, b: string) {\r\n        return equateValues(a, b);\r\n    }\r\n\r\n    function compareComparableValues(a: string, b: string): Comparison;\r\n    function compareComparableValues(a: number, b: number): Comparison;\r\n    function compareComparableValues(a: string | number, b: string | number) {\r\n        return a === b ? Comparison.EqualTo :\r\n            a === undefined ? Comparison.LessThan :\r\n            b === undefined ? Comparison.GreaterThan :\r\n            a < b ? Comparison.LessThan :\r\n            Comparison.GreaterThan;\r\n    }\r\n\r\n    /**\r\n     * Compare two numeric values for their order relative to each other.\r\n     * To compare strings, use any of the `compareStrings` functions.\r\n     */\r\n    export function compareValues(a: number, b: number) {\r\n        return compareComparableValues(a, b);\r\n    }\r\n\r\n    export function min<T>(a: T, b: T, compare: Comparer<T>): T {\r\n        return compare(a, b) === Comparison.LessThan ? a : b;\r\n    }\r\n\r\n    /**\r\n     * Compare two strings using a case-insensitive ordinal comparison.\r\n     *\r\n     * Ordinal comparisons are based on the difference between the unicode code points of both\r\n     * strings. Characters with multiple unicode representations are considered unequal. Ordinal\r\n     * comparisons provide predictable ordering, but place \"a\" after \"B\".\r\n     *\r\n     * Case-insensitive comparisons compare both strings one code-point at a time using the integer\r\n     * value of each code-point after applying `toUpperCase` to each string. We always map both\r\n     * strings to their upper-case form as some unicode characters do not properly round-trip to\r\n     * lowercase (such as `` (German sharp capital s)).\r\n     */\r\n    export function compareStringsCaseInsensitive(a: string, b: string) {\r\n        if (a === b) return Comparison.EqualTo;\r\n        if (a === undefined) return Comparison.LessThan;\r\n        if (b === undefined) return Comparison.GreaterThan;\r\n        a = a.toUpperCase();\r\n        b = b.toUpperCase();\r\n        return a < b ? Comparison.LessThan : a > b ? Comparison.GreaterThan : Comparison.EqualTo;\r\n    }\r\n\r\n    /**\r\n     * Compare two strings using a case-sensitive ordinal comparison.\r\n     *\r\n     * Ordinal comparisons are based on the difference between the unicode code points of both\r\n     * strings. Characters with multiple unicode representations are considered unequal. Ordinal\r\n     * comparisons provide predictable ordering, but place \"a\" after \"B\".\r\n     *\r\n     * Case-sensitive comparisons compare both strings one code-point at a time using the integer\r\n     * value of each code-point.\r\n     */\r\n    export function compareStringsCaseSensitive(a: string, b: string) {\r\n        return compareComparableValues(a, b);\r\n    }\r\n\r\n    export function getStringComparer(ignoreCase?: boolean) {\r\n        return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;\r\n    }\r\n\r\n    /**\r\n     * Creates a string comparer for use with string collation in the UI.\r\n     */\r\n    const createUIStringComparer = (() => {\r\n        let defaultComparer: Comparer<string> | undefined;\r\n        let enUSComparer: Comparer<string> | undefined;\r\n\r\n        const stringComparerFactory = getStringComparerFactory();\r\n        return createStringComparer;\r\n\r\n        function compareWithCallback(a: string | undefined, b: string | undefined, comparer: (a: string, b: string) => number) {\r\n            if (a === b) return Comparison.EqualTo;\r\n            if (a === undefined) return Comparison.LessThan;\r\n            if (b === undefined) return Comparison.GreaterThan;\r\n            const value = comparer(a, b);\r\n            return value < 0 ? Comparison.LessThan : value > 0 ? Comparison.GreaterThan : Comparison.EqualTo;\r\n        }\r\n\r\n        function createIntlCollatorStringComparer(locale: string | undefined): Comparer<string> {\r\n            // Intl.Collator.prototype.compare is bound to the collator. See NOTE in\r\n            // http://www.ecma-international.org/ecma-402/2.0/#sec-Intl.Collator.prototype.compare\r\n            const comparer = new Intl.Collator(locale, { usage: \"sort\", sensitivity: \"variant\" }).compare;\r\n            return (a, b) => compareWithCallback(a, b, comparer);\r\n        }\r\n\r\n        function createLocaleCompareStringComparer(locale: string | undefined): Comparer<string> {\r\n            // if the locale is not the default locale (`undefined`), use the fallback comparer.\r\n            if (locale !== undefined) return createFallbackStringComparer();\r\n\r\n            return (a, b) => compareWithCallback(a, b, compareStrings);\r\n\r\n            function compareStrings(a: string, b: string) {\r\n                return a.localeCompare(b);\r\n            }\r\n        }\r\n\r\n        function createFallbackStringComparer(): Comparer<string> {\r\n            // An ordinal comparison puts \"A\" after \"b\", but for the UI we want \"A\" before \"b\".\r\n            // We first sort case insensitively.  So \"Aaa\" will come before \"baa\".\r\n            // Then we sort case sensitively, so \"aaa\" will come before \"Aaa\".\r\n            //\r\n            // For case insensitive comparisons we always map both strings to their\r\n            // upper-case form as some unicode characters do not properly round-trip to\r\n            // lowercase (such as `` (German sharp capital s)).\r\n            return (a, b) => compareWithCallback(a, b, compareDictionaryOrder);\r\n\r\n            function compareDictionaryOrder(a: string, b: string) {\r\n                return compareStrings(a.toUpperCase(), b.toUpperCase()) || compareStrings(a, b);\r\n            }\r\n\r\n            function compareStrings(a: string, b: string) {\r\n                return a < b ? Comparison.LessThan : a > b ? Comparison.GreaterThan : Comparison.EqualTo;\r\n            }\r\n        }\r\n\r\n        function getStringComparerFactory() {\r\n            // If the host supports Intl, we use it for comparisons using the default locale.\r\n            if (typeof Intl === \"object\" && typeof Intl.Collator === \"function\") {\r\n                return createIntlCollatorStringComparer;\r\n            }\r\n\r\n            // If the host does not support Intl, we fall back to localeCompare.\r\n            // localeCompare in Node v0.10 is just an ordinal comparison, so don't use it.\r\n            if (typeof String.prototype.localeCompare === \"function\" &&\r\n                typeof String.prototype.toLocaleUpperCase === \"function\" &&\r\n                \"a\".localeCompare(\"B\") < 0) {\r\n                return createLocaleCompareStringComparer;\r\n            }\r\n\r\n            // Otherwise, fall back to ordinal comparison:\r\n            return createFallbackStringComparer;\r\n        }\r\n\r\n        function createStringComparer(locale: string | undefined) {\r\n            // Hold onto common string comparers. This avoids constantly reallocating comparers during\r\n            // tests.\r\n            if (locale === undefined) {\r\n                return defaultComparer || (defaultComparer = stringComparerFactory(locale));\r\n            }\r\n            else if (locale === \"en-US\") {\r\n                return enUSComparer || (enUSComparer = stringComparerFactory(locale));\r\n            }\r\n            else {\r\n                return stringComparerFactory(locale);\r\n            }\r\n        }\r\n    })();\r\n\r\n    let uiComparerCaseSensitive: Comparer<string> | undefined;\r\n    let uiLocale: string | undefined;\r\n\r\n    export function getUILocale() {\r\n        return uiLocale;\r\n    }\r\n\r\n    export function setUILocale(value: string) {\r\n        if (uiLocale !== value) {\r\n            uiLocale = value;\r\n            uiComparerCaseSensitive = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compare two strings in a using the case-sensitive sort behavior of the UI locale.\r\n     *\r\n     * Ordering is not predictable between different host locales, but is best for displaying\r\n     * ordered data for UI presentation. Characters with multiple unicode representations may\r\n     * be considered equal.\r\n     *\r\n     * Case-sensitive comparisons compare strings that differ in base characters, or\r\n     * accents/diacritic marks, or case as unequal.\r\n     */\r\n    export function compareStringsCaseSensitiveUI(a: string, b: string) {\r\n        const comparer = uiComparerCaseSensitive || (uiComparerCaseSensitive = createUIStringComparer(uiLocale));\r\n        return comparer(a, b);\r\n    }\r\n\r\n    export function compareProperties<T, K extends keyof T>(a: T, b: T, key: K, comparer: Comparer<T[K]>) {\r\n        return a === b ? Comparison.EqualTo :\r\n            a === undefined ? Comparison.LessThan :\r\n            b === undefined ? Comparison.GreaterThan :\r\n            comparer(a[key], b[key]);\r\n    }\r\n\r\n    function getDiagnosticFileName(diagnostic: Diagnostic): string {\r\n        return diagnostic.file ? diagnostic.file.fileName : undefined;\r\n    }\r\n\r\n    export function compareDiagnostics(d1: Diagnostic, d2: Diagnostic): Comparison {\r\n        return compareStringsCaseSensitive(getDiagnosticFileName(d1), getDiagnosticFileName(d2)) ||\r\n            compareValues(d1.start, d2.start) ||\r\n            compareValues(d1.length, d2.length) ||\r\n            compareValues(d1.code, d2.code) ||\r\n            compareMessageText(d1.messageText, d2.messageText) ||\r\n            Comparison.EqualTo;\r\n    }\r\n\r\n    /** True is greater than false. */\r\n    export function compareBooleans(a: boolean, b: boolean): Comparison {\r\n        return compareValues(a ? 1 : 0, b ? 1 : 0);\r\n    }\r\n\r\n    function compareMessageText(text1: string | DiagnosticMessageChain, text2: string | DiagnosticMessageChain): Comparison {\r\n        while (text1 && text2) {\r\n            // We still have both chains.\r\n            const string1 = isString(text1) ? text1 : text1.messageText;\r\n            const string2 = isString(text2) ? text2 : text2.messageText;\r\n\r\n            const res = compareStringsCaseSensitive(string1, string2);\r\n            if (res) {\r\n                return res;\r\n            }\r\n\r\n            text1 = isString(text1) ? undefined : text1.next;\r\n            text2 = isString(text2) ? undefined : text2.next;\r\n        }\r\n\r\n        if (!text1 && !text2) {\r\n            // if the chains are done, then these messages are the same.\r\n            return Comparison.EqualTo;\r\n        }\r\n\r\n        // We still have one chain remaining.  The shorter chain should come first.\r\n        return text1 ? Comparison.GreaterThan : Comparison.LessThan;\r\n    }\r\n\r\n    export function normalizeSlashes(path: string): string {\r\n        return path.replace(/\\\\/g, \"/\");\r\n    }\r\n\r\n    /**\r\n     * Returns length of path root (i.e. length of \"/\", \"x:/\", \"//server/share/, file:///user/files\")\r\n     */\r\n    export function getRootLength(path: string): number {\r\n        if (path.charCodeAt(0) === CharacterCodes.slash) {\r\n            if (path.charCodeAt(1) !== CharacterCodes.slash) return 1;\r\n            const p1 = path.indexOf(\"/\", 2);\r\n            if (p1 < 0) return 2;\r\n            const p2 = path.indexOf(\"/\", p1 + 1);\r\n            if (p2 < 0) return p1 + 1;\r\n            return p2 + 1;\r\n        }\r\n        if (path.charCodeAt(1) === CharacterCodes.colon) {\r\n            if (path.charCodeAt(2) === CharacterCodes.slash || path.charCodeAt(2) === CharacterCodes.backslash) return 3;\r\n        }\r\n        // Per RFC 1738 'file' URI schema has the shape file://<host>/<path>\r\n        // if <host> is omitted then it is assumed that host value is 'localhost',\r\n        // however slash after the omitted <host> is not removed.\r\n        // file:///folder1/file1 - this is a correct URI\r\n        // file://folder2/file2 - this is an incorrect URI\r\n        if (path.lastIndexOf(\"file:///\", 0) === 0) {\r\n            return \"file:///\".length;\r\n        }\r\n        const idx = path.indexOf(\"://\");\r\n        if (idx !== -1) {\r\n            return idx + \"://\".length;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Internally, we represent paths as strings with '/' as the directory separator.\r\n     * When we make system calls (eg: LanguageServiceHost.getDirectory()),\r\n     * we expect the host to correctly handle paths in our specified format.\r\n     */\r\n    export const directorySeparator = \"/\";\r\n    const directorySeparatorCharCode = CharacterCodes.slash;\r\n    function getNormalizedParts(normalizedSlashedPath: string, rootLength: number): string[] {\r\n        const parts = normalizedSlashedPath.substr(rootLength).split(directorySeparator);\r\n        const normalized: string[] = [];\r\n        for (const part of parts) {\r\n            if (part !== \".\") {\r\n                if (part === \"..\" && normalized.length > 0 && lastOrUndefined(normalized) !== \"..\") {\r\n                    normalized.pop();\r\n                }\r\n                else {\r\n                    // A part may be an empty string (which is 'falsy') if the path had consecutive slashes,\r\n                    // e.g. \"path//file.ts\".  Drop these before re-joining the parts.\r\n                    if (part) {\r\n                        normalized.push(part);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return normalized;\r\n    }\r\n\r\n    export function normalizePath(path: string): string {\r\n        return normalizePathAndParts(path).path;\r\n    }\r\n\r\n    export function normalizePathAndParts(path: string): { path: string, parts: string[] } {\r\n        path = normalizeSlashes(path);\r\n        const rootLength = getRootLength(path);\r\n        const root = path.substr(0, rootLength);\r\n        const parts = getNormalizedParts(path, rootLength);\r\n        if (parts.length) {\r\n            const joinedParts = root + parts.join(directorySeparator);\r\n            return { path: pathEndsWithDirectorySeparator(path) ? joinedParts + directorySeparator : joinedParts, parts };\r\n        }\r\n        else {\r\n            return { path: root, parts };\r\n        }\r\n    }\r\n\r\n    /** A path ending with '/' refers to a directory only, never a file. */\r\n    export function pathEndsWithDirectorySeparator(path: string): boolean {\r\n        return path.charCodeAt(path.length - 1) === directorySeparatorCharCode;\r\n    }\r\n\r\n    /**\r\n     * Returns the path except for its basename. Eg:\r\n     *\r\n     * /path/to/file.ext -> /path/to\r\n     */\r\n    export function getDirectoryPath(path: Path): Path;\r\n    export function getDirectoryPath(path: string): string;\r\n    export function getDirectoryPath(path: string): string {\r\n        return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(directorySeparator)));\r\n    }\r\n\r\n    export function isUrl(path: string) {\r\n        return path && !isRootedDiskPath(path) && stringContains(path, \"://\");\r\n    }\r\n\r\n    export function pathIsRelative(path: string): boolean {\r\n        return /^\\.\\.?($|[\\\\/])/.test(path);\r\n    }\r\n\r\n    export function getEmitScriptTarget(compilerOptions: CompilerOptions) {\r\n        return compilerOptions.target || ScriptTarget.ES3;\r\n    }\r\n\r\n    export function getEmitModuleKind(compilerOptions: {module?: CompilerOptions[\"module\"], target?: CompilerOptions[\"target\"]}) {\r\n        return typeof compilerOptions.module === \"number\" ?\r\n            compilerOptions.module :\r\n            getEmitScriptTarget(compilerOptions) >= ScriptTarget.ES2015 ? ModuleKind.ES2015 : ModuleKind.CommonJS;\r\n    }\r\n\r\n    export function getEmitModuleResolutionKind(compilerOptions: CompilerOptions) {\r\n        let moduleResolution = compilerOptions.moduleResolution;\r\n        if (moduleResolution === undefined) {\r\n            moduleResolution = getEmitModuleKind(compilerOptions) === ModuleKind.CommonJS ? ModuleResolutionKind.NodeJs : ModuleResolutionKind.Classic;\r\n        }\r\n        return moduleResolution;\r\n    }\r\n\r\n    export function getAreDeclarationMapsEnabled(options: CompilerOptions) {\r\n        return !!(options.declaration && options.declarationMap);\r\n    }\r\n\r\n    export function getAllowSyntheticDefaultImports(compilerOptions: CompilerOptions) {\r\n        const moduleKind = getEmitModuleKind(compilerOptions);\r\n        return compilerOptions.allowSyntheticDefaultImports !== undefined\r\n            ? compilerOptions.allowSyntheticDefaultImports\r\n            : compilerOptions.esModuleInterop\r\n                ? moduleKind !== ModuleKind.None && moduleKind < ModuleKind.ES2015\r\n                : moduleKind === ModuleKind.System;\r\n    }\r\n\r\n    export type StrictOptionName = \"noImplicitAny\" | \"noImplicitThis\" | \"strictNullChecks\" | \"strictFunctionTypes\" | \"strictPropertyInitialization\" | \"alwaysStrict\";\r\n\r\n    export function getStrictOptionValue(compilerOptions: CompilerOptions, flag: StrictOptionName): boolean {\r\n        return compilerOptions[flag] === undefined ? compilerOptions.strict : compilerOptions[flag];\r\n    }\r\n\r\n    export function hasZeroOrOneAsteriskCharacter(str: string): boolean {\r\n        let seenAsterisk = false;\r\n        for (let i = 0; i < str.length; i++) {\r\n            if (str.charCodeAt(i) === CharacterCodes.asterisk) {\r\n                if (!seenAsterisk) {\r\n                    seenAsterisk = true;\r\n                }\r\n                else {\r\n                    // have already seen asterisk\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    export function isRootedDiskPath(path: string) {\r\n        return path && getRootLength(path) !== 0;\r\n    }\r\n\r\n    export function convertToRelativePath(absoluteOrRelativePath: string, basePath: string, getCanonicalFileName: (path: string) => string): string {\r\n        return !isRootedDiskPath(absoluteOrRelativePath)\r\n            ? absoluteOrRelativePath\r\n            : getRelativePathToDirectoryOrUrl(basePath, absoluteOrRelativePath, basePath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);\r\n    }\r\n\r\n    function normalizedPathComponents(path: string, rootLength: number) {\r\n        const normalizedParts = getNormalizedParts(path, rootLength);\r\n        return [path.substr(0, rootLength)].concat(normalizedParts);\r\n    }\r\n\r\n    export function getNormalizedPathComponents(path: string, currentDirectory: string) {\r\n        path = normalizeSlashes(path);\r\n        let rootLength = getRootLength(path);\r\n        if (rootLength === 0) {\r\n            // If the path is not rooted it is relative to current directory\r\n            path = combinePaths(normalizeSlashes(currentDirectory), path);\r\n            rootLength = getRootLength(path);\r\n        }\r\n\r\n        return normalizedPathComponents(path, rootLength);\r\n    }\r\n\r\n    export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string) {\r\n        return getNormalizedPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n    }\r\n\r\n    export function getNormalizedPathFromPathComponents(pathComponents: ReadonlyArray<string>) {\r\n        if (pathComponents && pathComponents.length) {\r\n            return pathComponents[0] + pathComponents.slice(1).join(directorySeparator);\r\n        }\r\n    }\r\n\r\n    function getNormalizedPathComponentsOfUrl(url: string) {\r\n        // Get root length of http://www.website.com/folder1/folder2/\r\n        // In this example the root is: http://www.website.com/\r\n        // normalized path components should be [\"http://www.website.com/\", \"folder1\", \"folder2\"]\r\n\r\n        const urlLength = url.length;\r\n        // Initial root length is http:// part\r\n        let rootLength = url.indexOf(\"://\") + \"://\".length;\r\n        while (rootLength < urlLength) {\r\n            // Consume all immediate slashes in the protocol\r\n            // eg.initial rootlength is just file:// but it needs to consume another \"/\" in file:///\r\n            if (url.charCodeAt(rootLength) === CharacterCodes.slash) {\r\n                rootLength++;\r\n            }\r\n            else {\r\n                // non slash character means we continue proceeding to next component of root search\r\n                break;\r\n            }\r\n        }\r\n\r\n        // there are no parts after http:// just return current string as the pathComponent\r\n        if (rootLength === urlLength) {\r\n            return [url];\r\n        }\r\n\r\n        // Find the index of \"/\" after website.com so the root can be http://www.website.com/ (from existing http://)\r\n        const indexOfNextSlash = url.indexOf(directorySeparator, rootLength);\r\n        if (indexOfNextSlash !== -1) {\r\n            // Found the \"/\" after the website.com so the root is length of http://www.website.com/\r\n            // and get components after the root normally like any other folder components\r\n            rootLength = indexOfNextSlash + 1;\r\n            return normalizedPathComponents(url, rootLength);\r\n        }\r\n        else {\r\n            // Can't find the host assume the rest of the string as component\r\n            // but make sure we append \"/\" to it as root is not joined using \"/\"\r\n            // eg. if url passed in was http://website.com we want to use root as [http://website.com/]\r\n            // so that other path manipulations will be correct and it can be merged with relative paths correctly\r\n            return [url + directorySeparator];\r\n        }\r\n    }\r\n\r\n    function getNormalizedPathOrUrlComponents(pathOrUrl: string, currentDirectory: string) {\r\n        if (isUrl(pathOrUrl)) {\r\n            return getNormalizedPathComponentsOfUrl(pathOrUrl);\r\n        }\r\n        else {\r\n            return getNormalizedPathComponents(pathOrUrl, currentDirectory);\r\n        }\r\n    }\r\n\r\n    export function getRelativePathToDirectoryOrUrl(directoryPathOrUrl: string, relativeOrAbsolutePath: string, currentDirectory: string, getCanonicalFileName: GetCanonicalFileName, isAbsolutePathAnUrl: boolean) {\r\n        const pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);\r\n        const directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);\r\n        if (directoryComponents.length > 1 && lastOrUndefined(directoryComponents) === \"\") {\r\n            // If the directory path given was of type test/cases/ then we really need components of directory to be only till its name\r\n            // that is [\"test\", \"cases\", \"\"] needs to be actually [\"test\", \"cases\"]\r\n            directoryComponents.pop();\r\n        }\r\n\r\n        // Find the component that differs\r\n        let joinStartIndex: number;\r\n        for (joinStartIndex = 0; joinStartIndex < pathComponents.length && joinStartIndex < directoryComponents.length; joinStartIndex++) {\r\n            if (getCanonicalFileName(directoryComponents[joinStartIndex]) !== getCanonicalFileName(pathComponents[joinStartIndex])) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the relative path\r\n        if (joinStartIndex) {\r\n            let relativePath = \"\";\r\n            const relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);\r\n            for (; joinStartIndex < directoryComponents.length; joinStartIndex++) {\r\n                if (directoryComponents[joinStartIndex] !== \"\") {\r\n                    relativePath = relativePath + \"..\" + directorySeparator;\r\n                }\r\n            }\r\n\r\n            return relativePath + relativePathComponents.join(directorySeparator);\r\n        }\r\n\r\n        // Cant find the relative path, get the absolute path\r\n        let absolutePath = getNormalizedPathFromPathComponents(pathComponents);\r\n        if (isAbsolutePathAnUrl && isRootedDiskPath(absolutePath)) {\r\n            absolutePath = \"file:///\" + absolutePath;\r\n        }\r\n\r\n        return absolutePath;\r\n    }\r\n\r\n    export function getRelativePath(path: string, directoryPath: string, getCanonicalFileName: GetCanonicalFileName) {\r\n        const relativePath = getRelativePathToDirectoryOrUrl(directoryPath, path, directoryPath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);\r\n        return ensurePathIsRelative(relativePath);\r\n    }\r\n\r\n    export function ensurePathIsRelative(path: string): string {\r\n        return !pathIsRelative(path) ? \"./\" + path : path;\r\n    }\r\n\r\n    export function getBaseFileName(path: string) {\r\n        if (path === undefined) {\r\n            return undefined;\r\n        }\r\n        const i = path.lastIndexOf(directorySeparator);\r\n        return i < 0 ? path : path.substring(i + 1);\r\n    }\r\n\r\n    export function combinePaths(path1: string, path2: string): string {\r\n        if (!(path1 && path1.length)) return path2;\r\n        if (!(path2 && path2.length)) return path1;\r\n        if (getRootLength(path2) !== 0) return path2;\r\n        if (path1.charAt(path1.length - 1) === directorySeparator) return path1 + path2;\r\n        return path1 + directorySeparator + path2;\r\n    }\r\n\r\n    /**\r\n     * Removes a trailing directory separator from a path.\r\n     * @param path The path.\r\n     */\r\n    export function removeTrailingDirectorySeparator(path: Path): Path;\r\n    export function removeTrailingDirectorySeparator(path: string): string;\r\n    export function removeTrailingDirectorySeparator(path: string) {\r\n        if (path.charAt(path.length - 1) === directorySeparator) {\r\n            return path.substr(0, path.length - 1);\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Adds a trailing directory separator to a path, if it does not already have one.\r\n     * @param path The path.\r\n     */\r\n    export function ensureTrailingDirectorySeparator(path: Path): Path;\r\n    export function ensureTrailingDirectorySeparator(path: string): string;\r\n    export function ensureTrailingDirectorySeparator(path: string) {\r\n        if (path.charAt(path.length - 1) !== directorySeparator) {\r\n            return path + directorySeparator;\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    export function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean) {\r\n        if (a === b) return Comparison.EqualTo;\r\n        if (a === undefined) return Comparison.LessThan;\r\n        if (b === undefined) return Comparison.GreaterThan;\r\n        a = removeTrailingDirectorySeparator(a);\r\n        b = removeTrailingDirectorySeparator(b);\r\n        const aComponents = getNormalizedPathComponents(a, currentDirectory);\r\n        const bComponents = getNormalizedPathComponents(b, currentDirectory);\r\n        const sharedLength = Math.min(aComponents.length, bComponents.length);\r\n        const comparer = getStringComparer(ignoreCase);\r\n        for (let i = 0; i < sharedLength; i++) {\r\n            const result = comparer(aComponents[i], bComponents[i]);\r\n            if (result !== Comparison.EqualTo) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return compareValues(aComponents.length, bComponents.length);\r\n    }\r\n\r\n    export function containsPath(parent: string, child: string, currentDirectory: string, ignoreCase?: boolean) {\r\n        if (parent === undefined || child === undefined) return false;\r\n        if (parent === child) return true;\r\n        parent = removeTrailingDirectorySeparator(parent);\r\n        child = removeTrailingDirectorySeparator(child);\r\n        if (parent === child) return true;\r\n        const parentComponents = getNormalizedPathComponents(parent, currentDirectory);\r\n        const childComponents = getNormalizedPathComponents(child, currentDirectory);\r\n        if (childComponents.length < parentComponents.length) {\r\n            return false;\r\n        }\r\n\r\n        const equalityComparer = ignoreCase ? equateStringsCaseInsensitive : equateStringsCaseSensitive;\r\n        for (let i = 0; i < parentComponents.length; i++) {\r\n            if (!equalityComparer(parentComponents[i], childComponents[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    export function startsWith(str: string, prefix: string): boolean {\r\n        return str.lastIndexOf(prefix, 0) === 0;\r\n    }\r\n\r\n    export function removePrefix(str: string, prefix: string): string {\r\n        return startsWith(str, prefix) ? str.substr(prefix.length) : str;\r\n    }\r\n\r\n    export function endsWith(str: string, suffix: string): boolean {\r\n        const expectedPos = str.length - suffix.length;\r\n        return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\r\n    }\r\n\r\n    export function removeSuffix(str: string, suffix: string): string {\r\n        return endsWith(str, suffix) ? str.slice(0, str.length - suffix.length) : str;\r\n    }\r\n\r\n    export function stringContains(str: string, substring: string): boolean {\r\n        return str.indexOf(substring) !== -1;\r\n    }\r\n\r\n    export function hasExtension(fileName: string): boolean {\r\n        return stringContains(getBaseFileName(fileName), \".\");\r\n    }\r\n\r\n    export function fileExtensionIs(path: string, extension: string): boolean {\r\n        return path.length > extension.length && endsWith(path, extension);\r\n    }\r\n\r\n    export function fileExtensionIsOneOf(path: string, extensions: ReadonlyArray<string>): boolean {\r\n        for (const extension of extensions) {\r\n            if (fileExtensionIs(path, extension)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\r\n    // It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\r\n    // proof.\r\n    const reservedCharacterPattern = /[^\\w\\s\\/]/g;\r\n    const wildcardCharCodes = [CharacterCodes.asterisk, CharacterCodes.question];\r\n\r\n    export const commonPackageFolders: ReadonlyArray<string> = [\"node_modules\", \"bower_components\", \"jspm_packages\"];\r\n\r\n    const implicitExcludePathRegexPattern = `(?!(${commonPackageFolders.join(\"|\")})(/|$))`;\r\n\r\n    interface WildcardMatcher {\r\n        singleAsteriskRegexFragment: string;\r\n        doubleAsteriskRegexFragment: string;\r\n        replaceWildcardCharacter: (match: string) => string;\r\n    }\r\n\r\n    const filesMatcher: WildcardMatcher = {\r\n        /**\r\n         * Matches any single directory segment unless it is the last segment and a .min.js file\r\n         * Breakdown:\r\n         *  [^./]                   # matches everything up to the first . character (excluding directory seperators)\r\n         *  (\\\\.(?!min\\\\.js$))?     # matches . characters but not if they are part of the .min.js file extension\r\n         */\r\n        singleAsteriskRegexFragment: \"([^./]|(\\\\.(?!min\\\\.js$))?)*\",\r\n        /**\r\n         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including\r\n         * files or directories, does not match subdirectories that start with a . character\r\n         */\r\n        doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,\r\n        replaceWildcardCharacter: match => replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment)\r\n    };\r\n\r\n    const directoriesMatcher: WildcardMatcher = {\r\n        singleAsteriskRegexFragment: \"[^/]*\",\r\n        /**\r\n         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including\r\n         * files or directories, does not match subdirectories that start with a . character\r\n         */\r\n        doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,\r\n        replaceWildcardCharacter: match => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)\r\n    };\r\n\r\n    const excludeMatcher: WildcardMatcher = {\r\n        singleAsteriskRegexFragment: \"[^/]*\",\r\n        doubleAsteriskRegexFragment: \"(/.+?)?\",\r\n        replaceWildcardCharacter: match => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)\r\n    };\r\n\r\n    const wildcardMatchers = {\r\n        files: filesMatcher,\r\n        directories: directoriesMatcher,\r\n        exclude: excludeMatcher\r\n    };\r\n\r\n    export function getRegularExpressionForWildcard(specs: ReadonlyArray<string>, basePath: string, usage: \"files\" | \"directories\" | \"exclude\"): string | undefined {\r\n        const patterns = getRegularExpressionsForWildcards(specs, basePath, usage);\r\n        if (!patterns || !patterns.length) {\r\n            return undefined;\r\n        }\r\n\r\n        const pattern = patterns.map(pattern => `(${pattern})`).join(\"|\");\r\n        // If excluding, match \"foo/bar/baz...\", but if including, only allow \"foo\".\r\n        const terminator = usage === \"exclude\" ? \"($|/)\" : \"$\";\r\n        return `^(${pattern})${terminator}`;\r\n    }\r\n\r\n    function getRegularExpressionsForWildcards(specs: ReadonlyArray<string>, basePath: string, usage: \"files\" | \"directories\" | \"exclude\"): string[] | undefined {\r\n        if (specs === undefined || specs.length === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return flatMap(specs, spec =>\r\n            spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]));\r\n    }\r\n\r\n    /**\r\n     * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\r\n     * and does not contain any glob characters itself.\r\n     */\r\n    export function isImplicitGlob(lastPathComponent: string): boolean {\r\n        return !/[.*?]/.test(lastPathComponent);\r\n    }\r\n\r\n    function getSubPatternFromSpec(spec: string, basePath: string, usage: \"files\" | \"directories\" | \"exclude\", { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter }: WildcardMatcher): string | undefined {\r\n        let subpattern = \"\";\r\n        let hasWrittenComponent = false;\r\n        const components = getNormalizedPathComponents(spec, basePath);\r\n        const lastComponent = lastOrUndefined(components);\r\n        if (usage !== \"exclude\" && lastComponent === \"**\") {\r\n            return undefined;\r\n        }\r\n\r\n        // getNormalizedPathComponents includes the separator for the root component.\r\n        // We need to remove to create our regex correctly.\r\n        components[0] = removeTrailingDirectorySeparator(components[0]);\r\n\r\n        if (isImplicitGlob(lastComponent)) {\r\n            components.push(\"**\", \"*\");\r\n        }\r\n\r\n        let optionalCount = 0;\r\n        for (let component of components) {\r\n            if (component === \"**\") {\r\n                subpattern += doubleAsteriskRegexFragment;\r\n            }\r\n            else {\r\n                if (usage === \"directories\") {\r\n                    subpattern += \"(\";\r\n                    optionalCount++;\r\n                }\r\n\r\n                if (hasWrittenComponent) {\r\n                    subpattern += directorySeparator;\r\n                }\r\n\r\n                if (usage !== \"exclude\") {\r\n                    let componentPattern = \"\";\r\n                    // The * and ? wildcards should not match directories or files that start with . if they\r\n                    // appear first in a component. Dotted directories and files can be included explicitly\r\n                    // like so: **/.*/.*\r\n                    if (component.charCodeAt(0) === CharacterCodes.asterisk) {\r\n                        componentPattern += \"([^./]\" + singleAsteriskRegexFragment + \")?\";\r\n                        component = component.substr(1);\r\n                    }\r\n                    else if (component.charCodeAt(0) === CharacterCodes.question) {\r\n                        componentPattern += \"[^./]\";\r\n                        component = component.substr(1);\r\n                    }\r\n\r\n                    componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\r\n\r\n                    // Patterns should not include subfolders like node_modules unless they are\r\n                    // explicitly included as part of the path.\r\n                    //\r\n                    // As an optimization, if the component pattern is the same as the component,\r\n                    // then there definitely were no wildcard characters and we do not need to\r\n                    // add the exclusion pattern.\r\n                    if (componentPattern !== component) {\r\n                        subpattern += implicitExcludePathRegexPattern;\r\n                    }\r\n\r\n                    subpattern += componentPattern;\r\n                }\r\n                else {\r\n                    subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\r\n                }\r\n            }\r\n\r\n            hasWrittenComponent = true;\r\n        }\r\n\r\n        while (optionalCount > 0) {\r\n            subpattern += \")?\";\r\n            optionalCount--;\r\n        }\r\n\r\n        return subpattern;\r\n    }\r\n\r\n    function replaceWildcardCharacter(match: string, singleAsteriskRegexFragment: string) {\r\n        return match === \"*\" ? singleAsteriskRegexFragment : match === \"?\" ? \"[^/]\" : \"\\\\\" + match;\r\n    }\r\n\r\n    export interface FileSystemEntries {\r\n        readonly files: ReadonlyArray<string>;\r\n        readonly directories: ReadonlyArray<string>;\r\n    }\r\n\r\n    export interface FileMatcherPatterns {\r\n        /** One pattern for each \"include\" spec. */\r\n        includeFilePatterns: ReadonlyArray<string>;\r\n        /** One pattern matching one of any of the \"include\" specs. */\r\n        includeFilePattern: string;\r\n        includeDirectoryPattern: string;\r\n        excludePattern: string;\r\n        basePaths: ReadonlyArray<string>;\r\n    }\r\n\r\n    export function getFileMatcherPatterns(path: string, excludes: ReadonlyArray<string>, includes: ReadonlyArray<string>, useCaseSensitiveFileNames: boolean, currentDirectory: string): FileMatcherPatterns {\r\n        path = normalizePath(path);\r\n        currentDirectory = normalizePath(currentDirectory);\r\n        const absolutePath = combinePaths(currentDirectory, path);\r\n\r\n        return {\r\n            includeFilePatterns: map(getRegularExpressionsForWildcards(includes, absolutePath, \"files\"), pattern => `^${pattern}$`),\r\n            includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, \"files\"),\r\n            includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, \"directories\"),\r\n            excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, \"exclude\"),\r\n            basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)\r\n        };\r\n    }\r\n\r\n    export function matchFiles(path: string, extensions: ReadonlyArray<string>, excludes: ReadonlyArray<string>, includes: ReadonlyArray<string>, useCaseSensitiveFileNames: boolean, currentDirectory: string, depth: number | undefined, getFileSystemEntries: (path: string) => FileSystemEntries): string[] {\r\n        path = normalizePath(path);\r\n        currentDirectory = normalizePath(currentDirectory);\r\n\r\n        const patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);\r\n\r\n        const regexFlag = useCaseSensitiveFileNames ? \"\" : \"i\";\r\n        const includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map(pattern => new RegExp(pattern, regexFlag));\r\n        const includeDirectoryRegex = patterns.includeDirectoryPattern && new RegExp(patterns.includeDirectoryPattern, regexFlag);\r\n        const excludeRegex = patterns.excludePattern && new RegExp(patterns.excludePattern, regexFlag);\r\n\r\n        // Associate an array of results with each include regex. This keeps results in order of the \"include\" order.\r\n        // If there are no \"includes\", then just put everything in results[0].\r\n        const results: string[][] = includeFileRegexes ? includeFileRegexes.map(() => []) : [[]];\r\n\r\n        for (const basePath of patterns.basePaths) {\r\n            visitDirectory(basePath, combinePaths(currentDirectory, basePath), depth);\r\n        }\r\n\r\n        return flatten<string>(results);\r\n\r\n        function visitDirectory(path: string, absolutePath: string, depth: number | undefined) {\r\n            const { files, directories } = getFileSystemEntries(path);\r\n\r\n            for (const current of sort(files, compareStringsCaseSensitive)) {\r\n                const name = combinePaths(path, current);\r\n                const absoluteName = combinePaths(absolutePath, current);\r\n                if (extensions && !fileExtensionIsOneOf(name, extensions)) continue;\r\n                if (excludeRegex && excludeRegex.test(absoluteName)) continue;\r\n                if (!includeFileRegexes) {\r\n                    results[0].push(name);\r\n                }\r\n                else {\r\n                    const includeIndex = findIndex(includeFileRegexes, re => re.test(absoluteName));\r\n                    if (includeIndex !== -1) {\r\n                        results[includeIndex].push(name);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (depth !== undefined) {\r\n                depth--;\r\n                if (depth === 0) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            for (const current of sort(directories, compareStringsCaseSensitive)) {\r\n                const name = combinePaths(path, current);\r\n                const absoluteName = combinePaths(absolutePath, current);\r\n                if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &&\r\n                    (!excludeRegex || !excludeRegex.test(absoluteName))) {\r\n                    visitDirectory(name, absoluteName, depth);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Computes the unique non-wildcard base paths amongst the provided include patterns.\r\n     */\r\n    function getBasePaths(path: string, includes: ReadonlyArray<string>, useCaseSensitiveFileNames: boolean) {\r\n        // Storage for our results in the form of literal paths (e.g. the paths as written by the user).\r\n        const basePaths: string[] = [path];\r\n\r\n        if (includes) {\r\n            // Storage for literal base paths amongst the include patterns.\r\n            const includeBasePaths: string[] = [];\r\n            for (const include of includes) {\r\n                // We also need to check the relative paths by converting them to absolute and normalizing\r\n                // in case they escape the base path (e.g \"..\\somedirectory\")\r\n                const absolute: string = isRootedDiskPath(include) ? include : normalizePath(combinePaths(path, include));\r\n                // Append the literal and canonical candidate base paths.\r\n                includeBasePaths.push(getIncludeBasePath(absolute));\r\n            }\r\n\r\n            // Sort the offsets array using either the literal or canonical path representations.\r\n            includeBasePaths.sort(getStringComparer(!useCaseSensitiveFileNames));\r\n\r\n            // Iterate over each include base path and include unique base paths that are not a\r\n            // subpath of an existing base path\r\n            for (const includeBasePath of includeBasePaths) {\r\n                if (every(basePaths, basePath => !containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames))) {\r\n                    basePaths.push(includeBasePath);\r\n                }\r\n            }\r\n        }\r\n\r\n        return basePaths;\r\n    }\r\n\r\n    function getIncludeBasePath(absolute: string): string {\r\n        const wildcardOffset = indexOfAnyCharCode(absolute, wildcardCharCodes);\r\n        if (wildcardOffset < 0) {\r\n            // No \"*\" or \"?\" in the path\r\n            return !hasExtension(absolute)\r\n                ? absolute\r\n                : removeTrailingDirectorySeparator(getDirectoryPath(absolute));\r\n        }\r\n        return absolute.substring(0, absolute.lastIndexOf(directorySeparator, wildcardOffset));\r\n    }\r\n\r\n    export function ensureScriptKind(fileName: string, scriptKind: ScriptKind | undefined): ScriptKind {\r\n        // Using scriptKind as a condition handles both:\r\n        // - 'scriptKind' is unspecified and thus it is `undefined`\r\n        // - 'scriptKind' is set and it is `Unknown` (0)\r\n        // If the 'scriptKind' is 'undefined' or 'Unknown' then we attempt\r\n        // to get the ScriptKind from the file name. If it cannot be resolved\r\n        // from the file name then the default 'TS' script kind is returned.\r\n        return scriptKind || getScriptKindFromFileName(fileName) || ScriptKind.TS;\r\n    }\r\n\r\n    export function getScriptKindFromFileName(fileName: string): ScriptKind {\r\n        const ext = fileName.substr(fileName.lastIndexOf(\".\"));\r\n        switch (ext.toLowerCase()) {\r\n            case Extension.Js:\r\n                return ScriptKind.JS;\r\n            case Extension.Jsx:\r\n                return ScriptKind.JSX;\r\n            case Extension.Ts:\r\n                return ScriptKind.TS;\r\n            case Extension.Tsx:\r\n                return ScriptKind.TSX;\r\n            case Extension.Json:\r\n                return ScriptKind.JSON;\r\n            default:\r\n                return ScriptKind.Unknown;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  List of supported extensions in order of file resolution precedence.\r\n     */\r\n    export const supportedTypeScriptExtensions: ReadonlyArray<Extension> = [Extension.Ts, Extension.Tsx, Extension.Dts];\r\n    /** Must have \".d.ts\" first because if \".ts\" goes first, that will be detected as the extension instead of \".d.ts\". */\r\n    export const supportedTypescriptExtensionsForExtractExtension: ReadonlyArray<Extension> = [Extension.Dts, Extension.Ts, Extension.Tsx];\r\n    export const supportedJavascriptExtensions: ReadonlyArray<Extension> = [Extension.Js, Extension.Jsx];\r\n    const allSupportedExtensions: ReadonlyArray<Extension> = [...supportedTypeScriptExtensions, ...supportedJavascriptExtensions];\r\n\r\n    export function getSupportedExtensions(options?: CompilerOptions, extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>): ReadonlyArray<string> {\r\n        const needAllExtensions = options && options.allowJs;\r\n        if (!extraFileExtensions || extraFileExtensions.length === 0 || !needAllExtensions) {\r\n            return needAllExtensions ? allSupportedExtensions : supportedTypeScriptExtensions;\r\n        }\r\n        return deduplicate(\r\n            [...allSupportedExtensions, ...extraFileExtensions.map(e => e.extension)],\r\n            equateStringsCaseSensitive,\r\n            compareStringsCaseSensitive\r\n        );\r\n    }\r\n\r\n    export function hasJavaScriptFileExtension(fileName: string) {\r\n        return forEach(supportedJavascriptExtensions, extension => fileExtensionIs(fileName, extension));\r\n    }\r\n\r\n    export function hasTypeScriptFileExtension(fileName: string) {\r\n        return forEach(supportedTypeScriptExtensions, extension => fileExtensionIs(fileName, extension));\r\n    }\r\n\r\n    export function isSupportedSourceFileName(fileName: string, compilerOptions?: CompilerOptions, extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>) {\r\n        if (!fileName) { return false; }\r\n\r\n        for (const extension of getSupportedExtensions(compilerOptions, extraFileExtensions)) {\r\n            if (fileExtensionIs(fileName, extension)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Extension boundaries by priority. Lower numbers indicate higher priorities, and are\r\n     * aligned to the offset of the highest priority extension in the\r\n     * allSupportedExtensions array.\r\n     */\r\n    export const enum ExtensionPriority {\r\n        TypeScriptFiles = 0,\r\n        DeclarationAndJavaScriptFiles = 2,\r\n\r\n        Highest = TypeScriptFiles,\r\n        Lowest = DeclarationAndJavaScriptFiles,\r\n    }\r\n\r\n    export function getExtensionPriority(path: string, supportedExtensions: ReadonlyArray<string>): ExtensionPriority {\r\n        for (let i = supportedExtensions.length - 1; i >= 0; i--) {\r\n            if (fileExtensionIs(path, supportedExtensions[i])) {\r\n                return adjustExtensionPriority(<ExtensionPriority>i, supportedExtensions);\r\n            }\r\n        }\r\n\r\n        // If its not in the list of supported extensions, this is likely a\r\n        // TypeScript file with a non-ts extension\r\n        return ExtensionPriority.Highest;\r\n    }\r\n\r\n    /**\r\n     * Adjusts an extension priority to be the highest priority within the same range.\r\n     */\r\n    export function adjustExtensionPriority(extensionPriority: ExtensionPriority, supportedExtensions: ReadonlyArray<string>): ExtensionPriority {\r\n        if (extensionPriority < ExtensionPriority.DeclarationAndJavaScriptFiles) {\r\n            return ExtensionPriority.TypeScriptFiles;\r\n        }\r\n        else if (extensionPriority < supportedExtensions.length) {\r\n            return ExtensionPriority.DeclarationAndJavaScriptFiles;\r\n        }\r\n        else {\r\n            return supportedExtensions.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the next lowest extension priority for a given priority.\r\n     */\r\n    export function getNextLowestExtensionPriority(extensionPriority: ExtensionPriority, supportedExtensions: ReadonlyArray<string>): ExtensionPriority {\r\n        if (extensionPriority < ExtensionPriority.DeclarationAndJavaScriptFiles) {\r\n            return ExtensionPriority.DeclarationAndJavaScriptFiles;\r\n        }\r\n        else {\r\n            return supportedExtensions.length;\r\n        }\r\n    }\r\n\r\n    const extensionsToRemove = [Extension.Dts, Extension.Ts, Extension.Js, Extension.Tsx, Extension.Jsx];\r\n    export function removeFileExtension(path: string): string {\r\n        for (const ext of extensionsToRemove) {\r\n            const extensionless = tryRemoveExtension(path, ext);\r\n            if (extensionless !== undefined) {\r\n                return extensionless;\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n\r\n    export function tryRemoveExtension(path: string, extension: string): string | undefined {\r\n        return fileExtensionIs(path, extension) ? removeExtension(path, extension) : undefined;\r\n    }\r\n\r\n    export function removeExtension(path: string, extension: string): string {\r\n        return path.substring(0, path.length - extension.length);\r\n    }\r\n\r\n    export function changeExtension<T extends string | Path>(path: T, newExtension: string): T {\r\n        return <T>(removeFileExtension(path) + newExtension);\r\n    }\r\n\r\n    /**\r\n     * Takes a string like \"jquery-min.4.2.3\" and returns \"jquery\"\r\n     */\r\n    export function removeMinAndVersionNumbers(fileName: string) {\r\n        // Match a \".\" or \"-\" followed by a version number or 'min' at the end of the name\r\n        const trailingMinOrVersion = /[.-]((min)|(\\d+(\\.\\d+)*))$/;\r\n\r\n        // The \"min\" or version may both be present, in either order, so try applying the above twice.\r\n        return fileName.replace(trailingMinOrVersion, \"\").replace(trailingMinOrVersion, \"\");\r\n    }\r\n\r\n    export interface ObjectAllocator {\r\n        getNodeConstructor(): new (kind: SyntaxKind, pos?: number, end?: number) => Node;\r\n        getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos?: number, end?: number) => Token<TKind>;\r\n        getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos?: number, end?: number) => Identifier;\r\n        getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos?: number, end?: number) => SourceFile;\r\n        getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol;\r\n        getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type;\r\n        getSignatureConstructor(): new (checker: TypeChecker) => Signature;\r\n        getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource;\r\n    }\r\n\r\n    function Symbol(this: Symbol, flags: SymbolFlags, name: __String) {\r\n        this.flags = flags;\r\n        this.escapedName = name;\r\n        this.declarations = undefined;\r\n        this.valueDeclaration = undefined;\r\n        this.id = undefined;\r\n        this.mergeId = undefined;\r\n        this.parent = undefined;\r\n    }\r\n\r\n    function Type(this: Type, checker: TypeChecker, flags: TypeFlags) {\r\n        this.flags = flags;\r\n        if (Debug.isDebugging) {\r\n            this.checker = checker;\r\n        }\r\n    }\r\n\r\n    function Signature() {} // tslint:disable-line no-empty\r\n\r\n    function Node(this: Node, kind: SyntaxKind, pos: number, end: number) {\r\n        this.pos = pos;\r\n        this.end = end;\r\n        this.kind = kind;\r\n        this.id = 0;\r\n        this.flags = NodeFlags.None;\r\n        this.modifierFlagsCache = ModifierFlags.None;\r\n        this.transformFlags = TransformFlags.None;\r\n        this.parent = undefined;\r\n        this.original = undefined;\r\n    }\r\n\r\n    function SourceMapSource(this: SourceMapSource, fileName: string, text: string, skipTrivia?: (pos: number) => number) {\r\n        this.fileName = fileName;\r\n        this.text = text;\r\n        this.skipTrivia = skipTrivia || (pos => pos);\r\n    }\r\n\r\n    export let objectAllocator: ObjectAllocator = {\r\n        getNodeConstructor: () => <any>Node,\r\n        getTokenConstructor: () => <any>Node,\r\n        getIdentifierConstructor: () => <any>Node,\r\n        getSourceFileConstructor: () => <any>Node,\r\n        getSymbolConstructor: () => <any>Symbol,\r\n        getTypeConstructor: () => <any>Type,\r\n        getSignatureConstructor: () => <any>Signature,\r\n        getSourceMapSourceConstructor: () => <any>SourceMapSource,\r\n    };\r\n\r\n    export const enum AssertionLevel {\r\n        None = 0,\r\n        Normal = 1,\r\n        Aggressive = 2,\r\n        VeryAggressive = 3,\r\n    }\r\n\r\n    /**\r\n     * Safer version of `Function` which should not be called.\r\n     * Every function should be assignable to this, but this should not be assignable to every function.\r\n     */\r\n    export type AnyFunction = (...args: never[]) => void;\r\n\r\n    export namespace Debug {\r\n        export let currentAssertionLevel = AssertionLevel.None;\r\n        export let isDebugging = false;\r\n\r\n        export function shouldAssert(level: AssertionLevel): boolean {\r\n            return currentAssertionLevel >= level;\r\n        }\r\n\r\n        export function assert(expression: boolean, message?: string, verboseDebugInfo?: string | (() => string), stackCrawlMark?: AnyFunction): void {\r\n            if (!expression) {\r\n                if (verboseDebugInfo) {\r\n                    message += \"\\r\\nVerbose Debug Information: \" + (typeof verboseDebugInfo === \"string\" ? verboseDebugInfo : verboseDebugInfo());\r\n                }\r\n                fail(message ? \"False expression: \" + message : \"False expression.\", stackCrawlMark || assert);\r\n            }\r\n        }\r\n\r\n        export function assertEqual<T>(a: T, b: T, msg?: string, msg2?: string): void {\r\n            if (a !== b) {\r\n                const message = msg ? msg2 ? `${msg} ${msg2}` : msg : \"\";\r\n                fail(`Expected ${a} === ${b}. ${message}`);\r\n            }\r\n        }\r\n\r\n        export function assertLessThan(a: number, b: number, msg?: string): void {\r\n            if (a >= b) {\r\n                fail(`Expected ${a} < ${b}. ${msg || \"\"}`);\r\n            }\r\n        }\r\n\r\n        export function assertLessThanOrEqual(a: number, b: number): void {\r\n            if (a > b) {\r\n                fail(`Expected ${a} <= ${b}`);\r\n            }\r\n        }\r\n\r\n        export function assertGreaterThanOrEqual(a: number, b: number): void {\r\n            if (a < b) {\r\n                fail(`Expected ${a} >= ${b}`);\r\n            }\r\n        }\r\n\r\n        export function fail(message?: string, stackCrawlMark?: AnyFunction): never {\r\n            debugger;\r\n            const e = new Error(message ? `Debug Failure. ${message}` : \"Debug Failure.\");\r\n            if ((<any>Error).captureStackTrace) {\r\n                (<any>Error).captureStackTrace(e, stackCrawlMark || fail);\r\n            }\r\n            throw e;\r\n        }\r\n\r\n        export function assertDefined<T>(value: T | null | undefined, message?: string): T {\r\n            assert(value !== undefined && value !== null, message);\r\n            return value;\r\n        }\r\n\r\n        export function assertEachDefined<T, A extends ReadonlyArray<T>>(value: A, message?: string): A {\r\n            for (const v of value) {\r\n                assertDefined(v, message);\r\n            }\r\n            return value;\r\n        }\r\n\r\n        export function assertNever(member: never, message?: string, stackCrawlMark?: AnyFunction): never {\r\n            return fail(message || `Illegal value: ${member}`, stackCrawlMark || assertNever);\r\n        }\r\n\r\n        export function getFunctionName(func: AnyFunction) {\r\n            if (typeof func !== \"function\") {\r\n                return \"\";\r\n            }\r\n            else if (func.hasOwnProperty(\"name\")) {\r\n                return (<any>func).name;\r\n            }\r\n            else {\r\n                const text = Function.prototype.toString.call(func);\r\n                const match = /^function\\s+([\\w\\$]+)\\s*\\(/.exec(text);\r\n                return match ? match[1] : \"\";\r\n            }\r\n        }\r\n\r\n        export function showSymbol(symbol: Symbol): string {\r\n            const symbolFlags = (ts as any).SymbolFlags;\r\n            return `{ flags: ${symbolFlags ? showFlags(symbol.flags, symbolFlags) : symbol.flags}; declarations: ${map(symbol.declarations, showSyntaxKind)} }`;\r\n        }\r\n\r\n        function showFlags(flags: number, flagsEnum: { [flag: number]: string }): string {\r\n            const out = [];\r\n            for (let pow = 0; pow <= 30; pow++) {\r\n                const n = 1 << pow;\r\n                if (flags & n) {\r\n                    out.push(flagsEnum[n]);\r\n                }\r\n            }\r\n            return out.join(\"|\");\r\n        }\r\n\r\n        export function showSyntaxKind(node: Node): string {\r\n            const syntaxKind = (ts as any).SyntaxKind;\r\n            return syntaxKind ? syntaxKind[node.kind] : node.kind.toString();\r\n        }\r\n    }\r\n\r\n    /** Remove an item from an array, moving everything to its right one space left. */\r\n    export function orderedRemoveItem<T>(array: T[], item: T): boolean {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (array[i] === item) {\r\n                orderedRemoveItemAt(array, i);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** Remove an item by index from an array, moving everything to its right one space left. */\r\n    export function orderedRemoveItemAt<T>(array: T[], index: number): void {\r\n        // This seems to be faster than either `array.splice(i, 1)` or `array.copyWithin(i, i+ 1)`.\r\n        for (let i = index; i < array.length - 1; i++) {\r\n            array[i] = array[i + 1];\r\n        }\r\n        array.pop();\r\n    }\r\n\r\n    export function unorderedRemoveItemAt<T>(array: T[], index: number): void {\r\n        // Fill in the \"hole\" left at `index`.\r\n        array[index] = array[array.length - 1];\r\n        array.pop();\r\n    }\r\n\r\n    /** Remove the *first* occurrence of `item` from the array. */\r\n    export function unorderedRemoveItem<T>(array: T[], item: T) {\r\n        return unorderedRemoveFirstItemWhere(array, element => element === item);\r\n    }\r\n\r\n    /** Remove the *first* element satisfying `predicate`. */\r\n    function unorderedRemoveFirstItemWhere<T>(array: T[], predicate: (element: T) => boolean) {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (predicate(array[i])) {\r\n                unorderedRemoveItemAt(array, i);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export type GetCanonicalFileName = (fileName: string) => string;\r\n    export function createGetCanonicalFileName(useCaseSensitiveFileNames: boolean): GetCanonicalFileName {\r\n        return useCaseSensitiveFileNames ? identity : toLowerCase;\r\n    }\r\n\r\n    /**\r\n     * patternStrings contains both pattern strings (containing \"*\") and regular strings.\r\n     * Return an exact match if possible, or a pattern match, or undefined.\r\n     * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\r\n     */\r\n    export function matchPatternOrExact(patternStrings: ReadonlyArray<string>, candidate: string): string | Pattern | undefined {\r\n        const patterns: Pattern[] = [];\r\n        for (const patternString of patternStrings) {\r\n            const pattern = tryParsePattern(patternString);\r\n            if (pattern) {\r\n                patterns.push(pattern);\r\n            }\r\n            else if (patternString === candidate) {\r\n                // pattern was matched as is - no need to search further\r\n                return patternString;\r\n            }\r\n        }\r\n\r\n        return findBestPatternMatch(patterns, _ => _, candidate);\r\n    }\r\n\r\n    export function patternText({ prefix, suffix }: Pattern): string {\r\n        return `${prefix}*${suffix}`;\r\n    }\r\n\r\n    /**\r\n     * Given that candidate matches pattern, returns the text matching the '*'.\r\n     * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\r\n     */\r\n    export function matchedText(pattern: Pattern, candidate: string): string {\r\n        Debug.assert(isPatternMatch(pattern, candidate));\r\n        return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);\r\n    }\r\n\r\n    /** Return the object corresponding to the best pattern to match `candidate`. */\r\n    export function findBestPatternMatch<T>(values: ReadonlyArray<T>, getPattern: (value: T) => Pattern, candidate: string): T | undefined {\r\n        let matchedValue: T | undefined;\r\n        // use length of prefix as betterness criteria\r\n        let longestMatchPrefixLength = -1;\r\n\r\n        for (const v of values) {\r\n            const pattern = getPattern(v);\r\n            if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {\r\n                longestMatchPrefixLength = pattern.prefix.length;\r\n                matchedValue = v;\r\n            }\r\n        }\r\n\r\n        return matchedValue;\r\n    }\r\n\r\n    function isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {\r\n        return candidate.length >= prefix.length + suffix.length &&\r\n            startsWith(candidate, prefix) &&\r\n            endsWith(candidate, suffix);\r\n    }\r\n\r\n    export function tryParsePattern(pattern: string): Pattern | undefined {\r\n        // This should be verified outside of here and a proper error thrown.\r\n        Debug.assert(hasZeroOrOneAsteriskCharacter(pattern));\r\n        const indexOfStar = pattern.indexOf(\"*\");\r\n        return indexOfStar === -1 ? undefined : {\r\n            prefix: pattern.substr(0, indexOfStar),\r\n            suffix: pattern.substr(indexOfStar + 1)\r\n        };\r\n    }\r\n\r\n    export function positionIsSynthesized(pos: number): boolean {\r\n        // This is a fast way of testing the following conditions:\r\n        //  pos === undefined || pos === null || isNaN(pos) || pos < 0;\r\n        return !(pos >= 0);\r\n    }\r\n\r\n    /** True if an extension is one of the supported TypeScript extensions. */\r\n    export function extensionIsTypeScript(ext: Extension): boolean {\r\n        return ext === Extension.Ts || ext === Extension.Tsx || ext === Extension.Dts;\r\n    }\r\n\r\n    /**\r\n     * Gets the extension from a path.\r\n     * Path must have a valid extension.\r\n     */\r\n    export function extensionFromPath(path: string): Extension {\r\n        const ext = tryGetExtensionFromPath(path);\r\n        if (ext !== undefined) {\r\n            return ext;\r\n        }\r\n        Debug.fail(`File ${path} has unknown extension.`);\r\n    }\r\n\r\n    export function isAnySupportedFileExtension(path: string): boolean {\r\n        return tryGetExtensionFromPath(path) !== undefined;\r\n    }\r\n\r\n    export function tryGetExtensionFromPath(path: string): Extension | undefined {\r\n        return find<Extension>(supportedTypescriptExtensionsForExtractExtension, e => fileExtensionIs(path, e)) || find(supportedJavascriptExtensions, e => fileExtensionIs(path, e));\r\n    }\r\n\r\n    // Retrieves any string from the final \".\" onwards from a base file name.\r\n    // Unlike extensionFromPath, which throws an exception on unrecognized extensions.\r\n    export function getAnyExtensionFromPath(path: string): string | undefined {\r\n        const baseFileName = getBaseFileName(path);\r\n        const extensionIndex = baseFileName.lastIndexOf(\".\");\r\n        if (extensionIndex >= 0) {\r\n            return baseFileName.substring(extensionIndex);\r\n        }\r\n    }\r\n\r\n    export function isCheckJsEnabledForFile(sourceFile: SourceFile, compilerOptions: CompilerOptions) {\r\n        return sourceFile.checkJsDirective ? sourceFile.checkJsDirective.enabled : compilerOptions.checkJs;\r\n    }\r\n\r\n    export function and<T>(f: (arg: T) => boolean, g: (arg: T) => boolean) {\r\n        return (arg: T) => f(arg) && g(arg);\r\n    }\r\n\r\n    export function or<T>(f: (arg: T) => boolean, g: (arg: T) => boolean): (arg: T) => boolean {\r\n        return arg => f(arg) || g(arg);\r\n    }\r\n\r\n    export function assertTypeIsNever(_: never): void { } // tslint:disable-line no-empty\r\n\r\n    export const emptyFileSystemEntries: FileSystemEntries = {\r\n        files: emptyArray,\r\n        directories: emptyArray\r\n    };\r\n\r\n    export function singleElementArray<T>(t: T | undefined): T[] | undefined {\r\n        return t === undefined ? undefined : [t];\r\n    }\r\n\r\n    export function enumerateInsertsAndDeletes<T, U>(newItems: ReadonlyArray<T>, oldItems: ReadonlyArray<U>, comparer: (a: T, b: U) => Comparison, inserted: (newItem: T) => void, deleted: (oldItem: U) => void, unchanged?: (oldItem: U, newItem: T) => void) {\r\n        unchanged = unchanged || noop;\r\n        let newIndex = 0;\r\n        let oldIndex = 0;\r\n        const newLen = newItems.length;\r\n        const oldLen = oldItems.length;\r\n        while (newIndex < newLen && oldIndex < oldLen) {\r\n            const newItem = newItems[newIndex];\r\n            const oldItem = oldItems[oldIndex];\r\n            const compareResult = comparer(newItem, oldItem);\r\n            if (compareResult === Comparison.LessThan) {\r\n                inserted(newItem);\r\n                newIndex++;\r\n            }\r\n            else if (compareResult === Comparison.GreaterThan) {\r\n                deleted(oldItem);\r\n                oldIndex++;\r\n            }\r\n            else {\r\n                unchanged(oldItem, newItem);\r\n                newIndex++;\r\n                oldIndex++;\r\n            }\r\n        }\r\n        while (newIndex < newLen) {\r\n            inserted(newItems[newIndex++]);\r\n        }\r\n        while (oldIndex < oldLen) {\r\n            deleted(oldItems[oldIndex++]);\r\n        }\r\n    }\r\n}\r\n","declare function setTimeout(handler: (...args: any[]) => void, timeout: number): any;\r\ndeclare function clearTimeout(handle: any): void;\r\n\r\nnamespace ts {\r\n    /**\r\n     * Set a high stack trace limit to provide more information in case of an error.\r\n     * Called for command-line and server use cases.\r\n     * Not called if TypeScript is used as a library.\r\n     */\r\n    /* @internal */\r\n    export function setStackTraceLimit() {\r\n        if ((Error as any).stackTraceLimit < 100) { // Also tests that we won't set the property if it doesn't exist.\r\n            (Error as any).stackTraceLimit = 100;\r\n        }\r\n    }\r\n\r\n    export enum FileWatcherEventKind {\r\n        Created,\r\n        Changed,\r\n        Deleted\r\n    }\r\n\r\n    export type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind) => void;\r\n    export type DirectoryWatcherCallback = (fileName: string) => void;\r\n    /*@internal*/\r\n    export interface WatchedFile {\r\n        readonly fileName: string;\r\n        readonly callback: FileWatcherCallback;\r\n        mtime: Date;\r\n    }\r\n\r\n    /* @internal */\r\n    export enum PollingInterval {\r\n        High = 2000,\r\n        Medium = 500,\r\n        Low = 250\r\n    }\r\n\r\n    function getPriorityValues(highPriorityValue: number): [number, number, number] {\r\n        const mediumPriorityValue = highPriorityValue * 2;\r\n        const lowPriorityValue = mediumPriorityValue * 4;\r\n        return [highPriorityValue, mediumPriorityValue, lowPriorityValue];\r\n    }\r\n\r\n    function pollingInterval(watchPriority: PollingInterval): number {\r\n        return pollingIntervalsForPriority[watchPriority];\r\n    }\r\n\r\n    const pollingIntervalsForPriority = getPriorityValues(250);\r\n\r\n    /* @internal */\r\n    export function watchFileUsingPriorityPollingInterval(host: System, fileName: string, callback: FileWatcherCallback, watchPriority: PollingInterval): FileWatcher {\r\n        return host.watchFile(fileName, callback, pollingInterval(watchPriority));\r\n    }\r\n\r\n    /* @internal */\r\n    export type HostWatchFile = (fileName: string, callback: FileWatcherCallback, pollingInterval: PollingInterval) => FileWatcher;\r\n    /* @internal */\r\n    export type HostWatchDirectory = (fileName: string, callback: DirectoryWatcherCallback, recursive?: boolean) => FileWatcher;\r\n\r\n    /* @internal */\r\n    export const missingFileModifiedTime = new Date(0); // Any subsequent modification will occur after this time\r\n\r\n    interface Levels {\r\n        Low: number;\r\n        Medium: number;\r\n        High: number;\r\n    }\r\n\r\n    function createPollingIntervalBasedLevels(levels: Levels) {\r\n        return {\r\n            [PollingInterval.Low]: levels.Low,\r\n            [PollingInterval.Medium]: levels.Medium,\r\n            [PollingInterval.High]: levels.High\r\n        };\r\n    }\r\n\r\n    const defaultChunkLevels: Levels = { Low: 32, Medium: 64, High: 256 };\r\n    let pollingChunkSize = createPollingIntervalBasedLevels(defaultChunkLevels);\r\n    /* @internal */\r\n    export let unchangedPollThresholds = createPollingIntervalBasedLevels(defaultChunkLevels);\r\n\r\n    /* @internal */\r\n    export function setCustomPollingValues(system: System) {\r\n        if (!system.getEnvironmentVariable) {\r\n            return;\r\n        }\r\n        const pollingIntervalChanged = setCustomLevels(\"TSC_WATCH_POLLINGINTERVAL\", PollingInterval);\r\n        pollingChunkSize = getCustomPollingBasedLevels(\"TSC_WATCH_POLLINGCHUNKSIZE\", defaultChunkLevels) || pollingChunkSize;\r\n        unchangedPollThresholds = getCustomPollingBasedLevels(\"TSC_WATCH_UNCHANGEDPOLLTHRESHOLDS\", defaultChunkLevels) || unchangedPollThresholds;\r\n\r\n        function getLevel(envVar: string, level: keyof Levels) {\r\n            return system.getEnvironmentVariable(`${envVar}_${level.toUpperCase()}`);\r\n        }\r\n\r\n        function getCustomLevels(baseVariable: string) {\r\n            let customLevels: Partial<Levels> | undefined;\r\n            setCustomLevel(\"Low\");\r\n            setCustomLevel(\"Medium\");\r\n            setCustomLevel(\"High\");\r\n            return customLevels;\r\n\r\n            function setCustomLevel(level: keyof Levels) {\r\n                const customLevel = getLevel(baseVariable, level);\r\n                if (customLevel) {\r\n                    (customLevels || (customLevels = {}))[level] = Number(customLevel);\r\n                }\r\n            }\r\n        }\r\n\r\n        function setCustomLevels(baseVariable: string, levels: Levels) {\r\n            const customLevels = getCustomLevels(baseVariable);\r\n            if (customLevels) {\r\n                setLevel(\"Low\");\r\n                setLevel(\"Medium\");\r\n                setLevel(\"High\");\r\n                return true;\r\n            }\r\n            return false;\r\n\r\n            function setLevel(level: keyof Levels) {\r\n                levels[level] = customLevels[level] || levels[level];\r\n            }\r\n        }\r\n\r\n        function getCustomPollingBasedLevels(baseVariable: string, defaultLevels: Levels) {\r\n            const customLevels = getCustomLevels(baseVariable);\r\n            return (pollingIntervalChanged || customLevels) &&\r\n                createPollingIntervalBasedLevels(customLevels ? { ...defaultLevels, ...customLevels } : defaultLevels);\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function createDynamicPriorityPollingWatchFile(host: { getModifiedTime: System[\"getModifiedTime\"]; setTimeout: System[\"setTimeout\"]; }): HostWatchFile {\r\n        interface WatchedFile extends ts.WatchedFile {\r\n            isClosed?: boolean;\r\n            unchangedPolls: number;\r\n        }\r\n\r\n        interface PollingIntervalQueue extends Array<WatchedFile> {\r\n            pollingInterval: PollingInterval;\r\n            pollIndex: number;\r\n            pollScheduled: boolean;\r\n        }\r\n\r\n        const watchedFiles: WatchedFile[] = [];\r\n        const changedFilesInLastPoll: WatchedFile[] = [];\r\n        const lowPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.Low);\r\n        const mediumPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.Medium);\r\n        const highPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.High);\r\n        return watchFile;\r\n\r\n        function watchFile(fileName: string, callback: FileWatcherCallback, defaultPollingInterval: PollingInterval): FileWatcher {\r\n            const file: WatchedFile = {\r\n                fileName,\r\n                callback,\r\n                unchangedPolls: 0,\r\n                mtime: getModifiedTime(fileName)\r\n            };\r\n            watchedFiles.push(file);\r\n\r\n            addToPollingIntervalQueue(file, defaultPollingInterval);\r\n            return {\r\n                close: () => {\r\n                    file.isClosed = true;\r\n                    // Remove from watchedFiles\r\n                    unorderedRemoveItem(watchedFiles, file);\r\n                    // Do not update polling interval queue since that will happen as part of polling\r\n                }\r\n            };\r\n        }\r\n\r\n        function createPollingIntervalQueue(pollingInterval: PollingInterval): PollingIntervalQueue {\r\n            const queue = [] as PollingIntervalQueue;\r\n            queue.pollingInterval = pollingInterval;\r\n            queue.pollIndex = 0;\r\n            queue.pollScheduled = false;\r\n            return queue;\r\n        }\r\n\r\n        function pollPollingIntervalQueue(queue: PollingIntervalQueue) {\r\n            queue.pollIndex = pollQueue(queue, queue.pollingInterval, queue.pollIndex, pollingChunkSize[queue.pollingInterval]);\r\n            // Set the next polling index and timeout\r\n            if (queue.length) {\r\n                scheduleNextPoll(queue.pollingInterval);\r\n            }\r\n            else {\r\n                Debug.assert(queue.pollIndex === 0);\r\n                queue.pollScheduled = false;\r\n            }\r\n        }\r\n\r\n        function pollLowPollingIntervalQueue(queue: PollingIntervalQueue) {\r\n            // Always poll complete list of changedFilesInLastPoll\r\n            pollQueue(changedFilesInLastPoll, PollingInterval.Low, /*pollIndex*/ 0, changedFilesInLastPoll.length);\r\n\r\n            // Finally do the actual polling of the queue\r\n            pollPollingIntervalQueue(queue);\r\n            // Schedule poll if there are files in changedFilesInLastPoll but no files in the actual queue\r\n            // as pollPollingIntervalQueue wont schedule for next poll\r\n            if (!queue.pollScheduled && changedFilesInLastPoll.length) {\r\n                scheduleNextPoll(PollingInterval.Low);\r\n            }\r\n        }\r\n\r\n        function pollQueue(queue: WatchedFile[], pollingInterval: PollingInterval, pollIndex: number, chunkSize: number) {\r\n            // Max visit would be all elements of the queue\r\n            let needsVisit = queue.length;\r\n            let definedValueCopyToIndex = pollIndex;\r\n            for (let polled = 0; polled < chunkSize && needsVisit > 0; nextPollIndex(), needsVisit--) {\r\n                const watchedFile = queue[pollIndex];\r\n                if (!watchedFile) {\r\n                    continue;\r\n                }\r\n                else if (watchedFile.isClosed) {\r\n                    queue[pollIndex] = undefined;\r\n                    continue;\r\n                }\r\n\r\n                polled++;\r\n                const fileChanged = onWatchedFileStat(watchedFile, getModifiedTime(watchedFile.fileName));\r\n                if (watchedFile.isClosed) {\r\n                    // Closed watcher as part of callback\r\n                    queue[pollIndex] = undefined;\r\n                }\r\n                else if (fileChanged) {\r\n                    watchedFile.unchangedPolls = 0;\r\n                    // Changed files go to changedFilesInLastPoll queue\r\n                    if (queue !== changedFilesInLastPoll) {\r\n                        queue[pollIndex] = undefined;\r\n                        addChangedFileToLowPollingIntervalQueue(watchedFile);\r\n                    }\r\n                }\r\n                else if (watchedFile.unchangedPolls !== unchangedPollThresholds[pollingInterval]) {\r\n                    watchedFile.unchangedPolls++;\r\n                }\r\n                else if (queue === changedFilesInLastPoll) {\r\n                    // Restart unchangedPollCount for unchanged file and move to low polling interval queue\r\n                    watchedFile.unchangedPolls = 1;\r\n                    queue[pollIndex] = undefined;\r\n                    addToPollingIntervalQueue(watchedFile, PollingInterval.Low);\r\n                }\r\n                else if (pollingInterval !== PollingInterval.High) {\r\n                    watchedFile.unchangedPolls++;\r\n                    queue[pollIndex] = undefined;\r\n                    addToPollingIntervalQueue(watchedFile, pollingInterval === PollingInterval.Low ? PollingInterval.Medium : PollingInterval.High);\r\n                }\r\n\r\n                if (queue[pollIndex]) {\r\n                    // Copy this file to the non hole location\r\n                    if (definedValueCopyToIndex < pollIndex) {\r\n                        queue[definedValueCopyToIndex] = watchedFile;\r\n                        queue[pollIndex] = undefined;\r\n                    }\r\n                    definedValueCopyToIndex++;\r\n                }\r\n            }\r\n\r\n            // Return next poll index\r\n            return pollIndex;\r\n\r\n            function nextPollIndex() {\r\n                pollIndex++;\r\n                if (pollIndex === queue.length) {\r\n                    if (definedValueCopyToIndex < pollIndex) {\r\n                        // There are holes from nextDefinedValueIndex to end of queue, change queue size\r\n                        queue.length = definedValueCopyToIndex;\r\n                    }\r\n                    pollIndex = 0;\r\n                    definedValueCopyToIndex = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        function pollingIntervalQueue(pollingInterval: PollingInterval) {\r\n            switch (pollingInterval) {\r\n                case PollingInterval.Low:\r\n                    return lowPollingIntervalQueue;\r\n                case PollingInterval.Medium:\r\n                    return mediumPollingIntervalQueue;\r\n                case PollingInterval.High:\r\n                    return highPollingIntervalQueue;\r\n            }\r\n        }\r\n\r\n        function addToPollingIntervalQueue(file: WatchedFile, pollingInterval: PollingInterval) {\r\n            pollingIntervalQueue(pollingInterval).push(file);\r\n            scheduleNextPollIfNotAlreadyScheduled(pollingInterval);\r\n        }\r\n\r\n        function addChangedFileToLowPollingIntervalQueue(file: WatchedFile) {\r\n            changedFilesInLastPoll.push(file);\r\n            scheduleNextPollIfNotAlreadyScheduled(PollingInterval.Low);\r\n        }\r\n\r\n        function scheduleNextPollIfNotAlreadyScheduled(pollingInterval: PollingInterval) {\r\n            if (!pollingIntervalQueue(pollingInterval).pollScheduled) {\r\n                scheduleNextPoll(pollingInterval);\r\n            }\r\n        }\r\n\r\n        function scheduleNextPoll(pollingInterval: PollingInterval) {\r\n            pollingIntervalQueue(pollingInterval).pollScheduled = host.setTimeout(pollingInterval === PollingInterval.Low ? pollLowPollingIntervalQueue : pollPollingIntervalQueue, pollingInterval, pollingIntervalQueue(pollingInterval));\r\n        }\r\n\r\n        function getModifiedTime(fileName: string) {\r\n            return host.getModifiedTime(fileName) || missingFileModifiedTime;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if file status changed\r\n     */\r\n    /*@internal*/\r\n    export function onWatchedFileStat(watchedFile: WatchedFile, modifiedTime: Date): boolean {\r\n        const oldTime = watchedFile.mtime.getTime();\r\n        const newTime = modifiedTime.getTime();\r\n        if (oldTime !== newTime) {\r\n            watchedFile.mtime = modifiedTime;\r\n            const eventKind = oldTime === 0\r\n                ? FileWatcherEventKind.Created\r\n                : newTime === 0\r\n                    ? FileWatcherEventKind.Deleted\r\n                    : FileWatcherEventKind.Changed;\r\n            watchedFile.callback(watchedFile.fileName, eventKind);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /*@internal*/\r\n    export interface RecursiveDirectoryWatcherHost {\r\n        watchDirectory: HostWatchDirectory;\r\n        getAccessibleSortedChildDirectories(path: string): ReadonlyArray<string>;\r\n        directoryExists(dir: string): boolean;\r\n        filePathComparer: Comparer<string>;\r\n        realpath(s: string): string;\r\n    }\r\n\r\n    /**\r\n     * Watch the directory recursively using host provided method to watch child directories\r\n     * that means if this is recursive watcher, watch the children directories as well\r\n     * (eg on OS that dont support recursive watch using fs.watch use fs.watchFile)\r\n     */\r\n    /*@internal*/\r\n    export function createRecursiveDirectoryWatcher(host: RecursiveDirectoryWatcherHost): (directoryName: string, callback: DirectoryWatcherCallback) => FileWatcher {\r\n        type ChildWatches = ReadonlyArray<DirectoryWatcher>;\r\n        interface DirectoryWatcher extends FileWatcher {\r\n            childWatches: ChildWatches;\r\n            dirName: string;\r\n        }\r\n\r\n        return createDirectoryWatcher;\r\n\r\n        /**\r\n         * Create the directory watcher for the dirPath.\r\n         */\r\n        function createDirectoryWatcher(dirName: string, callback: DirectoryWatcherCallback): DirectoryWatcher {\r\n            const watcher = host.watchDirectory(dirName, fileName => {\r\n                // Call the actual callback\r\n                callback(fileName);\r\n\r\n                // Iterate through existing children and update the watches if needed\r\n                updateChildWatches(result, callback);\r\n            });\r\n\r\n            let result: DirectoryWatcher = {\r\n                close: () => {\r\n                    watcher.close();\r\n                    result.childWatches.forEach(closeFileWatcher);\r\n                    result = undefined;\r\n                },\r\n                dirName,\r\n                childWatches: emptyArray\r\n            };\r\n            updateChildWatches(result, callback);\r\n            return result;\r\n        }\r\n\r\n        function updateChildWatches(watcher: DirectoryWatcher, callback: DirectoryWatcherCallback) {\r\n            // Iterate through existing children and update the watches if needed\r\n            if (watcher) {\r\n                watcher.childWatches = watchChildDirectories(watcher.dirName, watcher.childWatches, callback);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Watch the directories in the parentDir\r\n         */\r\n        function watchChildDirectories(parentDir: string, existingChildWatches: ChildWatches, callback: DirectoryWatcherCallback): ChildWatches {\r\n            let newChildWatches: DirectoryWatcher[] | undefined;\r\n            enumerateInsertsAndDeletes<string, DirectoryWatcher>(\r\n                host.directoryExists(parentDir) ? mapDefined(host.getAccessibleSortedChildDirectories(parentDir), child => {\r\n                    const childFullName = getNormalizedAbsolutePath(child, parentDir);\r\n                    // Filter our the symbolic link directories since those arent included in recursive watch\r\n                    // which is same behaviour when recursive: true is passed to fs.watch\r\n                    return host.filePathComparer(childFullName, host.realpath(childFullName)) === Comparison.EqualTo ? childFullName : undefined;\r\n                }) : emptyArray,\r\n                existingChildWatches,\r\n                (child, childWatcher) => host.filePathComparer(child, childWatcher.dirName),\r\n                createAndAddChildDirectoryWatcher,\r\n                closeFileWatcher,\r\n                addChildDirectoryWatcher\r\n            );\r\n\r\n            return newChildWatches || emptyArray;\r\n\r\n            /**\r\n             * Create new childDirectoryWatcher and add it to the new ChildDirectoryWatcher list\r\n             */\r\n            function createAndAddChildDirectoryWatcher(childName: string) {\r\n                const result = createDirectoryWatcher(childName, callback);\r\n                addChildDirectoryWatcher(result);\r\n            }\r\n\r\n            /**\r\n             * Add child directory watcher to the new ChildDirectoryWatcher list\r\n             */\r\n            function addChildDirectoryWatcher(childWatcher: DirectoryWatcher) {\r\n                (newChildWatches || (newChildWatches = [])).push(childWatcher);\r\n            }\r\n        }\r\n    }\r\n\r\n    export interface System {\r\n        args: string[];\r\n        newLine: string;\r\n        useCaseSensitiveFileNames: boolean;\r\n        write(s: string): void;\r\n        writeOutputIsTTY?(): boolean;\r\n        readFile(path: string, encoding?: string): string | undefined;\r\n        getFileSize?(path: string): number;\r\n        writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;\r\n        /**\r\n         * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that\r\n         * use native OS file watching\r\n         */\r\n        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number): FileWatcher;\r\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean): FileWatcher;\r\n        resolvePath(path: string): string;\r\n        fileExists(path: string): boolean;\r\n        directoryExists(path: string): boolean;\r\n        createDirectory(path: string): void;\r\n        getExecutingFilePath(): string;\r\n        getCurrentDirectory(): string;\r\n        getDirectories(path: string): string[];\r\n        readDirectory(path: string, extensions?: ReadonlyArray<string>, exclude?: ReadonlyArray<string>, include?: ReadonlyArray<string>, depth?: number): string[];\r\n        getModifiedTime?(path: string): Date;\r\n        /**\r\n         * This should be cryptographically secure.\r\n         * A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)\r\n         */\r\n        createHash?(data: string): string;\r\n        getMemoryUsage?(): number;\r\n        exit(exitCode?: number): void;\r\n        realpath?(path: string): string;\r\n        /*@internal*/ getEnvironmentVariable(name: string): string;\r\n        /*@internal*/ tryEnableSourceMapsForHost?(): void;\r\n        /*@internal*/ debugMode?: boolean;\r\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\r\n        clearTimeout?(timeoutId: any): void;\r\n        clearScreen?(): void;\r\n        /*@internal*/ setBlocking?(): void;\r\n        base64decode?(input: string): string;\r\n        base64encode?(input: string): string;\r\n    }\r\n\r\n    export interface FileWatcher {\r\n        close(): void;\r\n    }\r\n\r\n    interface DirectoryWatcher extends FileWatcher {\r\n        referenceCount: number;\r\n    }\r\n\r\n    declare const require: any;\r\n    declare const process: any;\r\n    declare const global: any;\r\n    declare const __filename: string;\r\n\r\n    export function getNodeMajorVersion() {\r\n        if (typeof process === \"undefined\") {\r\n            return undefined;\r\n        }\r\n        const version: string = process.version;\r\n        if (!version) {\r\n            return undefined;\r\n        }\r\n        const dot = version.indexOf(\".\");\r\n        if (dot === -1) {\r\n            return undefined;\r\n        }\r\n        return parseInt(version.substring(1, dot));\r\n    }\r\n\r\n    declare const ChakraHost: {\r\n        args: string[];\r\n        currentDirectory: string;\r\n        executingFile: string;\r\n        newLine?: string;\r\n        useCaseSensitiveFileNames?: boolean;\r\n        echo(s: string): void;\r\n        quit(exitCode?: number): void;\r\n        fileExists(path: string): boolean;\r\n        directoryExists(path: string): boolean;\r\n        createDirectory(path: string): void;\r\n        resolvePath(path: string): string;\r\n        readFile(path: string): string | undefined;\r\n        writeFile(path: string, contents: string): void;\r\n        getDirectories(path: string): string[];\r\n        readDirectory(path: string, extensions?: ReadonlyArray<string>, basePaths?: ReadonlyArray<string>, excludeEx?: string, includeFileEx?: string, includeDirEx?: string): string[];\r\n        watchFile?(path: string, callback: FileWatcherCallback): FileWatcher;\r\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean): FileWatcher;\r\n        realpath(path: string): string;\r\n        getEnvironmentVariable?(name: string): string;\r\n    };\r\n\r\n    export let sys: System = (() => {\r\n        // NodeJS detects \"\\uFEFF\" at the start of the string and *replaces* it with the actual\r\n        // byte order mark from the specified encoding. Using any other byte order mark does\r\n        // not actually work.\r\n        const byteOrderMarkIndicator = \"\\uFEFF\";\r\n\r\n        function getNodeSystem(): System {\r\n            const _fs = require(\"fs\");\r\n            const _path = require(\"path\");\r\n            const _os = require(\"os\");\r\n            // crypto can be absent on reduced node installations\r\n            let _crypto: any;\r\n            try {\r\n              _crypto = require(\"crypto\");\r\n            }\r\n            catch {\r\n              _crypto = undefined;\r\n            }\r\n\r\n            const Buffer: {\r\n                new (input: string, encoding?: string): any;\r\n                from?(input: string, encoding?: string): any;\r\n            } = require(\"buffer\").Buffer;\r\n\r\n            const nodeVersion = getNodeMajorVersion();\r\n            const isNode4OrLater = nodeVersion >= 4;\r\n\r\n            const platform: string = _os.platform();\r\n            const useCaseSensitiveFileNames = isFileSystemCaseSensitive();\r\n\r\n            const enum FileSystemEntryKind {\r\n                File,\r\n                Directory\r\n            }\r\n\r\n            const useNonPollingWatchers = process.env.TSC_NONPOLLING_WATCHER;\r\n            const tscWatchFile = process.env.TSC_WATCHFILE;\r\n            const tscWatchDirectory = process.env.TSC_WATCHDIRECTORY;\r\n            let dynamicPollingWatchFile: HostWatchFile | undefined;\r\n            const nodeSystem: System = {\r\n                args: process.argv.slice(2),\r\n                newLine: _os.EOL,\r\n                useCaseSensitiveFileNames,\r\n                write(s: string): void {\r\n                    process.stdout.write(s);\r\n                },\r\n                writeOutputIsTTY() {\r\n                    return process.stdout.isTTY;\r\n                },\r\n                readFile,\r\n                writeFile,\r\n                watchFile: getWatchFile(),\r\n                watchDirectory: getWatchDirectory(),\r\n                resolvePath: path => _path.resolve(path),\r\n                fileExists,\r\n                directoryExists,\r\n                createDirectory(directoryName: string) {\r\n                    if (!nodeSystem.directoryExists(directoryName)) {\r\n                        _fs.mkdirSync(directoryName);\r\n                    }\r\n                },\r\n                getExecutingFilePath() {\r\n                    return __filename;\r\n                },\r\n                getCurrentDirectory() {\r\n                    return process.cwd();\r\n                },\r\n                getDirectories,\r\n                getEnvironmentVariable(name: string) {\r\n                    return process.env[name] || \"\";\r\n                },\r\n                readDirectory,\r\n                getModifiedTime,\r\n                createHash: _crypto ? createMD5HashUsingNativeCrypto : generateDjb2Hash,\r\n                getMemoryUsage() {\r\n                    if (global.gc) {\r\n                        global.gc();\r\n                    }\r\n                    return process.memoryUsage().heapUsed;\r\n                },\r\n                getFileSize(path) {\r\n                    try {\r\n                        const stat = _fs.statSync(path);\r\n                        if (stat.isFile()) {\r\n                            return stat.size;\r\n                        }\r\n                    }\r\n                    catch { /*ignore*/ }\r\n                    return 0;\r\n                },\r\n                exit(exitCode?: number): void {\r\n                    process.exit(exitCode);\r\n                },\r\n                realpath,\r\n                debugMode: some(<string[]>process.execArgv, arg => /^--(inspect|debug)(-brk)?(=\\d+)?$/i.test(arg)),\r\n                tryEnableSourceMapsForHost() {\r\n                    try {\r\n                        require(\"source-map-support\").install();\r\n                    }\r\n                    catch {\r\n                        // Could not enable source maps.\r\n                    }\r\n                },\r\n                setTimeout,\r\n                clearTimeout,\r\n                clearScreen: () => {\r\n                    process.stdout.write(\"\\x1Bc\");\r\n                },\r\n                setBlocking: () => {\r\n                    if (process.stdout && process.stdout._handle && process.stdout._handle.setBlocking) {\r\n                        process.stdout._handle.setBlocking(true);\r\n                    }\r\n                },\r\n                base64decode: Buffer.from ? input => {\r\n                    return Buffer.from(input, \"base64\").toString(\"utf8\");\r\n                } : input => {\r\n                    return new Buffer(input, \"base64\").toString(\"utf8\");\r\n                },\r\n                base64encode: Buffer.from ? input => {\r\n                    return Buffer.from(input).toString(\"base64\");\r\n                } : input => {\r\n                    return new Buffer(input).toString(\"base64\");\r\n                }\r\n            };\r\n            return nodeSystem;\r\n\r\n            function isFileSystemCaseSensitive(): boolean {\r\n                // win32\\win64 are case insensitive platforms\r\n                if (platform === \"win32\" || platform === \"win64\") {\r\n                    return false;\r\n                }\r\n                // If this file exists under a different case, we must be case-insensitve.\r\n                return !fileExists(swapCase(__filename));\r\n            }\r\n\r\n            /** Convert all lowercase chars to uppercase, and vice-versa */\r\n            function swapCase(s: string): string {\r\n                return s.replace(/\\w/g, (ch) => {\r\n                    const up = ch.toUpperCase();\r\n                    return ch === up ? ch.toLowerCase() : up;\r\n                });\r\n            }\r\n\r\n            function getWatchFile(): HostWatchFile {\r\n                switch (tscWatchFile) {\r\n                    case \"PriorityPollingInterval\":\r\n                        // Use polling interval based on priority when create watch using host.watchFile\r\n                        return fsWatchFile;\r\n                    case \"DynamicPriorityPolling\":\r\n                        // Use polling interval but change the interval depending on file changes and their default polling interval\r\n                        return createDynamicPriorityPollingWatchFile({ getModifiedTime, setTimeout });\r\n                    case \"UseFsEvents\":\r\n                        // Use notifications from FS to watch with falling back to fs.watchFile\r\n                        return watchFileUsingFsWatch;\r\n                    case \"UseFsEventsWithFallbackDynamicPolling\":\r\n                        // Use notifications from FS to watch with falling back to dynamic watch file\r\n                        dynamicPollingWatchFile = createDynamicPriorityPollingWatchFile({ getModifiedTime, setTimeout });\r\n                        return createWatchFileUsingDynamicWatchFile(dynamicPollingWatchFile);\r\n                    case \"UseFsEventsOnParentDirectory\":\r\n                        // Use notifications from FS to watch with falling back to fs.watchFile\r\n                        return createNonPollingWatchFile();\r\n                }\r\n                return useNonPollingWatchers ?\r\n                    createNonPollingWatchFile() :\r\n                    // Default to do not use polling interval as it is before this experiment branch\r\n                    (fileName, callback) => fsWatchFile(fileName, callback);\r\n            }\r\n\r\n            function getWatchDirectory(): HostWatchDirectory {\r\n                // Node 4.0 `fs.watch` function supports the \"recursive\" option on both OSX and Windows\r\n                // (ref: https://github.com/nodejs/node/pull/2649 and https://github.com/Microsoft/TypeScript/issues/4643)\r\n                const fsSupportsRecursive = isNode4OrLater && (process.platform === \"win32\" || process.platform === \"darwin\");\r\n                if (fsSupportsRecursive) {\r\n                    return watchDirectoryUsingFsWatch;\r\n                }\r\n\r\n                const watchDirectory = tscWatchDirectory === \"RecursiveDirectoryUsingFsWatchFile\" ?\r\n                    createWatchDirectoryUsing(fsWatchFile) :\r\n                    tscWatchDirectory === \"RecursiveDirectoryUsingDynamicPriorityPolling\" ?\r\n                        createWatchDirectoryUsing(dynamicPollingWatchFile || createDynamicPriorityPollingWatchFile({ getModifiedTime, setTimeout })) :\r\n                        watchDirectoryUsingFsWatch;\r\n                const watchDirectoryRecursively = createRecursiveDirectoryWatcher({\r\n                    filePathComparer: getStringComparer(!useCaseSensitiveFileNames),\r\n                    directoryExists,\r\n                    getAccessibleSortedChildDirectories: path => getAccessibleFileSystemEntries(path).directories,\r\n                    watchDirectory,\r\n                    realpath\r\n                });\r\n\r\n                return (directoryName, callback, recursive) => {\r\n                    if (recursive) {\r\n                        return watchDirectoryRecursively(directoryName, callback);\r\n                    }\r\n                    watchDirectory(directoryName, callback);\r\n                };\r\n            }\r\n\r\n            function createNonPollingWatchFile() {\r\n                // One file can have multiple watchers\r\n                const fileWatcherCallbacks = createMultiMap<FileWatcherCallback>();\r\n                const dirWatchers = createMap<DirectoryWatcher>();\r\n                const toCanonicalName = createGetCanonicalFileName(useCaseSensitiveFileNames);\r\n                return nonPollingWatchFile;\r\n\r\n                function nonPollingWatchFile(fileName: string, callback: FileWatcherCallback): FileWatcher {\r\n                    const filePath = toCanonicalName(fileName);\r\n                    fileWatcherCallbacks.add(filePath, callback);\r\n                    const dirPath = getDirectoryPath(filePath) || \".\";\r\n                    const watcher = dirWatchers.get(dirPath) || createDirectoryWatcher(getDirectoryPath(fileName) || \".\", dirPath);\r\n                    watcher.referenceCount++;\r\n                    return {\r\n                        close: () => {\r\n                            if (watcher.referenceCount === 1) {\r\n                                watcher.close();\r\n                                dirWatchers.delete(dirPath);\r\n                            }\r\n                            else {\r\n                                watcher.referenceCount--;\r\n                            }\r\n                            fileWatcherCallbacks.remove(filePath, callback);\r\n                        }\r\n                    };\r\n                }\r\n\r\n                function createDirectoryWatcher(dirName: string, dirPath: string) {\r\n                    const watcher = fsWatchDirectory(\r\n                        dirName,\r\n                        (_eventName: string, relativeFileName) => {\r\n                            // When files are deleted from disk, the triggered \"rename\" event would have a relativefileName of \"undefined\"\r\n                            const fileName = !isString(relativeFileName)\r\n                                ? undefined\r\n                                : getNormalizedAbsolutePath(relativeFileName, dirName);\r\n                            // Some applications save a working file via rename operations\r\n                            const callbacks = fileWatcherCallbacks.get(toCanonicalName(fileName));\r\n                            if (callbacks) {\r\n                                for (const fileCallback of callbacks) {\r\n                                    fileCallback(fileName, FileWatcherEventKind.Changed);\r\n                                }\r\n                            }\r\n                        }\r\n                    ) as DirectoryWatcher;\r\n                    watcher.referenceCount = 0;\r\n                    dirWatchers.set(dirPath, watcher);\r\n                    return watcher;\r\n                }\r\n            }\r\n\r\n            function fsWatchFile(fileName: string, callback: FileWatcherCallback, pollingInterval?: number): FileWatcher {\r\n                _fs.watchFile(fileName, { persistent: true, interval: pollingInterval || 250 }, fileChanged);\r\n                let eventKind: FileWatcherEventKind;\r\n                return {\r\n                    close: () => _fs.unwatchFile(fileName, fileChanged)\r\n                };\r\n\r\n                function fileChanged(curr: any, prev: any) {\r\n                    // previous event kind check is to ensure we recongnize the file as previously also missing when it is restored or renamed twice (that is it disappears and reappears)\r\n                    // In such case, prevTime returned is same as prev time of event when file was deleted as per node documentation\r\n                    const isPreviouslyDeleted = +prev.mtime === 0 || eventKind === FileWatcherEventKind.Deleted;\r\n                    if (+curr.mtime === 0) {\r\n                        if (isPreviouslyDeleted) {\r\n                            // Already deleted file, no need to callback again\r\n                            return;\r\n                        }\r\n                        eventKind = FileWatcherEventKind.Deleted;\r\n                    }\r\n                    else if (isPreviouslyDeleted) {\r\n                        eventKind = FileWatcherEventKind.Created;\r\n                    }\r\n                    // If there is no change in modified time, ignore the event\r\n                    else if (+curr.mtime === +prev.mtime) {\r\n                        return;\r\n                    }\r\n                    else {\r\n                        // File changed\r\n                        eventKind = FileWatcherEventKind.Changed;\r\n                    }\r\n                    callback(fileName, eventKind);\r\n                }\r\n            }\r\n\r\n            type FsWatchCallback = (eventName: \"rename\" | \"change\", relativeFileName: string) => void;\r\n\r\n            function createFileWatcherCallback(callback: FsWatchCallback): FileWatcherCallback {\r\n                return (_fileName, eventKind) => callback(eventKind === FileWatcherEventKind.Changed ? \"change\" : \"rename\", \"\");\r\n            }\r\n\r\n            function createFsWatchCallbackForFileWatcherCallback(fileName: string, callback: FileWatcherCallback): FsWatchCallback {\r\n                return eventName => {\r\n                    if (eventName === \"rename\") {\r\n                        callback(fileName, fileExists(fileName) ? FileWatcherEventKind.Created : FileWatcherEventKind.Deleted);\r\n                    }\r\n                    else {\r\n                        // Change\r\n                        callback(fileName, FileWatcherEventKind.Changed);\r\n                    }\r\n                };\r\n            }\r\n\r\n            function createFsWatchCallbackForDirectoryWatcherCallback(directoryName: string, callback: DirectoryWatcherCallback): FsWatchCallback {\r\n                return (eventName, relativeFileName) => {\r\n                    // In watchDirectory we only care about adding and removing files (when event name is\r\n                    // \"rename\"); changes made within files are handled by corresponding fileWatchers (when\r\n                    // event name is \"change\")\r\n                    if (eventName === \"rename\") {\r\n                        // When deleting a file, the passed baseFileName is null\r\n                        callback(!relativeFileName ? directoryName : normalizePath(combinePaths(directoryName, relativeFileName)));\r\n                    }\r\n                };\r\n            }\r\n\r\n            function fsWatch(fileOrDirectory: string, entryKind: FileSystemEntryKind.File | FileSystemEntryKind.Directory, callback: FsWatchCallback, recursive: boolean, fallbackPollingWatchFile: HostWatchFile, pollingInterval?: number): FileWatcher {\r\n                let options: any;\r\n                /** Watcher for the file system entry depending on whether it is missing or present */\r\n                let watcher = !fileSystemEntryExists(fileOrDirectory, entryKind) ?\r\n                    watchMissingFileSystemEntry() :\r\n                    watchPresentFileSystemEntry();\r\n                return {\r\n                    close: () => {\r\n                        // Close the watcher (either existing file system entry watcher or missing file system entry watcher)\r\n                        watcher.close();\r\n                        watcher = undefined;\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Invoke the callback with rename and update the watcher if not closed\r\n                 * @param createWatcher\r\n                 */\r\n                function invokeCallbackAndUpdateWatcher(createWatcher: () => FileWatcher) {\r\n                    // Call the callback for current directory\r\n                    callback(\"rename\", \"\");\r\n\r\n                    // If watcher is not closed, update it\r\n                    if (watcher) {\r\n                        watcher.close();\r\n                        watcher = createWatcher();\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Watch the file or directory that is currently present\r\n                 * and when the watched file or directory is deleted, switch to missing file system entry watcher\r\n                 */\r\n                function watchPresentFileSystemEntry(): FileWatcher {\r\n                    // Node 4.0 `fs.watch` function supports the \"recursive\" option on both OSX and Windows\r\n                    // (ref: https://github.com/nodejs/node/pull/2649 and https://github.com/Microsoft/TypeScript/issues/4643)\r\n                    if (options === undefined) {\r\n                        if (isNode4OrLater && (process.platform === \"win32\" || process.platform === \"darwin\")) {\r\n                            options = { persistent: true, recursive: !!recursive };\r\n                        }\r\n                        else {\r\n                            options = { persistent: true };\r\n                        }\r\n                    }\r\n                    try {\r\n\r\n                        const presentWatcher = _fs.watch(\r\n                            fileOrDirectory,\r\n                            options,\r\n                            callback\r\n                        );\r\n                        // Watch the missing file or directory or error\r\n                        presentWatcher.on(\"error\", () => invokeCallbackAndUpdateWatcher(watchMissingFileSystemEntry));\r\n                        return presentWatcher;\r\n                    }\r\n                    catch (e) {\r\n                        // Catch the exception and use polling instead\r\n                        // Eg. on linux the number of watches are limited and one could easily exhaust watches and the exception ENOSPC is thrown when creating watcher at that point\r\n                        // so instead of throwing error, use fs.watchFile\r\n                        return watchPresentFileSystemEntryWithFsWatchFile();\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Watch the file or directory using fs.watchFile since fs.watch threw exception\r\n                 * Eg. on linux the number of watches are limited and one could easily exhaust watches and the exception ENOSPC is thrown when creating watcher at that point\r\n                 */\r\n                function watchPresentFileSystemEntryWithFsWatchFile(): FileWatcher {\r\n                    return fallbackPollingWatchFile(fileOrDirectory, createFileWatcherCallback(callback), pollingInterval);\r\n                }\r\n\r\n                /**\r\n                 * Watch the file or directory that is missing\r\n                 * and switch to existing file or directory when the missing filesystem entry is created\r\n                 */\r\n                function watchMissingFileSystemEntry(): FileWatcher {\r\n                    return fallbackPollingWatchFile(fileOrDirectory, (_fileName, eventKind) => {\r\n                        if (eventKind === FileWatcherEventKind.Created && fileSystemEntryExists(fileOrDirectory, entryKind)) {\r\n                            // Call the callback for current file or directory\r\n                            // For now it could be callback for the inner directory creation,\r\n                            // but just return current directory, better than current no-op\r\n                            invokeCallbackAndUpdateWatcher(watchPresentFileSystemEntry);\r\n                        }\r\n                    }, pollingInterval);\r\n                }\r\n            }\r\n\r\n            function watchFileUsingFsWatch(fileName: string, callback: FileWatcherCallback, pollingInterval?: number) {\r\n                return fsWatch(fileName, FileSystemEntryKind.File, createFsWatchCallbackForFileWatcherCallback(fileName, callback), /*recursive*/ false, fsWatchFile, pollingInterval);\r\n            }\r\n\r\n            function createWatchFileUsingDynamicWatchFile(watchFile: HostWatchFile): HostWatchFile {\r\n                return (fileName, callback, pollingInterval) => fsWatch(fileName, FileSystemEntryKind.File, createFsWatchCallbackForFileWatcherCallback(fileName, callback), /*recursive*/ false, watchFile, pollingInterval);\r\n            }\r\n\r\n            function fsWatchDirectory(directoryName: string, callback: FsWatchCallback, recursive?: boolean): FileWatcher {\r\n                return fsWatch(directoryName, FileSystemEntryKind.Directory, callback, !!recursive, fsWatchFile);\r\n            }\r\n\r\n            function watchDirectoryUsingFsWatch(directoryName: string, callback: DirectoryWatcherCallback, recursive?: boolean) {\r\n                return fsWatchDirectory(directoryName, createFsWatchCallbackForDirectoryWatcherCallback(directoryName, callback), recursive);\r\n            }\r\n\r\n            function createWatchDirectoryUsing(fsWatchFile: HostWatchFile): HostWatchDirectory {\r\n                return (directoryName, callback) => fsWatchFile(directoryName, () => callback(directoryName), PollingInterval.Medium);\r\n            }\r\n\r\n            function readFile(fileName: string, _encoding?: string): string | undefined {\r\n                if (!fileExists(fileName)) {\r\n                    return undefined;\r\n                }\r\n                const buffer = _fs.readFileSync(fileName);\r\n                let len = buffer.length;\r\n                if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {\r\n                    // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,\r\n                    // flip all byte pairs and treat as little endian.\r\n                    len &= ~1; // Round down to a multiple of 2\r\n                    for (let i = 0; i < len; i += 2) {\r\n                        const temp = buffer[i];\r\n                        buffer[i] = buffer[i + 1];\r\n                        buffer[i + 1] = temp;\r\n                    }\r\n                    return buffer.toString(\"utf16le\", 2);\r\n                }\r\n                if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {\r\n                    // Little endian UTF-16 byte order mark detected\r\n                    return buffer.toString(\"utf16le\", 2);\r\n                }\r\n                if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\r\n                    // UTF-8 byte order mark detected\r\n                    return buffer.toString(\"utf8\", 3);\r\n                }\r\n                // Default is UTF-8 with no byte order mark\r\n                return buffer.toString(\"utf8\");\r\n            }\r\n\r\n            function writeFile(fileName: string, data: string, writeByteOrderMark?: boolean): void {\r\n                // If a BOM is required, emit one\r\n                if (writeByteOrderMark) {\r\n                    data = byteOrderMarkIndicator + data;\r\n                }\r\n\r\n                let fd: number;\r\n\r\n                try {\r\n                    fd = _fs.openSync(fileName, \"w\");\r\n                    _fs.writeSync(fd, data, /*position*/ undefined, \"utf8\");\r\n                }\r\n                finally {\r\n                    if (fd !== undefined) {\r\n                        _fs.closeSync(fd);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function getAccessibleFileSystemEntries(path: string): FileSystemEntries {\r\n                try {\r\n                    const entries = _fs.readdirSync(path || \".\").sort();\r\n                    const files: string[] = [];\r\n                    const directories: string[] = [];\r\n                    for (const entry of entries) {\r\n                        // This is necessary because on some file system node fails to exclude\r\n                        // \".\" and \"..\". See https://github.com/nodejs/node/issues/4002\r\n                        if (entry === \".\" || entry === \"..\") {\r\n                            continue;\r\n                        }\r\n                        const name = combinePaths(path, entry);\r\n\r\n                        let stat: any;\r\n                        try {\r\n                            stat = _fs.statSync(name);\r\n                        }\r\n                        catch (e) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (stat.isFile()) {\r\n                            files.push(entry);\r\n                        }\r\n                        else if (stat.isDirectory()) {\r\n                            directories.push(entry);\r\n                        }\r\n                    }\r\n                    return { files, directories };\r\n                }\r\n                catch (e) {\r\n                    return emptyFileSystemEntries;\r\n                }\r\n            }\r\n\r\n            function readDirectory(path: string, extensions?: ReadonlyArray<string>, excludes?: ReadonlyArray<string>, includes?: ReadonlyArray<string>, depth?: number): string[] {\r\n                return matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, process.cwd(), depth, getAccessibleFileSystemEntries);\r\n            }\r\n\r\n            function fileSystemEntryExists(path: string, entryKind: FileSystemEntryKind): boolean {\r\n                try {\r\n                    const stat = _fs.statSync(path);\r\n                    switch (entryKind) {\r\n                        case FileSystemEntryKind.File: return stat.isFile();\r\n                        case FileSystemEntryKind.Directory: return stat.isDirectory();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            function fileExists(path: string): boolean {\r\n                return fileSystemEntryExists(path, FileSystemEntryKind.File);\r\n            }\r\n\r\n            function directoryExists(path: string): boolean {\r\n                return fileSystemEntryExists(path, FileSystemEntryKind.Directory);\r\n            }\r\n\r\n            function getDirectories(path: string): string[] {\r\n                return filter<string>(_fs.readdirSync(path), dir => fileSystemEntryExists(combinePaths(path, dir), FileSystemEntryKind.Directory));\r\n            }\r\n\r\n            function realpath(path: string): string {\r\n                try {\r\n                    return _fs.realpathSync(path);\r\n                }\r\n                catch {\r\n                    return path;\r\n                }\r\n            }\r\n\r\n            function getModifiedTime(path: string) {\r\n                try {\r\n                    return _fs.statSync(path).mtime;\r\n                }\r\n                catch (e) {\r\n                    return undefined;\r\n                }\r\n            }\r\n\r\n            /**\r\n             * djb2 hashing algorithm\r\n             * http://www.cse.yorku.ca/~oz/hash.html\r\n             */\r\n            function generateDjb2Hash(data: string): string {\r\n                const chars = data.split(\"\").map(str => str.charCodeAt(0));\r\n                return `${chars.reduce((prev, curr) => ((prev << 5) + prev) + curr, 5381)}`;\r\n            }\r\n\r\n            function createMD5HashUsingNativeCrypto(data: string) {\r\n                const hash = _crypto.createHash(\"md5\");\r\n                hash.update(data);\r\n                return hash.digest(\"hex\");\r\n            }\r\n        }\r\n\r\n        function getChakraSystem(): System {\r\n            const realpath = ChakraHost.realpath && ((path: string) => ChakraHost.realpath(path));\r\n            return {\r\n                newLine: ChakraHost.newLine || \"\\r\\n\",\r\n                args: ChakraHost.args,\r\n                useCaseSensitiveFileNames: !!ChakraHost.useCaseSensitiveFileNames,\r\n                write: ChakraHost.echo,\r\n                readFile(path: string, _encoding?: string) {\r\n                    // encoding is automatically handled by the implementation in ChakraHost\r\n                    return ChakraHost.readFile(path);\r\n                },\r\n                writeFile(path: string, data: string, writeByteOrderMark?: boolean) {\r\n                    // If a BOM is required, emit one\r\n                    if (writeByteOrderMark) {\r\n                        data = byteOrderMarkIndicator + data;\r\n                    }\r\n\r\n                    ChakraHost.writeFile(path, data);\r\n                },\r\n                resolvePath: ChakraHost.resolvePath,\r\n                fileExists: ChakraHost.fileExists,\r\n                directoryExists: ChakraHost.directoryExists,\r\n                createDirectory: ChakraHost.createDirectory,\r\n                getExecutingFilePath: () => ChakraHost.executingFile,\r\n                getCurrentDirectory: () => ChakraHost.currentDirectory,\r\n                getDirectories: ChakraHost.getDirectories,\r\n                getEnvironmentVariable: ChakraHost.getEnvironmentVariable || (() => \"\"),\r\n                readDirectory(path, extensions, excludes, includes, _depth) {\r\n                    const pattern = getFileMatcherPatterns(path, excludes, includes, !!ChakraHost.useCaseSensitiveFileNames, ChakraHost.currentDirectory);\r\n                    return ChakraHost.readDirectory(path, extensions, pattern.basePaths, pattern.excludePattern, pattern.includeFilePattern, pattern.includeDirectoryPattern);\r\n                },\r\n                exit: ChakraHost.quit,\r\n                realpath\r\n            };\r\n        }\r\n\r\n        function recursiveCreateDirectory(directoryPath: string, sys: System) {\r\n            const basePath = getDirectoryPath(directoryPath);\r\n            const shouldCreateParent = basePath !== \"\" && directoryPath !== basePath && !sys.directoryExists(basePath);\r\n            if (shouldCreateParent) {\r\n                recursiveCreateDirectory(basePath, sys);\r\n            }\r\n            if (shouldCreateParent || !sys.directoryExists(directoryPath)) {\r\n                sys.createDirectory(directoryPath);\r\n            }\r\n        }\r\n\r\n        let sys: System;\r\n        if (typeof ChakraHost !== \"undefined\") {\r\n            sys = getChakraSystem();\r\n        }\r\n        else if (typeof process !== \"undefined\" && process.nextTick && !process.browser && typeof require !== \"undefined\") {\r\n            // process and process.nextTick checks if current environment is node-like\r\n            // process.browser check excludes webpack and browserify\r\n            sys = getNodeSystem();\r\n        }\r\n        if (sys) {\r\n            // patch writefile to create folder before writing the file\r\n            const originalWriteFile = sys.writeFile;\r\n            sys.writeFile = (path, data, writeBom) => {\r\n                const directoryPath = getDirectoryPath(normalizeSlashes(path));\r\n                if (directoryPath && !sys.directoryExists(directoryPath)) {\r\n                    recursiveCreateDirectory(directoryPath, sys);\r\n                }\r\n                originalWriteFile.call(sys, path, data, writeBom);\r\n            };\r\n        }\r\n        return sys;\r\n    })();\r\n\r\n    if (sys && sys.getEnvironmentVariable) {\r\n        setCustomPollingValues(sys);\r\n        Debug.currentAssertionLevel = /^development$/i.test(sys.getEnvironmentVariable(\"NODE_ENV\"))\r\n            ? AssertionLevel.Normal\r\n            : AssertionLevel.None;\r\n    }\r\n    if (sys && sys.debugMode) {\r\n        Debug.isDebugging = true;\r\n    }\r\n}\r\n","// <auto-generated />\r\n// generated from './diagnosticInformationMap.generated.ts' by '../../scripts/processDiagnosticMessages.js'\r\n/* @internal */\r\nnamespace ts {\r\n    function diag(code: number, category: DiagnosticCategory, key: string, message: string, reportsUnnecessary?: {}): DiagnosticMessage {\r\n        return { code, category, key, message, reportsUnnecessary };\r\n    }\r\n    // tslint:disable-next-line variable-name\r\n    export const Diagnostics = {\r\n        Unterminated_string_literal: diag(1002, DiagnosticCategory.Error, \"Unterminated_string_literal_1002\", \"Unterminated string literal.\"),\r\n        Identifier_expected: diag(1003, DiagnosticCategory.Error, \"Identifier_expected_1003\", \"Identifier expected.\"),\r\n        _0_expected: diag(1005, DiagnosticCategory.Error, \"_0_expected_1005\", \"'{0}' expected.\"),\r\n        A_file_cannot_have_a_reference_to_itself: diag(1006, DiagnosticCategory.Error, \"A_file_cannot_have_a_reference_to_itself_1006\", \"A file cannot have a reference to itself.\"),\r\n        Trailing_comma_not_allowed: diag(1009, DiagnosticCategory.Error, \"Trailing_comma_not_allowed_1009\", \"Trailing comma not allowed.\"),\r\n        Asterisk_Slash_expected: diag(1010, DiagnosticCategory.Error, \"Asterisk_Slash_expected_1010\", \"'*/' expected.\"),\r\n        An_element_access_expression_should_take_an_argument: diag(1011, DiagnosticCategory.Error, \"An_element_access_expression_should_take_an_argument_1011\", \"An element access expression should take an argument.\"),\r\n        Unexpected_token: diag(1012, DiagnosticCategory.Error, \"Unexpected_token_1012\", \"Unexpected token.\"),\r\n        A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma: diag(1013, DiagnosticCategory.Error, \"A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013\", \"A rest parameter or binding pattern may not have a trailing comma.\"),\r\n        A_rest_parameter_must_be_last_in_a_parameter_list: diag(1014, DiagnosticCategory.Error, \"A_rest_parameter_must_be_last_in_a_parameter_list_1014\", \"A rest parameter must be last in a parameter list.\"),\r\n        Parameter_cannot_have_question_mark_and_initializer: diag(1015, DiagnosticCategory.Error, \"Parameter_cannot_have_question_mark_and_initializer_1015\", \"Parameter cannot have question mark and initializer.\"),\r\n        A_required_parameter_cannot_follow_an_optional_parameter: diag(1016, DiagnosticCategory.Error, \"A_required_parameter_cannot_follow_an_optional_parameter_1016\", \"A required parameter cannot follow an optional parameter.\"),\r\n        An_index_signature_cannot_have_a_rest_parameter: diag(1017, DiagnosticCategory.Error, \"An_index_signature_cannot_have_a_rest_parameter_1017\", \"An index signature cannot have a rest parameter.\"),\r\n        An_index_signature_parameter_cannot_have_an_accessibility_modifier: diag(1018, DiagnosticCategory.Error, \"An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018\", \"An index signature parameter cannot have an accessibility modifier.\"),\r\n        An_index_signature_parameter_cannot_have_a_question_mark: diag(1019, DiagnosticCategory.Error, \"An_index_signature_parameter_cannot_have_a_question_mark_1019\", \"An index signature parameter cannot have a question mark.\"),\r\n        An_index_signature_parameter_cannot_have_an_initializer: diag(1020, DiagnosticCategory.Error, \"An_index_signature_parameter_cannot_have_an_initializer_1020\", \"An index signature parameter cannot have an initializer.\"),\r\n        An_index_signature_must_have_a_type_annotation: diag(1021, DiagnosticCategory.Error, \"An_index_signature_must_have_a_type_annotation_1021\", \"An index signature must have a type annotation.\"),\r\n        An_index_signature_parameter_must_have_a_type_annotation: diag(1022, DiagnosticCategory.Error, \"An_index_signature_parameter_must_have_a_type_annotation_1022\", \"An index signature parameter must have a type annotation.\"),\r\n        An_index_signature_parameter_type_must_be_string_or_number: diag(1023, DiagnosticCategory.Error, \"An_index_signature_parameter_type_must_be_string_or_number_1023\", \"An index signature parameter type must be 'string' or 'number'.\"),\r\n        readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: diag(1024, DiagnosticCategory.Error, \"readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024\", \"'readonly' modifier can only appear on a property declaration or index signature.\"),\r\n        Accessibility_modifier_already_seen: diag(1028, DiagnosticCategory.Error, \"Accessibility_modifier_already_seen_1028\", \"Accessibility modifier already seen.\"),\r\n        _0_modifier_must_precede_1_modifier: diag(1029, DiagnosticCategory.Error, \"_0_modifier_must_precede_1_modifier_1029\", \"'{0}' modifier must precede '{1}' modifier.\"),\r\n        _0_modifier_already_seen: diag(1030, DiagnosticCategory.Error, \"_0_modifier_already_seen_1030\", \"'{0}' modifier already seen.\"),\r\n        _0_modifier_cannot_appear_on_a_class_element: diag(1031, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_class_element_1031\", \"'{0}' modifier cannot appear on a class element.\"),\r\n        super_must_be_followed_by_an_argument_list_or_member_access: diag(1034, DiagnosticCategory.Error, \"super_must_be_followed_by_an_argument_list_or_member_access_1034\", \"'super' must be followed by an argument list or member access.\"),\r\n        Only_ambient_modules_can_use_quoted_names: diag(1035, DiagnosticCategory.Error, \"Only_ambient_modules_can_use_quoted_names_1035\", \"Only ambient modules can use quoted names.\"),\r\n        Statements_are_not_allowed_in_ambient_contexts: diag(1036, DiagnosticCategory.Error, \"Statements_are_not_allowed_in_ambient_contexts_1036\", \"Statements are not allowed in ambient contexts.\"),\r\n        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: diag(1038, DiagnosticCategory.Error, \"A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038\", \"A 'declare' modifier cannot be used in an already ambient context.\"),\r\n        Initializers_are_not_allowed_in_ambient_contexts: diag(1039, DiagnosticCategory.Error, \"Initializers_are_not_allowed_in_ambient_contexts_1039\", \"Initializers are not allowed in ambient contexts.\"),\r\n        _0_modifier_cannot_be_used_in_an_ambient_context: diag(1040, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_in_an_ambient_context_1040\", \"'{0}' modifier cannot be used in an ambient context.\"),\r\n        _0_modifier_cannot_be_used_with_a_class_declaration: diag(1041, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_with_a_class_declaration_1041\", \"'{0}' modifier cannot be used with a class declaration.\"),\r\n        _0_modifier_cannot_be_used_here: diag(1042, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_here_1042\", \"'{0}' modifier cannot be used here.\"),\r\n        _0_modifier_cannot_appear_on_a_data_property: diag(1043, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_data_property_1043\", \"'{0}' modifier cannot appear on a data property.\"),\r\n        _0_modifier_cannot_appear_on_a_module_or_namespace_element: diag(1044, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044\", \"'{0}' modifier cannot appear on a module or namespace element.\"),\r\n        A_0_modifier_cannot_be_used_with_an_interface_declaration: diag(1045, DiagnosticCategory.Error, \"A_0_modifier_cannot_be_used_with_an_interface_declaration_1045\", \"A '{0}' modifier cannot be used with an interface declaration.\"),\r\n        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: diag(1046, DiagnosticCategory.Error, \"A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file_1046\", \"A 'declare' modifier is required for a top level declaration in a .d.ts file.\"),\r\n        A_rest_parameter_cannot_be_optional: diag(1047, DiagnosticCategory.Error, \"A_rest_parameter_cannot_be_optional_1047\", \"A rest parameter cannot be optional.\"),\r\n        A_rest_parameter_cannot_have_an_initializer: diag(1048, DiagnosticCategory.Error, \"A_rest_parameter_cannot_have_an_initializer_1048\", \"A rest parameter cannot have an initializer.\"),\r\n        A_set_accessor_must_have_exactly_one_parameter: diag(1049, DiagnosticCategory.Error, \"A_set_accessor_must_have_exactly_one_parameter_1049\", \"A 'set' accessor must have exactly one parameter.\"),\r\n        A_set_accessor_cannot_have_an_optional_parameter: diag(1051, DiagnosticCategory.Error, \"A_set_accessor_cannot_have_an_optional_parameter_1051\", \"A 'set' accessor cannot have an optional parameter.\"),\r\n        A_set_accessor_parameter_cannot_have_an_initializer: diag(1052, DiagnosticCategory.Error, \"A_set_accessor_parameter_cannot_have_an_initializer_1052\", \"A 'set' accessor parameter cannot have an initializer.\"),\r\n        A_set_accessor_cannot_have_rest_parameter: diag(1053, DiagnosticCategory.Error, \"A_set_accessor_cannot_have_rest_parameter_1053\", \"A 'set' accessor cannot have rest parameter.\"),\r\n        A_get_accessor_cannot_have_parameters: diag(1054, DiagnosticCategory.Error, \"A_get_accessor_cannot_have_parameters_1054\", \"A 'get' accessor cannot have parameters.\"),\r\n        Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: diag(1055, DiagnosticCategory.Error, \"Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055\", \"Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value.\"),\r\n        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: diag(1056, DiagnosticCategory.Error, \"Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056\", \"Accessors are only available when targeting ECMAScript 5 and higher.\"),\r\n        An_async_function_or_method_must_have_a_valid_awaitable_return_type: diag(1057, DiagnosticCategory.Error, \"An_async_function_or_method_must_have_a_valid_awaitable_return_type_1057\", \"An async function or method must have a valid awaitable return type.\"),\r\n        The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1058, DiagnosticCategory.Error, \"The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058\", \"The return type of an async function must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        A_promise_must_have_a_then_method: diag(1059, DiagnosticCategory.Error, \"A_promise_must_have_a_then_method_1059\", \"A promise must have a 'then' method.\"),\r\n        The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: diag(1060, DiagnosticCategory.Error, \"The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060\", \"The first parameter of the 'then' method of a promise must be a callback.\"),\r\n        Enum_member_must_have_initializer: diag(1061, DiagnosticCategory.Error, \"Enum_member_must_have_initializer_1061\", \"Enum member must have initializer.\"),\r\n        Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: diag(1062, DiagnosticCategory.Error, \"Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062\", \"Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method.\"),\r\n        An_export_assignment_cannot_be_used_in_a_namespace: diag(1063, DiagnosticCategory.Error, \"An_export_assignment_cannot_be_used_in_a_namespace_1063\", \"An export assignment cannot be used in a namespace.\"),\r\n        The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type: diag(1064, DiagnosticCategory.Error, \"The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_1064\", \"The return type of an async function or method must be the global Promise<T> type.\"),\r\n        In_ambient_enum_declarations_member_initializer_must_be_constant_expression: diag(1066, DiagnosticCategory.Error, \"In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066\", \"In ambient enum declarations member initializer must be constant expression.\"),\r\n        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: diag(1068, DiagnosticCategory.Error, \"Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068\", \"Unexpected token. A constructor, method, accessor, or property was expected.\"),\r\n        _0_modifier_cannot_appear_on_a_type_member: diag(1070, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_type_member_1070\", \"'{0}' modifier cannot appear on a type member.\"),\r\n        _0_modifier_cannot_appear_on_an_index_signature: diag(1071, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_an_index_signature_1071\", \"'{0}' modifier cannot appear on an index signature.\"),\r\n        A_0_modifier_cannot_be_used_with_an_import_declaration: diag(1079, DiagnosticCategory.Error, \"A_0_modifier_cannot_be_used_with_an_import_declaration_1079\", \"A '{0}' modifier cannot be used with an import declaration.\"),\r\n        Invalid_reference_directive_syntax: diag(1084, DiagnosticCategory.Error, \"Invalid_reference_directive_syntax_1084\", \"Invalid 'reference' directive syntax.\"),\r\n        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0: diag(1085, DiagnosticCategory.Error, \"Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0_1085\", \"Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'.\"),\r\n        An_accessor_cannot_be_declared_in_an_ambient_context: diag(1086, DiagnosticCategory.Error, \"An_accessor_cannot_be_declared_in_an_ambient_context_1086\", \"An accessor cannot be declared in an ambient context.\"),\r\n        _0_modifier_cannot_appear_on_a_constructor_declaration: diag(1089, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_constructor_declaration_1089\", \"'{0}' modifier cannot appear on a constructor declaration.\"),\r\n        _0_modifier_cannot_appear_on_a_parameter: diag(1090, DiagnosticCategory.Error, \"_0_modifier_cannot_appear_on_a_parameter_1090\", \"'{0}' modifier cannot appear on a parameter.\"),\r\n        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: diag(1091, DiagnosticCategory.Error, \"Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091\", \"Only a single variable declaration is allowed in a 'for...in' statement.\"),\r\n        Type_parameters_cannot_appear_on_a_constructor_declaration: diag(1092, DiagnosticCategory.Error, \"Type_parameters_cannot_appear_on_a_constructor_declaration_1092\", \"Type parameters cannot appear on a constructor declaration.\"),\r\n        Type_annotation_cannot_appear_on_a_constructor_declaration: diag(1093, DiagnosticCategory.Error, \"Type_annotation_cannot_appear_on_a_constructor_declaration_1093\", \"Type annotation cannot appear on a constructor declaration.\"),\r\n        An_accessor_cannot_have_type_parameters: diag(1094, DiagnosticCategory.Error, \"An_accessor_cannot_have_type_parameters_1094\", \"An accessor cannot have type parameters.\"),\r\n        A_set_accessor_cannot_have_a_return_type_annotation: diag(1095, DiagnosticCategory.Error, \"A_set_accessor_cannot_have_a_return_type_annotation_1095\", \"A 'set' accessor cannot have a return type annotation.\"),\r\n        An_index_signature_must_have_exactly_one_parameter: diag(1096, DiagnosticCategory.Error, \"An_index_signature_must_have_exactly_one_parameter_1096\", \"An index signature must have exactly one parameter.\"),\r\n        _0_list_cannot_be_empty: diag(1097, DiagnosticCategory.Error, \"_0_list_cannot_be_empty_1097\", \"'{0}' list cannot be empty.\"),\r\n        Type_parameter_list_cannot_be_empty: diag(1098, DiagnosticCategory.Error, \"Type_parameter_list_cannot_be_empty_1098\", \"Type parameter list cannot be empty.\"),\r\n        Type_argument_list_cannot_be_empty: diag(1099, DiagnosticCategory.Error, \"Type_argument_list_cannot_be_empty_1099\", \"Type argument list cannot be empty.\"),\r\n        Invalid_use_of_0_in_strict_mode: diag(1100, DiagnosticCategory.Error, \"Invalid_use_of_0_in_strict_mode_1100\", \"Invalid use of '{0}' in strict mode.\"),\r\n        with_statements_are_not_allowed_in_strict_mode: diag(1101, DiagnosticCategory.Error, \"with_statements_are_not_allowed_in_strict_mode_1101\", \"'with' statements are not allowed in strict mode.\"),\r\n        delete_cannot_be_called_on_an_identifier_in_strict_mode: diag(1102, DiagnosticCategory.Error, \"delete_cannot_be_called_on_an_identifier_in_strict_mode_1102\", \"'delete' cannot be called on an identifier in strict mode.\"),\r\n        A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator: diag(1103, DiagnosticCategory.Error, \"A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator_1103\", \"A 'for-await-of' statement is only allowed within an async function or async generator.\"),\r\n        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: diag(1104, DiagnosticCategory.Error, \"A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104\", \"A 'continue' statement can only be used within an enclosing iteration statement.\"),\r\n        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: diag(1105, DiagnosticCategory.Error, \"A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105\", \"A 'break' statement can only be used within an enclosing iteration or switch statement.\"),\r\n        Jump_target_cannot_cross_function_boundary: diag(1107, DiagnosticCategory.Error, \"Jump_target_cannot_cross_function_boundary_1107\", \"Jump target cannot cross function boundary.\"),\r\n        A_return_statement_can_only_be_used_within_a_function_body: diag(1108, DiagnosticCategory.Error, \"A_return_statement_can_only_be_used_within_a_function_body_1108\", \"A 'return' statement can only be used within a function body.\"),\r\n        Expression_expected: diag(1109, DiagnosticCategory.Error, \"Expression_expected_1109\", \"Expression expected.\"),\r\n        Type_expected: diag(1110, DiagnosticCategory.Error, \"Type_expected_1110\", \"Type expected.\"),\r\n        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: diag(1113, DiagnosticCategory.Error, \"A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113\", \"A 'default' clause cannot appear more than once in a 'switch' statement.\"),\r\n        Duplicate_label_0: diag(1114, DiagnosticCategory.Error, \"Duplicate_label_0_1114\", \"Duplicate label '{0}'.\"),\r\n        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: diag(1115, DiagnosticCategory.Error, \"A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115\", \"A 'continue' statement can only jump to a label of an enclosing iteration statement.\"),\r\n        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: diag(1116, DiagnosticCategory.Error, \"A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116\", \"A 'break' statement can only jump to a label of an enclosing statement.\"),\r\n        An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode: diag(1117, DiagnosticCategory.Error, \"An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode_1117\", \"An object literal cannot have multiple properties with the same name in strict mode.\"),\r\n        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: diag(1118, DiagnosticCategory.Error, \"An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118\", \"An object literal cannot have multiple get/set accessors with the same name.\"),\r\n        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: diag(1119, DiagnosticCategory.Error, \"An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119\", \"An object literal cannot have property and accessor with the same name.\"),\r\n        An_export_assignment_cannot_have_modifiers: diag(1120, DiagnosticCategory.Error, \"An_export_assignment_cannot_have_modifiers_1120\", \"An export assignment cannot have modifiers.\"),\r\n        Octal_literals_are_not_allowed_in_strict_mode: diag(1121, DiagnosticCategory.Error, \"Octal_literals_are_not_allowed_in_strict_mode_1121\", \"Octal literals are not allowed in strict mode.\"),\r\n        A_tuple_type_element_list_cannot_be_empty: diag(1122, DiagnosticCategory.Error, \"A_tuple_type_element_list_cannot_be_empty_1122\", \"A tuple type element list cannot be empty.\"),\r\n        Variable_declaration_list_cannot_be_empty: diag(1123, DiagnosticCategory.Error, \"Variable_declaration_list_cannot_be_empty_1123\", \"Variable declaration list cannot be empty.\"),\r\n        Digit_expected: diag(1124, DiagnosticCategory.Error, \"Digit_expected_1124\", \"Digit expected.\"),\r\n        Hexadecimal_digit_expected: diag(1125, DiagnosticCategory.Error, \"Hexadecimal_digit_expected_1125\", \"Hexadecimal digit expected.\"),\r\n        Unexpected_end_of_text: diag(1126, DiagnosticCategory.Error, \"Unexpected_end_of_text_1126\", \"Unexpected end of text.\"),\r\n        Invalid_character: diag(1127, DiagnosticCategory.Error, \"Invalid_character_1127\", \"Invalid character.\"),\r\n        Declaration_or_statement_expected: diag(1128, DiagnosticCategory.Error, \"Declaration_or_statement_expected_1128\", \"Declaration or statement expected.\"),\r\n        Statement_expected: diag(1129, DiagnosticCategory.Error, \"Statement_expected_1129\", \"Statement expected.\"),\r\n        case_or_default_expected: diag(1130, DiagnosticCategory.Error, \"case_or_default_expected_1130\", \"'case' or 'default' expected.\"),\r\n        Property_or_signature_expected: diag(1131, DiagnosticCategory.Error, \"Property_or_signature_expected_1131\", \"Property or signature expected.\"),\r\n        Enum_member_expected: diag(1132, DiagnosticCategory.Error, \"Enum_member_expected_1132\", \"Enum member expected.\"),\r\n        Variable_declaration_expected: diag(1134, DiagnosticCategory.Error, \"Variable_declaration_expected_1134\", \"Variable declaration expected.\"),\r\n        Argument_expression_expected: diag(1135, DiagnosticCategory.Error, \"Argument_expression_expected_1135\", \"Argument expression expected.\"),\r\n        Property_assignment_expected: diag(1136, DiagnosticCategory.Error, \"Property_assignment_expected_1136\", \"Property assignment expected.\"),\r\n        Expression_or_comma_expected: diag(1137, DiagnosticCategory.Error, \"Expression_or_comma_expected_1137\", \"Expression or comma expected.\"),\r\n        Parameter_declaration_expected: diag(1138, DiagnosticCategory.Error, \"Parameter_declaration_expected_1138\", \"Parameter declaration expected.\"),\r\n        Type_parameter_declaration_expected: diag(1139, DiagnosticCategory.Error, \"Type_parameter_declaration_expected_1139\", \"Type parameter declaration expected.\"),\r\n        Type_argument_expected: diag(1140, DiagnosticCategory.Error, \"Type_argument_expected_1140\", \"Type argument expected.\"),\r\n        String_literal_expected: diag(1141, DiagnosticCategory.Error, \"String_literal_expected_1141\", \"String literal expected.\"),\r\n        Line_break_not_permitted_here: diag(1142, DiagnosticCategory.Error, \"Line_break_not_permitted_here_1142\", \"Line break not permitted here.\"),\r\n        or_expected: diag(1144, DiagnosticCategory.Error, \"or_expected_1144\", \"'{' or ';' expected.\"),\r\n        Declaration_expected: diag(1146, DiagnosticCategory.Error, \"Declaration_expected_1146\", \"Declaration expected.\"),\r\n        Import_declarations_in_a_namespace_cannot_reference_a_module: diag(1147, DiagnosticCategory.Error, \"Import_declarations_in_a_namespace_cannot_reference_a_module_1147\", \"Import declarations in a namespace cannot reference a module.\"),\r\n        Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: diag(1148, DiagnosticCategory.Error, \"Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148\", \"Cannot use imports, exports, or module augmentations when '--module' is 'none'.\"),\r\n        File_name_0_differs_from_already_included_file_name_1_only_in_casing: diag(1149, DiagnosticCategory.Error, \"File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149\", \"File name '{0}' differs from already included file name '{1}' only in casing.\"),\r\n        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: diag(1150, DiagnosticCategory.Error, \"new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead_1150\", \"'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.\"),\r\n        const_declarations_must_be_initialized: diag(1155, DiagnosticCategory.Error, \"const_declarations_must_be_initialized_1155\", \"'const' declarations must be initialized.\"),\r\n        const_declarations_can_only_be_declared_inside_a_block: diag(1156, DiagnosticCategory.Error, \"const_declarations_can_only_be_declared_inside_a_block_1156\", \"'const' declarations can only be declared inside a block.\"),\r\n        let_declarations_can_only_be_declared_inside_a_block: diag(1157, DiagnosticCategory.Error, \"let_declarations_can_only_be_declared_inside_a_block_1157\", \"'let' declarations can only be declared inside a block.\"),\r\n        Unterminated_template_literal: diag(1160, DiagnosticCategory.Error, \"Unterminated_template_literal_1160\", \"Unterminated template literal.\"),\r\n        Unterminated_regular_expression_literal: diag(1161, DiagnosticCategory.Error, \"Unterminated_regular_expression_literal_1161\", \"Unterminated regular expression literal.\"),\r\n        An_object_member_cannot_be_declared_optional: diag(1162, DiagnosticCategory.Error, \"An_object_member_cannot_be_declared_optional_1162\", \"An object member cannot be declared optional.\"),\r\n        A_yield_expression_is_only_allowed_in_a_generator_body: diag(1163, DiagnosticCategory.Error, \"A_yield_expression_is_only_allowed_in_a_generator_body_1163\", \"A 'yield' expression is only allowed in a generator body.\"),\r\n        Computed_property_names_are_not_allowed_in_enums: diag(1164, DiagnosticCategory.Error, \"Computed_property_names_are_not_allowed_in_enums_1164\", \"Computed property names are not allowed in enums.\"),\r\n        A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1165, DiagnosticCategory.Error, \"A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165\", \"A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type.\"),\r\n        A_computed_property_name_in_a_class_property_declaration_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1166, DiagnosticCategory.Error, \"A_computed_property_name_in_a_class_property_declaration_must_refer_to_an_expression_whose_type_is_a_1166\", \"A computed property name in a class property declaration must refer to an expression whose type is a literal type or a 'unique symbol' type.\"),\r\n        A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1168, DiagnosticCategory.Error, \"A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168\", \"A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type.\"),\r\n        A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1169, DiagnosticCategory.Error, \"A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169\", \"A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type.\"),\r\n        A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1170, DiagnosticCategory.Error, \"A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170\", \"A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type.\"),\r\n        A_comma_expression_is_not_allowed_in_a_computed_property_name: diag(1171, DiagnosticCategory.Error, \"A_comma_expression_is_not_allowed_in_a_computed_property_name_1171\", \"A comma expression is not allowed in a computed property name.\"),\r\n        extends_clause_already_seen: diag(1172, DiagnosticCategory.Error, \"extends_clause_already_seen_1172\", \"'extends' clause already seen.\"),\r\n        extends_clause_must_precede_implements_clause: diag(1173, DiagnosticCategory.Error, \"extends_clause_must_precede_implements_clause_1173\", \"'extends' clause must precede 'implements' clause.\"),\r\n        Classes_can_only_extend_a_single_class: diag(1174, DiagnosticCategory.Error, \"Classes_can_only_extend_a_single_class_1174\", \"Classes can only extend a single class.\"),\r\n        implements_clause_already_seen: diag(1175, DiagnosticCategory.Error, \"implements_clause_already_seen_1175\", \"'implements' clause already seen.\"),\r\n        Interface_declaration_cannot_have_implements_clause: diag(1176, DiagnosticCategory.Error, \"Interface_declaration_cannot_have_implements_clause_1176\", \"Interface declaration cannot have 'implements' clause.\"),\r\n        Binary_digit_expected: diag(1177, DiagnosticCategory.Error, \"Binary_digit_expected_1177\", \"Binary digit expected.\"),\r\n        Octal_digit_expected: diag(1178, DiagnosticCategory.Error, \"Octal_digit_expected_1178\", \"Octal digit expected.\"),\r\n        Unexpected_token_expected: diag(1179, DiagnosticCategory.Error, \"Unexpected_token_expected_1179\", \"Unexpected token. '{' expected.\"),\r\n        Property_destructuring_pattern_expected: diag(1180, DiagnosticCategory.Error, \"Property_destructuring_pattern_expected_1180\", \"Property destructuring pattern expected.\"),\r\n        Array_element_destructuring_pattern_expected: diag(1181, DiagnosticCategory.Error, \"Array_element_destructuring_pattern_expected_1181\", \"Array element destructuring pattern expected.\"),\r\n        A_destructuring_declaration_must_have_an_initializer: diag(1182, DiagnosticCategory.Error, \"A_destructuring_declaration_must_have_an_initializer_1182\", \"A destructuring declaration must have an initializer.\"),\r\n        An_implementation_cannot_be_declared_in_ambient_contexts: diag(1183, DiagnosticCategory.Error, \"An_implementation_cannot_be_declared_in_ambient_contexts_1183\", \"An implementation cannot be declared in ambient contexts.\"),\r\n        Modifiers_cannot_appear_here: diag(1184, DiagnosticCategory.Error, \"Modifiers_cannot_appear_here_1184\", \"Modifiers cannot appear here.\"),\r\n        Merge_conflict_marker_encountered: diag(1185, DiagnosticCategory.Error, \"Merge_conflict_marker_encountered_1185\", \"Merge conflict marker encountered.\"),\r\n        A_rest_element_cannot_have_an_initializer: diag(1186, DiagnosticCategory.Error, \"A_rest_element_cannot_have_an_initializer_1186\", \"A rest element cannot have an initializer.\"),\r\n        A_parameter_property_may_not_be_declared_using_a_binding_pattern: diag(1187, DiagnosticCategory.Error, \"A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187\", \"A parameter property may not be declared using a binding pattern.\"),\r\n        Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: diag(1188, DiagnosticCategory.Error, \"Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188\", \"Only a single variable declaration is allowed in a 'for...of' statement.\"),\r\n        The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: diag(1189, DiagnosticCategory.Error, \"The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189\", \"The variable declaration of a 'for...in' statement cannot have an initializer.\"),\r\n        The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: diag(1190, DiagnosticCategory.Error, \"The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190\", \"The variable declaration of a 'for...of' statement cannot have an initializer.\"),\r\n        An_import_declaration_cannot_have_modifiers: diag(1191, DiagnosticCategory.Error, \"An_import_declaration_cannot_have_modifiers_1191\", \"An import declaration cannot have modifiers.\"),\r\n        Module_0_has_no_default_export: diag(1192, DiagnosticCategory.Error, \"Module_0_has_no_default_export_1192\", \"Module '{0}' has no default export.\"),\r\n        An_export_declaration_cannot_have_modifiers: diag(1193, DiagnosticCategory.Error, \"An_export_declaration_cannot_have_modifiers_1193\", \"An export declaration cannot have modifiers.\"),\r\n        Export_declarations_are_not_permitted_in_a_namespace: diag(1194, DiagnosticCategory.Error, \"Export_declarations_are_not_permitted_in_a_namespace_1194\", \"Export declarations are not permitted in a namespace.\"),\r\n        Catch_clause_variable_cannot_have_a_type_annotation: diag(1196, DiagnosticCategory.Error, \"Catch_clause_variable_cannot_have_a_type_annotation_1196\", \"Catch clause variable cannot have a type annotation.\"),\r\n        Catch_clause_variable_cannot_have_an_initializer: diag(1197, DiagnosticCategory.Error, \"Catch_clause_variable_cannot_have_an_initializer_1197\", \"Catch clause variable cannot have an initializer.\"),\r\n        An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: diag(1198, DiagnosticCategory.Error, \"An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198\", \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\"),\r\n        Unterminated_Unicode_escape_sequence: diag(1199, DiagnosticCategory.Error, \"Unterminated_Unicode_escape_sequence_1199\", \"Unterminated Unicode escape sequence.\"),\r\n        Line_terminator_not_permitted_before_arrow: diag(1200, DiagnosticCategory.Error, \"Line_terminator_not_permitted_before_arrow_1200\", \"Line terminator not permitted before arrow.\"),\r\n        Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: diag(1202, DiagnosticCategory.Error, \"Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202\", \"Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from \\\"mod\\\"', 'import {a} from \\\"mod\\\"', 'import d from \\\"mod\\\"', or another module format instead.\"),\r\n        Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: diag(1203, DiagnosticCategory.Error, \"Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203\", \"Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead.\"),\r\n        Cannot_re_export_a_type_when_the_isolatedModules_flag_is_provided: diag(1205, DiagnosticCategory.Error, \"Cannot_re_export_a_type_when_the_isolatedModules_flag_is_provided_1205\", \"Cannot re-export a type when the '--isolatedModules' flag is provided.\"),\r\n        Decorators_are_not_valid_here: diag(1206, DiagnosticCategory.Error, \"Decorators_are_not_valid_here_1206\", \"Decorators are not valid here.\"),\r\n        Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: diag(1207, DiagnosticCategory.Error, \"Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207\", \"Decorators cannot be applied to multiple get/set accessors of the same name.\"),\r\n        Cannot_compile_namespaces_when_the_isolatedModules_flag_is_provided: diag(1208, DiagnosticCategory.Error, \"Cannot_compile_namespaces_when_the_isolatedModules_flag_is_provided_1208\", \"Cannot compile namespaces when the '--isolatedModules' flag is provided.\"),\r\n        Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided: diag(1209, DiagnosticCategory.Error, \"Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided_1209\", \"Ambient const enums are not allowed when the '--isolatedModules' flag is provided.\"),\r\n        Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode: diag(1210, DiagnosticCategory.Error, \"Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode_1210\", \"Invalid use of '{0}'. Class definitions are automatically in strict mode.\"),\r\n        A_class_declaration_without_the_default_modifier_must_have_a_name: diag(1211, DiagnosticCategory.Error, \"A_class_declaration_without_the_default_modifier_must_have_a_name_1211\", \"A class declaration without the 'default' modifier must have a name.\"),\r\n        Identifier_expected_0_is_a_reserved_word_in_strict_mode: diag(1212, DiagnosticCategory.Error, \"Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212\", \"Identifier expected. '{0}' is a reserved word in strict mode.\"),\r\n        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: diag(1213, DiagnosticCategory.Error, \"Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213\", \"Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.\"),\r\n        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: diag(1214, DiagnosticCategory.Error, \"Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214\", \"Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.\"),\r\n        Invalid_use_of_0_Modules_are_automatically_in_strict_mode: diag(1215, DiagnosticCategory.Error, \"Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215\", \"Invalid use of '{0}'. Modules are automatically in strict mode.\"),\r\n        Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: diag(1216, DiagnosticCategory.Error, \"Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216\", \"Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules.\"),\r\n        Export_assignment_is_not_supported_when_module_flag_is_system: diag(1218, DiagnosticCategory.Error, \"Export_assignment_is_not_supported_when_module_flag_is_system_1218\", \"Export assignment is not supported when '--module' flag is 'system'.\"),\r\n        Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_to_remove_this_warning: diag(1219, DiagnosticCategory.Error, \"Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219\", \"Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning.\"),\r\n        Generators_are_only_available_when_targeting_ECMAScript_2015_or_higher: diag(1220, DiagnosticCategory.Error, \"Generators_are_only_available_when_targeting_ECMAScript_2015_or_higher_1220\", \"Generators are only available when targeting ECMAScript 2015 or higher.\"),\r\n        Generators_are_not_allowed_in_an_ambient_context: diag(1221, DiagnosticCategory.Error, \"Generators_are_not_allowed_in_an_ambient_context_1221\", \"Generators are not allowed in an ambient context.\"),\r\n        An_overload_signature_cannot_be_declared_as_a_generator: diag(1222, DiagnosticCategory.Error, \"An_overload_signature_cannot_be_declared_as_a_generator_1222\", \"An overload signature cannot be declared as a generator.\"),\r\n        _0_tag_already_specified: diag(1223, DiagnosticCategory.Error, \"_0_tag_already_specified_1223\", \"'{0}' tag already specified.\"),\r\n        Signature_0_must_be_a_type_predicate: diag(1224, DiagnosticCategory.Error, \"Signature_0_must_be_a_type_predicate_1224\", \"Signature '{0}' must be a type predicate.\"),\r\n        Cannot_find_parameter_0: diag(1225, DiagnosticCategory.Error, \"Cannot_find_parameter_0_1225\", \"Cannot find parameter '{0}'.\"),\r\n        Type_predicate_0_is_not_assignable_to_1: diag(1226, DiagnosticCategory.Error, \"Type_predicate_0_is_not_assignable_to_1_1226\", \"Type predicate '{0}' is not assignable to '{1}'.\"),\r\n        Parameter_0_is_not_in_the_same_position_as_parameter_1: diag(1227, DiagnosticCategory.Error, \"Parameter_0_is_not_in_the_same_position_as_parameter_1_1227\", \"Parameter '{0}' is not in the same position as parameter '{1}'.\"),\r\n        A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: diag(1228, DiagnosticCategory.Error, \"A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228\", \"A type predicate is only allowed in return type position for functions and methods.\"),\r\n        A_type_predicate_cannot_reference_a_rest_parameter: diag(1229, DiagnosticCategory.Error, \"A_type_predicate_cannot_reference_a_rest_parameter_1229\", \"A type predicate cannot reference a rest parameter.\"),\r\n        A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: diag(1230, DiagnosticCategory.Error, \"A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230\", \"A type predicate cannot reference element '{0}' in a binding pattern.\"),\r\n        An_export_assignment_can_only_be_used_in_a_module: diag(1231, DiagnosticCategory.Error, \"An_export_assignment_can_only_be_used_in_a_module_1231\", \"An export assignment can only be used in a module.\"),\r\n        An_import_declaration_can_only_be_used_in_a_namespace_or_module: diag(1232, DiagnosticCategory.Error, \"An_import_declaration_can_only_be_used_in_a_namespace_or_module_1232\", \"An import declaration can only be used in a namespace or module.\"),\r\n        An_export_declaration_can_only_be_used_in_a_module: diag(1233, DiagnosticCategory.Error, \"An_export_declaration_can_only_be_used_in_a_module_1233\", \"An export declaration can only be used in a module.\"),\r\n        An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: diag(1234, DiagnosticCategory.Error, \"An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234\", \"An ambient module declaration is only allowed at the top level in a file.\"),\r\n        A_namespace_declaration_is_only_allowed_in_a_namespace_or_module: diag(1235, DiagnosticCategory.Error, \"A_namespace_declaration_is_only_allowed_in_a_namespace_or_module_1235\", \"A namespace declaration is only allowed in a namespace or module.\"),\r\n        The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: diag(1236, DiagnosticCategory.Error, \"The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236\", \"The return type of a property decorator function must be either 'void' or 'any'.\"),\r\n        The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: diag(1237, DiagnosticCategory.Error, \"The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237\", \"The return type of a parameter decorator function must be either 'void' or 'any'.\"),\r\n        Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: diag(1238, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238\", \"Unable to resolve signature of class decorator when called as an expression.\"),\r\n        Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: diag(1239, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239\", \"Unable to resolve signature of parameter decorator when called as an expression.\"),\r\n        Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: diag(1240, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240\", \"Unable to resolve signature of property decorator when called as an expression.\"),\r\n        Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: diag(1241, DiagnosticCategory.Error, \"Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241\", \"Unable to resolve signature of method decorator when called as an expression.\"),\r\n        abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: diag(1242, DiagnosticCategory.Error, \"abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242\", \"'abstract' modifier can only appear on a class, method, or property declaration.\"),\r\n        _0_modifier_cannot_be_used_with_1_modifier: diag(1243, DiagnosticCategory.Error, \"_0_modifier_cannot_be_used_with_1_modifier_1243\", \"'{0}' modifier cannot be used with '{1}' modifier.\"),\r\n        Abstract_methods_can_only_appear_within_an_abstract_class: diag(1244, DiagnosticCategory.Error, \"Abstract_methods_can_only_appear_within_an_abstract_class_1244\", \"Abstract methods can only appear within an abstract class.\"),\r\n        Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: diag(1245, DiagnosticCategory.Error, \"Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245\", \"Method '{0}' cannot have an implementation because it is marked abstract.\"),\r\n        An_interface_property_cannot_have_an_initializer: diag(1246, DiagnosticCategory.Error, \"An_interface_property_cannot_have_an_initializer_1246\", \"An interface property cannot have an initializer.\"),\r\n        A_type_literal_property_cannot_have_an_initializer: diag(1247, DiagnosticCategory.Error, \"A_type_literal_property_cannot_have_an_initializer_1247\", \"A type literal property cannot have an initializer.\"),\r\n        A_class_member_cannot_have_the_0_keyword: diag(1248, DiagnosticCategory.Error, \"A_class_member_cannot_have_the_0_keyword_1248\", \"A class member cannot have the '{0}' keyword.\"),\r\n        A_decorator_can_only_decorate_a_method_implementation_not_an_overload: diag(1249, DiagnosticCategory.Error, \"A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249\", \"A decorator can only decorate a method implementation, not an overload.\"),\r\n        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5: diag(1250, DiagnosticCategory.Error, \"Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250\", \"Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'.\"),\r\n        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode: diag(1251, DiagnosticCategory.Error, \"Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251\", \"Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode.\"),\r\n        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode: diag(1252, DiagnosticCategory.Error, \"Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252\", \"Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode.\"),\r\n        _0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag: diag(1253, DiagnosticCategory.Error, \"_0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag_1253\", \"'{0}' tag cannot be used independently as a top level JSDoc tag.\"),\r\n        A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal: diag(1254, DiagnosticCategory.Error, \"A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_1254\", \"A 'const' initializer in an ambient context must be a string or numeric literal.\"),\r\n        A_definite_assignment_assertion_is_not_permitted_in_this_context: diag(1255, DiagnosticCategory.Error, \"A_definite_assignment_assertion_is_not_permitted_in_this_context_1255\", \"A definite assignment assertion '!' is not permitted in this context.\"),\r\n        with_statements_are_not_allowed_in_an_async_function_block: diag(1300, DiagnosticCategory.Error, \"with_statements_are_not_allowed_in_an_async_function_block_1300\", \"'with' statements are not allowed in an async function block.\"),\r\n        await_expression_is_only_allowed_within_an_async_function: diag(1308, DiagnosticCategory.Error, \"await_expression_is_only_allowed_within_an_async_function_1308\", \"'await' expression is only allowed within an async function.\"),\r\n        can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment: diag(1312, DiagnosticCategory.Error, \"can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment_1312\", \"'=' can only be used in an object literal property inside a destructuring assignment.\"),\r\n        The_body_of_an_if_statement_cannot_be_the_empty_statement: diag(1313, DiagnosticCategory.Error, \"The_body_of_an_if_statement_cannot_be_the_empty_statement_1313\", \"The body of an 'if' statement cannot be the empty statement.\"),\r\n        Global_module_exports_may_only_appear_in_module_files: diag(1314, DiagnosticCategory.Error, \"Global_module_exports_may_only_appear_in_module_files_1314\", \"Global module exports may only appear in module files.\"),\r\n        Global_module_exports_may_only_appear_in_declaration_files: diag(1315, DiagnosticCategory.Error, \"Global_module_exports_may_only_appear_in_declaration_files_1315\", \"Global module exports may only appear in declaration files.\"),\r\n        Global_module_exports_may_only_appear_at_top_level: diag(1316, DiagnosticCategory.Error, \"Global_module_exports_may_only_appear_at_top_level_1316\", \"Global module exports may only appear at top level.\"),\r\n        A_parameter_property_cannot_be_declared_using_a_rest_parameter: diag(1317, DiagnosticCategory.Error, \"A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317\", \"A parameter property cannot be declared using a rest parameter.\"),\r\n        An_abstract_accessor_cannot_have_an_implementation: diag(1318, DiagnosticCategory.Error, \"An_abstract_accessor_cannot_have_an_implementation_1318\", \"An abstract accessor cannot have an implementation.\"),\r\n        A_default_export_can_only_be_used_in_an_ECMAScript_style_module: diag(1319, DiagnosticCategory.Error, \"A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319\", \"A default export can only be used in an ECMAScript-style module.\"),\r\n        Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1320, DiagnosticCategory.Error, \"Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320\", \"Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1321, DiagnosticCategory.Error, \"Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321\", \"Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1322, DiagnosticCategory.Error, \"Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322\", \"Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member.\"),\r\n        Dynamic_import_cannot_be_used_when_targeting_ECMAScript_2015_modules: diag(1323, DiagnosticCategory.Error, \"Dynamic_import_cannot_be_used_when_targeting_ECMAScript_2015_modules_1323\", \"Dynamic import cannot be used when targeting ECMAScript 2015 modules.\"),\r\n        Dynamic_import_must_have_one_specifier_as_an_argument: diag(1324, DiagnosticCategory.Error, \"Dynamic_import_must_have_one_specifier_as_an_argument_1324\", \"Dynamic import must have one specifier as an argument.\"),\r\n        Specifier_of_dynamic_import_cannot_be_spread_element: diag(1325, DiagnosticCategory.Error, \"Specifier_of_dynamic_import_cannot_be_spread_element_1325\", \"Specifier of dynamic import cannot be spread element.\"),\r\n        Dynamic_import_cannot_have_type_arguments: diag(1326, DiagnosticCategory.Error, \"Dynamic_import_cannot_have_type_arguments_1326\", \"Dynamic import cannot have type arguments\"),\r\n        String_literal_with_double_quotes_expected: diag(1327, DiagnosticCategory.Error, \"String_literal_with_double_quotes_expected_1327\", \"String literal with double quotes expected.\"),\r\n        Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: diag(1328, DiagnosticCategory.Error, \"Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328\", \"Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal.\"),\r\n        _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: diag(1329, DiagnosticCategory.Error, \"_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329\", \"'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?\"),\r\n        A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly: diag(1330, DiagnosticCategory.Error, \"A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330\", \"A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'.\"),\r\n        A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly: diag(1331, DiagnosticCategory.Error, \"A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331\", \"A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'.\"),\r\n        A_variable_whose_type_is_a_unique_symbol_type_must_be_const: diag(1332, DiagnosticCategory.Error, \"A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332\", \"A variable whose type is a 'unique symbol' type must be 'const'.\"),\r\n        unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name: diag(1333, DiagnosticCategory.Error, \"unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333\", \"'unique symbol' types may not be used on a variable declaration with a binding name.\"),\r\n        unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement: diag(1334, DiagnosticCategory.Error, \"unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334\", \"'unique symbol' types are only allowed on variables in a variable statement.\"),\r\n        unique_symbol_types_are_not_allowed_here: diag(1335, DiagnosticCategory.Error, \"unique_symbol_types_are_not_allowed_here_1335\", \"'unique symbol' types are not allowed here.\"),\r\n        An_index_signature_parameter_type_cannot_be_a_type_alias_Consider_writing_0_Colon_1_Colon_2_instead: diag(1336, DiagnosticCategory.Error, \"An_index_signature_parameter_type_cannot_be_a_type_alias_Consider_writing_0_Colon_1_Colon_2_instead_1336\", \"An index signature parameter type cannot be a type alias. Consider writing '[{0}: {1}]: {2}' instead.\"),\r\n        An_index_signature_parameter_type_cannot_be_a_union_type_Consider_using_a_mapped_object_type_instead: diag(1337, DiagnosticCategory.Error, \"An_index_signature_parameter_type_cannot_be_a_union_type_Consider_using_a_mapped_object_type_instead_1337\", \"An index signature parameter type cannot be a union type. Consider using a mapped object type instead.\"),\r\n        infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type: diag(1338, DiagnosticCategory.Error, \"infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338\", \"'infer' declarations are only permitted in the 'extends' clause of a conditional type.\"),\r\n        Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here: diag(1339, DiagnosticCategory.Error, \"Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339\", \"Module '{0}' does not refer to a value, but is used as a value here.\"),\r\n        Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here: diag(1340, DiagnosticCategory.Error, \"Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_1340\", \"Module '{0}' does not refer to a type, but is used as a type here.\"),\r\n        Type_arguments_cannot_be_used_here: diag(1342, DiagnosticCategory.Error, \"Type_arguments_cannot_be_used_here_1342\", \"Type arguments cannot be used here.\"),\r\n        The_import_meta_meta_property_is_only_allowed_using_ESNext_for_the_target_and_module_compiler_options: diag(1343, DiagnosticCategory.Error, \"The_import_meta_meta_property_is_only_allowed_using_ESNext_for_the_target_and_module_compiler_option_1343\", \"The 'import.meta' meta-property is only allowed using 'ESNext' for the 'target' and 'module' compiler options.\"),\r\n        Duplicate_identifier_0: diag(2300, DiagnosticCategory.Error, \"Duplicate_identifier_0_2300\", \"Duplicate identifier '{0}'.\"),\r\n        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: diag(2301, DiagnosticCategory.Error, \"Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301\", \"Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.\"),\r\n        Static_members_cannot_reference_class_type_parameters: diag(2302, DiagnosticCategory.Error, \"Static_members_cannot_reference_class_type_parameters_2302\", \"Static members cannot reference class type parameters.\"),\r\n        Circular_definition_of_import_alias_0: diag(2303, DiagnosticCategory.Error, \"Circular_definition_of_import_alias_0_2303\", \"Circular definition of import alias '{0}'.\"),\r\n        Cannot_find_name_0: diag(2304, DiagnosticCategory.Error, \"Cannot_find_name_0_2304\", \"Cannot find name '{0}'.\"),\r\n        Module_0_has_no_exported_member_1: diag(2305, DiagnosticCategory.Error, \"Module_0_has_no_exported_member_1_2305\", \"Module '{0}' has no exported member '{1}'.\"),\r\n        File_0_is_not_a_module: diag(2306, DiagnosticCategory.Error, \"File_0_is_not_a_module_2306\", \"File '{0}' is not a module.\"),\r\n        Cannot_find_module_0: diag(2307, DiagnosticCategory.Error, \"Cannot_find_module_0_2307\", \"Cannot find module '{0}'.\"),\r\n        Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: diag(2308, DiagnosticCategory.Error, \"Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308\", \"Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity.\"),\r\n        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: diag(2309, DiagnosticCategory.Error, \"An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309\", \"An export assignment cannot be used in a module with other exported elements.\"),\r\n        Type_0_recursively_references_itself_as_a_base_type: diag(2310, DiagnosticCategory.Error, \"Type_0_recursively_references_itself_as_a_base_type_2310\", \"Type '{0}' recursively references itself as a base type.\"),\r\n        A_class_may_only_extend_another_class: diag(2311, DiagnosticCategory.Error, \"A_class_may_only_extend_another_class_2311\", \"A class may only extend another class.\"),\r\n        An_interface_may_only_extend_a_class_or_another_interface: diag(2312, DiagnosticCategory.Error, \"An_interface_may_only_extend_a_class_or_another_interface_2312\", \"An interface may only extend a class or another interface.\"),\r\n        Type_parameter_0_has_a_circular_constraint: diag(2313, DiagnosticCategory.Error, \"Type_parameter_0_has_a_circular_constraint_2313\", \"Type parameter '{0}' has a circular constraint.\"),\r\n        Generic_type_0_requires_1_type_argument_s: diag(2314, DiagnosticCategory.Error, \"Generic_type_0_requires_1_type_argument_s_2314\", \"Generic type '{0}' requires {1} type argument(s).\"),\r\n        Type_0_is_not_generic: diag(2315, DiagnosticCategory.Error, \"Type_0_is_not_generic_2315\", \"Type '{0}' is not generic.\"),\r\n        Global_type_0_must_be_a_class_or_interface_type: diag(2316, DiagnosticCategory.Error, \"Global_type_0_must_be_a_class_or_interface_type_2316\", \"Global type '{0}' must be a class or interface type.\"),\r\n        Global_type_0_must_have_1_type_parameter_s: diag(2317, DiagnosticCategory.Error, \"Global_type_0_must_have_1_type_parameter_s_2317\", \"Global type '{0}' must have {1} type parameter(s).\"),\r\n        Cannot_find_global_type_0: diag(2318, DiagnosticCategory.Error, \"Cannot_find_global_type_0_2318\", \"Cannot find global type '{0}'.\"),\r\n        Named_property_0_of_types_1_and_2_are_not_identical: diag(2319, DiagnosticCategory.Error, \"Named_property_0_of_types_1_and_2_are_not_identical_2319\", \"Named property '{0}' of types '{1}' and '{2}' are not identical.\"),\r\n        Interface_0_cannot_simultaneously_extend_types_1_and_2: diag(2320, DiagnosticCategory.Error, \"Interface_0_cannot_simultaneously_extend_types_1_and_2_2320\", \"Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.\"),\r\n        Excessive_stack_depth_comparing_types_0_and_1: diag(2321, DiagnosticCategory.Error, \"Excessive_stack_depth_comparing_types_0_and_1_2321\", \"Excessive stack depth comparing types '{0}' and '{1}'.\"),\r\n        Type_0_is_not_assignable_to_type_1: diag(2322, DiagnosticCategory.Error, \"Type_0_is_not_assignable_to_type_1_2322\", \"Type '{0}' is not assignable to type '{1}'.\"),\r\n        Cannot_redeclare_exported_variable_0: diag(2323, DiagnosticCategory.Error, \"Cannot_redeclare_exported_variable_0_2323\", \"Cannot redeclare exported variable '{0}'.\"),\r\n        Property_0_is_missing_in_type_1: diag(2324, DiagnosticCategory.Error, \"Property_0_is_missing_in_type_1_2324\", \"Property '{0}' is missing in type '{1}'.\"),\r\n        Property_0_is_private_in_type_1_but_not_in_type_2: diag(2325, DiagnosticCategory.Error, \"Property_0_is_private_in_type_1_but_not_in_type_2_2325\", \"Property '{0}' is private in type '{1}' but not in type '{2}'.\"),\r\n        Types_of_property_0_are_incompatible: diag(2326, DiagnosticCategory.Error, \"Types_of_property_0_are_incompatible_2326\", \"Types of property '{0}' are incompatible.\"),\r\n        Property_0_is_optional_in_type_1_but_required_in_type_2: diag(2327, DiagnosticCategory.Error, \"Property_0_is_optional_in_type_1_but_required_in_type_2_2327\", \"Property '{0}' is optional in type '{1}' but required in type '{2}'.\"),\r\n        Types_of_parameters_0_and_1_are_incompatible: diag(2328, DiagnosticCategory.Error, \"Types_of_parameters_0_and_1_are_incompatible_2328\", \"Types of parameters '{0}' and '{1}' are incompatible.\"),\r\n        Index_signature_is_missing_in_type_0: diag(2329, DiagnosticCategory.Error, \"Index_signature_is_missing_in_type_0_2329\", \"Index signature is missing in type '{0}'.\"),\r\n        Index_signatures_are_incompatible: diag(2330, DiagnosticCategory.Error, \"Index_signatures_are_incompatible_2330\", \"Index signatures are incompatible.\"),\r\n        this_cannot_be_referenced_in_a_module_or_namespace_body: diag(2331, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_a_module_or_namespace_body_2331\", \"'this' cannot be referenced in a module or namespace body.\"),\r\n        this_cannot_be_referenced_in_current_location: diag(2332, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_current_location_2332\", \"'this' cannot be referenced in current location.\"),\r\n        this_cannot_be_referenced_in_constructor_arguments: diag(2333, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_constructor_arguments_2333\", \"'this' cannot be referenced in constructor arguments.\"),\r\n        this_cannot_be_referenced_in_a_static_property_initializer: diag(2334, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_a_static_property_initializer_2334\", \"'this' cannot be referenced in a static property initializer.\"),\r\n        super_can_only_be_referenced_in_a_derived_class: diag(2335, DiagnosticCategory.Error, \"super_can_only_be_referenced_in_a_derived_class_2335\", \"'super' can only be referenced in a derived class.\"),\r\n        super_cannot_be_referenced_in_constructor_arguments: diag(2336, DiagnosticCategory.Error, \"super_cannot_be_referenced_in_constructor_arguments_2336\", \"'super' cannot be referenced in constructor arguments.\"),\r\n        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: diag(2337, DiagnosticCategory.Error, \"Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337\", \"Super calls are not permitted outside constructors or in nested functions inside constructors.\"),\r\n        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: diag(2338, DiagnosticCategory.Error, \"super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338\", \"'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.\"),\r\n        Property_0_does_not_exist_on_type_1: diag(2339, DiagnosticCategory.Error, \"Property_0_does_not_exist_on_type_1_2339\", \"Property '{0}' does not exist on type '{1}'.\"),\r\n        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: diag(2340, DiagnosticCategory.Error, \"Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340\", \"Only public and protected methods of the base class are accessible via the 'super' keyword.\"),\r\n        Property_0_is_private_and_only_accessible_within_class_1: diag(2341, DiagnosticCategory.Error, \"Property_0_is_private_and_only_accessible_within_class_1_2341\", \"Property '{0}' is private and only accessible within class '{1}'.\"),\r\n        An_index_expression_argument_must_be_of_type_string_number_symbol_or_any: diag(2342, DiagnosticCategory.Error, \"An_index_expression_argument_must_be_of_type_string_number_symbol_or_any_2342\", \"An index expression argument must be of type 'string', 'number', 'symbol', or 'any'.\"),\r\n        This_syntax_requires_an_imported_helper_named_1_but_module_0_has_no_exported_member_1: diag(2343, DiagnosticCategory.Error, \"This_syntax_requires_an_imported_helper_named_1_but_module_0_has_no_exported_member_1_2343\", \"This syntax requires an imported helper named '{1}', but module '{0}' has no exported member '{1}'.\"),\r\n        Type_0_does_not_satisfy_the_constraint_1: diag(2344, DiagnosticCategory.Error, \"Type_0_does_not_satisfy_the_constraint_1_2344\", \"Type '{0}' does not satisfy the constraint '{1}'.\"),\r\n        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: diag(2345, DiagnosticCategory.Error, \"Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345\", \"Argument of type '{0}' is not assignable to parameter of type '{1}'.\"),\r\n        Call_target_does_not_contain_any_signatures: diag(2346, DiagnosticCategory.Error, \"Call_target_does_not_contain_any_signatures_2346\", \"Call target does not contain any signatures.\"),\r\n        Untyped_function_calls_may_not_accept_type_arguments: diag(2347, DiagnosticCategory.Error, \"Untyped_function_calls_may_not_accept_type_arguments_2347\", \"Untyped function calls may not accept type arguments.\"),\r\n        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: diag(2348, DiagnosticCategory.Error, \"Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348\", \"Value of type '{0}' is not callable. Did you mean to include 'new'?\"),\r\n        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures: diag(2349, DiagnosticCategory.Error, \"Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatur_2349\", \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\"),\r\n        Only_a_void_function_can_be_called_with_the_new_keyword: diag(2350, DiagnosticCategory.Error, \"Only_a_void_function_can_be_called_with_the_new_keyword_2350\", \"Only a void function can be called with the 'new' keyword.\"),\r\n        Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature: diag(2351, DiagnosticCategory.Error, \"Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature_2351\", \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\"),\r\n        Type_0_cannot_be_converted_to_type_1: diag(2352, DiagnosticCategory.Error, \"Type_0_cannot_be_converted_to_type_1_2352\", \"Type '{0}' cannot be converted to type '{1}'.\"),\r\n        Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: diag(2353, DiagnosticCategory.Error, \"Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353\", \"Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.\"),\r\n        This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: diag(2354, DiagnosticCategory.Error, \"This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354\", \"This syntax requires an imported helper but module '{0}' cannot be found.\"),\r\n        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value: diag(2355, DiagnosticCategory.Error, \"A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355\", \"A function whose declared type is neither 'void' nor 'any' must return a value.\"),\r\n        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: diag(2356, DiagnosticCategory.Error, \"An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type_2356\", \"An arithmetic operand must be of type 'any', 'number' or an enum type.\"),\r\n        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: diag(2357, DiagnosticCategory.Error, \"The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357\", \"The operand of an increment or decrement operator must be a variable or a property access.\"),\r\n        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: diag(2358, DiagnosticCategory.Error, \"The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358\", \"The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.\"),\r\n        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: diag(2359, DiagnosticCategory.Error, \"The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359\", \"The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.\"),\r\n        The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol: diag(2360, DiagnosticCategory.Error, \"The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol_2360\", \"The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.\"),\r\n        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: diag(2361, DiagnosticCategory.Error, \"The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter_2361\", \"The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.\"),\r\n        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: diag(2362, DiagnosticCategory.Error, \"The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2362\", \"The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\"),\r\n        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: diag(2363, DiagnosticCategory.Error, \"The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2363\", \"The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\"),\r\n        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: diag(2364, DiagnosticCategory.Error, \"The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364\", \"The left-hand side of an assignment expression must be a variable or a property access.\"),\r\n        Operator_0_cannot_be_applied_to_types_1_and_2: diag(2365, DiagnosticCategory.Error, \"Operator_0_cannot_be_applied_to_types_1_and_2_2365\", \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\"),\r\n        Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: diag(2366, DiagnosticCategory.Error, \"Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366\", \"Function lacks ending return statement and return type does not include 'undefined'.\"),\r\n        Type_parameter_name_cannot_be_0: diag(2368, DiagnosticCategory.Error, \"Type_parameter_name_cannot_be_0_2368\", \"Type parameter name cannot be '{0}'.\"),\r\n        A_parameter_property_is_only_allowed_in_a_constructor_implementation: diag(2369, DiagnosticCategory.Error, \"A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369\", \"A parameter property is only allowed in a constructor implementation.\"),\r\n        A_rest_parameter_must_be_of_an_array_type: diag(2370, DiagnosticCategory.Error, \"A_rest_parameter_must_be_of_an_array_type_2370\", \"A rest parameter must be of an array type.\"),\r\n        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: diag(2371, DiagnosticCategory.Error, \"A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371\", \"A parameter initializer is only allowed in a function or constructor implementation.\"),\r\n        Parameter_0_cannot_be_referenced_in_its_initializer: diag(2372, DiagnosticCategory.Error, \"Parameter_0_cannot_be_referenced_in_its_initializer_2372\", \"Parameter '{0}' cannot be referenced in its initializer.\"),\r\n        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: diag(2373, DiagnosticCategory.Error, \"Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it_2373\", \"Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.\"),\r\n        Duplicate_string_index_signature: diag(2374, DiagnosticCategory.Error, \"Duplicate_string_index_signature_2374\", \"Duplicate string index signature.\"),\r\n        Duplicate_number_index_signature: diag(2375, DiagnosticCategory.Error, \"Duplicate_number_index_signature_2375\", \"Duplicate number index signature.\"),\r\n        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: diag(2376, DiagnosticCategory.Error, \"A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_proper_2376\", \"A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.\"),\r\n        Constructors_for_derived_classes_must_contain_a_super_call: diag(2377, DiagnosticCategory.Error, \"Constructors_for_derived_classes_must_contain_a_super_call_2377\", \"Constructors for derived classes must contain a 'super' call.\"),\r\n        A_get_accessor_must_return_a_value: diag(2378, DiagnosticCategory.Error, \"A_get_accessor_must_return_a_value_2378\", \"A 'get' accessor must return a value.\"),\r\n        Getter_and_setter_accessors_do_not_agree_in_visibility: diag(2379, DiagnosticCategory.Error, \"Getter_and_setter_accessors_do_not_agree_in_visibility_2379\", \"Getter and setter accessors do not agree in visibility.\"),\r\n        get_and_set_accessor_must_have_the_same_type: diag(2380, DiagnosticCategory.Error, \"get_and_set_accessor_must_have_the_same_type_2380\", \"'get' and 'set' accessor must have the same type.\"),\r\n        A_signature_with_an_implementation_cannot_use_a_string_literal_type: diag(2381, DiagnosticCategory.Error, \"A_signature_with_an_implementation_cannot_use_a_string_literal_type_2381\", \"A signature with an implementation cannot use a string literal type.\"),\r\n        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: diag(2382, DiagnosticCategory.Error, \"Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature_2382\", \"Specialized overload signature is not assignable to any non-specialized signature.\"),\r\n        Overload_signatures_must_all_be_exported_or_non_exported: diag(2383, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_exported_or_non_exported_2383\", \"Overload signatures must all be exported or non-exported.\"),\r\n        Overload_signatures_must_all_be_ambient_or_non_ambient: diag(2384, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_ambient_or_non_ambient_2384\", \"Overload signatures must all be ambient or non-ambient.\"),\r\n        Overload_signatures_must_all_be_public_private_or_protected: diag(2385, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_public_private_or_protected_2385\", \"Overload signatures must all be public, private or protected.\"),\r\n        Overload_signatures_must_all_be_optional_or_required: diag(2386, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_optional_or_required_2386\", \"Overload signatures must all be optional or required.\"),\r\n        Function_overload_must_be_static: diag(2387, DiagnosticCategory.Error, \"Function_overload_must_be_static_2387\", \"Function overload must be static.\"),\r\n        Function_overload_must_not_be_static: diag(2388, DiagnosticCategory.Error, \"Function_overload_must_not_be_static_2388\", \"Function overload must not be static.\"),\r\n        Function_implementation_name_must_be_0: diag(2389, DiagnosticCategory.Error, \"Function_implementation_name_must_be_0_2389\", \"Function implementation name must be '{0}'.\"),\r\n        Constructor_implementation_is_missing: diag(2390, DiagnosticCategory.Error, \"Constructor_implementation_is_missing_2390\", \"Constructor implementation is missing.\"),\r\n        Function_implementation_is_missing_or_not_immediately_following_the_declaration: diag(2391, DiagnosticCategory.Error, \"Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391\", \"Function implementation is missing or not immediately following the declaration.\"),\r\n        Multiple_constructor_implementations_are_not_allowed: diag(2392, DiagnosticCategory.Error, \"Multiple_constructor_implementations_are_not_allowed_2392\", \"Multiple constructor implementations are not allowed.\"),\r\n        Duplicate_function_implementation: diag(2393, DiagnosticCategory.Error, \"Duplicate_function_implementation_2393\", \"Duplicate function implementation.\"),\r\n        Overload_signature_is_not_compatible_with_function_implementation: diag(2394, DiagnosticCategory.Error, \"Overload_signature_is_not_compatible_with_function_implementation_2394\", \"Overload signature is not compatible with function implementation.\"),\r\n        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: diag(2395, DiagnosticCategory.Error, \"Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395\", \"Individual declarations in merged declaration '{0}' must be all exported or all local.\"),\r\n        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: diag(2396, DiagnosticCategory.Error, \"Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396\", \"Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.\"),\r\n        Declaration_name_conflicts_with_built_in_global_identifier_0: diag(2397, DiagnosticCategory.Error, \"Declaration_name_conflicts_with_built_in_global_identifier_0_2397\", \"Declaration name conflicts with built-in global identifier '{0}'.\"),\r\n        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: diag(2399, DiagnosticCategory.Error, \"Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399\", \"Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.\"),\r\n        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: diag(2400, DiagnosticCategory.Error, \"Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400\", \"Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.\"),\r\n        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: diag(2401, DiagnosticCategory.Error, \"Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference_2401\", \"Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.\"),\r\n        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: diag(2402, DiagnosticCategory.Error, \"Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402\", \"Expression resolves to '_super' that compiler uses to capture base class reference.\"),\r\n        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: diag(2403, DiagnosticCategory.Error, \"Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403\", \"Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.\"),\r\n        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: diag(2404, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404\", \"The left-hand side of a 'for...in' statement cannot use a type annotation.\"),\r\n        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: diag(2405, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405\", \"The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.\"),\r\n        The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: diag(2406, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406\", \"The left-hand side of a 'for...in' statement must be a variable or a property access.\"),\r\n        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0: diag(2407, DiagnosticCategory.Error, \"The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407\", \"The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'.\"),\r\n        Setters_cannot_return_a_value: diag(2408, DiagnosticCategory.Error, \"Setters_cannot_return_a_value_2408\", \"Setters cannot return a value.\"),\r\n        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: diag(2409, DiagnosticCategory.Error, \"Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409\", \"Return type of constructor signature must be assignable to the instance type of the class.\"),\r\n        The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: diag(2410, DiagnosticCategory.Error, \"The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410\", \"The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'.\"),\r\n        Property_0_of_type_1_is_not_assignable_to_string_index_type_2: diag(2411, DiagnosticCategory.Error, \"Property_0_of_type_1_is_not_assignable_to_string_index_type_2_2411\", \"Property '{0}' of type '{1}' is not assignable to string index type '{2}'.\"),\r\n        Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2: diag(2412, DiagnosticCategory.Error, \"Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2_2412\", \"Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.\"),\r\n        Numeric_index_type_0_is_not_assignable_to_string_index_type_1: diag(2413, DiagnosticCategory.Error, \"Numeric_index_type_0_is_not_assignable_to_string_index_type_1_2413\", \"Numeric index type '{0}' is not assignable to string index type '{1}'.\"),\r\n        Class_name_cannot_be_0: diag(2414, DiagnosticCategory.Error, \"Class_name_cannot_be_0_2414\", \"Class name cannot be '{0}'.\"),\r\n        Class_0_incorrectly_extends_base_class_1: diag(2415, DiagnosticCategory.Error, \"Class_0_incorrectly_extends_base_class_1_2415\", \"Class '{0}' incorrectly extends base class '{1}'.\"),\r\n        Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2: diag(2416, DiagnosticCategory.Error, \"Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416\", \"Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.\"),\r\n        Class_static_side_0_incorrectly_extends_base_class_static_side_1: diag(2417, DiagnosticCategory.Error, \"Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417\", \"Class static side '{0}' incorrectly extends base class static side '{1}'.\"),\r\n        Class_0_incorrectly_implements_interface_1: diag(2420, DiagnosticCategory.Error, \"Class_0_incorrectly_implements_interface_1_2420\", \"Class '{0}' incorrectly implements interface '{1}'.\"),\r\n        A_class_may_only_implement_another_class_or_interface: diag(2422, DiagnosticCategory.Error, \"A_class_may_only_implement_another_class_or_interface_2422\", \"A class may only implement another class or interface.\"),\r\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: diag(2423, DiagnosticCategory.Error, \"Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423\", \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.\"),\r\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: diag(2424, DiagnosticCategory.Error, \"Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_proper_2424\", \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.\"),\r\n        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2425, DiagnosticCategory.Error, \"Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425\", \"Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.\"),\r\n        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2426, DiagnosticCategory.Error, \"Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426\", \"Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.\"),\r\n        Interface_name_cannot_be_0: diag(2427, DiagnosticCategory.Error, \"Interface_name_cannot_be_0_2427\", \"Interface name cannot be '{0}'.\"),\r\n        All_declarations_of_0_must_have_identical_type_parameters: diag(2428, DiagnosticCategory.Error, \"All_declarations_of_0_must_have_identical_type_parameters_2428\", \"All declarations of '{0}' must have identical type parameters.\"),\r\n        Interface_0_incorrectly_extends_interface_1: diag(2430, DiagnosticCategory.Error, \"Interface_0_incorrectly_extends_interface_1_2430\", \"Interface '{0}' incorrectly extends interface '{1}'.\"),\r\n        Enum_name_cannot_be_0: diag(2431, DiagnosticCategory.Error, \"Enum_name_cannot_be_0_2431\", \"Enum name cannot be '{0}'.\"),\r\n        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: diag(2432, DiagnosticCategory.Error, \"In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432\", \"In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.\"),\r\n        A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: diag(2433, DiagnosticCategory.Error, \"A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433\", \"A namespace declaration cannot be in a different file from a class or function with which it is merged.\"),\r\n        A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: diag(2434, DiagnosticCategory.Error, \"A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434\", \"A namespace declaration cannot be located prior to a class or function with which it is merged.\"),\r\n        Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: diag(2435, DiagnosticCategory.Error, \"Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435\", \"Ambient modules cannot be nested in other modules or namespaces.\"),\r\n        Ambient_module_declaration_cannot_specify_relative_module_name: diag(2436, DiagnosticCategory.Error, \"Ambient_module_declaration_cannot_specify_relative_module_name_2436\", \"Ambient module declaration cannot specify relative module name.\"),\r\n        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: diag(2437, DiagnosticCategory.Error, \"Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437\", \"Module '{0}' is hidden by a local declaration with the same name.\"),\r\n        Import_name_cannot_be_0: diag(2438, DiagnosticCategory.Error, \"Import_name_cannot_be_0_2438\", \"Import name cannot be '{0}'.\"),\r\n        Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: diag(2439, DiagnosticCategory.Error, \"Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439\", \"Import or export declaration in an ambient module declaration cannot reference module through relative module name.\"),\r\n        Import_declaration_conflicts_with_local_declaration_of_0: diag(2440, DiagnosticCategory.Error, \"Import_declaration_conflicts_with_local_declaration_of_0_2440\", \"Import declaration conflicts with local declaration of '{0}'.\"),\r\n        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: diag(2441, DiagnosticCategory.Error, \"Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441\", \"Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.\"),\r\n        Types_have_separate_declarations_of_a_private_property_0: diag(2442, DiagnosticCategory.Error, \"Types_have_separate_declarations_of_a_private_property_0_2442\", \"Types have separate declarations of a private property '{0}'.\"),\r\n        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: diag(2443, DiagnosticCategory.Error, \"Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443\", \"Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.\"),\r\n        Property_0_is_protected_in_type_1_but_public_in_type_2: diag(2444, DiagnosticCategory.Error, \"Property_0_is_protected_in_type_1_but_public_in_type_2_2444\", \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\"),\r\n        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: diag(2445, DiagnosticCategory.Error, \"Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445\", \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\"),\r\n        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1: diag(2446, DiagnosticCategory.Error, \"Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_2446\", \"Property '{0}' is protected and only accessible through an instance of class '{1}'.\"),\r\n        The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: diag(2447, DiagnosticCategory.Error, \"The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447\", \"The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.\"),\r\n        Block_scoped_variable_0_used_before_its_declaration: diag(2448, DiagnosticCategory.Error, \"Block_scoped_variable_0_used_before_its_declaration_2448\", \"Block-scoped variable '{0}' used before its declaration.\"),\r\n        Class_0_used_before_its_declaration: diag(2449, DiagnosticCategory.Error, \"Class_0_used_before_its_declaration_2449\", \"Class '{0}' used before its declaration.\"),\r\n        Enum_0_used_before_its_declaration: diag(2450, DiagnosticCategory.Error, \"Enum_0_used_before_its_declaration_2450\", \"Enum '{0}' used before its declaration.\"),\r\n        Cannot_redeclare_block_scoped_variable_0: diag(2451, DiagnosticCategory.Error, \"Cannot_redeclare_block_scoped_variable_0_2451\", \"Cannot redeclare block-scoped variable '{0}'.\"),\r\n        An_enum_member_cannot_have_a_numeric_name: diag(2452, DiagnosticCategory.Error, \"An_enum_member_cannot_have_a_numeric_name_2452\", \"An enum member cannot have a numeric name.\"),\r\n        The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly: diag(2453, DiagnosticCategory.Error, \"The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_typ_2453\", \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\"),\r\n        Variable_0_is_used_before_being_assigned: diag(2454, DiagnosticCategory.Error, \"Variable_0_is_used_before_being_assigned_2454\", \"Variable '{0}' is used before being assigned.\"),\r\n        Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0: diag(2455, DiagnosticCategory.Error, \"Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0_2455\", \"Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.\"),\r\n        Type_alias_0_circularly_references_itself: diag(2456, DiagnosticCategory.Error, \"Type_alias_0_circularly_references_itself_2456\", \"Type alias '{0}' circularly references itself.\"),\r\n        Type_alias_name_cannot_be_0: diag(2457, DiagnosticCategory.Error, \"Type_alias_name_cannot_be_0_2457\", \"Type alias name cannot be '{0}'.\"),\r\n        An_AMD_module_cannot_have_multiple_name_assignments: diag(2458, DiagnosticCategory.Error, \"An_AMD_module_cannot_have_multiple_name_assignments_2458\", \"An AMD module cannot have multiple name assignments.\"),\r\n        Type_0_has_no_property_1_and_no_string_index_signature: diag(2459, DiagnosticCategory.Error, \"Type_0_has_no_property_1_and_no_string_index_signature_2459\", \"Type '{0}' has no property '{1}' and no string index signature.\"),\r\n        Type_0_has_no_property_1: diag(2460, DiagnosticCategory.Error, \"Type_0_has_no_property_1_2460\", \"Type '{0}' has no property '{1}'.\"),\r\n        Type_0_is_not_an_array_type: diag(2461, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_2461\", \"Type '{0}' is not an array type.\"),\r\n        A_rest_element_must_be_last_in_a_destructuring_pattern: diag(2462, DiagnosticCategory.Error, \"A_rest_element_must_be_last_in_a_destructuring_pattern_2462\", \"A rest element must be last in a destructuring pattern.\"),\r\n        A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: diag(2463, DiagnosticCategory.Error, \"A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463\", \"A binding pattern parameter cannot be optional in an implementation signature.\"),\r\n        A_computed_property_name_must_be_of_type_string_number_symbol_or_any: diag(2464, DiagnosticCategory.Error, \"A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464\", \"A computed property name must be of type 'string', 'number', 'symbol', or 'any'.\"),\r\n        this_cannot_be_referenced_in_a_computed_property_name: diag(2465, DiagnosticCategory.Error, \"this_cannot_be_referenced_in_a_computed_property_name_2465\", \"'this' cannot be referenced in a computed property name.\"),\r\n        super_cannot_be_referenced_in_a_computed_property_name: diag(2466, DiagnosticCategory.Error, \"super_cannot_be_referenced_in_a_computed_property_name_2466\", \"'super' cannot be referenced in a computed property name.\"),\r\n        A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: diag(2467, DiagnosticCategory.Error, \"A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467\", \"A computed property name cannot reference a type parameter from its containing type.\"),\r\n        Cannot_find_global_value_0: diag(2468, DiagnosticCategory.Error, \"Cannot_find_global_value_0_2468\", \"Cannot find global value '{0}'.\"),\r\n        The_0_operator_cannot_be_applied_to_type_symbol: diag(2469, DiagnosticCategory.Error, \"The_0_operator_cannot_be_applied_to_type_symbol_2469\", \"The '{0}' operator cannot be applied to type 'symbol'.\"),\r\n        Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object: diag(2470, DiagnosticCategory.Error, \"Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object_2470\", \"'Symbol' reference does not refer to the global Symbol constructor object.\"),\r\n        A_computed_property_name_of_the_form_0_must_be_of_type_symbol: diag(2471, DiagnosticCategory.Error, \"A_computed_property_name_of_the_form_0_must_be_of_type_symbol_2471\", \"A computed property name of the form '{0}' must be of type 'symbol'.\"),\r\n        Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: diag(2472, DiagnosticCategory.Error, \"Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472\", \"Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.\"),\r\n        Enum_declarations_must_all_be_const_or_non_const: diag(2473, DiagnosticCategory.Error, \"Enum_declarations_must_all_be_const_or_non_const_2473\", \"Enum declarations must all be const or non-const.\"),\r\n        In_const_enum_declarations_member_initializer_must_be_constant_expression: diag(2474, DiagnosticCategory.Error, \"In_const_enum_declarations_member_initializer_must_be_constant_expression_2474\", \"In 'const' enum declarations member initializer must be constant expression.\"),\r\n        const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query: diag(2475, DiagnosticCategory.Error, \"const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475\", \"'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query.\"),\r\n        A_const_enum_member_can_only_be_accessed_using_a_string_literal: diag(2476, DiagnosticCategory.Error, \"A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476\", \"A const enum member can only be accessed using a string literal.\"),\r\n        const_enum_member_initializer_was_evaluated_to_a_non_finite_value: diag(2477, DiagnosticCategory.Error, \"const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477\", \"'const' enum member initializer was evaluated to a non-finite value.\"),\r\n        const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: diag(2478, DiagnosticCategory.Error, \"const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478\", \"'const' enum member initializer was evaluated to disallowed value 'NaN'.\"),\r\n        Property_0_does_not_exist_on_const_enum_1: diag(2479, DiagnosticCategory.Error, \"Property_0_does_not_exist_on_const_enum_1_2479\", \"Property '{0}' does not exist on 'const' enum '{1}'.\"),\r\n        let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: diag(2480, DiagnosticCategory.Error, \"let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480\", \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\"),\r\n        Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: diag(2481, DiagnosticCategory.Error, \"Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481\", \"Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.\"),\r\n        The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: diag(2483, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483\", \"The left-hand side of a 'for...of' statement cannot use a type annotation.\"),\r\n        Export_declaration_conflicts_with_exported_declaration_of_0: diag(2484, DiagnosticCategory.Error, \"Export_declaration_conflicts_with_exported_declaration_of_0_2484\", \"Export declaration conflicts with exported declaration of '{0}'.\"),\r\n        The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: diag(2487, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487\", \"The left-hand side of a 'for...of' statement must be a variable or a property access.\"),\r\n        Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2488, DiagnosticCategory.Error, \"Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488\", \"Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator.\"),\r\n        An_iterator_must_have_a_next_method: diag(2489, DiagnosticCategory.Error, \"An_iterator_must_have_a_next_method_2489\", \"An iterator must have a 'next()' method.\"),\r\n        The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property: diag(2490, DiagnosticCategory.Error, \"The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property_2490\", \"The type returned by the 'next()' method of an iterator must have a 'value' property.\"),\r\n        The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: diag(2491, DiagnosticCategory.Error, \"The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491\", \"The left-hand side of a 'for...in' statement cannot be a destructuring pattern.\"),\r\n        Cannot_redeclare_identifier_0_in_catch_clause: diag(2492, DiagnosticCategory.Error, \"Cannot_redeclare_identifier_0_in_catch_clause_2492\", \"Cannot redeclare identifier '{0}' in catch clause.\"),\r\n        Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2: diag(2493, DiagnosticCategory.Error, \"Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2_2493\", \"Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.\"),\r\n        Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: diag(2494, DiagnosticCategory.Error, \"Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494\", \"Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.\"),\r\n        Type_0_is_not_an_array_type_or_a_string_type: diag(2495, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_or_a_string_type_2495\", \"Type '{0}' is not an array type or a string type.\"),\r\n        The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression: diag(2496, DiagnosticCategory.Error, \"The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496\", \"The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.\"),\r\n        Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct: diag(2497, DiagnosticCategory.Error, \"Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct_2497\", \"Module '{0}' resolves to a non-module entity and cannot be imported using this construct.\"),\r\n        Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: diag(2498, DiagnosticCategory.Error, \"Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498\", \"Module '{0}' uses 'export =' and cannot be used with 'export *'.\"),\r\n        An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2499, DiagnosticCategory.Error, \"An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499\", \"An interface can only extend an identifier/qualified-name with optional type arguments.\"),\r\n        A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2500, DiagnosticCategory.Error, \"A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500\", \"A class can only implement an identifier/qualified-name with optional type arguments.\"),\r\n        A_rest_element_cannot_contain_a_binding_pattern: diag(2501, DiagnosticCategory.Error, \"A_rest_element_cannot_contain_a_binding_pattern_2501\", \"A rest element cannot contain a binding pattern.\"),\r\n        _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: diag(2502, DiagnosticCategory.Error, \"_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502\", \"'{0}' is referenced directly or indirectly in its own type annotation.\"),\r\n        Cannot_find_namespace_0: diag(2503, DiagnosticCategory.Error, \"Cannot_find_namespace_0_2503\", \"Cannot find namespace '{0}'.\"),\r\n        Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: diag(2504, DiagnosticCategory.Error, \"Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504\", \"Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator.\"),\r\n        A_generator_cannot_have_a_void_type_annotation: diag(2505, DiagnosticCategory.Error, \"A_generator_cannot_have_a_void_type_annotation_2505\", \"A generator cannot have a 'void' type annotation.\"),\r\n        _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: diag(2506, DiagnosticCategory.Error, \"_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506\", \"'{0}' is referenced directly or indirectly in its own base expression.\"),\r\n        Type_0_is_not_a_constructor_function_type: diag(2507, DiagnosticCategory.Error, \"Type_0_is_not_a_constructor_function_type_2507\", \"Type '{0}' is not a constructor function type.\"),\r\n        No_base_constructor_has_the_specified_number_of_type_arguments: diag(2508, DiagnosticCategory.Error, \"No_base_constructor_has_the_specified_number_of_type_arguments_2508\", \"No base constructor has the specified number of type arguments.\"),\r\n        Base_constructor_return_type_0_is_not_a_class_or_interface_type: diag(2509, DiagnosticCategory.Error, \"Base_constructor_return_type_0_is_not_a_class_or_interface_type_2509\", \"Base constructor return type '{0}' is not a class or interface type.\"),\r\n        Base_constructors_must_all_have_the_same_return_type: diag(2510, DiagnosticCategory.Error, \"Base_constructors_must_all_have_the_same_return_type_2510\", \"Base constructors must all have the same return type.\"),\r\n        Cannot_create_an_instance_of_an_abstract_class: diag(2511, DiagnosticCategory.Error, \"Cannot_create_an_instance_of_an_abstract_class_2511\", \"Cannot create an instance of an abstract class.\"),\r\n        Overload_signatures_must_all_be_abstract_or_non_abstract: diag(2512, DiagnosticCategory.Error, \"Overload_signatures_must_all_be_abstract_or_non_abstract_2512\", \"Overload signatures must all be abstract or non-abstract.\"),\r\n        Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: diag(2513, DiagnosticCategory.Error, \"Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513\", \"Abstract method '{0}' in class '{1}' cannot be accessed via super expression.\"),\r\n        Classes_containing_abstract_methods_must_be_marked_abstract: diag(2514, DiagnosticCategory.Error, \"Classes_containing_abstract_methods_must_be_marked_abstract_2514\", \"Classes containing abstract methods must be marked abstract.\"),\r\n        Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: diag(2515, DiagnosticCategory.Error, \"Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515\", \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.\"),\r\n        All_declarations_of_an_abstract_method_must_be_consecutive: diag(2516, DiagnosticCategory.Error, \"All_declarations_of_an_abstract_method_must_be_consecutive_2516\", \"All declarations of an abstract method must be consecutive.\"),\r\n        Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: diag(2517, DiagnosticCategory.Error, \"Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517\", \"Cannot assign an abstract constructor type to a non-abstract constructor type.\"),\r\n        A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: diag(2518, DiagnosticCategory.Error, \"A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518\", \"A 'this'-based type guard is not compatible with a parameter-based type guard.\"),\r\n        An_async_iterator_must_have_a_next_method: diag(2519, DiagnosticCategory.Error, \"An_async_iterator_must_have_a_next_method_2519\", \"An async iterator must have a 'next()' method.\"),\r\n        Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: diag(2520, DiagnosticCategory.Error, \"Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520\", \"Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.\"),\r\n        Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions: diag(2521, DiagnosticCategory.Error, \"Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions_2521\", \"Expression resolves to variable declaration '{0}' that compiler uses to support async functions.\"),\r\n        The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method: diag(2522, DiagnosticCategory.Error, \"The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522\", \"The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method.\"),\r\n        yield_expressions_cannot_be_used_in_a_parameter_initializer: diag(2523, DiagnosticCategory.Error, \"yield_expressions_cannot_be_used_in_a_parameter_initializer_2523\", \"'yield' expressions cannot be used in a parameter initializer.\"),\r\n        await_expressions_cannot_be_used_in_a_parameter_initializer: diag(2524, DiagnosticCategory.Error, \"await_expressions_cannot_be_used_in_a_parameter_initializer_2524\", \"'await' expressions cannot be used in a parameter initializer.\"),\r\n        Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value: diag(2525, DiagnosticCategory.Error, \"Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525\", \"Initializer provides no value for this binding element and the binding element has no default value.\"),\r\n        A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: diag(2526, DiagnosticCategory.Error, \"A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526\", \"A 'this' type is available only in a non-static member of a class or interface.\"),\r\n        The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary: diag(2527, DiagnosticCategory.Error, \"The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527\", \"The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary.\"),\r\n        A_module_cannot_have_multiple_default_exports: diag(2528, DiagnosticCategory.Error, \"A_module_cannot_have_multiple_default_exports_2528\", \"A module cannot have multiple default exports.\"),\r\n        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: diag(2529, DiagnosticCategory.Error, \"Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529\", \"Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.\"),\r\n        Property_0_is_incompatible_with_index_signature: diag(2530, DiagnosticCategory.Error, \"Property_0_is_incompatible_with_index_signature_2530\", \"Property '{0}' is incompatible with index signature.\"),\r\n        Object_is_possibly_null: diag(2531, DiagnosticCategory.Error, \"Object_is_possibly_null_2531\", \"Object is possibly 'null'.\"),\r\n        Object_is_possibly_undefined: diag(2532, DiagnosticCategory.Error, \"Object_is_possibly_undefined_2532\", \"Object is possibly 'undefined'.\"),\r\n        Object_is_possibly_null_or_undefined: diag(2533, DiagnosticCategory.Error, \"Object_is_possibly_null_or_undefined_2533\", \"Object is possibly 'null' or 'undefined'.\"),\r\n        A_function_returning_never_cannot_have_a_reachable_end_point: diag(2534, DiagnosticCategory.Error, \"A_function_returning_never_cannot_have_a_reachable_end_point_2534\", \"A function returning 'never' cannot have a reachable end point.\"),\r\n        Enum_type_0_has_members_with_initializers_that_are_not_literals: diag(2535, DiagnosticCategory.Error, \"Enum_type_0_has_members_with_initializers_that_are_not_literals_2535\", \"Enum type '{0}' has members with initializers that are not literals.\"),\r\n        Type_0_cannot_be_used_to_index_type_1: diag(2536, DiagnosticCategory.Error, \"Type_0_cannot_be_used_to_index_type_1_2536\", \"Type '{0}' cannot be used to index type '{1}'.\"),\r\n        Type_0_has_no_matching_index_signature_for_type_1: diag(2537, DiagnosticCategory.Error, \"Type_0_has_no_matching_index_signature_for_type_1_2537\", \"Type '{0}' has no matching index signature for type '{1}'.\"),\r\n        Type_0_cannot_be_used_as_an_index_type: diag(2538, DiagnosticCategory.Error, \"Type_0_cannot_be_used_as_an_index_type_2538\", \"Type '{0}' cannot be used as an index type.\"),\r\n        Cannot_assign_to_0_because_it_is_not_a_variable: diag(2539, DiagnosticCategory.Error, \"Cannot_assign_to_0_because_it_is_not_a_variable_2539\", \"Cannot assign to '{0}' because it is not a variable.\"),\r\n        Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property: diag(2540, DiagnosticCategory.Error, \"Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property_2540\", \"Cannot assign to '{0}' because it is a constant or a read-only property.\"),\r\n        The_target_of_an_assignment_must_be_a_variable_or_a_property_access: diag(2541, DiagnosticCategory.Error, \"The_target_of_an_assignment_must_be_a_variable_or_a_property_access_2541\", \"The target of an assignment must be a variable or a property access.\"),\r\n        Index_signature_in_type_0_only_permits_reading: diag(2542, DiagnosticCategory.Error, \"Index_signature_in_type_0_only_permits_reading_2542\", \"Index signature in type '{0}' only permits reading.\"),\r\n        Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: diag(2543, DiagnosticCategory.Error, \"Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543\", \"Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference.\"),\r\n        Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: diag(2544, DiagnosticCategory.Error, \"Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544\", \"Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference.\"),\r\n        A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: diag(2545, DiagnosticCategory.Error, \"A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545\", \"A mixin class must have a constructor with a single rest parameter of type 'any[]'.\"),\r\n        Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1: diag(2546, DiagnosticCategory.Error, \"Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1_2546\", \"Property '{0}' has conflicting declarations and is inaccessible in type '{1}'.\"),\r\n        The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: diag(2547, DiagnosticCategory.Error, \"The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value__2547\", \"The type returned by the 'next()' method of an async iterator must be a promise for a type with a 'value' property.\"),\r\n        Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2548, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548\", \"Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator.\"),\r\n        Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2549, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549\", \"Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator.\"),\r\n        Generic_type_instantiation_is_excessively_deep_and_possibly_infinite: diag(2550, DiagnosticCategory.Error, \"Generic_type_instantiation_is_excessively_deep_and_possibly_infinite_2550\", \"Generic type instantiation is excessively deep and possibly infinite.\"),\r\n        Property_0_does_not_exist_on_type_1_Did_you_mean_2: diag(2551, DiagnosticCategory.Error, \"Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551\", \"Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?\"),\r\n        Cannot_find_name_0_Did_you_mean_1: diag(2552, DiagnosticCategory.Error, \"Cannot_find_name_0_Did_you_mean_1_2552\", \"Cannot find name '{0}'. Did you mean '{1}'?\"),\r\n        Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: diag(2553, DiagnosticCategory.Error, \"Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553\", \"Computed values are not permitted in an enum with string valued members.\"),\r\n        Expected_0_arguments_but_got_1: diag(2554, DiagnosticCategory.Error, \"Expected_0_arguments_but_got_1_2554\", \"Expected {0} arguments, but got {1}.\"),\r\n        Expected_at_least_0_arguments_but_got_1: diag(2555, DiagnosticCategory.Error, \"Expected_at_least_0_arguments_but_got_1_2555\", \"Expected at least {0} arguments, but got {1}.\"),\r\n        Expected_0_arguments_but_got_1_or_more: diag(2556, DiagnosticCategory.Error, \"Expected_0_arguments_but_got_1_or_more_2556\", \"Expected {0} arguments, but got {1} or more.\"),\r\n        Expected_at_least_0_arguments_but_got_1_or_more: diag(2557, DiagnosticCategory.Error, \"Expected_at_least_0_arguments_but_got_1_or_more_2557\", \"Expected at least {0} arguments, but got {1} or more.\"),\r\n        Expected_0_type_arguments_but_got_1: diag(2558, DiagnosticCategory.Error, \"Expected_0_type_arguments_but_got_1_2558\", \"Expected {0} type arguments, but got {1}.\"),\r\n        Type_0_has_no_properties_in_common_with_type_1: diag(2559, DiagnosticCategory.Error, \"Type_0_has_no_properties_in_common_with_type_1_2559\", \"Type '{0}' has no properties in common with type '{1}'.\"),\r\n        Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: diag(2560, DiagnosticCategory.Error, \"Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560\", \"Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?\"),\r\n        Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: diag(2561, DiagnosticCategory.Error, \"Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561\", \"Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?\"),\r\n        Base_class_expressions_cannot_reference_class_type_parameters: diag(2562, DiagnosticCategory.Error, \"Base_class_expressions_cannot_reference_class_type_parameters_2562\", \"Base class expressions cannot reference class type parameters.\"),\r\n        The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: diag(2563, DiagnosticCategory.Error, \"The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563\", \"The containing function or module body is too large for control flow analysis.\"),\r\n        Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor: diag(2564, DiagnosticCategory.Error, \"Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564\", \"Property '{0}' has no initializer and is not definitely assigned in the constructor.\"),\r\n        Property_0_is_used_before_being_assigned: diag(2565, DiagnosticCategory.Error, \"Property_0_is_used_before_being_assigned_2565\", \"Property '{0}' is used before being assigned.\"),\r\n        A_rest_element_cannot_have_a_property_name: diag(2566, DiagnosticCategory.Error, \"A_rest_element_cannot_have_a_property_name_2566\", \"A rest element cannot have a property name.\"),\r\n        Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations: diag(2567, DiagnosticCategory.Error, \"Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567\", \"Enum declarations can only merge with namespace or other enum declarations.\"),\r\n        Type_0_is_not_an_array_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators: diag(2568, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators_2568\", \"Type '{0}' is not an array type. Use compiler option '--downlevelIteration' to allow iterating of iterators.\"),\r\n        Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators: diag(2569, DiagnosticCategory.Error, \"Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterati_2569\", \"Type '{0}' is not an array type or a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.\"),\r\n        Property_0_does_not_exist_on_type_1_Did_you_forget_to_use_await: diag(2570, DiagnosticCategory.Error, \"Property_0_does_not_exist_on_type_1_Did_you_forget_to_use_await_2570\", \"Property '{0}' does not exist on type '{1}'. Did you forget to use 'await'?\"),\r\n        JSX_element_attributes_type_0_may_not_be_a_union_type: diag(2600, DiagnosticCategory.Error, \"JSX_element_attributes_type_0_may_not_be_a_union_type_2600\", \"JSX element attributes type '{0}' may not be a union type.\"),\r\n        The_return_type_of_a_JSX_element_constructor_must_return_an_object_type: diag(2601, DiagnosticCategory.Error, \"The_return_type_of_a_JSX_element_constructor_must_return_an_object_type_2601\", \"The return type of a JSX element constructor must return an object type.\"),\r\n        JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: diag(2602, DiagnosticCategory.Error, \"JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602\", \"JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.\"),\r\n        Property_0_in_type_1_is_not_assignable_to_type_2: diag(2603, DiagnosticCategory.Error, \"Property_0_in_type_1_is_not_assignable_to_type_2_2603\", \"Property '{0}' in type '{1}' is not assignable to type '{2}'.\"),\r\n        JSX_element_type_0_does_not_have_any_construct_or_call_signatures: diag(2604, DiagnosticCategory.Error, \"JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604\", \"JSX element type '{0}' does not have any construct or call signatures.\"),\r\n        JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements: diag(2605, DiagnosticCategory.Error, \"JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements_2605\", \"JSX element type '{0}' is not a constructor function for JSX elements.\"),\r\n        Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: diag(2606, DiagnosticCategory.Error, \"Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606\", \"Property '{0}' of JSX spread attribute is not assignable to target property.\"),\r\n        JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: diag(2607, DiagnosticCategory.Error, \"JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607\", \"JSX element class does not support attributes because it does not have a '{0}' property.\"),\r\n        The_global_type_JSX_0_may_not_have_more_than_one_property: diag(2608, DiagnosticCategory.Error, \"The_global_type_JSX_0_may_not_have_more_than_one_property_2608\", \"The global type 'JSX.{0}' may not have more than one property.\"),\r\n        JSX_spread_child_must_be_an_array_type: diag(2609, DiagnosticCategory.Error, \"JSX_spread_child_must_be_an_array_type_2609\", \"JSX spread child must be an array type.\"),\r\n        Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: diag(2649, DiagnosticCategory.Error, \"Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649\", \"Cannot augment module '{0}' with value exports because it resolves to a non-module entity.\"),\r\n        A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: diag(2651, DiagnosticCategory.Error, \"A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651\", \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\"),\r\n        Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: diag(2652, DiagnosticCategory.Error, \"Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652\", \"Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.\"),\r\n        Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: diag(2653, DiagnosticCategory.Error, \"Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653\", \"Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'.\"),\r\n        Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_package_author_to_update_the_package_definition: diag(2654, DiagnosticCategory.Error, \"Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_pack_2654\", \"Exported external package typings file cannot contain tripleslash references. Please contact the package author to update the package definition.\"),\r\n        Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_the_package_definition: diag(2656, DiagnosticCategory.Error, \"Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_2656\", \"Exported external package typings file '{0}' is not a module. Please contact the package author to update the package definition.\"),\r\n        JSX_expressions_must_have_one_parent_element: diag(2657, DiagnosticCategory.Error, \"JSX_expressions_must_have_one_parent_element_2657\", \"JSX expressions must have one parent element.\"),\r\n        Type_0_provides_no_match_for_the_signature_1: diag(2658, DiagnosticCategory.Error, \"Type_0_provides_no_match_for_the_signature_1_2658\", \"Type '{0}' provides no match for the signature '{1}'.\"),\r\n        super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: diag(2659, DiagnosticCategory.Error, \"super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659\", \"'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.\"),\r\n        super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: diag(2660, DiagnosticCategory.Error, \"super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660\", \"'super' can only be referenced in members of derived classes or object literal expressions.\"),\r\n        Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: diag(2661, DiagnosticCategory.Error, \"Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661\", \"Cannot export '{0}'. Only local declarations can be exported from a module.\"),\r\n        Cannot_find_name_0_Did_you_mean_the_static_member_1_0: diag(2662, DiagnosticCategory.Error, \"Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662\", \"Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?\"),\r\n        Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: diag(2663, DiagnosticCategory.Error, \"Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663\", \"Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?\"),\r\n        Invalid_module_name_in_augmentation_module_0_cannot_be_found: diag(2664, DiagnosticCategory.Error, \"Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664\", \"Invalid module name in augmentation, module '{0}' cannot be found.\"),\r\n        Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: diag(2665, DiagnosticCategory.Error, \"Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665\", \"Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented.\"),\r\n        Exports_and_export_assignments_are_not_permitted_in_module_augmentations: diag(2666, DiagnosticCategory.Error, \"Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666\", \"Exports and export assignments are not permitted in module augmentations.\"),\r\n        Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: diag(2667, DiagnosticCategory.Error, \"Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667\", \"Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.\"),\r\n        export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: diag(2668, DiagnosticCategory.Error, \"export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668\", \"'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.\"),\r\n        Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: diag(2669, DiagnosticCategory.Error, \"Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669\", \"Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.\"),\r\n        Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: diag(2670, DiagnosticCategory.Error, \"Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670\", \"Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.\"),\r\n        Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: diag(2671, DiagnosticCategory.Error, \"Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671\", \"Cannot augment module '{0}' because it resolves to a non-module entity.\"),\r\n        Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: diag(2672, DiagnosticCategory.Error, \"Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672\", \"Cannot assign a '{0}' constructor type to a '{1}' constructor type.\"),\r\n        Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: diag(2673, DiagnosticCategory.Error, \"Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673\", \"Constructor of class '{0}' is private and only accessible within the class declaration.\"),\r\n        Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: diag(2674, DiagnosticCategory.Error, \"Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674\", \"Constructor of class '{0}' is protected and only accessible within the class declaration.\"),\r\n        Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: diag(2675, DiagnosticCategory.Error, \"Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675\", \"Cannot extend a class '{0}'. Class constructor is marked as private.\"),\r\n        Accessors_must_both_be_abstract_or_non_abstract: diag(2676, DiagnosticCategory.Error, \"Accessors_must_both_be_abstract_or_non_abstract_2676\", \"Accessors must both be abstract or non-abstract.\"),\r\n        A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: diag(2677, DiagnosticCategory.Error, \"A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677\", \"A type predicate's type must be assignable to its parameter's type.\"),\r\n        Type_0_is_not_comparable_to_type_1: diag(2678, DiagnosticCategory.Error, \"Type_0_is_not_comparable_to_type_1_2678\", \"Type '{0}' is not comparable to type '{1}'.\"),\r\n        A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: diag(2679, DiagnosticCategory.Error, \"A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679\", \"A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'.\"),\r\n        A_0_parameter_must_be_the_first_parameter: diag(2680, DiagnosticCategory.Error, \"A_0_parameter_must_be_the_first_parameter_2680\", \"A '{0}' parameter must be the first parameter.\"),\r\n        A_constructor_cannot_have_a_this_parameter: diag(2681, DiagnosticCategory.Error, \"A_constructor_cannot_have_a_this_parameter_2681\", \"A constructor cannot have a 'this' parameter.\"),\r\n        get_and_set_accessor_must_have_the_same_this_type: diag(2682, DiagnosticCategory.Error, \"get_and_set_accessor_must_have_the_same_this_type_2682\", \"'get' and 'set' accessor must have the same 'this' type.\"),\r\n        this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: diag(2683, DiagnosticCategory.Error, \"this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683\", \"'this' implicitly has type 'any' because it does not have a type annotation.\"),\r\n        The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: diag(2684, DiagnosticCategory.Error, \"The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684\", \"The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'.\"),\r\n        The_this_types_of_each_signature_are_incompatible: diag(2685, DiagnosticCategory.Error, \"The_this_types_of_each_signature_are_incompatible_2685\", \"The 'this' types of each signature are incompatible.\"),\r\n        _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: diag(2686, DiagnosticCategory.Error, \"_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686\", \"'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead.\"),\r\n        All_declarations_of_0_must_have_identical_modifiers: diag(2687, DiagnosticCategory.Error, \"All_declarations_of_0_must_have_identical_modifiers_2687\", \"All declarations of '{0}' must have identical modifiers.\"),\r\n        Cannot_find_type_definition_file_for_0: diag(2688, DiagnosticCategory.Error, \"Cannot_find_type_definition_file_for_0_2688\", \"Cannot find type definition file for '{0}'.\"),\r\n        Cannot_extend_an_interface_0_Did_you_mean_implements: diag(2689, DiagnosticCategory.Error, \"Cannot_extend_an_interface_0_Did_you_mean_implements_2689\", \"Cannot extend an interface '{0}'. Did you mean 'implements'?\"),\r\n        An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead: diag(2691, DiagnosticCategory.Error, \"An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead_2691\", \"An import path cannot end with a '{0}' extension. Consider importing '{1}' instead.\"),\r\n        _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: diag(2692, DiagnosticCategory.Error, \"_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692\", \"'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible.\"),\r\n        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: diag(2693, DiagnosticCategory.Error, \"_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693\", \"'{0}' only refers to a type, but is being used as a value here.\"),\r\n        Namespace_0_has_no_exported_member_1: diag(2694, DiagnosticCategory.Error, \"Namespace_0_has_no_exported_member_1_2694\", \"Namespace '{0}' has no exported member '{1}'.\"),\r\n        Left_side_of_comma_operator_is_unused_and_has_no_side_effects: diag(2695, DiagnosticCategory.Error, \"Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695\", \"Left side of comma operator is unused and has no side effects.\"),\r\n        The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: diag(2696, DiagnosticCategory.Error, \"The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696\", \"The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?\"),\r\n        An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2697, DiagnosticCategory.Error, \"An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697\", \"An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your `--lib` option.\"),\r\n        Spread_types_may_only_be_created_from_object_types: diag(2698, DiagnosticCategory.Error, \"Spread_types_may_only_be_created_from_object_types_2698\", \"Spread types may only be created from object types.\"),\r\n        Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: diag(2699, DiagnosticCategory.Error, \"Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699\", \"Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'.\"),\r\n        Rest_types_may_only_be_created_from_object_types: diag(2700, DiagnosticCategory.Error, \"Rest_types_may_only_be_created_from_object_types_2700\", \"Rest types may only be created from object types.\"),\r\n        The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: diag(2701, DiagnosticCategory.Error, \"The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701\", \"The target of an object rest assignment must be a variable or a property access.\"),\r\n        _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: diag(2702, DiagnosticCategory.Error, \"_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702\", \"'{0}' only refers to a type, but is being used as a namespace here.\"),\r\n        The_operand_of_a_delete_operator_must_be_a_property_reference: diag(2703, DiagnosticCategory.Error, \"The_operand_of_a_delete_operator_must_be_a_property_reference_2703\", \"The operand of a delete operator must be a property reference.\"),\r\n        The_operand_of_a_delete_operator_cannot_be_a_read_only_property: diag(2704, DiagnosticCategory.Error, \"The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704\", \"The operand of a delete operator cannot be a read-only property.\"),\r\n        An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2705, DiagnosticCategory.Error, \"An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705\", \"An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.\"),\r\n        Required_type_parameters_may_not_follow_optional_type_parameters: diag(2706, DiagnosticCategory.Error, \"Required_type_parameters_may_not_follow_optional_type_parameters_2706\", \"Required type parameters may not follow optional type parameters.\"),\r\n        Generic_type_0_requires_between_1_and_2_type_arguments: diag(2707, DiagnosticCategory.Error, \"Generic_type_0_requires_between_1_and_2_type_arguments_2707\", \"Generic type '{0}' requires between {1} and {2} type arguments.\"),\r\n        Cannot_use_namespace_0_as_a_value: diag(2708, DiagnosticCategory.Error, \"Cannot_use_namespace_0_as_a_value_2708\", \"Cannot use namespace '{0}' as a value.\"),\r\n        Cannot_use_namespace_0_as_a_type: diag(2709, DiagnosticCategory.Error, \"Cannot_use_namespace_0_as_a_type_2709\", \"Cannot use namespace '{0}' as a type.\"),\r\n        _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: diag(2710, DiagnosticCategory.Error, \"_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710\", \"'{0}' are specified twice. The attribute named '{0}' will be overwritten.\"),\r\n        A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2711, DiagnosticCategory.Error, \"A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711\", \"A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your `--lib` option.\"),\r\n        A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2712, DiagnosticCategory.Error, \"A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712\", \"A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.\"),\r\n        Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: diag(2713, DiagnosticCategory.Error, \"Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713\", \"Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}[\\\"{1}\\\"]'?\"),\r\n        The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: diag(2714, DiagnosticCategory.Error, \"The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714\", \"The expression of an export assignment must be an identifier or qualified name in an ambient context.\"),\r\n        Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: diag(2715, DiagnosticCategory.Error, \"Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715\", \"Abstract property '{0}' in class '{1}' cannot be accessed in the constructor.\"),\r\n        Type_parameter_0_has_a_circular_default: diag(2716, DiagnosticCategory.Error, \"Type_parameter_0_has_a_circular_default_2716\", \"Type parameter '{0}' has a circular default.\"),\r\n        Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2: diag(2717, DiagnosticCategory.Error, \"Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717\", \"Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'.\"),\r\n        Duplicate_declaration_0: diag(2718, DiagnosticCategory.Error, \"Duplicate_declaration_0_2718\", \"Duplicate declaration '{0}'.\"),\r\n        Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: diag(2719, DiagnosticCategory.Error, \"Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719\", \"Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated.\"),\r\n        Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass: diag(2720, DiagnosticCategory.Error, \"Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720\", \"Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?\"),\r\n        Cannot_invoke_an_object_which_is_possibly_null: diag(2721, DiagnosticCategory.Error, \"Cannot_invoke_an_object_which_is_possibly_null_2721\", \"Cannot invoke an object which is possibly 'null'.\"),\r\n        Cannot_invoke_an_object_which_is_possibly_undefined: diag(2722, DiagnosticCategory.Error, \"Cannot_invoke_an_object_which_is_possibly_undefined_2722\", \"Cannot invoke an object which is possibly 'undefined'.\"),\r\n        Cannot_invoke_an_object_which_is_possibly_null_or_undefined: diag(2723, DiagnosticCategory.Error, \"Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723\", \"Cannot invoke an object which is possibly 'null' or 'undefined'.\"),\r\n        Module_0_has_no_exported_member_1_Did_you_mean_2: diag(2724, DiagnosticCategory.Error, \"Module_0_has_no_exported_member_1_Did_you_mean_2_2724\", \"Module '{0}' has no exported member '{1}'. Did you mean '{2}'?\"),\r\n        Import_declaration_0_is_using_private_name_1: diag(4000, DiagnosticCategory.Error, \"Import_declaration_0_is_using_private_name_1_4000\", \"Import declaration '{0}' is using private name '{1}'.\"),\r\n        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: diag(4002, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002\", \"Type parameter '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: diag(4004, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004\", \"Type parameter '{0}' of exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4006, DiagnosticCategory.Error, \"Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006\", \"Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4008, DiagnosticCategory.Error, \"Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008\", \"Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4010, DiagnosticCategory.Error, \"Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010\", \"Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4012, DiagnosticCategory.Error, \"Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012\", \"Type parameter '{0}' of public method from exported class has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4014, DiagnosticCategory.Error, \"Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014\", \"Type parameter '{0}' of method from exported interface has or is using private name '{1}'.\"),\r\n        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4016, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016\", \"Type parameter '{0}' of exported function has or is using private name '{1}'.\"),\r\n        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4019, DiagnosticCategory.Error, \"Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019\", \"Implements clause of exported class '{0}' has or is using private name '{1}'.\"),\r\n        extends_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4020, DiagnosticCategory.Error, \"extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020\", \"'extends' clause of exported class '{0}' has or is using private name '{1}'.\"),\r\n        extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: diag(4022, DiagnosticCategory.Error, \"extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022\", \"'extends' clause of exported interface '{0}' has or is using private name '{1}'.\"),\r\n        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4023, DiagnosticCategory.Error, \"Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023\", \"Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: diag(4024, DiagnosticCategory.Error, \"Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024\", \"Exported variable '{0}' has or is using name '{1}' from private module '{2}'.\"),\r\n        Exported_variable_0_has_or_is_using_private_name_1: diag(4025, DiagnosticCategory.Error, \"Exported_variable_0_has_or_is_using_private_name_1_4025\", \"Exported variable '{0}' has or is using private name '{1}'.\"),\r\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4026, DiagnosticCategory.Error, \"Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026\", \"Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4027, DiagnosticCategory.Error, \"Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027\", \"Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4028, DiagnosticCategory.Error, \"Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028\", \"Public static property '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4029, DiagnosticCategory.Error, \"Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029\", \"Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4030, DiagnosticCategory.Error, \"Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030\", \"Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Public_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4031, DiagnosticCategory.Error, \"Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031\", \"Public property '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4032, DiagnosticCategory.Error, \"Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032\", \"Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Property_0_of_exported_interface_has_or_is_using_private_name_1: diag(4033, DiagnosticCategory.Error, \"Property_0_of_exported_interface_has_or_is_using_private_name_1_4033\", \"Property '{0}' of exported interface has or is using private name '{1}'.\"),\r\n        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4034, DiagnosticCategory.Error, \"Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034\", \"Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1: diag(4035, DiagnosticCategory.Error, \"Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035\", \"Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'.\"),\r\n        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4036, DiagnosticCategory.Error, \"Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036\", \"Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1: diag(4037, DiagnosticCategory.Error, \"Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037\", \"Parameter type of public setter '{0}' from exported class has or is using private name '{1}'.\"),\r\n        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4038, DiagnosticCategory.Error, \"Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038\", \"Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4039, DiagnosticCategory.Error, \"Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039\", \"Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1: diag(4040, DiagnosticCategory.Error, \"Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040\", \"Return type of public static getter '{0}' from exported class has or is using private name '{1}'.\"),\r\n        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4041, DiagnosticCategory.Error, \"Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041\", \"Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4042, DiagnosticCategory.Error, \"Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042\", \"Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1: diag(4043, DiagnosticCategory.Error, \"Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043\", \"Return type of public getter '{0}' from exported class has or is using private name '{1}'.\"),\r\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4044, DiagnosticCategory.Error, \"Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044\", \"Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4045, DiagnosticCategory.Error, \"Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045\", \"Return type of constructor signature from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4046, DiagnosticCategory.Error, \"Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046\", \"Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4047, DiagnosticCategory.Error, \"Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047\", \"Return type of call signature from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4048, DiagnosticCategory.Error, \"Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048\", \"Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4049, DiagnosticCategory.Error, \"Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049\", \"Return type of index signature from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4050, DiagnosticCategory.Error, \"Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050\", \"Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4051, DiagnosticCategory.Error, \"Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051\", \"Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: diag(4052, DiagnosticCategory.Error, \"Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052\", \"Return type of public static method from exported class has or is using private name '{0}'.\"),\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4053, DiagnosticCategory.Error, \"Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053\", \"Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4054, DiagnosticCategory.Error, \"Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054\", \"Return type of public method from exported class has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: diag(4055, DiagnosticCategory.Error, \"Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055\", \"Return type of public method from exported class has or is using private name '{0}'.\"),\r\n        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4056, DiagnosticCategory.Error, \"Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056\", \"Return type of method from exported interface has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: diag(4057, DiagnosticCategory.Error, \"Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057\", \"Return type of method from exported interface has or is using private name '{0}'.\"),\r\n        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4058, DiagnosticCategory.Error, \"Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058\", \"Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.\"),\r\n        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: diag(4059, DiagnosticCategory.Error, \"Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059\", \"Return type of exported function has or is using name '{0}' from private module '{1}'.\"),\r\n        Return_type_of_exported_function_has_or_is_using_private_name_0: diag(4060, DiagnosticCategory.Error, \"Return_type_of_exported_function_has_or_is_using_private_name_0_4060\", \"Return type of exported function has or is using private name '{0}'.\"),\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4061, DiagnosticCategory.Error, \"Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061\", \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4062, DiagnosticCategory.Error, \"Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062\", \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: diag(4063, DiagnosticCategory.Error, \"Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063\", \"Parameter '{0}' of constructor from exported class has or is using private name '{1}'.\"),\r\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4064, DiagnosticCategory.Error, \"Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064\", \"Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4065, DiagnosticCategory.Error, \"Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065\", \"Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\"),\r\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4066, DiagnosticCategory.Error, \"Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066\", \"Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4067, DiagnosticCategory.Error, \"Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067\", \"Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\"),\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4068, DiagnosticCategory.Error, \"Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068\", \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4069, DiagnosticCategory.Error, \"Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069\", \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4070, DiagnosticCategory.Error, \"Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070\", \"Parameter '{0}' of public static method from exported class has or is using private name '{1}'.\"),\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4071, DiagnosticCategory.Error, \"Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071\", \"Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4072, DiagnosticCategory.Error, \"Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072\", \"Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4073, DiagnosticCategory.Error, \"Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073\", \"Parameter '{0}' of public method from exported class has or is using private name '{1}'.\"),\r\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4074, DiagnosticCategory.Error, \"Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074\", \"Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4075, DiagnosticCategory.Error, \"Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075\", \"Parameter '{0}' of method from exported interface has or is using private name '{1}'.\"),\r\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4076, DiagnosticCategory.Error, \"Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076\", \"Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: diag(4077, DiagnosticCategory.Error, \"Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077\", \"Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4078, DiagnosticCategory.Error, \"Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078\", \"Parameter '{0}' of exported function has or is using private name '{1}'.\"),\r\n        Exported_type_alias_0_has_or_is_using_private_name_1: diag(4081, DiagnosticCategory.Error, \"Exported_type_alias_0_has_or_is_using_private_name_1_4081\", \"Exported type alias '{0}' has or is using private name '{1}'.\"),\r\n        Default_export_of_the_module_has_or_is_using_private_name_0: diag(4082, DiagnosticCategory.Error, \"Default_export_of_the_module_has_or_is_using_private_name_0_4082\", \"Default export of the module has or is using private name '{0}'.\"),\r\n        Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: diag(4083, DiagnosticCategory.Error, \"Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083\", \"Type parameter '{0}' of exported type alias has or is using private name '{1}'.\"),\r\n        Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict: diag(4090, DiagnosticCategory.Error, \"Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090\", \"Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict.\"),\r\n        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4091, DiagnosticCategory.Error, \"Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091\", \"Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4092, DiagnosticCategory.Error, \"Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092\", \"Parameter '{0}' of index signature from exported interface has or is using private name '{1}'.\"),\r\n        Property_0_of_exported_class_expression_may_not_be_private_or_protected: diag(4094, DiagnosticCategory.Error, \"Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094\", \"Property '{0}' of exported class expression may not be private or protected.\"),\r\n        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4095, DiagnosticCategory.Error, \"Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095\", \"Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4096, DiagnosticCategory.Error, \"Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096\", \"Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Public_static_method_0_of_exported_class_has_or_is_using_private_name_1: diag(4097, DiagnosticCategory.Error, \"Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097\", \"Public static method '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4098, DiagnosticCategory.Error, \"Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098\", \"Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\"),\r\n        Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4099, DiagnosticCategory.Error, \"Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099\", \"Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'.\"),\r\n        Public_method_0_of_exported_class_has_or_is_using_private_name_1: diag(4100, DiagnosticCategory.Error, \"Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100\", \"Public method '{0}' of exported class has or is using private name '{1}'.\"),\r\n        Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4101, DiagnosticCategory.Error, \"Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101\", \"Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'.\"),\r\n        Method_0_of_exported_interface_has_or_is_using_private_name_1: diag(4102, DiagnosticCategory.Error, \"Method_0_of_exported_interface_has_or_is_using_private_name_1_4102\", \"Method '{0}' of exported interface has or is using private name '{1}'.\"),\r\n        The_current_host_does_not_support_the_0_option: diag(5001, DiagnosticCategory.Error, \"The_current_host_does_not_support_the_0_option_5001\", \"The current host does not support the '{0}' option.\"),\r\n        Cannot_find_the_common_subdirectory_path_for_the_input_files: diag(5009, DiagnosticCategory.Error, \"Cannot_find_the_common_subdirectory_path_for_the_input_files_5009\", \"Cannot find the common subdirectory path for the input files.\"),\r\n        File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5010, DiagnosticCategory.Error, \"File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010\", \"File specification cannot end in a recursive directory wildcard ('**'): '{0}'.\"),\r\n        Cannot_read_file_0_Colon_1: diag(5012, DiagnosticCategory.Error, \"Cannot_read_file_0_Colon_1_5012\", \"Cannot read file '{0}': {1}.\"),\r\n        Failed_to_parse_file_0_Colon_1: diag(5014, DiagnosticCategory.Error, \"Failed_to_parse_file_0_Colon_1_5014\", \"Failed to parse file '{0}': {1}.\"),\r\n        Unknown_compiler_option_0: diag(5023, DiagnosticCategory.Error, \"Unknown_compiler_option_0_5023\", \"Unknown compiler option '{0}'.\"),\r\n        Compiler_option_0_requires_a_value_of_type_1: diag(5024, DiagnosticCategory.Error, \"Compiler_option_0_requires_a_value_of_type_1_5024\", \"Compiler option '{0}' requires a value of type {1}.\"),\r\n        Could_not_write_file_0_Colon_1: diag(5033, DiagnosticCategory.Error, \"Could_not_write_file_0_Colon_1_5033\", \"Could not write file '{0}': {1}.\"),\r\n        Option_project_cannot_be_mixed_with_source_files_on_a_command_line: diag(5042, DiagnosticCategory.Error, \"Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042\", \"Option 'project' cannot be mixed with source files on a command line.\"),\r\n        Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: diag(5047, DiagnosticCategory.Error, \"Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047\", \"Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher.\"),\r\n        Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: diag(5051, DiagnosticCategory.Error, \"Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051\", \"Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.\"),\r\n        Option_0_cannot_be_specified_without_specifying_option_1: diag(5052, DiagnosticCategory.Error, \"Option_0_cannot_be_specified_without_specifying_option_1_5052\", \"Option '{0}' cannot be specified without specifying option '{1}'.\"),\r\n        Option_0_cannot_be_specified_with_option_1: diag(5053, DiagnosticCategory.Error, \"Option_0_cannot_be_specified_with_option_1_5053\", \"Option '{0}' cannot be specified with option '{1}'.\"),\r\n        A_tsconfig_json_file_is_already_defined_at_Colon_0: diag(5054, DiagnosticCategory.Error, \"A_tsconfig_json_file_is_already_defined_at_Colon_0_5054\", \"A 'tsconfig.json' file is already defined at: '{0}'.\"),\r\n        Cannot_write_file_0_because_it_would_overwrite_input_file: diag(5055, DiagnosticCategory.Error, \"Cannot_write_file_0_because_it_would_overwrite_input_file_5055\", \"Cannot write file '{0}' because it would overwrite input file.\"),\r\n        Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: diag(5056, DiagnosticCategory.Error, \"Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056\", \"Cannot write file '{0}' because it would be overwritten by multiple input files.\"),\r\n        Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: diag(5057, DiagnosticCategory.Error, \"Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057\", \"Cannot find a tsconfig.json file at the specified directory: '{0}'.\"),\r\n        The_specified_path_does_not_exist_Colon_0: diag(5058, DiagnosticCategory.Error, \"The_specified_path_does_not_exist_Colon_0_5058\", \"The specified path does not exist: '{0}'.\"),\r\n        Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: diag(5059, DiagnosticCategory.Error, \"Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059\", \"Invalid value for '--reactNamespace'. '{0}' is not a valid identifier.\"),\r\n        Option_paths_cannot_be_used_without_specifying_baseUrl_option: diag(5060, DiagnosticCategory.Error, \"Option_paths_cannot_be_used_without_specifying_baseUrl_option_5060\", \"Option 'paths' cannot be used without specifying '--baseUrl' option.\"),\r\n        Pattern_0_can_have_at_most_one_Asterisk_character: diag(5061, DiagnosticCategory.Error, \"Pattern_0_can_have_at_most_one_Asterisk_character_5061\", \"Pattern '{0}' can have at most one '*' character.\"),\r\n        Substitution_0_in_pattern_1_in_can_have_at_most_one_Asterisk_character: diag(5062, DiagnosticCategory.Error, \"Substitution_0_in_pattern_1_in_can_have_at_most_one_Asterisk_character_5062\", \"Substitution '{0}' in pattern '{1}' in can have at most one '*' character.\"),\r\n        Substitutions_for_pattern_0_should_be_an_array: diag(5063, DiagnosticCategory.Error, \"Substitutions_for_pattern_0_should_be_an_array_5063\", \"Substitutions for pattern '{0}' should be an array.\"),\r\n        Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: diag(5064, DiagnosticCategory.Error, \"Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064\", \"Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'.\"),\r\n        File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5065, DiagnosticCategory.Error, \"File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065\", \"File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'.\"),\r\n        Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: diag(5066, DiagnosticCategory.Error, \"Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066\", \"Substitutions for pattern '{0}' shouldn't be an empty array.\"),\r\n        Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: diag(5067, DiagnosticCategory.Error, \"Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067\", \"Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name.\"),\r\n        Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: diag(5068, DiagnosticCategory.Error, \"Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068\", \"Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig.\"),\r\n        Option_0_cannot_be_specified_without_specifying_option_1_or_option_2: diag(5069, DiagnosticCategory.Error, \"Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069\", \"Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'.\"),\r\n        Generates_a_sourcemap_for_each_corresponding_d_ts_file: diag(6000, DiagnosticCategory.Message, \"Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000\", \"Generates a sourcemap for each corresponding '.d.ts' file.\"),\r\n        Concatenate_and_emit_output_to_single_file: diag(6001, DiagnosticCategory.Message, \"Concatenate_and_emit_output_to_single_file_6001\", \"Concatenate and emit output to single file.\"),\r\n        Generates_corresponding_d_ts_file: diag(6002, DiagnosticCategory.Message, \"Generates_corresponding_d_ts_file_6002\", \"Generates corresponding '.d.ts' file.\"),\r\n        Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: diag(6003, DiagnosticCategory.Message, \"Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6003\", \"Specify the location where debugger should locate map files instead of generated locations.\"),\r\n        Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: diag(6004, DiagnosticCategory.Message, \"Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004\", \"Specify the location where debugger should locate TypeScript files instead of source locations.\"),\r\n        Watch_input_files: diag(6005, DiagnosticCategory.Message, \"Watch_input_files_6005\", \"Watch input files.\"),\r\n        Redirect_output_structure_to_the_directory: diag(6006, DiagnosticCategory.Message, \"Redirect_output_structure_to_the_directory_6006\", \"Redirect output structure to the directory.\"),\r\n        Do_not_erase_const_enum_declarations_in_generated_code: diag(6007, DiagnosticCategory.Message, \"Do_not_erase_const_enum_declarations_in_generated_code_6007\", \"Do not erase const enum declarations in generated code.\"),\r\n        Do_not_emit_outputs_if_any_errors_were_reported: diag(6008, DiagnosticCategory.Message, \"Do_not_emit_outputs_if_any_errors_were_reported_6008\", \"Do not emit outputs if any errors were reported.\"),\r\n        Do_not_emit_comments_to_output: diag(6009, DiagnosticCategory.Message, \"Do_not_emit_comments_to_output_6009\", \"Do not emit comments to output.\"),\r\n        Do_not_emit_outputs: diag(6010, DiagnosticCategory.Message, \"Do_not_emit_outputs_6010\", \"Do not emit outputs.\"),\r\n        Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: diag(6011, DiagnosticCategory.Message, \"Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011\", \"Allow default imports from modules with no default export. This does not affect code emit, just typechecking.\"),\r\n        Skip_type_checking_of_declaration_files: diag(6012, DiagnosticCategory.Message, \"Skip_type_checking_of_declaration_files_6012\", \"Skip type checking of declaration files.\"),\r\n        Do_not_resolve_the_real_path_of_symlinks: diag(6013, DiagnosticCategory.Message, \"Do_not_resolve_the_real_path_of_symlinks_6013\", \"Do not resolve the real path of symlinks.\"),\r\n        Only_emit_d_ts_declaration_files: diag(6014, DiagnosticCategory.Message, \"Only_emit_d_ts_declaration_files_6014\", \"Only emit '.d.ts' declaration files.\"),\r\n        Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_ES2018_or_ESNEXT: diag(6015, DiagnosticCategory.Message, \"Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_ES2018_or_ESNEXT_6015\", \"Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'.\"),\r\n        Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_or_ESNext: diag(6016, DiagnosticCategory.Message, \"Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_or_ESNext_6016\", \"Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'.\"),\r\n        Print_this_message: diag(6017, DiagnosticCategory.Message, \"Print_this_message_6017\", \"Print this message.\"),\r\n        Print_the_compiler_s_version: diag(6019, DiagnosticCategory.Message, \"Print_the_compiler_s_version_6019\", \"Print the compiler's version.\"),\r\n        Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: diag(6020, DiagnosticCategory.Message, \"Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020\", \"Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'.\"),\r\n        Syntax_Colon_0: diag(6023, DiagnosticCategory.Message, \"Syntax_Colon_0_6023\", \"Syntax: {0}\"),\r\n        options: diag(6024, DiagnosticCategory.Message, \"options_6024\", \"options\"),\r\n        file: diag(6025, DiagnosticCategory.Message, \"file_6025\", \"file\"),\r\n        Examples_Colon_0: diag(6026, DiagnosticCategory.Message, \"Examples_Colon_0_6026\", \"Examples: {0}\"),\r\n        Options_Colon: diag(6027, DiagnosticCategory.Message, \"Options_Colon_6027\", \"Options:\"),\r\n        Version_0: diag(6029, DiagnosticCategory.Message, \"Version_0_6029\", \"Version {0}\"),\r\n        Insert_command_line_options_and_files_from_a_file: diag(6030, DiagnosticCategory.Message, \"Insert_command_line_options_and_files_from_a_file_6030\", \"Insert command line options and files from a file.\"),\r\n        Starting_compilation_in_watch_mode: diag(6031, DiagnosticCategory.Message, \"Starting_compilation_in_watch_mode_6031\", \"Starting compilation in watch mode...\"),\r\n        File_change_detected_Starting_incremental_compilation: diag(6032, DiagnosticCategory.Message, \"File_change_detected_Starting_incremental_compilation_6032\", \"File change detected. Starting incremental compilation...\"),\r\n        KIND: diag(6034, DiagnosticCategory.Message, \"KIND_6034\", \"KIND\"),\r\n        FILE: diag(6035, DiagnosticCategory.Message, \"FILE_6035\", \"FILE\"),\r\n        VERSION: diag(6036, DiagnosticCategory.Message, \"VERSION_6036\", \"VERSION\"),\r\n        LOCATION: diag(6037, DiagnosticCategory.Message, \"LOCATION_6037\", \"LOCATION\"),\r\n        DIRECTORY: diag(6038, DiagnosticCategory.Message, \"DIRECTORY_6038\", \"DIRECTORY\"),\r\n        STRATEGY: diag(6039, DiagnosticCategory.Message, \"STRATEGY_6039\", \"STRATEGY\"),\r\n        FILE_OR_DIRECTORY: diag(6040, DiagnosticCategory.Message, \"FILE_OR_DIRECTORY_6040\", \"FILE OR DIRECTORY\"),\r\n        Generates_corresponding_map_file: diag(6043, DiagnosticCategory.Message, \"Generates_corresponding_map_file_6043\", \"Generates corresponding '.map' file.\"),\r\n        Compiler_option_0_expects_an_argument: diag(6044, DiagnosticCategory.Error, \"Compiler_option_0_expects_an_argument_6044\", \"Compiler option '{0}' expects an argument.\"),\r\n        Unterminated_quoted_string_in_response_file_0: diag(6045, DiagnosticCategory.Error, \"Unterminated_quoted_string_in_response_file_0_6045\", \"Unterminated quoted string in response file '{0}'.\"),\r\n        Argument_for_0_option_must_be_Colon_1: diag(6046, DiagnosticCategory.Error, \"Argument_for_0_option_must_be_Colon_1_6046\", \"Argument for '{0}' option must be: {1}.\"),\r\n        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: diag(6048, DiagnosticCategory.Error, \"Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048\", \"Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.\"),\r\n        Unsupported_locale_0: diag(6049, DiagnosticCategory.Error, \"Unsupported_locale_0_6049\", \"Unsupported locale '{0}'.\"),\r\n        Unable_to_open_file_0: diag(6050, DiagnosticCategory.Error, \"Unable_to_open_file_0_6050\", \"Unable to open file '{0}'.\"),\r\n        Corrupted_locale_file_0: diag(6051, DiagnosticCategory.Error, \"Corrupted_locale_file_0_6051\", \"Corrupted locale file {0}.\"),\r\n        Raise_error_on_expressions_and_declarations_with_an_implied_any_type: diag(6052, DiagnosticCategory.Message, \"Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052\", \"Raise error on expressions and declarations with an implied 'any' type.\"),\r\n        File_0_not_found: diag(6053, DiagnosticCategory.Error, \"File_0_not_found_6053\", \"File '{0}' not found.\"),\r\n        File_0_has_unsupported_extension_The_only_supported_extensions_are_1: diag(6054, DiagnosticCategory.Error, \"File_0_has_unsupported_extension_The_only_supported_extensions_are_1_6054\", \"File '{0}' has unsupported extension. The only supported extensions are {1}.\"),\r\n        Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: diag(6055, DiagnosticCategory.Message, \"Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055\", \"Suppress noImplicitAny errors for indexing objects lacking index signatures.\"),\r\n        Do_not_emit_declarations_for_code_that_has_an_internal_annotation: diag(6056, DiagnosticCategory.Message, \"Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056\", \"Do not emit declarations for code that has an '@internal' annotation.\"),\r\n        Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: diag(6058, DiagnosticCategory.Message, \"Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058\", \"Specify the root directory of input files. Use to control the output directory structure with --outDir.\"),\r\n        File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: diag(6059, DiagnosticCategory.Error, \"File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059\", \"File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.\"),\r\n        Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: diag(6060, DiagnosticCategory.Message, \"Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060\", \"Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).\"),\r\n        NEWLINE: diag(6061, DiagnosticCategory.Message, \"NEWLINE_6061\", \"NEWLINE\"),\r\n        Option_0_can_only_be_specified_in_tsconfig_json_file: diag(6064, DiagnosticCategory.Error, \"Option_0_can_only_be_specified_in_tsconfig_json_file_6064\", \"Option '{0}' can only be specified in 'tsconfig.json' file.\"),\r\n        Enables_experimental_support_for_ES7_decorators: diag(6065, DiagnosticCategory.Message, \"Enables_experimental_support_for_ES7_decorators_6065\", \"Enables experimental support for ES7 decorators.\"),\r\n        Enables_experimental_support_for_emitting_type_metadata_for_decorators: diag(6066, DiagnosticCategory.Message, \"Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066\", \"Enables experimental support for emitting type metadata for decorators.\"),\r\n        Enables_experimental_support_for_ES7_async_functions: diag(6068, DiagnosticCategory.Message, \"Enables_experimental_support_for_ES7_async_functions_6068\", \"Enables experimental support for ES7 async functions.\"),\r\n        Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6: diag(6069, DiagnosticCategory.Message, \"Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069\", \"Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6).\"),\r\n        Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: diag(6070, DiagnosticCategory.Message, \"Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070\", \"Initializes a TypeScript project and creates a tsconfig.json file.\"),\r\n        Successfully_created_a_tsconfig_json_file: diag(6071, DiagnosticCategory.Message, \"Successfully_created_a_tsconfig_json_file_6071\", \"Successfully created a tsconfig.json file.\"),\r\n        Suppress_excess_property_checks_for_object_literals: diag(6072, DiagnosticCategory.Message, \"Suppress_excess_property_checks_for_object_literals_6072\", \"Suppress excess property checks for object literals.\"),\r\n        Stylize_errors_and_messages_using_color_and_context_experimental: diag(6073, DiagnosticCategory.Message, \"Stylize_errors_and_messages_using_color_and_context_experimental_6073\", \"Stylize errors and messages using color and context (experimental).\"),\r\n        Do_not_report_errors_on_unused_labels: diag(6074, DiagnosticCategory.Message, \"Do_not_report_errors_on_unused_labels_6074\", \"Do not report errors on unused labels.\"),\r\n        Report_error_when_not_all_code_paths_in_function_return_a_value: diag(6075, DiagnosticCategory.Message, \"Report_error_when_not_all_code_paths_in_function_return_a_value_6075\", \"Report error when not all code paths in function return a value.\"),\r\n        Report_errors_for_fallthrough_cases_in_switch_statement: diag(6076, DiagnosticCategory.Message, \"Report_errors_for_fallthrough_cases_in_switch_statement_6076\", \"Report errors for fallthrough cases in switch statement.\"),\r\n        Do_not_report_errors_on_unreachable_code: diag(6077, DiagnosticCategory.Message, \"Do_not_report_errors_on_unreachable_code_6077\", \"Do not report errors on unreachable code.\"),\r\n        Disallow_inconsistently_cased_references_to_the_same_file: diag(6078, DiagnosticCategory.Message, \"Disallow_inconsistently_cased_references_to_the_same_file_6078\", \"Disallow inconsistently-cased references to the same file.\"),\r\n        Specify_library_files_to_be_included_in_the_compilation: diag(6079, DiagnosticCategory.Message, \"Specify_library_files_to_be_included_in_the_compilation_6079\", \"Specify library files to be included in the compilation.\"),\r\n        Specify_JSX_code_generation_Colon_preserve_react_native_or_react: diag(6080, DiagnosticCategory.Message, \"Specify_JSX_code_generation_Colon_preserve_react_native_or_react_6080\", \"Specify JSX code generation: 'preserve', 'react-native', or 'react'.\"),\r\n        File_0_has_an_unsupported_extension_so_skipping_it: diag(6081, DiagnosticCategory.Message, \"File_0_has_an_unsupported_extension_so_skipping_it_6081\", \"File '{0}' has an unsupported extension, so skipping it.\"),\r\n        Only_amd_and_system_modules_are_supported_alongside_0: diag(6082, DiagnosticCategory.Error, \"Only_amd_and_system_modules_are_supported_alongside_0_6082\", \"Only 'amd' and 'system' modules are supported alongside --{0}.\"),\r\n        Base_directory_to_resolve_non_absolute_module_names: diag(6083, DiagnosticCategory.Message, \"Base_directory_to_resolve_non_absolute_module_names_6083\", \"Base directory to resolve non-absolute module names.\"),\r\n        Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: diag(6084, DiagnosticCategory.Message, \"Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084\", \"[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit\"),\r\n        Enable_tracing_of_the_name_resolution_process: diag(6085, DiagnosticCategory.Message, \"Enable_tracing_of_the_name_resolution_process_6085\", \"Enable tracing of the name resolution process.\"),\r\n        Resolving_module_0_from_1: diag(6086, DiagnosticCategory.Message, \"Resolving_module_0_from_1_6086\", \"======== Resolving module '{0}' from '{1}'. ========\"),\r\n        Explicitly_specified_module_resolution_kind_Colon_0: diag(6087, DiagnosticCategory.Message, \"Explicitly_specified_module_resolution_kind_Colon_0_6087\", \"Explicitly specified module resolution kind: '{0}'.\"),\r\n        Module_resolution_kind_is_not_specified_using_0: diag(6088, DiagnosticCategory.Message, \"Module_resolution_kind_is_not_specified_using_0_6088\", \"Module resolution kind is not specified, using '{0}'.\"),\r\n        Module_name_0_was_successfully_resolved_to_1: diag(6089, DiagnosticCategory.Message, \"Module_name_0_was_successfully_resolved_to_1_6089\", \"======== Module name '{0}' was successfully resolved to '{1}'. ========\"),\r\n        Module_name_0_was_not_resolved: diag(6090, DiagnosticCategory.Message, \"Module_name_0_was_not_resolved_6090\", \"======== Module name '{0}' was not resolved. ========\"),\r\n        paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: diag(6091, DiagnosticCategory.Message, \"paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091\", \"'paths' option is specified, looking for a pattern to match module name '{0}'.\"),\r\n        Module_name_0_matched_pattern_1: diag(6092, DiagnosticCategory.Message, \"Module_name_0_matched_pattern_1_6092\", \"Module name '{0}', matched pattern '{1}'.\"),\r\n        Trying_substitution_0_candidate_module_location_Colon_1: diag(6093, DiagnosticCategory.Message, \"Trying_substitution_0_candidate_module_location_Colon_1_6093\", \"Trying substitution '{0}', candidate module location: '{1}'.\"),\r\n        Resolving_module_name_0_relative_to_base_url_1_2: diag(6094, DiagnosticCategory.Message, \"Resolving_module_name_0_relative_to_base_url_1_2_6094\", \"Resolving module name '{0}' relative to base url '{1}' - '{2}'.\"),\r\n        Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1: diag(6095, DiagnosticCategory.Message, \"Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1_6095\", \"Loading module as file / folder, candidate module location '{0}', target file type '{1}'.\"),\r\n        File_0_does_not_exist: diag(6096, DiagnosticCategory.Message, \"File_0_does_not_exist_6096\", \"File '{0}' does not exist.\"),\r\n        File_0_exist_use_it_as_a_name_resolution_result: diag(6097, DiagnosticCategory.Message, \"File_0_exist_use_it_as_a_name_resolution_result_6097\", \"File '{0}' exist - use it as a name resolution result.\"),\r\n        Loading_module_0_from_node_modules_folder_target_file_type_1: diag(6098, DiagnosticCategory.Message, \"Loading_module_0_from_node_modules_folder_target_file_type_1_6098\", \"Loading module '{0}' from 'node_modules' folder, target file type '{1}'.\"),\r\n        Found_package_json_at_0: diag(6099, DiagnosticCategory.Message, \"Found_package_json_at_0_6099\", \"Found 'package.json' at '{0}'.\"),\r\n        package_json_does_not_have_a_0_field: diag(6100, DiagnosticCategory.Message, \"package_json_does_not_have_a_0_field_6100\", \"'package.json' does not have a '{0}' field.\"),\r\n        package_json_has_0_field_1_that_references_2: diag(6101, DiagnosticCategory.Message, \"package_json_has_0_field_1_that_references_2_6101\", \"'package.json' has '{0}' field '{1}' that references '{2}'.\"),\r\n        Allow_javascript_files_to_be_compiled: diag(6102, DiagnosticCategory.Message, \"Allow_javascript_files_to_be_compiled_6102\", \"Allow javascript files to be compiled.\"),\r\n        Option_0_should_have_array_of_strings_as_a_value: diag(6103, DiagnosticCategory.Error, \"Option_0_should_have_array_of_strings_as_a_value_6103\", \"Option '{0}' should have array of strings as a value.\"),\r\n        Checking_if_0_is_the_longest_matching_prefix_for_1_2: diag(6104, DiagnosticCategory.Message, \"Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104\", \"Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'.\"),\r\n        Expected_type_of_0_field_in_package_json_to_be_string_got_1: diag(6105, DiagnosticCategory.Message, \"Expected_type_of_0_field_in_package_json_to_be_string_got_1_6105\", \"Expected type of '{0}' field in 'package.json' to be 'string', got '{1}'.\"),\r\n        baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: diag(6106, DiagnosticCategory.Message, \"baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106\", \"'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'.\"),\r\n        rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: diag(6107, DiagnosticCategory.Message, \"rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107\", \"'rootDirs' option is set, using it to resolve relative module name '{0}'.\"),\r\n        Longest_matching_prefix_for_0_is_1: diag(6108, DiagnosticCategory.Message, \"Longest_matching_prefix_for_0_is_1_6108\", \"Longest matching prefix for '{0}' is '{1}'.\"),\r\n        Loading_0_from_the_root_dir_1_candidate_location_2: diag(6109, DiagnosticCategory.Message, \"Loading_0_from_the_root_dir_1_candidate_location_2_6109\", \"Loading '{0}' from the root dir '{1}', candidate location '{2}'.\"),\r\n        Trying_other_entries_in_rootDirs: diag(6110, DiagnosticCategory.Message, \"Trying_other_entries_in_rootDirs_6110\", \"Trying other entries in 'rootDirs'.\"),\r\n        Module_resolution_using_rootDirs_has_failed: diag(6111, DiagnosticCategory.Message, \"Module_resolution_using_rootDirs_has_failed_6111\", \"Module resolution using 'rootDirs' has failed.\"),\r\n        Do_not_emit_use_strict_directives_in_module_output: diag(6112, DiagnosticCategory.Message, \"Do_not_emit_use_strict_directives_in_module_output_6112\", \"Do not emit 'use strict' directives in module output.\"),\r\n        Enable_strict_null_checks: diag(6113, DiagnosticCategory.Message, \"Enable_strict_null_checks_6113\", \"Enable strict null checks.\"),\r\n        Unknown_option_excludes_Did_you_mean_exclude: diag(6114, DiagnosticCategory.Error, \"Unknown_option_excludes_Did_you_mean_exclude_6114\", \"Unknown option 'excludes'. Did you mean 'exclude'?\"),\r\n        Raise_error_on_this_expressions_with_an_implied_any_type: diag(6115, DiagnosticCategory.Message, \"Raise_error_on_this_expressions_with_an_implied_any_type_6115\", \"Raise error on 'this' expressions with an implied 'any' type.\"),\r\n        Resolving_type_reference_directive_0_containing_file_1_root_directory_2: diag(6116, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116\", \"======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========\"),\r\n        Resolving_using_primary_search_paths: diag(6117, DiagnosticCategory.Message, \"Resolving_using_primary_search_paths_6117\", \"Resolving using primary search paths...\"),\r\n        Resolving_from_node_modules_folder: diag(6118, DiagnosticCategory.Message, \"Resolving_from_node_modules_folder_6118\", \"Resolving from node_modules folder...\"),\r\n        Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: diag(6119, DiagnosticCategory.Message, \"Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119\", \"======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========\"),\r\n        Type_reference_directive_0_was_not_resolved: diag(6120, DiagnosticCategory.Message, \"Type_reference_directive_0_was_not_resolved_6120\", \"======== Type reference directive '{0}' was not resolved. ========\"),\r\n        Resolving_with_primary_search_path_0: diag(6121, DiagnosticCategory.Message, \"Resolving_with_primary_search_path_0_6121\", \"Resolving with primary search path '{0}'.\"),\r\n        Root_directory_cannot_be_determined_skipping_primary_search_paths: diag(6122, DiagnosticCategory.Message, \"Root_directory_cannot_be_determined_skipping_primary_search_paths_6122\", \"Root directory cannot be determined, skipping primary search paths.\"),\r\n        Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: diag(6123, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123\", \"======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========\"),\r\n        Type_declaration_files_to_be_included_in_compilation: diag(6124, DiagnosticCategory.Message, \"Type_declaration_files_to_be_included_in_compilation_6124\", \"Type declaration files to be included in compilation.\"),\r\n        Looking_up_in_node_modules_folder_initial_location_0: diag(6125, DiagnosticCategory.Message, \"Looking_up_in_node_modules_folder_initial_location_0_6125\", \"Looking up in 'node_modules' folder, initial location '{0}'.\"),\r\n        Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: diag(6126, DiagnosticCategory.Message, \"Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126\", \"Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder.\"),\r\n        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: diag(6127, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127\", \"======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========\"),\r\n        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: diag(6128, DiagnosticCategory.Message, \"Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128\", \"======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========\"),\r\n        Resolving_real_path_for_0_result_1: diag(6130, DiagnosticCategory.Message, \"Resolving_real_path_for_0_result_1_6130\", \"Resolving real path for '{0}', result '{1}'.\"),\r\n        Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: diag(6131, DiagnosticCategory.Error, \"Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131\", \"Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'.\"),\r\n        File_name_0_has_a_1_extension_stripping_it: diag(6132, DiagnosticCategory.Message, \"File_name_0_has_a_1_extension_stripping_it_6132\", \"File name '{0}' has a '{1}' extension - stripping it.\"),\r\n        _0_is_declared_but_its_value_is_never_read: diag(6133, DiagnosticCategory.Error, \"_0_is_declared_but_its_value_is_never_read_6133\", \"'{0}' is declared but its value is never read.\", /*reportsUnnecessary*/ true),\r\n        Report_errors_on_unused_locals: diag(6134, DiagnosticCategory.Message, \"Report_errors_on_unused_locals_6134\", \"Report errors on unused locals.\"),\r\n        Report_errors_on_unused_parameters: diag(6135, DiagnosticCategory.Message, \"Report_errors_on_unused_parameters_6135\", \"Report errors on unused parameters.\"),\r\n        The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: diag(6136, DiagnosticCategory.Message, \"The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136\", \"The maximum dependency depth to search under node_modules and load JavaScript files.\"),\r\n        Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: diag(6137, DiagnosticCategory.Error, \"Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137\", \"Cannot import type declaration files. Consider importing '{0}' instead of '{1}'.\"),\r\n        Property_0_is_declared_but_its_value_is_never_read: diag(6138, DiagnosticCategory.Error, \"Property_0_is_declared_but_its_value_is_never_read_6138\", \"Property '{0}' is declared but its value is never read.\", /*reportsUnnecessary*/ true),\r\n        Import_emit_helpers_from_tslib: diag(6139, DiagnosticCategory.Message, \"Import_emit_helpers_from_tslib_6139\", \"Import emit helpers from 'tslib'.\"),\r\n        Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: diag(6140, DiagnosticCategory.Error, \"Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140\", \"Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'.\"),\r\n        Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: diag(6141, DiagnosticCategory.Message, \"Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141\", \"Parse in strict mode and emit \\\"use strict\\\" for each source file.\"),\r\n        Module_0_was_resolved_to_1_but_jsx_is_not_set: diag(6142, DiagnosticCategory.Error, \"Module_0_was_resolved_to_1_but_jsx_is_not_set_6142\", \"Module '{0}' was resolved to '{1}', but '--jsx' is not set.\"),\r\n        Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: diag(6144, DiagnosticCategory.Message, \"Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144\", \"Module '{0}' was resolved as locally declared ambient module in file '{1}'.\"),\r\n        Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified: diag(6145, DiagnosticCategory.Message, \"Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145\", \"Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified.\"),\r\n        Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: diag(6146, DiagnosticCategory.Message, \"Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146\", \"Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'.\"),\r\n        Resolution_for_module_0_was_found_in_cache_from_location_1: diag(6147, DiagnosticCategory.Message, \"Resolution_for_module_0_was_found_in_cache_from_location_1_6147\", \"Resolution for module '{0}' was found in cache from location '{1}'.\"),\r\n        Directory_0_does_not_exist_skipping_all_lookups_in_it: diag(6148, DiagnosticCategory.Message, \"Directory_0_does_not_exist_skipping_all_lookups_in_it_6148\", \"Directory '{0}' does not exist, skipping all lookups in it.\"),\r\n        Show_diagnostic_information: diag(6149, DiagnosticCategory.Message, \"Show_diagnostic_information_6149\", \"Show diagnostic information.\"),\r\n        Show_verbose_diagnostic_information: diag(6150, DiagnosticCategory.Message, \"Show_verbose_diagnostic_information_6150\", \"Show verbose diagnostic information.\"),\r\n        Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: diag(6151, DiagnosticCategory.Message, \"Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151\", \"Emit a single file with source maps instead of having a separate file.\"),\r\n        Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: diag(6152, DiagnosticCategory.Message, \"Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152\", \"Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set.\"),\r\n        Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: diag(6153, DiagnosticCategory.Message, \"Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153\", \"Transpile each file as a separate module (similar to 'ts.transpileModule').\"),\r\n        Print_names_of_generated_files_part_of_the_compilation: diag(6154, DiagnosticCategory.Message, \"Print_names_of_generated_files_part_of_the_compilation_6154\", \"Print names of generated files part of the compilation.\"),\r\n        Print_names_of_files_part_of_the_compilation: diag(6155, DiagnosticCategory.Message, \"Print_names_of_files_part_of_the_compilation_6155\", \"Print names of files part of the compilation.\"),\r\n        The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: diag(6156, DiagnosticCategory.Message, \"The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156\", \"The locale used when displaying messages to the user (e.g. 'en-us')\"),\r\n        Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: diag(6157, DiagnosticCategory.Message, \"Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157\", \"Do not generate custom helper functions like '__extends' in compiled output.\"),\r\n        Do_not_include_the_default_library_file_lib_d_ts: diag(6158, DiagnosticCategory.Message, \"Do_not_include_the_default_library_file_lib_d_ts_6158\", \"Do not include the default library file (lib.d.ts).\"),\r\n        Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: diag(6159, DiagnosticCategory.Message, \"Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159\", \"Do not add triple-slash references or imported modules to the list of compiled files.\"),\r\n        Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: diag(6160, DiagnosticCategory.Message, \"Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160\", \"[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files.\"),\r\n        List_of_folders_to_include_type_definitions_from: diag(6161, DiagnosticCategory.Message, \"List_of_folders_to_include_type_definitions_from_6161\", \"List of folders to include type definitions from.\"),\r\n        Disable_size_limitations_on_JavaScript_projects: diag(6162, DiagnosticCategory.Message, \"Disable_size_limitations_on_JavaScript_projects_6162\", \"Disable size limitations on JavaScript projects.\"),\r\n        The_character_set_of_the_input_files: diag(6163, DiagnosticCategory.Message, \"The_character_set_of_the_input_files_6163\", \"The character set of the input files.\"),\r\n        Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: diag(6164, DiagnosticCategory.Message, \"Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6164\", \"Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.\"),\r\n        Do_not_truncate_error_messages: diag(6165, DiagnosticCategory.Message, \"Do_not_truncate_error_messages_6165\", \"Do not truncate error messages.\"),\r\n        Output_directory_for_generated_declaration_files: diag(6166, DiagnosticCategory.Message, \"Output_directory_for_generated_declaration_files_6166\", \"Output directory for generated declaration files.\"),\r\n        A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: diag(6167, DiagnosticCategory.Message, \"A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167\", \"A series of entries which re-map imports to lookup locations relative to the 'baseUrl'.\"),\r\n        List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: diag(6168, DiagnosticCategory.Message, \"List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168\", \"List of root folders whose combined content represents the structure of the project at runtime.\"),\r\n        Show_all_compiler_options: diag(6169, DiagnosticCategory.Message, \"Show_all_compiler_options_6169\", \"Show all compiler options.\"),\r\n        Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: diag(6170, DiagnosticCategory.Message, \"Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170\", \"[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file\"),\r\n        Command_line_Options: diag(6171, DiagnosticCategory.Message, \"Command_line_Options_6171\", \"Command-line Options\"),\r\n        Basic_Options: diag(6172, DiagnosticCategory.Message, \"Basic_Options_6172\", \"Basic Options\"),\r\n        Strict_Type_Checking_Options: diag(6173, DiagnosticCategory.Message, \"Strict_Type_Checking_Options_6173\", \"Strict Type-Checking Options\"),\r\n        Module_Resolution_Options: diag(6174, DiagnosticCategory.Message, \"Module_Resolution_Options_6174\", \"Module Resolution Options\"),\r\n        Source_Map_Options: diag(6175, DiagnosticCategory.Message, \"Source_Map_Options_6175\", \"Source Map Options\"),\r\n        Additional_Checks: diag(6176, DiagnosticCategory.Message, \"Additional_Checks_6176\", \"Additional Checks\"),\r\n        Experimental_Options: diag(6177, DiagnosticCategory.Message, \"Experimental_Options_6177\", \"Experimental Options\"),\r\n        Advanced_Options: diag(6178, DiagnosticCategory.Message, \"Advanced_Options_6178\", \"Advanced Options\"),\r\n        Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3: diag(6179, DiagnosticCategory.Message, \"Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179\", \"Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'.\"),\r\n        Enable_all_strict_type_checking_options: diag(6180, DiagnosticCategory.Message, \"Enable_all_strict_type_checking_options_6180\", \"Enable all strict type-checking options.\"),\r\n        List_of_language_service_plugins: diag(6181, DiagnosticCategory.Message, \"List_of_language_service_plugins_6181\", \"List of language service plugins.\"),\r\n        Scoped_package_detected_looking_in_0: diag(6182, DiagnosticCategory.Message, \"Scoped_package_detected_looking_in_0_6182\", \"Scoped package detected, looking in '{0}'\"),\r\n        Reusing_resolution_of_module_0_to_file_1_from_old_program: diag(6183, DiagnosticCategory.Message, \"Reusing_resolution_of_module_0_to_file_1_from_old_program_6183\", \"Reusing resolution of module '{0}' to file '{1}' from old program.\"),\r\n        Reusing_module_resolutions_originating_in_0_since_resolutions_are_unchanged_from_old_program: diag(6184, DiagnosticCategory.Message, \"Reusing_module_resolutions_originating_in_0_since_resolutions_are_unchanged_from_old_program_6184\", \"Reusing module resolutions originating in '{0}' since resolutions are unchanged from old program.\"),\r\n        Disable_strict_checking_of_generic_signatures_in_function_types: diag(6185, DiagnosticCategory.Message, \"Disable_strict_checking_of_generic_signatures_in_function_types_6185\", \"Disable strict checking of generic signatures in function types.\"),\r\n        Enable_strict_checking_of_function_types: diag(6186, DiagnosticCategory.Message, \"Enable_strict_checking_of_function_types_6186\", \"Enable strict checking of function types.\"),\r\n        Enable_strict_checking_of_property_initialization_in_classes: diag(6187, DiagnosticCategory.Message, \"Enable_strict_checking_of_property_initialization_in_classes_6187\", \"Enable strict checking of property initialization in classes.\"),\r\n        Numeric_separators_are_not_allowed_here: diag(6188, DiagnosticCategory.Error, \"Numeric_separators_are_not_allowed_here_6188\", \"Numeric separators are not allowed here.\"),\r\n        Multiple_consecutive_numeric_separators_are_not_permitted: diag(6189, DiagnosticCategory.Error, \"Multiple_consecutive_numeric_separators_are_not_permitted_6189\", \"Multiple consecutive numeric separators are not permitted.\"),\r\n        Found_package_json_at_0_Package_ID_is_1: diag(6190, DiagnosticCategory.Message, \"Found_package_json_at_0_Package_ID_is_1_6190\", \"Found 'package.json' at '{0}'. Package ID is '{1}'.\"),\r\n        Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen: diag(6191, DiagnosticCategory.Message, \"Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191\", \"Whether to keep outdated console output in watch mode instead of clearing the screen.\"),\r\n        All_imports_in_import_declaration_are_unused: diag(6192, DiagnosticCategory.Error, \"All_imports_in_import_declaration_are_unused_6192\", \"All imports in import declaration are unused.\", /*reportsUnnecessary*/ true),\r\n        Found_1_error_Watching_for_file_changes: diag(6193, DiagnosticCategory.Message, \"Found_1_error_Watching_for_file_changes_6193\", \"Found 1 error. Watching for file changes.\"),\r\n        Found_0_errors_Watching_for_file_changes: diag(6194, DiagnosticCategory.Message, \"Found_0_errors_Watching_for_file_changes_6194\", \"Found {0} errors. Watching for file changes.\"),\r\n        Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols: diag(6195, DiagnosticCategory.Message, \"Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195\", \"Resolve 'keyof' to string valued property names only (no numbers or symbols).\"),\r\n        _0_is_declared_but_never_used: diag(6196, DiagnosticCategory.Error, \"_0_is_declared_but_never_used_6196\", \"'{0}' is declared but never used.\", /*reportsUnnecessary*/ true),\r\n        Variable_0_implicitly_has_an_1_type: diag(7005, DiagnosticCategory.Error, \"Variable_0_implicitly_has_an_1_type_7005\", \"Variable '{0}' implicitly has an '{1}' type.\"),\r\n        Parameter_0_implicitly_has_an_1_type: diag(7006, DiagnosticCategory.Error, \"Parameter_0_implicitly_has_an_1_type_7006\", \"Parameter '{0}' implicitly has an '{1}' type.\"),\r\n        Member_0_implicitly_has_an_1_type: diag(7008, DiagnosticCategory.Error, \"Member_0_implicitly_has_an_1_type_7008\", \"Member '{0}' implicitly has an '{1}' type.\"),\r\n        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: diag(7009, DiagnosticCategory.Error, \"new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009\", \"'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.\"),\r\n        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: diag(7010, DiagnosticCategory.Error, \"_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010\", \"'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.\"),\r\n        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: diag(7011, DiagnosticCategory.Error, \"Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011\", \"Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.\"),\r\n        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7013, DiagnosticCategory.Error, \"Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013\", \"Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.\"),\r\n        Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: diag(7015, DiagnosticCategory.Error, \"Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015\", \"Element implicitly has an 'any' type because index expression is not of type 'number'.\"),\r\n        Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: diag(7016, DiagnosticCategory.Error, \"Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016\", \"Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type.\"),\r\n        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: diag(7017, DiagnosticCategory.Error, \"Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017\", \"Element implicitly has an 'any' type because type '{0}' has no index signature.\"),\r\n        Object_literal_s_property_0_implicitly_has_an_1_type: diag(7018, DiagnosticCategory.Error, \"Object_literal_s_property_0_implicitly_has_an_1_type_7018\", \"Object literal's property '{0}' implicitly has an '{1}' type.\"),\r\n        Rest_parameter_0_implicitly_has_an_any_type: diag(7019, DiagnosticCategory.Error, \"Rest_parameter_0_implicitly_has_an_any_type_7019\", \"Rest parameter '{0}' implicitly has an 'any[]' type.\"),\r\n        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7020, DiagnosticCategory.Error, \"Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020\", \"Call signature, which lacks return-type annotation, implicitly has an 'any' return type.\"),\r\n        _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: diag(7022, DiagnosticCategory.Error, \"_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022\", \"'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.\"),\r\n        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7023, DiagnosticCategory.Error, \"_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023\", \"'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\"),\r\n        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7024, DiagnosticCategory.Error, \"Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024\", \"Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\"),\r\n        Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type: diag(7025, DiagnosticCategory.Error, \"Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_typ_7025\", \"Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.\"),\r\n        JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: diag(7026, DiagnosticCategory.Error, \"JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026\", \"JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists.\"),\r\n        Unreachable_code_detected: diag(7027, DiagnosticCategory.Error, \"Unreachable_code_detected_7027\", \"Unreachable code detected.\"),\r\n        Unused_label: diag(7028, DiagnosticCategory.Error, \"Unused_label_7028\", \"Unused label.\", /*reportsUnnecessary*/ true),\r\n        Fallthrough_case_in_switch: diag(7029, DiagnosticCategory.Error, \"Fallthrough_case_in_switch_7029\", \"Fallthrough case in switch.\"),\r\n        Not_all_code_paths_return_a_value: diag(7030, DiagnosticCategory.Error, \"Not_all_code_paths_return_a_value_7030\", \"Not all code paths return a value.\"),\r\n        Binding_element_0_implicitly_has_an_1_type: diag(7031, DiagnosticCategory.Error, \"Binding_element_0_implicitly_has_an_1_type_7031\", \"Binding element '{0}' implicitly has an '{1}' type.\"),\r\n        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: diag(7032, DiagnosticCategory.Error, \"Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032\", \"Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation.\"),\r\n        Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: diag(7033, DiagnosticCategory.Error, \"Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033\", \"Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation.\"),\r\n        Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: diag(7034, DiagnosticCategory.Error, \"Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034\", \"Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined.\"),\r\n        Try_npm_install_types_Slash_0_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: diag(7035, DiagnosticCategory.Error, \"Try_npm_install_types_Slash_0_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_mod_7035\", \"Try `npm install @types/{0}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`\"),\r\n        Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: diag(7036, DiagnosticCategory.Error, \"Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036\", \"Dynamic import's specifier must be of type 'string', but here has type '{0}'.\"),\r\n        Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports: diag(7037, DiagnosticCategory.Message, \"Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037\", \"Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'.\"),\r\n        A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime: diag(7038, DiagnosticCategory.Error, \"A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_7038\", \"A namespace-style import cannot be called or constructed, and will cause a failure at runtime.\"),\r\n        Mapped_object_type_implicitly_has_an_any_template_type: diag(7039, DiagnosticCategory.Error, \"Mapped_object_type_implicitly_has_an_any_template_type_7039\", \"Mapped object type implicitly has an 'any' template type.\"),\r\n        You_cannot_rename_this_element: diag(8000, DiagnosticCategory.Error, \"You_cannot_rename_this_element_8000\", \"You cannot rename this element.\"),\r\n        You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: diag(8001, DiagnosticCategory.Error, \"You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001\", \"You cannot rename elements that are defined in the standard TypeScript library.\"),\r\n        import_can_only_be_used_in_a_ts_file: diag(8002, DiagnosticCategory.Error, \"import_can_only_be_used_in_a_ts_file_8002\", \"'import ... =' can only be used in a .ts file.\"),\r\n        export_can_only_be_used_in_a_ts_file: diag(8003, DiagnosticCategory.Error, \"export_can_only_be_used_in_a_ts_file_8003\", \"'export=' can only be used in a .ts file.\"),\r\n        type_parameter_declarations_can_only_be_used_in_a_ts_file: diag(8004, DiagnosticCategory.Error, \"type_parameter_declarations_can_only_be_used_in_a_ts_file_8004\", \"'type parameter declarations' can only be used in a .ts file.\"),\r\n        implements_clauses_can_only_be_used_in_a_ts_file: diag(8005, DiagnosticCategory.Error, \"implements_clauses_can_only_be_used_in_a_ts_file_8005\", \"'implements clauses' can only be used in a .ts file.\"),\r\n        interface_declarations_can_only_be_used_in_a_ts_file: diag(8006, DiagnosticCategory.Error, \"interface_declarations_can_only_be_used_in_a_ts_file_8006\", \"'interface declarations' can only be used in a .ts file.\"),\r\n        module_declarations_can_only_be_used_in_a_ts_file: diag(8007, DiagnosticCategory.Error, \"module_declarations_can_only_be_used_in_a_ts_file_8007\", \"'module declarations' can only be used in a .ts file.\"),\r\n        type_aliases_can_only_be_used_in_a_ts_file: diag(8008, DiagnosticCategory.Error, \"type_aliases_can_only_be_used_in_a_ts_file_8008\", \"'type aliases' can only be used in a .ts file.\"),\r\n        _0_can_only_be_used_in_a_ts_file: diag(8009, DiagnosticCategory.Error, \"_0_can_only_be_used_in_a_ts_file_8009\", \"'{0}' can only be used in a .ts file.\"),\r\n        types_can_only_be_used_in_a_ts_file: diag(8010, DiagnosticCategory.Error, \"types_can_only_be_used_in_a_ts_file_8010\", \"'types' can only be used in a .ts file.\"),\r\n        type_arguments_can_only_be_used_in_a_ts_file: diag(8011, DiagnosticCategory.Error, \"type_arguments_can_only_be_used_in_a_ts_file_8011\", \"'type arguments' can only be used in a .ts file.\"),\r\n        parameter_modifiers_can_only_be_used_in_a_ts_file: diag(8012, DiagnosticCategory.Error, \"parameter_modifiers_can_only_be_used_in_a_ts_file_8012\", \"'parameter modifiers' can only be used in a .ts file.\"),\r\n        non_null_assertions_can_only_be_used_in_a_ts_file: diag(8013, DiagnosticCategory.Error, \"non_null_assertions_can_only_be_used_in_a_ts_file_8013\", \"'non-null assertions' can only be used in a .ts file.\"),\r\n        enum_declarations_can_only_be_used_in_a_ts_file: diag(8015, DiagnosticCategory.Error, \"enum_declarations_can_only_be_used_in_a_ts_file_8015\", \"'enum declarations' can only be used in a .ts file.\"),\r\n        type_assertion_expressions_can_only_be_used_in_a_ts_file: diag(8016, DiagnosticCategory.Error, \"type_assertion_expressions_can_only_be_used_in_a_ts_file_8016\", \"'type assertion expressions' can only be used in a .ts file.\"),\r\n        Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0: diag(8017, DiagnosticCategory.Error, \"Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0_8017\", \"Octal literal types must use ES2015 syntax. Use the syntax '{0}'.\"),\r\n        Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0: diag(8018, DiagnosticCategory.Error, \"Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0_8018\", \"Octal literals are not allowed in enums members initializer. Use the syntax '{0}'.\"),\r\n        Report_errors_in_js_files: diag(8019, DiagnosticCategory.Message, \"Report_errors_in_js_files_8019\", \"Report errors in .js files.\"),\r\n        JSDoc_types_can_only_be_used_inside_documentation_comments: diag(8020, DiagnosticCategory.Error, \"JSDoc_types_can_only_be_used_inside_documentation_comments_8020\", \"JSDoc types can only be used inside documentation comments.\"),\r\n        JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: diag(8021, DiagnosticCategory.Error, \"JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021\", \"JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags.\"),\r\n        JSDoc_0_is_not_attached_to_a_class: diag(8022, DiagnosticCategory.Error, \"JSDoc_0_is_not_attached_to_a_class_8022\", \"JSDoc '@{0}' is not attached to a class.\"),\r\n        JSDoc_0_1_does_not_match_the_extends_2_clause: diag(8023, DiagnosticCategory.Error, \"JSDoc_0_1_does_not_match_the_extends_2_clause_8023\", \"JSDoc '@{0} {1}' does not match the 'extends {2}' clause.\"),\r\n        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: diag(8024, DiagnosticCategory.Error, \"JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024\", \"JSDoc '@param' tag has name '{0}', but there is no parameter with that name.\"),\r\n        Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: diag(8025, DiagnosticCategory.Error, \"Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025\", \"Class declarations cannot have more than one `@augments` or `@extends` tag.\"),\r\n        Expected_0_type_arguments_provide_these_with_an_extends_tag: diag(8026, DiagnosticCategory.Error, \"Expected_0_type_arguments_provide_these_with_an_extends_tag_8026\", \"Expected {0} type arguments; provide these with an '@extends' tag.\"),\r\n        Expected_0_1_type_arguments_provide_these_with_an_extends_tag: diag(8027, DiagnosticCategory.Error, \"Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027\", \"Expected {0}-{1} type arguments; provide these with an '@extends' tag.\"),\r\n        JSDoc_may_only_appear_in_the_last_parameter_of_a_signature: diag(8028, DiagnosticCategory.Error, \"JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028\", \"JSDoc '...' may only appear in the last parameter of a signature.\"),\r\n        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type: diag(8029, DiagnosticCategory.Error, \"JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029\", \"JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type.\"),\r\n        Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_class_extends_clause: diag(9002, DiagnosticCategory.Error, \"Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_clas_9002\", \"Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clause.\"),\r\n        class_expressions_are_not_currently_supported: diag(9003, DiagnosticCategory.Error, \"class_expressions_are_not_currently_supported_9003\", \"'class' expressions are not currently supported.\"),\r\n        Language_service_is_disabled: diag(9004, DiagnosticCategory.Error, \"Language_service_is_disabled_9004\", \"Language service is disabled.\"),\r\n        JSX_attributes_must_only_be_assigned_a_non_empty_expression: diag(17000, DiagnosticCategory.Error, \"JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000\", \"JSX attributes must only be assigned a non-empty 'expression'.\"),\r\n        JSX_elements_cannot_have_multiple_attributes_with_the_same_name: diag(17001, DiagnosticCategory.Error, \"JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001\", \"JSX elements cannot have multiple attributes with the same name.\"),\r\n        Expected_corresponding_JSX_closing_tag_for_0: diag(17002, DiagnosticCategory.Error, \"Expected_corresponding_JSX_closing_tag_for_0_17002\", \"Expected corresponding JSX closing tag for '{0}'.\"),\r\n        JSX_attribute_expected: diag(17003, DiagnosticCategory.Error, \"JSX_attribute_expected_17003\", \"JSX attribute expected.\"),\r\n        Cannot_use_JSX_unless_the_jsx_flag_is_provided: diag(17004, DiagnosticCategory.Error, \"Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004\", \"Cannot use JSX unless the '--jsx' flag is provided.\"),\r\n        A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: diag(17005, DiagnosticCategory.Error, \"A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005\", \"A constructor cannot contain a 'super' call when its class extends 'null'.\"),\r\n        An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17006, DiagnosticCategory.Error, \"An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006\", \"An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.\"),\r\n        A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17007, DiagnosticCategory.Error, \"A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007\", \"A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.\"),\r\n        JSX_element_0_has_no_corresponding_closing_tag: diag(17008, DiagnosticCategory.Error, \"JSX_element_0_has_no_corresponding_closing_tag_17008\", \"JSX element '{0}' has no corresponding closing tag.\"),\r\n        super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: diag(17009, DiagnosticCategory.Error, \"super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009\", \"'super' must be called before accessing 'this' in the constructor of a derived class.\"),\r\n        Unknown_type_acquisition_option_0: diag(17010, DiagnosticCategory.Error, \"Unknown_type_acquisition_option_0_17010\", \"Unknown type acquisition option '{0}'.\"),\r\n        super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: diag(17011, DiagnosticCategory.Error, \"super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011\", \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\"),\r\n        _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: diag(17012, DiagnosticCategory.Error, \"_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012\", \"'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?\"),\r\n        Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: diag(17013, DiagnosticCategory.Error, \"Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013\", \"Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor.\"),\r\n        JSX_fragment_has_no_corresponding_closing_tag: diag(17014, DiagnosticCategory.Error, \"JSX_fragment_has_no_corresponding_closing_tag_17014\", \"JSX fragment has no corresponding closing tag.\"),\r\n        Expected_corresponding_closing_tag_for_JSX_fragment: diag(17015, DiagnosticCategory.Error, \"Expected_corresponding_closing_tag_for_JSX_fragment_17015\", \"Expected corresponding closing tag for JSX fragment.\"),\r\n        JSX_fragment_is_not_supported_when_using_jsxFactory: diag(17016, DiagnosticCategory.Error, \"JSX_fragment_is_not_supported_when_using_jsxFactory_17016\", \"JSX fragment is not supported when using --jsxFactory\"),\r\n        JSX_fragment_is_not_supported_when_using_an_inline_JSX_factory_pragma: diag(17017, DiagnosticCategory.Error, \"JSX_fragment_is_not_supported_when_using_an_inline_JSX_factory_pragma_17017\", \"JSX fragment is not supported when using an inline JSX factory pragma\"),\r\n        Circularity_detected_while_resolving_configuration_Colon_0: diag(18000, DiagnosticCategory.Error, \"Circularity_detected_while_resolving_configuration_Colon_0_18000\", \"Circularity detected while resolving configuration: {0}\"),\r\n        A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not: diag(18001, DiagnosticCategory.Error, \"A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not_18001\", \"A path in an 'extends' option must be relative or rooted, but '{0}' is not.\"),\r\n        The_files_list_in_config_file_0_is_empty: diag(18002, DiagnosticCategory.Error, \"The_files_list_in_config_file_0_is_empty_18002\", \"The 'files' list in config file '{0}' is empty.\"),\r\n        No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: diag(18003, DiagnosticCategory.Error, \"No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003\", \"No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'.\"),\r\n        File_is_a_CommonJS_module_it_may_be_converted_to_an_ES6_module: diag(80001, DiagnosticCategory.Suggestion, \"File_is_a_CommonJS_module_it_may_be_converted_to_an_ES6_module_80001\", \"File is a CommonJS module; it may be converted to an ES6 module.\"),\r\n        This_constructor_function_may_be_converted_to_a_class_declaration: diag(80002, DiagnosticCategory.Suggestion, \"This_constructor_function_may_be_converted_to_a_class_declaration_80002\", \"This constructor function may be converted to a class declaration.\"),\r\n        Import_may_be_converted_to_a_default_import: diag(80003, DiagnosticCategory.Suggestion, \"Import_may_be_converted_to_a_default_import_80003\", \"Import may be converted to a default import.\"),\r\n        JSDoc_types_may_be_moved_to_TypeScript_types: diag(80004, DiagnosticCategory.Suggestion, \"JSDoc_types_may_be_moved_to_TypeScript_types_80004\", \"JSDoc types may be moved to TypeScript types.\"),\r\n        require_call_may_be_converted_to_an_import: diag(80005, DiagnosticCategory.Suggestion, \"require_call_may_be_converted_to_an_import_80005\", \"'require' call may be converted to an import.\"),\r\n        Add_missing_super_call: diag(90001, DiagnosticCategory.Message, \"Add_missing_super_call_90001\", \"Add missing 'super()' call\"),\r\n        Make_super_call_the_first_statement_in_the_constructor: diag(90002, DiagnosticCategory.Message, \"Make_super_call_the_first_statement_in_the_constructor_90002\", \"Make 'super()' call the first statement in the constructor\"),\r\n        Change_extends_to_implements: diag(90003, DiagnosticCategory.Message, \"Change_extends_to_implements_90003\", \"Change 'extends' to 'implements'\"),\r\n        Remove_declaration_for_Colon_0: diag(90004, DiagnosticCategory.Message, \"Remove_declaration_for_Colon_0_90004\", \"Remove declaration for: '{0}'\"),\r\n        Remove_import_from_0: diag(90005, DiagnosticCategory.Message, \"Remove_import_from_0_90005\", \"Remove import from '{0}'\"),\r\n        Implement_interface_0: diag(90006, DiagnosticCategory.Message, \"Implement_interface_0_90006\", \"Implement interface '{0}'\"),\r\n        Implement_inherited_abstract_class: diag(90007, DiagnosticCategory.Message, \"Implement_inherited_abstract_class_90007\", \"Implement inherited abstract class\"),\r\n        Add_0_to_unresolved_variable: diag(90008, DiagnosticCategory.Message, \"Add_0_to_unresolved_variable_90008\", \"Add '{0}.' to unresolved variable\"),\r\n        Import_0_from_module_1: diag(90013, DiagnosticCategory.Message, \"Import_0_from_module_1_90013\", \"Import '{0}' from module \\\"{1}\\\"\"),\r\n        Change_0_to_1: diag(90014, DiagnosticCategory.Message, \"Change_0_to_1_90014\", \"Change '{0}' to '{1}'\"),\r\n        Add_0_to_existing_import_declaration_from_1: diag(90015, DiagnosticCategory.Message, \"Add_0_to_existing_import_declaration_from_1_90015\", \"Add '{0}' to existing import declaration from \\\"{1}\\\"\"),\r\n        Declare_property_0: diag(90016, DiagnosticCategory.Message, \"Declare_property_0_90016\", \"Declare property '{0}'\"),\r\n        Add_index_signature_for_property_0: diag(90017, DiagnosticCategory.Message, \"Add_index_signature_for_property_0_90017\", \"Add index signature for property '{0}'\"),\r\n        Disable_checking_for_this_file: diag(90018, DiagnosticCategory.Message, \"Disable_checking_for_this_file_90018\", \"Disable checking for this file\"),\r\n        Ignore_this_error_message: diag(90019, DiagnosticCategory.Message, \"Ignore_this_error_message_90019\", \"Ignore this error message\"),\r\n        Initialize_property_0_in_the_constructor: diag(90020, DiagnosticCategory.Message, \"Initialize_property_0_in_the_constructor_90020\", \"Initialize property '{0}' in the constructor\"),\r\n        Initialize_static_property_0: diag(90021, DiagnosticCategory.Message, \"Initialize_static_property_0_90021\", \"Initialize static property '{0}'\"),\r\n        Change_spelling_to_0: diag(90022, DiagnosticCategory.Message, \"Change_spelling_to_0_90022\", \"Change spelling to '{0}'\"),\r\n        Declare_method_0: diag(90023, DiagnosticCategory.Message, \"Declare_method_0_90023\", \"Declare method '{0}'\"),\r\n        Declare_static_method_0: diag(90024, DiagnosticCategory.Message, \"Declare_static_method_0_90024\", \"Declare static method '{0}'\"),\r\n        Prefix_0_with_an_underscore: diag(90025, DiagnosticCategory.Message, \"Prefix_0_with_an_underscore_90025\", \"Prefix '{0}' with an underscore\"),\r\n        Rewrite_as_the_indexed_access_type_0: diag(90026, DiagnosticCategory.Message, \"Rewrite_as_the_indexed_access_type_0_90026\", \"Rewrite as the indexed access type '{0}'\"),\r\n        Declare_static_property_0: diag(90027, DiagnosticCategory.Message, \"Declare_static_property_0_90027\", \"Declare static property '{0}'\"),\r\n        Call_decorator_expression: diag(90028, DiagnosticCategory.Message, \"Call_decorator_expression_90028\", \"Call decorator expression\"),\r\n        Add_async_modifier_to_containing_function: diag(90029, DiagnosticCategory.Message, \"Add_async_modifier_to_containing_function_90029\", \"Add async modifier to containing function\"),\r\n        Convert_function_to_an_ES2015_class: diag(95001, DiagnosticCategory.Message, \"Convert_function_to_an_ES2015_class_95001\", \"Convert function to an ES2015 class\"),\r\n        Convert_function_0_to_class: diag(95002, DiagnosticCategory.Message, \"Convert_function_0_to_class_95002\", \"Convert function '{0}' to class\"),\r\n        Extract_to_0_in_1: diag(95004, DiagnosticCategory.Message, \"Extract_to_0_in_1_95004\", \"Extract to {0} in {1}\"),\r\n        Extract_function: diag(95005, DiagnosticCategory.Message, \"Extract_function_95005\", \"Extract function\"),\r\n        Extract_constant: diag(95006, DiagnosticCategory.Message, \"Extract_constant_95006\", \"Extract constant\"),\r\n        Extract_to_0_in_enclosing_scope: diag(95007, DiagnosticCategory.Message, \"Extract_to_0_in_enclosing_scope_95007\", \"Extract to {0} in enclosing scope\"),\r\n        Extract_to_0_in_1_scope: diag(95008, DiagnosticCategory.Message, \"Extract_to_0_in_1_scope_95008\", \"Extract to {0} in {1} scope\"),\r\n        Annotate_with_type_from_JSDoc: diag(95009, DiagnosticCategory.Message, \"Annotate_with_type_from_JSDoc_95009\", \"Annotate with type from JSDoc\"),\r\n        Annotate_with_types_from_JSDoc: diag(95010, DiagnosticCategory.Message, \"Annotate_with_types_from_JSDoc_95010\", \"Annotate with types from JSDoc\"),\r\n        Infer_type_of_0_from_usage: diag(95011, DiagnosticCategory.Message, \"Infer_type_of_0_from_usage_95011\", \"Infer type of '{0}' from usage\"),\r\n        Infer_parameter_types_from_usage: diag(95012, DiagnosticCategory.Message, \"Infer_parameter_types_from_usage_95012\", \"Infer parameter types from usage\"),\r\n        Convert_to_default_import: diag(95013, DiagnosticCategory.Message, \"Convert_to_default_import_95013\", \"Convert to default import\"),\r\n        Install_0: diag(95014, DiagnosticCategory.Message, \"Install_0_95014\", \"Install '{0}'\"),\r\n        Replace_import_with_0: diag(95015, DiagnosticCategory.Message, \"Replace_import_with_0_95015\", \"Replace import with '{0}'.\"),\r\n        Use_synthetic_default_member: diag(95016, DiagnosticCategory.Message, \"Use_synthetic_default_member_95016\", \"Use synthetic 'default' member.\"),\r\n        Convert_to_ES6_module: diag(95017, DiagnosticCategory.Message, \"Convert_to_ES6_module_95017\", \"Convert to ES6 module\"),\r\n        Add_undefined_type_to_property_0: diag(95018, DiagnosticCategory.Message, \"Add_undefined_type_to_property_0_95018\", \"Add 'undefined' type to property '{0}'\"),\r\n        Add_initializer_to_property_0: diag(95019, DiagnosticCategory.Message, \"Add_initializer_to_property_0_95019\", \"Add initializer to property '{0}'\"),\r\n        Add_definite_assignment_assertion_to_property_0: diag(95020, DiagnosticCategory.Message, \"Add_definite_assignment_assertion_to_property_0_95020\", \"Add definite assignment assertion to property '{0}'\"),\r\n        Add_all_missing_members: diag(95022, DiagnosticCategory.Message, \"Add_all_missing_members_95022\", \"Add all missing members\"),\r\n        Infer_all_types_from_usage: diag(95023, DiagnosticCategory.Message, \"Infer_all_types_from_usage_95023\", \"Infer all types from usage\"),\r\n        Delete_all_unused_declarations: diag(95024, DiagnosticCategory.Message, \"Delete_all_unused_declarations_95024\", \"Delete all unused declarations\"),\r\n        Prefix_all_unused_declarations_with_where_possible: diag(95025, DiagnosticCategory.Message, \"Prefix_all_unused_declarations_with_where_possible_95025\", \"Prefix all unused declarations with '_' where possible\"),\r\n        Fix_all_detected_spelling_errors: diag(95026, DiagnosticCategory.Message, \"Fix_all_detected_spelling_errors_95026\", \"Fix all detected spelling errors\"),\r\n        Add_initializers_to_all_uninitialized_properties: diag(95027, DiagnosticCategory.Message, \"Add_initializers_to_all_uninitialized_properties_95027\", \"Add initializers to all uninitialized properties\"),\r\n        Add_definite_assignment_assertions_to_all_uninitialized_properties: diag(95028, DiagnosticCategory.Message, \"Add_definite_assignment_assertions_to_all_uninitialized_properties_95028\", \"Add definite assignment assertions to all uninitialized properties\"),\r\n        Add_undefined_type_to_all_uninitialized_properties: diag(95029, DiagnosticCategory.Message, \"Add_undefined_type_to_all_uninitialized_properties_95029\", \"Add undefined type to all uninitialized properties\"),\r\n        Change_all_jsdoc_style_types_to_TypeScript: diag(95030, DiagnosticCategory.Message, \"Change_all_jsdoc_style_types_to_TypeScript_95030\", \"Change all jsdoc-style types to TypeScript\"),\r\n        Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types: diag(95031, DiagnosticCategory.Message, \"Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031\", \"Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)\"),\r\n        Implement_all_unimplemented_interfaces: diag(95032, DiagnosticCategory.Message, \"Implement_all_unimplemented_interfaces_95032\", \"Implement all unimplemented interfaces\"),\r\n        Install_all_missing_types_packages: diag(95033, DiagnosticCategory.Message, \"Install_all_missing_types_packages_95033\", \"Install all missing types packages\"),\r\n        Rewrite_all_as_indexed_access_types: diag(95034, DiagnosticCategory.Message, \"Rewrite_all_as_indexed_access_types_95034\", \"Rewrite all as indexed access types\"),\r\n        Convert_all_to_default_imports: diag(95035, DiagnosticCategory.Message, \"Convert_all_to_default_imports_95035\", \"Convert all to default imports\"),\r\n        Make_all_super_calls_the_first_statement_in_their_constructor: diag(95036, DiagnosticCategory.Message, \"Make_all_super_calls_the_first_statement_in_their_constructor_95036\", \"Make all 'super()' calls the first statement in their constructor\"),\r\n        Add_qualifier_to_all_unresolved_variables_matching_a_member_name: diag(95037, DiagnosticCategory.Message, \"Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037\", \"Add qualifier to all unresolved variables matching a member name\"),\r\n        Change_all_extended_interfaces_to_implements: diag(95038, DiagnosticCategory.Message, \"Change_all_extended_interfaces_to_implements_95038\", \"Change all extended interfaces to 'implements'\"),\r\n        Add_all_missing_super_calls: diag(95039, DiagnosticCategory.Message, \"Add_all_missing_super_calls_95039\", \"Add all missing super calls\"),\r\n        Implement_all_inherited_abstract_classes: diag(95040, DiagnosticCategory.Message, \"Implement_all_inherited_abstract_classes_95040\", \"Implement all inherited abstract classes\"),\r\n        Add_all_missing_async_modifiers: diag(95041, DiagnosticCategory.Message, \"Add_all_missing_async_modifiers_95041\", \"Add all missing 'async' modifiers\"),\r\n        Add_ts_ignore_to_all_error_messages: diag(95042, DiagnosticCategory.Message, \"Add_ts_ignore_to_all_error_messages_95042\", \"Add '@ts-ignore' to all error messages\"),\r\n        Annotate_everything_with_types_from_JSDoc: diag(95043, DiagnosticCategory.Message, \"Annotate_everything_with_types_from_JSDoc_95043\", \"Annotate everything with types from JSDoc\"),\r\n        Add_to_all_uncalled_decorators: diag(95044, DiagnosticCategory.Message, \"Add_to_all_uncalled_decorators_95044\", \"Add '()' to all uncalled decorators\"),\r\n        Convert_all_constructor_functions_to_classes: diag(95045, DiagnosticCategory.Message, \"Convert_all_constructor_functions_to_classes_95045\", \"Convert all constructor functions to classes\"),\r\n        Generate_get_and_set_accessors: diag(95046, DiagnosticCategory.Message, \"Generate_get_and_set_accessors_95046\", \"Generate 'get' and 'set' accessors\"),\r\n        Convert_require_to_import: diag(95047, DiagnosticCategory.Message, \"Convert_require_to_import_95047\", \"Convert 'require' to 'import'\"),\r\n        Convert_all_require_to_import: diag(95048, DiagnosticCategory.Message, \"Convert_all_require_to_import_95048\", \"Convert all 'require' to 'import'\"),\r\n    };\r\n}","/* @internal */\r\nnamespace ts {\r\n    export const resolvingEmptyArray: never[] = [] as never[];\r\n    export const emptyMap: ReadonlyMap<never> = createMap<never>();\r\n    export const emptyUnderscoreEscapedMap: ReadonlyUnderscoreEscapedMap<never> = emptyMap as ReadonlyUnderscoreEscapedMap<never>;\r\n\r\n    export const externalHelpersModuleNameText = \"tslib\";\r\n\r\n    export interface ReferencePathMatchResult {\r\n        fileReference?: FileReference;\r\n        diagnosticMessage?: DiagnosticMessage;\r\n        isNoDefaultLib?: boolean;\r\n        isTypeReferenceDirective?: boolean;\r\n    }\r\n\r\n    export function getDeclarationOfKind<T extends Declaration>(symbol: Symbol, kind: T[\"kind\"]): T {\r\n        const declarations = symbol.declarations;\r\n        if (declarations) {\r\n            for (const declaration of declarations) {\r\n                if (declaration.kind === kind) {\r\n                    return declaration as T;\r\n                }\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    const stringWriter = createSingleLineStringWriter();\r\n\r\n    function createSingleLineStringWriter(): EmitTextWriter {\r\n        let str = \"\";\r\n\r\n        const writeText: (text: string) => void = text => str += text;\r\n        return {\r\n            getText: () => str,\r\n            write: writeText,\r\n            rawWrite: writeText,\r\n            writeTextOfNode: writeText,\r\n            writeKeyword: writeText,\r\n            writeOperator: writeText,\r\n            writePunctuation: writeText,\r\n            writeSpace: writeText,\r\n            writeStringLiteral: writeText,\r\n            writeLiteral: writeText,\r\n            writeParameter: writeText,\r\n            writeProperty: writeText,\r\n            writeSymbol: writeText,\r\n            getTextPos: () => str.length,\r\n            getLine: () => 0,\r\n            getColumn: () => 0,\r\n            getIndent: () => 0,\r\n            isAtStartOfLine: () => false,\r\n\r\n            // Completely ignore indentation for string writers.  And map newlines to\r\n            // a single space.\r\n            writeLine: () => str += \" \",\r\n            increaseIndent: noop,\r\n            decreaseIndent: noop,\r\n            clear: () => str = \"\",\r\n            trackSymbol: noop,\r\n            reportInaccessibleThisError: noop,\r\n            reportInaccessibleUniqueSymbolError: noop,\r\n            reportPrivateInBaseOfClassExpression: noop,\r\n        };\r\n    }\r\n\r\n    export function usingSingleLineStringWriter(action: (writer: EmitTextWriter) => void): string {\r\n        const oldString = stringWriter.getText();\r\n        try {\r\n            action(stringWriter);\r\n            return stringWriter.getText();\r\n        }\r\n        finally {\r\n            stringWriter.clear();\r\n            stringWriter.writeKeyword(oldString);\r\n        }\r\n    }\r\n\r\n    export function getFullWidth(node: Node) {\r\n        return node.end - node.pos;\r\n    }\r\n\r\n    export function getResolvedModule(sourceFile: SourceFile, moduleNameText: string): ResolvedModuleFull | undefined {\r\n        return sourceFile && sourceFile.resolvedModules && sourceFile.resolvedModules.get(moduleNameText);\r\n    }\r\n\r\n    export function setResolvedModule(sourceFile: SourceFile, moduleNameText: string, resolvedModule: ResolvedModuleFull): void {\r\n        if (!sourceFile.resolvedModules) {\r\n            sourceFile.resolvedModules = createMap<ResolvedModuleFull>();\r\n        }\r\n\r\n        sourceFile.resolvedModules.set(moduleNameText, resolvedModule);\r\n    }\r\n\r\n    export function setResolvedTypeReferenceDirective(sourceFile: SourceFile, typeReferenceDirectiveName: string, resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective): void {\r\n        if (!sourceFile.resolvedTypeReferenceDirectiveNames) {\r\n            sourceFile.resolvedTypeReferenceDirectiveNames = createMap<ResolvedTypeReferenceDirective>();\r\n        }\r\n\r\n        sourceFile.resolvedTypeReferenceDirectiveNames.set(typeReferenceDirectiveName, resolvedTypeReferenceDirective);\r\n    }\r\n\r\n    export function moduleResolutionIsEqualTo(oldResolution: ResolvedModuleFull, newResolution: ResolvedModuleFull): boolean {\r\n        return oldResolution.isExternalLibraryImport === newResolution.isExternalLibraryImport &&\r\n            oldResolution.extension === newResolution.extension &&\r\n            oldResolution.resolvedFileName === newResolution.resolvedFileName &&\r\n            oldResolution.originalPath === newResolution.originalPath &&\r\n            packageIdIsEqual(oldResolution.packageId, newResolution.packageId);\r\n    }\r\n\r\n    function packageIdIsEqual(a: PackageId | undefined, b: PackageId | undefined): boolean {\r\n        return a === b || a && b && a.name === b.name && a.subModuleName === b.subModuleName && a.version === b.version;\r\n    }\r\n\r\n    export function packageIdToString({ name, subModuleName, version }: PackageId): string {\r\n        const fullName = subModuleName ? `${name}/${subModuleName}` : name;\r\n        return `${fullName}@${version}`;\r\n    }\r\n\r\n    export function typeDirectiveIsEqualTo(oldResolution: ResolvedTypeReferenceDirective, newResolution: ResolvedTypeReferenceDirective): boolean {\r\n        return oldResolution.resolvedFileName === newResolution.resolvedFileName && oldResolution.primary === newResolution.primary;\r\n    }\r\n\r\n    export function hasChangesInResolutions<T>(\r\n        names: ReadonlyArray<string>,\r\n        newResolutions: ReadonlyArray<T>,\r\n        oldResolutions: ReadonlyMap<T>,\r\n        comparer: (oldResolution: T, newResolution: T) => boolean): boolean {\r\n        Debug.assert(names.length === newResolutions.length);\r\n\r\n        for (let i = 0; i < names.length; i++) {\r\n            const newResolution = newResolutions[i];\r\n            const oldResolution = oldResolutions && oldResolutions.get(names[i]);\r\n            const changed =\r\n                oldResolution\r\n                    ? !newResolution || !comparer(oldResolution, newResolution)\r\n                    : newResolution;\r\n            if (changed) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Returns true if this node contains a parse error anywhere underneath it.\r\n    export function containsParseError(node: Node): boolean {\r\n        aggregateChildData(node);\r\n        return (node.flags & NodeFlags.ThisNodeOrAnySubNodesHasError) !== 0;\r\n    }\r\n\r\n    function aggregateChildData(node: Node): void {\r\n        if (!(node.flags & NodeFlags.HasAggregatedChildData)) {\r\n            // A node is considered to contain a parse error if:\r\n            //  a) the parser explicitly marked that it had an error\r\n            //  b) any of it's children reported that it had an error.\r\n            const thisNodeOrAnySubNodesHasError = ((node.flags & NodeFlags.ThisNodeHasError) !== 0) ||\r\n                forEachChild(node, containsParseError);\r\n\r\n            // If so, mark ourselves accordingly.\r\n            if (thisNodeOrAnySubNodesHasError) {\r\n                node.flags |= NodeFlags.ThisNodeOrAnySubNodesHasError;\r\n            }\r\n\r\n            // Also mark that we've propagated the child information to this node.  This way we can\r\n            // always consult the bit directly on this node without needing to check its children\r\n            // again.\r\n            node.flags |= NodeFlags.HasAggregatedChildData;\r\n        }\r\n    }\r\n\r\n    export function getSourceFileOfNode(node: Node): SourceFile {\r\n        while (node && node.kind !== SyntaxKind.SourceFile) {\r\n            node = node.parent;\r\n        }\r\n        return <SourceFile>node;\r\n    }\r\n\r\n    export function isStatementWithLocals(node: Node) {\r\n        switch (node.kind) {\r\n            case SyntaxKind.Block:\r\n            case SyntaxKind.CaseBlock:\r\n            case SyntaxKind.ForStatement:\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function getStartPositionOfLine(line: number, sourceFile: SourceFileLike): number {\r\n        Debug.assert(line >= 0);\r\n        return getLineStarts(sourceFile)[line];\r\n    }\r\n\r\n    // This is a useful function for debugging purposes.\r\n    export function nodePosToString(node: Node): string {\r\n        const file = getSourceFileOfNode(node);\r\n        const loc = getLineAndCharacterOfPosition(file, node.pos);\r\n        return `${file.fileName}(${loc.line + 1},${loc.character + 1})`;\r\n    }\r\n\r\n    export function getEndLinePosition(line: number, sourceFile: SourceFileLike): number {\r\n        Debug.assert(line >= 0);\r\n        const lineStarts = getLineStarts(sourceFile);\r\n\r\n        const lineIndex = line;\r\n        const sourceText = sourceFile.text;\r\n        if (lineIndex + 1 === lineStarts.length) {\r\n            // last line - return EOF\r\n            return sourceText.length - 1;\r\n        }\r\n        else {\r\n            // current line start\r\n            const start = lineStarts[lineIndex];\r\n            // take the start position of the next line - 1 = it should be some line break\r\n            let pos = lineStarts[lineIndex + 1] - 1;\r\n            Debug.assert(isLineBreak(sourceText.charCodeAt(pos)));\r\n            // walk backwards skipping line breaks, stop the the beginning of current line.\r\n            // i.e:\r\n            // <some text>\r\n            // $ <- end of line for this position should match the start position\r\n            while (start <= pos && isLineBreak(sourceText.charCodeAt(pos))) {\r\n                pos--;\r\n            }\r\n            return pos;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a value indicating whether a name is unique globally or within the current file\r\n     */\r\n    export function isFileLevelUniqueName(currentSourceFile: SourceFile, name: string, hasGlobalName?: PrintHandlers[\"hasGlobalName\"]): boolean {\r\n        return !(hasGlobalName && hasGlobalName(name))\r\n            && !currentSourceFile.identifiers.has(name);\r\n    }\r\n\r\n    // Returns true if this node is missing from the actual source code. A 'missing' node is different\r\n    // from 'undefined/defined'. When a node is undefined (which can happen for optional nodes\r\n    // in the tree), it is definitely missing. However, a node may be defined, but still be\r\n    // missing.  This happens whenever the parser knows it needs to parse something, but can't\r\n    // get anything in the source code that it expects at that location. For example:\r\n    //\r\n    //          let a: ;\r\n    //\r\n    // Here, the Type in the Type-Annotation is not-optional (as there is a colon in the source\r\n    // code). So the parser will attempt to parse out a type, and will create an actual node.\r\n    // However, this node will be 'missing' in the sense that no actual source-code/tokens are\r\n    // contained within it.\r\n    export function nodeIsMissing(node: Node) {\r\n        if (node === undefined) {\r\n            return true;\r\n        }\r\n\r\n        return node.pos === node.end && node.pos >= 0 && node.kind !== SyntaxKind.EndOfFileToken;\r\n    }\r\n\r\n    export function nodeIsPresent(node: Node) {\r\n        return !nodeIsMissing(node);\r\n    }\r\n\r\n    /**\r\n     * Determine if the given comment is a triple-slash\r\n     *\r\n     * @return true if the comment is a triple-slash comment else false\r\n     */\r\n    export function isRecognizedTripleSlashComment(text: string, commentPos: number, commentEnd: number) {\r\n        // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text\r\n        // so that we don't end up computing comment string and doing match for all // comments\r\n        if (text.charCodeAt(commentPos + 1) === CharacterCodes.slash &&\r\n            commentPos + 2 < commentEnd &&\r\n            text.charCodeAt(commentPos + 2) === CharacterCodes.slash) {\r\n            const textSubStr = text.substring(commentPos, commentEnd);\r\n            return textSubStr.match(fullTripleSlashReferencePathRegEx) ||\r\n                textSubStr.match(fullTripleSlashAMDReferencePathRegEx) ||\r\n                textSubStr.match(fullTripleSlashReferenceTypeReferenceDirectiveRegEx) ||\r\n                textSubStr.match(defaultLibReferenceRegEx) ?\r\n                true : false;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isPinnedComment(text: string, start: number) {\r\n        return text.charCodeAt(start + 1) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(start + 2) === CharacterCodes.exclamation;\r\n    }\r\n\r\n    export function getTokenPosOfNode(node: Node, sourceFile?: SourceFileLike, includeJsDoc?: boolean): number {\r\n        // With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*\r\n        // want to skip trivia because this will launch us forward to the next token.\r\n        if (nodeIsMissing(node)) {\r\n            return node.pos;\r\n        }\r\n\r\n        if (isJSDocNode(node)) {\r\n            return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, /*stopAfterLineBreak*/ false, /*stopAtComments*/ true);\r\n        }\r\n\r\n        if (includeJsDoc && hasJSDocNodes(node)) {\r\n            return getTokenPosOfNode(node.jsDoc[0]);\r\n        }\r\n\r\n        // For a syntax list, it is possible that one of its children has JSDocComment nodes, while\r\n        // the syntax list itself considers them as normal trivia. Therefore if we simply skip\r\n        // trivia for the list, we may have skipped the JSDocComment as well. So we should process its\r\n        // first child to determine the actual position of its first token.\r\n        if (node.kind === SyntaxKind.SyntaxList && (<SyntaxList>node)._children.length > 0) {\r\n            return getTokenPosOfNode((<SyntaxList>node)._children[0], sourceFile, includeJsDoc);\r\n        }\r\n\r\n        return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos);\r\n    }\r\n\r\n    export function getNonDecoratorTokenPosOfNode(node: Node, sourceFile?: SourceFileLike): number {\r\n        if (nodeIsMissing(node) || !node.decorators) {\r\n            return getTokenPosOfNode(node, sourceFile);\r\n        }\r\n\r\n        return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.decorators.end);\r\n    }\r\n\r\n    export function getSourceTextOfNodeFromSourceFile(sourceFile: SourceFile, node: Node, includeTrivia = false): string {\r\n        return getTextOfNodeFromSourceText(sourceFile.text, node, includeTrivia);\r\n    }\r\n\r\n    export function getTextOfNodeFromSourceText(sourceText: string, node: Node, includeTrivia = false): string {\r\n        if (nodeIsMissing(node)) {\r\n            return \"\";\r\n        }\r\n\r\n        return sourceText.substring(includeTrivia ? node.pos : skipTrivia(sourceText, node.pos), node.end);\r\n    }\r\n\r\n    export function getTextOfNode(node: Node, includeTrivia = false): string {\r\n        return getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node, includeTrivia);\r\n    }\r\n\r\n    function getPos(range: Node) {\r\n        return range.pos;\r\n    }\r\n\r\n    /**\r\n     * Note: it is expected that the `nodeArray` and the `node` are within the same file.\r\n     * For example, searching for a `SourceFile` in a `SourceFile[]` wouldn't work.\r\n     */\r\n    export function indexOfNode(nodeArray: ReadonlyArray<Node>, node: Node) {\r\n        return binarySearch(nodeArray, node, getPos, compareValues);\r\n    }\r\n\r\n    /**\r\n     * Gets flags that control emit behavior of a node.\r\n     */\r\n    export function getEmitFlags(node: Node): EmitFlags | undefined {\r\n        const emitNode = node.emitNode;\r\n        return emitNode && emitNode.flags;\r\n    }\r\n\r\n    export function getLiteralText(node: LiteralLikeNode, sourceFile: SourceFile) {\r\n        // If we don't need to downlevel and we can reach the original source text using\r\n        // the node's parent reference, then simply get the text as it was originally written.\r\n        if (!nodeIsSynthesized(node) && node.parent && !(isNumericLiteral(node) && node.numericLiteralFlags & TokenFlags.ContainsSeparator)) {\r\n            return getSourceTextOfNodeFromSourceFile(sourceFile, node);\r\n        }\r\n\r\n        const escapeText = getEmitFlags(node) & EmitFlags.NoAsciiEscaping ? escapeString : escapeNonAsciiString;\r\n\r\n        // If we can't reach the original source text, use the canonical form if it's a number,\r\n        // or a (possibly escaped) quoted form of the original text if it's string-like.\r\n        switch (node.kind) {\r\n            case SyntaxKind.StringLiteral:\r\n                if ((<StringLiteral>node).singleQuote) {\r\n                    return \"'\" + escapeText(node.text, CharacterCodes.singleQuote) + \"'\";\r\n                }\r\n                else {\r\n                    return '\"' + escapeText(node.text, CharacterCodes.doubleQuote) + '\"';\r\n                }\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                return \"`\" + escapeText(node.text, CharacterCodes.backtick) + \"`\";\r\n            case SyntaxKind.TemplateHead:\r\n                // tslint:disable-next-line no-invalid-template-strings\r\n                return \"`\" + escapeText(node.text, CharacterCodes.backtick) + \"${\";\r\n            case SyntaxKind.TemplateMiddle:\r\n                // tslint:disable-next-line no-invalid-template-strings\r\n                return \"}\" + escapeText(node.text, CharacterCodes.backtick) + \"${\";\r\n            case SyntaxKind.TemplateTail:\r\n                return \"}\" + escapeText(node.text, CharacterCodes.backtick) + \"`\";\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n                return node.text;\r\n        }\r\n\r\n        Debug.fail(`Literal kind '${node.kind}' not accounted for.`);\r\n    }\r\n\r\n    export function getTextOfConstantValue(value: string | number) {\r\n        return isString(value) ? '\"' + escapeNonAsciiString(value) + '\"' : \"\" + value;\r\n    }\r\n\r\n    // Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'\r\n    export function escapeLeadingUnderscores(identifier: string): __String {\r\n        return (identifier.length >= 2 && identifier.charCodeAt(0) === CharacterCodes._ && identifier.charCodeAt(1) === CharacterCodes._ ? \"_\" + identifier : identifier) as __String;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `id.escapedText` to get the escaped text of an Identifier.\r\n     * @param identifier The identifier to escape\r\n     */\r\n    export function escapeIdentifier(identifier: string): string {\r\n        return identifier;\r\n    }\r\n\r\n    // Make an identifier from an external module name by extracting the string after the last \"/\" and replacing\r\n    // all non-alphanumeric characters with underscores\r\n    export function makeIdentifierFromModuleName(moduleName: string): string {\r\n        return getBaseFileName(moduleName).replace(/^(\\d)/, \"_$1\").replace(/\\W/g, \"_\");\r\n    }\r\n\r\n    export function isBlockOrCatchScoped(declaration: Declaration) {\r\n        return (getCombinedNodeFlags(declaration) & NodeFlags.BlockScoped) !== 0 ||\r\n            isCatchClauseVariableDeclarationOrBindingElement(declaration);\r\n    }\r\n\r\n    export function isCatchClauseVariableDeclarationOrBindingElement(declaration: Declaration) {\r\n        const node = getRootDeclaration(declaration);\r\n        return node.kind === SyntaxKind.VariableDeclaration && node.parent.kind === SyntaxKind.CatchClause;\r\n    }\r\n\r\n    export function isAmbientModule(node: Node): node is AmbientModuleDeclaration {\r\n        return isModuleDeclaration(node) && (node.name.kind === SyntaxKind.StringLiteral || isGlobalScopeAugmentation(node));\r\n    }\r\n\r\n    export function isModuleWithStringLiteralName(node: Node): node is ModuleDeclaration {\r\n        return isModuleDeclaration(node) && node.name.kind === SyntaxKind.StringLiteral;\r\n    }\r\n\r\n    export function isNonGlobalAmbientModule(node: Node): node is ModuleDeclaration & { name: StringLiteral } {\r\n        return isModuleDeclaration(node) && isStringLiteral(node.name);\r\n    }\r\n\r\n    /** Given a symbol for a module, checks that it is a shorthand ambient module. */\r\n    export function isShorthandAmbientModuleSymbol(moduleSymbol: Symbol): boolean {\r\n        return isShorthandAmbientModule(moduleSymbol.valueDeclaration);\r\n    }\r\n\r\n    function isShorthandAmbientModule(node: Node): boolean {\r\n        // The only kind of module that can be missing a body is a shorthand ambient module.\r\n        return node && node.kind === SyntaxKind.ModuleDeclaration && (!(<ModuleDeclaration>node).body);\r\n    }\r\n\r\n    export function isBlockScopedContainerTopLevel(node: Node): boolean {\r\n        return node.kind === SyntaxKind.SourceFile ||\r\n            node.kind === SyntaxKind.ModuleDeclaration ||\r\n            isFunctionLike(node);\r\n    }\r\n\r\n    export function isGlobalScopeAugmentation(module: ModuleDeclaration): boolean {\r\n        return !!(module.flags & NodeFlags.GlobalAugmentation);\r\n    }\r\n\r\n    export function isExternalModuleAugmentation(node: Node): node is AmbientModuleDeclaration {\r\n        return isAmbientModule(node) && isModuleAugmentationExternal(node);\r\n    }\r\n\r\n    export function isModuleAugmentationExternal(node: AmbientModuleDeclaration) {\r\n        // external module augmentation is a ambient module declaration that is either:\r\n        // - defined in the top level scope and source file is an external module\r\n        // - defined inside ambient module declaration located in the top level scope and source file not an external module\r\n        switch (node.parent.kind) {\r\n            case SyntaxKind.SourceFile:\r\n                return isExternalModule(node.parent);\r\n            case SyntaxKind.ModuleBlock:\r\n                return isAmbientModule(node.parent.parent) && isSourceFile(node.parent.parent.parent) && !isExternalModule(node.parent.parent.parent);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isEffectiveExternalModule(node: SourceFile, compilerOptions: CompilerOptions) {\r\n        return isExternalModule(node) || compilerOptions.isolatedModules || ((getEmitModuleKind(compilerOptions) === ModuleKind.CommonJS) && !!node.commonJsModuleIndicator);\r\n    }\r\n\r\n    export function isBlockScope(node: Node, parentNode: Node) {\r\n        switch (node.kind) {\r\n            case SyntaxKind.SourceFile:\r\n            case SyntaxKind.CaseBlock:\r\n            case SyntaxKind.CatchClause:\r\n            case SyntaxKind.ModuleDeclaration:\r\n            case SyntaxKind.ForStatement:\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n                return true;\r\n\r\n            case SyntaxKind.Block:\r\n                // function block is not considered block-scope container\r\n                // see comment in binder.ts: bind(...), case for SyntaxKind.Block\r\n                return parentNode && !isFunctionLike(parentNode);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function isDeclarationWithTypeParameters(node: Node): node is DeclarationWithTypeParameters;\r\n    export function isDeclarationWithTypeParameters(node: DeclarationWithTypeParameters): node is DeclarationWithTypeParameters {\r\n        switch (node.kind) {\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.IndexSignature:\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n            case SyntaxKind.JSDocFunctionType:\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.InterfaceDeclaration:\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n            case SyntaxKind.JSDocTemplateTag:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n                return true;\r\n            default:\r\n                assertTypeIsNever(node);\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isAnyImportSyntax(node: Node): node is AnyImportSyntax {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ImportDeclaration:\r\n            case SyntaxKind.ImportEqualsDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isLateVisibilityPaintedStatement(node: Node): node is LateVisibilityPaintedStatement {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ImportDeclaration:\r\n            case SyntaxKind.ImportEqualsDeclaration:\r\n            case SyntaxKind.VariableStatement:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isAnyImportOrReExport(node: Node): node is AnyImportOrReExport {\r\n        return isAnyImportSyntax(node) || isExportDeclaration(node);\r\n    }\r\n\r\n    // Gets the nearest enclosing block scope container that has the provided node\r\n    // as a descendant, that is not the provided node.\r\n    export function getEnclosingBlockScopeContainer(node: Node): Node {\r\n        let current = node.parent;\r\n        while (current) {\r\n            if (isBlockScope(current, current.parent)) {\r\n                return current;\r\n            }\r\n\r\n            current = current.parent;\r\n        }\r\n    }\r\n\r\n    // Return display name of an identifier\r\n    // Computed property names will just be emitted as \"[<expr>]\", where <expr> is the source\r\n    // text of the expression in the computed property.\r\n    export function declarationNameToString(name: DeclarationName | QualifiedName) {\r\n        return getFullWidth(name) === 0 ? \"(Missing)\" : getTextOfNode(name);\r\n    }\r\n\r\n    export function getNameFromIndexInfo(info: IndexInfo): string | undefined {\r\n        return info.declaration ? declarationNameToString(info.declaration.parameters[0].name) : undefined;\r\n    }\r\n\r\n    export function getTextOfPropertyName(name: PropertyName): __String {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n                return name.escapedText;\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n                return escapeLeadingUnderscores(name.text);\r\n            case SyntaxKind.ComputedPropertyName:\r\n                return isStringOrNumericLiteral(name.expression) ? escapeLeadingUnderscores(name.expression.text) : undefined;\r\n            default:\r\n                Debug.assertNever(name);\r\n        }\r\n    }\r\n\r\n    export function entityNameToString(name: EntityNameOrEntityNameExpression): string {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n                return getFullWidth(name) === 0 ? idText(name) : getTextOfNode(name);\r\n            case SyntaxKind.QualifiedName:\r\n                return entityNameToString(name.left) + \".\" + entityNameToString(name.right);\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                return entityNameToString(name.expression) + \".\" + entityNameToString(name.name);\r\n        }\r\n    }\r\n\r\n    export function createDiagnosticForNode(node: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): Diagnostic {\r\n        const sourceFile = getSourceFileOfNode(node);\r\n        return createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2, arg3);\r\n    }\r\n\r\n    export function createDiagnosticForNodeArray(sourceFile: SourceFile, nodes: NodeArray<Node>, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): Diagnostic {\r\n        const start = skipTrivia(sourceFile.text, nodes.pos);\r\n        return createFileDiagnostic(sourceFile, start, nodes.end - start, message, arg0, arg1, arg2, arg3);\r\n    }\r\n\r\n    export function createDiagnosticForNodeInSourceFile(sourceFile: SourceFile, node: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): Diagnostic {\r\n        const span = getErrorSpanForNode(sourceFile, node);\r\n        return createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2, arg3);\r\n    }\r\n\r\n    export function createDiagnosticForNodeSpan(sourceFile: SourceFile, startNode: Node, endNode: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): Diagnostic {\r\n        const start = skipTrivia(sourceFile.text, startNode.pos);\r\n        return createFileDiagnostic(sourceFile, start, endNode.end - start, message, arg0, arg1, arg2, arg3);\r\n    }\r\n\r\n    export function createDiagnosticForNodeFromMessageChain(node: Node, messageChain: DiagnosticMessageChain): Diagnostic {\r\n        const sourceFile = getSourceFileOfNode(node);\r\n        const span = getErrorSpanForNode(sourceFile, node);\r\n        return {\r\n            file: sourceFile,\r\n            start: span.start,\r\n            length: span.length,\r\n            code: messageChain.code,\r\n            category: messageChain.category,\r\n            messageText: messageChain.next ? messageChain : messageChain.messageText\r\n        };\r\n    }\r\n\r\n    export function getSpanOfTokenAtPosition(sourceFile: SourceFile, pos: number): TextSpan {\r\n        const scanner = createScanner(sourceFile.languageVersion, /*skipTrivia*/ true, sourceFile.languageVariant, sourceFile.text, /*onError:*/ undefined, pos);\r\n        scanner.scan();\r\n        const start = scanner.getTokenPos();\r\n        return createTextSpanFromBounds(start, scanner.getTextPos());\r\n    }\r\n\r\n    function getErrorSpanForArrowFunction(sourceFile: SourceFile, node: ArrowFunction): TextSpan {\r\n        const pos = skipTrivia(sourceFile.text, node.pos);\r\n        if (node.body && node.body.kind === SyntaxKind.Block) {\r\n            const { line: startLine } = getLineAndCharacterOfPosition(sourceFile, node.body.pos);\r\n            const { line: endLine } = getLineAndCharacterOfPosition(sourceFile, node.body.end);\r\n            if (startLine < endLine) {\r\n                // The arrow function spans multiple lines,\r\n                // make the error span be the first line, inclusive.\r\n                return createTextSpan(pos, getEndLinePosition(startLine, sourceFile) - pos + 1);\r\n            }\r\n        }\r\n        return createTextSpanFromBounds(pos, node.end);\r\n    }\r\n\r\n    export function getErrorSpanForNode(sourceFile: SourceFile, node: Node): TextSpan {\r\n        let errorNode = node;\r\n        switch (node.kind) {\r\n            case SyntaxKind.SourceFile:\r\n                const pos = skipTrivia(sourceFile.text, 0, /*stopAfterLineBreak*/ false);\r\n                if (pos === sourceFile.text.length) {\r\n                    // file is empty - return span for the beginning of the file\r\n                    return createTextSpan(0, 0);\r\n                }\r\n                return getSpanOfTokenAtPosition(sourceFile, pos);\r\n            // This list is a work in progress. Add missing node kinds to improve their error\r\n            // spans.\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.BindingElement:\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.InterfaceDeclaration:\r\n            case SyntaxKind.ModuleDeclaration:\r\n            case SyntaxKind.EnumDeclaration:\r\n            case SyntaxKind.EnumMember:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n                errorNode = (<NamedDeclaration>node).name;\r\n                break;\r\n            case SyntaxKind.ArrowFunction:\r\n                return getErrorSpanForArrowFunction(sourceFile, <ArrowFunction>node);\r\n        }\r\n\r\n        if (errorNode === undefined) {\r\n            // If we don't have a better node, then just set the error on the first token of\r\n            // construct.\r\n            return getSpanOfTokenAtPosition(sourceFile, node.pos);\r\n        }\r\n\r\n        const isMissing = nodeIsMissing(errorNode);\r\n        const pos = isMissing\r\n            ? errorNode.pos\r\n            : skipTrivia(sourceFile.text, errorNode.pos);\r\n\r\n        // These asserts should all be satisfied for a properly constructed `errorNode`.\r\n        if (isMissing) {\r\n            Debug.assert(pos === errorNode.pos, \"This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809\");\r\n            Debug.assert(pos === errorNode.end, \"This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809\");\r\n        }\r\n        else {\r\n            Debug.assert(pos >= errorNode.pos, \"This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809\");\r\n            Debug.assert(pos <= errorNode.end, \"This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809\");\r\n        }\r\n\r\n        return createTextSpanFromBounds(pos, errorNode.end);\r\n    }\r\n\r\n    export function isExternalOrCommonJsModule(file: SourceFile): boolean {\r\n        return (file.externalModuleIndicator || file.commonJsModuleIndicator) !== undefined;\r\n    }\r\n\r\n    export function isConstEnumDeclaration(node: Node): boolean {\r\n        return node.kind === SyntaxKind.EnumDeclaration && isConst(node);\r\n    }\r\n\r\n    export function isConst(node: Node): boolean {\r\n        return !!(getCombinedNodeFlags(node) & NodeFlags.Const)\r\n            || !!(getCombinedModifierFlags(node) & ModifierFlags.Const);\r\n    }\r\n\r\n    export function isLet(node: Node): boolean {\r\n        return !!(getCombinedNodeFlags(node) & NodeFlags.Let);\r\n    }\r\n\r\n    export function isSuperCall(n: Node): n is SuperCall {\r\n        return n.kind === SyntaxKind.CallExpression && (<CallExpression>n).expression.kind === SyntaxKind.SuperKeyword;\r\n    }\r\n\r\n    export function isImportCall(n: Node): n is ImportCall {\r\n        return n.kind === SyntaxKind.CallExpression && (<CallExpression>n).expression.kind === SyntaxKind.ImportKeyword;\r\n    }\r\n\r\n    export function isLiteralImportTypeNode(n: Node): n is LiteralImportTypeNode {\r\n        return n.kind === SyntaxKind.ImportType &&\r\n            (n as ImportTypeNode).argument.kind === SyntaxKind.LiteralType &&\r\n            isStringLiteral(((n as ImportTypeNode).argument as LiteralTypeNode).literal);\r\n    }\r\n\r\n    export function isPrologueDirective(node: Node): node is PrologueDirective {\r\n        return node.kind === SyntaxKind.ExpressionStatement\r\n            && (<ExpressionStatement>node).expression.kind === SyntaxKind.StringLiteral;\r\n    }\r\n\r\n    export function getLeadingCommentRangesOfNode(node: Node, sourceFileOfNode: SourceFile) {\r\n        return node.kind !== SyntaxKind.JsxText ? getLeadingCommentRanges(sourceFileOfNode.text, node.pos) : undefined;\r\n    }\r\n\r\n    export function getJSDocCommentRanges(node: Node, text: string) {\r\n        const commentRanges = (node.kind === SyntaxKind.Parameter ||\r\n            node.kind === SyntaxKind.TypeParameter ||\r\n            node.kind === SyntaxKind.FunctionExpression ||\r\n            node.kind === SyntaxKind.ArrowFunction ||\r\n            node.kind === SyntaxKind.ParenthesizedExpression) ?\r\n            concatenate(getTrailingCommentRanges(text, node.pos), getLeadingCommentRanges(text, node.pos)) :\r\n            getLeadingCommentRanges(text, node.pos);\r\n        // True if the comment starts with '/**' but not if it is '/**/'\r\n        return filter(commentRanges, comment =>\r\n            text.charCodeAt(comment.pos + 1) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(comment.pos + 2) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(comment.pos + 3) !== CharacterCodes.slash);\r\n    }\r\n\r\n    export const fullTripleSlashReferencePathRegEx = /^(\\/\\/\\/\\s*<reference\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n    const fullTripleSlashReferenceTypeReferenceDirectiveRegEx = /^(\\/\\/\\/\\s*<reference\\s+types\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n    export const fullTripleSlashAMDReferencePathRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\r\n    const defaultLibReferenceRegEx = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib\\s*=\\s*)('|\")(.+?)\\2\\s*\\/>/;\r\n\r\n    export function isPartOfTypeNode(node: Node): boolean {\r\n        if (SyntaxKind.FirstTypeNode <= node.kind && node.kind <= SyntaxKind.LastTypeNode) {\r\n            return true;\r\n        }\r\n\r\n        switch (node.kind) {\r\n            case SyntaxKind.AnyKeyword:\r\n            case SyntaxKind.NumberKeyword:\r\n            case SyntaxKind.StringKeyword:\r\n            case SyntaxKind.BooleanKeyword:\r\n            case SyntaxKind.SymbolKeyword:\r\n            case SyntaxKind.UndefinedKeyword:\r\n            case SyntaxKind.NeverKeyword:\r\n                return true;\r\n            case SyntaxKind.VoidKeyword:\r\n                return node.parent.kind !== SyntaxKind.VoidExpression;\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return !isExpressionWithTypeArgumentsInClassExtendsClause(node);\r\n            case SyntaxKind.TypeParameter:\r\n                return node.parent.kind === SyntaxKind.MappedType || node.parent.kind === SyntaxKind.InferType;\r\n\r\n            // Identifiers and qualified names may be type nodes, depending on their context. Climb\r\n            // above them to find the lowest container\r\n            case SyntaxKind.Identifier:\r\n                // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.\r\n                if (node.parent.kind === SyntaxKind.QualifiedName && (<QualifiedName>node.parent).right === node) {\r\n                    node = node.parent;\r\n                }\r\n                else if (node.parent.kind === SyntaxKind.PropertyAccessExpression && (<PropertyAccessExpression>node.parent).name === node) {\r\n                    node = node.parent;\r\n                }\r\n                // At this point, node is either a qualified name or an identifier\r\n                Debug.assert(node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.QualifiedName || node.kind === SyntaxKind.PropertyAccessExpression,\r\n                    \"'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.\");\r\n                // falls through\r\n            case SyntaxKind.QualifiedName:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ThisKeyword:\r\n                const parent = node.parent;\r\n                if (parent.kind === SyntaxKind.TypeQuery) {\r\n                    return false;\r\n                }\r\n                if (parent.kind === SyntaxKind.ImportType) {\r\n                    return !(parent as ImportTypeNode).isTypeOf;\r\n                }\r\n                // Do not recursively call isPartOfTypeNode on the parent. In the example:\r\n                //\r\n                //     let a: A.B.C;\r\n                //\r\n                // Calling isPartOfTypeNode would consider the qualified name A.B a type node.\r\n                // Only C and A.B.C are type nodes.\r\n                if (SyntaxKind.FirstTypeNode <= parent.kind && parent.kind <= SyntaxKind.LastTypeNode) {\r\n                    return true;\r\n                }\r\n                switch (parent.kind) {\r\n                    case SyntaxKind.ExpressionWithTypeArguments:\r\n                        return !isExpressionWithTypeArgumentsInClassExtendsClause(parent);\r\n                    case SyntaxKind.TypeParameter:\r\n                        return node === (<TypeParameterDeclaration>parent).constraint;\r\n                    case SyntaxKind.PropertyDeclaration:\r\n                    case SyntaxKind.PropertySignature:\r\n                    case SyntaxKind.Parameter:\r\n                    case SyntaxKind.VariableDeclaration:\r\n                        return node === (parent as HasType).type;\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ArrowFunction:\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.MethodDeclaration:\r\n                    case SyntaxKind.MethodSignature:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                        return node === (<FunctionLikeDeclaration>parent).type;\r\n                    case SyntaxKind.CallSignature:\r\n                    case SyntaxKind.ConstructSignature:\r\n                    case SyntaxKind.IndexSignature:\r\n                        return node === (<SignatureDeclaration>parent).type;\r\n                    case SyntaxKind.TypeAssertionExpression:\r\n                        return node === (<TypeAssertion>parent).type;\r\n                    case SyntaxKind.CallExpression:\r\n                    case SyntaxKind.NewExpression:\r\n                        return contains((<CallExpression>parent).typeArguments, node);\r\n                    case SyntaxKind.TaggedTemplateExpression:\r\n                        // TODO (drosen): TaggedTemplateExpressions may eventually support type arguments.\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function isChildOfNodeWithKind(node: Node, kind: SyntaxKind): boolean {\r\n        while (node) {\r\n            if (node.kind === kind) {\r\n                return true;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Warning: This has the same semantics as the forEach family of functions,\r\n    //          in that traversal terminates in the event that 'visitor' supplies a truthy value.\r\n    export function forEachReturnStatement<T>(body: Block, visitor: (stmt: ReturnStatement) => T): T {\r\n\r\n        return traverse(body);\r\n\r\n        function traverse(node: Node): T {\r\n            switch (node.kind) {\r\n                case SyntaxKind.ReturnStatement:\r\n                    return visitor(<ReturnStatement>node);\r\n                case SyntaxKind.CaseBlock:\r\n                case SyntaxKind.Block:\r\n                case SyntaxKind.IfStatement:\r\n                case SyntaxKind.DoStatement:\r\n                case SyntaxKind.WhileStatement:\r\n                case SyntaxKind.ForStatement:\r\n                case SyntaxKind.ForInStatement:\r\n                case SyntaxKind.ForOfStatement:\r\n                case SyntaxKind.WithStatement:\r\n                case SyntaxKind.SwitchStatement:\r\n                case SyntaxKind.CaseClause:\r\n                case SyntaxKind.DefaultClause:\r\n                case SyntaxKind.LabeledStatement:\r\n                case SyntaxKind.TryStatement:\r\n                case SyntaxKind.CatchClause:\r\n                    return forEachChild(node, traverse);\r\n            }\r\n        }\r\n    }\r\n\r\n    export function forEachYieldExpression(body: Block, visitor: (expr: YieldExpression) => void): void {\r\n\r\n        return traverse(body);\r\n\r\n        function traverse(node: Node): void {\r\n            switch (node.kind) {\r\n                case SyntaxKind.YieldExpression:\r\n                    visitor(<YieldExpression>node);\r\n                    const operand = (<YieldExpression>node).expression;\r\n                    if (operand) {\r\n                        traverse(operand);\r\n                    }\r\n                    return;\r\n                case SyntaxKind.EnumDeclaration:\r\n                case SyntaxKind.InterfaceDeclaration:\r\n                case SyntaxKind.ModuleDeclaration:\r\n                case SyntaxKind.TypeAliasDeclaration:\r\n                case SyntaxKind.ClassDeclaration:\r\n                case SyntaxKind.ClassExpression:\r\n                    // These are not allowed inside a generator now, but eventually they may be allowed\r\n                    // as local types. Regardless, any yield statements contained within them should be\r\n                    // skipped in this traversal.\r\n                    return;\r\n                default:\r\n                    if (isFunctionLike(node)) {\r\n                        if (node.name && node.name.kind === SyntaxKind.ComputedPropertyName) {\r\n                            // Note that we will not include methods/accessors of a class because they would require\r\n                            // first descending into the class. This is by design.\r\n                            traverse(node.name.expression);\r\n                            return;\r\n                        }\r\n                    }\r\n                    else if (!isPartOfTypeNode(node)) {\r\n                        // This is the general case, which should include mostly expressions and statements.\r\n                        // Also includes NodeArrays.\r\n                        forEachChild(node, traverse);\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the most likely element type for a TypeNode. This is not an exhaustive test\r\n     * as it assumes a rest argument can only be an array type (either T[], or Array<T>).\r\n     *\r\n     * @param node The type node.\r\n     */\r\n    export function getRestParameterElementType(node: TypeNode) {\r\n        if (node && node.kind === SyntaxKind.ArrayType) {\r\n            return (<ArrayTypeNode>node).elementType;\r\n        }\r\n        else if (node && node.kind === SyntaxKind.TypeReference) {\r\n            return singleOrUndefined((<TypeReferenceNode>node).typeArguments);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    export function getMembersOfDeclaration(node: Declaration): NodeArray<ClassElement | TypeElement | ObjectLiteralElement> | undefined {\r\n        switch (node.kind) {\r\n            case SyntaxKind.InterfaceDeclaration:\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.TypeLiteral:\r\n                return (<ObjectTypeDeclaration>node).members;\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n                return (<ObjectLiteralExpression>node).properties;\r\n        }\r\n    }\r\n\r\n    export function isVariableLike(node: Node): node is VariableLikeDeclaration {\r\n        if (node) {\r\n            switch (node.kind) {\r\n                case SyntaxKind.BindingElement:\r\n                case SyntaxKind.EnumMember:\r\n                case SyntaxKind.Parameter:\r\n                case SyntaxKind.PropertyAssignment:\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                case SyntaxKind.ShorthandPropertyAssignment:\r\n                case SyntaxKind.VariableDeclaration:\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isVariableLikeOrAccessor(node: Node): node is AccessorDeclaration | VariableLikeDeclaration {\r\n        return isVariableLike(node) || isAccessor(node);\r\n    }\r\n\r\n    export function isVariableDeclarationInVariableStatement(node: VariableDeclaration) {\r\n        return node.parent.kind === SyntaxKind.VariableDeclarationList\r\n            && node.parent.parent.kind === SyntaxKind.VariableStatement;\r\n    }\r\n\r\n    export function isValidESSymbolDeclaration(node: Node) {\r\n        return isVariableDeclaration(node) ? isConst(node) && isIdentifier(node.name) && isVariableDeclarationInVariableStatement(node) :\r\n            isPropertyDeclaration(node) ? hasReadonlyModifier(node) && hasStaticModifier(node) :\r\n            isPropertySignature(node) && hasReadonlyModifier(node);\r\n    }\r\n\r\n    export function introducesArgumentsExoticObject(node: Node) {\r\n        switch (node.kind) {\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function unwrapInnermostStatementOfLabel(node: LabeledStatement, beforeUnwrapLabelCallback?: (node: LabeledStatement) => void) {\r\n        while (true) {\r\n            if (beforeUnwrapLabelCallback) {\r\n                beforeUnwrapLabelCallback(node);\r\n            }\r\n            if (node.statement.kind !== SyntaxKind.LabeledStatement) {\r\n                return node.statement;\r\n            }\r\n            node = <LabeledStatement>node.statement;\r\n        }\r\n    }\r\n\r\n    export function isFunctionBlock(node: Node) {\r\n        return node && node.kind === SyntaxKind.Block && isFunctionLike(node.parent);\r\n    }\r\n\r\n    export function isObjectLiteralMethod(node: Node): node is MethodDeclaration {\r\n        return node && node.kind === SyntaxKind.MethodDeclaration && node.parent.kind === SyntaxKind.ObjectLiteralExpression;\r\n    }\r\n\r\n    export function isObjectLiteralOrClassExpressionMethod(node: Node): node is MethodDeclaration {\r\n        return node.kind === SyntaxKind.MethodDeclaration &&\r\n            (node.parent.kind === SyntaxKind.ObjectLiteralExpression ||\r\n                node.parent.kind === SyntaxKind.ClassExpression);\r\n    }\r\n\r\n    export function isIdentifierTypePredicate(predicate: TypePredicate): predicate is IdentifierTypePredicate {\r\n        return predicate && predicate.kind === TypePredicateKind.Identifier;\r\n    }\r\n\r\n    export function isThisTypePredicate(predicate: TypePredicate): predicate is ThisTypePredicate {\r\n        return predicate && predicate.kind === TypePredicateKind.This;\r\n    }\r\n\r\n    export function getPropertyAssignment(objectLiteral: ObjectLiteralExpression, key: string, key2?: string): ReadonlyArray<PropertyAssignment> {\r\n        return filter(objectLiteral.properties, (property): property is PropertyAssignment => {\r\n            if (property.kind === SyntaxKind.PropertyAssignment) {\r\n                const propName = getTextOfPropertyName(property.name);\r\n                return key === propName || (key2 && key2 === propName);\r\n            }\r\n        });\r\n    }\r\n\r\n    export function getContainingFunction(node: Node): SignatureDeclaration {\r\n        return findAncestor(node.parent, isFunctionLike);\r\n    }\r\n\r\n    export function getContainingClass(node: Node): ClassLikeDeclaration {\r\n        return findAncestor(node.parent, isClassLike);\r\n    }\r\n\r\n    export function getThisContainer(node: Node, includeArrowFunctions: boolean): Node {\r\n        while (true) {\r\n            node = node.parent;\r\n            if (!node) {\r\n                return undefined;\r\n            }\r\n            switch (node.kind) {\r\n                case SyntaxKind.ComputedPropertyName:\r\n                    // If the grandparent node is an object literal (as opposed to a class),\r\n                    // then the computed property is not a 'this' container.\r\n                    // A computed property name in a class needs to be a this container\r\n                    // so that we can error on it.\r\n                    if (isClassLike(node.parent.parent)) {\r\n                        return node;\r\n                    }\r\n                    // If this is a computed property, then the parent should not\r\n                    // make it a this container. The parent might be a property\r\n                    // in an object literal, like a method or accessor. But in order for\r\n                    // such a parent to be a this container, the reference must be in\r\n                    // the *body* of the container.\r\n                    node = node.parent;\r\n                    break;\r\n                case SyntaxKind.Decorator:\r\n                    // Decorators are always applied outside of the body of a class or method.\r\n                    if (node.parent.kind === SyntaxKind.Parameter && isClassElement(node.parent.parent)) {\r\n                        // If the decorator's parent is a Parameter, we resolve the this container from\r\n                        // the grandparent class declaration.\r\n                        node = node.parent.parent;\r\n                    }\r\n                    else if (isClassElement(node.parent)) {\r\n                        // If the decorator's parent is a class element, we resolve the 'this' container\r\n                        // from the parent class declaration.\r\n                        node = node.parent;\r\n                    }\r\n                    break;\r\n                case SyntaxKind.ArrowFunction:\r\n                    if (!includeArrowFunctions) {\r\n                        continue;\r\n                    }\r\n                    // falls through\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ModuleDeclaration:\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                case SyntaxKind.MethodDeclaration:\r\n                case SyntaxKind.MethodSignature:\r\n                case SyntaxKind.Constructor:\r\n                case SyntaxKind.GetAccessor:\r\n                case SyntaxKind.SetAccessor:\r\n                case SyntaxKind.CallSignature:\r\n                case SyntaxKind.ConstructSignature:\r\n                case SyntaxKind.IndexSignature:\r\n                case SyntaxKind.EnumDeclaration:\r\n                case SyntaxKind.SourceFile:\r\n                    return node;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function getNewTargetContainer(node: Node) {\r\n        const container = getThisContainer(node, /*includeArrowFunctions*/ false);\r\n        if (container) {\r\n            switch (container.kind) {\r\n                case SyntaxKind.Constructor:\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.FunctionExpression:\r\n                    return container;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Given an super call/property node, returns the closest node where\r\n     * - a super call/property access is legal in the node and not legal in the parent node the node.\r\n     *   i.e. super call is legal in constructor but not legal in the class body.\r\n     * - the container is an arrow function (so caller might need to call getSuperContainer again in case it needs to climb higher)\r\n     * - a super call/property is definitely illegal in the container (but might be legal in some subnode)\r\n     *   i.e. super property access is illegal in function declaration but can be legal in the statement list\r\n     */\r\n    export function getSuperContainer(node: Node, stopOnFunctions: boolean): Node {\r\n        while (true) {\r\n            node = node.parent;\r\n            if (!node) {\r\n                return node;\r\n            }\r\n            switch (node.kind) {\r\n                case SyntaxKind.ComputedPropertyName:\r\n                    node = node.parent;\r\n                    break;\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ArrowFunction:\r\n                    if (!stopOnFunctions) {\r\n                        continue;\r\n                    }\r\n                    // falls through\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                case SyntaxKind.MethodDeclaration:\r\n                case SyntaxKind.MethodSignature:\r\n                case SyntaxKind.Constructor:\r\n                case SyntaxKind.GetAccessor:\r\n                case SyntaxKind.SetAccessor:\r\n                    return node;\r\n                case SyntaxKind.Decorator:\r\n                    // Decorators are always applied outside of the body of a class or method.\r\n                    if (node.parent.kind === SyntaxKind.Parameter && isClassElement(node.parent.parent)) {\r\n                        // If the decorator's parent is a Parameter, we resolve the this container from\r\n                        // the grandparent class declaration.\r\n                        node = node.parent.parent;\r\n                    }\r\n                    else if (isClassElement(node.parent)) {\r\n                        // If the decorator's parent is a class element, we resolve the 'this' container\r\n                        // from the parent class declaration.\r\n                        node = node.parent;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function getImmediatelyInvokedFunctionExpression(func: Node): CallExpression {\r\n        if (func.kind === SyntaxKind.FunctionExpression || func.kind === SyntaxKind.ArrowFunction) {\r\n            let prev = func;\r\n            let parent = func.parent;\r\n            while (parent.kind === SyntaxKind.ParenthesizedExpression) {\r\n                prev = parent;\r\n                parent = parent.parent;\r\n            }\r\n            if (parent.kind === SyntaxKind.CallExpression && (parent as CallExpression).expression === prev) {\r\n                return parent as CallExpression;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is a property or element access expression for `super`.\r\n     */\r\n    export function isSuperProperty(node: Node): node is SuperProperty {\r\n        const kind = node.kind;\r\n        return (kind === SyntaxKind.PropertyAccessExpression || kind === SyntaxKind.ElementAccessExpression)\r\n            && (<PropertyAccessExpression | ElementAccessExpression>node).expression.kind === SyntaxKind.SuperKeyword;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is a property or element access expression for `this`.\r\n     */\r\n    export function isThisProperty(node: Node): boolean {\r\n        const kind = node.kind;\r\n        return (kind === SyntaxKind.PropertyAccessExpression || kind === SyntaxKind.ElementAccessExpression)\r\n            && (<PropertyAccessExpression | ElementAccessExpression>node).expression.kind === SyntaxKind.ThisKeyword;\r\n    }\r\n\r\n    export function getEntityNameFromTypeNode(node: TypeNode): EntityNameOrEntityNameExpression {\r\n        switch (node.kind) {\r\n            case SyntaxKind.TypeReference:\r\n                return (<TypeReferenceNode>node).typeName;\r\n\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return isEntityNameExpression((<ExpressionWithTypeArguments>node).expression)\r\n                    ? <EntityNameExpression>(<ExpressionWithTypeArguments>node).expression\r\n                    : undefined;\r\n\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.QualifiedName:\r\n                return (<EntityName><Node>node);\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function getInvokedExpression(node: CallLikeExpression): Expression {\r\n        switch (node.kind) {\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n                return node.tag;\r\n            case SyntaxKind.JsxOpeningElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n                return node.tagName;\r\n            default:\r\n                return node.expression;\r\n        }\r\n    }\r\n\r\n    export function nodeCanBeDecorated(node: ClassDeclaration): true;\r\n    export function nodeCanBeDecorated(node: ClassElement, parent: Node): boolean;\r\n    export function nodeCanBeDecorated(node: Node, parent: Node, grandparent: Node): boolean;\r\n    export function nodeCanBeDecorated(node: Node, parent?: Node, grandparent?: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ClassDeclaration:\r\n                // classes are valid targets\r\n                return true;\r\n\r\n            case SyntaxKind.PropertyDeclaration:\r\n                // property declarations are valid if their parent is a class declaration.\r\n                return parent.kind === SyntaxKind.ClassDeclaration;\r\n\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.MethodDeclaration:\r\n                // if this method has a body and its parent is a class declaration, this is a valid target.\r\n                return (<FunctionLikeDeclaration>node).body !== undefined\r\n                    && parent.kind === SyntaxKind.ClassDeclaration;\r\n\r\n            case SyntaxKind.Parameter:\r\n                // if the parameter's parent has a body and its grandparent is a class declaration, this is a valid target;\r\n                return (<FunctionLikeDeclaration>parent).body !== undefined\r\n                    && (parent.kind === SyntaxKind.Constructor\r\n                        || parent.kind === SyntaxKind.MethodDeclaration\r\n                        || parent.kind === SyntaxKind.SetAccessor)\r\n                    && grandparent.kind === SyntaxKind.ClassDeclaration;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function nodeIsDecorated(node: ClassDeclaration): boolean;\r\n    export function nodeIsDecorated(node: ClassElement, parent: Node): boolean;\r\n    export function nodeIsDecorated(node: Node, parent: Node, grandparent: Node): boolean;\r\n    export function nodeIsDecorated(node: Node, parent?: Node, grandparent?: Node): boolean {\r\n        return node.decorators !== undefined\r\n            && nodeCanBeDecorated(node, parent, grandparent);\r\n    }\r\n\r\n    export function nodeOrChildIsDecorated(node: ClassDeclaration): boolean;\r\n    export function nodeOrChildIsDecorated(node: ClassElement, parent: Node): boolean;\r\n    export function nodeOrChildIsDecorated(node: Node, parent: Node, grandparent: Node): boolean;\r\n    export function nodeOrChildIsDecorated(node: Node, parent?: Node, grandparent?: Node): boolean {\r\n        return nodeIsDecorated(node, parent, grandparent) || childIsDecorated(node, parent);\r\n    }\r\n\r\n    export function childIsDecorated(node: ClassDeclaration): boolean;\r\n    export function childIsDecorated(node: Node, parent: Node): boolean;\r\n    export function childIsDecorated(node: Node, parent?: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ClassDeclaration:\r\n                return forEach((<ClassDeclaration>node).members, m => nodeOrChildIsDecorated(m, node, parent));\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.SetAccessor:\r\n                return forEach((<FunctionLikeDeclaration>node).parameters, p => nodeIsDecorated(p, node, parent));\r\n        }\r\n    }\r\n\r\n    export function isJSXTagName(node: Node) {\r\n        const parent = node.parent;\r\n        if (parent.kind === SyntaxKind.JsxOpeningElement ||\r\n            parent.kind === SyntaxKind.JsxSelfClosingElement ||\r\n            parent.kind === SyntaxKind.JsxClosingElement) {\r\n            return (<JsxOpeningLikeElement>parent).tagName === node;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isExpressionNode(node: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.SuperKeyword:\r\n            case SyntaxKind.NullKeyword:\r\n            case SyntaxKind.TrueKeyword:\r\n            case SyntaxKind.FalseKeyword:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ElementAccessExpression:\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.NewExpression:\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.AsExpression:\r\n            case SyntaxKind.TypeAssertionExpression:\r\n            case SyntaxKind.NonNullExpression:\r\n            case SyntaxKind.ParenthesizedExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n            case SyntaxKind.BinaryExpression:\r\n            case SyntaxKind.ConditionalExpression:\r\n            case SyntaxKind.SpreadElement:\r\n            case SyntaxKind.TemplateExpression:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.OmittedExpression:\r\n            case SyntaxKind.JsxElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.JsxFragment:\r\n            case SyntaxKind.YieldExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n            case SyntaxKind.MetaProperty:\r\n                return true;\r\n            case SyntaxKind.QualifiedName:\r\n                while (node.parent.kind === SyntaxKind.QualifiedName) {\r\n                    node = node.parent;\r\n                }\r\n                return node.parent.kind === SyntaxKind.TypeQuery || isJSXTagName(node);\r\n            case SyntaxKind.Identifier:\r\n                if (node.parent.kind === SyntaxKind.TypeQuery || isJSXTagName(node)) {\r\n                    return true;\r\n                }\r\n                // falls through\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.ThisKeyword:\r\n                return isInExpressionContext(node);\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isInExpressionContext(node: Node): boolean {\r\n        const parent = node.parent;\r\n        switch (parent.kind) {\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.Parameter:\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.EnumMember:\r\n            case SyntaxKind.PropertyAssignment:\r\n            case SyntaxKind.BindingElement:\r\n                return (parent as HasInitializer).initializer === node;\r\n            case SyntaxKind.ExpressionStatement:\r\n            case SyntaxKind.IfStatement:\r\n            case SyntaxKind.DoStatement:\r\n            case SyntaxKind.WhileStatement:\r\n            case SyntaxKind.ReturnStatement:\r\n            case SyntaxKind.WithStatement:\r\n            case SyntaxKind.SwitchStatement:\r\n            case SyntaxKind.CaseClause:\r\n            case SyntaxKind.ThrowStatement:\r\n                return (<ExpressionStatement>parent).expression === node;\r\n            case SyntaxKind.ForStatement:\r\n                const forStatement = <ForStatement>parent;\r\n                return (forStatement.initializer === node && forStatement.initializer.kind !== SyntaxKind.VariableDeclarationList) ||\r\n                    forStatement.condition === node ||\r\n                    forStatement.incrementor === node;\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n                const forInStatement = <ForInStatement | ForOfStatement>parent;\r\n                return (forInStatement.initializer === node && forInStatement.initializer.kind !== SyntaxKind.VariableDeclarationList) ||\r\n                    forInStatement.expression === node;\r\n            case SyntaxKind.TypeAssertionExpression:\r\n            case SyntaxKind.AsExpression:\r\n                return node === (<AssertionExpression>parent).expression;\r\n            case SyntaxKind.TemplateSpan:\r\n                return node === (<TemplateSpan>parent).expression;\r\n            case SyntaxKind.ComputedPropertyName:\r\n                return node === (<ComputedPropertyName>parent).expression;\r\n            case SyntaxKind.Decorator:\r\n            case SyntaxKind.JsxExpression:\r\n            case SyntaxKind.JsxSpreadAttribute:\r\n            case SyntaxKind.SpreadAssignment:\r\n                return true;\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return (<ExpressionWithTypeArguments>parent).expression === node && isExpressionWithTypeArgumentsInClassExtendsClause(parent);\r\n            default:\r\n                return isExpressionNode(parent);\r\n        }\r\n    }\r\n\r\n    export function isExternalModuleImportEqualsDeclaration(node: Node) {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration && (<ImportEqualsDeclaration>node).moduleReference.kind === SyntaxKind.ExternalModuleReference;\r\n    }\r\n\r\n    export function getExternalModuleImportEqualsDeclarationExpression(node: Node) {\r\n        Debug.assert(isExternalModuleImportEqualsDeclaration(node));\r\n        return (<ExternalModuleReference>(<ImportEqualsDeclaration>node).moduleReference).expression;\r\n    }\r\n\r\n    export function isInternalModuleImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration && (<ImportEqualsDeclaration>node).moduleReference.kind !== SyntaxKind.ExternalModuleReference;\r\n    }\r\n\r\n    export function isSourceFileJavaScript(file: SourceFile): boolean {\r\n        return isInJavaScriptFile(file);\r\n    }\r\n\r\n    export function isSourceFileNotJavaScript(file: SourceFile): boolean {\r\n        return !isInJavaScriptFile(file);\r\n    }\r\n\r\n    export function isInJavaScriptFile(node: Node | undefined): boolean {\r\n        return node && !!(node.flags & NodeFlags.JavaScriptFile);\r\n    }\r\n\r\n    export function isInJSDoc(node: Node | undefined): boolean {\r\n        return node && !!(node.flags & NodeFlags.JSDoc);\r\n    }\r\n\r\n    export function isJSDocIndexSignature(node: TypeReferenceNode | ExpressionWithTypeArguments) {\r\n        return isTypeReferenceNode(node) &&\r\n            isIdentifier(node.typeName) &&\r\n            node.typeName.escapedText === \"Object\" &&\r\n            node.typeArguments && node.typeArguments.length === 2 &&\r\n            (node.typeArguments[0].kind === SyntaxKind.StringKeyword || node.typeArguments[0].kind === SyntaxKind.NumberKeyword);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the node is a CallExpression to the identifier 'require' with\r\n     * exactly one argument (of the form 'require(\"name\")').\r\n     * This function does not test if the node is in a JavaScript file or not.\r\n     */\r\n    export function isRequireCall(callExpression: Node, checkArgumentIsStringLiteralLike: true): callExpression is RequireOrImportCall & { expression: Identifier, arguments: [StringLiteralLike] };\r\n    export function isRequireCall(callExpression: Node, checkArgumentIsStringLiteralLike: boolean): callExpression is CallExpression;\r\n    export function isRequireCall(callExpression: Node, checkArgumentIsStringLiteralLike: boolean): callExpression is CallExpression {\r\n        if (callExpression.kind !== SyntaxKind.CallExpression) {\r\n            return false;\r\n        }\r\n        const { expression, arguments: args } = callExpression as CallExpression;\r\n\r\n        if (expression.kind !== SyntaxKind.Identifier || (expression as Identifier).escapedText !== \"require\") {\r\n            return false;\r\n        }\r\n\r\n        if (args.length !== 1) {\r\n            return false;\r\n        }\r\n        const arg = args[0];\r\n        return !checkArgumentIsStringLiteralLike || isStringLiteralLike(arg);\r\n    }\r\n\r\n    export function isSingleOrDoubleQuote(charCode: number) {\r\n        return charCode === CharacterCodes.singleQuote || charCode === CharacterCodes.doubleQuote;\r\n    }\r\n\r\n    export function isStringDoubleQuoted(str: StringLiteralLike, sourceFile: SourceFile): boolean {\r\n        return getSourceTextOfNodeFromSourceFile(sourceFile, str).charCodeAt(0) === CharacterCodes.doubleQuote;\r\n    }\r\n\r\n    /**\r\n     * Given the symbol of a declaration, find the symbol of its Javascript container-like initializer,\r\n     * if it has one. Otherwise just return the original symbol.\r\n     *\r\n     * Container-like initializer behave like namespaces, so the binder needs to add contained symbols\r\n     * to their exports. An example is a function with assignments to `this` inside.\r\n     */\r\n    export function getJSInitializerSymbol(symbol: Symbol) {\r\n        if (!symbol || !symbol.valueDeclaration) {\r\n            return symbol;\r\n        }\r\n        const declaration = symbol.valueDeclaration;\r\n        const e = getDeclaredJavascriptInitializer(declaration) || getAssignedJavascriptInitializer(declaration);\r\n        return e && e.symbol ? e.symbol : symbol;\r\n    }\r\n\r\n    /** Get the declaration initializer, when the initializer is container-like (See getJavascriptInitializer) */\r\n    export function getDeclaredJavascriptInitializer(node: Node) {\r\n        if (node && isVariableDeclaration(node) && node.initializer) {\r\n            return getJavascriptInitializer(node.initializer, /*isPrototypeAssignment*/ false) ||\r\n                isIdentifier(node.name) && getDefaultedJavascriptInitializer(node.name, node.initializer, /*isPrototypeAssignment*/ false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the assignment 'initializer' -- the righthand side-- when the initializer is container-like (See getJavascriptInitializer).\r\n     * We treat the right hand side of assignments with container-like initalizers as declarations.\r\n     */\r\n    export function getAssignedJavascriptInitializer(node: Node) {\r\n        if (node && node.parent && isBinaryExpression(node.parent) && node.parent.operatorToken.kind === SyntaxKind.EqualsToken) {\r\n            const isPrototypeAssignment = isPrototypeAccess(node.parent.left);\r\n            return getJavascriptInitializer(node.parent.right, isPrototypeAssignment) ||\r\n                getDefaultedJavascriptInitializer(node.parent.left as EntityNameExpression, node.parent.right, isPrototypeAssignment);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recognized Javascript container-like initializers are:\r\n     * 1. (function() {})() -- IIFEs\r\n     * 2. function() { } -- Function expressions\r\n     * 3. class { } -- Class expressions\r\n     * 4. {} -- Empty object literals\r\n     * 5. { ... } -- Non-empty object literals, when used to initialize a prototype, like `C.prototype = { m() { } }`\r\n     *\r\n     * This function returns the provided initializer, or undefined if it is not valid.\r\n     */\r\n    export function getJavascriptInitializer(initializer: Node, isPrototypeAssignment: boolean): Expression {\r\n        if (isCallExpression(initializer)) {\r\n            const e = skipParentheses(initializer.expression);\r\n            return e.kind === SyntaxKind.FunctionExpression || e.kind === SyntaxKind.ArrowFunction ? initializer : undefined;\r\n        }\r\n        if (initializer.kind === SyntaxKind.FunctionExpression ||\r\n            initializer.kind === SyntaxKind.ClassExpression ||\r\n            initializer.kind === SyntaxKind.ArrowFunction) {\r\n            return initializer as Expression;\r\n        }\r\n        if (isObjectLiteralExpression(initializer) && (initializer.properties.length === 0 || isPrototypeAssignment)) {\r\n            return initializer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A defaulted Javascript initializer matches the pattern\r\n     * `Lhs = Lhs || JavascriptInitializer`\r\n     * or `var Lhs = Lhs || JavascriptInitializer`\r\n     *\r\n     * The second Lhs is required to be the same as the first except that it may be prefixed with\r\n     * 'window.', 'global.' or 'self.' The second Lhs is otherwise ignored by the binder and checker.\r\n     */\r\n    function getDefaultedJavascriptInitializer(name: EntityNameExpression, initializer: Expression, isPrototypeAssignment: boolean) {\r\n        const e = isBinaryExpression(initializer) && initializer.operatorToken.kind === SyntaxKind.BarBarToken && getJavascriptInitializer(initializer.right, isPrototypeAssignment);\r\n        if (e && isSameEntityName(name, (initializer as BinaryExpression).left as EntityNameExpression)) {\r\n            return e;\r\n        }\r\n    }\r\n\r\n    /** Given a Javascript initializer, return the outer name. That is, the lhs of the assignment or the declaration name. */\r\n    export function getOuterNameOfJsInitializer(node: Declaration): DeclarationName | undefined {\r\n        if (isBinaryExpression(node.parent)) {\r\n            const parent = (node.parent.operatorToken.kind === SyntaxKind.BarBarToken && isBinaryExpression(node.parent.parent)) ? node.parent.parent : node.parent;\r\n            if (parent.operatorToken.kind === SyntaxKind.EqualsToken && isIdentifier(parent.left)) {\r\n                return parent.left;\r\n            }\r\n        }\r\n        else if (isVariableDeclaration(node.parent)) {\r\n            return node.parent.name;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the 'declared' name the same as the one in the initializer?\r\n     * @return true for identical entity names, as well as ones where the initializer is prefixed with\r\n     * 'window', 'self' or 'global'. For example:\r\n     *\r\n     * var my = my || {}\r\n     * var min = window.min || {}\r\n     * my.app = self.my.app || class { }\r\n     */\r\n    function isSameEntityName(name: EntityNameExpression, initializer: EntityNameExpression): boolean {\r\n        if (isIdentifier(name) && isIdentifier(initializer)) {\r\n            return name.escapedText === initializer.escapedText;\r\n        }\r\n        if (isIdentifier(name) && isPropertyAccessExpression(initializer)) {\r\n            return (initializer.expression.kind as SyntaxKind.ThisKeyword === SyntaxKind.ThisKeyword ||\r\n                    isIdentifier(initializer.expression) &&\r\n                    (initializer.expression.escapedText === \"window\" as __String ||\r\n                     initializer.expression.escapedText === \"self\" as __String ||\r\n                     initializer.expression.escapedText === \"global\" as __String)) &&\r\n                isSameEntityName(name, initializer.name);\r\n        }\r\n        if (isPropertyAccessExpression(name) && isPropertyAccessExpression(initializer)) {\r\n            return name.name.escapedText === initializer.name.escapedText && isSameEntityName(name.expression, initializer.expression);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function getRightMostAssignedExpression(node: Expression): Expression {\r\n        while (isAssignmentExpression(node, /*excludeCompoundAssignements*/ true)) {\r\n            node = node.right;\r\n        }\r\n        return node;\r\n    }\r\n\r\n    export function isExportsIdentifier(node: Node) {\r\n        return isIdentifier(node) && node.escapedText === \"exports\";\r\n    }\r\n\r\n    export function isModuleExportsPropertyAccessExpression(node: Node) {\r\n        return isPropertyAccessExpression(node) && isIdentifier(node.expression) && node.expression.escapedText === \"module\" && node.name.escapedText === \"exports\";\r\n    }\r\n\r\n    /// Given a BinaryExpression, returns SpecialPropertyAssignmentKind for the various kinds of property\r\n    /// assignments we treat as special in the binder\r\n    export function getSpecialPropertyAssignmentKind(expr: BinaryExpression): SpecialPropertyAssignmentKind {\r\n        if (!isInJavaScriptFile(expr) ||\r\n            expr.operatorToken.kind !== SyntaxKind.EqualsToken ||\r\n            !isPropertyAccessExpression(expr.left)) {\r\n            return SpecialPropertyAssignmentKind.None;\r\n        }\r\n        const lhs = expr.left;\r\n        if (lhs.expression.kind === SyntaxKind.ThisKeyword) {\r\n            return SpecialPropertyAssignmentKind.ThisProperty;\r\n        }\r\n        else if (isIdentifier(lhs.expression) && lhs.expression.escapedText === \"module\" && lhs.name.escapedText === \"exports\") {\r\n            // module.exports = expr\r\n            return SpecialPropertyAssignmentKind.ModuleExports;\r\n        }\r\n        else if (isEntityNameExpression(lhs.expression)) {\r\n            if (lhs.name.escapedText === \"prototype\" && isObjectLiteralExpression(getInitializerOfBinaryExpression(expr))) {\r\n                // F.prototype = { ... }\r\n                return SpecialPropertyAssignmentKind.Prototype;\r\n            }\r\n            else if (isPrototypeAccess(lhs.expression)) {\r\n                // F.G....prototype.x = expr\r\n                return SpecialPropertyAssignmentKind.PrototypeProperty;\r\n            }\r\n\r\n            let nextToLast = lhs;\r\n            while (isPropertyAccessExpression(nextToLast.expression)) {\r\n                nextToLast = nextToLast.expression;\r\n            }\r\n            Debug.assert(isIdentifier(nextToLast.expression));\r\n            const id = nextToLast.expression as Identifier;\r\n            if (id.escapedText === \"exports\" ||\r\n                id.escapedText === \"module\" && nextToLast.name.escapedText === \"exports\") {\r\n                // exports.name = expr OR module.exports.name = expr\r\n                return SpecialPropertyAssignmentKind.ExportsProperty;\r\n            }\r\n            // F.G...x = expr\r\n            return SpecialPropertyAssignmentKind.Property;\r\n        }\r\n\r\n        return SpecialPropertyAssignmentKind.None;\r\n    }\r\n\r\n    export function getInitializerOfBinaryExpression(expr: BinaryExpression) {\r\n        while (isBinaryExpression(expr.right)) {\r\n            expr = expr.right;\r\n        }\r\n        return expr.right;\r\n    }\r\n\r\n    export function isPrototypePropertyAssignment(node: Node): boolean {\r\n        return isBinaryExpression(node) && getSpecialPropertyAssignmentKind(node) === SpecialPropertyAssignmentKind.PrototypeProperty;\r\n    }\r\n\r\n    export function isSpecialPropertyDeclaration(expr: PropertyAccessExpression): boolean {\r\n        return isInJavaScriptFile(expr) &&\r\n            expr.parent && expr.parent.kind === SyntaxKind.ExpressionStatement &&\r\n            !!getJSDocTypeTag(expr.parent);\r\n    }\r\n\r\n    export function importFromModuleSpecifier(node: StringLiteralLike): AnyValidImportOrReExport {\r\n        switch (node.parent.kind) {\r\n            case SyntaxKind.ImportDeclaration:\r\n            case SyntaxKind.ExportDeclaration:\r\n                return node.parent as AnyValidImportOrReExport;\r\n            case SyntaxKind.ExternalModuleReference:\r\n                return (node.parent as ExternalModuleReference).parent as AnyValidImportOrReExport;\r\n            case SyntaxKind.CallExpression:\r\n                return node.parent as AnyValidImportOrReExport;\r\n            case SyntaxKind.LiteralType:\r\n                return cast(node.parent.parent, isImportTypeNode) as ImportTypeNode & { argument: LiteralType };\r\n            default:\r\n                return Debug.fail(Debug.showSyntaxKind(node.parent));\r\n        }\r\n    }\r\n\r\n    export function getExternalModuleName(node: AnyImportOrReExport | ImportTypeNode): Expression {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ImportDeclaration:\r\n            case SyntaxKind.ExportDeclaration:\r\n                return node.moduleSpecifier;\r\n            case SyntaxKind.ImportEqualsDeclaration:\r\n                return node.moduleReference.kind === SyntaxKind.ExternalModuleReference ? node.moduleReference.expression : undefined;\r\n            case SyntaxKind.ImportType:\r\n                return isLiteralImportTypeNode(node) ? node.argument.literal : undefined;\r\n            default:\r\n                return Debug.assertNever(node);\r\n        }\r\n    }\r\n\r\n    export function getNamespaceDeclarationNode(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration): ImportEqualsDeclaration | NamespaceImport {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ImportDeclaration:\r\n                return node.importClause && tryCast(node.importClause.namedBindings, isNamespaceImport);\r\n            case SyntaxKind.ImportEqualsDeclaration:\r\n                return node;\r\n            case SyntaxKind.ExportDeclaration:\r\n                return undefined;\r\n            default:\r\n                return Debug.assertNever(node);\r\n        }\r\n    }\r\n\r\n    export function isDefaultImport(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration) {\r\n        return node.kind === SyntaxKind.ImportDeclaration && node.importClause && !!node.importClause.name;\r\n    }\r\n\r\n    export function hasQuestionToken(node: Node) {\r\n        if (node) {\r\n            switch (node.kind) {\r\n                case SyntaxKind.Parameter:\r\n                case SyntaxKind.MethodDeclaration:\r\n                case SyntaxKind.MethodSignature:\r\n                case SyntaxKind.ShorthandPropertyAssignment:\r\n                case SyntaxKind.PropertyAssignment:\r\n                case SyntaxKind.PropertyDeclaration:\r\n                case SyntaxKind.PropertySignature:\r\n                    return (<ParameterDeclaration | MethodDeclaration | PropertyDeclaration>node).questionToken !== undefined;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function isJSDocConstructSignature(node: Node) {\r\n        return node.kind === SyntaxKind.JSDocFunctionType &&\r\n            (node as JSDocFunctionType).parameters.length > 0 &&\r\n            (node as JSDocFunctionType).parameters[0].name &&\r\n            ((node as JSDocFunctionType).parameters[0].name as Identifier).escapedText === \"new\";\r\n    }\r\n\r\n    function getSourceOfAssignment(node: Node): Node {\r\n        return isExpressionStatement(node) &&\r\n            node.expression && isBinaryExpression(node.expression) &&\r\n            node.expression.operatorToken.kind === SyntaxKind.EqualsToken &&\r\n            node.expression.right;\r\n    }\r\n\r\n    function getSourceOfDefaultedAssignment(node: Node): Node {\r\n        return isExpressionStatement(node) &&\r\n            isBinaryExpression(node.expression) &&\r\n            getSpecialPropertyAssignmentKind(node.expression) !== SpecialPropertyAssignmentKind.None &&\r\n            isBinaryExpression(node.expression.right) &&\r\n            node.expression.right.operatorToken.kind === SyntaxKind.BarBarToken &&\r\n            node.expression.right.right;\r\n    }\r\n\r\n    function getSingleInitializerOfVariableStatementOrPropertyDeclaration(node: Node): Expression | undefined {\r\n        switch (node.kind) {\r\n            case SyntaxKind.VariableStatement:\r\n                const v = getSingleVariableOfVariableStatement(node);\r\n                return v && v.initializer;\r\n            case SyntaxKind.PropertyDeclaration:\r\n                return (node as PropertyDeclaration).initializer;\r\n        }\r\n    }\r\n\r\n    function getSingleVariableOfVariableStatement(node: Node): VariableDeclaration | undefined {\r\n        return isVariableStatement(node) &&\r\n            node.declarationList.declarations.length > 0 &&\r\n            node.declarationList.declarations[0];\r\n    }\r\n\r\n    function getNestedModuleDeclaration(node: Node): Node {\r\n        return node.kind === SyntaxKind.ModuleDeclaration &&\r\n            (node as ModuleDeclaration).body &&\r\n            (node as ModuleDeclaration).body.kind === SyntaxKind.ModuleDeclaration &&\r\n            (node as ModuleDeclaration).body;\r\n    }\r\n\r\n    export function getJSDocCommentsAndTags(node: Node): ReadonlyArray<JSDoc | JSDocTag> {\r\n        let result: (JSDoc | JSDocTag)[] | undefined;\r\n        getJSDocCommentsAndTagsWorker(node);\r\n        return result || emptyArray;\r\n\r\n        function getJSDocCommentsAndTagsWorker(node: Node): void {\r\n            const parent = node.parent;\r\n            if (!parent) return;\r\n            if (parent.kind === SyntaxKind.PropertyAssignment || parent.kind === SyntaxKind.PropertyDeclaration || getNestedModuleDeclaration(parent)) {\r\n                getJSDocCommentsAndTagsWorker(parent);\r\n            }\r\n            // Try to recognize this pattern when node is initializer of variable declaration and JSDoc comments are on containing variable statement.\r\n            // /**\r\n            //   * @param {number} name\r\n            //   * @returns {number}\r\n            //   */\r\n            // var x = function(name) { return name.length; }\r\n            if (parent.parent &&\r\n                (getSingleVariableOfVariableStatement(parent.parent) === node || getSourceOfAssignment(parent.parent))) {\r\n                getJSDocCommentsAndTagsWorker(parent.parent);\r\n            }\r\n            if (parent.parent && parent.parent.parent &&\r\n                (getSingleVariableOfVariableStatement(parent.parent.parent) ||\r\n                    getSingleInitializerOfVariableStatementOrPropertyDeclaration(parent.parent.parent) === node ||\r\n                    getSourceOfDefaultedAssignment(parent.parent.parent))) {\r\n                getJSDocCommentsAndTagsWorker(parent.parent.parent);\r\n            }\r\n            if (isBinaryExpression(node) && getSpecialPropertyAssignmentKind(node) !== SpecialPropertyAssignmentKind.None ||\r\n                isBinaryExpression(parent) && getSpecialPropertyAssignmentKind(parent) !== SpecialPropertyAssignmentKind.None ||\r\n                node.kind === SyntaxKind.PropertyAccessExpression && node.parent && node.parent.kind === SyntaxKind.ExpressionStatement) {\r\n                getJSDocCommentsAndTagsWorker(parent);\r\n            }\r\n\r\n            // Pull parameter comments from declaring function as well\r\n            if (node.kind === SyntaxKind.Parameter) {\r\n                result = addRange(result, getJSDocParameterTags(node as ParameterDeclaration));\r\n            }\r\n\r\n            if (isVariableLike(node) && hasInitializer(node) && hasJSDocNodes(node.initializer)) {\r\n                result = addRange(result, node.initializer.jsDoc);\r\n            }\r\n\r\n            if (hasJSDocNodes(node)) {\r\n                result = addRange(result, node.jsDoc);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it. */\r\n    export function getParameterSymbolFromJSDoc(node: JSDocParameterTag): Symbol | undefined {\r\n        if (node.symbol) {\r\n            return node.symbol;\r\n        }\r\n        if (!isIdentifier(node.name)) {\r\n            return undefined;\r\n        }\r\n        const name = node.name.escapedText;\r\n        const decl = getHostSignatureFromJSDoc(node);\r\n        if (!decl) {\r\n            return undefined;\r\n        }\r\n        const parameter = find(decl.parameters, p => p.name.kind === SyntaxKind.Identifier && p.name.escapedText === name);\r\n        return parameter && parameter.symbol;\r\n    }\r\n\r\n    export function getHostSignatureFromJSDoc(node: JSDocParameterTag): SignatureDeclaration | undefined {\r\n        const host = getJSDocHost(node);\r\n        const decl = getSourceOfDefaultedAssignment(host) ||\r\n            getSourceOfAssignment(host) ||\r\n            getSingleInitializerOfVariableStatementOrPropertyDeclaration(host) ||\r\n            getSingleVariableOfVariableStatement(host) ||\r\n            getNestedModuleDeclaration(host) ||\r\n            host;\r\n        return decl && isFunctionLike(decl) ? decl : undefined;\r\n    }\r\n\r\n    export function getJSDocHost(node: JSDocTag): HasJSDoc {\r\n        while (node.parent.kind === SyntaxKind.JSDocTypeLiteral) {\r\n            if (node.parent.parent.kind === SyntaxKind.JSDocTypedefTag) {\r\n                node = node.parent.parent as JSDocTypedefTag;\r\n            }\r\n            else {\r\n                // node.parent.parent is a type expression, child of a parameter type\r\n                node = node.parent.parent.parent as JSDocParameterTag;\r\n            }\r\n        }\r\n        Debug.assert(node.parent!.kind === SyntaxKind.JSDocComment);\r\n        return node.parent!.parent!;\r\n    }\r\n\r\n    export function getTypeParameterFromJsDoc(node: TypeParameterDeclaration & { parent: JSDocTemplateTag }): TypeParameterDeclaration | undefined {\r\n        const name = node.name.escapedText;\r\n        const { typeParameters } = (node.parent.parent.parent as SignatureDeclaration | InterfaceDeclaration | ClassDeclaration);\r\n        return find(typeParameters, p => p.name.escapedText === name);\r\n    }\r\n\r\n    export function hasRestParameter(s: SignatureDeclaration): boolean {\r\n        const last = lastOrUndefined(s.parameters);\r\n        return last && isRestParameter(last);\r\n    }\r\n\r\n    export function isRestParameter(node: ParameterDeclaration): boolean {\r\n        return node.dotDotDotToken !== undefined || node.type && node.type.kind === SyntaxKind.JSDocVariadicType;\r\n    }\r\n\r\n    export const enum AssignmentKind {\r\n        None, Definite, Compound\r\n    }\r\n\r\n    export function getAssignmentTargetKind(node: Node): AssignmentKind {\r\n        let parent = node.parent;\r\n        while (true) {\r\n            switch (parent.kind) {\r\n                case SyntaxKind.BinaryExpression:\r\n                    const binaryOperator = (<BinaryExpression>parent).operatorToken.kind;\r\n                    return isAssignmentOperator(binaryOperator) && (<BinaryExpression>parent).left === node ?\r\n                        binaryOperator === SyntaxKind.EqualsToken ? AssignmentKind.Definite : AssignmentKind.Compound :\r\n                        AssignmentKind.None;\r\n                case SyntaxKind.PrefixUnaryExpression:\r\n                case SyntaxKind.PostfixUnaryExpression:\r\n                    const unaryOperator = (<PrefixUnaryExpression | PostfixUnaryExpression>parent).operator;\r\n                    return unaryOperator === SyntaxKind.PlusPlusToken || unaryOperator === SyntaxKind.MinusMinusToken ? AssignmentKind.Compound : AssignmentKind.None;\r\n                case SyntaxKind.ForInStatement:\r\n                case SyntaxKind.ForOfStatement:\r\n                    return (<ForInOrOfStatement>parent).initializer === node ? AssignmentKind.Definite : AssignmentKind.None;\r\n                case SyntaxKind.ParenthesizedExpression:\r\n                case SyntaxKind.ArrayLiteralExpression:\r\n                case SyntaxKind.SpreadElement:\r\n                case SyntaxKind.NonNullExpression:\r\n                    node = parent;\r\n                    break;\r\n                case SyntaxKind.ShorthandPropertyAssignment:\r\n                    if ((parent as ShorthandPropertyAssignment).name !== node) {\r\n                        return AssignmentKind.None;\r\n                    }\r\n                    node = parent.parent;\r\n                    break;\r\n                case SyntaxKind.PropertyAssignment:\r\n                    if ((parent as ShorthandPropertyAssignment).name === node) {\r\n                        return AssignmentKind.None;\r\n                    }\r\n                    node = parent.parent;\r\n                    break;\r\n                default:\r\n                    return AssignmentKind.None;\r\n            }\r\n            parent = node.parent;\r\n        }\r\n    }\r\n\r\n    // A node is an assignment target if it is on the left hand side of an '=' token, if it is parented by a property\r\n    // assignment in an object literal that is an assignment target, or if it is parented by an array literal that is\r\n    // an assignment target. Examples include 'a = xxx', '{ p: a } = xxx', '[{ a }] = xxx'.\r\n    // (Note that `p` is not a target in the above examples, only `a`.)\r\n    export function isAssignmentTarget(node: Node): boolean {\r\n        return getAssignmentTargetKind(node) !== AssignmentKind.None;\r\n    }\r\n\r\n    export type NodeWithPossibleHoistedDeclaration =\r\n        | Block\r\n        | VariableStatement\r\n        | WithStatement\r\n        | IfStatement\r\n        | SwitchStatement\r\n        | CaseBlock\r\n        | CaseClause\r\n        | DefaultClause\r\n        | LabeledStatement\r\n        | ForStatement\r\n        | ForInStatement\r\n        | ForOfStatement\r\n        | DoStatement\r\n        | WhileStatement\r\n        | TryStatement\r\n        | CatchClause;\r\n\r\n    /**\r\n     * Indicates whether a node could contain a `var` VariableDeclarationList that contributes to\r\n     * the same `var` declaration scope as the node's parent.\r\n     */\r\n    export function isNodeWithPossibleHoistedDeclaration(node: Node): node is NodeWithPossibleHoistedDeclaration {\r\n        switch (node.kind) {\r\n            case SyntaxKind.Block:\r\n            case SyntaxKind.VariableStatement:\r\n            case SyntaxKind.WithStatement:\r\n            case SyntaxKind.IfStatement:\r\n            case SyntaxKind.SwitchStatement:\r\n            case SyntaxKind.CaseBlock:\r\n            case SyntaxKind.CaseClause:\r\n            case SyntaxKind.DefaultClause:\r\n            case SyntaxKind.LabeledStatement:\r\n            case SyntaxKind.ForStatement:\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n            case SyntaxKind.DoStatement:\r\n            case SyntaxKind.WhileStatement:\r\n            case SyntaxKind.TryStatement:\r\n            case SyntaxKind.CatchClause:\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export type ValueSignatureDeclaration =\r\n        | FunctionDeclaration\r\n        | MethodDeclaration\r\n        | ConstructorDeclaration\r\n        | AccessorDeclaration\r\n        | FunctionExpression\r\n        | ArrowFunction;\r\n\r\n    export function isValueSignatureDeclaration(node: Node): node is ValueSignatureDeclaration {\r\n        return isFunctionExpression(node) || isArrowFunction(node) || isMethodOrAccessor(node) || isFunctionDeclaration(node) || isConstructorDeclaration(node);\r\n    }\r\n\r\n    function walkUp(node: Node, kind: SyntaxKind) {\r\n        while (node && node.kind === kind) {\r\n            node = node.parent;\r\n        }\r\n        return node;\r\n    }\r\n\r\n    export function walkUpParenthesizedTypes(node: Node) {\r\n        return walkUp(node, SyntaxKind.ParenthesizedType);\r\n    }\r\n\r\n    export function walkUpParenthesizedExpressions(node: Node) {\r\n        return walkUp(node, SyntaxKind.ParenthesizedExpression);\r\n    }\r\n\r\n    export function skipParentheses(node: Expression): Expression;\r\n    export function skipParentheses(node: Node): Node;\r\n    export function skipParentheses(node: Node): Node {\r\n        while (node.kind === SyntaxKind.ParenthesizedExpression) {\r\n            node = (node as ParenthesizedExpression).expression;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    // a node is delete target iff. it is PropertyAccessExpression/ElementAccessExpression with parentheses skipped\r\n    export function isDeleteTarget(node: Node): boolean {\r\n        if (node.kind !== SyntaxKind.PropertyAccessExpression && node.kind !== SyntaxKind.ElementAccessExpression) {\r\n            return false;\r\n        }\r\n        node = walkUpParenthesizedExpressions(node.parent);\r\n        return node && node.kind === SyntaxKind.DeleteExpression;\r\n    }\r\n\r\n    export function isNodeDescendantOf(node: Node, ancestor: Node): boolean {\r\n        while (node) {\r\n            if (node === ancestor) return true;\r\n            node = node.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // True if `name` is the name of a declaration node\r\n    export function isDeclarationName(name: Node): boolean {\r\n        return !isSourceFile(name) && !isBindingPattern(name) && isDeclaration(name.parent) && name.parent.name === name;\r\n    }\r\n\r\n    // See GH#16030\r\n    export function isAnyDeclarationName(name: Node): boolean {\r\n        switch (name.kind) {\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n                if (isDeclaration(name.parent)) {\r\n                    return name.parent.name === name;\r\n                }\r\n                const binExp = name.parent.parent;\r\n                return isBinaryExpression(binExp) && getSpecialPropertyAssignmentKind(binExp) !== SpecialPropertyAssignmentKind.None && getNameOfDeclaration(binExp) === name;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isLiteralComputedPropertyDeclarationName(node: Node) {\r\n        return (node.kind === SyntaxKind.StringLiteral || node.kind === SyntaxKind.NumericLiteral) &&\r\n            node.parent.kind === SyntaxKind.ComputedPropertyName &&\r\n            isDeclaration(node.parent.parent);\r\n    }\r\n\r\n    // Return true if the given identifier is classified as an IdentifierName\r\n    export function isIdentifierName(node: Identifier): boolean {\r\n        let parent = node.parent;\r\n        switch (parent.kind) {\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.EnumMember:\r\n            case SyntaxKind.PropertyAssignment:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                // Name in member declaration or property name in property access\r\n                return (<NamedDeclaration | PropertyAccessExpression>parent).name === node;\r\n            case SyntaxKind.QualifiedName:\r\n                // Name on right hand side of dot in a type query or type reference\r\n                if ((<QualifiedName>parent).right === node) {\r\n                    while (parent.kind === SyntaxKind.QualifiedName) {\r\n                        parent = parent.parent;\r\n                    }\r\n                    return parent.kind === SyntaxKind.TypeQuery || parent.kind === SyntaxKind.TypeReference;\r\n                }\r\n                return false;\r\n            case SyntaxKind.BindingElement:\r\n            case SyntaxKind.ImportSpecifier:\r\n                // Property name in binding element or import specifier\r\n                return (<BindingElement | ImportSpecifier>parent).propertyName === node;\r\n            case SyntaxKind.ExportSpecifier:\r\n            case SyntaxKind.JsxAttribute:\r\n                // Any name in an export specifier or JSX Attribute\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // An alias symbol is created by one of the following declarations:\r\n    // import <symbol> = ...\r\n    // import <symbol> from ...\r\n    // import * as <symbol> from ...\r\n    // import { x as <symbol> } from ...\r\n    // export { x as <symbol> } from ...\r\n    // export = <EntityNameExpression>\r\n    // export default <EntityNameExpression>\r\n    export function isAliasSymbolDeclaration(node: Node): boolean {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration ||\r\n            node.kind === SyntaxKind.NamespaceExportDeclaration ||\r\n            node.kind === SyntaxKind.ImportClause && !!(<ImportClause>node).name ||\r\n            node.kind === SyntaxKind.NamespaceImport ||\r\n            node.kind === SyntaxKind.ImportSpecifier ||\r\n            node.kind === SyntaxKind.ExportSpecifier ||\r\n            node.kind === SyntaxKind.ExportAssignment && exportAssignmentIsAlias(<ExportAssignment>node) ||\r\n            isBinaryExpression(node) && getSpecialPropertyAssignmentKind(node) === SpecialPropertyAssignmentKind.ModuleExports;\r\n    }\r\n\r\n    export function exportAssignmentIsAlias(node: ExportAssignment | BinaryExpression): boolean {\r\n        const e = isExportAssignment(node) ? node.expression : node.right;\r\n        return isEntityNameExpression(e) || isClassExpression(e);\r\n    }\r\n\r\n    export function getClassExtendsHeritageClauseElement(node: ClassLikeDeclaration | InterfaceDeclaration) {\r\n        const heritageClause = getHeritageClause(node.heritageClauses, SyntaxKind.ExtendsKeyword);\r\n        return heritageClause && heritageClause.types.length > 0 ? heritageClause.types[0] : undefined;\r\n    }\r\n\r\n    export function getClassImplementsHeritageClauseElements(node: ClassLikeDeclaration) {\r\n        const heritageClause = getHeritageClause(node.heritageClauses, SyntaxKind.ImplementsKeyword);\r\n        return heritageClause ? heritageClause.types : undefined;\r\n    }\r\n\r\n    /** Returns the node in an `extends` or `implements` clause of a class or interface. */\r\n    export function getAllSuperTypeNodes(node: Node): ReadonlyArray<TypeNode> {\r\n        return isInterfaceDeclaration(node) ? getInterfaceBaseTypeNodes(node) || emptyArray\r\n            : isClassLike(node) ? concatenate(singleElementArray(getClassExtendsHeritageClauseElement(node)), getClassImplementsHeritageClauseElements(node)) || emptyArray\r\n            : emptyArray;\r\n    }\r\n\r\n    export function getInterfaceBaseTypeNodes(node: InterfaceDeclaration) {\r\n        const heritageClause = getHeritageClause(node.heritageClauses, SyntaxKind.ExtendsKeyword);\r\n        return heritageClause ? heritageClause.types : undefined;\r\n    }\r\n\r\n    export function getHeritageClause(clauses: NodeArray<HeritageClause>, kind: SyntaxKind) {\r\n        if (clauses) {\r\n            for (const clause of clauses) {\r\n                if (clause.token === kind) {\r\n                    return clause;\r\n                }\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export function tryResolveScriptReference(host: ScriptReferenceHost, sourceFile: SourceFile, reference: FileReference) {\r\n        if (!host.getCompilerOptions().noResolve) {\r\n            const referenceFileName = isRootedDiskPath(reference.fileName) ? reference.fileName : combinePaths(getDirectoryPath(sourceFile.fileName), reference.fileName);\r\n            return host.getSourceFile(referenceFileName);\r\n        }\r\n    }\r\n\r\n    export function getAncestor(node: Node | undefined, kind: SyntaxKind): Node | undefined {\r\n        while (node) {\r\n            if (node.kind === kind) {\r\n                return node;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    export function isKeyword(token: SyntaxKind): boolean {\r\n        return SyntaxKind.FirstKeyword <= token && token <= SyntaxKind.LastKeyword;\r\n    }\r\n\r\n    export function isContextualKeyword(token: SyntaxKind): boolean {\r\n        return SyntaxKind.FirstContextualKeyword <= token && token <= SyntaxKind.LastContextualKeyword;\r\n    }\r\n\r\n    export function isNonContextualKeyword(token: SyntaxKind): boolean {\r\n        return isKeyword(token) && !isContextualKeyword(token);\r\n    }\r\n\r\n    export function isStringANonContextualKeyword(name: string) {\r\n        const token = stringToToken(name);\r\n        return token !== undefined && isNonContextualKeyword(token);\r\n    }\r\n\r\n    export type TriviaKind = SyntaxKind.SingleLineCommentTrivia\r\n        | SyntaxKind.MultiLineCommentTrivia\r\n        | SyntaxKind.NewLineTrivia\r\n        | SyntaxKind.WhitespaceTrivia\r\n        | SyntaxKind.ShebangTrivia\r\n        | SyntaxKind.ConflictMarkerTrivia;\r\n    export function isTrivia(token: SyntaxKind): token is TriviaKind {\r\n        return SyntaxKind.FirstTriviaToken <= token && token <= SyntaxKind.LastTriviaToken;\r\n    }\r\n\r\n    export const enum FunctionFlags {\r\n        Normal = 0,             // Function is a normal function\r\n        Generator = 1 << 0,     // Function is a generator function or async generator function\r\n        Async = 1 << 1,         // Function is an async function or an async generator function\r\n        Invalid = 1 << 2,       // Function is a signature or overload and does not have a body.\r\n        AsyncGenerator = Async | Generator, // Function is an async generator function\r\n    }\r\n\r\n    export function getFunctionFlags(node: SignatureDeclaration | undefined) {\r\n        if (!node) {\r\n            return FunctionFlags.Invalid;\r\n        }\r\n\r\n        let flags = FunctionFlags.Normal;\r\n        switch (node.kind) {\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.MethodDeclaration:\r\n                if (node.asteriskToken) {\r\n                    flags |= FunctionFlags.Generator;\r\n                }\r\n                // falls through\r\n            case SyntaxKind.ArrowFunction:\r\n                if (hasModifier(node, ModifierFlags.Async)) {\r\n                    flags |= FunctionFlags.Async;\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (!(node as FunctionLikeDeclaration).body) {\r\n            flags |= FunctionFlags.Invalid;\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    export function isAsyncFunction(node: Node): boolean {\r\n        switch (node.kind) {\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.MethodDeclaration:\r\n                return (<FunctionLikeDeclaration>node).body !== undefined\r\n                    && (<FunctionLikeDeclaration>node).asteriskToken === undefined\r\n                    && hasModifier(node, ModifierFlags.Async);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isStringOrNumericLiteral(node: Node): node is StringLiteral | NumericLiteral {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.StringLiteral\r\n            || kind === SyntaxKind.NumericLiteral;\r\n    }\r\n\r\n    /**\r\n     * A declaration has a dynamic name if both of the following are true:\r\n     *   1. The declaration has a computed property name\r\n     *   2. The computed name is *not* expressed as Symbol.<name>, where name\r\n     *      is a property of the Symbol constructor that denotes a built in\r\n     *      Symbol.\r\n     */\r\n    export function hasDynamicName(declaration: Declaration): declaration is DynamicNamedDeclaration {\r\n        const name = getNameOfDeclaration(declaration);\r\n        return name && isDynamicName(name);\r\n    }\r\n\r\n    export function isDynamicName(name: DeclarationName): boolean {\r\n        return name.kind === SyntaxKind.ComputedPropertyName &&\r\n            !isStringOrNumericLiteral(name.expression) &&\r\n            !isWellKnownSymbolSyntactically(name.expression);\r\n    }\r\n\r\n    /**\r\n     * Checks if the expression is of the form:\r\n     *    Symbol.name\r\n     * where Symbol is literally the word \"Symbol\", and name is any identifierName\r\n     */\r\n    export function isWellKnownSymbolSyntactically(node: Expression): boolean {\r\n        return isPropertyAccessExpression(node) && isESSymbolIdentifier(node.expression);\r\n    }\r\n\r\n    export function getPropertyNameForPropertyNameNode(name: DeclarationName): __String {\r\n        if (name.kind === SyntaxKind.Identifier) {\r\n            return name.escapedText;\r\n        }\r\n        if (name.kind === SyntaxKind.StringLiteral || name.kind === SyntaxKind.NumericLiteral) {\r\n            return escapeLeadingUnderscores(name.text);\r\n        }\r\n        if (name.kind === SyntaxKind.ComputedPropertyName) {\r\n            const nameExpression = name.expression;\r\n            if (isWellKnownSymbolSyntactically(nameExpression)) {\r\n                return getPropertyNameForKnownSymbolName(idText((<PropertyAccessExpression>nameExpression).name));\r\n            }\r\n            else if (nameExpression.kind === SyntaxKind.StringLiteral || nameExpression.kind === SyntaxKind.NumericLiteral) {\r\n                return escapeLeadingUnderscores((<LiteralExpression>nameExpression).text);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    export type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral;\r\n    export function isPropertyNameLiteral(node: Node): node is PropertyNameLiteral {\r\n        switch (node.kind) {\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    export function getTextOfIdentifierOrLiteral(node: PropertyNameLiteral): string {\r\n        return node.kind === SyntaxKind.Identifier ? idText(node) : node.text;\r\n    }\r\n\r\n    export function getEscapedTextOfIdentifierOrLiteral(node: PropertyNameLiteral): __String {\r\n        return node.kind === SyntaxKind.Identifier ? node.escapedText : escapeLeadingUnderscores(node.text);\r\n    }\r\n\r\n    export function getPropertyNameForKnownSymbolName(symbolName: string): __String {\r\n        return \"__@\" + symbolName as __String;\r\n    }\r\n\r\n    export function isKnownSymbol(symbol: Symbol): boolean {\r\n        return startsWith(symbol.escapedName as string, \"__@\");\r\n    }\r\n\r\n    /**\r\n     * Includes the word \"Symbol\" with unicode escapes\r\n     */\r\n    export function isESSymbolIdentifier(node: Node): boolean {\r\n        return node.kind === SyntaxKind.Identifier && (<Identifier>node).escapedText === \"Symbol\";\r\n    }\r\n\r\n    export function isPushOrUnshiftIdentifier(node: Identifier) {\r\n        return node.escapedText === \"push\" || node.escapedText === \"unshift\";\r\n    }\r\n\r\n    export function isParameterDeclaration(node: VariableLikeDeclaration) {\r\n        const root = getRootDeclaration(node);\r\n        return root.kind === SyntaxKind.Parameter;\r\n    }\r\n\r\n    export function getRootDeclaration(node: Node): Node {\r\n        while (node.kind === SyntaxKind.BindingElement) {\r\n            node = node.parent.parent;\r\n        }\r\n        return node;\r\n    }\r\n\r\n    export function nodeStartsNewLexicalEnvironment(node: Node): boolean {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Constructor\r\n            || kind === SyntaxKind.FunctionExpression\r\n            || kind === SyntaxKind.FunctionDeclaration\r\n            || kind === SyntaxKind.ArrowFunction\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.SetAccessor\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.SourceFile;\r\n    }\r\n\r\n    export function nodeIsSynthesized(range: TextRange): boolean {\r\n        return positionIsSynthesized(range.pos)\r\n            || positionIsSynthesized(range.end);\r\n    }\r\n\r\n    export function getOriginalSourceFile(sourceFile: SourceFile) {\r\n        return getParseTreeNode(sourceFile, isSourceFile) || sourceFile;\r\n    }\r\n\r\n    export const enum Associativity {\r\n        Left,\r\n        Right\r\n    }\r\n\r\n    export function getExpressionAssociativity(expression: Expression) {\r\n        const operator = getOperator(expression);\r\n        const hasArguments = expression.kind === SyntaxKind.NewExpression && (<NewExpression>expression).arguments !== undefined;\r\n        return getOperatorAssociativity(expression.kind, operator, hasArguments);\r\n    }\r\n\r\n    export function getOperatorAssociativity(kind: SyntaxKind, operator: SyntaxKind, hasArguments?: boolean) {\r\n        switch (kind) {\r\n            case SyntaxKind.NewExpression:\r\n                return hasArguments ? Associativity.Left : Associativity.Right;\r\n\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n            case SyntaxKind.ConditionalExpression:\r\n            case SyntaxKind.YieldExpression:\r\n                return Associativity.Right;\r\n\r\n            case SyntaxKind.BinaryExpression:\r\n                switch (operator) {\r\n                    case SyntaxKind.AsteriskAsteriskToken:\r\n                    case SyntaxKind.EqualsToken:\r\n                    case SyntaxKind.PlusEqualsToken:\r\n                    case SyntaxKind.MinusEqualsToken:\r\n                    case SyntaxKind.AsteriskAsteriskEqualsToken:\r\n                    case SyntaxKind.AsteriskEqualsToken:\r\n                    case SyntaxKind.SlashEqualsToken:\r\n                    case SyntaxKind.PercentEqualsToken:\r\n                    case SyntaxKind.LessThanLessThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.AmpersandEqualsToken:\r\n                    case SyntaxKind.CaretEqualsToken:\r\n                    case SyntaxKind.BarEqualsToken:\r\n                        return Associativity.Right;\r\n                }\r\n        }\r\n        return Associativity.Left;\r\n    }\r\n\r\n    export function getExpressionPrecedence(expression: Expression) {\r\n        const operator = getOperator(expression);\r\n        const hasArguments = expression.kind === SyntaxKind.NewExpression && (<NewExpression>expression).arguments !== undefined;\r\n        return getOperatorPrecedence(expression.kind, operator, hasArguments);\r\n    }\r\n\r\n    export function getOperator(expression: Expression) {\r\n        if (expression.kind === SyntaxKind.BinaryExpression) {\r\n            return (<BinaryExpression>expression).operatorToken.kind;\r\n        }\r\n        else if (expression.kind === SyntaxKind.PrefixUnaryExpression || expression.kind === SyntaxKind.PostfixUnaryExpression) {\r\n            return (<PrefixUnaryExpression | PostfixUnaryExpression>expression).operator;\r\n        }\r\n        else {\r\n            return expression.kind;\r\n        }\r\n    }\r\n\r\n    export function getOperatorPrecedence(nodeKind: SyntaxKind, operatorKind: SyntaxKind, hasArguments?: boolean) {\r\n        switch (nodeKind) {\r\n            case SyntaxKind.CommaListExpression:\r\n                return 0;\r\n\r\n            case SyntaxKind.SpreadElement:\r\n                return 1;\r\n\r\n            case SyntaxKind.YieldExpression:\r\n                return 2;\r\n\r\n            case SyntaxKind.ConditionalExpression:\r\n                return 4;\r\n\r\n            case SyntaxKind.BinaryExpression:\r\n                switch (operatorKind) {\r\n                    case SyntaxKind.CommaToken:\r\n                        return 0;\r\n\r\n                    case SyntaxKind.EqualsToken:\r\n                    case SyntaxKind.PlusEqualsToken:\r\n                    case SyntaxKind.MinusEqualsToken:\r\n                    case SyntaxKind.AsteriskAsteriskEqualsToken:\r\n                    case SyntaxKind.AsteriskEqualsToken:\r\n                    case SyntaxKind.SlashEqualsToken:\r\n                    case SyntaxKind.PercentEqualsToken:\r\n                    case SyntaxKind.LessThanLessThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\r\n                    case SyntaxKind.AmpersandEqualsToken:\r\n                    case SyntaxKind.CaretEqualsToken:\r\n                    case SyntaxKind.BarEqualsToken:\r\n                        return 3;\r\n\r\n                    default:\r\n                        return getBinaryOperatorPrecedence(operatorKind);\r\n                }\r\n\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n                return 16;\r\n\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n                return 17;\r\n\r\n            case SyntaxKind.CallExpression:\r\n                return 18;\r\n\r\n            case SyntaxKind.NewExpression:\r\n                return hasArguments ? 19 : 18;\r\n\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ElementAccessExpression:\r\n                return 19;\r\n\r\n            case SyntaxKind.ThisKeyword:\r\n            case SyntaxKind.SuperKeyword:\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.NullKeyword:\r\n            case SyntaxKind.TrueKeyword:\r\n            case SyntaxKind.FalseKeyword:\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.JsxElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.JsxFragment:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.TemplateExpression:\r\n            case SyntaxKind.ParenthesizedExpression:\r\n            case SyntaxKind.OmittedExpression:\r\n                return 20;\r\n\r\n            default:\r\n                return -1;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function getBinaryOperatorPrecedence(kind: SyntaxKind): number {\r\n        switch (kind) {\r\n            case SyntaxKind.BarBarToken:\r\n                return 5;\r\n            case SyntaxKind.AmpersandAmpersandToken:\r\n                return 6;\r\n            case SyntaxKind.BarToken:\r\n                return 7;\r\n            case SyntaxKind.CaretToken:\r\n                return 8;\r\n            case SyntaxKind.AmpersandToken:\r\n                return 9;\r\n            case SyntaxKind.EqualsEqualsToken:\r\n            case SyntaxKind.ExclamationEqualsToken:\r\n            case SyntaxKind.EqualsEqualsEqualsToken:\r\n            case SyntaxKind.ExclamationEqualsEqualsToken:\r\n                return 10;\r\n            case SyntaxKind.LessThanToken:\r\n            case SyntaxKind.GreaterThanToken:\r\n            case SyntaxKind.LessThanEqualsToken:\r\n            case SyntaxKind.GreaterThanEqualsToken:\r\n            case SyntaxKind.InstanceOfKeyword:\r\n            case SyntaxKind.InKeyword:\r\n            case SyntaxKind.AsKeyword:\r\n                return 11;\r\n            case SyntaxKind.LessThanLessThanToken:\r\n            case SyntaxKind.GreaterThanGreaterThanToken:\r\n            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\r\n                return 12;\r\n            case SyntaxKind.PlusToken:\r\n            case SyntaxKind.MinusToken:\r\n                return 13;\r\n            case SyntaxKind.AsteriskToken:\r\n            case SyntaxKind.SlashToken:\r\n            case SyntaxKind.PercentToken:\r\n                return 14;\r\n            case SyntaxKind.AsteriskAsteriskToken:\r\n                return 15;\r\n        }\r\n\r\n        // -1 is lower than all other precedences.  Returning it will cause binary expression\r\n        // parsing to stop.\r\n        return -1;\r\n    }\r\n\r\n    export function createDiagnosticCollection(): DiagnosticCollection {\r\n        let nonFileDiagnostics = [] as SortedArray<Diagnostic>;\r\n        const filesWithDiagnostics = [] as SortedArray<string>;\r\n        const fileDiagnostics = createMap<SortedArray<Diagnostic>>();\r\n        let hasReadNonFileDiagnostics = false;\r\n\r\n        return {\r\n            add,\r\n            getGlobalDiagnostics,\r\n            getDiagnostics,\r\n            reattachFileDiagnostics\r\n        };\r\n\r\n        function reattachFileDiagnostics(newFile: SourceFile): void {\r\n            forEach(fileDiagnostics.get(newFile.fileName), diagnostic => diagnostic.file = newFile);\r\n        }\r\n\r\n        function add(diagnostic: Diagnostic): void {\r\n            let diagnostics: SortedArray<Diagnostic>;\r\n            if (diagnostic.file) {\r\n                diagnostics = fileDiagnostics.get(diagnostic.file.fileName);\r\n                if (!diagnostics) {\r\n                    diagnostics = [] as SortedArray<Diagnostic>;\r\n                    fileDiagnostics.set(diagnostic.file.fileName, diagnostics);\r\n                    insertSorted(filesWithDiagnostics, diagnostic.file.fileName, compareStringsCaseSensitive);\r\n                }\r\n            }\r\n            else {\r\n                // If we've already read the non-file diagnostics, do not modify the existing array.\r\n                if (hasReadNonFileDiagnostics) {\r\n                    hasReadNonFileDiagnostics = false;\r\n                    nonFileDiagnostics = nonFileDiagnostics.slice() as SortedArray<Diagnostic>;\r\n                }\r\n\r\n                diagnostics = nonFileDiagnostics;\r\n            }\r\n\r\n            insertSorted(diagnostics, diagnostic, compareDiagnostics);\r\n        }\r\n\r\n        function getGlobalDiagnostics(): Diagnostic[] {\r\n            hasReadNonFileDiagnostics = true;\r\n            return nonFileDiagnostics;\r\n        }\r\n\r\n        function getDiagnostics(fileName?: string): Diagnostic[] {\r\n            if (fileName) {\r\n                return fileDiagnostics.get(fileName) || [];\r\n            }\r\n\r\n            const fileDiags = flatMap(filesWithDiagnostics, f => fileDiagnostics.get(f));\r\n            if (!nonFileDiagnostics.length) {\r\n                return fileDiags;\r\n            }\r\n            fileDiags.unshift(...nonFileDiagnostics);\r\n            return fileDiags;\r\n        }\r\n    }\r\n\r\n    // This consists of the first 19 unprintable ASCII characters, canonical escapes, lineSeparator,\r\n    // paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in\r\n    // the language service. These characters should be escaped when printing, and if any characters are added,\r\n    // the map below must be updated. Note that this regexp *does not* include the 'delete' character.\r\n    // There is no reason for this other than that JSON.stringify does not handle it either.\r\n    const doubleQuoteEscapedCharsRegExp = /[\\\\\\\"\\u0000-\\u001f\\t\\v\\f\\b\\r\\n\\u2028\\u2029\\u0085]/g;\r\n    const singleQuoteEscapedCharsRegExp = /[\\\\\\'\\u0000-\\u001f\\t\\v\\f\\b\\r\\n\\u2028\\u2029\\u0085]/g;\r\n    const backtickQuoteEscapedCharsRegExp = /[\\\\\\`\\u0000-\\u001f\\t\\v\\f\\b\\r\\n\\u2028\\u2029\\u0085]/g;\r\n    const escapedCharsMap = createMapFromTemplate({\r\n        \"\\t\": \"\\\\t\",\r\n        \"\\v\": \"\\\\v\",\r\n        \"\\f\": \"\\\\f\",\r\n        \"\\b\": \"\\\\b\",\r\n        \"\\r\": \"\\\\r\",\r\n        \"\\n\": \"\\\\n\",\r\n        \"\\\\\": \"\\\\\\\\\",\r\n        \"\\\"\": \"\\\\\\\"\",\r\n        \"\\'\": \"\\\\\\'\",\r\n        \"\\`\": \"\\\\\\`\",\r\n        \"\\u2028\": \"\\\\u2028\", // lineSeparator\r\n        \"\\u2029\": \"\\\\u2029\", // paragraphSeparator\r\n        \"\\u0085\": \"\\\\u0085\"  // nextLine\r\n    });\r\n\r\n    /**\r\n     * Based heavily on the abstract 'Quote'/'QuoteJSONString' operation from ECMA-262 (24.3.2.2),\r\n     * but augmented for a few select characters (e.g. lineSeparator, paragraphSeparator, nextLine)\r\n     * Note that this doesn't actually wrap the input in double quotes.\r\n     */\r\n    export function escapeString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string {\r\n        const escapedCharsRegExp =\r\n            quoteChar === CharacterCodes.backtick ? backtickQuoteEscapedCharsRegExp :\r\n            quoteChar === CharacterCodes.singleQuote ? singleQuoteEscapedCharsRegExp :\r\n            doubleQuoteEscapedCharsRegExp;\r\n        return s.replace(escapedCharsRegExp, getReplacement);\r\n    }\r\n\r\n    function getReplacement(c: string, offset: number, input: string) {\r\n        if (c.charCodeAt(0) === CharacterCodes.nullCharacter) {\r\n            const lookAhead = input.charCodeAt(offset + c.length);\r\n            if (lookAhead >= CharacterCodes._0 && lookAhead <= CharacterCodes._9) {\r\n                // If the null character is followed by digits, print as a hex escape to prevent the result from parsing as an octal (which is forbidden in strict mode)\r\n                return \"\\\\x00\";\r\n            }\r\n            // Otherwise, keep printing a literal \\0 for the null character\r\n            return \"\\\\0\";\r\n        }\r\n        return escapedCharsMap.get(c) || get16BitUnicodeEscapeSequence(c.charCodeAt(0));\r\n    }\r\n\r\n    export function isIntrinsicJsxName(name: __String | string) {\r\n        const ch = (name as string).charCodeAt(0);\r\n        return (ch >= CharacterCodes.a && ch <= CharacterCodes.z) || (name as string).indexOf(\"-\") > -1;\r\n    }\r\n\r\n    function get16BitUnicodeEscapeSequence(charCode: number): string {\r\n        const hexCharCode = charCode.toString(16).toUpperCase();\r\n        const paddedHexCode = (\"0000\" + hexCharCode).slice(-4);\r\n        return \"\\\\u\" + paddedHexCode;\r\n    }\r\n\r\n    const nonAsciiCharacters = /[^\\u0000-\\u007F]/g;\r\n    export function escapeNonAsciiString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string {\r\n        s = escapeString(s, quoteChar);\r\n        // Replace non-ASCII characters with '\\uNNNN' escapes if any exist.\r\n        // Otherwise just return the original string.\r\n        return nonAsciiCharacters.test(s) ?\r\n            s.replace(nonAsciiCharacters, c => get16BitUnicodeEscapeSequence(c.charCodeAt(0))) :\r\n            s;\r\n    }\r\n\r\n    const indentStrings: string[] = [\"\", \"    \"];\r\n    export function getIndentString(level: number) {\r\n        if (indentStrings[level] === undefined) {\r\n            indentStrings[level] = getIndentString(level - 1) + indentStrings[1];\r\n        }\r\n        return indentStrings[level];\r\n    }\r\n\r\n    export function getIndentSize() {\r\n        return indentStrings[1].length;\r\n    }\r\n\r\n    export function createTextWriter(newLine: string): EmitTextWriter {\r\n        let output: string;\r\n        let indent: number;\r\n        let lineStart: boolean;\r\n        let lineCount: number;\r\n        let linePos: number;\r\n\r\n        function write(s: string) {\r\n            if (s && s.length) {\r\n                if (lineStart) {\r\n                    output += getIndentString(indent);\r\n                    lineStart = false;\r\n                }\r\n                output += s;\r\n            }\r\n        }\r\n\r\n        function reset(): void {\r\n            output = \"\";\r\n            indent = 0;\r\n            lineStart = true;\r\n            lineCount = 0;\r\n            linePos = 0;\r\n        }\r\n\r\n        function rawWrite(s: string) {\r\n            if (s !== undefined) {\r\n                if (lineStart) {\r\n                    lineStart = false;\r\n                }\r\n                output += s;\r\n            }\r\n        }\r\n\r\n        function writeLiteral(s: string) {\r\n            if (s && s.length) {\r\n                write(s);\r\n                const lineStartsOfS = computeLineStarts(s);\r\n                if (lineStartsOfS.length > 1) {\r\n                    lineCount = lineCount + lineStartsOfS.length - 1;\r\n                    linePos = output.length - s.length + lastOrUndefined(lineStartsOfS);\r\n                }\r\n            }\r\n        }\r\n\r\n        function writeLine() {\r\n            if (!lineStart) {\r\n                output += newLine;\r\n                lineCount++;\r\n                linePos = output.length;\r\n                lineStart = true;\r\n            }\r\n        }\r\n\r\n        function writeTextOfNode(text: string, node: Node) {\r\n            write(getTextOfNodeFromSourceText(text, node));\r\n        }\r\n\r\n        reset();\r\n\r\n        return {\r\n            write,\r\n            rawWrite,\r\n            writeTextOfNode,\r\n            writeLiteral,\r\n            writeLine,\r\n            increaseIndent: () => { indent++; },\r\n            decreaseIndent: () => { indent--; },\r\n            getIndent: () => indent,\r\n            getTextPos: () => output.length,\r\n            getLine: () => lineCount + 1,\r\n            getColumn: () => lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1,\r\n            getText: () => output,\r\n            isAtStartOfLine: () => lineStart,\r\n            clear: reset,\r\n            reportInaccessibleThisError: noop,\r\n            reportPrivateInBaseOfClassExpression: noop,\r\n            reportInaccessibleUniqueSymbolError: noop,\r\n            trackSymbol: noop,\r\n            writeKeyword: write,\r\n            writeOperator: write,\r\n            writeParameter: write,\r\n            writeProperty: write,\r\n            writePunctuation: write,\r\n            writeSpace: write,\r\n            writeStringLiteral: write,\r\n            writeSymbol: write\r\n        };\r\n    }\r\n\r\n    export function getResolvedExternalModuleName(host: EmitHost, file: SourceFile): string {\r\n        return file.moduleName || getExternalModuleNameFromPath(host, file.fileName);\r\n    }\r\n\r\n    export function getExternalModuleNameFromDeclaration(host: EmitHost, resolver: EmitResolver, declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration | ImportTypeNode): string {\r\n        const file = resolver.getExternalModuleFileFromDeclaration(declaration);\r\n        if (!file || file.isDeclarationFile) {\r\n            return undefined;\r\n        }\r\n        return getResolvedExternalModuleName(host, file);\r\n    }\r\n\r\n    /**\r\n     * Resolves a local path to a path which is absolute to the base of the emit\r\n     */\r\n    export function getExternalModuleNameFromPath(host: EmitHost, fileName: string): string {\r\n        const getCanonicalFileName = (f: string) => host.getCanonicalFileName(f);\r\n        const dir = toPath(host.getCommonSourceDirectory(), host.getCurrentDirectory(), getCanonicalFileName);\r\n        const filePath = getNormalizedAbsolutePath(fileName, host.getCurrentDirectory());\r\n        const relativePath = getRelativePathToDirectoryOrUrl(dir, filePath, dir, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);\r\n        return removeFileExtension(relativePath);\r\n    }\r\n\r\n    export function getOwnEmitOutputFilePath(sourceFile: SourceFile, host: EmitHost, extension: string) {\r\n        const compilerOptions = host.getCompilerOptions();\r\n        let emitOutputFilePathWithoutExtension: string;\r\n        if (compilerOptions.outDir) {\r\n            emitOutputFilePathWithoutExtension = removeFileExtension(getSourceFilePathInNewDir(sourceFile, host, compilerOptions.outDir));\r\n        }\r\n        else {\r\n            emitOutputFilePathWithoutExtension = removeFileExtension(sourceFile.fileName);\r\n        }\r\n\r\n        return emitOutputFilePathWithoutExtension + extension;\r\n    }\r\n\r\n    export function getDeclarationEmitOutputFilePath(sourceFile: SourceFile, host: EmitHost) {\r\n        const options = host.getCompilerOptions();\r\n        const outputDir = options.declarationDir || options.outDir; // Prefer declaration folder if specified\r\n\r\n        const path = outputDir\r\n            ? getSourceFilePathInNewDir(sourceFile, host, outputDir)\r\n            : sourceFile.fileName;\r\n        return removeFileExtension(path) + Extension.Dts;\r\n    }\r\n\r\n    export interface EmitFileNames {\r\n        jsFilePath: string;\r\n        sourceMapFilePath: string | undefined;\r\n        declarationFilePath: string | undefined;\r\n        declarationMapPath: string | undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the source files that are expected to have an emit output.\r\n     *\r\n     * Originally part of `forEachExpectedEmitFile`, this functionality was extracted to support\r\n     * transformations.\r\n     *\r\n     * @param host An EmitHost.\r\n     * @param targetSourceFile An optional target source file to emit.\r\n     */\r\n    export function getSourceFilesToEmit(host: EmitHost, targetSourceFile?: SourceFile): ReadonlyArray<SourceFile> {\r\n        const options = host.getCompilerOptions();\r\n        const isSourceFileFromExternalLibrary = (file: SourceFile) => host.isSourceFileFromExternalLibrary(file);\r\n        if (options.outFile || options.out) {\r\n            const moduleKind = getEmitModuleKind(options);\r\n            const moduleEmitEnabled = moduleKind === ModuleKind.AMD || moduleKind === ModuleKind.System;\r\n            // Can emit only sources that are not declaration file and are either non module code or module with --module or --target es6 specified\r\n            return filter(host.getSourceFiles(), sourceFile =>\r\n                (moduleEmitEnabled || !isExternalModule(sourceFile)) && sourceFileMayBeEmitted(sourceFile, options, isSourceFileFromExternalLibrary));\r\n        }\r\n        else {\r\n            const sourceFiles = targetSourceFile === undefined ? host.getSourceFiles() : [targetSourceFile];\r\n            return filter(sourceFiles, sourceFile => sourceFileMayBeEmitted(sourceFile, options, isSourceFileFromExternalLibrary));\r\n        }\r\n    }\r\n\r\n    /** Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks. */\r\n    export function sourceFileMayBeEmitted(sourceFile: SourceFile, options: CompilerOptions, isSourceFileFromExternalLibrary: (file: SourceFile) => boolean) {\r\n        return !(options.noEmitForJsFiles && isSourceFileJavaScript(sourceFile)) && !sourceFile.isDeclarationFile && !isSourceFileFromExternalLibrary(sourceFile);\r\n    }\r\n\r\n    export function getSourceFilePathInNewDir(sourceFile: SourceFile, host: EmitHost, newDirPath: string) {\r\n        let sourceFilePath = getNormalizedAbsolutePath(sourceFile.fileName, host.getCurrentDirectory());\r\n        const commonSourceDirectory = host.getCommonSourceDirectory();\r\n        const isSourceFileInCommonSourceDirectory = host.getCanonicalFileName(sourceFilePath).indexOf(host.getCanonicalFileName(commonSourceDirectory)) === 0;\r\n        sourceFilePath = isSourceFileInCommonSourceDirectory ? sourceFilePath.substring(commonSourceDirectory.length) : sourceFilePath;\r\n        return combinePaths(newDirPath, sourceFilePath);\r\n    }\r\n\r\n    export function writeFile(host: EmitHost, diagnostics: DiagnosticCollection, fileName: string, data: string, writeByteOrderMark: boolean, sourceFiles?: ReadonlyArray<SourceFile>) {\r\n        host.writeFile(fileName, data, writeByteOrderMark, hostErrorMessage => {\r\n            diagnostics.add(createCompilerDiagnostic(Diagnostics.Could_not_write_file_0_Colon_1, fileName, hostErrorMessage));\r\n        }, sourceFiles);\r\n    }\r\n\r\n    export function getLineOfLocalPosition(currentSourceFile: SourceFile, pos: number) {\r\n        return getLineAndCharacterOfPosition(currentSourceFile, pos).line;\r\n    }\r\n\r\n    export function getLineOfLocalPositionFromLineMap(lineMap: ReadonlyArray<number>, pos: number) {\r\n        return computeLineAndCharacterOfPosition(lineMap, pos).line;\r\n    }\r\n\r\n    export function getFirstConstructorWithBody(node: ClassLikeDeclaration): ConstructorDeclaration {\r\n        return find(node.members, (member): member is ConstructorDeclaration => isConstructorDeclaration(member) && nodeIsPresent(member.body));\r\n    }\r\n\r\n    function getSetAccessorValueParameter(accessor: SetAccessorDeclaration): ParameterDeclaration | undefined {\r\n        if (accessor && accessor.parameters.length > 0) {\r\n            const hasThis = accessor.parameters.length === 2 && parameterIsThisKeyword(accessor.parameters[0]);\r\n            return accessor.parameters[hasThis ? 1 : 0];\r\n        }\r\n    }\r\n\r\n    /** Get the type annotation for the value parameter. */\r\n    export function getSetAccessorTypeAnnotationNode(accessor: SetAccessorDeclaration): TypeNode {\r\n        const parameter = getSetAccessorValueParameter(accessor);\r\n        return parameter && parameter.type;\r\n    }\r\n\r\n    export function getThisParameter(signature: SignatureDeclaration): ParameterDeclaration | undefined {\r\n        if (signature.parameters.length) {\r\n            const thisParameter = signature.parameters[0];\r\n            if (parameterIsThisKeyword(thisParameter)) {\r\n                return thisParameter;\r\n            }\r\n        }\r\n    }\r\n\r\n    export function parameterIsThisKeyword(parameter: ParameterDeclaration): boolean {\r\n        return isThisIdentifier(parameter.name);\r\n    }\r\n\r\n    export function isThisIdentifier(node: Node | undefined): boolean {\r\n        return node && node.kind === SyntaxKind.Identifier && identifierIsThisKeyword(node as Identifier);\r\n    }\r\n\r\n    export function identifierIsThisKeyword(id: Identifier): boolean {\r\n        return id.originalKeywordKind === SyntaxKind.ThisKeyword;\r\n    }\r\n\r\n    export interface AllAccessorDeclarations {\r\n        firstAccessor: AccessorDeclaration;\r\n        secondAccessor: AccessorDeclaration;\r\n        getAccessor: AccessorDeclaration;\r\n        setAccessor: AccessorDeclaration;\r\n    }\r\n\r\n    export function getAllAccessorDeclarations(declarations: NodeArray<Declaration>, accessor: AccessorDeclaration): AllAccessorDeclarations {\r\n        let firstAccessor: AccessorDeclaration;\r\n        let secondAccessor: AccessorDeclaration;\r\n        let getAccessor: AccessorDeclaration;\r\n        let setAccessor: AccessorDeclaration;\r\n        if (hasDynamicName(accessor)) {\r\n            firstAccessor = accessor;\r\n            if (accessor.kind === SyntaxKind.GetAccessor) {\r\n                getAccessor = accessor;\r\n            }\r\n            else if (accessor.kind === SyntaxKind.SetAccessor) {\r\n                setAccessor = accessor;\r\n            }\r\n            else {\r\n                Debug.fail(\"Accessor has wrong kind\");\r\n            }\r\n        }\r\n        else {\r\n            forEach(declarations, (member: Declaration) => {\r\n                if ((member.kind === SyntaxKind.GetAccessor || member.kind === SyntaxKind.SetAccessor)\r\n                    && hasModifier(member, ModifierFlags.Static) === hasModifier(accessor, ModifierFlags.Static)) {\r\n                    const memberName = getPropertyNameForPropertyNameNode((member as NamedDeclaration).name);\r\n                    const accessorName = getPropertyNameForPropertyNameNode(accessor.name);\r\n                    if (memberName === accessorName) {\r\n                        if (!firstAccessor) {\r\n                            firstAccessor = <AccessorDeclaration>member;\r\n                        }\r\n                        else if (!secondAccessor) {\r\n                            secondAccessor = <AccessorDeclaration>member;\r\n                        }\r\n\r\n                        if (member.kind === SyntaxKind.GetAccessor && !getAccessor) {\r\n                            getAccessor = <AccessorDeclaration>member;\r\n                        }\r\n\r\n                        if (member.kind === SyntaxKind.SetAccessor && !setAccessor) {\r\n                            setAccessor = <AccessorDeclaration>member;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return {\r\n            firstAccessor,\r\n            secondAccessor,\r\n            getAccessor,\r\n            setAccessor\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the effective type annotation of a variable, parameter, or property. If the node was\r\n     * parsed in a JavaScript file, gets the type annotation from JSDoc.\r\n     */\r\n    export function getEffectiveTypeAnnotationNode(node: Node): TypeNode | undefined {\r\n        return (node as HasType).type || (isInJavaScriptFile(node) ? getJSDocType(node) : undefined);\r\n    }\r\n\r\n    export function getTypeAnnotationNode(node: Node): TypeNode | undefined {\r\n        return (node as HasType).type;\r\n    }\r\n\r\n    /**\r\n     * Gets the effective return type annotation of a signature. If the node was parsed in a\r\n     * JavaScript file, gets the return type annotation from JSDoc.\r\n     */\r\n    export function getEffectiveReturnTypeNode(node: SignatureDeclaration): TypeNode | undefined {\r\n        return node.type || (isInJavaScriptFile(node) ? getJSDocReturnType(node) : undefined);\r\n    }\r\n\r\n    /**\r\n     * Gets the effective type parameters. If the node was parsed in a\r\n     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.\r\n     */\r\n    export function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters) {\r\n        return node.typeParameters || (isInJavaScriptFile(node) ? getJSDocTypeParameterDeclarations(node) : undefined);\r\n    }\r\n\r\n    export function getJSDocTypeParameterDeclarations(node: DeclarationWithTypeParameters) {\r\n        const templateTag = getJSDocTemplateTag(node);\r\n        return templateTag && templateTag.typeParameters;\r\n    }\r\n\r\n    /**\r\n     * Gets the effective type annotation of the value parameter of a set accessor. If the node\r\n     * was parsed in a JavaScript file, gets the type annotation from JSDoc.\r\n     */\r\n    export function getEffectiveSetAccessorTypeAnnotationNode(node: SetAccessorDeclaration): TypeNode {\r\n        const parameter = getSetAccessorValueParameter(node);\r\n        return parameter && getEffectiveTypeAnnotationNode(parameter);\r\n    }\r\n\r\n    export function emitNewLineBeforeLeadingComments(lineMap: ReadonlyArray<number>, writer: EmitTextWriter, node: TextRange, leadingComments: ReadonlyArray<CommentRange>) {\r\n        emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, node.pos, leadingComments);\r\n    }\r\n\r\n    export function emitNewLineBeforeLeadingCommentsOfPosition(lineMap: ReadonlyArray<number>, writer: EmitTextWriter, pos: number, leadingComments: ReadonlyArray<CommentRange>) {\r\n        // If the leading comments start on different line than the start of node, write new line\r\n        if (leadingComments && leadingComments.length && pos !== leadingComments[0].pos &&\r\n            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, leadingComments[0].pos)) {\r\n            writer.writeLine();\r\n        }\r\n    }\r\n\r\n    export function emitNewLineBeforeLeadingCommentOfPosition(lineMap: ReadonlyArray<number>, writer: EmitTextWriter, pos: number, commentPos: number) {\r\n        // If the leading comments start on different line than the start of node, write new line\r\n        if (pos !== commentPos &&\r\n            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, commentPos)) {\r\n            writer.writeLine();\r\n        }\r\n    }\r\n\r\n    export function emitComments(\r\n        text: string,\r\n        lineMap: ReadonlyArray<number>,\r\n        writer: EmitTextWriter,\r\n        comments: ReadonlyArray<CommentRange>,\r\n        leadingSeparator: boolean,\r\n        trailingSeparator: boolean,\r\n        newLine: string,\r\n        writeComment: (text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void) {\r\n        if (comments && comments.length > 0) {\r\n            if (leadingSeparator) {\r\n                writer.write(\" \");\r\n            }\r\n\r\n            let emitInterveningSeparator = false;\r\n            for (const comment of comments) {\r\n                if (emitInterveningSeparator) {\r\n                    writer.write(\" \");\r\n                    emitInterveningSeparator = false;\r\n                }\r\n\r\n                writeComment(text, lineMap, writer, comment.pos, comment.end, newLine);\r\n                if (comment.hasTrailingNewLine) {\r\n                    writer.writeLine();\r\n                }\r\n                else {\r\n                    emitInterveningSeparator = true;\r\n                }\r\n            }\r\n\r\n            if (emitInterveningSeparator && trailingSeparator) {\r\n                writer.write(\" \");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detached comment is a comment at the top of file or function body that is separated from\r\n     * the next statement by space.\r\n     */\r\n    export function emitDetachedComments(text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter,\r\n        writeComment: (text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void,\r\n        node: TextRange, newLine: string, removeComments: boolean) {\r\n        let leadingComments: CommentRange[];\r\n        let currentDetachedCommentInfo: { nodePos: number, detachedCommentEndPos: number };\r\n        if (removeComments) {\r\n            // removeComments is true, only reserve pinned comment at the top of file\r\n            // For example:\r\n            //      /*! Pinned Comment */\r\n            //\r\n            //      var x = 10;\r\n            if (node.pos === 0) {\r\n                leadingComments = filter(getLeadingCommentRanges(text, node.pos), isPinnedCommentLocal);\r\n            }\r\n        }\r\n        else {\r\n            // removeComments is false, just get detached as normal and bypass the process to filter comment\r\n            leadingComments = getLeadingCommentRanges(text, node.pos);\r\n        }\r\n\r\n        if (leadingComments) {\r\n            const detachedComments: CommentRange[] = [];\r\n            let lastComment: CommentRange;\r\n\r\n            for (const comment of leadingComments) {\r\n                if (lastComment) {\r\n                    const lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, lastComment.end);\r\n                    const commentLine = getLineOfLocalPositionFromLineMap(lineMap, comment.pos);\r\n\r\n                    if (commentLine >= lastCommentLine + 2) {\r\n                        // There was a blank line between the last comment and this comment.  This\r\n                        // comment is not part of the copyright comments.  Return what we have so\r\n                        // far.\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                detachedComments.push(comment);\r\n                lastComment = comment;\r\n            }\r\n\r\n            if (detachedComments.length) {\r\n                // All comments look like they could have been part of the copyright header.  Make\r\n                // sure there is at least one blank line between it and the node.  If not, it's not\r\n                // a copyright header.\r\n                const lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, lastOrUndefined(detachedComments).end);\r\n                const nodeLine = getLineOfLocalPositionFromLineMap(lineMap, skipTrivia(text, node.pos));\r\n                if (nodeLine >= lastCommentLine + 2) {\r\n                    // Valid detachedComments\r\n                    emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments);\r\n                    emitComments(text, lineMap, writer, detachedComments, /*leadingSeparator*/ false, /*trailingSeparator*/ true, newLine, writeComment);\r\n                    currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: lastOrUndefined(detachedComments).end };\r\n                }\r\n            }\r\n        }\r\n\r\n        return currentDetachedCommentInfo;\r\n\r\n        function isPinnedCommentLocal(comment: CommentRange) {\r\n            return isPinnedComment(text, comment.pos);\r\n        }\r\n\r\n    }\r\n\r\n    export function writeCommentRange(text: string, lineMap: ReadonlyArray<number>, writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) {\r\n        if (text.charCodeAt(commentPos + 1) === CharacterCodes.asterisk) {\r\n            const firstCommentLineAndCharacter = computeLineAndCharacterOfPosition(lineMap, commentPos);\r\n            const lineCount = lineMap.length;\r\n            let firstCommentLineIndent: number;\r\n            for (let pos = commentPos, currentLine = firstCommentLineAndCharacter.line; pos < commentEnd; currentLine++) {\r\n                const nextLineStart = (currentLine + 1) === lineCount\r\n                    ? text.length + 1\r\n                    : lineMap[currentLine + 1];\r\n\r\n                if (pos !== commentPos) {\r\n                    // If we are not emitting first line, we need to write the spaces to adjust the alignment\r\n                    if (firstCommentLineIndent === undefined) {\r\n                        firstCommentLineIndent = calculateIndent(text, lineMap[firstCommentLineAndCharacter.line], commentPos);\r\n                    }\r\n\r\n                    // These are number of spaces writer is going to write at current indent\r\n                    const currentWriterIndentSpacing = writer.getIndent() * getIndentSize();\r\n\r\n                    // Number of spaces we want to be writing\r\n                    // eg: Assume writer indent\r\n                    // module m {\r\n                    //         /* starts at character 9 this is line 1\r\n                    //    * starts at character pos 4 line                        --1  = 8 - 8 + 3\r\n                    //   More left indented comment */                            --2  = 8 - 8 + 2\r\n                    //     class c { }\r\n                    // }\r\n                    // module m {\r\n                    //     /* this is line 1 -- Assume current writer indent 8\r\n                    //      * line                                                --3 = 8 - 4 + 5\r\n                    //            More right indented comment */                  --4 = 8 - 4 + 11\r\n                    //     class c { }\r\n                    // }\r\n                    const spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(text, pos, nextLineStart);\r\n                    if (spacesToEmit > 0) {\r\n                        let numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();\r\n                        const indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());\r\n\r\n                        // Write indent size string ( in eg 1: = \"\", 2: \"\" , 3: string with 8 spaces 4: string with 12 spaces\r\n                        writer.rawWrite(indentSizeSpaceString);\r\n\r\n                        // Emit the single spaces (in eg: 1: 3 spaces, 2: 2 spaces, 3: 1 space, 4: 3 spaces)\r\n                        while (numberOfSingleSpacesToEmit) {\r\n                            writer.rawWrite(\" \");\r\n                            numberOfSingleSpacesToEmit--;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // No spaces to emit write empty string\r\n                        writer.rawWrite(\"\");\r\n                    }\r\n                }\r\n\r\n                // Write the comment line text\r\n                writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart);\r\n\r\n                pos = nextLineStart;\r\n            }\r\n        }\r\n        else {\r\n            // Single line comment of style //....\r\n            writer.write(text.substring(commentPos, commentEnd));\r\n        }\r\n    }\r\n\r\n    function writeTrimmedCurrentLine(text: string, commentEnd: number, writer: EmitTextWriter, newLine: string, pos: number, nextLineStart: number) {\r\n        const end = Math.min(commentEnd, nextLineStart - 1);\r\n        const currentLineText = text.substring(pos, end).replace(/^\\s+|\\s+$/g, \"\");\r\n        if (currentLineText) {\r\n            // trimmed forward and ending spaces text\r\n            writer.write(currentLineText);\r\n            if (end !== commentEnd) {\r\n                writer.writeLine();\r\n            }\r\n        }\r\n        else {\r\n            // Empty string - make sure we write empty line\r\n            writer.writeLiteral(newLine);\r\n        }\r\n    }\r\n\r\n    function calculateIndent(text: string, pos: number, end: number) {\r\n        let currentLineIndent = 0;\r\n        for (; pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos)); pos++) {\r\n            if (text.charCodeAt(pos) === CharacterCodes.tab) {\r\n                // Tabs = TabSize = indent size and go to next tabStop\r\n                currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize());\r\n            }\r\n            else {\r\n                // Single space\r\n                currentLineIndent++;\r\n            }\r\n        }\r\n\r\n        return currentLineIndent;\r\n    }\r\n\r\n    export function hasModifiers(node: Node) {\r\n        return getModifierFlags(node) !== ModifierFlags.None;\r\n    }\r\n\r\n    export function hasModifier(node: Node, flags: ModifierFlags): boolean {\r\n        return !!getSelectedModifierFlags(node, flags);\r\n    }\r\n\r\n    export function hasStaticModifier(node: Node): boolean {\r\n        return hasModifier(node, ModifierFlags.Static);\r\n    }\r\n\r\n    export function hasReadonlyModifier(node: Node): boolean {\r\n        return hasModifier(node, ModifierFlags.Readonly);\r\n    }\r\n\r\n    export function getSelectedModifierFlags(node: Node, flags: ModifierFlags): ModifierFlags {\r\n        return getModifierFlags(node) & flags;\r\n    }\r\n\r\n    export function getModifierFlags(node: Node): ModifierFlags {\r\n        if (node.modifierFlagsCache & ModifierFlags.HasComputedFlags) {\r\n            return node.modifierFlagsCache & ~ModifierFlags.HasComputedFlags;\r\n        }\r\n\r\n        const flags = getModifierFlagsNoCache(node);\r\n        node.modifierFlagsCache = flags | ModifierFlags.HasComputedFlags;\r\n        return flags;\r\n    }\r\n\r\n    export function getModifierFlagsNoCache(node: Node): ModifierFlags {\r\n\r\n        let flags = ModifierFlags.None;\r\n        if (node.modifiers) {\r\n            for (const modifier of node.modifiers) {\r\n                flags |= modifierToFlag(modifier.kind);\r\n            }\r\n        }\r\n\r\n        if (node.flags & NodeFlags.NestedNamespace || (node.kind === SyntaxKind.Identifier && (<Identifier>node).isInJSDocNamespace)) {\r\n            flags |= ModifierFlags.Export;\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    export function modifierToFlag(token: SyntaxKind): ModifierFlags {\r\n        switch (token) {\r\n            case SyntaxKind.StaticKeyword: return ModifierFlags.Static;\r\n            case SyntaxKind.PublicKeyword: return ModifierFlags.Public;\r\n            case SyntaxKind.ProtectedKeyword: return ModifierFlags.Protected;\r\n            case SyntaxKind.PrivateKeyword: return ModifierFlags.Private;\r\n            case SyntaxKind.AbstractKeyword: return ModifierFlags.Abstract;\r\n            case SyntaxKind.ExportKeyword: return ModifierFlags.Export;\r\n            case SyntaxKind.DeclareKeyword: return ModifierFlags.Ambient;\r\n            case SyntaxKind.ConstKeyword: return ModifierFlags.Const;\r\n            case SyntaxKind.DefaultKeyword: return ModifierFlags.Default;\r\n            case SyntaxKind.AsyncKeyword: return ModifierFlags.Async;\r\n            case SyntaxKind.ReadonlyKeyword: return ModifierFlags.Readonly;\r\n        }\r\n        return ModifierFlags.None;\r\n    }\r\n\r\n    export function isLogicalOperator(token: SyntaxKind): boolean {\r\n        return token === SyntaxKind.BarBarToken\r\n            || token === SyntaxKind.AmpersandAmpersandToken\r\n            || token === SyntaxKind.ExclamationToken;\r\n    }\r\n\r\n    export function isAssignmentOperator(token: SyntaxKind): boolean {\r\n        return token >= SyntaxKind.FirstAssignment && token <= SyntaxKind.LastAssignment;\r\n    }\r\n\r\n    /** Get `C` given `N` if `N` is in the position `class C extends N` where `N` is an ExpressionWithTypeArguments. */\r\n    export function tryGetClassExtendingExpressionWithTypeArguments(node: Node): ClassLikeDeclaration | undefined {\r\n        if (node.kind === SyntaxKind.ExpressionWithTypeArguments &&\r\n            (<HeritageClause>node.parent).token === SyntaxKind.ExtendsKeyword &&\r\n            isClassLike(node.parent.parent)) {\r\n            return node.parent.parent;\r\n        }\r\n    }\r\n\r\n    export function isAssignmentExpression(node: Node, excludeCompoundAssignment: true): node is AssignmentExpression<EqualsToken>;\r\n    export function isAssignmentExpression(node: Node, excludeCompoundAssignment?: false): node is AssignmentExpression<AssignmentOperatorToken>;\r\n    export function isAssignmentExpression(node: Node, excludeCompoundAssignment?: boolean): node is AssignmentExpression<AssignmentOperatorToken> {\r\n        return isBinaryExpression(node)\r\n            && (excludeCompoundAssignment\r\n                ? node.operatorToken.kind === SyntaxKind.EqualsToken\r\n                : isAssignmentOperator(node.operatorToken.kind))\r\n            && isLeftHandSideExpression(node.left);\r\n    }\r\n\r\n    export function isDestructuringAssignment(node: Node): node is DestructuringAssignment {\r\n        if (isAssignmentExpression(node, /*excludeCompoundAssignment*/ true)) {\r\n            const kind = node.left.kind;\r\n            return kind === SyntaxKind.ObjectLiteralExpression\r\n                || kind === SyntaxKind.ArrayLiteralExpression;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    export function isExpressionWithTypeArgumentsInClassExtendsClause(node: Node): boolean {\r\n        return tryGetClassExtendingExpressionWithTypeArguments(node) !== undefined;\r\n    }\r\n\r\n    export function isExpressionWithTypeArgumentsInClassImplementsClause(node: Node): node is ExpressionWithTypeArguments {\r\n        return node.kind === SyntaxKind.ExpressionWithTypeArguments\r\n            && isEntityNameExpression((node as ExpressionWithTypeArguments).expression)\r\n            && node.parent\r\n            && (<HeritageClause>node.parent).token === SyntaxKind.ImplementsKeyword\r\n            && node.parent.parent\r\n            && isClassLike(node.parent.parent);\r\n    }\r\n\r\n    export function isEntityNameExpression(node: Node): node is EntityNameExpression {\r\n        return node.kind === SyntaxKind.Identifier || isPropertyAccessEntityNameExpression(node);\r\n    }\r\n\r\n    export function isPropertyAccessEntityNameExpression(node: Node): node is PropertyAccessEntityNameExpression {\r\n        return isPropertyAccessExpression(node) && isEntityNameExpression(node.expression);\r\n    }\r\n\r\n    export function isPrototypeAccess(node: Node): node is PropertyAccessExpression {\r\n        return isPropertyAccessExpression(node) && node.name.escapedText === \"prototype\";\r\n    }\r\n\r\n    export function isRightSideOfQualifiedNameOrPropertyAccess(node: Node) {\r\n        return (node.parent.kind === SyntaxKind.QualifiedName && (<QualifiedName>node.parent).right === node) ||\r\n            (node.parent.kind === SyntaxKind.PropertyAccessExpression && (<PropertyAccessExpression>node.parent).name === node);\r\n    }\r\n\r\n    export function isEmptyObjectLiteral(expression: Node): boolean {\r\n        return expression.kind === SyntaxKind.ObjectLiteralExpression &&\r\n            (<ObjectLiteralExpression>expression).properties.length === 0;\r\n    }\r\n\r\n    export function isEmptyArrayLiteral(expression: Node): boolean {\r\n        return expression.kind === SyntaxKind.ArrayLiteralExpression &&\r\n            (<ArrayLiteralExpression>expression).elements.length === 0;\r\n    }\r\n\r\n    export function getLocalSymbolForExportDefault(symbol: Symbol) {\r\n        return isExportDefaultSymbol(symbol) ? symbol.declarations[0].localSymbol : undefined;\r\n    }\r\n\r\n    function isExportDefaultSymbol(symbol: Symbol): boolean {\r\n        return symbol && length(symbol.declarations) > 0 && hasModifier(symbol.declarations[0], ModifierFlags.Default);\r\n    }\r\n\r\n    /** Return \".ts\", \".d.ts\", or \".tsx\", if that is the extension. */\r\n    export function tryExtractTypeScriptExtension(fileName: string): string | undefined {\r\n        return find(supportedTypescriptExtensionsForExtractExtension, extension => fileExtensionIs(fileName, extension));\r\n    }\r\n    /**\r\n     * Replace each instance of non-ascii characters by one, two, three, or four escape sequences\r\n     * representing the UTF-8 encoding of the character, and return the expanded char code list.\r\n     */\r\n    function getExpandedCharCodes(input: string): number[] {\r\n        const output: number[] = [];\r\n        const length = input.length;\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            const charCode = input.charCodeAt(i);\r\n\r\n            // handle utf8\r\n            if (charCode < 0x80) {\r\n                output.push(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                output.push((charCode >> 6) | 0B11000000);\r\n                output.push((charCode & 0B00111111) | 0B10000000);\r\n            }\r\n            else if (charCode < 0x10000) {\r\n                output.push((charCode >> 12) | 0B11100000);\r\n                output.push(((charCode >> 6) & 0B00111111) | 0B10000000);\r\n                output.push((charCode & 0B00111111) | 0B10000000);\r\n            }\r\n            else if (charCode < 0x20000) {\r\n                output.push((charCode >> 18) | 0B11110000);\r\n                output.push(((charCode >> 12) & 0B00111111) | 0B10000000);\r\n                output.push(((charCode >> 6) & 0B00111111) | 0B10000000);\r\n                output.push((charCode & 0B00111111) | 0B10000000);\r\n            }\r\n            else {\r\n                Debug.assert(false, \"Unexpected code point\");\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    const base64Digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n\r\n    /**\r\n     * Converts a string to a base-64 encoded ASCII string.\r\n     */\r\n    export function convertToBase64(input: string): string {\r\n        let result = \"\";\r\n        const charCodes = getExpandedCharCodes(input);\r\n        let i = 0;\r\n        const length = charCodes.length;\r\n        let byte1: number, byte2: number, byte3: number, byte4: number;\r\n\r\n        while (i < length) {\r\n            // Convert every 6-bits in the input 3 character points\r\n            // into a base64 digit\r\n            byte1 = charCodes[i] >> 2;\r\n            byte2 = (charCodes[i] & 0B00000011) << 4 | charCodes[i + 1] >> 4;\r\n            byte3 = (charCodes[i + 1] & 0B00001111) << 2 | charCodes[i + 2] >> 6;\r\n            byte4 = charCodes[i + 2] & 0B00111111;\r\n\r\n            // We are out of characters in the input, set the extra\r\n            // digits to 64 (padding character).\r\n            if (i + 1 >= length) {\r\n                byte3 = byte4 = 64;\r\n            }\r\n            else if (i + 2 >= length) {\r\n                byte4 = 64;\r\n            }\r\n\r\n            // Write to the output\r\n            result += base64Digits.charAt(byte1) + base64Digits.charAt(byte2) + base64Digits.charAt(byte3) + base64Digits.charAt(byte4);\r\n\r\n            i += 3;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getStringFromExpandedCharCodes(codes: number[]): string {\r\n        let output = \"\";\r\n        let i = 0;\r\n        const length = codes.length;\r\n        while (i < length) {\r\n            const charCode = codes[i];\r\n\r\n            if (charCode < 0x80) {\r\n                output += String.fromCharCode(charCode);\r\n                i++;\r\n            }\r\n            else if ((charCode & 0B11000000) === 0B11000000) {\r\n                let value = charCode & 0B00111111;\r\n                i++;\r\n                let nextCode: number = codes[i];\r\n                while ((nextCode & 0B11000000) === 0B10000000) {\r\n                    value = (value << 6) | (nextCode & 0B00111111);\r\n                    i++;\r\n                    nextCode = codes[i];\r\n                }\r\n                // `value` may be greater than 10FFFF (the maximum unicode codepoint) - JS will just make this into an invalid character for us\r\n                output += String.fromCharCode(value);\r\n            }\r\n            else {\r\n                // We don't want to kill the process when decoding fails (due to a following char byte not\r\n                // following a leading char), so we just print the (bad) value\r\n                output += String.fromCharCode(charCode);\r\n                i++;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    export function base64encode(host: { base64encode?(input: string): string }, input: string): string {\r\n        if (host.base64encode) {\r\n            return host.base64encode(input);\r\n        }\r\n        return convertToBase64(input);\r\n    }\r\n\r\n    export function base64decode(host: { base64decode?(input: string): string }, input: string): string {\r\n        if (host.base64decode) {\r\n            return host.base64decode(input);\r\n        }\r\n        const length = input.length;\r\n        const expandedCharCodes: number[] = [];\r\n        let i = 0;\r\n        while (i < length) {\r\n            // Stop decoding once padding characters are present\r\n            if (input.charCodeAt(i) === base64Digits.charCodeAt(64)) {\r\n                break;\r\n            }\r\n            // convert 4 input digits into three characters, ignoring padding characters at the end\r\n            const ch1 = base64Digits.indexOf(input[i]);\r\n            const ch2 = base64Digits.indexOf(input[i + 1]);\r\n            const ch3 = base64Digits.indexOf(input[i + 2]);\r\n            const ch4 = base64Digits.indexOf(input[i + 3]);\r\n\r\n            const code1 = ((ch1 & 0B00111111) << 2) | ((ch2 >> 4) & 0B00000011);\r\n            const code2 = ((ch2 & 0B00001111) << 4) | ((ch3 >> 2) & 0B00001111);\r\n            const code3 = ((ch3 & 0B00000011) << 6) | (ch4 & 0B00111111);\r\n\r\n            if (code2 === 0 && ch3 !== 0) { // code2 decoded to zero, but ch3 was padding - elide code2 and code3\r\n                expandedCharCodes.push(code1);\r\n            }\r\n            else if (code3 === 0 && ch4 !== 0) { // code3 decoded to zero, but ch4 was padding, elide code3\r\n                expandedCharCodes.push(code1, code2);\r\n            }\r\n            else {\r\n                expandedCharCodes.push(code1, code2, code3);\r\n            }\r\n            i += 4;\r\n        }\r\n        return getStringFromExpandedCharCodes(expandedCharCodes);\r\n    }\r\n\r\n    const carriageReturnLineFeed = \"\\r\\n\";\r\n    const lineFeed = \"\\n\";\r\n    export function getNewLineCharacter(options: CompilerOptions | PrinterOptions, getNewLine?: () => string): string {\r\n        switch (options.newLine) {\r\n            case NewLineKind.CarriageReturnLineFeed:\r\n                return carriageReturnLineFeed;\r\n            case NewLineKind.LineFeed:\r\n                return lineFeed;\r\n        }\r\n        return getNewLine ? getNewLine() : sys ? sys.newLine : carriageReturnLineFeed;\r\n    }\r\n\r\n    /**\r\n     * Formats an enum value as a string for debugging and debug assertions.\r\n     */\r\n    function formatEnum(value = 0, enumObject: any, isFlags?: boolean) {\r\n        const members = getEnumMembers(enumObject);\r\n        if (value === 0) {\r\n            return members.length > 0 && members[0][0] === 0 ? members[0][1] : \"0\";\r\n        }\r\n        if (isFlags) {\r\n            let result = \"\";\r\n            let remainingFlags = value;\r\n            for (let i = members.length - 1; i >= 0 && remainingFlags !== 0; i--) {\r\n                const [enumValue, enumName] = members[i];\r\n                if (enumValue !== 0 && (remainingFlags & enumValue) === enumValue) {\r\n                    remainingFlags &= ~enumValue;\r\n                    result = `${enumName}${result ? \", \" : \"\"}${result}`;\r\n                }\r\n            }\r\n            if (remainingFlags === 0) {\r\n                return result;\r\n            }\r\n        }\r\n        else {\r\n            for (const [enumValue, enumName] of members) {\r\n                if (enumValue === value) {\r\n                    return enumName;\r\n                }\r\n            }\r\n        }\r\n        return value.toString();\r\n    }\r\n\r\n    function getEnumMembers(enumObject: any) {\r\n        const result: [number, string][] = [];\r\n        for (const name in enumObject) {\r\n            const value = enumObject[name];\r\n            if (typeof value === \"number\") {\r\n                result.push([value, name]);\r\n            }\r\n        }\r\n\r\n        return stableSort<[number, string]>(result, (x, y) => compareValues(x[0], y[0]));\r\n    }\r\n\r\n    export function formatSyntaxKind(kind: SyntaxKind): string {\r\n        return formatEnum(kind, (<any>ts).SyntaxKind, /*isFlags*/ false);\r\n    }\r\n\r\n    export function formatModifierFlags(flags: ModifierFlags): string {\r\n        return formatEnum(flags, (<any>ts).ModifierFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatTransformFlags(flags: TransformFlags): string {\r\n        return formatEnum(flags, (<any>ts).TransformFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatEmitFlags(flags: EmitFlags): string {\r\n        return formatEnum(flags, (<any>ts).EmitFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatSymbolFlags(flags: SymbolFlags): string {\r\n        return formatEnum(flags, (<any>ts).SymbolFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatTypeFlags(flags: TypeFlags): string {\r\n        return formatEnum(flags, (<any>ts).TypeFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    export function formatObjectFlags(flags: ObjectFlags): string {\r\n        return formatEnum(flags, (<any>ts).ObjectFlags, /*isFlags*/ true);\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange from the provided pos and end.\r\n     *\r\n     * @param pos The start position.\r\n     * @param end The end position.\r\n     */\r\n    export function createRange(pos: number, end: number): TextRange {\r\n        return { pos, end };\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange from a provided range with a new end position.\r\n     *\r\n     * @param range A TextRange.\r\n     * @param end The new end position.\r\n     */\r\n    export function moveRangeEnd(range: TextRange, end: number): TextRange {\r\n        return createRange(range.pos, end);\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange from a provided range with a new start position.\r\n     *\r\n     * @param range A TextRange.\r\n     * @param pos The new Start position.\r\n     */\r\n    export function moveRangePos(range: TextRange, pos: number): TextRange {\r\n        return createRange(pos, range.end);\r\n    }\r\n\r\n    /**\r\n     * Moves the start position of a range past any decorators.\r\n     */\r\n    export function moveRangePastDecorators(node: Node): TextRange {\r\n        return node.decorators && node.decorators.length > 0\r\n            ? moveRangePos(node, node.decorators.end)\r\n            : node;\r\n    }\r\n\r\n    /**\r\n     * Moves the start position of a range past any decorators or modifiers.\r\n     */\r\n    export function moveRangePastModifiers(node: Node): TextRange {\r\n        return node.modifiers && node.modifiers.length > 0\r\n            ? moveRangePos(node, node.modifiers.end)\r\n            : moveRangePastDecorators(node);\r\n    }\r\n\r\n    /**\r\n     * Determines whether a TextRange has the same start and end positions.\r\n     *\r\n     * @param range A TextRange.\r\n     */\r\n    export function isCollapsedRange(range: TextRange) {\r\n        return range.pos === range.end;\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRange for a token at the provides start position.\r\n     *\r\n     * @param pos The start position.\r\n     * @param token The token.\r\n     */\r\n    export function createTokenRange(pos: number, token: SyntaxKind): TextRange {\r\n        return createRange(pos, pos + tokenToString(token).length);\r\n    }\r\n\r\n    export function rangeIsOnSingleLine(range: TextRange, sourceFile: SourceFile) {\r\n        return rangeStartIsOnSameLineAsRangeEnd(range, range, sourceFile);\r\n    }\r\n\r\n    export function rangeStartPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile), getStartPositionOfRange(range2, sourceFile), sourceFile);\r\n    }\r\n\r\n    export function rangeEndPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(range1.end, range2.end, sourceFile);\r\n    }\r\n\r\n    export function rangeStartIsOnSameLineAsRangeEnd(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile), range2.end, sourceFile);\r\n    }\r\n\r\n    export function rangeEndIsOnSameLineAsRangeStart(range1: TextRange, range2: TextRange, sourceFile: SourceFile) {\r\n        return positionsAreOnSameLine(range1.end, getStartPositionOfRange(range2, sourceFile), sourceFile);\r\n    }\r\n\r\n    export function positionsAreOnSameLine(pos1: number, pos2: number, sourceFile: SourceFile) {\r\n        return pos1 === pos2 ||\r\n            getLineOfLocalPosition(sourceFile, pos1) === getLineOfLocalPosition(sourceFile, pos2);\r\n    }\r\n\r\n    export function getStartPositionOfRange(range: TextRange, sourceFile: SourceFile) {\r\n        return positionIsSynthesized(range.pos) ? -1 : skipTrivia(sourceFile.text, range.pos);\r\n    }\r\n\r\n    /**\r\n     * Determines whether a name was originally the declaration name of an enum or namespace\r\n     * declaration.\r\n     */\r\n    export function isDeclarationNameOfEnumOrNamespace(node: Identifier) {\r\n        const parseNode = getParseTreeNode(node);\r\n        if (parseNode) {\r\n            switch (parseNode.parent.kind) {\r\n                case SyntaxKind.EnumDeclaration:\r\n                case SyntaxKind.ModuleDeclaration:\r\n                    return parseNode === (<EnumDeclaration | ModuleDeclaration>parseNode.parent).name;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function getInitializedVariables(node: VariableDeclarationList) {\r\n        return filter(node.declarations, isInitializedVariable);\r\n    }\r\n\r\n    function isInitializedVariable(node: VariableDeclaration) {\r\n        return node.initializer !== undefined;\r\n    }\r\n\r\n    export function isWatchSet(options: CompilerOptions) {\r\n        // Firefox has Object.prototype.watch\r\n        return options.watch && options.hasOwnProperty(\"watch\");\r\n    }\r\n\r\n    export function getCheckFlags(symbol: Symbol): CheckFlags {\r\n        return symbol.flags & SymbolFlags.Transient ? (<TransientSymbol>symbol).checkFlags : 0;\r\n    }\r\n\r\n    export function getDeclarationModifierFlagsFromSymbol(s: Symbol): ModifierFlags {\r\n        if (s.valueDeclaration) {\r\n            const flags = getCombinedModifierFlags(s.valueDeclaration);\r\n            return s.parent && s.parent.flags & SymbolFlags.Class ? flags : flags & ~ModifierFlags.AccessibilityModifier;\r\n        }\r\n        if (getCheckFlags(s) & CheckFlags.Synthetic) {\r\n            const checkFlags = (<TransientSymbol>s).checkFlags;\r\n            const accessModifier = checkFlags & CheckFlags.ContainsPrivate ? ModifierFlags.Private :\r\n                checkFlags & CheckFlags.ContainsPublic ? ModifierFlags.Public :\r\n                    ModifierFlags.Protected;\r\n            const staticModifier = checkFlags & CheckFlags.ContainsStatic ? ModifierFlags.Static : 0;\r\n            return accessModifier | staticModifier;\r\n        }\r\n        if (s.flags & SymbolFlags.Prototype) {\r\n            return ModifierFlags.Public | ModifierFlags.Static;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    export function skipAlias(symbol: Symbol, checker: TypeChecker) {\r\n        return symbol.flags & SymbolFlags.Alias ? checker.getAliasedSymbol(symbol) : symbol;\r\n    }\r\n\r\n    /** See comment on `declareModuleMember` in `binder.ts`. */\r\n    export function getCombinedLocalAndExportSymbolFlags(symbol: Symbol): SymbolFlags {\r\n        return symbol.exportSymbol ? symbol.exportSymbol.flags | symbol.flags : symbol.flags;\r\n    }\r\n\r\n    export function isWriteOnlyAccess(node: Node) {\r\n        return accessKind(node) === AccessKind.Write;\r\n    }\r\n\r\n    export function isWriteAccess(node: Node) {\r\n        return accessKind(node) !== AccessKind.Read;\r\n    }\r\n\r\n    const enum AccessKind {\r\n        /** Only reads from a variable. */\r\n        Read,\r\n        /** Only writes to a variable without using the result. E.g.: `x++;`. */\r\n        Write,\r\n        /** Writes to a variable and uses the result as an expression. E.g.: `f(x++);`. */\r\n        ReadWrite\r\n    }\r\n    function accessKind(node: Node): AccessKind {\r\n        const { parent } = node;\r\n        if (!parent) return AccessKind.Read;\r\n\r\n        switch (parent.kind) {\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n                const { operator } = parent as PrefixUnaryExpression | PostfixUnaryExpression;\r\n                return operator === SyntaxKind.PlusPlusToken || operator === SyntaxKind.MinusMinusToken ? writeOrReadWrite() : AccessKind.Read;\r\n            case SyntaxKind.BinaryExpression:\r\n                const { left, operatorToken } = parent as BinaryExpression;\r\n                return left === node && isAssignmentOperator(operatorToken.kind) ? writeOrReadWrite() : AccessKind.Read;\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                return (parent as PropertyAccessExpression).name !== node ? AccessKind.Read : accessKind(parent);\r\n            default:\r\n                return AccessKind.Read;\r\n        }\r\n\r\n        function writeOrReadWrite(): AccessKind {\r\n            // If grandparent is not an ExpressionStatement, this is used as an expression in addition to having a side effect.\r\n            return parent.parent && parent.parent.kind === SyntaxKind.ExpressionStatement ? AccessKind.Write : AccessKind.ReadWrite;\r\n        }\r\n    }\r\n\r\n    export function compareDataObjects(dst: any, src: any): boolean {\r\n        if (!dst || !src || Object.keys(dst).length !== Object.keys(src).length) {\r\n            return false;\r\n        }\r\n\r\n        for (const e in dst) {\r\n            if (typeof dst[e] === \"object\") {\r\n                if (!compareDataObjects(dst[e], src[e])) {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (typeof dst[e] !== \"function\") {\r\n                if (dst[e] !== src[e]) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * clears already present map by calling onDeleteExistingValue callback before deleting that key/value\r\n     */\r\n    export function clearMap<T>(map: Map<T>, onDeleteValue: (valueInMap: T, key: string) => void) {\r\n        // Remove all\r\n        map.forEach(onDeleteValue);\r\n        map.clear();\r\n    }\r\n\r\n    export interface MutateMapOptions<T, U> {\r\n        createNewValue(key: string, valueInNewMap: U): T;\r\n        onDeleteValue(existingValue: T, key: string): void;\r\n\r\n        /**\r\n         * If present this is called with the key when there is value for that key both in new map as well as existing map provided\r\n         * Caller can then decide to update or remove this key.\r\n         * If the key is removed, caller will get callback of createNewValue for that key.\r\n         * If this callback is not provided, the value of such keys is not updated.\r\n         */\r\n        onExistingValue?(existingValue: T, valueInNewMap: U, key: string): void;\r\n    }\r\n\r\n    /**\r\n     * Mutates the map with newMap such that keys in map will be same as newMap.\r\n     */\r\n    export function mutateMap<T, U>(map: Map<T>, newMap: ReadonlyMap<U>, options: MutateMapOptions<T, U>) {\r\n        const { createNewValue, onDeleteValue, onExistingValue } = options;\r\n        // Needs update\r\n        map.forEach((existingValue, key) => {\r\n            const valueInNewMap = newMap.get(key);\r\n            // Not present any more in new map, remove it\r\n            if (valueInNewMap === undefined) {\r\n                map.delete(key);\r\n                onDeleteValue(existingValue, key);\r\n            }\r\n            // If present notify about existing values\r\n            else if (onExistingValue) {\r\n                onExistingValue(existingValue, valueInNewMap, key);\r\n            }\r\n        });\r\n\r\n        // Add new values that are not already present\r\n        newMap.forEach((valueInNewMap, key) => {\r\n            if (!map.has(key)) {\r\n                // New values\r\n                map.set(key, createNewValue(key, valueInNewMap));\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Calls `callback` on `directory` and every ancestor directory it has, returning the first defined result. */\r\n    export function forEachAncestorDirectory<T>(directory: string, callback: (directory: string) => T | undefined): T | undefined {\r\n        while (true) {\r\n            const result = callback(directory);\r\n            if (result !== undefined) {\r\n                return result;\r\n            }\r\n\r\n            const parentPath = getDirectoryPath(directory);\r\n            if (parentPath === directory) {\r\n                return undefined;\r\n            }\r\n\r\n            directory = parentPath;\r\n        }\r\n    }\r\n\r\n    // Return true if the given type is the constructor type for an abstract class\r\n    export function isAbstractConstructorType(type: Type): boolean {\r\n        return !!(getObjectFlags(type) & ObjectFlags.Anonymous) && !!type.symbol && isAbstractConstructorSymbol(type.symbol);\r\n    }\r\n\r\n    export function isAbstractConstructorSymbol(symbol: Symbol): boolean {\r\n        if (symbol.flags & SymbolFlags.Class) {\r\n            const declaration = getClassLikeDeclarationOfSymbol(symbol);\r\n            return !!declaration && hasModifier(declaration, ModifierFlags.Abstract);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function getClassLikeDeclarationOfSymbol(symbol: Symbol): ClassLikeDeclaration | undefined {\r\n        return find(symbol.declarations, isClassLike);\r\n    }\r\n\r\n    export function getObjectFlags(type: Type): ObjectFlags {\r\n        return type.flags & TypeFlags.Object ? (<ObjectType>type).objectFlags : 0;\r\n    }\r\n\r\n    export function typeHasCallOrConstructSignatures(type: Type, checker: TypeChecker) {\r\n        return checker.getSignaturesOfType(type, SignatureKind.Call).length !== 0 || checker.getSignaturesOfType(type, SignatureKind.Construct).length !== 0;\r\n    }\r\n\r\n    export function forSomeAncestorDirectory(directory: string, callback: (directory: string) => boolean): boolean {\r\n        return !!forEachAncestorDirectory(directory, d => callback(d) ? true : undefined);\r\n    }\r\n\r\n    export function isUMDExportSymbol(symbol: Symbol) {\r\n        return symbol && symbol.declarations && symbol.declarations[0] && isNamespaceExportDeclaration(symbol.declarations[0]);\r\n    }\r\n\r\n    export function showModuleSpecifier({ moduleSpecifier }: ImportDeclaration): string {\r\n        return isStringLiteral(moduleSpecifier) ? moduleSpecifier.text : getTextOfNode(moduleSpecifier);\r\n    }\r\n\r\n    export function getLastChild(node: Node): Node | undefined {\r\n        let lastChild: Node | undefined;\r\n        forEachChild(node,\r\n            child => {\r\n                if (nodeIsPresent(child)) lastChild = child;\r\n            },\r\n            children => {\r\n                // As an optimization, jump straight to the end of the list.\r\n                for (let i = children.length - 1; i >= 0; i--) {\r\n                    if (nodeIsPresent(children[i])) {\r\n                        lastChild = children[i];\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n        return lastChild;\r\n    }\r\n\r\n    /** Add a value to a set, and return true if it wasn't already present. */\r\n    export function addToSeen(seen: Map<true>, key: string | number): boolean;\r\n    export function addToSeen<T>(seen: Map<T>, key: string | number, value: T): boolean;\r\n    export function addToSeen<T>(seen: Map<T>, key: string | number, value: T = true as any): boolean {\r\n        key = String(key);\r\n        if (seen.has(key)) {\r\n            return false;\r\n        }\r\n        seen.set(key, value);\r\n        return true;\r\n    }\r\n\r\n    export function isObjectTypeDeclaration(node: Node): node is ObjectTypeDeclaration {\r\n        return isClassLike(node) || isInterfaceDeclaration(node) || isTypeLiteralNode(node);\r\n    }\r\n}\r\n\r\nnamespace ts {\r\n    export function getDefaultLibFileName(options: CompilerOptions): string {\r\n        switch (options.target) {\r\n            case ScriptTarget.ESNext:\r\n                return \"lib.esnext.full.d.ts\";\r\n            case ScriptTarget.ES2017:\r\n                return \"lib.es2017.full.d.ts\";\r\n            case ScriptTarget.ES2016:\r\n                return \"lib.es2016.full.d.ts\";\r\n            case ScriptTarget.ES2015:\r\n                return \"lib.es6.d.ts\";  // We don't use lib.es2015.full.d.ts due to breaking change.\r\n            default:\r\n                return \"lib.d.ts\";\r\n        }\r\n    }\r\n\r\n    export function textSpanEnd(span: TextSpan) {\r\n        return span.start + span.length;\r\n    }\r\n\r\n    export function textSpanIsEmpty(span: TextSpan) {\r\n        return span.length === 0;\r\n    }\r\n\r\n    export function textSpanContainsPosition(span: TextSpan, position: number) {\r\n        return position >= span.start && position < textSpanEnd(span);\r\n    }\r\n\r\n    // Returns true if 'span' contains 'other'.\r\n    export function textSpanContainsTextSpan(span: TextSpan, other: TextSpan) {\r\n        return other.start >= span.start && textSpanEnd(other) <= textSpanEnd(span);\r\n    }\r\n\r\n    export function textSpanOverlapsWith(span: TextSpan, other: TextSpan) {\r\n        return textSpanOverlap(span, other) !== undefined;\r\n    }\r\n\r\n    export function textSpanOverlap(span1: TextSpan, span2: TextSpan) {\r\n        const overlap = textSpanIntersection(span1, span2);\r\n        return overlap && overlap.length === 0 ? undefined : overlap;\r\n    }\r\n\r\n    export function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan) {\r\n        return decodedTextSpanIntersectsWith(span.start, span.length, other.start, other.length);\r\n    }\r\n\r\n    export function textSpanIntersectsWith(span: TextSpan, start: number, length: number) {\r\n        return decodedTextSpanIntersectsWith(span.start, span.length, start, length);\r\n    }\r\n\r\n    export function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number) {\r\n        const end1 = start1 + length1;\r\n        const end2 = start2 + length2;\r\n        return start2 <= end1 && end2 >= start1;\r\n    }\r\n\r\n    export function textSpanIntersectsWithPosition(span: TextSpan, position: number) {\r\n        return position <= textSpanEnd(span) && position >= span.start;\r\n    }\r\n\r\n    export function textSpanIntersection(span1: TextSpan, span2: TextSpan) {\r\n        const start = Math.max(span1.start, span2.start);\r\n        const end = Math.min(textSpanEnd(span1), textSpanEnd(span2));\r\n        return start <= end ? createTextSpanFromBounds(start, end) : undefined;\r\n    }\r\n\r\n    export function createTextSpan(start: number, length: number): TextSpan {\r\n        if (start < 0) {\r\n            throw new Error(\"start < 0\");\r\n        }\r\n        if (length < 0) {\r\n            throw new Error(\"length < 0\");\r\n        }\r\n\r\n        return { start, length };\r\n    }\r\n\r\n    /* @internal */\r\n    export function createTextRange(pos: number, end: number = pos): TextRange {\r\n        Debug.assert(end >= pos);\r\n        return { pos, end };\r\n    }\r\n\r\n    export function createTextSpanFromBounds(start: number, end: number) {\r\n        return createTextSpan(start, end - start);\r\n    }\r\n\r\n    export function textChangeRangeNewSpan(range: TextChangeRange) {\r\n        return createTextSpan(range.span.start, range.newLength);\r\n    }\r\n\r\n    export function textChangeRangeIsUnchanged(range: TextChangeRange) {\r\n        return textSpanIsEmpty(range.span) && range.newLength === 0;\r\n    }\r\n\r\n    export function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange {\r\n        if (newLength < 0) {\r\n            throw new Error(\"newLength < 0\");\r\n        }\r\n\r\n        return { span, newLength };\r\n    }\r\n\r\n    export let unchangedTextChangeRange = createTextChangeRange(createTextSpan(0, 0), 0);\r\n\r\n    /**\r\n     * Called to merge all the changes that occurred across several versions of a script snapshot\r\n     * into a single change.  i.e. if a user keeps making successive edits to a script we will\r\n     * have a text change from V1 to V2, V2 to V3, ..., Vn.\r\n     *\r\n     * This function will then merge those changes into a single change range valid between V1 and\r\n     * Vn.\r\n     */\r\n    export function collapseTextChangeRangesAcrossMultipleVersions(changes: ReadonlyArray<TextChangeRange>): TextChangeRange {\r\n        if (changes.length === 0) {\r\n            return unchangedTextChangeRange;\r\n        }\r\n\r\n        if (changes.length === 1) {\r\n            return changes[0];\r\n        }\r\n\r\n        // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }\r\n        // as it makes things much easier to reason about.\r\n        const change0 = changes[0];\r\n\r\n        let oldStartN = change0.span.start;\r\n        let oldEndN = textSpanEnd(change0.span);\r\n        let newEndN = oldStartN + change0.newLength;\r\n\r\n        for (let i = 1; i < changes.length; i++) {\r\n            const nextChange = changes[i];\r\n\r\n            // Consider the following case:\r\n            // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting\r\n            // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.\r\n            // i.e. the span starting at 30 with length 30 is increased to length 40.\r\n            //\r\n            //      0         10        20        30        40        50        60        70        80        90        100\r\n            //      -------------------------------------------------------------------------------------------------------\r\n            //                |                                                 /\r\n            //                |                                            /----\r\n            //  T1            |                                       /----\r\n            //                |                                  /----\r\n            //                |                             /----\r\n            //      -------------------------------------------------------------------------------------------------------\r\n            //                                     |                            \\\r\n            //                                     |                               \\\r\n            //   T2                                |                                 \\\r\n            //                                     |                                   \\\r\n            //                                     |                                      \\\r\n            //      -------------------------------------------------------------------------------------------------------\r\n            //\r\n            // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial\r\n            // it's just the min of the old and new starts.  i.e.:\r\n            //\r\n            //      0         10        20        30        40        50        60        70        80        90        100\r\n            //      ------------------------------------------------------------*------------------------------------------\r\n            //                |                                                 /\r\n            //                |                                            /----\r\n            //  T1            |                                       /----\r\n            //                |                                  /----\r\n            //                |                             /----\r\n            //      ----------------------------------------$-------------------$------------------------------------------\r\n            //                .                    |                            \\\r\n            //                .                    |                               \\\r\n            //   T2           .                    |                                 \\\r\n            //                .                    |                                   \\\r\n            //                .                    |                                      \\\r\n            //      ----------------------------------------------------------------------*--------------------------------\r\n            //\r\n            // (Note the dots represent the newly inferred start.\r\n            // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the\r\n            // absolute positions at the asterisks, and the relative change between the dollar signs. Basically, we see\r\n            // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that\r\n            // means:\r\n            //\r\n            //      0         10        20        30        40        50        60        70        80        90        100\r\n            //      --------------------------------------------------------------------------------*----------------------\r\n            //                |                                                                     /\r\n            //                |                                                                /----\r\n            //  T1            |                                                           /----\r\n            //                |                                                      /----\r\n            //                |                                                 /----\r\n            //      ------------------------------------------------------------$------------------------------------------\r\n            //                .                    |                            \\\r\n            //                .                    |                               \\\r\n            //   T2           .                    |                                 \\\r\n            //                .                    |                                   \\\r\n            //                .                    |                                      \\\r\n            //      ----------------------------------------------------------------------*--------------------------------\r\n            //\r\n            // In other words (in this case), we're recognizing that the second edit happened after where the first edit\r\n            // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started\r\n            // that's the same as if we started at char 80 instead of 60.\r\n            //\r\n            // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rather\r\n            // than pushing the first edit forward to match the second, we'll push the second edit forward to match the\r\n            // first.\r\n            //\r\n            // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange\r\n            // semantics: { { start: 10, length: 70 }, newLength: 60 }\r\n            //\r\n            // The math then works out as follows.\r\n            // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the\r\n            // final result like so:\r\n            //\r\n            // {\r\n            //      oldStart3: Min(oldStart1, oldStart2),\r\n            //      oldEnd3: Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),\r\n            //      newEnd3: Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))\r\n            // }\r\n\r\n            const oldStart1 = oldStartN;\r\n            const oldEnd1 = oldEndN;\r\n            const newEnd1 = newEndN;\r\n\r\n            const oldStart2 = nextChange.span.start;\r\n            const oldEnd2 = textSpanEnd(nextChange.span);\r\n            const newEnd2 = oldStart2 + nextChange.newLength;\r\n\r\n            oldStartN = Math.min(oldStart1, oldStart2);\r\n            oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));\r\n            newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));\r\n        }\r\n\r\n        return createTextChangeRange(createTextSpanFromBounds(oldStartN, oldEndN), /*newLength*/ newEndN - oldStartN);\r\n    }\r\n\r\n    export function getTypeParameterOwner(d: Declaration): Declaration {\r\n        if (d && d.kind === SyntaxKind.TypeParameter) {\r\n            for (let current: Node = d; current; current = current.parent) {\r\n                if (isFunctionLike(current) || isClassLike(current) || current.kind === SyntaxKind.InterfaceDeclaration) {\r\n                    return <Declaration>current;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export type ParameterPropertyDeclaration = ParameterDeclaration & { parent: ConstructorDeclaration, name: Identifier };\r\n    export function isParameterPropertyDeclaration(node: Node): node is ParameterPropertyDeclaration {\r\n        return hasModifier(node, ModifierFlags.ParameterPropertyModifier) && node.parent.kind === SyntaxKind.Constructor;\r\n    }\r\n\r\n    export function isEmptyBindingPattern(node: BindingName): node is BindingPattern {\r\n        if (isBindingPattern(node)) {\r\n            return every(node.elements, isEmptyBindingElement);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function isEmptyBindingElement(node: BindingElement): boolean {\r\n        if (isOmittedExpression(node)) {\r\n            return true;\r\n        }\r\n        return isEmptyBindingPattern(node.name);\r\n    }\r\n\r\n    function walkUpBindingElementsAndPatterns(node: Node): Node {\r\n        while (node && (node.kind === SyntaxKind.BindingElement || isBindingPattern(node))) {\r\n            node = node.parent;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    export function getCombinedModifierFlags(node: Node): ModifierFlags {\r\n        node = walkUpBindingElementsAndPatterns(node);\r\n        let flags = getModifierFlags(node);\r\n        if (node.kind === SyntaxKind.VariableDeclaration) {\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableDeclarationList) {\r\n            flags |= getModifierFlags(node);\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableStatement) {\r\n            flags |= getModifierFlags(node);\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    // Returns the node flags for this node and all relevant parent nodes.  This is done so that\r\n    // nodes like variable declarations and binding elements can returned a view of their flags\r\n    // that includes the modifiers from their container.  i.e. flags like export/declare aren't\r\n    // stored on the variable declaration directly, but on the containing variable statement\r\n    // (if it has one).  Similarly, flags for let/const are store on the variable declaration\r\n    // list.  By calling this function, all those flags are combined so that the client can treat\r\n    // the node as if it actually had those flags.\r\n    export function getCombinedNodeFlags(node: Node): NodeFlags {\r\n        node = walkUpBindingElementsAndPatterns(node);\r\n\r\n        let flags = node.flags;\r\n        if (node.kind === SyntaxKind.VariableDeclaration) {\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableDeclarationList) {\r\n            flags |= node.flags;\r\n            node = node.parent;\r\n        }\r\n\r\n        if (node && node.kind === SyntaxKind.VariableStatement) {\r\n            flags |= node.flags;\r\n        }\r\n\r\n        return flags;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the locale is in the appropriate format,\r\n     * and if it is, attempts to set the appropriate language.\r\n     */\r\n    export function validateLocaleAndSetLanguage(\r\n        locale: string,\r\n        sys: { getExecutingFilePath(): string, resolvePath(path: string): string, fileExists(fileName: string): boolean, readFile(fileName: string): string | undefined },\r\n        errors?: Push<Diagnostic>) {\r\n        const matchResult = /^([a-z]+)([_\\-]([a-z]+))?$/.exec(locale.toLowerCase());\r\n\r\n        if (!matchResult) {\r\n            if (errors) {\r\n                errors.push(createCompilerDiagnostic(Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, \"en\", \"ja-jp\"));\r\n            }\r\n            return;\r\n        }\r\n\r\n        const language = matchResult[1];\r\n        const territory = matchResult[3];\r\n\r\n        // First try the entire locale, then fall back to just language if that's all we have.\r\n        // Either ways do not fail, and fallback to the English diagnostic strings.\r\n        if (!trySetLanguageAndTerritory(language, territory, errors)) {\r\n            trySetLanguageAndTerritory(language, /*territory*/ undefined, errors);\r\n        }\r\n\r\n        // Set the UI locale for string collation\r\n        setUILocale(locale);\r\n\r\n        function trySetLanguageAndTerritory(language: string, territory: string, errors?: Push<Diagnostic>): boolean {\r\n            const compilerFilePath = normalizePath(sys.getExecutingFilePath());\r\n            const containingDirectoryPath = getDirectoryPath(compilerFilePath);\r\n\r\n            let filePath = combinePaths(containingDirectoryPath, language);\r\n\r\n            if (territory) {\r\n                filePath = filePath + \"-\" + territory;\r\n            }\r\n\r\n            filePath = sys.resolvePath(combinePaths(filePath, \"diagnosticMessages.generated.json\"));\r\n\r\n            if (!sys.fileExists(filePath)) {\r\n                return false;\r\n            }\r\n\r\n            // TODO: Add codePage support for readFile?\r\n            let fileContents = \"\";\r\n            try {\r\n                fileContents = sys.readFile(filePath);\r\n            }\r\n            catch (e) {\r\n                if (errors) {\r\n                    errors.push(createCompilerDiagnostic(Diagnostics.Unable_to_open_file_0, filePath));\r\n                }\r\n                return false;\r\n            }\r\n            try {\r\n                // tslint:disable-next-line no-unnecessary-qualifier (making clear this is a global mutation!)\r\n                ts.localizedDiagnosticMessages = JSON.parse(fileContents);\r\n            }\r\n            catch (e) {\r\n                if (errors) {\r\n                    errors.push(createCompilerDiagnostic(Diagnostics.Corrupted_locale_file_0, filePath));\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    export function getOriginalNode(node: Node): Node;\r\n    export function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;\r\n    export function getOriginalNode(node: Node, nodeTest?: (node: Node) => boolean): Node {\r\n        if (node) {\r\n            while (node.original !== undefined) {\r\n                node = node.original;\r\n            }\r\n        }\r\n\r\n        return !nodeTest || nodeTest(node) ? node : undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating whether a node originated in the parse tree.\r\n     *\r\n     * @param node The node to test.\r\n     */\r\n    export function isParseTreeNode(node: Node): boolean {\r\n        return (node.flags & NodeFlags.Synthesized) === 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the original parse tree node for a node.\r\n     *\r\n     * @param node The original node.\r\n     * @returns The original parse tree node if found; otherwise, undefined.\r\n     */\r\n    export function getParseTreeNode(node: Node): Node;\r\n\r\n    /**\r\n     * Gets the original parse tree node for a node.\r\n     *\r\n     * @param node The original node.\r\n     * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.\r\n     * @returns The original parse tree node if found; otherwise, undefined.\r\n     */\r\n    export function getParseTreeNode<T extends Node>(node: Node, nodeTest?: (node: Node) => node is T): T;\r\n    export function getParseTreeNode(node: Node, nodeTest?: (node: Node) => boolean): Node {\r\n        if (node === undefined || isParseTreeNode(node)) {\r\n            return node;\r\n        }\r\n\r\n        node = getOriginalNode(node);\r\n\r\n        if (isParseTreeNode(node) && (!nodeTest || nodeTest(node))) {\r\n            return node;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Remove extra underscore from escaped identifier text content.\r\n     *\r\n     * @param identifier The escaped identifier text.\r\n     * @returns The unescaped identifier text.\r\n     */\r\n    export function unescapeLeadingUnderscores(identifier: __String): string {\r\n        const id = identifier as string;\r\n        return id.length >= 3 && id.charCodeAt(0) === CharacterCodes._ && id.charCodeAt(1) === CharacterCodes._ && id.charCodeAt(2) === CharacterCodes._ ? id.substr(1) : id;\r\n    }\r\n\r\n    export function idText(identifier: Identifier): string {\r\n        return unescapeLeadingUnderscores(identifier.escapedText);\r\n    }\r\n    export function symbolName(symbol: Symbol): string {\r\n        return unescapeLeadingUnderscores(symbol.escapedName);\r\n    }\r\n\r\n    /**\r\n     * Remove extra underscore from escaped identifier text content.\r\n     * @deprecated Use `id.text` for the unescaped text.\r\n     * @param identifier The escaped identifier text.\r\n     * @returns The unescaped identifier text.\r\n     */\r\n    export function unescapeIdentifier(id: string): string {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * A JSDocTypedef tag has an _optional_ name field - if a name is not directly present, we should\r\n     * attempt to draw the name from the node the declaration is on (as that declaration is what its' symbol\r\n     * will be merged with)\r\n     */\r\n    function nameForNamelessJSDocTypedef(declaration: JSDocTypedefTag): Identifier | undefined {\r\n        const hostNode = declaration.parent.parent;\r\n        if (!hostNode) {\r\n            return undefined;\r\n        }\r\n        // Covers classes, functions - any named declaration host node\r\n        if (isDeclaration(hostNode)) {\r\n            return getDeclarationIdentifier(hostNode);\r\n        }\r\n        // Covers remaining cases\r\n        switch (hostNode.kind) {\r\n            case SyntaxKind.VariableStatement:\r\n                if (hostNode.declarationList && hostNode.declarationList.declarations[0]) {\r\n                    return getDeclarationIdentifier(hostNode.declarationList.declarations[0]);\r\n                }\r\n                return undefined;\r\n            case SyntaxKind.ExpressionStatement:\r\n                const expr = hostNode.expression;\r\n                switch (expr.kind) {\r\n                    case SyntaxKind.PropertyAccessExpression:\r\n                        return (expr as PropertyAccessExpression).name;\r\n                    case SyntaxKind.ElementAccessExpression:\r\n                        const arg = (expr as ElementAccessExpression).argumentExpression;\r\n                        if (isIdentifier(arg)) {\r\n                            return arg;\r\n                        }\r\n                }\r\n                return undefined;\r\n            case SyntaxKind.EndOfFileToken:\r\n                return undefined;\r\n            case SyntaxKind.ParenthesizedExpression: {\r\n                return getDeclarationIdentifier(hostNode.expression);\r\n            }\r\n            case SyntaxKind.LabeledStatement: {\r\n                if (isDeclaration(hostNode.statement) || isExpression(hostNode.statement)) {\r\n                    return getDeclarationIdentifier(hostNode.statement);\r\n                }\r\n                return undefined;\r\n            }\r\n            default:\r\n                Debug.assertNever(hostNode, \"Found typedef tag attached to node which it should not be!\");\r\n        }\r\n    }\r\n\r\n    function getDeclarationIdentifier(node: Declaration | Expression) {\r\n        const name = getNameOfDeclaration(node);\r\n        return isIdentifier(name) ? name : undefined;\r\n    }\r\n\r\n    export function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | undefined {\r\n        return declaration.name || nameForNamelessJSDocTypedef(declaration);\r\n    }\r\n\r\n    /** @internal */\r\n    export function isNamedDeclaration(node: Node): node is NamedDeclaration & { name: DeclarationName } {\r\n        return !!(node as NamedDeclaration).name; // A 'name' property should always be a DeclarationName.\r\n    }\r\n\r\n    export function getNameOfDeclaration(declaration: Declaration | Expression): DeclarationName | undefined {\r\n        if (!declaration) {\r\n            return undefined;\r\n        }\r\n        switch (declaration.kind) {\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n                if (!(declaration as ClassExpression | FunctionExpression).name) {\r\n                    return getAssignedName(declaration);\r\n                }\r\n                break;\r\n            case SyntaxKind.Identifier:\r\n                return declaration as Identifier;\r\n            case SyntaxKind.JSDocPropertyTag:\r\n            case SyntaxKind.JSDocParameterTag: {\r\n                const { name } = declaration as JSDocPropertyLikeTag;\r\n                if (name.kind === SyntaxKind.QualifiedName) {\r\n                    return name.right;\r\n                }\r\n                break;\r\n            }\r\n            case SyntaxKind.BinaryExpression: {\r\n                const expr = declaration as BinaryExpression;\r\n                switch (getSpecialPropertyAssignmentKind(expr)) {\r\n                    case SpecialPropertyAssignmentKind.ExportsProperty:\r\n                    case SpecialPropertyAssignmentKind.ThisProperty:\r\n                    case SpecialPropertyAssignmentKind.Property:\r\n                    case SpecialPropertyAssignmentKind.PrototypeProperty:\r\n                        return (expr.left as PropertyAccessExpression).name;\r\n                    default:\r\n                        return undefined;\r\n                }\r\n            }\r\n            case SyntaxKind.JSDocTypedefTag:\r\n                return getNameOfJSDocTypedef(declaration as JSDocTypedefTag);\r\n            case SyntaxKind.ExportAssignment: {\r\n                const { expression } = declaration as ExportAssignment;\r\n                return isIdentifier(expression) ? expression : undefined;\r\n            }\r\n        }\r\n        return (declaration as NamedDeclaration).name;\r\n    }\r\n\r\n    function getAssignedName(node: Node): DeclarationName {\r\n        if (!node.parent) {\r\n            return undefined;\r\n        }\r\n        else if (isPropertyAssignment(node.parent) || isBindingElement(node.parent)) {\r\n            return node.parent.name;\r\n        }\r\n        else if (isBinaryExpression(node.parent) && node === node.parent.right) {\r\n            if (isIdentifier(node.parent.left)) {\r\n                return node.parent.left;\r\n            }\r\n            else if (isPropertyAccessExpression(node.parent.left)) {\r\n                return node.parent.left.name;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the JSDoc parameter tags for the node if present.\r\n     *\r\n     * @remarks Returns any JSDoc param tag that matches the provided\r\n     * parameter, whether a param tag on a containing function\r\n     * expression, or a param tag on a variable declaration whose\r\n     * initializer is the containing function. The tags closest to the\r\n     * node are returned first, so in the previous example, the param\r\n     * tag on the containing function expression would be first.\r\n     *\r\n     * Does not return tags for binding patterns, because JSDoc matches\r\n     * parameters by name and binding patterns do not have a name.\r\n     */\r\n    export function getJSDocParameterTags(param: ParameterDeclaration): ReadonlyArray<JSDocParameterTag> {\r\n        if (param.name) {\r\n            if (isIdentifier(param.name)) {\r\n                const name = param.name.escapedText;\r\n                return getJSDocTags(param.parent).filter((tag): tag is JSDocParameterTag => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name);\r\n            }\r\n            else {\r\n                const i = param.parent.parameters.indexOf(param);\r\n                Debug.assert(i > -1, \"Parameters should always be in their parents' parameter list\");\r\n                const paramTags = getJSDocTags(param.parent).filter(isJSDocParameterTag);\r\n                if (i < paramTags.length) {\r\n                    return [paramTags[i]];\r\n                }\r\n            }\r\n        }\r\n        // return empty array for: out-of-order binding patterns and JSDoc function syntax, which has un-named parameters\r\n        return emptyArray;\r\n    }\r\n\r\n    /**\r\n     * Return true if the node has JSDoc parameter tags.\r\n     *\r\n     * @remarks Includes parameter tags that are not directly on the node,\r\n     * for example on a variable declaration whose initializer is a function expression.\r\n     */\r\n    export function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean {\r\n        return !!getFirstJSDocTag(node, isJSDocParameterTag);\r\n    }\r\n\r\n    /** Gets the JSDoc augments tag for the node if present */\r\n    export function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined {\r\n        return getFirstJSDocTag(node, isJSDocAugmentsTag);\r\n    }\r\n\r\n    /** Gets the JSDoc class tag for the node if present */\r\n    export function getJSDocClassTag(node: Node): JSDocClassTag | undefined {\r\n        return getFirstJSDocTag(node, isJSDocClassTag);\r\n    }\r\n\r\n    /** Gets the JSDoc return tag for the node if present */\r\n    export function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined {\r\n        return getFirstJSDocTag(node, isJSDocReturnTag);\r\n    }\r\n\r\n    /** Gets the JSDoc template tag for the node if present */\r\n    export function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined {\r\n        return getFirstJSDocTag(node, isJSDocTemplateTag);\r\n    }\r\n\r\n    /** Gets the JSDoc type tag for the node if present and valid */\r\n    export function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined {\r\n        // We should have already issued an error if there were multiple type jsdocs, so just use the first one.\r\n        const tag = getFirstJSDocTag(node, isJSDocTypeTag);\r\n        if (tag && tag.typeExpression && tag.typeExpression.type) {\r\n            return tag;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the type node for the node if provided via JSDoc.\r\n     *\r\n     * @remarks The search includes any JSDoc param tag that relates\r\n     * to the provided parameter, for example a type tag on the\r\n     * parameter itself, or a param tag on a containing function\r\n     * expression, or a param tag on a variable declaration whose\r\n     * initializer is the containing function. The tags closest to the\r\n     * node are examined first, so in the previous example, the type\r\n     * tag directly on the node would be returned.\r\n     */\r\n    export function getJSDocType(node: Node): TypeNode | undefined {\r\n        let tag: JSDocTypeTag | JSDocParameterTag | undefined = getFirstJSDocTag(node, isJSDocTypeTag);\r\n        if (!tag && isParameter(node)) {\r\n            tag = find(getJSDocParameterTags(node), tag => !!tag.typeExpression);\r\n        }\r\n\r\n        return tag && tag.typeExpression && tag.typeExpression.type;\r\n    }\r\n\r\n    /**\r\n     * Gets the return type node for the node if provided via JSDoc's return tag.\r\n     *\r\n     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function\r\n     * gets the type from inside the braces.\r\n     */\r\n    export function getJSDocReturnType(node: Node): TypeNode | undefined {\r\n        const returnTag = getJSDocReturnTag(node);\r\n        return returnTag && returnTag.typeExpression && returnTag.typeExpression.type;\r\n    }\r\n\r\n    /** Get all JSDoc tags related to a node, including those on parent nodes. */\r\n    export function getJSDocTags(node: Node): ReadonlyArray<JSDocTag> {\r\n        let tags = (node as JSDocContainer).jsDocCache;\r\n        // If cache is 'null', that means we did the work of searching for JSDoc tags and came up with nothing.\r\n        if (tags === undefined) {\r\n            (node as JSDocContainer).jsDocCache = tags = flatMap(getJSDocCommentsAndTags(node), j => isJSDoc(j) ? j.tags : j);\r\n        }\r\n        return tags;\r\n    }\r\n\r\n    /** Get the first JSDoc tag of a specified kind, or undefined if not present. */\r\n    function getFirstJSDocTag<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): T | undefined {\r\n        return find(getJSDocTags(node), predicate);\r\n    }\r\n\r\n    /** Gets all JSDoc tags of a specified kind, or undefined if not present. */\r\n    export function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): ReadonlyArray<JSDocTag> {\r\n        return getJSDocTags(node).filter(doc => doc.kind === kind);\r\n    }\r\n}\r\n\r\n// Simple node tests of the form `node.kind === SyntaxKind.Foo`.\r\nnamespace ts {\r\n    // Literals\r\n    export function isNumericLiteral(node: Node): node is NumericLiteral {\r\n        return node.kind === SyntaxKind.NumericLiteral;\r\n    }\r\n\r\n    export function isStringLiteral(node: Node): node is StringLiteral {\r\n        return node.kind === SyntaxKind.StringLiteral;\r\n    }\r\n\r\n    export function isJsxText(node: Node): node is JsxText {\r\n        return node.kind === SyntaxKind.JsxText;\r\n    }\r\n\r\n    export function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral {\r\n        return node.kind === SyntaxKind.RegularExpressionLiteral;\r\n    }\r\n\r\n    export function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral {\r\n        return node.kind === SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    }\r\n\r\n    // Pseudo-literals\r\n\r\n    export function isTemplateHead(node: Node): node is TemplateHead {\r\n        return node.kind === SyntaxKind.TemplateHead;\r\n    }\r\n\r\n    export function isTemplateMiddle(node: Node): node is TemplateMiddle {\r\n        return node.kind === SyntaxKind.TemplateMiddle;\r\n    }\r\n\r\n    export function isTemplateTail(node: Node): node is TemplateTail {\r\n        return node.kind === SyntaxKind.TemplateTail;\r\n    }\r\n\r\n    export function isIdentifier(node: Node): node is Identifier {\r\n        return node.kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    // Names\r\n\r\n    export function isQualifiedName(node: Node): node is QualifiedName {\r\n        return node.kind === SyntaxKind.QualifiedName;\r\n    }\r\n\r\n    export function isComputedPropertyName(node: Node): node is ComputedPropertyName {\r\n        return node.kind === SyntaxKind.ComputedPropertyName;\r\n    }\r\n\r\n    // Signature elements\r\n\r\n    export function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration {\r\n        return node.kind === SyntaxKind.TypeParameter;\r\n    }\r\n\r\n    export function isParameter(node: Node): node is ParameterDeclaration {\r\n        return node.kind === SyntaxKind.Parameter;\r\n    }\r\n\r\n    export function isDecorator(node: Node): node is Decorator {\r\n        return node.kind === SyntaxKind.Decorator;\r\n    }\r\n\r\n    // TypeMember\r\n\r\n    export function isPropertySignature(node: Node): node is PropertySignature {\r\n        return node.kind === SyntaxKind.PropertySignature;\r\n    }\r\n\r\n    export function isPropertyDeclaration(node: Node): node is PropertyDeclaration {\r\n        return node.kind === SyntaxKind.PropertyDeclaration;\r\n    }\r\n\r\n    export function isMethodSignature(node: Node): node is MethodSignature {\r\n        return node.kind === SyntaxKind.MethodSignature;\r\n    }\r\n\r\n    export function isMethodDeclaration(node: Node): node is MethodDeclaration {\r\n        return node.kind === SyntaxKind.MethodDeclaration;\r\n    }\r\n\r\n    export function isConstructorDeclaration(node: Node): node is ConstructorDeclaration {\r\n        return node.kind === SyntaxKind.Constructor;\r\n    }\r\n\r\n    export function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.GetAccessor;\r\n    }\r\n\r\n    export function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.SetAccessor;\r\n    }\r\n\r\n    export function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration {\r\n        return node.kind === SyntaxKind.CallSignature;\r\n    }\r\n\r\n    export function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration {\r\n        return node.kind === SyntaxKind.ConstructSignature;\r\n    }\r\n\r\n    export function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration {\r\n        return node.kind === SyntaxKind.IndexSignature;\r\n    }\r\n\r\n    // Type\r\n\r\n    export function isTypePredicateNode(node: Node): node is TypePredicateNode {\r\n        return node.kind === SyntaxKind.TypePredicate;\r\n    }\r\n\r\n    export function isTypeReferenceNode(node: Node): node is TypeReferenceNode {\r\n        return node.kind === SyntaxKind.TypeReference;\r\n    }\r\n\r\n    export function isFunctionTypeNode(node: Node): node is FunctionTypeNode {\r\n        return node.kind === SyntaxKind.FunctionType;\r\n    }\r\n\r\n    export function isConstructorTypeNode(node: Node): node is ConstructorTypeNode {\r\n        return node.kind === SyntaxKind.ConstructorType;\r\n    }\r\n\r\n    export function isTypeQueryNode(node: Node): node is TypeQueryNode {\r\n        return node.kind === SyntaxKind.TypeQuery;\r\n    }\r\n\r\n    export function isTypeLiteralNode(node: Node): node is TypeLiteralNode {\r\n        return node.kind === SyntaxKind.TypeLiteral;\r\n    }\r\n\r\n    export function isArrayTypeNode(node: Node): node is ArrayTypeNode {\r\n        return node.kind === SyntaxKind.ArrayType;\r\n    }\r\n\r\n    export function isTupleTypeNode(node: Node): node is TupleTypeNode {\r\n        return node.kind === SyntaxKind.TupleType;\r\n    }\r\n\r\n    export function isUnionTypeNode(node: Node): node is UnionTypeNode {\r\n        return node.kind === SyntaxKind.UnionType;\r\n    }\r\n\r\n    export function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode {\r\n        return node.kind === SyntaxKind.IntersectionType;\r\n    }\r\n\r\n    export function isConditionalTypeNode(node: Node): node is ConditionalTypeNode {\r\n        return node.kind === SyntaxKind.ConditionalType;\r\n    }\r\n\r\n    export function isInferTypeNode(node: Node): node is InferTypeNode {\r\n        return node.kind === SyntaxKind.InferType;\r\n    }\r\n\r\n    export function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode {\r\n        return node.kind === SyntaxKind.ParenthesizedType;\r\n    }\r\n\r\n    export function isThisTypeNode(node: Node): node is ThisTypeNode {\r\n        return node.kind === SyntaxKind.ThisType;\r\n    }\r\n\r\n    export function isTypeOperatorNode(node: Node): node is TypeOperatorNode {\r\n        return node.kind === SyntaxKind.TypeOperator;\r\n    }\r\n\r\n    export function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode {\r\n        return node.kind === SyntaxKind.IndexedAccessType;\r\n    }\r\n\r\n    export function isMappedTypeNode(node: Node): node is MappedTypeNode {\r\n        return node.kind === SyntaxKind.MappedType;\r\n    }\r\n\r\n    export function isLiteralTypeNode(node: Node): node is LiteralTypeNode {\r\n        return node.kind === SyntaxKind.LiteralType;\r\n    }\r\n\r\n    export function isImportTypeNode(node: Node): node is ImportTypeNode {\r\n        return node.kind === SyntaxKind.ImportType;\r\n    }\r\n\r\n    // Binding patterns\r\n\r\n    export function isObjectBindingPattern(node: Node): node is ObjectBindingPattern {\r\n        return node.kind === SyntaxKind.ObjectBindingPattern;\r\n    }\r\n\r\n    export function isArrayBindingPattern(node: Node): node is ArrayBindingPattern {\r\n        return node.kind === SyntaxKind.ArrayBindingPattern;\r\n    }\r\n\r\n    export function isBindingElement(node: Node): node is BindingElement {\r\n        return node.kind === SyntaxKind.BindingElement;\r\n    }\r\n\r\n    // Expression\r\n\r\n    export function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression {\r\n        return node.kind === SyntaxKind.ArrayLiteralExpression;\r\n    }\r\n\r\n    export function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression {\r\n        return node.kind === SyntaxKind.ObjectLiteralExpression;\r\n    }\r\n\r\n    export function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression {\r\n        return node.kind === SyntaxKind.PropertyAccessExpression;\r\n    }\r\n\r\n    export function isElementAccessExpression(node: Node): node is ElementAccessExpression {\r\n        return node.kind === SyntaxKind.ElementAccessExpression;\r\n    }\r\n\r\n    export function isCallExpression(node: Node): node is CallExpression {\r\n        return node.kind === SyntaxKind.CallExpression;\r\n    }\r\n\r\n    export function isNewExpression(node: Node): node is NewExpression {\r\n        return node.kind === SyntaxKind.NewExpression;\r\n    }\r\n\r\n    export function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression {\r\n        return node.kind === SyntaxKind.TaggedTemplateExpression;\r\n    }\r\n\r\n    export function isTypeAssertion(node: Node): node is TypeAssertion {\r\n        return node.kind === SyntaxKind.TypeAssertionExpression;\r\n    }\r\n\r\n    export function isParenthesizedExpression(node: Node): node is ParenthesizedExpression {\r\n        return node.kind === SyntaxKind.ParenthesizedExpression;\r\n    }\r\n\r\n    export function skipPartiallyEmittedExpressions(node: Expression): Expression;\r\n    export function skipPartiallyEmittedExpressions(node: Node): Node;\r\n    export function skipPartiallyEmittedExpressions(node: Node) {\r\n        while (node.kind === SyntaxKind.PartiallyEmittedExpression) {\r\n            node = (<PartiallyEmittedExpression>node).expression;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    export function isFunctionExpression(node: Node): node is FunctionExpression {\r\n        return node.kind === SyntaxKind.FunctionExpression;\r\n    }\r\n\r\n    export function isArrowFunction(node: Node): node is ArrowFunction {\r\n        return node.kind === SyntaxKind.ArrowFunction;\r\n    }\r\n\r\n    export function isDeleteExpression(node: Node): node is DeleteExpression {\r\n        return node.kind === SyntaxKind.DeleteExpression;\r\n    }\r\n\r\n    export function isTypeOfExpression(node: Node): node is TypeOfExpression {\r\n        return node.kind === SyntaxKind.TypeOfExpression;\r\n    }\r\n\r\n    export function isVoidExpression(node: Node): node is VoidExpression {\r\n        return node.kind === SyntaxKind.VoidExpression;\r\n    }\r\n\r\n    export function isAwaitExpression(node: Node): node is AwaitExpression {\r\n        return node.kind === SyntaxKind.AwaitExpression;\r\n    }\r\n\r\n    export function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression {\r\n        return node.kind === SyntaxKind.PrefixUnaryExpression;\r\n    }\r\n\r\n    export function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression {\r\n        return node.kind === SyntaxKind.PostfixUnaryExpression;\r\n    }\r\n\r\n    export function isBinaryExpression(node: Node): node is BinaryExpression {\r\n        return node.kind === SyntaxKind.BinaryExpression;\r\n    }\r\n\r\n    export function isConditionalExpression(node: Node): node is ConditionalExpression {\r\n        return node.kind === SyntaxKind.ConditionalExpression;\r\n    }\r\n\r\n    export function isTemplateExpression(node: Node): node is TemplateExpression {\r\n        return node.kind === SyntaxKind.TemplateExpression;\r\n    }\r\n\r\n    export function isYieldExpression(node: Node): node is YieldExpression {\r\n        return node.kind === SyntaxKind.YieldExpression;\r\n    }\r\n\r\n    export function isSpreadElement(node: Node): node is SpreadElement {\r\n        return node.kind === SyntaxKind.SpreadElement;\r\n    }\r\n\r\n    export function isClassExpression(node: Node): node is ClassExpression {\r\n        return node.kind === SyntaxKind.ClassExpression;\r\n    }\r\n\r\n    export function isOmittedExpression(node: Node): node is OmittedExpression {\r\n        return node.kind === SyntaxKind.OmittedExpression;\r\n    }\r\n\r\n    export function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments {\r\n        return node.kind === SyntaxKind.ExpressionWithTypeArguments;\r\n    }\r\n\r\n    export function isAsExpression(node: Node): node is AsExpression {\r\n        return node.kind === SyntaxKind.AsExpression;\r\n    }\r\n\r\n    export function isNonNullExpression(node: Node): node is NonNullExpression {\r\n        return node.kind === SyntaxKind.NonNullExpression;\r\n    }\r\n\r\n    export function isMetaProperty(node: Node): node is MetaProperty {\r\n        return node.kind === SyntaxKind.MetaProperty;\r\n    }\r\n\r\n    // Misc\r\n\r\n    export function isTemplateSpan(node: Node): node is TemplateSpan {\r\n        return node.kind === SyntaxKind.TemplateSpan;\r\n    }\r\n\r\n    export function isSemicolonClassElement(node: Node): node is SemicolonClassElement {\r\n        return node.kind === SyntaxKind.SemicolonClassElement;\r\n    }\r\n\r\n    // Block\r\n\r\n    export function isBlock(node: Node): node is Block {\r\n        return node.kind === SyntaxKind.Block;\r\n    }\r\n\r\n    export function isVariableStatement(node: Node): node is VariableStatement {\r\n        return node.kind === SyntaxKind.VariableStatement;\r\n    }\r\n\r\n    export function isEmptyStatement(node: Node): node is EmptyStatement {\r\n        return node.kind === SyntaxKind.EmptyStatement;\r\n    }\r\n\r\n    export function isExpressionStatement(node: Node): node is ExpressionStatement {\r\n        return node.kind === SyntaxKind.ExpressionStatement;\r\n    }\r\n\r\n    export function isIfStatement(node: Node): node is IfStatement {\r\n        return node.kind === SyntaxKind.IfStatement;\r\n    }\r\n\r\n    export function isDoStatement(node: Node): node is DoStatement {\r\n        return node.kind === SyntaxKind.DoStatement;\r\n    }\r\n\r\n    export function isWhileStatement(node: Node): node is WhileStatement {\r\n        return node.kind === SyntaxKind.WhileStatement;\r\n    }\r\n\r\n    export function isForStatement(node: Node): node is ForStatement {\r\n        return node.kind === SyntaxKind.ForStatement;\r\n    }\r\n\r\n    export function isForInStatement(node: Node): node is ForInStatement {\r\n        return node.kind === SyntaxKind.ForInStatement;\r\n    }\r\n\r\n    export function isForOfStatement(node: Node): node is ForOfStatement {\r\n        return node.kind === SyntaxKind.ForOfStatement;\r\n    }\r\n\r\n    export function isContinueStatement(node: Node): node is ContinueStatement {\r\n        return node.kind === SyntaxKind.ContinueStatement;\r\n    }\r\n\r\n    export function isBreakStatement(node: Node): node is BreakStatement {\r\n        return node.kind === SyntaxKind.BreakStatement;\r\n    }\r\n\r\n    export function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement {\r\n        return node.kind === SyntaxKind.BreakStatement || node.kind === SyntaxKind.ContinueStatement;\r\n    }\r\n\r\n    export function isReturnStatement(node: Node): node is ReturnStatement {\r\n        return node.kind === SyntaxKind.ReturnStatement;\r\n    }\r\n\r\n    export function isWithStatement(node: Node): node is WithStatement {\r\n        return node.kind === SyntaxKind.WithStatement;\r\n    }\r\n\r\n    export function isSwitchStatement(node: Node): node is SwitchStatement {\r\n        return node.kind === SyntaxKind.SwitchStatement;\r\n    }\r\n\r\n    export function isLabeledStatement(node: Node): node is LabeledStatement {\r\n        return node.kind === SyntaxKind.LabeledStatement;\r\n    }\r\n\r\n    export function isThrowStatement(node: Node): node is ThrowStatement {\r\n        return node.kind === SyntaxKind.ThrowStatement;\r\n    }\r\n\r\n    export function isTryStatement(node: Node): node is TryStatement {\r\n        return node.kind === SyntaxKind.TryStatement;\r\n    }\r\n\r\n    export function isDebuggerStatement(node: Node): node is DebuggerStatement {\r\n        return node.kind === SyntaxKind.DebuggerStatement;\r\n    }\r\n\r\n    export function isVariableDeclaration(node: Node): node is VariableDeclaration {\r\n        return node.kind === SyntaxKind.VariableDeclaration;\r\n    }\r\n\r\n    export function isVariableDeclarationList(node: Node): node is VariableDeclarationList {\r\n        return node.kind === SyntaxKind.VariableDeclarationList;\r\n    }\r\n\r\n    export function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\r\n        return node.kind === SyntaxKind.FunctionDeclaration;\r\n    }\r\n\r\n    export function isClassDeclaration(node: Node): node is ClassDeclaration {\r\n        return node.kind === SyntaxKind.ClassDeclaration;\r\n    }\r\n\r\n    export function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration {\r\n        return node.kind === SyntaxKind.InterfaceDeclaration;\r\n    }\r\n\r\n    export function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration {\r\n        return node.kind === SyntaxKind.TypeAliasDeclaration;\r\n    }\r\n\r\n    export function isEnumDeclaration(node: Node): node is EnumDeclaration {\r\n        return node.kind === SyntaxKind.EnumDeclaration;\r\n    }\r\n\r\n    export function isModuleDeclaration(node: Node): node is ModuleDeclaration {\r\n        return node.kind === SyntaxKind.ModuleDeclaration;\r\n    }\r\n\r\n    export function isModuleBlock(node: Node): node is ModuleBlock {\r\n        return node.kind === SyntaxKind.ModuleBlock;\r\n    }\r\n\r\n    export function isCaseBlock(node: Node): node is CaseBlock {\r\n        return node.kind === SyntaxKind.CaseBlock;\r\n    }\r\n\r\n    export function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration {\r\n        return node.kind === SyntaxKind.NamespaceExportDeclaration;\r\n    }\r\n\r\n    export function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration {\r\n        return node.kind === SyntaxKind.ImportEqualsDeclaration;\r\n    }\r\n\r\n    export function isImportDeclaration(node: Node): node is ImportDeclaration {\r\n        return node.kind === SyntaxKind.ImportDeclaration;\r\n    }\r\n\r\n    export function isImportClause(node: Node): node is ImportClause {\r\n        return node.kind === SyntaxKind.ImportClause;\r\n    }\r\n\r\n    export function isNamespaceImport(node: Node): node is NamespaceImport {\r\n        return node.kind === SyntaxKind.NamespaceImport;\r\n    }\r\n\r\n    export function isNamedImports(node: Node): node is NamedImports {\r\n        return node.kind === SyntaxKind.NamedImports;\r\n    }\r\n\r\n    export function isImportSpecifier(node: Node): node is ImportSpecifier {\r\n        return node.kind === SyntaxKind.ImportSpecifier;\r\n    }\r\n\r\n    export function isExportAssignment(node: Node): node is ExportAssignment {\r\n        return node.kind === SyntaxKind.ExportAssignment;\r\n    }\r\n\r\n    export function isExportDeclaration(node: Node): node is ExportDeclaration {\r\n        return node.kind === SyntaxKind.ExportDeclaration;\r\n    }\r\n\r\n    export function isNamedExports(node: Node): node is NamedExports {\r\n        return node.kind === SyntaxKind.NamedExports;\r\n    }\r\n\r\n    export function isExportSpecifier(node: Node): node is ExportSpecifier {\r\n        return node.kind === SyntaxKind.ExportSpecifier;\r\n    }\r\n\r\n    export function isMissingDeclaration(node: Node): node is MissingDeclaration {\r\n        return node.kind === SyntaxKind.MissingDeclaration;\r\n    }\r\n\r\n    // Module References\r\n\r\n    export function isExternalModuleReference(node: Node): node is ExternalModuleReference {\r\n        return node.kind === SyntaxKind.ExternalModuleReference;\r\n    }\r\n\r\n    // JSX\r\n\r\n    export function isJsxElement(node: Node): node is JsxElement {\r\n        return node.kind === SyntaxKind.JsxElement;\r\n    }\r\n\r\n    export function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement {\r\n        return node.kind === SyntaxKind.JsxSelfClosingElement;\r\n    }\r\n\r\n    export function isJsxOpeningElement(node: Node): node is JsxOpeningElement {\r\n        return node.kind === SyntaxKind.JsxOpeningElement;\r\n    }\r\n\r\n    export function isJsxClosingElement(node: Node): node is JsxClosingElement {\r\n        return node.kind === SyntaxKind.JsxClosingElement;\r\n    }\r\n\r\n    export function isJsxFragment(node: Node): node is JsxFragment {\r\n        return node.kind === SyntaxKind.JsxFragment;\r\n    }\r\n\r\n    export function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment {\r\n        return node.kind === SyntaxKind.JsxOpeningFragment;\r\n    }\r\n\r\n    export function isJsxClosingFragment(node: Node): node is JsxClosingFragment {\r\n        return node.kind === SyntaxKind.JsxClosingFragment;\r\n    }\r\n\r\n    export function isJsxAttribute(node: Node): node is JsxAttribute {\r\n        return node.kind === SyntaxKind.JsxAttribute;\r\n    }\r\n\r\n    export function isJsxAttributes(node: Node): node is JsxAttributes {\r\n        return node.kind === SyntaxKind.JsxAttributes;\r\n    }\r\n\r\n    export function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute {\r\n        return node.kind === SyntaxKind.JsxSpreadAttribute;\r\n    }\r\n\r\n    export function isJsxExpression(node: Node): node is JsxExpression {\r\n        return node.kind === SyntaxKind.JsxExpression;\r\n    }\r\n\r\n    // Clauses\r\n\r\n    export function isCaseClause(node: Node): node is CaseClause {\r\n        return node.kind === SyntaxKind.CaseClause;\r\n    }\r\n\r\n    export function isDefaultClause(node: Node): node is DefaultClause {\r\n        return node.kind === SyntaxKind.DefaultClause;\r\n    }\r\n\r\n    export function isHeritageClause(node: Node): node is HeritageClause {\r\n        return node.kind === SyntaxKind.HeritageClause;\r\n    }\r\n\r\n    export function isCatchClause(node: Node): node is CatchClause {\r\n        return node.kind === SyntaxKind.CatchClause;\r\n    }\r\n\r\n    // Property assignments\r\n\r\n    export function isPropertyAssignment(node: Node): node is PropertyAssignment {\r\n        return node.kind === SyntaxKind.PropertyAssignment;\r\n    }\r\n\r\n    export function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment {\r\n        return node.kind === SyntaxKind.ShorthandPropertyAssignment;\r\n    }\r\n\r\n    export function isSpreadAssignment(node: Node): node is SpreadAssignment {\r\n        return node.kind === SyntaxKind.SpreadAssignment;\r\n    }\r\n\r\n    // Enum\r\n\r\n    export function isEnumMember(node: Node): node is EnumMember {\r\n        return node.kind === SyntaxKind.EnumMember;\r\n    }\r\n\r\n    // Top-level nodes\r\n    export function isSourceFile(node: Node): node is SourceFile {\r\n        return node.kind === SyntaxKind.SourceFile;\r\n    }\r\n\r\n    export function isBundle(node: Node): node is Bundle {\r\n        return node.kind === SyntaxKind.Bundle;\r\n    }\r\n\r\n    // JSDoc\r\n\r\n    export function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression {\r\n        return node.kind === SyntaxKind.JSDocTypeExpression;\r\n    }\r\n\r\n    export function isJSDocAllType(node: JSDocAllType): node is JSDocAllType {\r\n        return node.kind === SyntaxKind.JSDocAllType;\r\n    }\r\n\r\n    export function isJSDocUnknownType(node: Node): node is JSDocUnknownType {\r\n        return node.kind === SyntaxKind.JSDocUnknownType;\r\n    }\r\n\r\n    export function isJSDocNullableType(node: Node): node is JSDocNullableType {\r\n        return node.kind === SyntaxKind.JSDocNullableType;\r\n    }\r\n\r\n    export function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType {\r\n        return node.kind === SyntaxKind.JSDocNonNullableType;\r\n    }\r\n\r\n    export function isJSDocOptionalType(node: Node): node is JSDocOptionalType {\r\n        return node.kind === SyntaxKind.JSDocOptionalType;\r\n    }\r\n\r\n    export function isJSDocFunctionType(node: Node): node is JSDocFunctionType {\r\n        return node.kind === SyntaxKind.JSDocFunctionType;\r\n    }\r\n\r\n    export function isJSDocVariadicType(node: Node): node is JSDocVariadicType {\r\n        return node.kind === SyntaxKind.JSDocVariadicType;\r\n    }\r\n\r\n    export function isJSDoc(node: Node): node is JSDoc {\r\n        return node.kind === SyntaxKind.JSDocComment;\r\n    }\r\n\r\n    export function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag {\r\n        return node.kind === SyntaxKind.JSDocAugmentsTag;\r\n    }\r\n\r\n    export function isJSDocClassTag(node: Node): node is JSDocClassTag {\r\n        return node.kind === SyntaxKind.JSDocClassTag;\r\n    }\r\n\r\n    export function isJSDocParameterTag(node: Node): node is JSDocParameterTag {\r\n        return node.kind === SyntaxKind.JSDocParameterTag;\r\n    }\r\n\r\n    export function isJSDocReturnTag(node: Node): node is JSDocReturnTag {\r\n        return node.kind === SyntaxKind.JSDocReturnTag;\r\n    }\r\n\r\n    export function isJSDocTypeTag(node: Node): node is JSDocTypeTag {\r\n        return node.kind === SyntaxKind.JSDocTypeTag;\r\n    }\r\n\r\n    export function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag {\r\n        return node.kind === SyntaxKind.JSDocTemplateTag;\r\n    }\r\n\r\n    export function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag {\r\n        return node.kind === SyntaxKind.JSDocTypedefTag;\r\n    }\r\n\r\n    export function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag {\r\n        return node.kind === SyntaxKind.JSDocPropertyTag;\r\n    }\r\n\r\n    export function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag {\r\n        return node.kind === SyntaxKind.JSDocPropertyTag || node.kind === SyntaxKind.JSDocParameterTag;\r\n    }\r\n\r\n    export function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral {\r\n        return node.kind === SyntaxKind.JSDocTypeLiteral;\r\n    }\r\n}\r\n\r\n// Node tests\r\n//\r\n// All node tests in the following list should *not* reference parent pointers so that\r\n// they may be used with transformations.\r\nnamespace ts {\r\n    /* @internal */\r\n    export function isSyntaxList(n: Node): n is SyntaxList {\r\n        return n.kind === SyntaxKind.SyntaxList;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNode(node: Node) {\r\n        return isNodeKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNodeKind(kind: SyntaxKind) {\r\n        return kind >= SyntaxKind.FirstNode;\r\n    }\r\n\r\n    /**\r\n     * True if node is of some token syntax kind.\r\n     * For example, this is true for an IfKeyword but not for an IfStatement.\r\n     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.\r\n     */\r\n    export function isToken(n: Node): boolean {\r\n        return n.kind >= SyntaxKind.FirstToken && n.kind <= SyntaxKind.LastToken;\r\n    }\r\n\r\n    // Node Arrays\r\n\r\n    /* @internal */\r\n    export function isNodeArray<T extends Node>(array: ReadonlyArray<T>): array is NodeArray<T> {\r\n        return array.hasOwnProperty(\"pos\") && array.hasOwnProperty(\"end\");\r\n    }\r\n\r\n    // Literals\r\n\r\n    /* @internal */\r\n    export function isLiteralKind(kind: SyntaxKind): boolean {\r\n        return SyntaxKind.FirstLiteralToken <= kind && kind <= SyntaxKind.LastLiteralToken;\r\n    }\r\n\r\n    export function isLiteralExpression(node: Node): node is LiteralExpression {\r\n        return isLiteralKind(node.kind);\r\n    }\r\n\r\n    // Pseudo-literals\r\n\r\n    /* @internal */\r\n    export function isTemplateLiteralKind(kind: SyntaxKind): boolean {\r\n        return SyntaxKind.FirstTemplateToken <= kind && kind <= SyntaxKind.LastTemplateToken;\r\n    }\r\n\r\n    export function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.TemplateMiddle\r\n            || kind === SyntaxKind.TemplateTail;\r\n    }\r\n\r\n    export function isStringTextContainingNode(node: Node) {\r\n        return node.kind === SyntaxKind.StringLiteral || isTemplateLiteralKind(node.kind);\r\n    }\r\n\r\n    // Identifiers\r\n\r\n    /* @internal */\r\n    export function isGeneratedIdentifier(node: Node): node is GeneratedIdentifier {\r\n        // Using `>` here catches both `GeneratedIdentifierKind.None` and `undefined`.\r\n        return isIdentifier(node) && (node.autoGenerateFlags & GeneratedIdentifierFlags.KindMask) > GeneratedIdentifierFlags.None;\r\n    }\r\n\r\n    // Keywords\r\n\r\n    /* @internal */\r\n    export function isModifierKind(token: SyntaxKind): boolean {\r\n        switch (token) {\r\n            case SyntaxKind.AbstractKeyword:\r\n            case SyntaxKind.AsyncKeyword:\r\n            case SyntaxKind.ConstKeyword:\r\n            case SyntaxKind.DeclareKeyword:\r\n            case SyntaxKind.DefaultKeyword:\r\n            case SyntaxKind.ExportKeyword:\r\n            case SyntaxKind.PublicKeyword:\r\n            case SyntaxKind.PrivateKeyword:\r\n            case SyntaxKind.ProtectedKeyword:\r\n            case SyntaxKind.ReadonlyKeyword:\r\n            case SyntaxKind.StaticKeyword:\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isParameterPropertyModifier(kind: SyntaxKind): boolean {\r\n        return !!(modifierToFlag(kind) & ModifierFlags.ParameterPropertyModifier);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isClassMemberModifier(idToken: SyntaxKind): boolean {\r\n        return isParameterPropertyModifier(idToken) || idToken === SyntaxKind.StaticKeyword;\r\n    }\r\n\r\n    export function isModifier(node: Node): node is Modifier {\r\n        return isModifierKind(node.kind);\r\n    }\r\n\r\n    export function isEntityName(node: Node): node is EntityName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.QualifiedName\r\n            || kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    export function isPropertyName(node: Node): node is PropertyName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.StringLiteral\r\n            || kind === SyntaxKind.NumericLiteral\r\n            || kind === SyntaxKind.ComputedPropertyName;\r\n    }\r\n\r\n    export function isBindingName(node: Node): node is BindingName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.ObjectBindingPattern\r\n            || kind === SyntaxKind.ArrayBindingPattern;\r\n    }\r\n\r\n    // Functions\r\n\r\n    export function isFunctionLike(node: Node): node is SignatureDeclaration {\r\n        return node && isFunctionLikeKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionLikeDeclaration(node: Node): node is FunctionLikeDeclaration {\r\n        return node && isFunctionLikeDeclarationKind(node.kind);\r\n    }\r\n\r\n    function isFunctionLikeDeclarationKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionLikeKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.IndexSignature:\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.JSDocFunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n                return true;\r\n            default:\r\n                return isFunctionLikeDeclarationKind(kind);\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionOrModuleBlock(node: Node): boolean {\r\n        return isSourceFile(node) || isModuleBlock(node) || isBlock(node) && isFunctionLike(node.parent);\r\n    }\r\n\r\n    // Classes\r\n    export function isClassElement(node: Node): node is ClassElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Constructor\r\n            || kind === SyntaxKind.PropertyDeclaration\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.SetAccessor\r\n            || kind === SyntaxKind.IndexSignature\r\n            || kind === SyntaxKind.SemicolonClassElement;\r\n    }\r\n\r\n    export function isClassLike(node: Node): node is ClassLikeDeclaration {\r\n        return node && (node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression);\r\n    }\r\n\r\n    export function isAccessor(node: Node): node is AccessorDeclaration {\r\n        return node && (node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isMethodOrAccessor(node: Node): node is MethodDeclaration | AccessorDeclaration {\r\n        switch (node.kind) {\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    // Type members\r\n\r\n    export function isTypeElement(node: Node): node is TypeElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ConstructSignature\r\n            || kind === SyntaxKind.CallSignature\r\n            || kind === SyntaxKind.PropertySignature\r\n            || kind === SyntaxKind.MethodSignature\r\n            || kind === SyntaxKind.IndexSignature;\r\n    }\r\n\r\n    export function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement {\r\n        return isTypeElement(node) || isClassElement(node);\r\n    }\r\n\r\n    export function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.PropertyAssignment\r\n            || kind === SyntaxKind.ShorthandPropertyAssignment\r\n            || kind === SyntaxKind.SpreadAssignment\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.SetAccessor;\r\n    }\r\n\r\n    // Type\r\n\r\n    function isTypeNodeKind(kind: SyntaxKind) {\r\n        return (kind >= SyntaxKind.FirstTypeNode && kind <= SyntaxKind.LastTypeNode)\r\n            || kind === SyntaxKind.AnyKeyword\r\n            || kind === SyntaxKind.NumberKeyword\r\n            || kind === SyntaxKind.ObjectKeyword\r\n            || kind === SyntaxKind.BooleanKeyword\r\n            || kind === SyntaxKind.StringKeyword\r\n            || kind === SyntaxKind.SymbolKeyword\r\n            || kind === SyntaxKind.ThisKeyword\r\n            || kind === SyntaxKind.VoidKeyword\r\n            || kind === SyntaxKind.UndefinedKeyword\r\n            || kind === SyntaxKind.NullKeyword\r\n            || kind === SyntaxKind.NeverKeyword\r\n            || kind === SyntaxKind.ExpressionWithTypeArguments\r\n            || kind === SyntaxKind.JSDocAllType\r\n            || kind === SyntaxKind.JSDocUnknownType\r\n            || kind === SyntaxKind.JSDocNullableType\r\n            || kind === SyntaxKind.JSDocNonNullableType\r\n            || kind === SyntaxKind.JSDocOptionalType\r\n            || kind === SyntaxKind.JSDocFunctionType\r\n            || kind === SyntaxKind.JSDocVariadicType;\r\n    }\r\n\r\n    /**\r\n     * Node test that determines whether a node is a valid type node.\r\n     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*\r\n     * of a TypeNode.\r\n     */\r\n    export function isTypeNode(node: Node): node is TypeNode {\r\n        return isTypeNodeKind(node.kind);\r\n    }\r\n\r\n    export function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode {\r\n        switch (node.kind) {\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Binding patterns\r\n\r\n    /* @internal */\r\n    export function isBindingPattern(node: Node): node is BindingPattern {\r\n        if (node) {\r\n            const kind = node.kind;\r\n            return kind === SyntaxKind.ArrayBindingPattern\r\n                || kind === SyntaxKind.ObjectBindingPattern;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isAssignmentPattern(node: Node): node is AssignmentPattern {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ArrayLiteralExpression\r\n            || kind === SyntaxKind.ObjectLiteralExpression;\r\n    }\r\n\r\n\r\n    /* @internal */\r\n    export function isArrayBindingElement(node: Node): node is ArrayBindingElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.BindingElement\r\n            || kind === SyntaxKind.OmittedExpression;\r\n    }\r\n\r\n\r\n    /**\r\n     * Determines whether the BindingOrAssignmentElement is a BindingElement-like declaration\r\n     */\r\n    /* @internal */\r\n    export function isDeclarationBindingElement(bindingElement: BindingOrAssignmentElement): bindingElement is VariableDeclaration | ParameterDeclaration | BindingElement {\r\n        switch (bindingElement.kind) {\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.Parameter:\r\n            case SyntaxKind.BindingElement:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is a BindingOrAssignmentPattern\r\n     */\r\n    /* @internal */\r\n    export function isBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is BindingOrAssignmentPattern {\r\n        return isObjectBindingOrAssignmentPattern(node)\r\n            || isArrayBindingOrAssignmentPattern(node);\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is an ObjectBindingOrAssignmentPattern\r\n     */\r\n    /* @internal */\r\n    export function isObjectBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ObjectBindingOrAssignmentPattern {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ObjectBindingPattern:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a node is an ArrayBindingOrAssignmentPattern\r\n     */\r\n    /* @internal */\r\n    export function isArrayBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ArrayBindingOrAssignmentPattern {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ArrayBindingPattern:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isPropertyAccessOrQualifiedNameOrImportTypeNode(node: Node): node is PropertyAccessExpression | QualifiedName | ImportTypeNode {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.PropertyAccessExpression\r\n            || kind === SyntaxKind.QualifiedName\r\n            || kind === SyntaxKind.ImportType;\r\n    }\r\n\r\n    // Expression\r\n\r\n    export function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.PropertyAccessExpression\r\n            || kind === SyntaxKind.QualifiedName;\r\n    }\r\n\r\n    export function isCallLikeExpression(node: Node): node is CallLikeExpression {\r\n        switch (node.kind) {\r\n            case SyntaxKind.JsxOpeningElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.NewExpression:\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.Decorator:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    export function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression {\r\n        return node.kind === SyntaxKind.CallExpression || node.kind === SyntaxKind.NewExpression;\r\n    }\r\n\r\n    export function isTemplateLiteral(node: Node): node is TemplateLiteral {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.TemplateExpression\r\n            || kind === SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isLeftHandSideExpression(node: Node): node is LeftHandSideExpression {\r\n        return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind);\r\n    }\r\n\r\n    function isLeftHandSideExpressionKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.PropertyAccessExpression:\r\n            case SyntaxKind.ElementAccessExpression:\r\n            case SyntaxKind.NewExpression:\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.JsxElement:\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.JsxFragment:\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n            case SyntaxKind.ParenthesizedExpression:\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n            case SyntaxKind.ClassExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.Identifier:\r\n            case SyntaxKind.RegularExpressionLiteral:\r\n            case SyntaxKind.NumericLiteral:\r\n            case SyntaxKind.StringLiteral:\r\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case SyntaxKind.TemplateExpression:\r\n            case SyntaxKind.FalseKeyword:\r\n            case SyntaxKind.NullKeyword:\r\n            case SyntaxKind.ThisKeyword:\r\n            case SyntaxKind.TrueKeyword:\r\n            case SyntaxKind.SuperKeyword:\r\n            case SyntaxKind.NonNullExpression:\r\n            case SyntaxKind.MetaProperty:\r\n            case SyntaxKind.ImportKeyword: // technically this is only an Expression if it's in a CallExpression\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isUnaryExpression(node: Node): node is UnaryExpression {\r\n        return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind);\r\n    }\r\n\r\n    function isUnaryExpressionKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n            case SyntaxKind.DeleteExpression:\r\n            case SyntaxKind.TypeOfExpression:\r\n            case SyntaxKind.VoidExpression:\r\n            case SyntaxKind.AwaitExpression:\r\n            case SyntaxKind.TypeAssertionExpression:\r\n                return true;\r\n            default:\r\n                return isLeftHandSideExpressionKind(kind);\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isUnaryExpressionWithWrite(expr: Node): expr is PrefixUnaryExpression | PostfixUnaryExpression {\r\n        switch (expr.kind) {\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n                return true;\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n                return (<PrefixUnaryExpression>expr).operator === SyntaxKind.PlusPlusToken ||\r\n                    (<PrefixUnaryExpression>expr).operator === SyntaxKind.MinusMinusToken;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    /**\r\n     * Determines whether a node is an expression based only on its kind.\r\n     * Use `isExpressionNode` if not in transforms.\r\n     */\r\n    export function isExpression(node: Node): node is Expression {\r\n        return isExpressionKind(skipPartiallyEmittedExpressions(node).kind);\r\n    }\r\n\r\n    function isExpressionKind(kind: SyntaxKind): boolean {\r\n        switch (kind) {\r\n            case SyntaxKind.ConditionalExpression:\r\n            case SyntaxKind.YieldExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.BinaryExpression:\r\n            case SyntaxKind.SpreadElement:\r\n            case SyntaxKind.AsExpression:\r\n            case SyntaxKind.OmittedExpression:\r\n            case SyntaxKind.CommaListExpression:\r\n            case SyntaxKind.PartiallyEmittedExpression:\r\n                return true;\r\n            default:\r\n                return isUnaryExpressionKind(kind);\r\n        }\r\n    }\r\n\r\n    export function isAssertionExpression(node: Node): node is AssertionExpression {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.TypeAssertionExpression\r\n            || kind === SyntaxKind.AsExpression;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression {\r\n        return node.kind === SyntaxKind.PartiallyEmittedExpression;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNotEmittedStatement(node: Node): node is NotEmittedStatement {\r\n        return node.kind === SyntaxKind.NotEmittedStatement;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNotEmittedOrPartiallyEmittedNode(node: Node): node is NotEmittedStatement | PartiallyEmittedExpression {\r\n        return isNotEmittedStatement(node)\r\n            || isPartiallyEmittedExpression(node);\r\n    }\r\n\r\n    // Statement\r\n\r\n    export function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;\r\n    export function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;\r\n    export function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement {\r\n        switch (node.kind) {\r\n            case SyntaxKind.ForStatement:\r\n            case SyntaxKind.ForInStatement:\r\n            case SyntaxKind.ForOfStatement:\r\n            case SyntaxKind.DoStatement:\r\n            case SyntaxKind.WhileStatement:\r\n                return true;\r\n            case SyntaxKind.LabeledStatement:\r\n                return lookInLabeledStatements && isIterationStatement((<LabeledStatement>node).statement, lookInLabeledStatements);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isForInOrOfStatement(node: Node): node is ForInOrOfStatement {\r\n        return node.kind === SyntaxKind.ForInStatement || node.kind === SyntaxKind.ForOfStatement;\r\n    }\r\n\r\n    // Element\r\n\r\n    /* @internal */\r\n    export function isConciseBody(node: Node): node is ConciseBody {\r\n        return isBlock(node)\r\n            || isExpression(node);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isFunctionBody(node: Node): node is FunctionBody {\r\n        return isBlock(node);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isForInitializer(node: Node): node is ForInitializer {\r\n        return isVariableDeclarationList(node)\r\n            || isExpression(node);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isModuleBody(node: Node): node is ModuleBody {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ModuleBlock\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNamespaceBody(node: Node): node is NamespaceBody {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ModuleBlock\r\n            || kind === SyntaxKind.ModuleDeclaration;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isJSDocNamespaceBody(node: Node): node is JSDocNamespaceBody {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.ModuleDeclaration;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isNamedImportBindings(node: Node): node is NamedImportBindings {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.NamedImports\r\n            || kind === SyntaxKind.NamespaceImport;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isModuleOrEnumDeclaration(node: Node): node is ModuleDeclaration | EnumDeclaration {\r\n        return node.kind === SyntaxKind.ModuleDeclaration || node.kind === SyntaxKind.EnumDeclaration;\r\n    }\r\n\r\n    function isDeclarationKind(kind: SyntaxKind) {\r\n        return kind === SyntaxKind.ArrowFunction\r\n            || kind === SyntaxKind.BindingElement\r\n            || kind === SyntaxKind.ClassDeclaration\r\n            || kind === SyntaxKind.ClassExpression\r\n            || kind === SyntaxKind.Constructor\r\n            || kind === SyntaxKind.EnumDeclaration\r\n            || kind === SyntaxKind.EnumMember\r\n            || kind === SyntaxKind.ExportSpecifier\r\n            || kind === SyntaxKind.FunctionDeclaration\r\n            || kind === SyntaxKind.FunctionExpression\r\n            || kind === SyntaxKind.GetAccessor\r\n            || kind === SyntaxKind.ImportClause\r\n            || kind === SyntaxKind.ImportEqualsDeclaration\r\n            || kind === SyntaxKind.ImportSpecifier\r\n            || kind === SyntaxKind.InterfaceDeclaration\r\n            || kind === SyntaxKind.JsxAttribute\r\n            || kind === SyntaxKind.MethodDeclaration\r\n            || kind === SyntaxKind.MethodSignature\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.NamespaceExportDeclaration\r\n            || kind === SyntaxKind.NamespaceImport\r\n            || kind === SyntaxKind.Parameter\r\n            || kind === SyntaxKind.PropertyAssignment\r\n            || kind === SyntaxKind.PropertyDeclaration\r\n            || kind === SyntaxKind.PropertySignature\r\n            || kind === SyntaxKind.SetAccessor\r\n            || kind === SyntaxKind.ShorthandPropertyAssignment\r\n            || kind === SyntaxKind.TypeAliasDeclaration\r\n            || kind === SyntaxKind.TypeParameter\r\n            || kind === SyntaxKind.VariableDeclaration\r\n            || kind === SyntaxKind.JSDocTypedefTag;\r\n    }\r\n\r\n    function isDeclarationStatementKind(kind: SyntaxKind) {\r\n        return kind === SyntaxKind.FunctionDeclaration\r\n            || kind === SyntaxKind.MissingDeclaration\r\n            || kind === SyntaxKind.ClassDeclaration\r\n            || kind === SyntaxKind.InterfaceDeclaration\r\n            || kind === SyntaxKind.TypeAliasDeclaration\r\n            || kind === SyntaxKind.EnumDeclaration\r\n            || kind === SyntaxKind.ModuleDeclaration\r\n            || kind === SyntaxKind.ImportDeclaration\r\n            || kind === SyntaxKind.ImportEqualsDeclaration\r\n            || kind === SyntaxKind.ExportDeclaration\r\n            || kind === SyntaxKind.ExportAssignment\r\n            || kind === SyntaxKind.NamespaceExportDeclaration;\r\n    }\r\n\r\n    function isStatementKindButNotDeclarationKind(kind: SyntaxKind) {\r\n        return kind === SyntaxKind.BreakStatement\r\n            || kind === SyntaxKind.ContinueStatement\r\n            || kind === SyntaxKind.DebuggerStatement\r\n            || kind === SyntaxKind.DoStatement\r\n            || kind === SyntaxKind.ExpressionStatement\r\n            || kind === SyntaxKind.EmptyStatement\r\n            || kind === SyntaxKind.ForInStatement\r\n            || kind === SyntaxKind.ForOfStatement\r\n            || kind === SyntaxKind.ForStatement\r\n            || kind === SyntaxKind.IfStatement\r\n            || kind === SyntaxKind.LabeledStatement\r\n            || kind === SyntaxKind.ReturnStatement\r\n            || kind === SyntaxKind.SwitchStatement\r\n            || kind === SyntaxKind.ThrowStatement\r\n            || kind === SyntaxKind.TryStatement\r\n            || kind === SyntaxKind.VariableStatement\r\n            || kind === SyntaxKind.WhileStatement\r\n            || kind === SyntaxKind.WithStatement\r\n            || kind === SyntaxKind.NotEmittedStatement\r\n            || kind === SyntaxKind.EndOfDeclarationMarker\r\n            || kind === SyntaxKind.MergeDeclarationMarker;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isDeclaration(node: Node): node is NamedDeclaration {\r\n        if (node.kind === SyntaxKind.TypeParameter) {\r\n            return node.parent.kind !== SyntaxKind.JSDocTemplateTag || isInJavaScriptFile(node);\r\n        }\r\n\r\n        return isDeclarationKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isDeclarationStatement(node: Node): node is DeclarationStatement {\r\n        return isDeclarationStatementKind(node.kind);\r\n    }\r\n\r\n    /**\r\n     * Determines whether the node is a statement that is not also a declaration\r\n     */\r\n    /* @internal */\r\n    export function isStatementButNotDeclaration(node: Node): node is Statement {\r\n        return isStatementKindButNotDeclarationKind(node.kind);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isStatement(node: Node): node is Statement {\r\n        const kind = node.kind;\r\n        return isStatementKindButNotDeclarationKind(kind)\r\n            || isDeclarationStatementKind(kind)\r\n            || isBlockStatement(node);\r\n    }\r\n\r\n    function isBlockStatement(node: Node): node is Block {\r\n        if (node.kind !== SyntaxKind.Block) return false;\r\n        if (node.parent !== undefined) {\r\n            if (node.parent.kind === SyntaxKind.TryStatement || node.parent.kind === SyntaxKind.CatchClause) {\r\n                return false;\r\n            }\r\n        }\r\n        return !isFunctionBlock(node);\r\n    }\r\n\r\n    // Module references\r\n\r\n    /* @internal */\r\n    export function isModuleReference(node: Node): node is ModuleReference {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ExternalModuleReference\r\n            || kind === SyntaxKind.QualifiedName\r\n            || kind === SyntaxKind.Identifier;\r\n    }\r\n\r\n    // JSX\r\n\r\n    /* @internal */\r\n    export function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.ThisKeyword\r\n            || kind === SyntaxKind.Identifier\r\n            || kind === SyntaxKind.PropertyAccessExpression;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isJsxChild(node: Node): node is JsxChild {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.JsxElement\r\n            || kind === SyntaxKind.JsxExpression\r\n            || kind === SyntaxKind.JsxSelfClosingElement\r\n            || kind === SyntaxKind.JsxText\r\n            || kind === SyntaxKind.JsxFragment;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isJsxAttributeLike(node: Node): node is JsxAttributeLike {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.JsxAttribute\r\n            || kind === SyntaxKind.JsxSpreadAttribute;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.StringLiteral\r\n            || kind === SyntaxKind.JsxExpression;\r\n    }\r\n\r\n    export function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.JsxOpeningElement\r\n            || kind === SyntaxKind.JsxSelfClosingElement;\r\n    }\r\n\r\n    // Clauses\r\n\r\n    export function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause {\r\n        const kind = node.kind;\r\n        return kind === SyntaxKind.CaseClause\r\n            || kind === SyntaxKind.DefaultClause;\r\n    }\r\n\r\n    // JSDoc\r\n\r\n    /** True if node is of some JSDoc syntax kind. */\r\n    /* @internal */\r\n    export function isJSDocNode(node: Node): boolean {\r\n        return node.kind >= SyntaxKind.FirstJSDocNode && node.kind <= SyntaxKind.LastJSDocNode;\r\n    }\r\n\r\n    /** True if node is of a kind that may contain comment text. */\r\n    export function isJSDocCommentContainingNode(node: Node): boolean {\r\n        return node.kind === SyntaxKind.JSDocComment || isJSDocTag(node) || isJSDocTypeLiteral(node);\r\n    }\r\n\r\n    // TODO: determine what this does before making it public.\r\n    /* @internal */\r\n    export function isJSDocTag(node: Node): boolean {\r\n        return node.kind >= SyntaxKind.FirstJSDocTagNode && node.kind <= SyntaxKind.LastJSDocTagNode;\r\n    }\r\n\r\n    export function isSetAccessor(node: Node): node is SetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.SetAccessor;\r\n    }\r\n\r\n    export function isGetAccessor(node: Node): node is GetAccessorDeclaration {\r\n        return node.kind === SyntaxKind.GetAccessor;\r\n    }\r\n\r\n    /** True if has jsdoc nodes attached to it. */\r\n    /* @internal */\r\n    export function hasJSDocNodes(node: Node): node is HasJSDoc {\r\n        return !!(node as JSDocContainer).jsDoc && (node as JSDocContainer).jsDoc.length > 0;\r\n    }\r\n\r\n    /** True if has type node attached to it. */\r\n    /* @internal */\r\n    export function hasType(node: Node): node is HasType {\r\n        return !!(node as HasType).type;\r\n    }\r\n\r\n    /* True if the node could have a type node a `.type` */\r\n    /* @internal */\r\n    export function couldHaveType(node: Node): node is HasType {\r\n        switch (node.kind) {\r\n            case SyntaxKind.Parameter:\r\n            case SyntaxKind.PropertySignature:\r\n            case SyntaxKind.PropertyDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.IndexSignature:\r\n            case SyntaxKind.TypePredicate:\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n            case SyntaxKind.ParenthesizedType:\r\n            case SyntaxKind.TypeOperator:\r\n            case SyntaxKind.MappedType:\r\n            case SyntaxKind.TypeAssertionExpression:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.ArrowFunction:\r\n            case SyntaxKind.AsExpression:\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n            case SyntaxKind.JSDocTypeExpression:\r\n            case SyntaxKind.JSDocNullableType:\r\n            case SyntaxKind.JSDocNonNullableType:\r\n            case SyntaxKind.JSDocOptionalType:\r\n            case SyntaxKind.JSDocFunctionType:\r\n            case SyntaxKind.JSDocVariadicType:\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** True if has initializer node attached to it. */\r\n    /* @internal */\r\n    export function hasInitializer(node: Node): node is HasInitializer {\r\n        return !!(node as HasInitializer).initializer;\r\n    }\r\n\r\n    /** True if has initializer node attached to it. */\r\n    /* @internal */\r\n    export function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer {\r\n        return hasInitializer(node) && !isForStatement(node) && !isForInStatement(node) && !isForOfStatement(node) && !isJsxAttribute(node);\r\n    }\r\n\r\n    export function isObjectLiteralElement(node: Node): node is ObjectLiteralElement {\r\n        switch (node.kind) {\r\n            case SyntaxKind.JsxAttribute:\r\n            case SyntaxKind.JsxSpreadAttribute:\r\n            case SyntaxKind.PropertyAssignment:\r\n            case SyntaxKind.ShorthandPropertyAssignment:\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function isTypeReferenceType(node: Node): node is TypeReferenceType {\r\n        return node.kind === SyntaxKind.TypeReference || node.kind === SyntaxKind.ExpressionWithTypeArguments;\r\n    }\r\n\r\n    const MAX_SMI_X86 = 0x3fff_ffff;\r\n    /* @internal */\r\n    export function guessIndentation(lines: string[]) {\r\n        let indentation = MAX_SMI_X86;\r\n        for (const line of lines) {\r\n            if (!line.length) {\r\n                continue;\r\n            }\r\n            let i = 0;\r\n            for (; i < line.length && i < indentation; i++) {\r\n                if (!isWhiteSpaceLike(line.charCodeAt(i))) {\r\n                    break;\r\n                }\r\n            }\r\n            if (i < indentation) {\r\n                indentation = i;\r\n            }\r\n            if (indentation === 0) {\r\n                return 0;\r\n            }\r\n        }\r\n        return indentation === MAX_SMI_X86 ? undefined : indentation;\r\n    }\r\n\r\n    export function isStringLiteralLike(node: Node): node is StringLiteralLike {\r\n        return node.kind === SyntaxKind.StringLiteral || node.kind === SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    }\r\n\r\n    /** @internal */\r\n    export function isNamedImportsOrExports(node: Node): node is NamedImportsOrExports {\r\n        return node.kind === SyntaxKind.NamedImports || node.kind === SyntaxKind.NamedExports;\r\n    }\r\n}\r\n","namespace ts {\r\n    export type ErrorCallback = (message: DiagnosticMessage, length: number) => void;\r\n\r\n    /* @internal */\r\n    export function tokenIsIdentifierOrKeyword(token: SyntaxKind): boolean {\r\n        return token >= SyntaxKind.Identifier;\r\n    }\r\n\r\n    /* @internal */\r\n    export function tokenIsIdentifierOrKeywordOrGreaterThan(token: SyntaxKind): boolean {\r\n        return token === SyntaxKind.GreaterThanToken || tokenIsIdentifierOrKeyword(token);\r\n    }\r\n\r\n    export interface Scanner {\r\n        getStartPos(): number;\r\n        getToken(): SyntaxKind;\r\n        getTextPos(): number;\r\n        getTokenPos(): number;\r\n        getTokenText(): string;\r\n        getTokenValue(): string;\r\n        hasExtendedUnicodeEscape(): boolean;\r\n        hasPrecedingLineBreak(): boolean;\r\n        isIdentifier(): boolean;\r\n        isReservedWord(): boolean;\r\n        isUnterminated(): boolean;\r\n        /* @internal */\r\n        getTokenFlags(): TokenFlags;\r\n        reScanGreaterToken(): SyntaxKind;\r\n        reScanSlashToken(): SyntaxKind;\r\n        reScanTemplateToken(): SyntaxKind;\r\n        scanJsxIdentifier(): SyntaxKind;\r\n        scanJsxAttributeValue(): SyntaxKind;\r\n        reScanJsxToken(): JsxTokenSyntaxKind;\r\n        scanJsxToken(): JsxTokenSyntaxKind;\r\n        scanJSDocToken(): JsDocSyntaxKind;\r\n        scan(): SyntaxKind;\r\n        getText(): string;\r\n        // Sets the text for the scanner to scan.  An optional subrange starting point and length\r\n        // can be provided to have the scanner only scan a portion of the text.\r\n        setText(text: string, start?: number, length?: number): void;\r\n        setOnError(onError: ErrorCallback): void;\r\n        setScriptTarget(scriptTarget: ScriptTarget): void;\r\n        setLanguageVariant(variant: LanguageVariant): void;\r\n        setTextPos(textPos: number): void;\r\n        // Invokes the provided callback then unconditionally restores the scanner to the state it\r\n        // was in immediately prior to invoking the callback.  The result of invoking the callback\r\n        // is returned from this function.\r\n        lookAhead<T>(callback: () => T): T;\r\n\r\n        // Invokes the callback with the scanner set to scan the specified range. When the callback\r\n        // returns, the scanner is restored to the state it was in before scanRange was called.\r\n        scanRange<T>(start: number, length: number, callback: () => T): T;\r\n\r\n        // Invokes the provided callback.  If the callback returns something falsy, then it restores\r\n        // the scanner to the state it was in immediately prior to invoking the callback.  If the\r\n        // callback returns something truthy, then the scanner state is not rolled back.  The result\r\n        // of invoking the callback is returned from this function.\r\n        tryScan<T>(callback: () => T): T;\r\n    }\r\n\r\n    const textToToken = createMapFromTemplate({\r\n        \"abstract\": SyntaxKind.AbstractKeyword,\r\n        \"any\": SyntaxKind.AnyKeyword,\r\n        \"as\": SyntaxKind.AsKeyword,\r\n        \"boolean\": SyntaxKind.BooleanKeyword,\r\n        \"break\": SyntaxKind.BreakKeyword,\r\n        \"case\": SyntaxKind.CaseKeyword,\r\n        \"catch\": SyntaxKind.CatchKeyword,\r\n        \"class\": SyntaxKind.ClassKeyword,\r\n        \"continue\": SyntaxKind.ContinueKeyword,\r\n        \"const\": SyntaxKind.ConstKeyword,\r\n        \"constructor\": SyntaxKind.ConstructorKeyword,\r\n        \"debugger\": SyntaxKind.DebuggerKeyword,\r\n        \"declare\": SyntaxKind.DeclareKeyword,\r\n        \"default\": SyntaxKind.DefaultKeyword,\r\n        \"delete\": SyntaxKind.DeleteKeyword,\r\n        \"do\": SyntaxKind.DoKeyword,\r\n        \"else\": SyntaxKind.ElseKeyword,\r\n        \"enum\": SyntaxKind.EnumKeyword,\r\n        \"export\": SyntaxKind.ExportKeyword,\r\n        \"extends\": SyntaxKind.ExtendsKeyword,\r\n        \"false\": SyntaxKind.FalseKeyword,\r\n        \"finally\": SyntaxKind.FinallyKeyword,\r\n        \"for\": SyntaxKind.ForKeyword,\r\n        \"from\": SyntaxKind.FromKeyword,\r\n        \"function\": SyntaxKind.FunctionKeyword,\r\n        \"get\": SyntaxKind.GetKeyword,\r\n        \"if\": SyntaxKind.IfKeyword,\r\n        \"implements\": SyntaxKind.ImplementsKeyword,\r\n        \"import\": SyntaxKind.ImportKeyword,\r\n        \"in\": SyntaxKind.InKeyword,\r\n        \"infer\": SyntaxKind.InferKeyword,\r\n        \"instanceof\": SyntaxKind.InstanceOfKeyword,\r\n        \"interface\": SyntaxKind.InterfaceKeyword,\r\n        \"is\": SyntaxKind.IsKeyword,\r\n        \"keyof\": SyntaxKind.KeyOfKeyword,\r\n        \"let\": SyntaxKind.LetKeyword,\r\n        \"module\": SyntaxKind.ModuleKeyword,\r\n        \"namespace\": SyntaxKind.NamespaceKeyword,\r\n        \"never\": SyntaxKind.NeverKeyword,\r\n        \"new\": SyntaxKind.NewKeyword,\r\n        \"null\": SyntaxKind.NullKeyword,\r\n        \"number\": SyntaxKind.NumberKeyword,\r\n        \"object\": SyntaxKind.ObjectKeyword,\r\n        \"package\": SyntaxKind.PackageKeyword,\r\n        \"private\": SyntaxKind.PrivateKeyword,\r\n        \"protected\": SyntaxKind.ProtectedKeyword,\r\n        \"public\": SyntaxKind.PublicKeyword,\r\n        \"readonly\": SyntaxKind.ReadonlyKeyword,\r\n        \"require\": SyntaxKind.RequireKeyword,\r\n        \"global\": SyntaxKind.GlobalKeyword,\r\n        \"return\": SyntaxKind.ReturnKeyword,\r\n        \"set\": SyntaxKind.SetKeyword,\r\n        \"static\": SyntaxKind.StaticKeyword,\r\n        \"string\": SyntaxKind.StringKeyword,\r\n        \"super\": SyntaxKind.SuperKeyword,\r\n        \"switch\": SyntaxKind.SwitchKeyword,\r\n        \"symbol\": SyntaxKind.SymbolKeyword,\r\n        \"this\": SyntaxKind.ThisKeyword,\r\n        \"throw\": SyntaxKind.ThrowKeyword,\r\n        \"true\": SyntaxKind.TrueKeyword,\r\n        \"try\": SyntaxKind.TryKeyword,\r\n        \"type\": SyntaxKind.TypeKeyword,\r\n        \"typeof\": SyntaxKind.TypeOfKeyword,\r\n        \"undefined\": SyntaxKind.UndefinedKeyword,\r\n        \"unique\": SyntaxKind.UniqueKeyword,\r\n        \"var\": SyntaxKind.VarKeyword,\r\n        \"void\": SyntaxKind.VoidKeyword,\r\n        \"while\": SyntaxKind.WhileKeyword,\r\n        \"with\": SyntaxKind.WithKeyword,\r\n        \"yield\": SyntaxKind.YieldKeyword,\r\n        \"async\": SyntaxKind.AsyncKeyword,\r\n        \"await\": SyntaxKind.AwaitKeyword,\r\n        \"of\": SyntaxKind.OfKeyword,\r\n        \"{\": SyntaxKind.OpenBraceToken,\r\n        \"}\": SyntaxKind.CloseBraceToken,\r\n        \"(\": SyntaxKind.OpenParenToken,\r\n        \")\": SyntaxKind.CloseParenToken,\r\n        \"[\": SyntaxKind.OpenBracketToken,\r\n        \"]\": SyntaxKind.CloseBracketToken,\r\n        \".\": SyntaxKind.DotToken,\r\n        \"...\": SyntaxKind.DotDotDotToken,\r\n        \";\": SyntaxKind.SemicolonToken,\r\n        \",\": SyntaxKind.CommaToken,\r\n        \"<\": SyntaxKind.LessThanToken,\r\n        \">\": SyntaxKind.GreaterThanToken,\r\n        \"<=\": SyntaxKind.LessThanEqualsToken,\r\n        \">=\": SyntaxKind.GreaterThanEqualsToken,\r\n        \"==\": SyntaxKind.EqualsEqualsToken,\r\n        \"!=\": SyntaxKind.ExclamationEqualsToken,\r\n        \"===\": SyntaxKind.EqualsEqualsEqualsToken,\r\n        \"!==\": SyntaxKind.ExclamationEqualsEqualsToken,\r\n        \"=>\": SyntaxKind.EqualsGreaterThanToken,\r\n        \"+\": SyntaxKind.PlusToken,\r\n        \"-\": SyntaxKind.MinusToken,\r\n        \"**\": SyntaxKind.AsteriskAsteriskToken,\r\n        \"*\": SyntaxKind.AsteriskToken,\r\n        \"/\": SyntaxKind.SlashToken,\r\n        \"%\": SyntaxKind.PercentToken,\r\n        \"++\": SyntaxKind.PlusPlusToken,\r\n        \"--\": SyntaxKind.MinusMinusToken,\r\n        \"<<\": SyntaxKind.LessThanLessThanToken,\r\n        \"</\": SyntaxKind.LessThanSlashToken,\r\n        \">>\": SyntaxKind.GreaterThanGreaterThanToken,\r\n        \">>>\": SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\r\n        \"&\": SyntaxKind.AmpersandToken,\r\n        \"|\": SyntaxKind.BarToken,\r\n        \"^\": SyntaxKind.CaretToken,\r\n        \"!\": SyntaxKind.ExclamationToken,\r\n        \"~\": SyntaxKind.TildeToken,\r\n        \"&&\": SyntaxKind.AmpersandAmpersandToken,\r\n        \"||\": SyntaxKind.BarBarToken,\r\n        \"?\": SyntaxKind.QuestionToken,\r\n        \":\": SyntaxKind.ColonToken,\r\n        \"=\": SyntaxKind.EqualsToken,\r\n        \"+=\": SyntaxKind.PlusEqualsToken,\r\n        \"-=\": SyntaxKind.MinusEqualsToken,\r\n        \"*=\": SyntaxKind.AsteriskEqualsToken,\r\n        \"**=\": SyntaxKind.AsteriskAsteriskEqualsToken,\r\n        \"/=\": SyntaxKind.SlashEqualsToken,\r\n        \"%=\": SyntaxKind.PercentEqualsToken,\r\n        \"<<=\": SyntaxKind.LessThanLessThanEqualsToken,\r\n        \">>=\": SyntaxKind.GreaterThanGreaterThanEqualsToken,\r\n        \">>>=\": SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,\r\n        \"&=\": SyntaxKind.AmpersandEqualsToken,\r\n        \"|=\": SyntaxKind.BarEqualsToken,\r\n        \"^=\": SyntaxKind.CaretEqualsToken,\r\n        \"@\": SyntaxKind.AtToken,\r\n    });\r\n\r\n    /*\r\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\r\n        IdentifierStart ::\r\n            Can contain Unicode 3.0.0 categories:\r\n            Uppercase letter (Lu),\r\n            Lowercase letter (Ll),\r\n            Titlecase letter (Lt),\r\n            Modifier letter (Lm),\r\n            Other letter (Lo), or\r\n            Letter number (Nl).\r\n        IdentifierPart :: =\r\n            Can contain IdentifierStart + Unicode 3.0.0 categories:\r\n            Non-spacing mark (Mn),\r\n            Combining spacing mark (Mc),\r\n            Decimal number (Nd), or\r\n            Connector punctuation (Pc).\r\n\r\n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\r\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\r\n    */\r\n    const unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n    const unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n\r\n    /*\r\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers\r\n        IdentifierStart ::\r\n            Can contain Unicode 6.2 categories:\r\n            Uppercase letter (Lu),\r\n            Lowercase letter (Ll),\r\n            Titlecase letter (Lt),\r\n            Modifier letter (Lm),\r\n            Other letter (Lo), or\r\n            Letter number (Nl).\r\n        IdentifierPart ::\r\n            Can contain IdentifierStart + Unicode 6.2 categories:\r\n            Non-spacing mark (Mn),\r\n            Combining spacing mark (Mc),\r\n            Decimal number (Nd),\r\n            Connector punctuation (Pc),\r\n            <ZWNJ>, or\r\n            <ZWJ>.\r\n\r\n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\r\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\r\n    */\r\n    const unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n    const unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n\r\n    function lookupInUnicodeMap(code: number, map: ReadonlyArray<number>): boolean {\r\n        // Bail out quickly if it couldn't possibly be in the map.\r\n        if (code < map[0]) {\r\n            return false;\r\n        }\r\n\r\n        // Perform binary search in one of the Unicode range maps\r\n        let lo = 0;\r\n        let hi: number = map.length;\r\n        let mid: number;\r\n\r\n        while (lo + 1 < hi) {\r\n            mid = lo + (hi - lo) / 2;\r\n            // mid has to be even to catch a range's beginning\r\n            mid -= mid % 2;\r\n            if (map[mid] <= code && code <= map[mid + 1]) {\r\n                return true;\r\n            }\r\n\r\n            if (code < map[mid]) {\r\n                hi = mid;\r\n            }\r\n            else {\r\n                lo = mid + 2;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @internal */ export function isUnicodeIdentifierStart(code: number, languageVersion: ScriptTarget) {\r\n        return languageVersion >= ScriptTarget.ES5 ?\r\n            lookupInUnicodeMap(code, unicodeES5IdentifierStart) :\r\n            lookupInUnicodeMap(code, unicodeES3IdentifierStart);\r\n    }\r\n\r\n    function isUnicodeIdentifierPart(code: number, languageVersion: ScriptTarget) {\r\n        return languageVersion >= ScriptTarget.ES5 ?\r\n            lookupInUnicodeMap(code, unicodeES5IdentifierPart) :\r\n            lookupInUnicodeMap(code, unicodeES3IdentifierPart);\r\n    }\r\n\r\n    function makeReverseMap(source: Map<number>): string[] {\r\n        const result: string[] = [];\r\n        source.forEach((value, name) => {\r\n            result[value] = name;\r\n        });\r\n        return result;\r\n    }\r\n\r\n    const tokenStrings = makeReverseMap(textToToken);\r\n\r\n    export function tokenToString(t: SyntaxKind): string | undefined {\r\n        return tokenStrings[t];\r\n    }\r\n\r\n    /* @internal */\r\n    export function stringToToken(s: string): SyntaxKind | undefined {\r\n        return textToToken.get(s);\r\n    }\r\n\r\n    /* @internal */\r\n    export function computeLineStarts(text: string): number[] {\r\n        const result: number[] = new Array();\r\n        let pos = 0;\r\n        let lineStart = 0;\r\n        while (pos < text.length) {\r\n           const ch = text.charCodeAt(pos);\r\n           pos++;\r\n           switch (ch) {\r\n                case CharacterCodes.carriageReturn:\r\n                    if (text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n                    // falls through\r\n                case CharacterCodes.lineFeed:\r\n                    result.push(lineStart);\r\n                    lineStart = pos;\r\n                    break;\r\n                default:\r\n                    if (ch > CharacterCodes.maxAsciiCharacter && isLineBreak(ch)) {\r\n                        result.push(lineStart);\r\n                        lineStart = pos;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        result.push(lineStart);\r\n        return result;\r\n    }\r\n\r\n    export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number {\r\n        return computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character, sourceFile.text);\r\n    }\r\n\r\n    /* @internal */\r\n    export function computePositionOfLineAndCharacter(lineStarts: ReadonlyArray<number>, line: number, character: number, debugText?: string): number {\r\n        if (line < 0 || line >= lineStarts.length) {\r\n            Debug.fail(`Bad line number. Line: ${line}, lineStarts.length: ${lineStarts.length} , line map is correct? ${debugText !== undefined ? arraysEqual(lineStarts, computeLineStarts(debugText)) : \"unknown\"}`);\r\n        }\r\n\r\n        const res = lineStarts[line] + character;\r\n        if (line < lineStarts.length - 1) {\r\n            Debug.assert(res < lineStarts[line + 1]);\r\n        }\r\n        else if (debugText !== undefined) {\r\n            Debug.assert(res <= debugText.length); // Allow single character overflow for trailing newline\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getLineStarts(sourceFile: SourceFileLike): ReadonlyArray<number> {\r\n        return sourceFile.lineMap || (sourceFile.lineMap = computeLineStarts(sourceFile.text));\r\n    }\r\n\r\n    /* @internal */\r\n    /**\r\n     * We assume the first line starts at position 0 and 'position' is non-negative.\r\n     */\r\n    export function computeLineAndCharacterOfPosition(lineStarts: ReadonlyArray<number>, position: number): LineAndCharacter {\r\n        let lineNumber = binarySearch(lineStarts, position, identity, compareValues);\r\n        if (lineNumber < 0) {\r\n            // If the actual position was not found,\r\n            // the binary search returns the 2's-complement of the next line start\r\n            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20\r\n            // then the search will return -2.\r\n            //\r\n            // We want the index of the previous line start, so we subtract 1.\r\n            // Review 2's-complement if this is confusing.\r\n            lineNumber = ~lineNumber - 1;\r\n            Debug.assert(lineNumber !== -1, \"position cannot precede the beginning of the file\");\r\n        }\r\n        return {\r\n            line: lineNumber,\r\n            character: position - lineStarts[lineNumber]\r\n        };\r\n    }\r\n\r\n    export function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter {\r\n        return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position);\r\n    }\r\n\r\n    export function isWhiteSpaceLike(ch: number): boolean {\r\n        return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);\r\n    }\r\n\r\n    /** Does not include line breaks. For that, see isWhiteSpaceLike. */\r\n    export function isWhiteSpaceSingleLine(ch: number): boolean {\r\n        // Note: nextLine is in the Zs space, and should be considered to be a whitespace.\r\n        // It is explicitly not a line-break as it isn't in the exact set specified by EcmaScript.\r\n        return ch === CharacterCodes.space ||\r\n            ch === CharacterCodes.tab ||\r\n            ch === CharacterCodes.verticalTab ||\r\n            ch === CharacterCodes.formFeed ||\r\n            ch === CharacterCodes.nonBreakingSpace ||\r\n            ch === CharacterCodes.nextLine ||\r\n            ch === CharacterCodes.ogham ||\r\n            ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\r\n            ch === CharacterCodes.narrowNoBreakSpace ||\r\n            ch === CharacterCodes.mathematicalSpace ||\r\n            ch === CharacterCodes.ideographicSpace ||\r\n            ch === CharacterCodes.byteOrderMark;\r\n      }\r\n\r\n      export function isLineBreak(ch: number): boolean {\r\n          // ES5 7.3:\r\n          // The ECMAScript line terminator characters are listed in Table 3.\r\n          //     Table 3: Line Terminator Characters\r\n          //     Code Unit Value     Name                    Formal Name\r\n          //     \\u000A              Line Feed               <LF>\r\n          //     \\u000D              Carriage Return         <CR>\r\n          //     \\u2028              Line separator          <LS>\r\n          //     \\u2029              Paragraph separator     <PS>\r\n          // Only the characters in Table 3 are treated as line terminators. Other new line or line\r\n          // breaking characters are treated as white space but not as line terminators.\r\n\r\n          return ch === CharacterCodes.lineFeed ||\r\n              ch === CharacterCodes.carriageReturn ||\r\n              ch === CharacterCodes.lineSeparator ||\r\n              ch === CharacterCodes.paragraphSeparator;\r\n      }\r\n\r\n      function isDigit(ch: number): boolean {\r\n          return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\r\n      }\r\n\r\n      /* @internal */\r\n      export function isOctalDigit(ch: number): boolean {\r\n          return ch >= CharacterCodes._0 && ch <= CharacterCodes._7;\r\n      }\r\n\r\n      export function couldStartTrivia(text: string, pos: number): boolean {\r\n          // Keep in sync with skipTrivia\r\n          const ch = text.charCodeAt(pos);\r\n          switch (ch) {\r\n              case CharacterCodes.carriageReturn:\r\n              case CharacterCodes.lineFeed:\r\n              case CharacterCodes.tab:\r\n              case CharacterCodes.verticalTab:\r\n              case CharacterCodes.formFeed:\r\n              case CharacterCodes.space:\r\n              case CharacterCodes.slash:\r\n                  // starts of normal trivia\r\n              case CharacterCodes.lessThan:\r\n              case CharacterCodes.bar:\r\n              case CharacterCodes.equals:\r\n              case CharacterCodes.greaterThan:\r\n                  // Starts of conflict marker trivia\r\n                  return true;\r\n              case CharacterCodes.hash:\r\n                  // Only if its the beginning can we have #! trivia\r\n                  return pos === 0;\r\n              default:\r\n                  return ch > CharacterCodes.maxAsciiCharacter;\r\n          }\r\n      }\r\n\r\n      /* @internal */\r\n      export function skipTrivia(text: string, pos: number, stopAfterLineBreak?: boolean, stopAtComments = false): number {\r\n          if (positionIsSynthesized(pos)) {\r\n              return pos;\r\n          }\r\n\r\n          // Keep in sync with couldStartTrivia\r\n          while (true) {\r\n              const ch = text.charCodeAt(pos);\r\n              switch (ch) {\r\n                  case CharacterCodes.carriageReturn:\r\n                      if (text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) {\r\n                          pos++;\r\n                      }\r\n                      // falls through\r\n                  case CharacterCodes.lineFeed:\r\n                      pos++;\r\n                      if (stopAfterLineBreak) {\r\n                          return pos;\r\n                      }\r\n                      continue;\r\n                  case CharacterCodes.tab:\r\n                  case CharacterCodes.verticalTab:\r\n                  case CharacterCodes.formFeed:\r\n                  case CharacterCodes.space:\r\n                      pos++;\r\n                      continue;\r\n                  case CharacterCodes.slash:\r\n                      if (stopAtComments) {\r\n                          break;\r\n                      }\r\n                      if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                          pos += 2;\r\n                          while (pos < text.length) {\r\n                              if (isLineBreak(text.charCodeAt(pos))) {\r\n                                  break;\r\n                              }\r\n                              pos++;\r\n                          }\r\n                          continue;\r\n                      }\r\n                      if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                          pos += 2;\r\n                          while (pos < text.length) {\r\n                              if (text.charCodeAt(pos) === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                  pos += 2;\r\n                                  break;\r\n                              }\r\n                              pos++;\r\n                          }\r\n                          continue;\r\n                      }\r\n                      break;\r\n\r\n                  case CharacterCodes.lessThan:\r\n                  case CharacterCodes.bar:\r\n                  case CharacterCodes.equals:\r\n                  case CharacterCodes.greaterThan:\r\n                      if (isConflictMarkerTrivia(text, pos)) {\r\n                          pos = scanConflictMarkerTrivia(text, pos);\r\n                          continue;\r\n                      }\r\n                      break;\r\n\r\n                  case CharacterCodes.hash:\r\n                      if (pos === 0 && isShebangTrivia(text, pos)) {\r\n                          pos = scanShebangTrivia(text, pos);\r\n                          continue;\r\n                      }\r\n                      break;\r\n\r\n                  default:\r\n                      if (ch > CharacterCodes.maxAsciiCharacter && (isWhiteSpaceLike(ch))) {\r\n                          pos++;\r\n                          continue;\r\n                      }\r\n                      break;\r\n              }\r\n              return pos;\r\n          }\r\n      }\r\n\r\n      // All conflict markers consist of the same character repeated seven times.  If it is\r\n      // a <<<<<<< or >>>>>>> marker then it is also followed by a space.\r\n    const mergeConflictMarkerLength = \"<<<<<<<\".length;\r\n\r\n    function isConflictMarkerTrivia(text: string, pos: number) {\r\n        Debug.assert(pos >= 0);\r\n\r\n        // Conflict markers must be at the start of a line.\r\n        if (pos === 0 || isLineBreak(text.charCodeAt(pos - 1))) {\r\n            const ch = text.charCodeAt(pos);\r\n\r\n            if ((pos + mergeConflictMarkerLength) < text.length) {\r\n                for (let i = 0; i < mergeConflictMarkerLength; i++) {\r\n                    if (text.charCodeAt(pos + i) !== ch) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return ch === CharacterCodes.equals ||\r\n                    text.charCodeAt(pos + mergeConflictMarkerLength) === CharacterCodes.space;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function scanConflictMarkerTrivia(text: string, pos: number, error?: (diag: DiagnosticMessage, pos?: number, len?: number) => void) {\r\n        if (error) {\r\n            error(Diagnostics.Merge_conflict_marker_encountered, pos, mergeConflictMarkerLength);\r\n        }\r\n\r\n        const ch = text.charCodeAt(pos);\r\n        const len = text.length;\r\n\r\n        if (ch === CharacterCodes.lessThan || ch === CharacterCodes.greaterThan) {\r\n            while (pos < len && !isLineBreak(text.charCodeAt(pos))) {\r\n                pos++;\r\n            }\r\n        }\r\n        else {\r\n            Debug.assert(ch === CharacterCodes.bar || ch === CharacterCodes.equals);\r\n            // Consume everything from the start of a ||||||| or ======= marker to the start\r\n            // of the next ======= or >>>>>>> marker.\r\n            while (pos < len) {\r\n                const currentChar = text.charCodeAt(pos);\r\n                if ((currentChar === CharacterCodes.equals || currentChar === CharacterCodes.greaterThan) && currentChar !== ch && isConflictMarkerTrivia(text, pos)) {\r\n                    break;\r\n                }\r\n\r\n                pos++;\r\n            }\r\n        }\r\n\r\n        return pos;\r\n    }\r\n\r\n    const shebangTriviaRegex = /^#!.*/;\r\n\r\n    function isShebangTrivia(text: string, pos: number) {\r\n        // Shebangs check must only be done at the start of the file\r\n        Debug.assert(pos === 0);\r\n        return shebangTriviaRegex.test(text);\r\n    }\r\n\r\n    function scanShebangTrivia(text: string, pos: number) {\r\n        const shebang = shebangTriviaRegex.exec(text)[0];\r\n        pos = pos + shebang.length;\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Invokes a callback for each comment range following the provided position.\r\n     *\r\n     * Single-line comment ranges include the leading double-slash characters but not the ending\r\n     * line break. Multi-line comment ranges include the leading slash-asterisk and trailing\r\n     * asterisk-slash characters.\r\n     *\r\n     * @param reduce If true, accumulates the result of calling the callback in a fashion similar\r\n     *      to reduceLeft. If false, iteration stops when the callback returns a truthy value.\r\n     * @param text The source text to scan.\r\n     * @param pos The position at which to start scanning.\r\n     * @param trailing If false, whitespace is skipped until the first line break and comments\r\n     *      between that location and the next token are returned. If true, comments occurring\r\n     *      between the given position and the next line break are returned.\r\n     * @param cb The callback to execute as each comment range is encountered.\r\n     * @param state A state value to pass to each iteration of the callback.\r\n     * @param initial An initial value to pass when accumulating results (when \"reduce\" is true).\r\n     * @returns If \"reduce\" is true, the accumulated value. If \"reduce\" is false, the first truthy\r\n     *      return value of the callback.\r\n     */\r\n    function iterateCommentRanges<T, U>(reduce: boolean, text: string, pos: number, trailing: boolean, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial?: U): U {\r\n        let pendingPos: number;\r\n        let pendingEnd: number;\r\n        let pendingKind: CommentKind;\r\n        let pendingHasTrailingNewLine: boolean;\r\n        let hasPendingCommentRange = false;\r\n        let collecting = trailing || pos === 0;\r\n        let accumulator = initial;\r\n        scan: while (pos >= 0 && pos < text.length) {\r\n            const ch = text.charCodeAt(pos);\r\n            switch (ch) {\r\n                case CharacterCodes.carriageReturn:\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n                    // falls through\r\n                case CharacterCodes.lineFeed:\r\n                    pos++;\r\n                    if (trailing) {\r\n                        break scan;\r\n                    }\r\n\r\n                    collecting = true;\r\n                    if (hasPendingCommentRange) {\r\n                        pendingHasTrailingNewLine = true;\r\n                    }\r\n\r\n                    continue;\r\n                case CharacterCodes.tab:\r\n                case CharacterCodes.verticalTab:\r\n                case CharacterCodes.formFeed:\r\n                case CharacterCodes.space:\r\n                    pos++;\r\n                    continue;\r\n                case CharacterCodes.slash:\r\n                    const nextChar = text.charCodeAt(pos + 1);\r\n                    let hasTrailingNewLine = false;\r\n                    if (nextChar === CharacterCodes.slash || nextChar === CharacterCodes.asterisk) {\r\n                        const kind = nextChar === CharacterCodes.slash ? SyntaxKind.SingleLineCommentTrivia : SyntaxKind.MultiLineCommentTrivia;\r\n                        const startPos = pos;\r\n                        pos += 2;\r\n                        if (nextChar === CharacterCodes.slash) {\r\n                            while (pos < text.length) {\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    hasTrailingNewLine = true;\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n                        }\r\n                        else {\r\n                            while (pos < text.length) {\r\n                                if (text.charCodeAt(pos) === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                    pos += 2;\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n                        }\r\n\r\n                        if (collecting) {\r\n                            if (hasPendingCommentRange) {\r\n                                accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);\r\n                                if (!reduce && accumulator) {\r\n                                    // If we are not reducing and we have a truthy result, return it.\r\n                                    return accumulator;\r\n                                }\r\n                            }\r\n\r\n                            pendingPos = startPos;\r\n                            pendingEnd = pos;\r\n                            pendingKind = kind;\r\n                            pendingHasTrailingNewLine = hasTrailingNewLine;\r\n                            hasPendingCommentRange = true;\r\n                        }\r\n\r\n                        continue;\r\n                    }\r\n                    break scan;\r\n                default:\r\n                    if (ch > CharacterCodes.maxAsciiCharacter && (isWhiteSpaceLike(ch))) {\r\n                        if (hasPendingCommentRange && isLineBreak(ch)) {\r\n                            pendingHasTrailingNewLine = true;\r\n                        }\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    break scan;\r\n            }\r\n        }\r\n\r\n        if (hasPendingCommentRange) {\r\n            accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);\r\n        }\r\n\r\n        return accumulator;\r\n    }\r\n\r\n    export function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\r\n    export function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\r\n    export function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state?: T): U | undefined {\r\n        return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ false, cb, state);\r\n    }\r\n\r\n    export function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\r\n    export function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\r\n    export function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state?: T): U | undefined {\r\n        return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ true, cb, state);\r\n    }\r\n\r\n    export function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U) {\r\n        return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ false, cb, state, initial);\r\n    }\r\n\r\n    export function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U) {\r\n        return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ true, cb, state, initial);\r\n    }\r\n\r\n    function appendCommentRange(pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, _state: any, comments: CommentRange[]) {\r\n        if (!comments) {\r\n            comments = [];\r\n        }\r\n\r\n        comments.push({ kind, pos, end, hasTrailingNewLine });\r\n        return comments;\r\n    }\r\n\r\n    export function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined {\r\n        return reduceEachLeadingCommentRange(text, pos, appendCommentRange, /*state*/ undefined, /*initial*/ undefined);\r\n    }\r\n\r\n    export function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined {\r\n        return reduceEachTrailingCommentRange(text, pos, appendCommentRange, /*state*/ undefined, /*initial*/ undefined);\r\n    }\r\n\r\n    /** Optionally, get the shebang */\r\n    export function getShebang(text: string): string | undefined {\r\n        const match = shebangTriviaRegex.exec(text);\r\n        if (match) {\r\n            return match[0];\r\n        }\r\n    }\r\n\r\n    export function isIdentifierStart(ch: number, languageVersion: ScriptTarget): boolean {\r\n        return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z ||\r\n            ch === CharacterCodes.$ || ch === CharacterCodes._ ||\r\n            ch > CharacterCodes.maxAsciiCharacter && isUnicodeIdentifierStart(ch, languageVersion);\r\n    }\r\n\r\n    export function isIdentifierPart(ch: number, languageVersion: ScriptTarget): boolean {\r\n        return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z ||\r\n            ch >= CharacterCodes._0 && ch <= CharacterCodes._9 || ch === CharacterCodes.$ || ch === CharacterCodes._ ||\r\n            ch > CharacterCodes.maxAsciiCharacter && isUnicodeIdentifierPart(ch, languageVersion);\r\n    }\r\n\r\n    /* @internal */\r\n    export function isIdentifierText(name: string, languageVersion: ScriptTarget): boolean {\r\n        if (!isIdentifierStart(name.charCodeAt(0), languageVersion)) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 1; i < name.length; i++) {\r\n            if (!isIdentifierPart(name.charCodeAt(i), languageVersion)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Creates a scanner over a (possibly unspecified) range of a piece of text.\r\n    export function createScanner(languageVersion: ScriptTarget,\r\n                                  skipTrivia: boolean,\r\n                                  languageVariant = LanguageVariant.Standard,\r\n                                  text?: string,\r\n                                  onError?: ErrorCallback,\r\n                                  start?: number,\r\n                                  length?: number): Scanner {\r\n        // Current position (end position of text of current token)\r\n        let pos: number;\r\n\r\n        // end of text\r\n        let end: number;\r\n\r\n        // Start position of whitespace before current token\r\n        let startPos: number;\r\n\r\n        // Start position of text of current token\r\n        let tokenPos: number;\r\n\r\n        let token: SyntaxKind;\r\n        let tokenValue: string;\r\n        let tokenFlags: TokenFlags;\r\n\r\n        setText(text, start, length);\r\n\r\n        return {\r\n            getStartPos: () => startPos,\r\n            getTextPos: () => pos,\r\n            getToken: () => token,\r\n            getTokenPos: () => tokenPos,\r\n            getTokenText: () => text.substring(tokenPos, pos),\r\n            getTokenValue: () => tokenValue,\r\n            hasExtendedUnicodeEscape: () => (tokenFlags & TokenFlags.ExtendedUnicodeEscape) !== 0,\r\n            hasPrecedingLineBreak: () => (tokenFlags & TokenFlags.PrecedingLineBreak) !== 0,\r\n            isIdentifier: () => token === SyntaxKind.Identifier || token > SyntaxKind.LastReservedWord,\r\n            isReservedWord: () => token >= SyntaxKind.FirstReservedWord && token <= SyntaxKind.LastReservedWord,\r\n            isUnterminated: () => (tokenFlags & TokenFlags.Unterminated) !== 0,\r\n            getTokenFlags: () => tokenFlags,\r\n            reScanGreaterToken,\r\n            reScanSlashToken,\r\n            reScanTemplateToken,\r\n            scanJsxIdentifier,\r\n            scanJsxAttributeValue,\r\n            reScanJsxToken,\r\n            scanJsxToken,\r\n            scanJSDocToken,\r\n            scan,\r\n            getText,\r\n            setText,\r\n            setScriptTarget,\r\n            setLanguageVariant,\r\n            setOnError,\r\n            setTextPos,\r\n            tryScan,\r\n            lookAhead,\r\n            scanRange,\r\n        };\r\n\r\n        function error(message: DiagnosticMessage): void;\r\n        function error(message: DiagnosticMessage, errPos: number, length: number): void;\r\n        function error(message: DiagnosticMessage, errPos: number = pos, length?: number): void {\r\n            if (onError) {\r\n                const oldPos = pos;\r\n                pos = errPos;\r\n                onError(message, length || 0);\r\n                pos = oldPos;\r\n            }\r\n        }\r\n\r\n        function scanNumberFragment(): string {\r\n            let start = pos;\r\n            let allowSeparator = false;\r\n            let isPreviousTokenSeparator = false;\r\n            let result = \"\";\r\n            while (true) {\r\n                const ch = text.charCodeAt(pos);\r\n                if (ch === CharacterCodes._) {\r\n                    tokenFlags |= TokenFlags.ContainsSeparator;\r\n                    if (allowSeparator) {\r\n                        allowSeparator = false;\r\n                        isPreviousTokenSeparator = true;\r\n                        result += text.substring(start, pos);\r\n                    }\r\n                    else if (isPreviousTokenSeparator) {\r\n                        error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);\r\n                    }\r\n                    else {\r\n                        error(Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);\r\n                    }\r\n                    pos++;\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n                if (isDigit(ch)) {\r\n                    allowSeparator = true;\r\n                    isPreviousTokenSeparator = false;\r\n                    pos++;\r\n                    continue;\r\n                }\r\n                break;\r\n            }\r\n            if (text.charCodeAt(pos - 1) === CharacterCodes._) {\r\n                error(Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);\r\n            }\r\n            return result + text.substring(start, pos);\r\n        }\r\n\r\n        function scanNumber(): string {\r\n            const start = pos;\r\n            const mainFragment = scanNumberFragment();\r\n            let decimalFragment: string;\r\n            let scientificFragment: string;\r\n            if (text.charCodeAt(pos) === CharacterCodes.dot) {\r\n                pos++;\r\n                decimalFragment = scanNumberFragment();\r\n            }\r\n            let end = pos;\r\n            if (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e) {\r\n                pos++;\r\n                tokenFlags |= TokenFlags.Scientific;\r\n                if (text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) pos++;\r\n                const preNumericPart = pos;\r\n                const finalFragment = scanNumberFragment();\r\n                if (!finalFragment) {\r\n                    error(Diagnostics.Digit_expected);\r\n                }\r\n                else {\r\n                    scientificFragment = text.substring(end, preNumericPart) + finalFragment;\r\n                    end = pos;\r\n                }\r\n            }\r\n            if (tokenFlags & TokenFlags.ContainsSeparator) {\r\n                let result = mainFragment;\r\n                if (decimalFragment) {\r\n                    result += \".\" + decimalFragment;\r\n                }\r\n                if (scientificFragment) {\r\n                    result += scientificFragment;\r\n                }\r\n                return \"\" + +result;\r\n            }\r\n            else {\r\n                return \"\" + +(text.substring(start, end)); // No need to use all the fragments; no _ removal needed\r\n            }\r\n        }\r\n\r\n        function scanOctalDigits(): number {\r\n            const start = pos;\r\n            while (isOctalDigit(text.charCodeAt(pos))) {\r\n                pos++;\r\n            }\r\n            return +(text.substring(start, pos));\r\n        }\r\n\r\n        /**\r\n         * Scans the given number of hexadecimal digits in the text,\r\n         * returning -1 if the given number is unavailable.\r\n         */\r\n        function scanExactNumberOfHexDigits(count: number, canHaveSeparators: boolean): number {\r\n            return scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ false, canHaveSeparators);\r\n        }\r\n\r\n        /**\r\n         * Scans as many hexadecimal digits as are available in the text,\r\n         * returning -1 if the given number of digits was unavailable.\r\n         */\r\n        function scanMinimumNumberOfHexDigits(count: number, canHaveSeparators: boolean): number {\r\n            return scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ true, canHaveSeparators);\r\n        }\r\n\r\n        function scanHexDigits(minCount: number, scanAsManyAsPossible: boolean, canHaveSeparators: boolean): number {\r\n            let digits = 0;\r\n            let value = 0;\r\n            let allowSeparator = false;\r\n            let isPreviousTokenSeparator = false;\r\n            while (digits < minCount || scanAsManyAsPossible) {\r\n                const ch = text.charCodeAt(pos);\r\n                if (canHaveSeparators && ch === CharacterCodes._) {\r\n                    tokenFlags |= TokenFlags.ContainsSeparator;\r\n                    if (allowSeparator) {\r\n                        allowSeparator = false;\r\n                        isPreviousTokenSeparator = true;\r\n                    }\r\n                    else if (isPreviousTokenSeparator) {\r\n                        error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);\r\n                    }\r\n                    else {\r\n                        error(Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);\r\n                    }\r\n                    pos++;\r\n                    continue;\r\n                }\r\n                allowSeparator = canHaveSeparators;\r\n                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\r\n                    value = value * 16 + ch - CharacterCodes._0;\r\n                }\r\n                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\r\n                    value = value * 16 + ch - CharacterCodes.A + 10;\r\n                }\r\n                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\r\n                    value = value * 16 + ch - CharacterCodes.a + 10;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n                pos++;\r\n                digits++;\r\n                isPreviousTokenSeparator = false;\r\n            }\r\n            if (digits < minCount) {\r\n                value = -1;\r\n            }\r\n            if (text.charCodeAt(pos - 1) === CharacterCodes._) {\r\n                error(Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function scanString(jsxAttributeString = false): string {\r\n            const quote = text.charCodeAt(pos);\r\n            pos++;\r\n            let result = \"\";\r\n            let start = pos;\r\n            while (true) {\r\n                if (pos >= end) {\r\n                    result += text.substring(start, pos);\r\n                    tokenFlags |= TokenFlags.Unterminated;\r\n                    error(Diagnostics.Unterminated_string_literal);\r\n                    break;\r\n                }\r\n                const ch = text.charCodeAt(pos);\r\n                if (ch === quote) {\r\n                    result += text.substring(start, pos);\r\n                    pos++;\r\n                    break;\r\n                }\r\n                if (ch === CharacterCodes.backslash && !jsxAttributeString) {\r\n                    result += text.substring(start, pos);\r\n                    result += scanEscapeSequence();\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n                if (isLineBreak(ch) && !jsxAttributeString) {\r\n                    result += text.substring(start, pos);\r\n                    tokenFlags |= TokenFlags.Unterminated;\r\n                    error(Diagnostics.Unterminated_string_literal);\r\n                    break;\r\n                }\r\n                pos++;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Sets the current 'tokenValue' and returns a NoSubstitutionTemplateLiteral or\r\n         * a literal component of a TemplateExpression.\r\n         */\r\n        function scanTemplateAndSetTokenValue(): SyntaxKind {\r\n            const startedWithBacktick = text.charCodeAt(pos) === CharacterCodes.backtick;\r\n\r\n            pos++;\r\n            let start = pos;\r\n            let contents = \"\";\r\n            let resultingToken: SyntaxKind;\r\n\r\n            while (true) {\r\n                if (pos >= end) {\r\n                    contents += text.substring(start, pos);\r\n                    tokenFlags |= TokenFlags.Unterminated;\r\n                    error(Diagnostics.Unterminated_template_literal);\r\n                    resultingToken = startedWithBacktick ? SyntaxKind.NoSubstitutionTemplateLiteral : SyntaxKind.TemplateTail;\r\n                    break;\r\n                }\r\n\r\n                const currChar = text.charCodeAt(pos);\r\n\r\n                // '`'\r\n                if (currChar === CharacterCodes.backtick) {\r\n                    contents += text.substring(start, pos);\r\n                    pos++;\r\n                    resultingToken = startedWithBacktick ? SyntaxKind.NoSubstitutionTemplateLiteral : SyntaxKind.TemplateTail;\r\n                    break;\r\n                }\r\n\r\n                // '${'\r\n                if (currChar === CharacterCodes.$ && pos + 1 < end && text.charCodeAt(pos + 1) === CharacterCodes.openBrace) {\r\n                    contents += text.substring(start, pos);\r\n                    pos += 2;\r\n                    resultingToken = startedWithBacktick ? SyntaxKind.TemplateHead : SyntaxKind.TemplateMiddle;\r\n                    break;\r\n                }\r\n\r\n                // Escape character\r\n                if (currChar === CharacterCodes.backslash) {\r\n                    contents += text.substring(start, pos);\r\n                    contents += scanEscapeSequence();\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n\r\n                // Speculated ECMAScript 6 Spec 11.8.6.1:\r\n                // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for Template Values\r\n                if (currChar === CharacterCodes.carriageReturn) {\r\n                    contents += text.substring(start, pos);\r\n                    pos++;\r\n\r\n                    if (pos < end && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n\r\n                    contents += \"\\n\";\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n\r\n                pos++;\r\n            }\r\n\r\n            Debug.assert(resultingToken !== undefined);\r\n\r\n            tokenValue = contents;\r\n            return resultingToken;\r\n        }\r\n\r\n        function scanEscapeSequence(): string {\r\n            pos++;\r\n            if (pos >= end) {\r\n                error(Diagnostics.Unexpected_end_of_text);\r\n                return \"\";\r\n            }\r\n            const ch = text.charCodeAt(pos);\r\n            pos++;\r\n            switch (ch) {\r\n                case CharacterCodes._0:\r\n                    return \"\\0\";\r\n                case CharacterCodes.b:\r\n                    return \"\\b\";\r\n                case CharacterCodes.t:\r\n                    return \"\\t\";\r\n                case CharacterCodes.n:\r\n                    return \"\\n\";\r\n                case CharacterCodes.v:\r\n                    return \"\\v\";\r\n                case CharacterCodes.f:\r\n                    return \"\\f\";\r\n                case CharacterCodes.r:\r\n                    return \"\\r\";\r\n                case CharacterCodes.singleQuote:\r\n                    return \"\\'\";\r\n                case CharacterCodes.doubleQuote:\r\n                    return \"\\\"\";\r\n                case CharacterCodes.u:\r\n                    // '\\u{DDDDDDDD}'\r\n                    if (pos < end && text.charCodeAt(pos) === CharacterCodes.openBrace) {\r\n                        tokenFlags |= TokenFlags.ExtendedUnicodeEscape;\r\n                        pos++;\r\n                        return scanExtendedUnicodeEscape();\r\n                    }\r\n\r\n                    // '\\uDDDD'\r\n                    return scanHexadecimalEscape(/*numDigits*/ 4);\r\n\r\n                case CharacterCodes.x:\r\n                    // '\\xDD'\r\n                    return scanHexadecimalEscape(/*numDigits*/ 2);\r\n\r\n                // when encountering a LineContinuation (i.e. a backslash and a line terminator sequence),\r\n                // the line terminator is interpreted to be \"the empty code unit sequence\".\r\n                case CharacterCodes.carriageReturn:\r\n                    if (pos < end && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n                    // falls through\r\n                case CharacterCodes.lineFeed:\r\n                case CharacterCodes.lineSeparator:\r\n                case CharacterCodes.paragraphSeparator:\r\n                    return \"\";\r\n                default:\r\n                    return String.fromCharCode(ch);\r\n            }\r\n        }\r\n\r\n        function scanHexadecimalEscape(numDigits: number): string {\r\n            const escapedValue = scanExactNumberOfHexDigits(numDigits, /*canHaveSeparators*/ false);\r\n\r\n            if (escapedValue >= 0) {\r\n                return String.fromCharCode(escapedValue);\r\n            }\r\n            else {\r\n                error(Diagnostics.Hexadecimal_digit_expected);\r\n                return \"\";\r\n            }\r\n        }\r\n\r\n        function scanExtendedUnicodeEscape(): string {\r\n            const escapedValue = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ false);\r\n            let isInvalidExtendedEscape = false;\r\n\r\n            // Validate the value of the digit\r\n            if (escapedValue < 0) {\r\n                error(Diagnostics.Hexadecimal_digit_expected);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n            else if (escapedValue > 0x10FFFF) {\r\n                error(Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n\r\n            if (pos >= end) {\r\n                error(Diagnostics.Unexpected_end_of_text);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n            else if (text.charCodeAt(pos) === CharacterCodes.closeBrace) {\r\n                // Only swallow the following character up if it's a '}'.\r\n                pos++;\r\n            }\r\n            else {\r\n                error(Diagnostics.Unterminated_Unicode_escape_sequence);\r\n                isInvalidExtendedEscape = true;\r\n            }\r\n\r\n            if (isInvalidExtendedEscape) {\r\n                return \"\";\r\n            }\r\n\r\n            return utf16EncodeAsString(escapedValue);\r\n        }\r\n\r\n        // Derived from the 10.1.1 UTF16Encoding of the ES6 Spec.\r\n        function utf16EncodeAsString(codePoint: number): string {\r\n            Debug.assert(0x0 <= codePoint && codePoint <= 0x10FFFF);\r\n\r\n            if (codePoint <= 65535) {\r\n                return String.fromCharCode(codePoint);\r\n            }\r\n\r\n            const codeUnit1 = Math.floor((codePoint - 65536) / 1024) + 0xD800;\r\n            const codeUnit2 = ((codePoint - 65536) % 1024) + 0xDC00;\r\n\r\n            return String.fromCharCode(codeUnit1, codeUnit2);\r\n        }\r\n\r\n        // Current character is known to be a backslash. Check for Unicode escape of the form '\\uXXXX'\r\n        // and return code point value if valid Unicode escape is found. Otherwise return -1.\r\n        function peekUnicodeEscape(): number {\r\n            if (pos + 5 < end && text.charCodeAt(pos + 1) === CharacterCodes.u) {\r\n                const start = pos;\r\n                pos += 2;\r\n                const value = scanExactNumberOfHexDigits(4, /*canHaveSeparators*/ false);\r\n                pos = start;\r\n                return value;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        function scanIdentifierParts(): string {\r\n            let result = \"\";\r\n            let start = pos;\r\n            while (pos < end) {\r\n                let ch = text.charCodeAt(pos);\r\n                if (isIdentifierPart(ch, languageVersion)) {\r\n                    pos++;\r\n                }\r\n                else if (ch === CharacterCodes.backslash) {\r\n                    ch = peekUnicodeEscape();\r\n                    if (!(ch >= 0 && isIdentifierPart(ch, languageVersion))) {\r\n                        break;\r\n                    }\r\n                    result += text.substring(start, pos);\r\n                    result += String.fromCharCode(ch);\r\n                    // Valid Unicode escape is always six characters\r\n                    pos += 6;\r\n                    start = pos;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            result += text.substring(start, pos);\r\n            return result;\r\n        }\r\n\r\n        function getIdentifierToken(): SyntaxKind {\r\n            // Reserved words are between 2 and 11 characters long and start with a lowercase letter\r\n            const len = tokenValue.length;\r\n            if (len >= 2 && len <= 11) {\r\n                const ch = tokenValue.charCodeAt(0);\r\n                if (ch >= CharacterCodes.a && ch <= CharacterCodes.z) {\r\n                    token = textToToken.get(tokenValue);\r\n                    if (token !== undefined) {\r\n                        return token;\r\n                    }\r\n                }\r\n            }\r\n            return token = SyntaxKind.Identifier;\r\n        }\r\n\r\n        function scanBinaryOrOctalDigits(base: number): number {\r\n            Debug.assert(base === 2 || base === 8, \"Expected either base 2 or base 8\");\r\n\r\n            let value = 0;\r\n            // For counting number of digits; Valid binaryIntegerLiteral must have at least one binary digit following B or b.\r\n            // Similarly valid octalIntegerLiteral must have at least one octal digit following o or O.\r\n            let numberOfDigits = 0;\r\n            let separatorAllowed = false;\r\n            let isPreviousTokenSeparator = false;\r\n            while (true) {\r\n                const ch = text.charCodeAt(pos);\r\n                // Numeric seperators are allowed anywhere within a numeric literal, except not at the beginning, or following another separator\r\n                if (ch === CharacterCodes._) {\r\n                    tokenFlags |= TokenFlags.ContainsSeparator;\r\n                    if (separatorAllowed) {\r\n                        separatorAllowed = false;\r\n                        isPreviousTokenSeparator = true;\r\n                    }\r\n                    else if (isPreviousTokenSeparator) {\r\n                        error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);\r\n                    }\r\n                    else {\r\n                        error(Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);\r\n                    }\r\n                    pos++;\r\n                    continue;\r\n                }\r\n                separatorAllowed = true;\r\n                const valueOfCh = ch - CharacterCodes._0;\r\n                if (!isDigit(ch) || valueOfCh >= base) {\r\n                    break;\r\n                }\r\n                value = value * base + valueOfCh;\r\n                pos++;\r\n                numberOfDigits++;\r\n                isPreviousTokenSeparator = false;\r\n            }\r\n            // Invalid binaryIntegerLiteral or octalIntegerLiteral\r\n            if (numberOfDigits === 0) {\r\n                return -1;\r\n            }\r\n            if (text.charCodeAt(pos - 1) === CharacterCodes._) {\r\n                // Literal ends with underscore - not allowed\r\n                error(Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);\r\n                return value;\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function scan(): SyntaxKind {\r\n            startPos = pos;\r\n            tokenFlags = 0;\r\n            while (true) {\r\n                tokenPos = pos;\r\n                if (pos >= end) {\r\n                    return token = SyntaxKind.EndOfFileToken;\r\n                }\r\n                let ch = text.charCodeAt(pos);\r\n\r\n                // Special handling for shebang\r\n                if (ch === CharacterCodes.hash && pos === 0 && isShebangTrivia(text, pos)) {\r\n                    pos = scanShebangTrivia(text, pos);\r\n                    if (skipTrivia) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        return token = SyntaxKind.ShebangTrivia;\r\n                    }\r\n                }\r\n\r\n                switch (ch) {\r\n                    case CharacterCodes.lineFeed:\r\n                    case CharacterCodes.carriageReturn:\r\n                        tokenFlags |= TokenFlags.PrecedingLineBreak;\r\n                        if (skipTrivia) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        else {\r\n                            if (ch === CharacterCodes.carriageReturn && pos + 1 < end && text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) {\r\n                                // consume both CR and LF\r\n                                pos += 2;\r\n                            }\r\n                            else {\r\n                                pos++;\r\n                            }\r\n                            return token = SyntaxKind.NewLineTrivia;\r\n                        }\r\n                    case CharacterCodes.tab:\r\n                    case CharacterCodes.verticalTab:\r\n                    case CharacterCodes.formFeed:\r\n                    case CharacterCodes.space:\r\n                        if (skipTrivia) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        else {\r\n                            while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {\r\n                                pos++;\r\n                            }\r\n                            return token = SyntaxKind.WhitespaceTrivia;\r\n                        }\r\n                    case CharacterCodes.exclamation:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.ExclamationEqualsEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.ExclamationEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.ExclamationToken;\r\n                    case CharacterCodes.doubleQuote:\r\n                    case CharacterCodes.singleQuote:\r\n                        tokenValue = scanString();\r\n                        return token = SyntaxKind.StringLiteral;\r\n                    case CharacterCodes.backtick:\r\n                        return token = scanTemplateAndSetTokenValue();\r\n                    case CharacterCodes.percent:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.PercentEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.PercentToken;\r\n                    case CharacterCodes.ampersand:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.ampersand) {\r\n                            return pos += 2, token = SyntaxKind.AmpersandAmpersandToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.AmpersandEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.AmpersandToken;\r\n                    case CharacterCodes.openParen:\r\n                        pos++;\r\n                        return token = SyntaxKind.OpenParenToken;\r\n                    case CharacterCodes.closeParen:\r\n                        pos++;\r\n                        return token = SyntaxKind.CloseParenToken;\r\n                    case CharacterCodes.asterisk:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.AsteriskEqualsToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.AsteriskAsteriskEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.AsteriskAsteriskToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.AsteriskToken;\r\n                    case CharacterCodes.plus:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.plus) {\r\n                            return pos += 2, token = SyntaxKind.PlusPlusToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.PlusEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.PlusToken;\r\n                    case CharacterCodes.comma:\r\n                        pos++;\r\n                        return token = SyntaxKind.CommaToken;\r\n                    case CharacterCodes.minus:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.minus) {\r\n                            return pos += 2, token = SyntaxKind.MinusMinusToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.MinusEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.MinusToken;\r\n                    case CharacterCodes.dot:\r\n                        if (isDigit(text.charCodeAt(pos + 1))) {\r\n                            tokenValue = scanNumber();\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.dot && text.charCodeAt(pos + 2) === CharacterCodes.dot) {\r\n                            return pos += 3, token = SyntaxKind.DotDotDotToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.DotToken;\r\n                    case CharacterCodes.slash:\r\n                        // Single-line comment\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                            pos += 2;\r\n\r\n                            while (pos < end) {\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n\r\n                            }\r\n\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.SingleLineCommentTrivia;\r\n                            }\r\n                        }\r\n                        // Multi-line comment\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                            pos += 2;\r\n                            if (text.charCodeAt(pos) === CharacterCodes.asterisk && text.charCodeAt(pos + 1) !== CharacterCodes.slash) {\r\n                                tokenFlags |= TokenFlags.PrecedingJSDocComment;\r\n                            }\r\n\r\n                            let commentClosed = false;\r\n                            while (pos < end) {\r\n                                const ch = text.charCodeAt(pos);\r\n\r\n                                if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                    pos += 2;\r\n                                    commentClosed = true;\r\n                                    break;\r\n                                }\r\n\r\n                                if (isLineBreak(ch)) {\r\n                                    tokenFlags |= TokenFlags.PrecedingLineBreak;\r\n                                }\r\n                                pos++;\r\n                            }\r\n\r\n                            if (!commentClosed) {\r\n                                error(Diagnostics.Asterisk_Slash_expected);\r\n                            }\r\n\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                if (!commentClosed) {\r\n                                    tokenFlags |= TokenFlags.Unterminated;\r\n                                }\r\n                                return token = SyntaxKind.MultiLineCommentTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.SlashEqualsToken;\r\n                        }\r\n\r\n                        pos++;\r\n                        return token = SyntaxKind.SlashToken;\r\n\r\n                    case CharacterCodes._0:\r\n                        if (pos + 2 < end && (text.charCodeAt(pos + 1) === CharacterCodes.X || text.charCodeAt(pos + 1) === CharacterCodes.x)) {\r\n                            pos += 2;\r\n                            let value = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ true);\r\n                            if (value < 0) {\r\n                                error(Diagnostics.Hexadecimal_digit_expected);\r\n                                value = 0;\r\n                            }\r\n                            tokenValue = \"\" + value;\r\n                            tokenFlags |= TokenFlags.HexSpecifier;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === CharacterCodes.B || text.charCodeAt(pos + 1) === CharacterCodes.b)) {\r\n                            pos += 2;\r\n                            let value = scanBinaryOrOctalDigits(/* base */ 2);\r\n                            if (value < 0) {\r\n                                error(Diagnostics.Binary_digit_expected);\r\n                                value = 0;\r\n                            }\r\n                            tokenValue = \"\" + value;\r\n                            tokenFlags |= TokenFlags.BinarySpecifier;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === CharacterCodes.O || text.charCodeAt(pos + 1) === CharacterCodes.o)) {\r\n                            pos += 2;\r\n                            let value = scanBinaryOrOctalDigits(/* base */ 8);\r\n                            if (value < 0) {\r\n                                error(Diagnostics.Octal_digit_expected);\r\n                                value = 0;\r\n                            }\r\n                            tokenValue = \"\" + value;\r\n                            tokenFlags |= TokenFlags.OctalSpecifier;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        // Try to parse as an octal\r\n                        if (pos + 1 < end && isOctalDigit(text.charCodeAt(pos + 1))) {\r\n                            tokenValue = \"\" + scanOctalDigits();\r\n                            tokenFlags |= TokenFlags.Octal;\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        // This fall-through is a deviation from the EcmaScript grammar. The grammar says that a leading zero\r\n                        // can only be followed by an octal digit, a dot, or the end of the number literal. However, we are being\r\n                        // permissive and allowing decimal digits of the form 08* and 09* (which many browsers also do).\r\n                        // falls through\r\n                    case CharacterCodes._1:\r\n                    case CharacterCodes._2:\r\n                    case CharacterCodes._3:\r\n                    case CharacterCodes._4:\r\n                    case CharacterCodes._5:\r\n                    case CharacterCodes._6:\r\n                    case CharacterCodes._7:\r\n                    case CharacterCodes._8:\r\n                    case CharacterCodes._9:\r\n                        tokenValue = scanNumber();\r\n                        return token = SyntaxKind.NumericLiteral;\r\n                    case CharacterCodes.colon:\r\n                        pos++;\r\n                        return token = SyntaxKind.ColonToken;\r\n                    case CharacterCodes.semicolon:\r\n                        pos++;\r\n                        return token = SyntaxKind.SemicolonToken;\r\n                    case CharacterCodes.lessThan:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.lessThan) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.LessThanLessThanEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.LessThanLessThanToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.LessThanEqualsToken;\r\n                        }\r\n                        if (languageVariant === LanguageVariant.JSX &&\r\n                                text.charCodeAt(pos + 1) === CharacterCodes.slash &&\r\n                                text.charCodeAt(pos + 2) !== CharacterCodes.asterisk) {\r\n                            return pos += 2, token = SyntaxKind.LessThanSlashToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.LessThanToken;\r\n                    case CharacterCodes.equals:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.EqualsEqualsEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.EqualsEqualsToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.greaterThan) {\r\n                            return pos += 2, token = SyntaxKind.EqualsGreaterThanToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.EqualsToken;\r\n                    case CharacterCodes.greaterThan:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        pos++;\r\n                        return token = SyntaxKind.GreaterThanToken;\r\n                    case CharacterCodes.question:\r\n                        pos++;\r\n                        return token = SyntaxKind.QuestionToken;\r\n                    case CharacterCodes.openBracket:\r\n                        pos++;\r\n                        return token = SyntaxKind.OpenBracketToken;\r\n                    case CharacterCodes.closeBracket:\r\n                        pos++;\r\n                        return token = SyntaxKind.CloseBracketToken;\r\n                    case CharacterCodes.caret:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.CaretEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.CaretToken;\r\n                    case CharacterCodes.openBrace:\r\n                        pos++;\r\n                        return token = SyntaxKind.OpenBraceToken;\r\n                    case CharacterCodes.bar:\r\n                        if (isConflictMarkerTrivia(text, pos)) {\r\n                            pos = scanConflictMarkerTrivia(text, pos, error);\r\n                            if (skipTrivia) {\r\n                                continue;\r\n                            }\r\n                            else {\r\n                                return token = SyntaxKind.ConflictMarkerTrivia;\r\n                            }\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.bar) {\r\n                            return pos += 2, token = SyntaxKind.BarBarToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.BarEqualsToken;\r\n                        }\r\n                        pos++;\r\n                        return token = SyntaxKind.BarToken;\r\n                    case CharacterCodes.closeBrace:\r\n                        pos++;\r\n                        return token = SyntaxKind.CloseBraceToken;\r\n                    case CharacterCodes.tilde:\r\n                        pos++;\r\n                        return token = SyntaxKind.TildeToken;\r\n                    case CharacterCodes.at:\r\n                        pos++;\r\n                        return token = SyntaxKind.AtToken;\r\n                    case CharacterCodes.backslash:\r\n                        const cookedChar = peekUnicodeEscape();\r\n                        if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {\r\n                            pos += 6;\r\n                            tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();\r\n                            return token = getIdentifierToken();\r\n                        }\r\n                        error(Diagnostics.Invalid_character);\r\n                        pos++;\r\n                        return token = SyntaxKind.Unknown;\r\n                    default:\r\n                        if (isIdentifierStart(ch, languageVersion)) {\r\n                            pos++;\r\n                            while (pos < end && isIdentifierPart(ch = text.charCodeAt(pos), languageVersion)) pos++;\r\n                            tokenValue = text.substring(tokenPos, pos);\r\n                            if (ch === CharacterCodes.backslash) {\r\n                                tokenValue += scanIdentifierParts();\r\n                            }\r\n                            return token = getIdentifierToken();\r\n                        }\r\n                        else if (isWhiteSpaceSingleLine(ch)) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        else if (isLineBreak(ch)) {\r\n                            tokenFlags |= TokenFlags.PrecedingLineBreak;\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        error(Diagnostics.Invalid_character);\r\n                        pos++;\r\n                        return token = SyntaxKind.Unknown;\r\n                }\r\n            }\r\n        }\r\n\r\n        function reScanGreaterToken(): SyntaxKind {\r\n            if (token === SyntaxKind.GreaterThanToken) {\r\n                if (text.charCodeAt(pos) === CharacterCodes.greaterThan) {\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.greaterThan) {\r\n                        if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                            return pos += 3, token = SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken;\r\n                        }\r\n                        return pos += 2, token = SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\r\n                    }\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                        return pos += 2, token = SyntaxKind.GreaterThanGreaterThanEqualsToken;\r\n                    }\r\n                    pos++;\r\n                    return token = SyntaxKind.GreaterThanGreaterThanToken;\r\n                }\r\n                if (text.charCodeAt(pos) === CharacterCodes.equals) {\r\n                    pos++;\r\n                    return token = SyntaxKind.GreaterThanEqualsToken;\r\n                }\r\n            }\r\n            return token;\r\n        }\r\n\r\n        function reScanSlashToken(): SyntaxKind {\r\n            if (token === SyntaxKind.SlashToken || token === SyntaxKind.SlashEqualsToken) {\r\n                let p = tokenPos + 1;\r\n                let inEscape = false;\r\n                let inCharacterClass = false;\r\n                while (true) {\r\n                    // If we reach the end of a file, or hit a newline, then this is an unterminated\r\n                    // regex.  Report error and return what we have so far.\r\n                    if (p >= end) {\r\n                        tokenFlags |= TokenFlags.Unterminated;\r\n                        error(Diagnostics.Unterminated_regular_expression_literal);\r\n                        break;\r\n                    }\r\n\r\n                    const ch = text.charCodeAt(p);\r\n                    if (isLineBreak(ch)) {\r\n                        tokenFlags |= TokenFlags.Unterminated;\r\n                        error(Diagnostics.Unterminated_regular_expression_literal);\r\n                        break;\r\n                    }\r\n\r\n                    if (inEscape) {\r\n                        // Parsing an escape character;\r\n                        // reset the flag and just advance to the next char.\r\n                        inEscape = false;\r\n                    }\r\n                    else if (ch === CharacterCodes.slash && !inCharacterClass) {\r\n                        // A slash within a character class is permissible,\r\n                        // but in general it signals the end of the regexp literal.\r\n                        p++;\r\n                        break;\r\n                    }\r\n                    else if (ch === CharacterCodes.openBracket) {\r\n                        inCharacterClass = true;\r\n                    }\r\n                    else if (ch === CharacterCodes.backslash) {\r\n                        inEscape = true;\r\n                    }\r\n                    else if (ch === CharacterCodes.closeBracket) {\r\n                        inCharacterClass = false;\r\n                    }\r\n                    p++;\r\n                }\r\n\r\n                while (p < end && isIdentifierPart(text.charCodeAt(p), languageVersion)) {\r\n                    p++;\r\n                }\r\n                pos = p;\r\n                tokenValue = text.substring(tokenPos, pos);\r\n                token = SyntaxKind.RegularExpressionLiteral;\r\n            }\r\n            return token;\r\n        }\r\n\r\n        /**\r\n         * Unconditionally back up and scan a template expression portion.\r\n         */\r\n        function reScanTemplateToken(): SyntaxKind {\r\n            Debug.assert(token === SyntaxKind.CloseBraceToken, \"'reScanTemplateToken' should only be called on a '}'\");\r\n            pos = tokenPos;\r\n            return token = scanTemplateAndSetTokenValue();\r\n        }\r\n\r\n        function reScanJsxToken(): JsxTokenSyntaxKind {\r\n            pos = tokenPos = startPos;\r\n            return token = scanJsxToken();\r\n        }\r\n\r\n        function scanJsxToken(): JsxTokenSyntaxKind {\r\n            startPos = tokenPos = pos;\r\n\r\n            if (pos >= end) {\r\n                return token = SyntaxKind.EndOfFileToken;\r\n            }\r\n\r\n            let char = text.charCodeAt(pos);\r\n            if (char === CharacterCodes.lessThan) {\r\n                if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                    pos += 2;\r\n                    return token = SyntaxKind.LessThanSlashToken;\r\n                }\r\n                pos++;\r\n                return token = SyntaxKind.LessThanToken;\r\n            }\r\n\r\n            if (char === CharacterCodes.openBrace) {\r\n                pos++;\r\n                return token = SyntaxKind.OpenBraceToken;\r\n            }\r\n\r\n            // First non-whitespace character on this line.\r\n            let firstNonWhitespace = 0;\r\n            // These initial values are special because the first line is:\r\n            // firstNonWhitespace = 0 to indicate that we want leading whitspace,\r\n\r\n            while (pos < end) {\r\n                char = text.charCodeAt(pos);\r\n                if (char === CharacterCodes.openBrace) {\r\n                    break;\r\n                }\r\n                if (char === CharacterCodes.lessThan) {\r\n                    if (isConflictMarkerTrivia(text, pos)) {\r\n                        pos = scanConflictMarkerTrivia(text, pos, error);\r\n                        return token = SyntaxKind.ConflictMarkerTrivia;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                // FirstNonWhitespace is 0, then we only see whitespaces so far. If we see a linebreak, we want to ignore that whitespaces.\r\n                // i.e (- : whitespace)\r\n                //      <div>----\r\n                //      </div> becomes <div></div>\r\n                //\r\n                //      <div>----</div> becomes <div>----</div>\r\n                if (isLineBreak(char) && firstNonWhitespace === 0) {\r\n                    firstNonWhitespace = -1;\r\n                }\r\n                else if (!isWhiteSpaceLike(char)) {\r\n                    firstNonWhitespace = pos;\r\n                }\r\n                pos++;\r\n            }\r\n\r\n            return firstNonWhitespace === -1 ? SyntaxKind.JsxTextAllWhiteSpaces : SyntaxKind.JsxText;\r\n        }\r\n\r\n        // Scans a JSX identifier; these differ from normal identifiers in that\r\n        // they allow dashes\r\n        function scanJsxIdentifier(): SyntaxKind {\r\n            if (tokenIsIdentifierOrKeyword(token)) {\r\n                const firstCharPosition = pos;\r\n                while (pos < end) {\r\n                    const ch = text.charCodeAt(pos);\r\n                    if (ch === CharacterCodes.minus || ((firstCharPosition === pos) ? isIdentifierStart(ch, languageVersion) : isIdentifierPart(ch, languageVersion))) {\r\n                        pos++;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                tokenValue += text.substring(firstCharPosition, pos);\r\n            }\r\n            return token;\r\n        }\r\n\r\n        function scanJsxAttributeValue(): SyntaxKind {\r\n            startPos = pos;\r\n\r\n            switch (text.charCodeAt(pos)) {\r\n                case CharacterCodes.doubleQuote:\r\n                case CharacterCodes.singleQuote:\r\n                    tokenValue = scanString(/*jsxAttributeString*/ true);\r\n                    return token = SyntaxKind.StringLiteral;\r\n                default:\r\n                    // If this scans anything other than `{`, it's a parse error.\r\n                    return scan();\r\n            }\r\n        }\r\n\r\n        function scanJSDocToken(): JsDocSyntaxKind {\r\n            if (pos >= end) {\r\n                return token = SyntaxKind.EndOfFileToken;\r\n            }\r\n\r\n            startPos = pos;\r\n            tokenPos = pos;\r\n\r\n            const ch = text.charCodeAt(pos);\r\n            pos++;\r\n            switch (ch) {\r\n                case CharacterCodes.tab:\r\n                case CharacterCodes.verticalTab:\r\n                case CharacterCodes.formFeed:\r\n                case CharacterCodes.space:\r\n                    while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {\r\n                        pos++;\r\n                    }\r\n                    return token = SyntaxKind.WhitespaceTrivia;\r\n                case CharacterCodes.at:\r\n                    return token = SyntaxKind.AtToken;\r\n                case CharacterCodes.lineFeed:\r\n                case CharacterCodes.carriageReturn:\r\n                    return token = SyntaxKind.NewLineTrivia;\r\n                case CharacterCodes.asterisk:\r\n                    return token = SyntaxKind.AsteriskToken;\r\n                case CharacterCodes.openBrace:\r\n                    return token = SyntaxKind.OpenBraceToken;\r\n                case CharacterCodes.closeBrace:\r\n                    return token = SyntaxKind.CloseBraceToken;\r\n                case CharacterCodes.openBracket:\r\n                    return token = SyntaxKind.OpenBracketToken;\r\n                case CharacterCodes.closeBracket:\r\n                    return token = SyntaxKind.CloseBracketToken;\r\n                case CharacterCodes.lessThan:\r\n                    return token = SyntaxKind.LessThanToken;\r\n                case CharacterCodes.equals:\r\n                    return token = SyntaxKind.EqualsToken;\r\n                case CharacterCodes.comma:\r\n                    return token = SyntaxKind.CommaToken;\r\n                case CharacterCodes.dot:\r\n                    return token = SyntaxKind.DotToken;\r\n                case CharacterCodes.backtick:\r\n                    while (pos < end && text.charCodeAt(pos) !== CharacterCodes.backtick) {\r\n                        pos++;\r\n                    }\r\n                    tokenValue = text.substring(tokenPos + 1, pos);\r\n                    pos++;\r\n                    return token = SyntaxKind.NoSubstitutionTemplateLiteral;\r\n            }\r\n\r\n            if (isIdentifierStart(ch, ScriptTarget.Latest)) {\r\n                while (isIdentifierPart(text.charCodeAt(pos), ScriptTarget.Latest) && pos < end) {\r\n                    pos++;\r\n                }\r\n                tokenValue = text.substring(tokenPos, pos);\r\n                return token = SyntaxKind.Identifier;\r\n            }\r\n            else {\r\n                return token = SyntaxKind.Unknown;\r\n            }\r\n        }\r\n\r\n        function speculationHelper<T>(callback: () => T, isLookahead: boolean): T {\r\n            const savePos = pos;\r\n            const saveStartPos = startPos;\r\n            const saveTokenPos = tokenPos;\r\n            const saveToken = token;\r\n            const saveTokenValue = tokenValue;\r\n            const saveTokenFlags = tokenFlags;\r\n            const result = callback();\r\n\r\n            // If our callback returned something 'falsy' or we're just looking ahead,\r\n            // then unconditionally restore us to where we were.\r\n            if (!result || isLookahead) {\r\n                pos = savePos;\r\n                startPos = saveStartPos;\r\n                tokenPos = saveTokenPos;\r\n                token = saveToken;\r\n                tokenValue = saveTokenValue;\r\n                tokenFlags = saveTokenFlags;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function scanRange<T>(start: number, length: number, callback: () => T): T {\r\n            const saveEnd = end;\r\n            const savePos = pos;\r\n            const saveStartPos = startPos;\r\n            const saveTokenPos = tokenPos;\r\n            const saveToken = token;\r\n            const saveTokenValue = tokenValue;\r\n            const saveTokenFlags = tokenFlags;\r\n\r\n            setText(text, start, length);\r\n            const result = callback();\r\n\r\n            end = saveEnd;\r\n            pos = savePos;\r\n            startPos = saveStartPos;\r\n            tokenPos = saveTokenPos;\r\n            token = saveToken;\r\n            tokenValue = saveTokenValue;\r\n            tokenFlags = saveTokenFlags;\r\n\r\n            return result;\r\n        }\r\n\r\n        function lookAhead<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookahead*/ true);\r\n        }\r\n\r\n        function tryScan<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookahead*/ false);\r\n        }\r\n\r\n        function getText(): string {\r\n            return text;\r\n        }\r\n\r\n        function setText(newText: string, start: number, length: number) {\r\n            text = newText || \"\";\r\n            end = length === undefined ? text.length : start + length;\r\n            setTextPos(start || 0);\r\n        }\r\n\r\n        function setOnError(errorCallback: ErrorCallback) {\r\n            onError = errorCallback;\r\n        }\r\n\r\n        function setScriptTarget(scriptTarget: ScriptTarget) {\r\n            languageVersion = scriptTarget;\r\n        }\r\n\r\n        function setLanguageVariant(variant: LanguageVariant) {\r\n            languageVariant = variant;\r\n        }\r\n\r\n        function setTextPos(textPos: number) {\r\n            Debug.assert(textPos >= 0);\r\n            pos = textPos;\r\n            startPos = textPos;\r\n            tokenPos = textPos;\r\n            token = SyntaxKind.Unknown;\r\n            tokenValue = undefined;\r\n            tokenFlags = 0;\r\n        }\r\n    }\r\n}\r\n","namespace ts {\r\n    const enum SignatureFlags {\r\n        None = 0,\r\n        Yield = 1 << 0,\r\n        Await = 1 << 1,\r\n        Type  = 1 << 2,\r\n        RequireCompleteParameterList = 1 << 3,\r\n        IgnoreMissingOpenBrace = 1 << 4,\r\n        JSDoc = 1 << 5,\r\n    }\r\n\r\n    // tslint:disable variable-name\r\n    let NodeConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    let TokenConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    let IdentifierConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    let SourceFileConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n    // tslint:enable variable-name\r\n\r\n    export function createNode(kind: SyntaxKind, pos?: number, end?: number): Node {\r\n        if (kind === SyntaxKind.SourceFile) {\r\n            return new (SourceFileConstructor || (SourceFileConstructor = objectAllocator.getSourceFileConstructor()))(kind, pos, end);\r\n        }\r\n        else if (kind === SyntaxKind.Identifier) {\r\n            return new (IdentifierConstructor || (IdentifierConstructor = objectAllocator.getIdentifierConstructor()))(kind, pos, end);\r\n        }\r\n        else if (!isNodeKind(kind)) {\r\n            return new (TokenConstructor || (TokenConstructor = objectAllocator.getTokenConstructor()))(kind, pos, end);\r\n        }\r\n        else {\r\n            return new (NodeConstructor || (NodeConstructor = objectAllocator.getNodeConstructor()))(kind, pos, end);\r\n        }\r\n    }\r\n\r\n    function visitNode<T>(cbNode: (node: Node) => T, node: Node): T | undefined {\r\n        return node && cbNode(node);\r\n    }\r\n\r\n    function visitNodes<T>(cbNode: (node: Node) => T, cbNodes: (node: NodeArray<Node>) => T | undefined, nodes: NodeArray<Node>): T | undefined {\r\n        if (nodes) {\r\n            if (cbNodes) {\r\n                return cbNodes(nodes);\r\n            }\r\n            for (const node of nodes) {\r\n                const result = cbNode(node);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*@internal*/\r\n    export function isJSDocLikeText(text: string, start: number) {\r\n        return text.charCodeAt(start + 1) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(start + 2) === CharacterCodes.asterisk &&\r\n            text.charCodeAt(start + 3) !== CharacterCodes.slash;\r\n    }\r\n\r\n    /**\r\n     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes\r\n     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,\r\n     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns\r\n     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\r\n     *\r\n     * @param node a given node to visit its children\r\n     * @param cbNode a callback to be invoked for all child nodes\r\n     * @param cbNodes a callback to be invoked for embedded array\r\n     *\r\n     * @remarks `forEachChild` must visit the children of a node in the order\r\n     * that they appear in the source code. The language service depends on this property to locate nodes by position.\r\n     */\r\n    export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined {\r\n        if (!node || node.kind <= SyntaxKind.LastToken) {\r\n            return;\r\n        }\r\n        switch (node.kind) {\r\n            case SyntaxKind.QualifiedName:\r\n                return visitNode(cbNode, (<QualifiedName>node).left) ||\r\n                    visitNode(cbNode, (<QualifiedName>node).right);\r\n            case SyntaxKind.TypeParameter:\r\n                return visitNode(cbNode, (<TypeParameterDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<TypeParameterDeclaration>node).constraint) ||\r\n                    visitNode(cbNode, (<TypeParameterDeclaration>node).default) ||\r\n                    visitNode(cbNode, (<TypeParameterDeclaration>node).expression);\r\n            case SyntaxKind.ShorthandPropertyAssignment:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).name) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).questionToken) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).equalsToken) ||\r\n                    visitNode(cbNode, (<ShorthandPropertyAssignment>node).objectAssignmentInitializer);\r\n            case SyntaxKind.SpreadAssignment:\r\n                return visitNode(cbNode, (<SpreadAssignment>node).expression);\r\n            case SyntaxKind.Parameter:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ParameterDeclaration>node).dotDotDotToken) ||\r\n                    visitNode(cbNode, (<ParameterDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<ParameterDeclaration>node).questionToken) ||\r\n                    visitNode(cbNode, (<ParameterDeclaration>node).type) ||\r\n                    visitNode(cbNode, (<ParameterDeclaration>node).initializer);\r\n            case SyntaxKind.PropertyDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<PropertyDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<PropertyDeclaration>node).questionToken) ||\r\n                    visitNode(cbNode, (<PropertyDeclaration>node).exclamationToken) ||\r\n                    visitNode(cbNode, (<PropertyDeclaration>node).type) ||\r\n                    visitNode(cbNode, (<PropertyDeclaration>node).initializer);\r\n            case SyntaxKind.PropertySignature:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<PropertySignature>node).name) ||\r\n                    visitNode(cbNode, (<PropertySignature>node).questionToken) ||\r\n                    visitNode(cbNode, (<PropertySignature>node).type) ||\r\n                    visitNode(cbNode, (<PropertySignature>node).initializer);\r\n            case SyntaxKind.PropertyAssignment:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<PropertyAssignment>node).name) ||\r\n                    visitNode(cbNode, (<PropertyAssignment>node).questionToken) ||\r\n                    visitNode(cbNode, (<PropertyAssignment>node).initializer);\r\n            case SyntaxKind.VariableDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<VariableDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<VariableDeclaration>node).exclamationToken) ||\r\n                    visitNode(cbNode, (<VariableDeclaration>node).type) ||\r\n                    visitNode(cbNode, (<VariableDeclaration>node).initializer);\r\n            case SyntaxKind.BindingElement:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<BindingElement>node).dotDotDotToken) ||\r\n                    visitNode(cbNode, (<BindingElement>node).propertyName) ||\r\n                    visitNode(cbNode, (<BindingElement>node).name) ||\r\n                    visitNode(cbNode, (<BindingElement>node).initializer);\r\n            case SyntaxKind.FunctionType:\r\n            case SyntaxKind.ConstructorType:\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.IndexSignature:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNodes(cbNode, cbNodes, (<SignatureDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<SignatureDeclaration>node).parameters) ||\r\n                    visitNode(cbNode, (<SignatureDeclaration>node).type);\r\n            case SyntaxKind.MethodDeclaration:\r\n            case SyntaxKind.MethodSignature:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.ArrowFunction:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).asteriskToken) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).questionToken) ||\r\n                    visitNodes(cbNode, cbNodes, (<FunctionLikeDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<FunctionLikeDeclaration>node).parameters) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).type) ||\r\n                    visitNode(cbNode, (<ArrowFunction>node).equalsGreaterThanToken) ||\r\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).body);\r\n            case SyntaxKind.TypeReference:\r\n                return visitNode(cbNode, (<TypeReferenceNode>node).typeName) ||\r\n                    visitNodes(cbNode, cbNodes, (<TypeReferenceNode>node).typeArguments);\r\n            case SyntaxKind.TypePredicate:\r\n                return visitNode(cbNode, (<TypePredicateNode>node).parameterName) ||\r\n                    visitNode(cbNode, (<TypePredicateNode>node).type);\r\n            case SyntaxKind.TypeQuery:\r\n                return visitNode(cbNode, (<TypeQueryNode>node).exprName);\r\n            case SyntaxKind.TypeLiteral:\r\n                return visitNodes(cbNode, cbNodes, (<TypeLiteralNode>node).members);\r\n            case SyntaxKind.ArrayType:\r\n                return visitNode(cbNode, (<ArrayTypeNode>node).elementType);\r\n            case SyntaxKind.TupleType:\r\n                return visitNodes(cbNode, cbNodes, (<TupleTypeNode>node).elementTypes);\r\n            case SyntaxKind.UnionType:\r\n            case SyntaxKind.IntersectionType:\r\n                return visitNodes(cbNode, cbNodes, (<UnionOrIntersectionTypeNode>node).types);\r\n            case SyntaxKind.ConditionalType:\r\n                return visitNode(cbNode, (<ConditionalTypeNode>node).checkType) ||\r\n                    visitNode(cbNode, (<ConditionalTypeNode>node).extendsType) ||\r\n                    visitNode(cbNode, (<ConditionalTypeNode>node).trueType) ||\r\n                    visitNode(cbNode, (<ConditionalTypeNode>node).falseType);\r\n            case SyntaxKind.InferType:\r\n                return visitNode(cbNode, (<InferTypeNode>node).typeParameter);\r\n            case SyntaxKind.ImportType:\r\n                return visitNode(cbNode, (<ImportTypeNode>node).argument) ||\r\n                    visitNode(cbNode, (<ImportTypeNode>node).qualifier) ||\r\n                    visitNodes(cbNode, cbNodes, (<ImportTypeNode>node).typeArguments);\r\n            case SyntaxKind.ParenthesizedType:\r\n            case SyntaxKind.TypeOperator:\r\n                return visitNode(cbNode, (<ParenthesizedTypeNode | TypeOperatorNode>node).type);\r\n            case SyntaxKind.IndexedAccessType:\r\n                return visitNode(cbNode, (<IndexedAccessTypeNode>node).objectType) ||\r\n                    visitNode(cbNode, (<IndexedAccessTypeNode>node).indexType);\r\n            case SyntaxKind.MappedType:\r\n                return visitNode(cbNode, (<MappedTypeNode>node).readonlyToken) ||\r\n                    visitNode(cbNode, (<MappedTypeNode>node).typeParameter) ||\r\n                    visitNode(cbNode, (<MappedTypeNode>node).questionToken) ||\r\n                    visitNode(cbNode, (<MappedTypeNode>node).type);\r\n            case SyntaxKind.LiteralType:\r\n                return visitNode(cbNode, (<LiteralTypeNode>node).literal);\r\n            case SyntaxKind.ObjectBindingPattern:\r\n            case SyntaxKind.ArrayBindingPattern:\r\n                return visitNodes(cbNode, cbNodes, (<BindingPattern>node).elements);\r\n            case SyntaxKind.ArrayLiteralExpression:\r\n                return visitNodes(cbNode, cbNodes, (<ArrayLiteralExpression>node).elements);\r\n            case SyntaxKind.ObjectLiteralExpression:\r\n                return visitNodes(cbNode, cbNodes, (<ObjectLiteralExpression>node).properties);\r\n            case SyntaxKind.PropertyAccessExpression:\r\n                return visitNode(cbNode, (<PropertyAccessExpression>node).expression) ||\r\n                    visitNode(cbNode, (<PropertyAccessExpression>node).name);\r\n            case SyntaxKind.ElementAccessExpression:\r\n                return visitNode(cbNode, (<ElementAccessExpression>node).expression) ||\r\n                    visitNode(cbNode, (<ElementAccessExpression>node).argumentExpression);\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.NewExpression:\r\n                return visitNode(cbNode, (<CallExpression>node).expression) ||\r\n                    visitNodes(cbNode, cbNodes, (<CallExpression>node).typeArguments) ||\r\n                    visitNodes(cbNode, cbNodes, (<CallExpression>node).arguments);\r\n            case SyntaxKind.TaggedTemplateExpression:\r\n                return visitNode(cbNode, (<TaggedTemplateExpression>node).tag) ||\r\n                    visitNodes(cbNode, cbNodes, (<TaggedTemplateExpression>node).typeArguments) ||\r\n                    visitNode(cbNode, (<TaggedTemplateExpression>node).template);\r\n            case SyntaxKind.TypeAssertionExpression:\r\n                return visitNode(cbNode, (<TypeAssertion>node).type) ||\r\n                    visitNode(cbNode, (<TypeAssertion>node).expression);\r\n            case SyntaxKind.ParenthesizedExpression:\r\n                return visitNode(cbNode, (<ParenthesizedExpression>node).expression);\r\n            case SyntaxKind.DeleteExpression:\r\n                return visitNode(cbNode, (<DeleteExpression>node).expression);\r\n            case SyntaxKind.TypeOfExpression:\r\n                return visitNode(cbNode, (<TypeOfExpression>node).expression);\r\n            case SyntaxKind.VoidExpression:\r\n                return visitNode(cbNode, (<VoidExpression>node).expression);\r\n            case SyntaxKind.PrefixUnaryExpression:\r\n                return visitNode(cbNode, (<PrefixUnaryExpression>node).operand);\r\n            case SyntaxKind.YieldExpression:\r\n                return visitNode(cbNode, (<YieldExpression>node).asteriskToken) ||\r\n                    visitNode(cbNode, (<YieldExpression>node).expression);\r\n            case SyntaxKind.AwaitExpression:\r\n                return visitNode(cbNode, (<AwaitExpression>node).expression);\r\n            case SyntaxKind.PostfixUnaryExpression:\r\n                return visitNode(cbNode, (<PostfixUnaryExpression>node).operand);\r\n            case SyntaxKind.BinaryExpression:\r\n                return visitNode(cbNode, (<BinaryExpression>node).left) ||\r\n                    visitNode(cbNode, (<BinaryExpression>node).operatorToken) ||\r\n                    visitNode(cbNode, (<BinaryExpression>node).right);\r\n            case SyntaxKind.AsExpression:\r\n                return visitNode(cbNode, (<AsExpression>node).expression) ||\r\n                    visitNode(cbNode, (<AsExpression>node).type);\r\n            case SyntaxKind.NonNullExpression:\r\n                return visitNode(cbNode, (<NonNullExpression>node).expression);\r\n            case SyntaxKind.MetaProperty:\r\n                return visitNode(cbNode, (<MetaProperty>node).name);\r\n            case SyntaxKind.ConditionalExpression:\r\n                return visitNode(cbNode, (<ConditionalExpression>node).condition) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).questionToken) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).whenTrue) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).colonToken) ||\r\n                    visitNode(cbNode, (<ConditionalExpression>node).whenFalse);\r\n            case SyntaxKind.SpreadElement:\r\n                return visitNode(cbNode, (<SpreadElement>node).expression);\r\n            case SyntaxKind.Block:\r\n            case SyntaxKind.ModuleBlock:\r\n                return visitNodes(cbNode, cbNodes, (<Block>node).statements);\r\n            case SyntaxKind.SourceFile:\r\n                return visitNodes(cbNode, cbNodes, (<SourceFile>node).statements) ||\r\n                    visitNode(cbNode, (<SourceFile>node).endOfFileToken);\r\n            case SyntaxKind.VariableStatement:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<VariableStatement>node).declarationList);\r\n            case SyntaxKind.VariableDeclarationList:\r\n                return visitNodes(cbNode, cbNodes, (<VariableDeclarationList>node).declarations);\r\n            case SyntaxKind.ExpressionStatement:\r\n                return visitNode(cbNode, (<ExpressionStatement>node).expression);\r\n            case SyntaxKind.IfStatement:\r\n                return visitNode(cbNode, (<IfStatement>node).expression) ||\r\n                    visitNode(cbNode, (<IfStatement>node).thenStatement) ||\r\n                    visitNode(cbNode, (<IfStatement>node).elseStatement);\r\n            case SyntaxKind.DoStatement:\r\n                return visitNode(cbNode, (<DoStatement>node).statement) ||\r\n                    visitNode(cbNode, (<DoStatement>node).expression);\r\n            case SyntaxKind.WhileStatement:\r\n                return visitNode(cbNode, (<WhileStatement>node).expression) ||\r\n                    visitNode(cbNode, (<WhileStatement>node).statement);\r\n            case SyntaxKind.ForStatement:\r\n                return visitNode(cbNode, (<ForStatement>node).initializer) ||\r\n                    visitNode(cbNode, (<ForStatement>node).condition) ||\r\n                    visitNode(cbNode, (<ForStatement>node).incrementor) ||\r\n                    visitNode(cbNode, (<ForStatement>node).statement);\r\n            case SyntaxKind.ForInStatement:\r\n                return visitNode(cbNode, (<ForInStatement>node).initializer) ||\r\n                    visitNode(cbNode, (<ForInStatement>node).expression) ||\r\n                    visitNode(cbNode, (<ForInStatement>node).statement);\r\n            case SyntaxKind.ForOfStatement:\r\n                return visitNode(cbNode, (<ForOfStatement>node).awaitModifier) ||\r\n                    visitNode(cbNode, (<ForOfStatement>node).initializer) ||\r\n                    visitNode(cbNode, (<ForOfStatement>node).expression) ||\r\n                    visitNode(cbNode, (<ForOfStatement>node).statement);\r\n            case SyntaxKind.ContinueStatement:\r\n            case SyntaxKind.BreakStatement:\r\n                return visitNode(cbNode, (<BreakOrContinueStatement>node).label);\r\n            case SyntaxKind.ReturnStatement:\r\n                return visitNode(cbNode, (<ReturnStatement>node).expression);\r\n            case SyntaxKind.WithStatement:\r\n                return visitNode(cbNode, (<WithStatement>node).expression) ||\r\n                    visitNode(cbNode, (<WithStatement>node).statement);\r\n            case SyntaxKind.SwitchStatement:\r\n                return visitNode(cbNode, (<SwitchStatement>node).expression) ||\r\n                    visitNode(cbNode, (<SwitchStatement>node).caseBlock);\r\n            case SyntaxKind.CaseBlock:\r\n                return visitNodes(cbNode, cbNodes, (<CaseBlock>node).clauses);\r\n            case SyntaxKind.CaseClause:\r\n                return visitNode(cbNode, (<CaseClause>node).expression) ||\r\n                    visitNodes(cbNode, cbNodes, (<CaseClause>node).statements);\r\n            case SyntaxKind.DefaultClause:\r\n                return visitNodes(cbNode, cbNodes, (<DefaultClause>node).statements);\r\n            case SyntaxKind.LabeledStatement:\r\n                return visitNode(cbNode, (<LabeledStatement>node).label) ||\r\n                    visitNode(cbNode, (<LabeledStatement>node).statement);\r\n            case SyntaxKind.ThrowStatement:\r\n                return visitNode(cbNode, (<ThrowStatement>node).expression);\r\n            case SyntaxKind.TryStatement:\r\n                return visitNode(cbNode, (<TryStatement>node).tryBlock) ||\r\n                    visitNode(cbNode, (<TryStatement>node).catchClause) ||\r\n                    visitNode(cbNode, (<TryStatement>node).finallyBlock);\r\n            case SyntaxKind.CatchClause:\r\n                return visitNode(cbNode, (<CatchClause>node).variableDeclaration) ||\r\n                    visitNode(cbNode, (<CatchClause>node).block);\r\n            case SyntaxKind.Decorator:\r\n                return visitNode(cbNode, (<Decorator>node).expression);\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.ClassExpression:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ClassLikeDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassLikeDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassLikeDeclaration>node).heritageClauses) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassLikeDeclaration>node).members);\r\n            case SyntaxKind.InterfaceDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<InterfaceDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<InterfaceDeclaration>node).typeParameters) ||\r\n                    visitNodes(cbNode, cbNodes, (<ClassDeclaration>node).heritageClauses) ||\r\n                    visitNodes(cbNode, cbNodes, (<InterfaceDeclaration>node).members);\r\n            case SyntaxKind.TypeAliasDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<TypeAliasDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<TypeAliasDeclaration>node).typeParameters) ||\r\n                    visitNode(cbNode, (<TypeAliasDeclaration>node).type);\r\n            case SyntaxKind.EnumDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<EnumDeclaration>node).name) ||\r\n                    visitNodes(cbNode, cbNodes, (<EnumDeclaration>node).members);\r\n            case SyntaxKind.EnumMember:\r\n                return visitNode(cbNode, (<EnumMember>node).name) ||\r\n                    visitNode(cbNode, (<EnumMember>node).initializer);\r\n            case SyntaxKind.ModuleDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ModuleDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<ModuleDeclaration>node).body);\r\n            case SyntaxKind.ImportEqualsDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ImportEqualsDeclaration>node).name) ||\r\n                    visitNode(cbNode, (<ImportEqualsDeclaration>node).moduleReference);\r\n            case SyntaxKind.ImportDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ImportDeclaration>node).importClause) ||\r\n                    visitNode(cbNode, (<ImportDeclaration>node).moduleSpecifier);\r\n            case SyntaxKind.ImportClause:\r\n                return visitNode(cbNode, (<ImportClause>node).name) ||\r\n                    visitNode(cbNode, (<ImportClause>node).namedBindings);\r\n            case SyntaxKind.NamespaceExportDeclaration:\r\n                return visitNode(cbNode, (<NamespaceExportDeclaration>node).name);\r\n\r\n            case SyntaxKind.NamespaceImport:\r\n                return visitNode(cbNode, (<NamespaceImport>node).name);\r\n            case SyntaxKind.NamedImports:\r\n            case SyntaxKind.NamedExports:\r\n                return visitNodes(cbNode, cbNodes, (<NamedImportsOrExports>node).elements);\r\n            case SyntaxKind.ExportDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ExportDeclaration>node).exportClause) ||\r\n                    visitNode(cbNode, (<ExportDeclaration>node).moduleSpecifier);\r\n            case SyntaxKind.ImportSpecifier:\r\n            case SyntaxKind.ExportSpecifier:\r\n                return visitNode(cbNode, (<ImportOrExportSpecifier>node).propertyName) ||\r\n                    visitNode(cbNode, (<ImportOrExportSpecifier>node).name);\r\n            case SyntaxKind.ExportAssignment:\r\n                return visitNodes(cbNode, cbNodes, node.decorators) ||\r\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\r\n                    visitNode(cbNode, (<ExportAssignment>node).expression);\r\n            case SyntaxKind.TemplateExpression:\r\n                return visitNode(cbNode, (<TemplateExpression>node).head) || visitNodes(cbNode, cbNodes, (<TemplateExpression>node).templateSpans);\r\n            case SyntaxKind.TemplateSpan:\r\n                return visitNode(cbNode, (<TemplateSpan>node).expression) || visitNode(cbNode, (<TemplateSpan>node).literal);\r\n            case SyntaxKind.ComputedPropertyName:\r\n                return visitNode(cbNode, (<ComputedPropertyName>node).expression);\r\n            case SyntaxKind.HeritageClause:\r\n                return visitNodes(cbNode, cbNodes, (<HeritageClause>node).types);\r\n            case SyntaxKind.ExpressionWithTypeArguments:\r\n                return visitNode(cbNode, (<ExpressionWithTypeArguments>node).expression) ||\r\n                    visitNodes(cbNode, cbNodes, (<ExpressionWithTypeArguments>node).typeArguments);\r\n            case SyntaxKind.ExternalModuleReference:\r\n                return visitNode(cbNode, (<ExternalModuleReference>node).expression);\r\n            case SyntaxKind.MissingDeclaration:\r\n                return visitNodes(cbNode, cbNodes, node.decorators);\r\n            case SyntaxKind.CommaListExpression:\r\n                return visitNodes(cbNode, cbNodes, (<CommaListExpression>node).elements);\r\n\r\n            case SyntaxKind.JsxElement:\r\n                return visitNode(cbNode, (<JsxElement>node).openingElement) ||\r\n                    visitNodes(cbNode, cbNodes, (<JsxElement>node).children) ||\r\n                    visitNode(cbNode, (<JsxElement>node).closingElement);\r\n            case SyntaxKind.JsxFragment:\r\n                return visitNode(cbNode, (<JsxFragment>node).openingFragment) ||\r\n                    visitNodes(cbNode, cbNodes, (<JsxFragment>node).children) ||\r\n                    visitNode(cbNode, (<JsxFragment>node).closingFragment);\r\n            case SyntaxKind.JsxSelfClosingElement:\r\n            case SyntaxKind.JsxOpeningElement:\r\n                return visitNode(cbNode, (<JsxOpeningLikeElement>node).tagName) ||\r\n                    visitNodes(cbNode, cbNodes, (<JsxOpeningLikeElement>node).typeArguments) ||\r\n                    visitNode(cbNode, (<JsxOpeningLikeElement>node).attributes);\r\n            case SyntaxKind.JsxAttributes:\r\n                return visitNodes(cbNode, cbNodes, (<JsxAttributes>node).properties);\r\n            case SyntaxKind.JsxAttribute:\r\n                return visitNode(cbNode, (<JsxAttribute>node).name) ||\r\n                    visitNode(cbNode, (<JsxAttribute>node).initializer);\r\n            case SyntaxKind.JsxSpreadAttribute:\r\n                return visitNode(cbNode, (<JsxSpreadAttribute>node).expression);\r\n            case SyntaxKind.JsxExpression:\r\n                return visitNode(cbNode, (node as JsxExpression).dotDotDotToken) ||\r\n                    visitNode(cbNode, (node as JsxExpression).expression);\r\n            case SyntaxKind.JsxClosingElement:\r\n                return visitNode(cbNode, (<JsxClosingElement>node).tagName);\r\n\r\n            case SyntaxKind.JSDocTypeExpression:\r\n                return visitNode(cbNode, (<JSDocTypeExpression>node).type);\r\n            case SyntaxKind.JSDocNonNullableType:\r\n                return visitNode(cbNode, (<JSDocNonNullableType>node).type);\r\n            case SyntaxKind.JSDocNullableType:\r\n                return visitNode(cbNode, (<JSDocNullableType>node).type);\r\n            case SyntaxKind.JSDocOptionalType:\r\n                return visitNode(cbNode, (<JSDocOptionalType>node).type);\r\n            case SyntaxKind.JSDocFunctionType:\r\n                return visitNodes(cbNode, cbNodes, (<JSDocFunctionType>node).parameters) ||\r\n                    visitNode(cbNode, (<JSDocFunctionType>node).type);\r\n            case SyntaxKind.JSDocVariadicType:\r\n                return visitNode(cbNode, (<JSDocVariadicType>node).type);\r\n            case SyntaxKind.JSDocComment:\r\n                return visitNodes(cbNode, cbNodes, (<JSDoc>node).tags);\r\n            case SyntaxKind.JSDocParameterTag:\r\n            case SyntaxKind.JSDocPropertyTag:\r\n                if ((node as JSDocPropertyLikeTag).isNameFirst) {\r\n                    return visitNode(cbNode, (<JSDocPropertyLikeTag>node).name) ||\r\n                        visitNode(cbNode, (<JSDocPropertyLikeTag>node).typeExpression);\r\n                }\r\n                else {\r\n                    return visitNode(cbNode, (<JSDocPropertyLikeTag>node).typeExpression) ||\r\n                        visitNode(cbNode, (<JSDocPropertyLikeTag>node).name);\r\n                }\r\n            case SyntaxKind.JSDocReturnTag:\r\n                return visitNode(cbNode, (<JSDocReturnTag>node).typeExpression);\r\n            case SyntaxKind.JSDocTypeTag:\r\n                return visitNode(cbNode, (<JSDocTypeTag>node).typeExpression);\r\n            case SyntaxKind.JSDocAugmentsTag:\r\n                return visitNode(cbNode, (<JSDocAugmentsTag>node).class);\r\n            case SyntaxKind.JSDocTemplateTag:\r\n                return visitNodes(cbNode, cbNodes, (<JSDocTemplateTag>node).typeParameters);\r\n            case SyntaxKind.JSDocTypedefTag:\r\n                if ((node as JSDocTypedefTag).typeExpression &&\r\n                    (node as JSDocTypedefTag).typeExpression.kind === SyntaxKind.JSDocTypeExpression) {\r\n                    return visitNode(cbNode, (<JSDocTypedefTag>node).typeExpression) ||\r\n                        visitNode(cbNode, (<JSDocTypedefTag>node).fullName);\r\n                }\r\n                else {\r\n                    return visitNode(cbNode, (<JSDocTypedefTag>node).fullName) ||\r\n                        visitNode(cbNode, (<JSDocTypedefTag>node).typeExpression);\r\n                }\r\n            case SyntaxKind.JSDocTypeLiteral:\r\n                if ((node as JSDocTypeLiteral).jsDocPropertyTags) {\r\n                    for (const tag of (node as JSDocTypeLiteral).jsDocPropertyTags) {\r\n                        visitNode(cbNode, tag);\r\n                    }\r\n                }\r\n                return;\r\n            case SyntaxKind.PartiallyEmittedExpression:\r\n                return visitNode(cbNode, (<PartiallyEmittedExpression>node).expression);\r\n        }\r\n    }\r\n\r\n    export function createSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, setParentNodes = false, scriptKind?: ScriptKind): SourceFile {\r\n        performance.mark(\"beforeParse\");\r\n        const result = Parser.parseSourceFile(fileName, sourceText, languageVersion, /*syntaxCursor*/ undefined, setParentNodes, scriptKind);\r\n        performance.mark(\"afterParse\");\r\n        performance.measure(\"Parse\", \"beforeParse\", \"afterParse\");\r\n        return result;\r\n    }\r\n\r\n    export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName {\r\n        return Parser.parseIsolatedEntityName(text, languageVersion);\r\n    }\r\n\r\n    /**\r\n     * Parse json text into SyntaxTree and return node and parse errors if any\r\n     * @param fileName\r\n     * @param sourceText\r\n     */\r\n    export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile {\r\n        return Parser.parseJsonText(fileName, sourceText);\r\n    }\r\n\r\n    // See also `isExternalOrCommonJsModule` in utilities.ts\r\n    export function isExternalModule(file: SourceFile): boolean {\r\n        return file.externalModuleIndicator !== undefined;\r\n    }\r\n\r\n    // Produces a new SourceFile for the 'newText' provided. The 'textChangeRange' parameter\r\n    // indicates what changed between the 'text' that this SourceFile has and the 'newText'.\r\n    // The SourceFile will be created with the compiler attempting to reuse as many nodes from\r\n    // this file as possible.\r\n    //\r\n    // Note: this function mutates nodes from this SourceFile. That means any existing nodes\r\n    // from this SourceFile that are being held onto may change as a result (including\r\n    // becoming detached from any SourceFile).  It is recommended that this SourceFile not\r\n    // be used once 'update' is called on it.\r\n    export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile {\r\n        const newSourceFile = IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);\r\n        // Because new source file node is created, it may not have the flag PossiblyContainDynamicImport. This is the case if there is no new edit to add dynamic import.\r\n        // We will manually port the flag to the new source file.\r\n        newSourceFile.flags |= (sourceFile.flags & NodeFlags.PermanentlySetIncrementalFlags);\r\n        return newSourceFile;\r\n    }\r\n\r\n    /* @internal */\r\n    export function parseIsolatedJSDocComment(content: string, start?: number, length?: number) {\r\n        const result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length);\r\n        if (result && result.jsDoc) {\r\n            // because the jsDocComment was parsed out of the source file, it might\r\n            // not be covered by the fixupParentReferences.\r\n            Parser.fixupParentReferences(result.jsDoc);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /* @internal */\r\n    // Exposed only for testing.\r\n    export function parseJSDocTypeExpressionForTests(content: string, start?: number, length?: number) {\r\n        return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length);\r\n    }\r\n\r\n    // Implement the parser as a singleton module.  We do this for perf reasons because creating\r\n    // parser instances can actually be expensive enough to impact us on projects with many source\r\n    // files.\r\n    namespace Parser {\r\n        // Share a single scanner across all calls to parse a source file.  This helps speed things\r\n        // up by avoiding the cost of creating/compiling scanners over and over again.\r\n        const scanner = createScanner(ScriptTarget.Latest, /*skipTrivia*/ true);\r\n        const disallowInAndDecoratorContext = NodeFlags.DisallowInContext | NodeFlags.DecoratorContext;\r\n\r\n        // capture constructors in 'initializeState' to avoid null checks\r\n        // tslint:disable variable-name\r\n        let NodeConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        let TokenConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        let IdentifierConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        let SourceFileConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\r\n        // tslint:enable variable-name\r\n\r\n        let sourceFile: SourceFile;\r\n        let parseDiagnostics: Diagnostic[];\r\n        let syntaxCursor: IncrementalParser.SyntaxCursor;\r\n\r\n        let currentToken: SyntaxKind;\r\n        let sourceText: string;\r\n        let nodeCount: number;\r\n        let identifiers: Map<string>;\r\n        let identifierCount: number;\r\n\r\n        let parsingContext: ParsingContext;\r\n\r\n        // Flags that dictate what parsing context we're in.  For example:\r\n        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is\r\n        // that some tokens that would be considered identifiers may be considered keywords.\r\n        //\r\n        // When adding more parser context flags, consider which is the more common case that the\r\n        // flag will be in.  This should be the 'false' state for that flag.  The reason for this is\r\n        // that we don't store data in our nodes unless the value is in the *non-default* state.  So,\r\n        // for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for\r\n        // 'disallow-in' set to 'false'.  Otherwise, if we had 'allowsIn' set to 'true', then almost\r\n        // all nodes would need extra state on them to store this info.\r\n        //\r\n        // Note: 'allowIn' and 'allowYield' track 1:1 with the [in] and [yield] concepts in the ES6\r\n        // grammar specification.\r\n        //\r\n        // An important thing about these context concepts.  By default they are effectively inherited\r\n        // while parsing through every grammar production.  i.e. if you don't change them, then when\r\n        // you parse a sub-production, it will have the same context values as the parent production.\r\n        // This is great most of the time.  After all, consider all the 'expression' grammar productions\r\n        // and how nearly all of them pass along the 'in' and 'yield' context values:\r\n        //\r\n        // EqualityExpression[In, Yield] :\r\n        //      RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] == RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] != RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] === RelationalExpression[?In, ?Yield]\r\n        //      EqualityExpression[?In, ?Yield] !== RelationalExpression[?In, ?Yield]\r\n        //\r\n        // Where you have to be careful is then understanding what the points are in the grammar\r\n        // where the values are *not* passed along.  For example:\r\n        //\r\n        // SingleNameBinding[Yield,GeneratorParameter]\r\n        //      [+GeneratorParameter]BindingIdentifier[Yield] Initializer[In]opt\r\n        //      [~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt\r\n        //\r\n        // Here this is saying that if the GeneratorParameter context flag is set, that we should\r\n        // explicitly set the 'yield' context flag to false before calling into the BindingIdentifier\r\n        // and we should explicitly unset the 'yield' context flag before calling into the Initializer.\r\n        // production.  Conversely, if the GeneratorParameter context flag is not set, then we\r\n        // should leave the 'yield' context flag alone.\r\n        //\r\n        // Getting this all correct is tricky and requires careful reading of the grammar to\r\n        // understand when these values should be changed versus when they should be inherited.\r\n        //\r\n        // Note: it should not be necessary to save/restore these flags during speculative/lookahead\r\n        // parsing.  These context flags are naturally stored and restored through normal recursive\r\n        // descent parsing and unwinding.\r\n        let contextFlags: NodeFlags;\r\n\r\n        // Whether or not we've had a parse error since creating the last AST node.  If we have\r\n        // encountered an error, it will be stored on the next AST node we create.  Parse errors\r\n        // can be broken down into three categories:\r\n        //\r\n        // 1) An error that occurred during scanning.  For example, an unterminated literal, or a\r\n        //    character that was completely not understood.\r\n        //\r\n        // 2) A token was expected, but was not present.  This type of error is commonly produced\r\n        //    by the 'parseExpected' function.\r\n        //\r\n        // 3) A token was present that no parsing function was able to consume.  This type of error\r\n        //    only occurs in the 'abortParsingListOrMoveToNextToken' function when the parser\r\n        //    decides to skip the token.\r\n        //\r\n        // In all of these cases, we want to mark the next node as having had an error before it.\r\n        // With this mark, we can know in incremental settings if this node can be reused, or if\r\n        // we have to reparse it.  If we don't keep this information around, we may just reuse the\r\n        // node.  in that event we would then not produce the same errors as we did before, causing\r\n        // significant confusion problems.\r\n        //\r\n        // Note: it is necessary that this value be saved/restored during speculative/lookahead\r\n        // parsing.  During lookahead parsing, we will often create a node.  That node will have\r\n        // this value attached, and then this value will be set back to 'false'.  If we decide to\r\n        // rewind, we must get back to the same value we had prior to the lookahead.\r\n        //\r\n        // Note: any errors at the end of the file that do not precede a regular node, should get\r\n        // attached to the EOF token.\r\n        let parseErrorBeforeNextFinishedNode = false;\r\n\r\n        export function parseSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, syntaxCursor: IncrementalParser.SyntaxCursor, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile {\r\n            scriptKind = ensureScriptKind(fileName, scriptKind);\r\n\r\n            initializeState(sourceText, languageVersion, syntaxCursor, scriptKind);\r\n\r\n            const result = parseSourceFileWorker(fileName, languageVersion, setParentNodes, scriptKind);\r\n\r\n            clearState();\r\n\r\n            return result;\r\n        }\r\n\r\n        export function parseIsolatedEntityName(content: string, languageVersion: ScriptTarget): EntityName {\r\n            // Choice of `isDeclarationFile` should be arbitrary\r\n            initializeState(content, languageVersion, /*syntaxCursor*/ undefined, ScriptKind.JS);\r\n            // Prime the scanner.\r\n            nextToken();\r\n            const entityName = parseEntityName(/*allowReservedWords*/ true);\r\n            const isInvalid = token() === SyntaxKind.EndOfFileToken && !parseDiagnostics.length;\r\n            clearState();\r\n            return isInvalid ? entityName : undefined;\r\n        }\r\n\r\n        export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile {\r\n            initializeState(sourceText, ScriptTarget.ES2015, /*syntaxCursor*/ undefined, ScriptKind.JSON);\r\n            // Set source file so that errors will be reported with this file name\r\n            sourceFile = createSourceFile(fileName, ScriptTarget.ES2015, ScriptKind.JSON, /*isDeclaration*/ false);\r\n            const result = <JsonSourceFile>sourceFile;\r\n\r\n            // Prime the scanner.\r\n            nextToken();\r\n            if (token() === SyntaxKind.EndOfFileToken) {\r\n                sourceFile.endOfFileToken = parseTokenNode<EndOfFileToken>();\r\n            }\r\n            else if (token() === SyntaxKind.OpenBraceToken ||\r\n                lookAhead(() => token() === SyntaxKind.StringLiteral)) {\r\n                result.jsonObject = parseObjectLiteralExpression();\r\n                sourceFile.endOfFileToken = parseExpectedToken(SyntaxKind.EndOfFileToken, Diagnostics.Unexpected_token);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.OpenBraceToken);\r\n            }\r\n\r\n            sourceFile.parseDiagnostics = parseDiagnostics;\r\n            clearState();\r\n            return result;\r\n        }\r\n\r\n        function getLanguageVariant(scriptKind: ScriptKind) {\r\n            // .tsx and .jsx files are treated as jsx language variant.\r\n            return scriptKind === ScriptKind.TSX || scriptKind === ScriptKind.JSX || scriptKind === ScriptKind.JS || scriptKind === ScriptKind.JSON ? LanguageVariant.JSX : LanguageVariant.Standard;\r\n        }\r\n\r\n        function initializeState(_sourceText: string, languageVersion: ScriptTarget, _syntaxCursor: IncrementalParser.SyntaxCursor, scriptKind: ScriptKind) {\r\n            NodeConstructor = objectAllocator.getNodeConstructor();\r\n            TokenConstructor = objectAllocator.getTokenConstructor();\r\n            IdentifierConstructor = objectAllocator.getIdentifierConstructor();\r\n            SourceFileConstructor = objectAllocator.getSourceFileConstructor();\r\n\r\n            sourceText = _sourceText;\r\n            syntaxCursor = _syntaxCursor;\r\n\r\n            parseDiagnostics = [];\r\n            parsingContext = 0;\r\n            identifiers = createMap<string>();\r\n            identifierCount = 0;\r\n            nodeCount = 0;\r\n\r\n            switch (scriptKind) {\r\n                case ScriptKind.JS:\r\n                case ScriptKind.JSX:\r\n                case ScriptKind.JSON:\r\n                    contextFlags = NodeFlags.JavaScriptFile;\r\n                    break;\r\n                default:\r\n                    contextFlags = NodeFlags.None;\r\n                    break;\r\n            }\r\n            parseErrorBeforeNextFinishedNode = false;\r\n\r\n            // Initialize and prime the scanner before parsing the source elements.\r\n            scanner.setText(sourceText);\r\n            scanner.setOnError(scanError);\r\n            scanner.setScriptTarget(languageVersion);\r\n            scanner.setLanguageVariant(getLanguageVariant(scriptKind));\r\n        }\r\n\r\n        function clearState() {\r\n            // Clear out the text the scanner is pointing at, so it doesn't keep anything alive unnecessarily.\r\n            scanner.setText(\"\");\r\n            scanner.setOnError(undefined);\r\n\r\n            // Clear any data.  We don't want to accidentally hold onto it for too long.\r\n            parseDiagnostics = undefined;\r\n            sourceFile = undefined;\r\n            identifiers = undefined;\r\n            syntaxCursor = undefined;\r\n            sourceText = undefined;\r\n        }\r\n\r\n        function parseSourceFileWorker(fileName: string, languageVersion: ScriptTarget, setParentNodes: boolean, scriptKind: ScriptKind): SourceFile {\r\n            const isDeclarationFile = isDeclarationFileName(fileName);\r\n            if (isDeclarationFile) {\r\n                contextFlags |= NodeFlags.Ambient;\r\n            }\r\n\r\n            sourceFile = createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile);\r\n            sourceFile.flags = contextFlags;\r\n\r\n            // Prime the scanner.\r\n            nextToken();\r\n            // A member of ReadonlyArray<T> isn't assignable to a member of T[] (and prevents a direct cast) - but this is where we set up those members so they can be readonly in the future\r\n            processCommentPragmas(sourceFile as {} as PragmaContext, sourceText);\r\n            processPragmasIntoFields(sourceFile as {} as PragmaContext, reportPragmaDiagnostic);\r\n\r\n            sourceFile.statements = parseList(ParsingContext.SourceElements, parseStatement);\r\n            Debug.assert(token() === SyntaxKind.EndOfFileToken);\r\n            sourceFile.endOfFileToken = addJSDocComment(parseTokenNode());\r\n\r\n            setExternalModuleIndicator(sourceFile);\r\n\r\n            sourceFile.nodeCount = nodeCount;\r\n            sourceFile.identifierCount = identifierCount;\r\n            sourceFile.identifiers = identifiers;\r\n            sourceFile.parseDiagnostics = parseDiagnostics;\r\n\r\n            if (setParentNodes) {\r\n                fixupParentReferences(sourceFile);\r\n            }\r\n\r\n            return sourceFile;\r\n\r\n            function reportPragmaDiagnostic(pos: number, end: number, diagnostic: DiagnosticMessage) {\r\n                parseDiagnostics.push(createFileDiagnostic(sourceFile, pos, end, diagnostic));\r\n            }\r\n        }\r\n\r\n        function addJSDocComment<T extends HasJSDoc>(node: T): T {\r\n            const comments = getJSDocCommentRanges(node, sourceFile.text);\r\n            if (comments) {\r\n                for (const comment of comments) {\r\n                    node.jsDoc = append(node.jsDoc, JSDocParser.parseJSDocComment(node, comment.pos, comment.end - comment.pos));\r\n                }\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        export function fixupParentReferences(rootNode: Node) {\r\n            // normally parent references are set during binding. However, for clients that only need\r\n            // a syntax tree, and no semantic features, then the binding process is an unnecessary\r\n            // overhead.  This functions allows us to set all the parents, without all the expense of\r\n            // binding.\r\n\r\n            let parent: Node = rootNode;\r\n            forEachChild(rootNode, visitNode);\r\n            return;\r\n\r\n            function visitNode(n: Node): void {\r\n                // walk down setting parents that differ from the parent we think it should be.  This\r\n                // allows us to quickly bail out of setting parents for subtrees during incremental\r\n                // parsing\r\n                if (n.parent !== parent) {\r\n                    n.parent = parent;\r\n\r\n                    const saveParent = parent;\r\n                    parent = n;\r\n                    forEachChild(n, visitNode);\r\n                    if (hasJSDocNodes(n)) {\r\n                        for (const jsDoc of n.jsDoc) {\r\n                            jsDoc.parent = n;\r\n                            parent = jsDoc;\r\n                            forEachChild(jsDoc, visitNode);\r\n                        }\r\n                    }\r\n                    parent = saveParent;\r\n                }\r\n            }\r\n        }\r\n\r\n        function createSourceFile(fileName: string, languageVersion: ScriptTarget, scriptKind: ScriptKind, isDeclarationFile: boolean): SourceFile {\r\n            // code from createNode is inlined here so createNode won't have to deal with special case of creating source files\r\n            // this is quite rare comparing to other nodes and createNode should be as fast as possible\r\n            const sourceFile = <SourceFile>new SourceFileConstructor(SyntaxKind.SourceFile, /*pos*/ 0, /* end */ sourceText.length);\r\n            nodeCount++;\r\n\r\n            sourceFile.text = sourceText;\r\n            sourceFile.bindDiagnostics = [];\r\n            sourceFile.languageVersion = languageVersion;\r\n            sourceFile.fileName = normalizePath(fileName);\r\n            sourceFile.languageVariant = getLanguageVariant(scriptKind);\r\n            sourceFile.isDeclarationFile = isDeclarationFile;\r\n            sourceFile.scriptKind = scriptKind;\r\n\r\n            return sourceFile;\r\n        }\r\n\r\n        function setContextFlag(val: boolean, flag: NodeFlags) {\r\n            if (val) {\r\n                contextFlags |= flag;\r\n            }\r\n            else {\r\n                contextFlags &= ~flag;\r\n            }\r\n        }\r\n\r\n        function setDisallowInContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.DisallowInContext);\r\n        }\r\n\r\n        function setYieldContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.YieldContext);\r\n        }\r\n\r\n        function setDecoratorContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.DecoratorContext);\r\n        }\r\n\r\n        function setAwaitContext(val: boolean) {\r\n            setContextFlag(val, NodeFlags.AwaitContext);\r\n        }\r\n\r\n        function doOutsideOfContext<T>(context: NodeFlags, func: () => T): T {\r\n            // contextFlagsToClear will contain only the context flags that are\r\n            // currently set that we need to temporarily clear\r\n            // We don't just blindly reset to the previous flags to ensure\r\n            // that we do not mutate cached flags for the incremental\r\n            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and\r\n            // HasAggregatedChildData).\r\n            const contextFlagsToClear = context & contextFlags;\r\n            if (contextFlagsToClear) {\r\n                // clear the requested context flags\r\n                setContextFlag(/*val*/ false, contextFlagsToClear);\r\n                const result = func();\r\n                // restore the context flags we just cleared\r\n                setContextFlag(/*val*/ true, contextFlagsToClear);\r\n                return result;\r\n            }\r\n\r\n            // no need to do anything special as we are not in any of the requested contexts\r\n            return func();\r\n        }\r\n\r\n        function doInsideOfContext<T>(context: NodeFlags, func: () => T): T {\r\n            // contextFlagsToSet will contain only the context flags that\r\n            // are not currently set that we need to temporarily enable.\r\n            // We don't just blindly reset to the previous flags to ensure\r\n            // that we do not mutate cached flags for the incremental\r\n            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and\r\n            // HasAggregatedChildData).\r\n            const contextFlagsToSet = context & ~contextFlags;\r\n            if (contextFlagsToSet) {\r\n                // set the requested context flags\r\n                setContextFlag(/*val*/ true, contextFlagsToSet);\r\n                const result = func();\r\n                // reset the context flags we just set\r\n                setContextFlag(/*val*/ false, contextFlagsToSet);\r\n                return result;\r\n            }\r\n\r\n            // no need to do anything special as we are already in all of the requested contexts\r\n            return func();\r\n        }\r\n\r\n        function allowInAnd<T>(func: () => T): T {\r\n            return doOutsideOfContext(NodeFlags.DisallowInContext, func);\r\n        }\r\n\r\n        function disallowInAnd<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.DisallowInContext, func);\r\n        }\r\n\r\n        function doInYieldContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.YieldContext, func);\r\n        }\r\n\r\n        function doInDecoratorContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.DecoratorContext, func);\r\n        }\r\n\r\n        function doInAwaitContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.AwaitContext, func);\r\n        }\r\n\r\n        function doOutsideOfAwaitContext<T>(func: () => T): T {\r\n            return doOutsideOfContext(NodeFlags.AwaitContext, func);\r\n        }\r\n\r\n        function doInYieldAndAwaitContext<T>(func: () => T): T {\r\n            return doInsideOfContext(NodeFlags.YieldContext | NodeFlags.AwaitContext, func);\r\n        }\r\n\r\n        function inContext(flags: NodeFlags) {\r\n            return (contextFlags & flags) !== 0;\r\n        }\r\n\r\n        function inYieldContext() {\r\n            return inContext(NodeFlags.YieldContext);\r\n        }\r\n\r\n        function inDisallowInContext() {\r\n            return inContext(NodeFlags.DisallowInContext);\r\n        }\r\n\r\n        function inDecoratorContext() {\r\n            return inContext(NodeFlags.DecoratorContext);\r\n        }\r\n\r\n        function inAwaitContext() {\r\n            return inContext(NodeFlags.AwaitContext);\r\n        }\r\n\r\n        function parseErrorAtCurrentToken(message: DiagnosticMessage, arg0?: any): void {\r\n            parseErrorAt(scanner.getTokenPos(), scanner.getTextPos(), message, arg0);\r\n        }\r\n\r\n        function parseErrorAtPosition(start: number, length: number, message: DiagnosticMessage, arg0?: any): void {\r\n            // Don't report another error if it would just be at the same position as the last error.\r\n            const lastError = lastOrUndefined(parseDiagnostics);\r\n            if (!lastError || start !== lastError.start) {\r\n                parseDiagnostics.push(createFileDiagnostic(sourceFile, start, length, message, arg0));\r\n            }\r\n\r\n            // Mark that we've encountered an error.  We'll set an appropriate bit on the next\r\n            // node we finish so that it can't be reused incrementally.\r\n            parseErrorBeforeNextFinishedNode = true;\r\n        }\r\n\r\n        function parseErrorAt(start: number, end: number, message: DiagnosticMessage, arg0?: any): void {\r\n            parseErrorAtPosition(start, end - start, message, arg0);\r\n        }\r\n\r\n        function parseErrorAtRange(range: TextRange, message: DiagnosticMessage, arg0?: any): void {\r\n            parseErrorAt(range.pos, range.end, message, arg0);\r\n        }\r\n\r\n        function scanError(message: DiagnosticMessage, length: number): void {\r\n            parseErrorAtPosition(scanner.getTextPos(), length, message);\r\n        }\r\n\r\n        function getNodePos(): number {\r\n            return scanner.getStartPos();\r\n        }\r\n\r\n        // Use this function to access the current token instead of reading the currentToken\r\n        // variable. Since function results aren't narrowed in control flow analysis, this ensures\r\n        // that the type checker doesn't make wrong assumptions about the type of the current\r\n        // token (e.g. a call to nextToken() changes the current token but the checker doesn't\r\n        // reason about this side effect).  Mainstream VMs inline simple functions like this, so\r\n        // there is no performance penalty.\r\n        function token(): SyntaxKind {\r\n            return currentToken;\r\n        }\r\n\r\n        function nextToken(): SyntaxKind {\r\n            return currentToken = scanner.scan();\r\n        }\r\n\r\n        function reScanGreaterToken(): SyntaxKind {\r\n            return currentToken = scanner.reScanGreaterToken();\r\n        }\r\n\r\n        function reScanSlashToken(): SyntaxKind {\r\n            return currentToken = scanner.reScanSlashToken();\r\n        }\r\n\r\n        function reScanTemplateToken(): SyntaxKind {\r\n            return currentToken = scanner.reScanTemplateToken();\r\n        }\r\n\r\n        function scanJsxIdentifier(): SyntaxKind {\r\n            return currentToken = scanner.scanJsxIdentifier();\r\n        }\r\n\r\n        function scanJsxText(): SyntaxKind {\r\n            return currentToken = scanner.scanJsxToken();\r\n        }\r\n\r\n        function scanJsxAttributeValue(): SyntaxKind {\r\n            return currentToken = scanner.scanJsxAttributeValue();\r\n        }\r\n\r\n        function speculationHelper<T>(callback: () => T, isLookAhead: boolean): T {\r\n            // Keep track of the state we'll need to rollback to if lookahead fails (or if the\r\n            // caller asked us to always reset our state).\r\n            const saveToken = currentToken;\r\n            const saveParseDiagnosticsLength = parseDiagnostics.length;\r\n            const saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;\r\n\r\n            // Note: it is not actually necessary to save/restore the context flags here.  That's\r\n            // because the saving/restoring of these flags happens naturally through the recursive\r\n            // descent nature of our parser.  However, we still store this here just so we can\r\n            // assert that invariant holds.\r\n            const saveContextFlags = contextFlags;\r\n\r\n            // If we're only looking ahead, then tell the scanner to only lookahead as well.\r\n            // Otherwise, if we're actually speculatively parsing, then tell the scanner to do the\r\n            // same.\r\n            const result = isLookAhead\r\n                ? scanner.lookAhead(callback)\r\n                : scanner.tryScan(callback);\r\n\r\n            Debug.assert(saveContextFlags === contextFlags);\r\n\r\n            // If our callback returned something 'falsy' or we're just looking ahead,\r\n            // then unconditionally restore us to where we were.\r\n            if (!result || isLookAhead) {\r\n                currentToken = saveToken;\r\n                parseDiagnostics.length = saveParseDiagnosticsLength;\r\n                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Invokes the provided callback then unconditionally restores the parser to the state it\r\n         * was in immediately prior to invoking the callback.  The result of invoking the callback\r\n         * is returned from this function.\r\n         */\r\n        function lookAhead<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookAhead*/ true);\r\n        }\r\n\r\n        /** Invokes the provided callback.  If the callback returns something falsy, then it restores\r\n         * the parser to the state it was in immediately prior to invoking the callback.  If the\r\n         * callback returns something truthy, then the parser state is not rolled back.  The result\r\n         * of invoking the callback is returned from this function.\r\n         */\r\n        function tryParse<T>(callback: () => T): T {\r\n            return speculationHelper(callback, /*isLookAhead*/ false);\r\n        }\r\n\r\n        // Ignore strict mode flag because we will report an error in type checker instead.\r\n        function isIdentifier(): boolean {\r\n            if (token() === SyntaxKind.Identifier) {\r\n                return true;\r\n            }\r\n\r\n            // If we have a 'yield' keyword, and we're in the [yield] context, then 'yield' is\r\n            // considered a keyword and is not an identifier.\r\n            if (token() === SyntaxKind.YieldKeyword && inYieldContext()) {\r\n                return false;\r\n            }\r\n\r\n            // If we have a 'await' keyword, and we're in the [Await] context, then 'await' is\r\n            // considered a keyword and is not an identifier.\r\n            if (token() === SyntaxKind.AwaitKeyword && inAwaitContext()) {\r\n                return false;\r\n            }\r\n\r\n            return token() > SyntaxKind.LastReservedWord;\r\n        }\r\n\r\n        function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage, shouldAdvance = true): boolean {\r\n            if (token() === kind) {\r\n                if (shouldAdvance) {\r\n                    nextToken();\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // Report specific message if provided with one.  Otherwise, report generic fallback message.\r\n            if (diagnosticMessage) {\r\n                parseErrorAtCurrentToken(diagnosticMessage);\r\n            }\r\n            else {\r\n                parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(kind));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseOptional(t: SyntaxKind): boolean {\r\n            if (token() === t) {\r\n                nextToken();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseOptionalToken<TKind extends SyntaxKind>(t: TKind): Token<TKind>;\r\n        function parseOptionalToken(t: SyntaxKind): Node {\r\n            if (token() === t) {\r\n                return parseTokenNode();\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function parseExpectedToken<TKind extends SyntaxKind>(t: TKind, diagnosticMessage?: DiagnosticMessage, arg0?: any): Token<TKind>;\r\n        function parseExpectedToken(t: SyntaxKind, diagnosticMessage?: DiagnosticMessage, arg0?: any): Node {\r\n            return parseOptionalToken(t) ||\r\n                createMissingNode(t, /*reportAtCurrentPosition*/ false, diagnosticMessage || Diagnostics._0_expected, arg0 || tokenToString(t));\r\n        }\r\n\r\n        function parseTokenNode<T extends Node>(): T {\r\n            const node = <T>createNode(token());\r\n            nextToken();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function canParseSemicolon() {\r\n            // If there's a real semicolon, then we can always parse it out.\r\n            if (token() === SyntaxKind.SemicolonToken) {\r\n                return true;\r\n            }\r\n\r\n            // We can parse out an optional semicolon in ASI cases in the following cases.\r\n            return token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.EndOfFileToken || scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function parseSemicolon(): boolean {\r\n            if (canParseSemicolon()) {\r\n                if (token() === SyntaxKind.SemicolonToken) {\r\n                    // consume the semicolon if it was explicitly provided.\r\n                    nextToken();\r\n                }\r\n\r\n                return true;\r\n            }\r\n            else {\r\n                return parseExpected(SyntaxKind.SemicolonToken);\r\n            }\r\n        }\r\n\r\n        function createNode(kind: SyntaxKind, pos?: number): Node {\r\n            nodeCount++;\r\n            const p = pos >= 0 ? pos : scanner.getStartPos();\r\n            return isNodeKind(kind) || kind === SyntaxKind.Unknown ? new NodeConstructor(kind, p, p) :\r\n                kind === SyntaxKind.Identifier ? new IdentifierConstructor(kind, p, p) :\r\n                new TokenConstructor(kind, p, p);\r\n        }\r\n\r\n        function createNodeWithJSDoc(kind: SyntaxKind): Node {\r\n            const node = createNode(kind);\r\n            if (scanner.getTokenFlags() & TokenFlags.PrecedingJSDocComment) {\r\n                addJSDocComment(<HasJSDoc>node);\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function createNodeArray<T extends Node>(elements: T[], pos: number, end?: number): NodeArray<T> {\r\n            // Since the element list of a node array is typically created by starting with an empty array and\r\n            // repeatedly calling push(), the list may not have the optimal memory layout. We invoke slice() for\r\n            // small arrays (1 to 4 elements) to give the VM a chance to allocate an optimal representation.\r\n            const length = elements.length;\r\n            const array = <MutableNodeArray<T>>(length >= 1 && length <= 4 ? elements.slice() : elements);\r\n            array.pos = pos;\r\n            array.end = end === undefined ? scanner.getStartPos() : end;\r\n            return array;\r\n        }\r\n\r\n        function finishNode<T extends Node>(node: T, end?: number): T {\r\n            node.end = end === undefined ? scanner.getStartPos() : end;\r\n\r\n            if (contextFlags) {\r\n                node.flags |= contextFlags;\r\n            }\r\n\r\n            // Keep track on the node if we encountered an error while parsing it.  If we did, then\r\n            // we cannot reuse the node incrementally.  Once we've marked this node, clear out the\r\n            // flag so that we don't mark any subsequent nodes.\r\n            if (parseErrorBeforeNextFinishedNode) {\r\n                parseErrorBeforeNextFinishedNode = false;\r\n                node.flags |= NodeFlags.ThisNodeHasError;\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        function createMissingNode<T extends Node>(kind: T[\"kind\"], reportAtCurrentPosition: boolean, diagnosticMessage: DiagnosticMessage, arg0?: any): T {\r\n            if (reportAtCurrentPosition) {\r\n                parseErrorAtPosition(scanner.getStartPos(), 0, diagnosticMessage, arg0);\r\n            }\r\n            else if (diagnosticMessage) {\r\n                parseErrorAtCurrentToken(diagnosticMessage, arg0);\r\n            }\r\n\r\n            const result = createNode(kind);\r\n\r\n            if (kind === SyntaxKind.Identifier) {\r\n                (result as Identifier).escapedText = \"\" as __String;\r\n            }\r\n            else if (isLiteralKind(kind) || isTemplateLiteralKind(kind)) {\r\n                (result as LiteralLikeNode).text = \"\";\r\n            }\r\n\r\n            return finishNode(result) as T;\r\n        }\r\n\r\n        function internIdentifier(text: string): string {\r\n            let identifier = identifiers.get(text);\r\n            if (identifier === undefined) {\r\n                identifiers.set(text, identifier = text);\r\n            }\r\n            return identifier;\r\n        }\r\n\r\n        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues\r\n        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for\r\n        // each identifier in order to reduce memory consumption.\r\n        function createIdentifier(isIdentifier: boolean, diagnosticMessage?: DiagnosticMessage): Identifier {\r\n            identifierCount++;\r\n            if (isIdentifier) {\r\n                const node = <Identifier>createNode(SyntaxKind.Identifier);\r\n\r\n                // Store original token kind if it is not just an Identifier so we can report appropriate error later in type checker\r\n                if (token() !== SyntaxKind.Identifier) {\r\n                    node.originalKeywordKind = token();\r\n                }\r\n                node.escapedText = escapeLeadingUnderscores(internIdentifier(scanner.getTokenValue()));\r\n                nextToken();\r\n                return finishNode(node);\r\n            }\r\n\r\n            // Only for end of file because the error gets reported incorrectly on embedded script tags.\r\n            const reportAtCurrentPosition = token() === SyntaxKind.EndOfFileToken;\r\n\r\n            return createMissingNode<Identifier>(SyntaxKind.Identifier, reportAtCurrentPosition, diagnosticMessage || Diagnostics.Identifier_expected);\r\n        }\r\n\r\n        function parseIdentifier(diagnosticMessage?: DiagnosticMessage): Identifier {\r\n            return createIdentifier(isIdentifier(), diagnosticMessage);\r\n        }\r\n\r\n        function parseIdentifierName(diagnosticMessage?: DiagnosticMessage): Identifier {\r\n            return createIdentifier(tokenIsIdentifierOrKeyword(token()), diagnosticMessage);\r\n        }\r\n\r\n        function isLiteralPropertyName(): boolean {\r\n            return tokenIsIdentifierOrKeyword(token()) ||\r\n                token() === SyntaxKind.StringLiteral ||\r\n                token() === SyntaxKind.NumericLiteral;\r\n        }\r\n\r\n        function parsePropertyNameWorker(allowComputedPropertyNames: boolean): PropertyName {\r\n            if (token() === SyntaxKind.StringLiteral || token() === SyntaxKind.NumericLiteral) {\r\n                const node = <StringLiteral | NumericLiteral>parseLiteralNode();\r\n                node.text = internIdentifier(node.text);\r\n                return node;\r\n            }\r\n            if (allowComputedPropertyNames && token() === SyntaxKind.OpenBracketToken) {\r\n                return parseComputedPropertyName();\r\n            }\r\n            return parseIdentifierName();\r\n        }\r\n\r\n        function parsePropertyName(): PropertyName {\r\n            return parsePropertyNameWorker(/*allowComputedPropertyNames*/ true);\r\n        }\r\n\r\n        function parseComputedPropertyName(): ComputedPropertyName {\r\n            // PropertyName [Yield]:\r\n            //      LiteralPropertyName\r\n            //      ComputedPropertyName[?Yield]\r\n            const node = <ComputedPropertyName>createNode(SyntaxKind.ComputedPropertyName);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n\r\n            // We parse any expression (including a comma expression). But the grammar\r\n            // says that only an assignment expression is allowed, so the grammar checker\r\n            // will error if it sees a comma expression.\r\n            node.expression = allowInAnd(parseExpression);\r\n\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseContextualModifier(t: SyntaxKind): boolean {\r\n            return token() === t && tryParse(nextTokenCanFollowModifier);\r\n        }\r\n\r\n        function nextTokenIsOnSameLineAndCanFollowModifier() {\r\n            nextToken();\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                return false;\r\n            }\r\n            return canFollowModifier();\r\n        }\r\n\r\n        function nextTokenCanFollowModifier() {\r\n            switch (token()) {\r\n                case SyntaxKind.ConstKeyword:\r\n                    // 'const' is only a modifier if followed by 'enum'.\r\n                    return nextToken() === SyntaxKind.EnumKeyword;\r\n                case SyntaxKind.ExportKeyword:\r\n                    nextToken();\r\n                    if (token() === SyntaxKind.DefaultKeyword) {\r\n                        return lookAhead(nextTokenCanFollowDefaultKeyword);\r\n                    }\r\n                    return token() !== SyntaxKind.AsteriskToken && token() !== SyntaxKind.AsKeyword && token() !== SyntaxKind.OpenBraceToken && canFollowModifier();\r\n                case SyntaxKind.DefaultKeyword:\r\n                    return nextTokenCanFollowDefaultKeyword();\r\n                case SyntaxKind.StaticKeyword:\r\n                case SyntaxKind.GetKeyword:\r\n                case SyntaxKind.SetKeyword:\r\n                    nextToken();\r\n                    return canFollowModifier();\r\n                default:\r\n                    return nextTokenIsOnSameLineAndCanFollowModifier();\r\n            }\r\n        }\r\n\r\n        function parseAnyContextualModifier(): boolean {\r\n            return isModifierKind(token()) && tryParse(nextTokenCanFollowModifier);\r\n        }\r\n\r\n        function canFollowModifier(): boolean {\r\n            return token() === SyntaxKind.OpenBracketToken\r\n                || token() === SyntaxKind.OpenBraceToken\r\n                || token() === SyntaxKind.AsteriskToken\r\n                || token() === SyntaxKind.DotDotDotToken\r\n                || isLiteralPropertyName();\r\n        }\r\n\r\n        function nextTokenCanFollowDefaultKeyword(): boolean {\r\n            nextToken();\r\n            return token() === SyntaxKind.ClassKeyword || token() === SyntaxKind.FunctionKeyword ||\r\n                token() === SyntaxKind.InterfaceKeyword ||\r\n                (token() === SyntaxKind.AbstractKeyword && lookAhead(nextTokenIsClassKeywordOnSameLine)) ||\r\n                (token() === SyntaxKind.AsyncKeyword && lookAhead(nextTokenIsFunctionKeywordOnSameLine));\r\n        }\r\n\r\n        // True if positioned at the start of a list element\r\n        function isListElement(parsingContext: ParsingContext, inErrorRecovery: boolean): boolean {\r\n            const node = currentNode(parsingContext);\r\n            if (node) {\r\n                return true;\r\n            }\r\n\r\n            switch (parsingContext) {\r\n                case ParsingContext.SourceElements:\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.\r\n                    // The problem is that ';' can show up in far too many contexts, and if we see one\r\n                    // and assume it's a statement, then we may bail out inappropriately from whatever\r\n                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then\r\n                    // we really don't want to assume the class is over and we're on a statement in the\r\n                    // outer module.  We just want to consume and move on.\r\n                    return !(token() === SyntaxKind.SemicolonToken && inErrorRecovery) && isStartOfStatement();\r\n                case ParsingContext.SwitchClauses:\r\n                    return token() === SyntaxKind.CaseKeyword || token() === SyntaxKind.DefaultKeyword;\r\n                case ParsingContext.TypeMembers:\r\n                    return lookAhead(isTypeMemberStart);\r\n                case ParsingContext.ClassMembers:\r\n                    // We allow semicolons as class elements (as specified by ES6) as long as we're\r\n                    // not in error recovery.  If we're in error recovery, we don't want an errant\r\n                    // semicolon to be treated as a class member (since they're almost always used\r\n                    // for statements.\r\n                    return lookAhead(isClassMemberStart) || (token() === SyntaxKind.SemicolonToken && !inErrorRecovery);\r\n                case ParsingContext.EnumMembers:\r\n                    // Include open bracket computed properties. This technically also lets in indexers,\r\n                    // which would be a candidate for improved error reporting.\r\n                    return token() === SyntaxKind.OpenBracketToken || isLiteralPropertyName();\r\n                case ParsingContext.ObjectLiteralMembers:\r\n                    return token() === SyntaxKind.OpenBracketToken || token() === SyntaxKind.AsteriskToken || token() === SyntaxKind.DotDotDotToken || isLiteralPropertyName();\r\n                case ParsingContext.RestProperties:\r\n                    return isLiteralPropertyName();\r\n                case ParsingContext.ObjectBindingElements:\r\n                    return token() === SyntaxKind.OpenBracketToken || token() === SyntaxKind.DotDotDotToken || isLiteralPropertyName();\r\n                case ParsingContext.HeritageClauseElement:\r\n                    // If we see `{ ... }` then only consume it as an expression if it is followed by `,` or `{`\r\n                    // That way we won't consume the body of a class in its heritage clause.\r\n                    if (token() === SyntaxKind.OpenBraceToken) {\r\n                        return lookAhead(isValidHeritageClauseObjectLiteral);\r\n                    }\r\n\r\n                    if (!inErrorRecovery) {\r\n                        return isStartOfLeftHandSideExpression() && !isHeritageClauseExtendsOrImplementsKeyword();\r\n                    }\r\n                    else {\r\n                        // If we're in error recovery we tighten up what we're willing to match.\r\n                        // That way we don't treat something like \"this\" as a valid heritage clause\r\n                        // element during recovery.\r\n                        return isIdentifier() && !isHeritageClauseExtendsOrImplementsKeyword();\r\n                    }\r\n                case ParsingContext.VariableDeclarations:\r\n                    return isIdentifierOrPattern();\r\n                case ParsingContext.ArrayBindingElements:\r\n                    return token() === SyntaxKind.CommaToken || token() === SyntaxKind.DotDotDotToken || isIdentifierOrPattern();\r\n                case ParsingContext.TypeParameters:\r\n                    return isIdentifier();\r\n                case ParsingContext.ArrayLiteralMembers:\r\n                    if (token() === SyntaxKind.CommaToken) {\r\n                        return true;\r\n                    }\r\n                    // falls through\r\n                case ParsingContext.ArgumentExpressions:\r\n                    return token() === SyntaxKind.DotDotDotToken || isStartOfExpression();\r\n                case ParsingContext.Parameters:\r\n                    return isStartOfParameter();\r\n                case ParsingContext.TypeArguments:\r\n                case ParsingContext.TupleElementTypes:\r\n                    return token() === SyntaxKind.CommaToken || isStartOfType();\r\n                case ParsingContext.HeritageClauses:\r\n                    return isHeritageClause();\r\n                case ParsingContext.ImportOrExportSpecifiers:\r\n                    return tokenIsIdentifierOrKeyword(token());\r\n                case ParsingContext.JsxAttributes:\r\n                    return tokenIsIdentifierOrKeyword(token()) || token() === SyntaxKind.OpenBraceToken;\r\n                case ParsingContext.JsxChildren:\r\n                    return true;\r\n            }\r\n\r\n            Debug.fail(\"Non-exhaustive case in 'isListElement'.\");\r\n        }\r\n\r\n        function isValidHeritageClauseObjectLiteral() {\r\n            Debug.assert(token() === SyntaxKind.OpenBraceToken);\r\n            if (nextToken() === SyntaxKind.CloseBraceToken) {\r\n                // if we see \"extends {}\" then only treat the {} as what we're extending (and not\r\n                // the class body) if we have:\r\n                //\r\n                //      extends {} {\r\n                //      extends {},\r\n                //      extends {} extends\r\n                //      extends {} implements\r\n\r\n                const next = nextToken();\r\n                return next === SyntaxKind.CommaToken || next === SyntaxKind.OpenBraceToken || next === SyntaxKind.ExtendsKeyword || next === SyntaxKind.ImplementsKeyword;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function nextTokenIsIdentifier() {\r\n            nextToken();\r\n            return isIdentifier();\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrKeyword() {\r\n            nextToken();\r\n            return tokenIsIdentifierOrKeyword(token());\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrKeywordOrGreaterThan() {\r\n            nextToken();\r\n            return tokenIsIdentifierOrKeywordOrGreaterThan(token());\r\n        }\r\n\r\n        function isHeritageClauseExtendsOrImplementsKeyword(): boolean {\r\n            if (token() === SyntaxKind.ImplementsKeyword ||\r\n                token() === SyntaxKind.ExtendsKeyword) {\r\n\r\n                return lookAhead(nextTokenIsStartOfExpression);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function nextTokenIsStartOfExpression() {\r\n            nextToken();\r\n            return isStartOfExpression();\r\n        }\r\n\r\n        function nextTokenIsStartOfType() {\r\n            nextToken();\r\n            return isStartOfType();\r\n        }\r\n\r\n        // True if positioned at a list terminator\r\n        function isListTerminator(kind: ParsingContext): boolean {\r\n            if (token() === SyntaxKind.EndOfFileToken) {\r\n                // Being at the end of the file ends all lists.\r\n                return true;\r\n            }\r\n\r\n            switch (kind) {\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauses:\r\n                case ParsingContext.TypeMembers:\r\n                case ParsingContext.ClassMembers:\r\n                case ParsingContext.EnumMembers:\r\n                case ParsingContext.ObjectLiteralMembers:\r\n                case ParsingContext.ObjectBindingElements:\r\n                case ParsingContext.ImportOrExportSpecifiers:\r\n                    return token() === SyntaxKind.CloseBraceToken;\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    return token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.CaseKeyword || token() === SyntaxKind.DefaultKeyword;\r\n                case ParsingContext.HeritageClauseElement:\r\n                    return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.ExtendsKeyword || token() === SyntaxKind.ImplementsKeyword;\r\n                case ParsingContext.VariableDeclarations:\r\n                    return isVariableDeclaratorListTerminator();\r\n                case ParsingContext.TypeParameters:\r\n                    // Tokens other than '>' are here for better error recovery\r\n                    return token() === SyntaxKind.GreaterThanToken || token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.ExtendsKeyword || token() === SyntaxKind.ImplementsKeyword;\r\n                case ParsingContext.ArgumentExpressions:\r\n                    // Tokens other than ')' are here for better error recovery\r\n                    return token() === SyntaxKind.CloseParenToken || token() === SyntaxKind.SemicolonToken;\r\n                case ParsingContext.ArrayLiteralMembers:\r\n                case ParsingContext.TupleElementTypes:\r\n                case ParsingContext.ArrayBindingElements:\r\n                    return token() === SyntaxKind.CloseBracketToken;\r\n                case ParsingContext.Parameters:\r\n                case ParsingContext.RestProperties:\r\n                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery\r\n                    return token() === SyntaxKind.CloseParenToken || token() === SyntaxKind.CloseBracketToken /*|| token === SyntaxKind.OpenBraceToken*/;\r\n                case ParsingContext.TypeArguments:\r\n                    // All other tokens should cause the type-argument to terminate except comma token\r\n                    return token() !== SyntaxKind.CommaToken;\r\n                case ParsingContext.HeritageClauses:\r\n                    return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.CloseBraceToken;\r\n                case ParsingContext.JsxAttributes:\r\n                    return token() === SyntaxKind.GreaterThanToken || token() === SyntaxKind.SlashToken;\r\n                case ParsingContext.JsxChildren:\r\n                    return token() === SyntaxKind.LessThanToken && lookAhead(nextTokenIsSlash);\r\n            }\r\n        }\r\n\r\n        function isVariableDeclaratorListTerminator(): boolean {\r\n            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done\r\n            // with parsing the list of variable declarators.\r\n            if (canParseSemicolon()) {\r\n                return true;\r\n            }\r\n\r\n            // in the case where we're parsing the variable declarator of a 'for-in' statement, we\r\n            // are done if we see an 'in' keyword in front of us. Same with for-of\r\n            if (isInOrOfKeyword(token())) {\r\n                return true;\r\n            }\r\n\r\n            // ERROR RECOVERY TWEAK:\r\n            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an\r\n            // arrow function here and it's going to be very unlikely that we'll resynchronize and get\r\n            // another variable declaration.\r\n            if (token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                return true;\r\n            }\r\n\r\n            // Keep trying to parse out variable declarators.\r\n            return false;\r\n        }\r\n\r\n        // True if positioned at element or terminator of the current list or any enclosing list\r\n        function isInSomeParsingContext(): boolean {\r\n            for (let kind = 0; kind < ParsingContext.Count; kind++) {\r\n                if (parsingContext & (1 << kind)) {\r\n                    if (isListElement(kind, /*inErrorRecovery*/ true) || isListTerminator(kind)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Parses a list of elements\r\n        function parseList<T extends Node>(kind: ParsingContext, parseElement: () => T): NodeArray<T> {\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n\r\n            while (!isListTerminator(kind)) {\r\n                if (isListElement(kind, /*inErrorRecovery*/ false)) {\r\n                    const element = parseListElement(kind, parseElement);\r\n                    list.push(element);\r\n\r\n                    continue;\r\n                }\r\n\r\n                if (abortParsingListOrMoveToNextToken(kind)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            parsingContext = saveParsingContext;\r\n            return createNodeArray(list, listPos);\r\n        }\r\n\r\n        function parseListElement<T extends Node>(parsingContext: ParsingContext, parseElement: () => T): T {\r\n            const node = currentNode(parsingContext);\r\n            if (node) {\r\n                return <T>consumeNode(node);\r\n            }\r\n\r\n            return parseElement();\r\n        }\r\n\r\n        function currentNode(parsingContext: ParsingContext): Node {\r\n            // If there is an outstanding parse error that we've encountered, but not attached to\r\n            // some node, then we cannot get a node from the old source tree.  This is because we\r\n            // want to mark the next node we encounter as being unusable.\r\n            //\r\n            // Note: This may be too conservative.  Perhaps we could reuse the node and set the bit\r\n            // on it (or its leftmost child) as having the error.  For now though, being conservative\r\n            // is nice and likely won't ever affect perf.\r\n            if (parseErrorBeforeNextFinishedNode) {\r\n                return undefined;\r\n            }\r\n\r\n            if (!syntaxCursor) {\r\n                // if we don't have a cursor, we could never return a node from the old tree.\r\n                return undefined;\r\n            }\r\n\r\n            const node = syntaxCursor.currentNode(scanner.getStartPos());\r\n\r\n            // Can't reuse a missing node.\r\n            if (nodeIsMissing(node)) {\r\n                return undefined;\r\n            }\r\n\r\n            // Can't reuse a node that intersected the change range.\r\n            if (node.intersectsChange) {\r\n                return undefined;\r\n            }\r\n\r\n            // Can't reuse a node that contains a parse error.  This is necessary so that we\r\n            // produce the same set of errors again.\r\n            if (containsParseError(node)) {\r\n                return undefined;\r\n            }\r\n\r\n            // We can only reuse a node if it was parsed under the same strict mode that we're\r\n            // currently in.  i.e. if we originally parsed a node in non-strict mode, but then\r\n            // the user added 'using strict' at the top of the file, then we can't use that node\r\n            // again as the presence of strict mode may cause us to parse the tokens in the file\r\n            // differently.\r\n            //\r\n            // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens\r\n            // are unaffected by strict mode.  It's just the parser will decide what to do with it\r\n            // differently depending on what mode it is in.\r\n            //\r\n            // This also applies to all our other context flags as well.\r\n            const nodeContextFlags = node.flags & NodeFlags.ContextFlags;\r\n            if (nodeContextFlags !== contextFlags) {\r\n                return undefined;\r\n            }\r\n\r\n            // Ok, we have a node that looks like it could be reused.  Now verify that it is valid\r\n            // in the current list parsing context that we're currently at.\r\n            if (!canReuseNode(node, parsingContext)) {\r\n                return undefined;\r\n            }\r\n\r\n            if ((node as JSDocContainer).jsDocCache) {\r\n                // jsDocCache may include tags from parent nodes, which might have been modified.\r\n                (node as JSDocContainer).jsDocCache = undefined;\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        function consumeNode(node: Node) {\r\n            // Move the scanner so it is after the node we just consumed.\r\n            scanner.setTextPos(node.end);\r\n            nextToken();\r\n            return node;\r\n        }\r\n\r\n        function canReuseNode(node: Node, parsingContext: ParsingContext): boolean {\r\n            switch (parsingContext) {\r\n                case ParsingContext.ClassMembers:\r\n                    return isReusableClassMember(node);\r\n\r\n                case ParsingContext.SwitchClauses:\r\n                    return isReusableSwitchClause(node);\r\n\r\n                case ParsingContext.SourceElements:\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    return isReusableStatement(node);\r\n\r\n                case ParsingContext.EnumMembers:\r\n                    return isReusableEnumMember(node);\r\n\r\n                case ParsingContext.TypeMembers:\r\n                    return isReusableTypeMember(node);\r\n\r\n                case ParsingContext.VariableDeclarations:\r\n                    return isReusableVariableDeclaration(node);\r\n\r\n                case ParsingContext.Parameters:\r\n                    return isReusableParameter(node);\r\n\r\n                case ParsingContext.RestProperties:\r\n                    return false;\r\n\r\n                // Any other lists we do not care about reusing nodes in.  But feel free to add if\r\n                // you can do so safely.  Danger areas involve nodes that may involve speculative\r\n                // parsing.  If speculative parsing is involved with the node, then the range the\r\n                // parser reached while looking ahead might be in the edited range (see the example\r\n                // in canReuseVariableDeclaratorNode for a good case of this).\r\n                case ParsingContext.HeritageClauses:\r\n                // This would probably be safe to reuse.  There is no speculative parsing with\r\n                // heritage clauses.\r\n\r\n                case ParsingContext.TypeParameters:\r\n                // This would probably be safe to reuse.  There is no speculative parsing with\r\n                // type parameters.  Note that that's because type *parameters* only occur in\r\n                // unambiguous *type* contexts.  While type *arguments* occur in very ambiguous\r\n                // *expression* contexts.\r\n\r\n                case ParsingContext.TupleElementTypes:\r\n                // This would probably be safe to reuse.  There is no speculative parsing with\r\n                // tuple types.\r\n\r\n                // Technically, type argument list types are probably safe to reuse.  While\r\n                // speculative parsing is involved with them (since type argument lists are only\r\n                // produced from speculative parsing a < as a type argument list), we only have\r\n                // the types because speculative parsing succeeded.  Thus, the lookahead never\r\n                // went past the end of the list and rewound.\r\n                case ParsingContext.TypeArguments:\r\n\r\n                // Note: these are almost certainly not safe to ever reuse.  Expressions commonly\r\n                // need a large amount of lookahead, and we should not reuse them as they may\r\n                // have actually intersected the edit.\r\n                case ParsingContext.ArgumentExpressions:\r\n\r\n                // This is not safe to reuse for the same reason as the 'AssignmentExpression'\r\n                // cases.  i.e. a property assignment may end with an expression, and thus might\r\n                // have lookahead far beyond it's old node.\r\n                case ParsingContext.ObjectLiteralMembers:\r\n\r\n                // This is probably not safe to reuse.  There can be speculative parsing with\r\n                // type names in a heritage clause.  There can be generic names in the type\r\n                // name list, and there can be left hand side expressions (which can have type\r\n                // arguments.)\r\n                case ParsingContext.HeritageClauseElement:\r\n\r\n                // Perhaps safe to reuse, but it's unlikely we'd see more than a dozen attributes\r\n                // on any given element. Same for children.\r\n                case ParsingContext.JsxAttributes:\r\n                case ParsingContext.JsxChildren:\r\n\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableClassMember(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.IndexSignature:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                    case SyntaxKind.PropertyDeclaration:\r\n                    case SyntaxKind.SemicolonClassElement:\r\n                        return true;\r\n                    case SyntaxKind.MethodDeclaration:\r\n                        // Method declarations are not necessarily reusable.  An object-literal\r\n                        // may have a method calls \"constructor(...)\" and we must reparse that\r\n                        // into an actual .ConstructorDeclaration.\r\n                        const methodDeclaration = <MethodDeclaration>node;\r\n                        const nameIsConstructor = methodDeclaration.name.kind === SyntaxKind.Identifier &&\r\n                            methodDeclaration.name.originalKeywordKind === SyntaxKind.ConstructorKeyword;\r\n\r\n                        return !nameIsConstructor;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableSwitchClause(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.CaseClause:\r\n                    case SyntaxKind.DefaultClause:\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableStatement(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.VariableStatement:\r\n                    case SyntaxKind.Block:\r\n                    case SyntaxKind.IfStatement:\r\n                    case SyntaxKind.ExpressionStatement:\r\n                    case SyntaxKind.ThrowStatement:\r\n                    case SyntaxKind.ReturnStatement:\r\n                    case SyntaxKind.SwitchStatement:\r\n                    case SyntaxKind.BreakStatement:\r\n                    case SyntaxKind.ContinueStatement:\r\n                    case SyntaxKind.ForInStatement:\r\n                    case SyntaxKind.ForOfStatement:\r\n                    case SyntaxKind.ForStatement:\r\n                    case SyntaxKind.WhileStatement:\r\n                    case SyntaxKind.WithStatement:\r\n                    case SyntaxKind.EmptyStatement:\r\n                    case SyntaxKind.TryStatement:\r\n                    case SyntaxKind.LabeledStatement:\r\n                    case SyntaxKind.DoStatement:\r\n                    case SyntaxKind.DebuggerStatement:\r\n                    case SyntaxKind.ImportDeclaration:\r\n                    case SyntaxKind.ImportEqualsDeclaration:\r\n                    case SyntaxKind.ExportDeclaration:\r\n                    case SyntaxKind.ExportAssignment:\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                    case SyntaxKind.EnumDeclaration:\r\n                    case SyntaxKind.TypeAliasDeclaration:\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableEnumMember(node: Node) {\r\n            return node.kind === SyntaxKind.EnumMember;\r\n        }\r\n\r\n        function isReusableTypeMember(node: Node) {\r\n            if (node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.ConstructSignature:\r\n                    case SyntaxKind.MethodSignature:\r\n                    case SyntaxKind.IndexSignature:\r\n                    case SyntaxKind.PropertySignature:\r\n                    case SyntaxKind.CallSignature:\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isReusableVariableDeclaration(node: Node) {\r\n            if (node.kind !== SyntaxKind.VariableDeclaration) {\r\n                return false;\r\n            }\r\n\r\n            // Very subtle incremental parsing bug.  Consider the following code:\r\n            //\r\n            //      let v = new List < A, B\r\n            //\r\n            // This is actually legal code.  It's a list of variable declarators \"v = new List<A\"\r\n            // on one side and \"B\" on the other. If you then change that to:\r\n            //\r\n            //      let v = new List < A, B >()\r\n            //\r\n            // then we have a problem.  \"v = new List<A\" doesn't intersect the change range, so we\r\n            // start reparsing at \"B\" and we completely fail to handle this properly.\r\n            //\r\n            // In order to prevent this, we do not allow a variable declarator to be reused if it\r\n            // has an initializer.\r\n            const variableDeclarator = <VariableDeclaration>node;\r\n            return variableDeclarator.initializer === undefined;\r\n        }\r\n\r\n        function isReusableParameter(node: Node) {\r\n            if (node.kind !== SyntaxKind.Parameter) {\r\n                return false;\r\n            }\r\n\r\n            // See the comment in isReusableVariableDeclaration for why we do this.\r\n            const parameter = <ParameterDeclaration>node;\r\n            return parameter.initializer === undefined;\r\n        }\r\n\r\n        // Returns true if we should abort parsing.\r\n        function abortParsingListOrMoveToNextToken(kind: ParsingContext) {\r\n            parseErrorAtCurrentToken(parsingContextErrors(kind));\r\n            if (isInSomeParsingContext()) {\r\n                return true;\r\n            }\r\n\r\n            nextToken();\r\n            return false;\r\n        }\r\n\r\n        function parsingContextErrors(context: ParsingContext): DiagnosticMessage {\r\n            switch (context) {\r\n                case ParsingContext.SourceElements: return Diagnostics.Declaration_or_statement_expected;\r\n                case ParsingContext.BlockStatements: return Diagnostics.Declaration_or_statement_expected;\r\n                case ParsingContext.SwitchClauses: return Diagnostics.case_or_default_expected;\r\n                case ParsingContext.SwitchClauseStatements: return Diagnostics.Statement_expected;\r\n                case ParsingContext.RestProperties: // fallthrough\r\n                case ParsingContext.TypeMembers: return Diagnostics.Property_or_signature_expected;\r\n                case ParsingContext.ClassMembers: return Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected;\r\n                case ParsingContext.EnumMembers: return Diagnostics.Enum_member_expected;\r\n                case ParsingContext.HeritageClauseElement: return Diagnostics.Expression_expected;\r\n                case ParsingContext.VariableDeclarations: return Diagnostics.Variable_declaration_expected;\r\n                case ParsingContext.ObjectBindingElements: return Diagnostics.Property_destructuring_pattern_expected;\r\n                case ParsingContext.ArrayBindingElements: return Diagnostics.Array_element_destructuring_pattern_expected;\r\n                case ParsingContext.ArgumentExpressions: return Diagnostics.Argument_expression_expected;\r\n                case ParsingContext.ObjectLiteralMembers: return Diagnostics.Property_assignment_expected;\r\n                case ParsingContext.ArrayLiteralMembers: return Diagnostics.Expression_or_comma_expected;\r\n                case ParsingContext.Parameters: return Diagnostics.Parameter_declaration_expected;\r\n                case ParsingContext.TypeParameters: return Diagnostics.Type_parameter_declaration_expected;\r\n                case ParsingContext.TypeArguments: return Diagnostics.Type_argument_expected;\r\n                case ParsingContext.TupleElementTypes: return Diagnostics.Type_expected;\r\n                case ParsingContext.HeritageClauses: return Diagnostics.Unexpected_token_expected;\r\n                case ParsingContext.ImportOrExportSpecifiers: return Diagnostics.Identifier_expected;\r\n                case ParsingContext.JsxAttributes: return Diagnostics.Identifier_expected;\r\n                case ParsingContext.JsxChildren: return Diagnostics.Identifier_expected;\r\n            }\r\n        }\r\n\r\n        // Parses a comma-delimited list of elements\r\n        function parseDelimitedList<T extends Node>(kind: ParsingContext, parseElement: () => T, considerSemicolonAsDelimiter?: boolean): NodeArray<T> {\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n\r\n            let commaStart = -1; // Meaning the previous token was not a comma\r\n            while (true) {\r\n                if (isListElement(kind, /*inErrorRecovery*/ false)) {\r\n                    const startPos = scanner.getStartPos();\r\n                    list.push(parseListElement(kind, parseElement));\r\n                    commaStart = scanner.getTokenPos();\r\n\r\n                    if (parseOptional(SyntaxKind.CommaToken)) {\r\n                        // No need to check for a zero length node since we know we parsed a comma\r\n                        continue;\r\n                    }\r\n\r\n                    commaStart = -1; // Back to the state where the last token was not a comma\r\n                    if (isListTerminator(kind)) {\r\n                        break;\r\n                    }\r\n\r\n                    // We didn't get a comma, and the list wasn't terminated, explicitly parse\r\n                    // out a comma so we give a good error message.\r\n                    parseExpected(SyntaxKind.CommaToken);\r\n\r\n                    // If the token was a semicolon, and the caller allows that, then skip it and\r\n                    // continue.  This ensures we get back on track and don't result in tons of\r\n                    // parse errors.  For example, this can happen when people do things like use\r\n                    // a semicolon to delimit object literal members.   Note: we'll have already\r\n                    // reported an error when we called parseExpected above.\r\n                    if (considerSemicolonAsDelimiter && token() === SyntaxKind.SemicolonToken && !scanner.hasPrecedingLineBreak()) {\r\n                        nextToken();\r\n                    }\r\n                    if (startPos === scanner.getStartPos()) {\r\n                        // What we're parsing isn't actually remotely recognizable as a element and we've consumed no tokens whatsoever\r\n                        // Consume a token to advance the parser in some way and avoid an infinite loop\r\n                        // This can happen when we're speculatively parsing parenthesized expressions which we think may be arrow functions,\r\n                        // or when a modifier keyword which is disallowed as a parameter name (ie, `static` in strict mode) is supplied\r\n                        nextToken();\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (isListTerminator(kind)) {\r\n                    break;\r\n                }\r\n\r\n                if (abortParsingListOrMoveToNextToken(kind)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            parsingContext = saveParsingContext;\r\n            const result = createNodeArray(list, listPos);\r\n            // Recording the trailing comma is deliberately done after the previous\r\n            // loop, and not just if we see a list terminator. This is because the list\r\n            // may have ended incorrectly, but it is still important to know if there\r\n            // was a trailing comma.\r\n            // Check if the last token was a comma.\r\n            if (commaStart >= 0) {\r\n                // Always preserve a trailing comma by marking it on the NodeArray\r\n                result.hasTrailingComma = true;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function createMissingList<T extends Node>(): NodeArray<T> {\r\n            return createNodeArray<T>([], getNodePos());\r\n        }\r\n\r\n        function parseBracketedList<T extends Node>(kind: ParsingContext, parseElement: () => T, open: SyntaxKind, close: SyntaxKind): NodeArray<T> {\r\n            if (parseExpected(open)) {\r\n                const result = parseDelimitedList(kind, parseElement);\r\n                parseExpected(close);\r\n                return result;\r\n            }\r\n\r\n            return createMissingList<T>();\r\n        }\r\n\r\n        function parseEntityName(allowReservedWords: boolean, diagnosticMessage?: DiagnosticMessage): EntityName {\r\n            let entity: EntityName = allowReservedWords ? parseIdentifierName(diagnosticMessage) : parseIdentifier(diagnosticMessage);\r\n            let dotPos = scanner.getStartPos();\r\n            while (parseOptional(SyntaxKind.DotToken)) {\r\n                if (token() === SyntaxKind.LessThanToken) {\r\n                    // the entity is part of a JSDoc-style generic, so record the trailing dot for later error reporting\r\n                    entity.jsdocDotPos = dotPos;\r\n                    break;\r\n                }\r\n                dotPos = scanner.getStartPos();\r\n                entity = createQualifiedName(entity, parseRightSideOfDot(allowReservedWords));\r\n            }\r\n            return entity;\r\n        }\r\n\r\n        function createQualifiedName(entity: EntityName, name: Identifier): QualifiedName {\r\n            const node = createNode(SyntaxKind.QualifiedName, entity.pos) as QualifiedName;\r\n            node.left = entity;\r\n            node.right = name;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseRightSideOfDot(allowIdentifierNames: boolean): Identifier {\r\n            // Technically a keyword is valid here as all identifiers and keywords are identifier names.\r\n            // However, often we'll encounter this in error situations when the identifier or keyword\r\n            // is actually starting another valid construct.\r\n            //\r\n            // So, we check for the following specific case:\r\n            //\r\n            //      name.\r\n            //      identifierOrKeyword identifierNameOrKeyword\r\n            //\r\n            // Note: the newlines are important here.  For example, if that above code\r\n            // were rewritten into:\r\n            //\r\n            //      name.identifierOrKeyword\r\n            //      identifierNameOrKeyword\r\n            //\r\n            // Then we would consider it valid.  That's because ASI would take effect and\r\n            // the code would be implicitly: \"name.identifierOrKeyword; identifierNameOrKeyword\".\r\n            // In the first case though, ASI will not take effect because there is not a\r\n            // line terminator after the identifier or keyword.\r\n            if (scanner.hasPrecedingLineBreak() && tokenIsIdentifierOrKeyword(token())) {\r\n                const matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);\r\n\r\n                if (matchesPattern) {\r\n                    // Report that we need an identifier.  However, report it right after the dot,\r\n                    // and not on the next token.  This is because the next token might actually\r\n                    // be an identifier and the error would be quite confusing.\r\n                    return createMissingNode<Identifier>(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics.Identifier_expected);\r\n                }\r\n            }\r\n\r\n            return allowIdentifierNames ? parseIdentifierName() : parseIdentifier();\r\n        }\r\n\r\n        function parseTemplateExpression(): TemplateExpression {\r\n            const template = <TemplateExpression>createNode(SyntaxKind.TemplateExpression);\r\n\r\n            template.head = parseTemplateHead();\r\n            Debug.assert(template.head.kind === SyntaxKind.TemplateHead, \"Template head has wrong token kind\");\r\n\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n\r\n            do {\r\n                list.push(parseTemplateSpan());\r\n            }\r\n            while (lastOrUndefined(list).literal.kind === SyntaxKind.TemplateMiddle);\r\n\r\n            template.templateSpans = createNodeArray(list, listPos);\r\n\r\n            return finishNode(template);\r\n        }\r\n\r\n        function parseTemplateSpan(): TemplateSpan {\r\n            const span = <TemplateSpan>createNode(SyntaxKind.TemplateSpan);\r\n            span.expression = allowInAnd(parseExpression);\r\n\r\n            let literal: TemplateMiddle | TemplateTail;\r\n            if (token() === SyntaxKind.CloseBraceToken) {\r\n                reScanTemplateToken();\r\n                literal = parseTemplateMiddleOrTemplateTail();\r\n            }\r\n            else {\r\n                literal = <TemplateTail>parseExpectedToken(SyntaxKind.TemplateTail, Diagnostics._0_expected, tokenToString(SyntaxKind.CloseBraceToken));\r\n            }\r\n\r\n            span.literal = literal;\r\n            return finishNode(span);\r\n        }\r\n\r\n        function parseLiteralNode(): LiteralExpression {\r\n            return <LiteralExpression>parseLiteralLikeNode(token());\r\n        }\r\n\r\n        function parseTemplateHead(): TemplateHead {\r\n            const fragment = parseLiteralLikeNode(token());\r\n            Debug.assert(fragment.kind === SyntaxKind.TemplateHead, \"Template head has wrong token kind\");\r\n            return <TemplateHead>fragment;\r\n        }\r\n\r\n        function parseTemplateMiddleOrTemplateTail(): TemplateMiddle | TemplateTail {\r\n            const fragment = parseLiteralLikeNode(token());\r\n            Debug.assert(fragment.kind === SyntaxKind.TemplateMiddle || fragment.kind === SyntaxKind.TemplateTail, \"Template fragment has wrong token kind\");\r\n            return <TemplateMiddle | TemplateTail>fragment;\r\n        }\r\n\r\n        function parseLiteralLikeNode(kind: SyntaxKind): LiteralExpression | LiteralLikeNode {\r\n            const node = <LiteralExpression>createNode(kind);\r\n            const text = scanner.getTokenValue();\r\n            node.text = text;\r\n\r\n            if (scanner.hasExtendedUnicodeEscape()) {\r\n                node.hasExtendedUnicodeEscape = true;\r\n            }\r\n\r\n            if (scanner.isUnterminated()) {\r\n                node.isUnterminated = true;\r\n            }\r\n\r\n            // Octal literals are not allowed in strict mode or ES5\r\n            // Note that theoretically the following condition would hold true literals like 009,\r\n            // which is not octal.But because of how the scanner separates the tokens, we would\r\n            // never get a token like this. Instead, we would get 00 and 9 as two separate tokens.\r\n            // We also do not need to check for negatives because any prefix operator would be part of a\r\n            // parent unary expression.\r\n            if (node.kind === SyntaxKind.NumericLiteral) {\r\n                (<NumericLiteral>node).numericLiteralFlags = scanner.getTokenFlags() & TokenFlags.NumericLiteralFlags;\r\n            }\r\n\r\n            nextToken();\r\n            finishNode(node);\r\n\r\n            return node;\r\n        }\r\n\r\n        // TYPES\r\n\r\n        function parseTypeReference(): TypeReferenceNode {\r\n            const node = <TypeReferenceNode>createNode(SyntaxKind.TypeReference);\r\n            node.typeName = parseEntityName(/*allowReservedWords*/ true, Diagnostics.Type_expected);\r\n            if (!scanner.hasPrecedingLineBreak() && token() === SyntaxKind.LessThanToken) {\r\n                node.typeArguments = parseBracketedList(ParsingContext.TypeArguments, parseType, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseThisTypePredicate(lhs: ThisTypeNode): TypePredicateNode {\r\n            nextToken();\r\n            const node = createNode(SyntaxKind.TypePredicate, lhs.pos) as TypePredicateNode;\r\n            node.parameterName = lhs;\r\n            node.type = parseType();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseThisTypeNode(): ThisTypeNode {\r\n            const node = createNode(SyntaxKind.ThisType) as ThisTypeNode;\r\n            nextToken();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJSDocAllType(postFixEquals: boolean): JSDocAllType | JSDocOptionalType {\r\n            const result = createNode(SyntaxKind.JSDocAllType) as JSDocAllType;\r\n            if (postFixEquals) {\r\n                return createJSDocPostfixType(SyntaxKind.JSDocOptionalType, result) as JSDocOptionalType;\r\n            }\r\n            else {\r\n                nextToken();\r\n            }\r\n            return finishNode(result);\r\n        }\r\n\r\n        function parseJSDocNonNullableType(): TypeNode {\r\n            const result = createNode(SyntaxKind.JSDocNonNullableType) as JSDocNonNullableType;\r\n            nextToken();\r\n            result.type = parseNonArrayType();\r\n            return finishNode(result);\r\n        }\r\n\r\n        function parseJSDocUnknownOrNullableType(): JSDocUnknownType | JSDocNullableType {\r\n            const pos = scanner.getStartPos();\r\n            // skip the ?\r\n            nextToken();\r\n\r\n            // Need to lookahead to decide if this is a nullable or unknown type.\r\n\r\n            // Here are cases where we'll pick the unknown type:\r\n            //\r\n            //      Foo(?,\r\n            //      { a: ? }\r\n            //      Foo(?)\r\n            //      Foo<?>\r\n            //      Foo(?=\r\n            //      (?|\r\n            if (token() === SyntaxKind.CommaToken ||\r\n                token() === SyntaxKind.CloseBraceToken ||\r\n                token() === SyntaxKind.CloseParenToken ||\r\n                token() === SyntaxKind.GreaterThanToken ||\r\n                token() === SyntaxKind.EqualsToken ||\r\n                token() === SyntaxKind.BarToken) {\r\n\r\n                const result = <JSDocUnknownType>createNode(SyntaxKind.JSDocUnknownType, pos);\r\n                return finishNode(result);\r\n            }\r\n            else {\r\n                const result = <JSDocNullableType>createNode(SyntaxKind.JSDocNullableType, pos);\r\n                result.type = parseType();\r\n                return finishNode(result);\r\n            }\r\n        }\r\n\r\n        function parseJSDocFunctionType(): JSDocFunctionType | TypeReferenceNode {\r\n            if (lookAhead(nextTokenIsOpenParen)) {\r\n                const result = <JSDocFunctionType>createNodeWithJSDoc(SyntaxKind.JSDocFunctionType);\r\n                nextToken();\r\n                fillSignature(SyntaxKind.ColonToken, SignatureFlags.Type | SignatureFlags.JSDoc, result);\r\n                return finishNode(result);\r\n            }\r\n            const node = <TypeReferenceNode>createNode(SyntaxKind.TypeReference);\r\n            node.typeName = parseIdentifierName();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJSDocParameter(): ParameterDeclaration {\r\n            const parameter = createNode(SyntaxKind.Parameter) as ParameterDeclaration;\r\n            if (token() === SyntaxKind.ThisKeyword || token() === SyntaxKind.NewKeyword) {\r\n                parameter.name = parseIdentifierName();\r\n                parseExpected(SyntaxKind.ColonToken);\r\n            }\r\n            parameter.type = parseJSDocType();\r\n            return finishNode(parameter);\r\n        }\r\n\r\n        function parseJSDocType() {\r\n            const dotdotdot = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n            let type = parseType();\r\n            if (dotdotdot) {\r\n                const variadic = createNode(SyntaxKind.JSDocVariadicType, dotdotdot.pos) as JSDocVariadicType;\r\n                variadic.type = type;\r\n                type = finishNode(variadic);\r\n            }\r\n            if (token() === SyntaxKind.EqualsToken) {\r\n                return createJSDocPostfixType(SyntaxKind.JSDocOptionalType, type);\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function parseTypeQuery(): TypeQueryNode {\r\n            const node = <TypeQueryNode>createNode(SyntaxKind.TypeQuery);\r\n            parseExpected(SyntaxKind.TypeOfKeyword);\r\n            node.exprName = parseEntityName(/*allowReservedWords*/ true);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeParameter(): TypeParameterDeclaration {\r\n            const node = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter);\r\n            node.name = parseIdentifier();\r\n            if (parseOptional(SyntaxKind.ExtendsKeyword)) {\r\n                // It's not uncommon for people to write improper constraints to a generic.  If the\r\n                // user writes a constraint that is an expression and not an actual type, then parse\r\n                // it out as an expression (so we can recover well), but report that a type is needed\r\n                // instead.\r\n                if (isStartOfType() || !isStartOfExpression()) {\r\n                    node.constraint = parseType();\r\n                }\r\n                else {\r\n                    // It was not a type, and it looked like an expression.  Parse out an expression\r\n                    // here so we recover well.  Note: it is important that we call parseUnaryExpression\r\n                    // and not parseExpression here.  If the user has:\r\n                    //\r\n                    //      <T extends \"\">\r\n                    //\r\n                    // We do *not* want to consume the `>` as we're consuming the expression for \"\".\r\n                    node.expression = parseUnaryExpressionOrHigher();\r\n                }\r\n            }\r\n\r\n            if (parseOptional(SyntaxKind.EqualsToken)) {\r\n                node.default = parseType();\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeParameters(): NodeArray<TypeParameterDeclaration> | undefined {\r\n            if (token() === SyntaxKind.LessThanToken) {\r\n                return parseBracketedList(ParsingContext.TypeParameters, parseTypeParameter, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken);\r\n            }\r\n        }\r\n\r\n        function parseParameterType(): TypeNode {\r\n            if (parseOptional(SyntaxKind.ColonToken)) {\r\n                return parseType();\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function isStartOfParameter(): boolean {\r\n            return token() === SyntaxKind.DotDotDotToken ||\r\n                isIdentifierOrPattern() ||\r\n                isModifierKind(token()) ||\r\n                token() === SyntaxKind.AtToken ||\r\n                isStartOfType(/*inStartOfParameter*/ true);\r\n        }\r\n\r\n        function parseParameter(): ParameterDeclaration {\r\n            const node = <ParameterDeclaration>createNodeWithJSDoc(SyntaxKind.Parameter);\r\n            if (token() === SyntaxKind.ThisKeyword) {\r\n                node.name = createIdentifier(/*isIdentifier*/ true);\r\n                node.type = parseParameterType();\r\n                return finishNode(node);\r\n            }\r\n\r\n            node.decorators = parseDecorators();\r\n            node.modifiers = parseModifiers();\r\n            node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n\r\n            // FormalParameter [Yield,Await]:\r\n            //      BindingElement[?Yield,?Await]\r\n            node.name = parseIdentifierOrPattern();\r\n            if (getFullWidth(node.name) === 0 && !hasModifiers(node) && isModifierKind(token())) {\r\n                // in cases like\r\n                // 'use strict'\r\n                // function foo(static)\r\n                // isParameter('static') === true, because of isModifier('static')\r\n                // however 'static' is not a legal identifier in a strict mode.\r\n                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)\r\n                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)\r\n                // to avoid this we'll advance cursor to the next token.\r\n                nextToken();\r\n            }\r\n\r\n            node.questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            node.type = parseParameterType();\r\n            node.initializer = parseInitializer();\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function fillSignature(\r\n            returnToken: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken,\r\n            flags: SignatureFlags,\r\n            signature: SignatureDeclaration): void {\r\n            if (!(flags & SignatureFlags.JSDoc)) {\r\n                signature.typeParameters = parseTypeParameters();\r\n            }\r\n            signature.parameters = parseParameterList(flags);\r\n            signature.type = parseReturnType(returnToken, !!(flags & SignatureFlags.Type));\r\n        }\r\n\r\n        function parseReturnType(returnToken: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken, isType: boolean): TypeNode | undefined {\r\n            return shouldParseReturnType(returnToken, isType) ? parseTypeOrTypePredicate() : undefined;\r\n        }\r\n        function shouldParseReturnType(returnToken: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken, isType: boolean): boolean {\r\n            if (returnToken === SyntaxKind.EqualsGreaterThanToken) {\r\n                parseExpected(returnToken);\r\n                return true;\r\n            }\r\n            else if (parseOptional(SyntaxKind.ColonToken)) {\r\n                return true;\r\n            }\r\n            else if (isType && token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                // This is easy to get backward, especially in type contexts, so parse the type anyway\r\n                parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKind.ColonToken));\r\n                nextToken();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseParameterList(flags: SignatureFlags) {\r\n            // FormalParameters [Yield,Await]: (modified)\r\n            //      [empty]\r\n            //      FormalParameterList[?Yield,Await]\r\n            //\r\n            // FormalParameter[Yield,Await]: (modified)\r\n            //      BindingElement[?Yield,Await]\r\n            //\r\n            // BindingElement [Yield,Await]: (modified)\r\n            //      SingleNameBinding[?Yield,?Await]\r\n            //      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt\r\n            //\r\n            // SingleNameBinding [Yield,Await]:\r\n            //      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt\r\n            if (parseExpected(SyntaxKind.OpenParenToken)) {\r\n                const savedYieldContext = inYieldContext();\r\n                const savedAwaitContext = inAwaitContext();\r\n\r\n                setYieldContext(!!(flags & SignatureFlags.Yield));\r\n                setAwaitContext(!!(flags & SignatureFlags.Await));\r\n\r\n                const result = parseDelimitedList(ParsingContext.Parameters, flags & SignatureFlags.JSDoc ? parseJSDocParameter : parseParameter);\r\n\r\n                setYieldContext(savedYieldContext);\r\n                setAwaitContext(savedAwaitContext);\r\n\r\n                if (!parseExpected(SyntaxKind.CloseParenToken) && (flags & SignatureFlags.RequireCompleteParameterList)) {\r\n                    // Caller insisted that we had to end with a )   We didn't.  So just return\r\n                    // undefined here.\r\n                    return undefined;\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n            // We didn't even have an open paren.  If the caller requires a complete parameter list,\r\n            // we definitely can't provide that.  However, if they're ok with an incomplete one,\r\n            // then just return an empty set of parameters.\r\n            return (flags & SignatureFlags.RequireCompleteParameterList) ? undefined : createMissingList<ParameterDeclaration>();\r\n        }\r\n\r\n        function parseTypeMemberSemicolon() {\r\n            // We allow type members to be separated by commas or (possibly ASI) semicolons.\r\n            // First check if it was a comma.  If so, we're done with the member.\r\n            if (parseOptional(SyntaxKind.CommaToken)) {\r\n                return;\r\n            }\r\n\r\n            // Didn't have a comma.  We must have a (possible ASI) semicolon.\r\n            parseSemicolon();\r\n        }\r\n\r\n        function parseSignatureMember(kind: SyntaxKind.CallSignature | SyntaxKind.ConstructSignature): CallSignatureDeclaration | ConstructSignatureDeclaration {\r\n            const node = <CallSignatureDeclaration | ConstructSignatureDeclaration>createNodeWithJSDoc(kind);\r\n            if (kind === SyntaxKind.ConstructSignature) {\r\n                parseExpected(SyntaxKind.NewKeyword);\r\n            }\r\n            fillSignature(SyntaxKind.ColonToken, SignatureFlags.Type, node);\r\n            parseTypeMemberSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isIndexSignature(): boolean {\r\n            return token() === SyntaxKind.OpenBracketToken && lookAhead(isUnambiguouslyIndexSignature);\r\n        }\r\n\r\n        function isUnambiguouslyIndexSignature() {\r\n            // The only allowed sequence is:\r\n            //\r\n            //   [id:\r\n            //\r\n            // However, for error recovery, we also check the following cases:\r\n            //\r\n            //   [...\r\n            //   [id,\r\n            //   [id?,\r\n            //   [id?:\r\n            //   [id?]\r\n            //   [public id\r\n            //   [private id\r\n            //   [protected id\r\n            //   []\r\n            //\r\n            nextToken();\r\n            if (token() === SyntaxKind.DotDotDotToken || token() === SyntaxKind.CloseBracketToken) {\r\n                return true;\r\n            }\r\n\r\n            if (isModifierKind(token())) {\r\n                nextToken();\r\n                if (isIdentifier()) {\r\n                    return true;\r\n                }\r\n            }\r\n            else if (!isIdentifier()) {\r\n                return false;\r\n            }\r\n            else {\r\n                // Skip the identifier\r\n                nextToken();\r\n            }\r\n\r\n            // A colon signifies a well formed indexer\r\n            // A comma should be a badly formed indexer because comma expressions are not allowed\r\n            // in computed properties.\r\n            if (token() === SyntaxKind.ColonToken || token() === SyntaxKind.CommaToken) {\r\n                return true;\r\n            }\r\n\r\n            // Question mark could be an indexer with an optional property,\r\n            // or it could be a conditional expression in a computed property.\r\n            if (token() !== SyntaxKind.QuestionToken) {\r\n                return false;\r\n            }\r\n\r\n            // If any of the following tokens are after the question mark, it cannot\r\n            // be a conditional expression, so treat it as an indexer.\r\n            nextToken();\r\n            return token() === SyntaxKind.ColonToken || token() === SyntaxKind.CommaToken || token() === SyntaxKind.CloseBracketToken;\r\n        }\r\n\r\n        function parseIndexSignatureDeclaration(node: IndexSignatureDeclaration): IndexSignatureDeclaration {\r\n            node.kind = SyntaxKind.IndexSignature;\r\n            node.parameters = parseBracketedList(ParsingContext.Parameters, parseParameter, SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\r\n            node.type = parseTypeAnnotation();\r\n            parseTypeMemberSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parsePropertyOrMethodSignature(node: PropertySignature | MethodSignature): PropertySignature | MethodSignature {\r\n            node.name = parsePropertyName();\r\n            node.questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                node.kind = SyntaxKind.MethodSignature;\r\n                // Method signatures don't exist in expression contexts.  So they have neither\r\n                // [Yield] nor [Await]\r\n                fillSignature(SyntaxKind.ColonToken, SignatureFlags.Type, <MethodSignature>node);\r\n            }\r\n            else {\r\n                node.kind = SyntaxKind.PropertySignature;\r\n                node.type = parseTypeAnnotation();\r\n                if (token() === SyntaxKind.EqualsToken) {\r\n                    // Although type literal properties cannot not have initializers, we attempt\r\n                    // to parse an initializer so we can report in the checker that an interface\r\n                    // property or type literal property cannot have an initializer.\r\n                    (<PropertySignature>node).initializer = parseInitializer();\r\n                }\r\n            }\r\n            parseTypeMemberSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isTypeMemberStart(): boolean {\r\n            // Return true if we have the start of a signature member\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return true;\r\n            }\r\n            let idToken: boolean;\r\n            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier\r\n            while (isModifierKind(token())) {\r\n                idToken = true;\r\n                nextToken();\r\n            }\r\n            // Index signatures and computed property names are type members\r\n            if (token() === SyntaxKind.OpenBracketToken) {\r\n                return true;\r\n            }\r\n            // Try to get the first property-like token following all modifiers\r\n            if (isLiteralPropertyName()) {\r\n                idToken = true;\r\n                nextToken();\r\n            }\r\n            // If we were able to get any potential identifier, check that it is\r\n            // the start of a member declaration\r\n            if (idToken) {\r\n                return token() === SyntaxKind.OpenParenToken ||\r\n                    token() === SyntaxKind.LessThanToken ||\r\n                    token() === SyntaxKind.QuestionToken ||\r\n                    token() === SyntaxKind.ColonToken ||\r\n                    token() === SyntaxKind.CommaToken ||\r\n                    canParseSemicolon();\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseTypeMember(): TypeElement {\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return parseSignatureMember(SyntaxKind.CallSignature);\r\n            }\r\n            if (token() === SyntaxKind.NewKeyword && lookAhead(nextTokenIsOpenParenOrLessThan)) {\r\n                return parseSignatureMember(SyntaxKind.ConstructSignature);\r\n            }\r\n            const node = <TypeElement>createNodeWithJSDoc(SyntaxKind.Unknown);\r\n            node.modifiers = parseModifiers();\r\n            if (isIndexSignature()) {\r\n                return parseIndexSignatureDeclaration(<IndexSignatureDeclaration>node);\r\n            }\r\n            return parsePropertyOrMethodSignature(<PropertySignature | MethodSignature>node);\r\n        }\r\n\r\n        function nextTokenIsOpenParenOrLessThan() {\r\n            nextToken();\r\n            return token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken;\r\n        }\r\n\r\n        function nextTokenIsDot() {\r\n            return nextToken() === SyntaxKind.DotToken;\r\n        }\r\n\r\n        function nextTokenIsOpenParenOrLessThanOrDot() {\r\n            switch (nextToken()) {\r\n                case SyntaxKind.OpenParenToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.DotToken:\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseTypeLiteral(): TypeLiteralNode {\r\n            const node = <TypeLiteralNode>createNode(SyntaxKind.TypeLiteral);\r\n            node.members = parseObjectTypeMembers();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectTypeMembers(): NodeArray<TypeElement> {\r\n            let members: NodeArray<TypeElement>;\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                members = parseList(ParsingContext.TypeMembers, parseTypeMember);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                members = createMissingList<TypeElement>();\r\n            }\r\n\r\n            return members;\r\n        }\r\n\r\n        function isStartOfMappedType() {\r\n            nextToken();\r\n            if (token() === SyntaxKind.PlusToken || token() === SyntaxKind.MinusToken) {\r\n                return nextToken() === SyntaxKind.ReadonlyKeyword;\r\n            }\r\n            if (token() === SyntaxKind.ReadonlyKeyword) {\r\n                nextToken();\r\n            }\r\n            return token() === SyntaxKind.OpenBracketToken && nextTokenIsIdentifier() && nextToken() === SyntaxKind.InKeyword;\r\n        }\r\n\r\n        function parseMappedTypeParameter() {\r\n            const node = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter);\r\n            node.name = parseIdentifier();\r\n            parseExpected(SyntaxKind.InKeyword);\r\n            node.constraint = parseType();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseMappedType() {\r\n            const node = <MappedTypeNode>createNode(SyntaxKind.MappedType);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            if (token() === SyntaxKind.ReadonlyKeyword || token() === SyntaxKind.PlusToken || token() === SyntaxKind.MinusToken) {\r\n                node.readonlyToken = parseTokenNode();\r\n                if (node.readonlyToken.kind !== SyntaxKind.ReadonlyKeyword) {\r\n                    parseExpectedToken(SyntaxKind.ReadonlyKeyword);\r\n                }\r\n            }\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n            node.typeParameter = parseMappedTypeParameter();\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            if (token() === SyntaxKind.QuestionToken || token() === SyntaxKind.PlusToken || token() === SyntaxKind.MinusToken) {\r\n                node.questionToken = parseTokenNode();\r\n                if (node.questionToken.kind !== SyntaxKind.QuestionToken) {\r\n                    parseExpectedToken(SyntaxKind.QuestionToken);\r\n                }\r\n            }\r\n            node.type = parseTypeAnnotation();\r\n            parseSemicolon();\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTupleType(): TupleTypeNode {\r\n            const node = <TupleTypeNode>createNode(SyntaxKind.TupleType);\r\n            node.elementTypes = parseBracketedList(ParsingContext.TupleElementTypes, parseType, SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseParenthesizedType(): ParenthesizedTypeNode {\r\n            const node = <ParenthesizedTypeNode>createNode(SyntaxKind.ParenthesizedType);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.type = parseType();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionOrConstructorType(kind: SyntaxKind): FunctionOrConstructorTypeNode {\r\n            const node = <FunctionOrConstructorTypeNode>createNodeWithJSDoc(kind);\r\n            if (kind === SyntaxKind.ConstructorType) {\r\n                parseExpected(SyntaxKind.NewKeyword);\r\n            }\r\n            fillSignature(SyntaxKind.EqualsGreaterThanToken, SignatureFlags.Type, node);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseKeywordAndNoDot(): TypeNode | undefined {\r\n            const node = parseTokenNode<TypeNode>();\r\n            return token() === SyntaxKind.DotToken ? undefined : node;\r\n        }\r\n\r\n        function parseLiteralTypeNode(negative?: boolean): LiteralTypeNode {\r\n            const node = createNode(SyntaxKind.LiteralType) as LiteralTypeNode;\r\n            let unaryMinusExpression: PrefixUnaryExpression;\r\n            if (negative) {\r\n                unaryMinusExpression = createNode(SyntaxKind.PrefixUnaryExpression) as PrefixUnaryExpression;\r\n                unaryMinusExpression.operator = SyntaxKind.MinusToken;\r\n                nextToken();\r\n            }\r\n            let expression: BooleanLiteral | LiteralExpression | PrefixUnaryExpression = token() === SyntaxKind.TrueKeyword || token() === SyntaxKind.FalseKeyword\r\n                ? parseTokenNode<BooleanLiteral>()\r\n                : parseLiteralLikeNode(token()) as LiteralExpression;\r\n            if (negative) {\r\n                unaryMinusExpression.operand = expression;\r\n                finishNode(unaryMinusExpression);\r\n                expression = unaryMinusExpression;\r\n            }\r\n            node.literal = expression;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isStartOfTypeOfImportType() {\r\n            nextToken();\r\n            return token() === SyntaxKind.ImportKeyword;\r\n        }\r\n\r\n        function parseImportType(): ImportTypeNode {\r\n            sourceFile.flags |= NodeFlags.PossiblyContainsDynamicImport;\r\n            const node = createNode(SyntaxKind.ImportType) as ImportTypeNode;\r\n            if (parseOptional(SyntaxKind.TypeOfKeyword)) {\r\n                node.isTypeOf = true;\r\n            }\r\n            parseExpected(SyntaxKind.ImportKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.argument = parseType();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            if (parseOptional(SyntaxKind.DotToken)) {\r\n                node.qualifier = parseEntityName(/*allowReservedWords*/ true, Diagnostics.Type_expected);\r\n            }\r\n            node.typeArguments = tryParseTypeArguments();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function nextTokenIsNumericLiteral() {\r\n            return nextToken() === SyntaxKind.NumericLiteral;\r\n        }\r\n\r\n        function parseNonArrayType(): TypeNode {\r\n            switch (token()) {\r\n                case SyntaxKind.AnyKeyword:\r\n                case SyntaxKind.StringKeyword:\r\n                case SyntaxKind.NumberKeyword:\r\n                case SyntaxKind.SymbolKeyword:\r\n                case SyntaxKind.BooleanKeyword:\r\n                case SyntaxKind.UndefinedKeyword:\r\n                case SyntaxKind.NeverKeyword:\r\n                case SyntaxKind.ObjectKeyword:\r\n                    // If these are followed by a dot, then parse these out as a dotted type reference instead.\r\n                    return tryParse(parseKeywordAndNoDot) || parseTypeReference();\r\n                case SyntaxKind.AsteriskToken:\r\n                    return parseJSDocAllType(/*postfixEquals*/ false);\r\n                case SyntaxKind.AsteriskEqualsToken:\r\n                    return parseJSDocAllType(/*postfixEquals*/ true);\r\n                case SyntaxKind.QuestionToken:\r\n                    return parseJSDocUnknownOrNullableType();\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseJSDocFunctionType();\r\n                case SyntaxKind.ExclamationToken:\r\n                    return parseJSDocNonNullableType();\r\n                case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                    return parseLiteralTypeNode();\r\n                case SyntaxKind.MinusToken:\r\n                    return lookAhead(nextTokenIsNumericLiteral) ? parseLiteralTypeNode(/*negative*/ true) : parseTypeReference();\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                    return parseTokenNode<TypeNode>();\r\n                case SyntaxKind.ThisKeyword: {\r\n                    const thisKeyword = parseThisTypeNode();\r\n                    if (token() === SyntaxKind.IsKeyword && !scanner.hasPrecedingLineBreak()) {\r\n                        return parseThisTypePredicate(thisKeyword);\r\n                    }\r\n                    else {\r\n                        return thisKeyword;\r\n                    }\r\n                }\r\n                case SyntaxKind.TypeOfKeyword:\r\n                    return lookAhead(isStartOfTypeOfImportType) ? parseImportType() : parseTypeQuery();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return lookAhead(isStartOfMappedType) ? parseMappedType() : parseTypeLiteral();\r\n                case SyntaxKind.OpenBracketToken:\r\n                    return parseTupleType();\r\n                case SyntaxKind.OpenParenToken:\r\n                    return parseParenthesizedType();\r\n                case SyntaxKind.ImportKeyword:\r\n                    return parseImportType();\r\n                default:\r\n                    return parseTypeReference();\r\n            }\r\n        }\r\n\r\n        function isStartOfType(inStartOfParameter?: boolean): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.AnyKeyword:\r\n                case SyntaxKind.StringKeyword:\r\n                case SyntaxKind.NumberKeyword:\r\n                case SyntaxKind.BooleanKeyword:\r\n                case SyntaxKind.SymbolKeyword:\r\n                case SyntaxKind.UniqueKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.UndefinedKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.NeverKeyword:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.OpenBracketToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.BarToken:\r\n                case SyntaxKind.AmpersandToken:\r\n                case SyntaxKind.NewKeyword:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                case SyntaxKind.ObjectKeyword:\r\n                case SyntaxKind.AsteriskToken:\r\n                case SyntaxKind.QuestionToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DotDotDotToken:\r\n                case SyntaxKind.InferKeyword:\r\n                case SyntaxKind.ImportKeyword:\r\n                    return true;\r\n                case SyntaxKind.MinusToken:\r\n                    return !inStartOfParameter && lookAhead(nextTokenIsNumericLiteral);\r\n                case SyntaxKind.OpenParenToken:\r\n                    // Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,\r\n                    // or something that starts a type. We don't want to consider things like '(1)' a type.\r\n                    return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType);\r\n                default:\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function isStartOfParenthesizedOrFunctionType() {\r\n            nextToken();\r\n            return token() === SyntaxKind.CloseParenToken || isStartOfParameter() || isStartOfType();\r\n        }\r\n\r\n        function parsePostfixTypeOrHigher(): TypeNode {\r\n            let type = parseNonArrayType();\r\n            while (!scanner.hasPrecedingLineBreak()) {\r\n                switch (token()) {\r\n                    case SyntaxKind.ExclamationToken:\r\n                        type = createJSDocPostfixType(SyntaxKind.JSDocNonNullableType, type);\r\n                        break;\r\n                    case SyntaxKind.QuestionToken:\r\n                        // If not in JSDoc and next token is start of a type we have a conditional type\r\n                        if (!(contextFlags & NodeFlags.JSDoc) && lookAhead(nextTokenIsStartOfType)) {\r\n                            return type;\r\n                        }\r\n                        type = createJSDocPostfixType(SyntaxKind.JSDocNullableType, type);\r\n                        break;\r\n                    case SyntaxKind.OpenBracketToken:\r\n                        parseExpected(SyntaxKind.OpenBracketToken);\r\n                        if (isStartOfType()) {\r\n                            const node = createNode(SyntaxKind.IndexedAccessType, type.pos) as IndexedAccessTypeNode;\r\n                            node.objectType = type;\r\n                            node.indexType = parseType();\r\n                            parseExpected(SyntaxKind.CloseBracketToken);\r\n                            type = finishNode(node);\r\n                        }\r\n                        else {\r\n                            const node = createNode(SyntaxKind.ArrayType, type.pos) as ArrayTypeNode;\r\n                            node.elementType = type;\r\n                            parseExpected(SyntaxKind.CloseBracketToken);\r\n                            type = finishNode(node);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        return type;\r\n                }\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function createJSDocPostfixType(kind: SyntaxKind, type: TypeNode) {\r\n            nextToken();\r\n            const postfix = createNode(kind, type.pos) as JSDocOptionalType | JSDocNonNullableType | JSDocNullableType;\r\n            postfix.type = type;\r\n            return finishNode(postfix);\r\n        }\r\n\r\n        function parseTypeOperator(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword) {\r\n            const node = <TypeOperatorNode>createNode(SyntaxKind.TypeOperator);\r\n            parseExpected(operator);\r\n            node.operator = operator;\r\n            node.type = parseTypeOperatorOrHigher();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseInferType(): InferTypeNode {\r\n            const node = <InferTypeNode>createNode(SyntaxKind.InferType);\r\n            parseExpected(SyntaxKind.InferKeyword);\r\n            const typeParameter = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter);\r\n            typeParameter.name = parseIdentifier();\r\n            node.typeParameter = finishNode(typeParameter);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeOperatorOrHigher(): TypeNode {\r\n            const operator = token();\r\n            switch (operator) {\r\n                case SyntaxKind.KeyOfKeyword:\r\n                case SyntaxKind.UniqueKeyword:\r\n                    return parseTypeOperator(operator);\r\n                case SyntaxKind.InferKeyword:\r\n                    return parseInferType();\r\n            }\r\n            return parsePostfixTypeOrHigher();\r\n        }\r\n\r\n        function parseUnionOrIntersectionType(kind: SyntaxKind.UnionType | SyntaxKind.IntersectionType, parseConstituentType: () => TypeNode, operator: SyntaxKind.BarToken | SyntaxKind.AmpersandToken): TypeNode {\r\n            parseOptional(operator);\r\n            let type = parseConstituentType();\r\n            if (token() === operator) {\r\n                const types = [type];\r\n                while (parseOptional(operator)) {\r\n                    types.push(parseConstituentType());\r\n                }\r\n                const node = <UnionOrIntersectionTypeNode>createNode(kind, type.pos);\r\n                node.types = createNodeArray(types, type.pos);\r\n                type = finishNode(node);\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function parseIntersectionTypeOrHigher(): TypeNode {\r\n            return parseUnionOrIntersectionType(SyntaxKind.IntersectionType, parseTypeOperatorOrHigher, SyntaxKind.AmpersandToken);\r\n        }\r\n\r\n        function parseUnionTypeOrHigher(): TypeNode {\r\n            return parseUnionOrIntersectionType(SyntaxKind.UnionType, parseIntersectionTypeOrHigher, SyntaxKind.BarToken);\r\n        }\r\n\r\n        function isStartOfFunctionType(): boolean {\r\n            if (token() === SyntaxKind.LessThanToken) {\r\n                return true;\r\n            }\r\n            return token() === SyntaxKind.OpenParenToken && lookAhead(isUnambiguouslyStartOfFunctionType);\r\n        }\r\n\r\n        function skipParameterStart(): boolean {\r\n            if (isModifierKind(token())) {\r\n                // Skip modifiers\r\n                parseModifiers();\r\n            }\r\n            if (isIdentifier() || token() === SyntaxKind.ThisKeyword) {\r\n                nextToken();\r\n                return true;\r\n            }\r\n            if (token() === SyntaxKind.OpenBracketToken || token() === SyntaxKind.OpenBraceToken) {\r\n                // Return true if we can parse an array or object binding pattern with no errors\r\n                const previousErrorCount = parseDiagnostics.length;\r\n                parseIdentifierOrPattern();\r\n                return previousErrorCount === parseDiagnostics.length;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isUnambiguouslyStartOfFunctionType() {\r\n            nextToken();\r\n            if (token() === SyntaxKind.CloseParenToken || token() === SyntaxKind.DotDotDotToken) {\r\n                // ( )\r\n                // ( ...\r\n                return true;\r\n            }\r\n            if (skipParameterStart()) {\r\n                // We successfully skipped modifiers (if any) and an identifier or binding pattern,\r\n                // now see if we have something that indicates a parameter declaration\r\n                if (token() === SyntaxKind.ColonToken || token() === SyntaxKind.CommaToken ||\r\n                    token() === SyntaxKind.QuestionToken || token() === SyntaxKind.EqualsToken) {\r\n                    // ( xxx :\r\n                    // ( xxx ,\r\n                    // ( xxx ?\r\n                    // ( xxx =\r\n                    return true;\r\n                }\r\n                if (token() === SyntaxKind.CloseParenToken) {\r\n                    nextToken();\r\n                    if (token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                        // ( xxx ) =>\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseTypeOrTypePredicate(): TypeNode {\r\n            const typePredicateVariable = isIdentifier() && tryParse(parseTypePredicatePrefix);\r\n            const type = parseType();\r\n            if (typePredicateVariable) {\r\n                const node = <TypePredicateNode>createNode(SyntaxKind.TypePredicate, typePredicateVariable.pos);\r\n                node.parameterName = typePredicateVariable;\r\n                node.type = type;\r\n                return finishNode(node);\r\n            }\r\n            else {\r\n                return type;\r\n            }\r\n        }\r\n\r\n        function parseTypePredicatePrefix() {\r\n            const id = parseIdentifier();\r\n            if (token() === SyntaxKind.IsKeyword && !scanner.hasPrecedingLineBreak()) {\r\n                nextToken();\r\n                return id;\r\n            }\r\n        }\r\n\r\n        function parseType(): TypeNode {\r\n            // The rules about 'yield' only apply to actual code/expression contexts.  They don't\r\n            // apply to 'type' contexts.  So we disable these parameters here before moving on.\r\n            return doOutsideOfContext(NodeFlags.TypeExcludesFlags, parseTypeWorker);\r\n        }\r\n\r\n        function parseTypeWorker(noConditionalTypes?: boolean): TypeNode {\r\n            if (isStartOfFunctionType()) {\r\n                return parseFunctionOrConstructorType(SyntaxKind.FunctionType);\r\n            }\r\n            if (token() === SyntaxKind.NewKeyword) {\r\n                return parseFunctionOrConstructorType(SyntaxKind.ConstructorType);\r\n            }\r\n            const type = parseUnionTypeOrHigher();\r\n            if (!noConditionalTypes && !scanner.hasPrecedingLineBreak() && parseOptional(SyntaxKind.ExtendsKeyword)) {\r\n                const node = <ConditionalTypeNode>createNode(SyntaxKind.ConditionalType, type.pos);\r\n                node.checkType = type;\r\n                // The type following 'extends' is not permitted to be another conditional type\r\n                node.extendsType = parseTypeWorker(/*noConditionalTypes*/ true);\r\n                parseExpected(SyntaxKind.QuestionToken);\r\n                node.trueType = parseTypeWorker();\r\n                parseExpected(SyntaxKind.ColonToken);\r\n                node.falseType = parseTypeWorker();\r\n                return finishNode(node);\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function parseTypeAnnotation(): TypeNode {\r\n            return parseOptional(SyntaxKind.ColonToken) ? parseType() : undefined;\r\n        }\r\n\r\n        // EXPRESSIONS\r\n        function isStartOfLeftHandSideExpression(): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                case SyntaxKind.TemplateHead:\r\n                case SyntaxKind.OpenParenToken:\r\n                case SyntaxKind.OpenBracketToken:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.FunctionKeyword:\r\n                case SyntaxKind.ClassKeyword:\r\n                case SyntaxKind.NewKeyword:\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.SlashEqualsToken:\r\n                case SyntaxKind.Identifier:\r\n                    return true;\r\n                case SyntaxKind.ImportKeyword:\r\n                    return lookAhead(nextTokenIsOpenParenOrLessThanOrDot);\r\n                default:\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function isStartOfExpression(): boolean {\r\n            if (isStartOfLeftHandSideExpression()) {\r\n                return true;\r\n            }\r\n\r\n            switch (token()) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DeleteKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.PlusPlusToken:\r\n                case SyntaxKind.MinusMinusToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.AwaitKeyword:\r\n                case SyntaxKind.YieldKeyword:\r\n                    // Yield/await always starts an expression.  Either it is an identifier (in which case\r\n                    // it is definitely an expression).  Or it's a keyword (either because we're in\r\n                    // a generator or async function, or in strict mode (or both)) and it started a yield or await expression.\r\n                    return true;\r\n                default:\r\n                    // Error tolerance.  If we see the start of some binary operator, we consider\r\n                    // that the start of an expression.  That way we'll parse out a missing identifier,\r\n                    // give a good message about an identifier being missing, and then consume the\r\n                    // rest of the binary expression.\r\n                    if (isBinaryOperator()) {\r\n                        return true;\r\n                    }\r\n\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function isStartOfExpressionStatement(): boolean {\r\n            // As per the grammar, none of '{' or 'function' or 'class' can start an expression statement.\r\n            return token() !== SyntaxKind.OpenBraceToken &&\r\n                token() !== SyntaxKind.FunctionKeyword &&\r\n                token() !== SyntaxKind.ClassKeyword &&\r\n                token() !== SyntaxKind.AtToken &&\r\n                isStartOfExpression();\r\n        }\r\n\r\n        function parseExpression(): Expression {\r\n            // Expression[in]:\r\n            //      AssignmentExpression[in]\r\n            //      Expression[in] , AssignmentExpression[in]\r\n\r\n            // clear the decorator context when parsing Expression, as it should be unambiguous when parsing a decorator\r\n            const saveDecoratorContext = inDecoratorContext();\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ false);\r\n            }\r\n\r\n            let expr = parseAssignmentExpressionOrHigher();\r\n            let operatorToken: BinaryOperatorToken;\r\n            while ((operatorToken = parseOptionalToken(SyntaxKind.CommaToken))) {\r\n                expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher());\r\n            }\r\n\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ true);\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        function parseInitializer(): Expression | undefined {\r\n            return parseOptional(SyntaxKind.EqualsToken) ? parseAssignmentExpressionOrHigher() : undefined;\r\n        }\r\n\r\n        function parseAssignmentExpressionOrHigher(): Expression {\r\n            //  AssignmentExpression[in,yield]:\r\n            //      1) ConditionalExpression[?in,?yield]\r\n            //      2) LeftHandSideExpression = AssignmentExpression[?in,?yield]\r\n            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[?in,?yield]\r\n            //      4) ArrowFunctionExpression[?in,?yield]\r\n            //      5) AsyncArrowFunctionExpression[in,yield,await]\r\n            //      6) [+Yield] YieldExpression[?In]\r\n            //\r\n            // Note: for ease of implementation we treat productions '2' and '3' as the same thing.\r\n            // (i.e. they're both BinaryExpressions with an assignment operator in it).\r\n\r\n            // First, do the simple check if we have a YieldExpression (production '6').\r\n            if (isYieldExpression()) {\r\n                return parseYieldExpression();\r\n            }\r\n\r\n            // Then, check if we have an arrow function (production '4' and '5') that starts with a parenthesized\r\n            // parameter list or is an async arrow function.\r\n            // AsyncArrowFunctionExpression:\r\n            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            // Production (1) of AsyncArrowFunctionExpression is parsed in \"tryParseAsyncSimpleArrowFunctionExpression\".\r\n            // And production (2) is parsed in \"tryParseParenthesizedArrowFunctionExpression\".\r\n            //\r\n            // If we do successfully parse arrow-function, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is\r\n            // not a LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done\r\n            // with AssignmentExpression if we see one.\r\n            const arrowExpression = tryParseParenthesizedArrowFunctionExpression() || tryParseAsyncSimpleArrowFunctionExpression();\r\n            if (arrowExpression) {\r\n                return arrowExpression;\r\n            }\r\n\r\n            // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can\r\n            // start with a LogicalOrExpression, while the assignment productions can only start with\r\n            // LeftHandSideExpressions.\r\n            //\r\n            // So, first, we try to just parse out a BinaryExpression.  If we get something that is a\r\n            // LeftHandSide or higher, then we can try to parse out the assignment expression part.\r\n            // Otherwise, we try to parse out the conditional expression bit.  We want to allow any\r\n            // binary expression here, so we pass in the 'lowest' precedence here so that it matches\r\n            // and consumes anything.\r\n            const expr = parseBinaryExpressionOrHigher(/*precedence*/ 0);\r\n\r\n            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized\r\n            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single\r\n            // identifier and the current token is an arrow.\r\n            if (expr.kind === SyntaxKind.Identifier && token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                return parseSimpleArrowFunctionExpression(<Identifier>expr);\r\n            }\r\n\r\n            // Now see if we might be in cases '2' or '3'.\r\n            // If the expression was a LHS expression, and we have an assignment operator, then\r\n            // we're in '2' or '3'. Consume the assignment and return.\r\n            //\r\n            // Note: we call reScanGreaterToken so that we get an appropriately merged token\r\n            // for cases like `> > =` becoming `>>=`\r\n            if (isLeftHandSideExpression(expr) && isAssignmentOperator(reScanGreaterToken())) {\r\n                return makeBinaryExpression(expr, parseTokenNode(), parseAssignmentExpressionOrHigher());\r\n            }\r\n\r\n            // It wasn't an assignment or a lambda.  This is a conditional expression:\r\n            return parseConditionalExpressionRest(expr);\r\n        }\r\n\r\n        function isYieldExpression(): boolean {\r\n            if (token() === SyntaxKind.YieldKeyword) {\r\n                // If we have a 'yield' keyword, and this is a context where yield expressions are\r\n                // allowed, then definitely parse out a yield expression.\r\n                if (inYieldContext()) {\r\n                    return true;\r\n                }\r\n\r\n                // We're in a context where 'yield expr' is not allowed.  However, if we can\r\n                // definitely tell that the user was trying to parse a 'yield expr' and not\r\n                // just a normal expr that start with a 'yield' identifier, then parse out\r\n                // a 'yield expr'.  We can then report an error later that they are only\r\n                // allowed in generator expressions.\r\n                //\r\n                // for example, if we see 'yield(foo)', then we'll have to treat that as an\r\n                // invocation expression of something called 'yield'.  However, if we have\r\n                // 'yield foo' then that is not legal as a normal expression, so we can\r\n                // definitely recognize this as a yield expression.\r\n                //\r\n                // for now we just check if the next token is an identifier.  More heuristics\r\n                // can be added here later as necessary.  We just need to make sure that we\r\n                // don't accidentally consume something legal.\r\n                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function nextTokenIsIdentifierOnSameLine() {\r\n            nextToken();\r\n            return !scanner.hasPrecedingLineBreak() && isIdentifier();\r\n        }\r\n\r\n        function parseYieldExpression(): YieldExpression {\r\n            const node = <YieldExpression>createNode(SyntaxKind.YieldExpression);\r\n\r\n            // YieldExpression[In] :\r\n            //      yield\r\n            //      yield [no LineTerminator here] [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]\r\n            //      yield [no LineTerminator here] * [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]\r\n            nextToken();\r\n\r\n            if (!scanner.hasPrecedingLineBreak() &&\r\n                (token() === SyntaxKind.AsteriskToken || isStartOfExpression())) {\r\n                node.asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n                node.expression = parseAssignmentExpressionOrHigher();\r\n                return finishNode(node);\r\n            }\r\n            else {\r\n                // if the next token is not on the same line as yield.  or we don't have an '*' or\r\n                // the start of an expression, then this is just a simple \"yield\" expression.\r\n                return finishNode(node);\r\n            }\r\n        }\r\n\r\n        function parseSimpleArrowFunctionExpression(identifier: Identifier, asyncModifier?: NodeArray<Modifier>): ArrowFunction {\r\n            Debug.assert(token() === SyntaxKind.EqualsGreaterThanToken, \"parseSimpleArrowFunctionExpression should only have been called if we had a =>\");\r\n\r\n            let node: ArrowFunction;\r\n            if (asyncModifier) {\r\n                node = <ArrowFunction>createNode(SyntaxKind.ArrowFunction, asyncModifier.pos);\r\n                node.modifiers = asyncModifier;\r\n            }\r\n            else {\r\n                node = <ArrowFunction>createNode(SyntaxKind.ArrowFunction, identifier.pos);\r\n            }\r\n\r\n            const parameter = <ParameterDeclaration>createNode(SyntaxKind.Parameter, identifier.pos);\r\n            parameter.name = identifier;\r\n            finishNode(parameter);\r\n\r\n            node.parameters = createNodeArray<ParameterDeclaration>([parameter], parameter.pos, parameter.end);\r\n\r\n            node.equalsGreaterThanToken = parseExpectedToken(SyntaxKind.EqualsGreaterThanToken);\r\n            node.body = parseArrowFunctionExpressionBody(/*isAsync*/ !!asyncModifier);\r\n\r\n            return addJSDocComment(finishNode(node));\r\n        }\r\n\r\n        function tryParseParenthesizedArrowFunctionExpression(): Expression | undefined {\r\n            const triState = isParenthesizedArrowFunctionExpression();\r\n            if (triState === Tristate.False) {\r\n                // It's definitely not a parenthesized arrow function expression.\r\n                return undefined;\r\n            }\r\n\r\n            // If we definitely have an arrow function, then we can just parse one, not requiring a\r\n            // following => or { token. Otherwise, we *might* have an arrow function.  Try to parse\r\n            // it out, but don't allow any ambiguity, and return 'undefined' if this could be an\r\n            // expression instead.\r\n            const arrowFunction = triState === Tristate.True\r\n                ? parseParenthesizedArrowFunctionExpressionHead(/*allowAmbiguity*/ true)\r\n                : tryParse(parsePossibleParenthesizedArrowFunctionExpressionHead);\r\n\r\n            if (!arrowFunction) {\r\n                // Didn't appear to actually be a parenthesized arrow function.  Just bail out.\r\n                return undefined;\r\n            }\r\n\r\n            const isAsync = hasModifier(arrowFunction, ModifierFlags.Async);\r\n\r\n            // If we have an arrow, then try to parse the body. Even if not, try to parse if we\r\n            // have an opening brace, just in case we're in an error state.\r\n            const lastToken = token();\r\n            arrowFunction.equalsGreaterThanToken = parseExpectedToken(SyntaxKind.EqualsGreaterThanToken);\r\n            arrowFunction.body = (lastToken === SyntaxKind.EqualsGreaterThanToken || lastToken === SyntaxKind.OpenBraceToken)\r\n                ? parseArrowFunctionExpressionBody(isAsync)\r\n                : parseIdentifier();\r\n\r\n            return finishNode(arrowFunction);\r\n        }\r\n\r\n        //  True        -> We definitely expect a parenthesized arrow function here.\r\n        //  False       -> There *cannot* be a parenthesized arrow function here.\r\n        //  Unknown     -> There *might* be a parenthesized arrow function here.\r\n        //                 Speculatively look ahead to be sure, and rollback if not.\r\n        function isParenthesizedArrowFunctionExpression(): Tristate {\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken || token() === SyntaxKind.AsyncKeyword) {\r\n                return lookAhead(isParenthesizedArrowFunctionExpressionWorker);\r\n            }\r\n\r\n            if (token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                // ERROR RECOVERY TWEAK:\r\n                // If we see a standalone => try to parse it as an arrow function expression as that's\r\n                // likely what the user intended to write.\r\n                return Tristate.True;\r\n            }\r\n            // Definitely not a parenthesized arrow function.\r\n            return Tristate.False;\r\n        }\r\n\r\n        function isParenthesizedArrowFunctionExpressionWorker() {\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                nextToken();\r\n                if (scanner.hasPrecedingLineBreak()) {\r\n                    return Tristate.False;\r\n                }\r\n                if (token() !== SyntaxKind.OpenParenToken && token() !== SyntaxKind.LessThanToken) {\r\n                    return Tristate.False;\r\n                }\r\n            }\r\n\r\n            const first = token();\r\n            const second = nextToken();\r\n\r\n            if (first === SyntaxKind.OpenParenToken) {\r\n                if (second === SyntaxKind.CloseParenToken) {\r\n                    // Simple cases: \"() =>\", \"(): \", and \"() {\".\r\n                    // This is an arrow function with no parameters.\r\n                    // The last one is not actually an arrow function,\r\n                    // but this is probably what the user intended.\r\n                    const third = nextToken();\r\n                    switch (third) {\r\n                        case SyntaxKind.EqualsGreaterThanToken:\r\n                        case SyntaxKind.ColonToken:\r\n                        case SyntaxKind.OpenBraceToken:\r\n                            return Tristate.True;\r\n                        default:\r\n                            return Tristate.False;\r\n                    }\r\n                }\r\n\r\n                // If encounter \"([\" or \"({\", this could be the start of a binding pattern.\r\n                // Examples:\r\n                //      ([ x ]) => { }\r\n                //      ({ x }) => { }\r\n                //      ([ x ])\r\n                //      ({ x })\r\n                if (second === SyntaxKind.OpenBracketToken || second === SyntaxKind.OpenBraceToken) {\r\n                    return Tristate.Unknown;\r\n                }\r\n\r\n                // Simple case: \"(...\"\r\n                // This is an arrow function with a rest parameter.\r\n                if (second === SyntaxKind.DotDotDotToken) {\r\n                    return Tristate.True;\r\n                }\r\n\r\n                // Check for \"(xxx yyy\", where xxx is a modifier and yyy is an identifier. This\r\n                // isn't actually allowed, but we want to treat it as a lambda so we can provide\r\n                // a good error message.\r\n                if (isModifierKind(second) && second !== SyntaxKind.AsyncKeyword && lookAhead(nextTokenIsIdentifier)) {\r\n                    return Tristate.True;\r\n                }\r\n\r\n                // If we had \"(\" followed by something that's not an identifier,\r\n                // then this definitely doesn't look like a lambda.\r\n                if (!isIdentifier()) {\r\n                    return Tristate.False;\r\n                }\r\n\r\n                switch (nextToken()) {\r\n                    case SyntaxKind.ColonToken:\r\n                        // If we have something like \"(a:\", then we must have a\r\n                        // type-annotated parameter in an arrow function expression.\r\n                        return Tristate.True;\r\n                    case SyntaxKind.QuestionToken:\r\n                        nextToken();\r\n                        // If we have \"(a?:\" or \"(a?,\" or \"(a?=\" or \"(a?)\" then it is definitely a lambda.\r\n                        if (token() === SyntaxKind.ColonToken || token() === SyntaxKind.CommaToken || token() === SyntaxKind.EqualsToken || token() === SyntaxKind.CloseParenToken) {\r\n                            return Tristate.True;\r\n                        }\r\n                        // Otherwise it is definitely not a lambda.\r\n                        return Tristate.False;\r\n                    case SyntaxKind.CommaToken:\r\n                    case SyntaxKind.EqualsToken:\r\n                    case SyntaxKind.CloseParenToken:\r\n                        // If we have \"(a,\" or \"(a=\" or \"(a)\" this *could* be an arrow function\r\n                        return Tristate.Unknown;\r\n                }\r\n                // It is definitely not an arrow function\r\n                return Tristate.False;\r\n            }\r\n            else {\r\n                Debug.assert(first === SyntaxKind.LessThanToken);\r\n\r\n                // If we have \"<\" not followed by an identifier,\r\n                // then this definitely is not an arrow function.\r\n                if (!isIdentifier()) {\r\n                    return Tristate.False;\r\n                }\r\n\r\n                // JSX overrides\r\n                if (sourceFile.languageVariant === LanguageVariant.JSX) {\r\n                    const isArrowFunctionInJsx = lookAhead(() => {\r\n                        const third = nextToken();\r\n                        if (third === SyntaxKind.ExtendsKeyword) {\r\n                            const fourth = nextToken();\r\n                            switch (fourth) {\r\n                                case SyntaxKind.EqualsToken:\r\n                                case SyntaxKind.GreaterThanToken:\r\n                                    return false;\r\n                                default:\r\n                                    return true;\r\n                            }\r\n                        }\r\n                        else if (third === SyntaxKind.CommaToken) {\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    });\r\n\r\n                    if (isArrowFunctionInJsx) {\r\n                        return Tristate.True;\r\n                    }\r\n\r\n                    return Tristate.False;\r\n                }\r\n\r\n                // This *could* be a parenthesized arrow function.\r\n                return Tristate.Unknown;\r\n            }\r\n        }\r\n\r\n        function parsePossibleParenthesizedArrowFunctionExpressionHead(): ArrowFunction {\r\n            return parseParenthesizedArrowFunctionExpressionHead(/*allowAmbiguity*/ false);\r\n        }\r\n\r\n        function tryParseAsyncSimpleArrowFunctionExpression(): ArrowFunction | undefined {\r\n            // We do a check here so that we won't be doing unnecessarily call to \"lookAhead\"\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                if (lookAhead(isUnParenthesizedAsyncArrowFunctionWorker) === Tristate.True) {\r\n                    const asyncModifier = parseModifiersForArrowFunction();\r\n                    const expr = parseBinaryExpressionOrHigher(/*precedence*/ 0);\r\n                    return parseSimpleArrowFunctionExpression(<Identifier>expr, asyncModifier);\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function isUnParenthesizedAsyncArrowFunctionWorker(): Tristate {\r\n            // AsyncArrowFunctionExpression:\r\n            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                nextToken();\r\n                // If the \"async\" is followed by \"=>\" token then it is not a begining of an async arrow-function\r\n                // but instead a simple arrow-function which will be parsed inside \"parseAssignmentExpressionOrHigher\"\r\n                if (scanner.hasPrecedingLineBreak() || token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                    return Tristate.False;\r\n                }\r\n                // Check for un-parenthesized AsyncArrowFunction\r\n                const expr = parseBinaryExpressionOrHigher(/*precedence*/ 0);\r\n                if (!scanner.hasPrecedingLineBreak() && expr.kind === SyntaxKind.Identifier && token() === SyntaxKind.EqualsGreaterThanToken) {\r\n                    return Tristate.True;\r\n                }\r\n            }\r\n\r\n            return Tristate.False;\r\n        }\r\n\r\n        function parseParenthesizedArrowFunctionExpressionHead(allowAmbiguity: boolean): ArrowFunction {\r\n            const node = <ArrowFunction>createNodeWithJSDoc(SyntaxKind.ArrowFunction);\r\n            node.modifiers = parseModifiersForArrowFunction();\r\n            const isAsync = hasModifier(node, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            // Arrow functions are never generators.\r\n            //\r\n            // If we're speculatively parsing a signature for a parenthesized arrow function, then\r\n            // we have to have a complete parameter list.  Otherwise we might see something like\r\n            // a => (b => c)\r\n            // And think that \"(b =>\" was actually a parenthesized arrow function with a missing\r\n            // close paren.\r\n            fillSignature(SyntaxKind.ColonToken, isAsync | (allowAmbiguity ? SignatureFlags.None : SignatureFlags.RequireCompleteParameterList), node);\r\n\r\n            // If we couldn't get parameters, we definitely could not parse out an arrow function.\r\n            if (!node.parameters) {\r\n                return undefined;\r\n            }\r\n\r\n            // Parsing a signature isn't enough.\r\n            // Parenthesized arrow signatures often look like other valid expressions.\r\n            // For instance:\r\n            //  - \"(x = 10)\" is an assignment expression parsed as a signature with a default parameter value.\r\n            //  - \"(x,y)\" is a comma expression parsed as a signature with two parameters.\r\n            //  - \"a ? (b): c\" will have \"(b):\" parsed as a signature with a return type annotation.\r\n            //\r\n            // So we need just a bit of lookahead to ensure that it can only be a signature.\r\n            if (!allowAmbiguity && token() !== SyntaxKind.EqualsGreaterThanToken && token() !== SyntaxKind.OpenBraceToken) {\r\n                // Returning undefined here will cause our caller to rewind to where we started from.\r\n                return undefined;\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        function parseArrowFunctionExpressionBody(isAsync: boolean): Block | Expression {\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                return parseFunctionBlock(isAsync ? SignatureFlags.Await : SignatureFlags.None);\r\n            }\r\n\r\n            if (token() !== SyntaxKind.SemicolonToken &&\r\n                token() !== SyntaxKind.FunctionKeyword &&\r\n                token() !== SyntaxKind.ClassKeyword &&\r\n                isStartOfStatement() &&\r\n                !isStartOfExpressionStatement()) {\r\n                // Check if we got a plain statement (i.e. no expression-statements, no function/class expressions/declarations)\r\n                //\r\n                // Here we try to recover from a potential error situation in the case where the\r\n                // user meant to supply a block. For example, if the user wrote:\r\n                //\r\n                //  a =>\r\n                //      let v = 0;\r\n                //  }\r\n                //\r\n                // they may be missing an open brace.  Check to see if that's the case so we can\r\n                // try to recover better.  If we don't do this, then the next close curly we see may end\r\n                // up preemptively closing the containing construct.\r\n                //\r\n                // Note: even when 'IgnoreMissingOpenBrace' is passed, parseBody will still error.\r\n                return parseFunctionBlock(SignatureFlags.IgnoreMissingOpenBrace | (isAsync ? SignatureFlags.Await : SignatureFlags.None));\r\n            }\r\n\r\n            return isAsync\r\n                ? doInAwaitContext(parseAssignmentExpressionOrHigher)\r\n                : doOutsideOfAwaitContext(parseAssignmentExpressionOrHigher);\r\n        }\r\n\r\n        function parseConditionalExpressionRest(leftOperand: Expression): Expression {\r\n            // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.\r\n            const questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            if (!questionToken) {\r\n                return leftOperand;\r\n            }\r\n\r\n            // Note: we explicitly 'allowIn' in the whenTrue part of the condition expression, and\r\n            // we do not that for the 'whenFalse' part.\r\n            const node = <ConditionalExpression>createNode(SyntaxKind.ConditionalExpression, leftOperand.pos);\r\n            node.condition = leftOperand;\r\n            node.questionToken = questionToken;\r\n            node.whenTrue = doOutsideOfContext(disallowInAndDecoratorContext, parseAssignmentExpressionOrHigher);\r\n            node.colonToken = parseExpectedToken(SyntaxKind.ColonToken);\r\n            node.whenFalse = nodeIsPresent(node.colonToken)\r\n                ? parseAssignmentExpressionOrHigher()\r\n                : createMissingNode(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ false, Diagnostics._0_expected, tokenToString(SyntaxKind.ColonToken));\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseBinaryExpressionOrHigher(precedence: number): Expression {\r\n            const leftOperand = parseUnaryExpressionOrHigher();\r\n            return parseBinaryExpressionRest(precedence, leftOperand);\r\n        }\r\n\r\n        function isInOrOfKeyword(t: SyntaxKind) {\r\n            return t === SyntaxKind.InKeyword || t === SyntaxKind.OfKeyword;\r\n        }\r\n\r\n        function parseBinaryExpressionRest(precedence: number, leftOperand: Expression): Expression {\r\n            while (true) {\r\n                // We either have a binary operator here, or we're finished.  We call\r\n                // reScanGreaterToken so that we merge token sequences like > and = into >=\r\n\r\n                reScanGreaterToken();\r\n                const newPrecedence = getBinaryOperatorPrecedence(token());\r\n\r\n                // Check the precedence to see if we should \"take\" this operator\r\n                // - For left associative operator (all operator but **), consume the operator,\r\n                //   recursively call the function below, and parse binaryExpression as a rightOperand\r\n                //   of the caller if the new precedence of the operator is greater then or equal to the current precedence.\r\n                //   For example:\r\n                //      a - b - c;\r\n                //            ^token; leftOperand = b. Return b to the caller as a rightOperand\r\n                //      a * b - c\r\n                //            ^token; leftOperand = b. Return b to the caller as a rightOperand\r\n                //      a - b * c;\r\n                //            ^token; leftOperand = b. Return b * c to the caller as a rightOperand\r\n                // - For right associative operator (**), consume the operator, recursively call the function\r\n                //   and parse binaryExpression as a rightOperand of the caller if the new precedence of\r\n                //   the operator is strictly grater than the current precedence\r\n                //   For example:\r\n                //      a ** b ** c;\r\n                //             ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand\r\n                //      a - b ** c;\r\n                //            ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand\r\n                //      a ** b - c\r\n                //             ^token; leftOperand = b. Return b to the caller as a rightOperand\r\n                const consumeCurrentOperator = token() === SyntaxKind.AsteriskAsteriskToken ?\r\n                    newPrecedence >= precedence :\r\n                    newPrecedence > precedence;\r\n\r\n                if (!consumeCurrentOperator) {\r\n                    break;\r\n                }\r\n\r\n                if (token() === SyntaxKind.InKeyword && inDisallowInContext()) {\r\n                    break;\r\n                }\r\n\r\n                if (token() === SyntaxKind.AsKeyword) {\r\n                    // Make sure we *do* perform ASI for constructs like this:\r\n                    //    var x = foo\r\n                    //    as (Bar)\r\n                    // This should be parsed as an initialized variable, followed\r\n                    // by a function call to 'as' with the argument 'Bar'\r\n                    if (scanner.hasPrecedingLineBreak()) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        nextToken();\r\n                        leftOperand = makeAsExpression(leftOperand, parseType());\r\n                    }\r\n                }\r\n                else {\r\n                    leftOperand = makeBinaryExpression(leftOperand, parseTokenNode(), parseBinaryExpressionOrHigher(newPrecedence));\r\n                }\r\n            }\r\n\r\n            return leftOperand;\r\n        }\r\n\r\n        function isBinaryOperator() {\r\n            if (inDisallowInContext() && token() === SyntaxKind.InKeyword) {\r\n                return false;\r\n            }\r\n\r\n            return getBinaryOperatorPrecedence(token()) > 0;\r\n        }\r\n\r\n        function makeBinaryExpression(left: Expression, operatorToken: BinaryOperatorToken, right: Expression): BinaryExpression {\r\n            const node = <BinaryExpression>createNode(SyntaxKind.BinaryExpression, left.pos);\r\n            node.left = left;\r\n            node.operatorToken = operatorToken;\r\n            node.right = right;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function makeAsExpression(left: Expression, right: TypeNode): AsExpression {\r\n            const node = <AsExpression>createNode(SyntaxKind.AsExpression, left.pos);\r\n            node.expression = left;\r\n            node.type = right;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parsePrefixUnaryExpression() {\r\n            const node = <PrefixUnaryExpression>createNode(SyntaxKind.PrefixUnaryExpression);\r\n            node.operator = <PrefixUnaryOperator>token();\r\n            nextToken();\r\n            node.operand = parseSimpleUnaryExpression();\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDeleteExpression() {\r\n            const node = <DeleteExpression>createNode(SyntaxKind.DeleteExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeOfExpression() {\r\n            const node = <TypeOfExpression>createNode(SyntaxKind.TypeOfExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseVoidExpression() {\r\n            const node = <VoidExpression>createNode(SyntaxKind.VoidExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isAwaitExpression(): boolean {\r\n            if (token() === SyntaxKind.AwaitKeyword) {\r\n                if (inAwaitContext()) {\r\n                    return true;\r\n                }\r\n\r\n                // here we are using similar heuristics as 'isYieldExpression'\r\n                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function parseAwaitExpression() {\r\n            const node = <AwaitExpression>createNode(SyntaxKind.AwaitExpression);\r\n            nextToken();\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        /**\r\n         * Parse ES7 exponential expression and await expression\r\n         *\r\n         * ES7 ExponentiationExpression:\r\n         *      1) UnaryExpression[?Yield]\r\n         *      2) UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]\r\n         *\r\n         */\r\n        function parseUnaryExpressionOrHigher(): UnaryExpression | BinaryExpression {\r\n            /**\r\n             * ES7 UpdateExpression:\r\n             *      1) LeftHandSideExpression[?Yield]\r\n             *      2) LeftHandSideExpression[?Yield][no LineTerminator here]++\r\n             *      3) LeftHandSideExpression[?Yield][no LineTerminator here]--\r\n             *      4) ++UnaryExpression[?Yield]\r\n             *      5) --UnaryExpression[?Yield]\r\n             */\r\n            if (isUpdateExpression()) {\r\n                const updateExpression = parseUpdateExpression();\r\n                return token() === SyntaxKind.AsteriskAsteriskToken ?\r\n                    <BinaryExpression>parseBinaryExpressionRest(getBinaryOperatorPrecedence(token()), updateExpression) :\r\n                    updateExpression;\r\n            }\r\n\r\n            /**\r\n             * ES7 UnaryExpression:\r\n             *      1) UpdateExpression[?yield]\r\n             *      2) delete UpdateExpression[?yield]\r\n             *      3) void UpdateExpression[?yield]\r\n             *      4) typeof UpdateExpression[?yield]\r\n             *      5) + UpdateExpression[?yield]\r\n             *      6) - UpdateExpression[?yield]\r\n             *      7) ~ UpdateExpression[?yield]\r\n             *      8) ! UpdateExpression[?yield]\r\n             */\r\n            const unaryOperator = token();\r\n            const simpleUnaryExpression = parseSimpleUnaryExpression();\r\n            if (token() === SyntaxKind.AsteriskAsteriskToken) {\r\n                const pos = skipTrivia(sourceText, simpleUnaryExpression.pos);\r\n                const { end } = simpleUnaryExpression;\r\n                if (simpleUnaryExpression.kind === SyntaxKind.TypeAssertionExpression) {\r\n                    parseErrorAt(pos, end, Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses);\r\n                }\r\n                else {\r\n                    parseErrorAt(pos, end, Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, tokenToString(unaryOperator));\r\n                }\r\n            }\r\n            return simpleUnaryExpression;\r\n        }\r\n\r\n        /**\r\n         * Parse ES7 simple-unary expression or higher:\r\n         *\r\n         * ES7 UnaryExpression:\r\n         *      1) UpdateExpression[?yield]\r\n         *      2) delete UnaryExpression[?yield]\r\n         *      3) void UnaryExpression[?yield]\r\n         *      4) typeof UnaryExpression[?yield]\r\n         *      5) + UnaryExpression[?yield]\r\n         *      6) - UnaryExpression[?yield]\r\n         *      7) ~ UnaryExpression[?yield]\r\n         *      8) ! UnaryExpression[?yield]\r\n         *      9) [+Await] await UnaryExpression[?yield]\r\n         */\r\n        function parseSimpleUnaryExpression(): UnaryExpression {\r\n            switch (token()) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                    return parsePrefixUnaryExpression();\r\n                case SyntaxKind.DeleteKeyword:\r\n                    return parseDeleteExpression();\r\n                case SyntaxKind.TypeOfKeyword:\r\n                    return parseTypeOfExpression();\r\n                case SyntaxKind.VoidKeyword:\r\n                    return parseVoidExpression();\r\n                case SyntaxKind.LessThanToken:\r\n                    // This is modified UnaryExpression grammar in TypeScript\r\n                    //  UnaryExpression (modified):\r\n                    //      < type > UnaryExpression\r\n                    return parseTypeAssertion();\r\n                case SyntaxKind.AwaitKeyword:\r\n                    if (isAwaitExpression()) {\r\n                        return parseAwaitExpression();\r\n                    }\r\n                    // falls through\r\n                default:\r\n                    return parseUpdateExpression();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if the current token can possibly be an ES7 increment expression.\r\n         *\r\n         * ES7 UpdateExpression:\r\n         *      LeftHandSideExpression[?Yield]\r\n         *      LeftHandSideExpression[?Yield][no LineTerminator here]++\r\n         *      LeftHandSideExpression[?Yield][no LineTerminator here]--\r\n         *      ++LeftHandSideExpression[?Yield]\r\n         *      --LeftHandSideExpression[?Yield]\r\n         */\r\n        function isUpdateExpression(): boolean {\r\n            // This function is called inside parseUnaryExpression to decide\r\n            // whether to call parseSimpleUnaryExpression or call parseUpdateExpression directly\r\n            switch (token()) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DeleteKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.AwaitKeyword:\r\n                    return false;\r\n                case SyntaxKind.LessThanToken:\r\n                    // If we are not in JSX context, we are parsing TypeAssertion which is an UnaryExpression\r\n                    if (sourceFile.languageVariant !== LanguageVariant.JSX) {\r\n                        return false;\r\n                    }\r\n                    // We are in JSX context and the token is part of JSXElement.\r\n                    // falls through\r\n                default:\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Parse ES7 UpdateExpression. UpdateExpression is used instead of ES6's PostFixExpression.\r\n         *\r\n         * ES7 UpdateExpression[yield]:\r\n         *      1) LeftHandSideExpression[?yield]\r\n         *      2) LeftHandSideExpression[?yield] [[no LineTerminator here]]++\r\n         *      3) LeftHandSideExpression[?yield] [[no LineTerminator here]]--\r\n         *      4) ++LeftHandSideExpression[?yield]\r\n         *      5) --LeftHandSideExpression[?yield]\r\n         * In TypeScript (2), (3) are parsed as PostfixUnaryExpression. (4), (5) are parsed as PrefixUnaryExpression\r\n         */\r\n        function parseUpdateExpression(): UpdateExpression {\r\n            if (token() === SyntaxKind.PlusPlusToken || token() === SyntaxKind.MinusMinusToken) {\r\n                const node = <PrefixUnaryExpression>createNode(SyntaxKind.PrefixUnaryExpression);\r\n                node.operator = <PrefixUnaryOperator>token();\r\n                nextToken();\r\n                node.operand = parseLeftHandSideExpressionOrHigher();\r\n                return finishNode(node);\r\n            }\r\n            else if (sourceFile.languageVariant === LanguageVariant.JSX && token() === SyntaxKind.LessThanToken && lookAhead(nextTokenIsIdentifierOrKeywordOrGreaterThan)) {\r\n                // JSXElement is part of primaryExpression\r\n                return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ true);\r\n            }\r\n\r\n            const expression = parseLeftHandSideExpressionOrHigher();\r\n\r\n            Debug.assert(isLeftHandSideExpression(expression));\r\n            if ((token() === SyntaxKind.PlusPlusToken || token() === SyntaxKind.MinusMinusToken) && !scanner.hasPrecedingLineBreak()) {\r\n                const node = <PostfixUnaryExpression>createNode(SyntaxKind.PostfixUnaryExpression, expression.pos);\r\n                node.operand = expression;\r\n                node.operator = <PostfixUnaryOperator>token();\r\n                nextToken();\r\n                return finishNode(node);\r\n            }\r\n\r\n            return expression;\r\n        }\r\n\r\n        function parseLeftHandSideExpressionOrHigher(): LeftHandSideExpression {\r\n            // Original Ecma:\r\n            // LeftHandSideExpression: See 11.2\r\n            //      NewExpression\r\n            //      CallExpression\r\n            //\r\n            // Our simplification:\r\n            //\r\n            // LeftHandSideExpression: See 11.2\r\n            //      MemberExpression\r\n            //      CallExpression\r\n            //\r\n            // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with\r\n            // MemberExpression to make our lives easier.\r\n            //\r\n            // to best understand the below code, it's important to see how CallExpression expands\r\n            // out into its own productions:\r\n            //\r\n            // CallExpression:\r\n            //      MemberExpression Arguments\r\n            //      CallExpression Arguments\r\n            //      CallExpression[Expression]\r\n            //      CallExpression.IdentifierName\r\n            //      import (AssignmentExpression)\r\n            //      super Arguments\r\n            //      super.IdentifierName\r\n            //\r\n            // Because of the recursion in these calls, we need to bottom out first. There are three\r\n            // bottom out states we can run into: 1) We see 'super' which must start either of\r\n            // the last two CallExpression productions. 2) We see 'import' which must start import call.\r\n            // 3)we have a MemberExpression which either completes the LeftHandSideExpression,\r\n            // or starts the beginning of the first four CallExpression productions.\r\n            let expression: MemberExpression;\r\n            if (token() === SyntaxKind.ImportKeyword) {\r\n                if (lookAhead(nextTokenIsOpenParenOrLessThan)) {\r\n                    // We don't want to eagerly consume all import keyword as import call expression so we look ahead to find \"(\"\r\n                    // For example:\r\n                    //      var foo3 = require(\"subfolder\r\n                    //      import * as foo1 from \"module-from-node\r\n                    // We want this import to be a statement rather than import call expression\r\n                    sourceFile.flags |= NodeFlags.PossiblyContainsDynamicImport;\r\n                    expression = parseTokenNode<PrimaryExpression>();\r\n                }\r\n                else if (lookAhead(nextTokenIsDot)) {\r\n                    // This is an 'import.*' metaproperty (i.e. 'import.meta')\r\n                    const fullStart = scanner.getStartPos();\r\n                    nextToken(); // advance past the 'import'\r\n                    nextToken(); // advance past the dot\r\n                    const node = createNode(SyntaxKind.MetaProperty, fullStart) as MetaProperty;\r\n                    node.keywordToken = SyntaxKind.ImportKeyword;\r\n                    node.name = parseIdentifierName();\r\n                    expression = finishNode(node);\r\n\r\n                    sourceFile.flags |= NodeFlags.PossiblyContainsImportMeta;\r\n                }\r\n                else {\r\n                    expression = parseMemberExpressionOrHigher();\r\n                }\r\n            }\r\n            else {\r\n                expression = token() === SyntaxKind.SuperKeyword ? parseSuperExpression() : parseMemberExpressionOrHigher();\r\n            }\r\n\r\n            // Now, we *may* be complete.  However, we might have consumed the start of a\r\n            // CallExpression.  As such, we need to consume the rest of it here to be complete.\r\n            return parseCallExpressionRest(expression);\r\n        }\r\n\r\n        function parseMemberExpressionOrHigher(): MemberExpression {\r\n            // Note: to make our lives simpler, we decompose the NewExpression productions and\r\n            // place ObjectCreationExpression and FunctionExpression into PrimaryExpression.\r\n            // like so:\r\n            //\r\n            //   PrimaryExpression : See 11.1\r\n            //      this\r\n            //      Identifier\r\n            //      Literal\r\n            //      ArrayLiteral\r\n            //      ObjectLiteral\r\n            //      (Expression)\r\n            //      FunctionExpression\r\n            //      new MemberExpression Arguments?\r\n            //\r\n            //   MemberExpression : See 11.2\r\n            //      PrimaryExpression\r\n            //      MemberExpression[Expression]\r\n            //      MemberExpression.IdentifierName\r\n            //\r\n            //   CallExpression : See 11.2\r\n            //      MemberExpression\r\n            //      CallExpression Arguments\r\n            //      CallExpression[Expression]\r\n            //      CallExpression.IdentifierName\r\n            //\r\n            // Technically this is ambiguous.  i.e. CallExpression defines:\r\n            //\r\n            //   CallExpression:\r\n            //      CallExpression Arguments\r\n            //\r\n            // If you see: \"new Foo()\"\r\n            //\r\n            // Then that could be treated as a single ObjectCreationExpression, or it could be\r\n            // treated as the invocation of \"new Foo\".  We disambiguate that in code (to match\r\n            // the original grammar) by making sure that if we see an ObjectCreationExpression\r\n            // we always consume arguments if they are there. So we treat \"new Foo()\" as an\r\n            // object creation only, and not at all as an invocation.  Another way to think\r\n            // about this is that for every \"new\" that we see, we will consume an argument list if\r\n            // it is there as part of the *associated* object creation node.  Any additional\r\n            // argument lists we see, will become invocation expressions.\r\n            //\r\n            // Because there are no other places in the grammar now that refer to FunctionExpression\r\n            // or ObjectCreationExpression, it is safe to push down into the PrimaryExpression\r\n            // production.\r\n            //\r\n            // Because CallExpression and MemberExpression are left recursive, we need to bottom out\r\n            // of the recursion immediately.  So we parse out a primary expression to start with.\r\n            const expression = parsePrimaryExpression();\r\n            return parseMemberExpressionRest(expression);\r\n        }\r\n\r\n        function parseSuperExpression(): MemberExpression {\r\n            const expression = parseTokenNode<PrimaryExpression>();\r\n            if (token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.DotToken || token() === SyntaxKind.OpenBracketToken) {\r\n                return expression;\r\n            }\r\n\r\n            // If we have seen \"super\" it must be followed by '(' or '.'.\r\n            // If it wasn't then just try to parse out a '.' and report an error.\r\n            const node = <PropertyAccessExpression>createNode(SyntaxKind.PropertyAccessExpression, expression.pos);\r\n            node.expression = expression;\r\n            parseExpectedToken(SyntaxKind.DotToken, Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);\r\n            node.name = parseRightSideOfDot(/*allowIdentifierNames*/ true);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function tagNamesAreEquivalent(lhs: JsxTagNameExpression, rhs: JsxTagNameExpression): boolean {\r\n            if (lhs.kind !== rhs.kind) {\r\n                return false;\r\n            }\r\n\r\n            if (lhs.kind === SyntaxKind.Identifier) {\r\n                return (<Identifier>lhs).escapedText === (<Identifier>rhs).escapedText;\r\n            }\r\n\r\n            if (lhs.kind === SyntaxKind.ThisKeyword) {\r\n                return true;\r\n            }\r\n\r\n            // If we are at this statement then we must have PropertyAccessExpression and because tag name in Jsx element can only\r\n            // take forms of JsxTagNameExpression which includes an identifier, \"this\" expression, or another propertyAccessExpression\r\n            // it is safe to case the expression property as such. See parseJsxElementName for how we parse tag name in Jsx element\r\n            return (<PropertyAccessExpression>lhs).name.escapedText === (<PropertyAccessExpression>rhs).name.escapedText &&\r\n                tagNamesAreEquivalent((<PropertyAccessExpression>lhs).expression as JsxTagNameExpression, (<PropertyAccessExpression>rhs).expression as JsxTagNameExpression);\r\n        }\r\n\r\n\r\n        function parseJsxElementOrSelfClosingElementOrFragment(inExpressionContext: boolean): JsxElement | JsxSelfClosingElement | JsxFragment {\r\n            const opening = parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext);\r\n            let result: JsxElement | JsxSelfClosingElement | JsxFragment;\r\n            if (opening.kind === SyntaxKind.JsxOpeningElement) {\r\n                const node = <JsxElement>createNode(SyntaxKind.JsxElement, opening.pos);\r\n                node.openingElement = opening;\r\n\r\n                node.children = parseJsxChildren(node.openingElement);\r\n                node.closingElement = parseJsxClosingElement(inExpressionContext);\r\n\r\n                if (!tagNamesAreEquivalent(node.openingElement.tagName, node.closingElement.tagName)) {\r\n                    parseErrorAtRange(node.closingElement, Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, getTextOfNodeFromSourceText(sourceText, node.openingElement.tagName));\r\n                }\r\n\r\n                result = finishNode(node);\r\n            }\r\n            else if (opening.kind === SyntaxKind.JsxOpeningFragment) {\r\n                const node = <JsxFragment>createNode(SyntaxKind.JsxFragment, opening.pos);\r\n                node.openingFragment = opening;\r\n                node.children = parseJsxChildren(node.openingFragment);\r\n                node.closingFragment = parseJsxClosingFragment(inExpressionContext);\r\n\r\n                result = finishNode(node);\r\n            }\r\n            else {\r\n                Debug.assert(opening.kind === SyntaxKind.JsxSelfClosingElement);\r\n                // Nothing else to do for self-closing elements\r\n                result = opening;\r\n            }\r\n\r\n            // If the user writes the invalid code '<div></div><div></div>' in an expression context (i.e. not wrapped in\r\n            // an enclosing tag), we'll naively try to parse   ^ this as a 'less than' operator and the remainder of the tag\r\n            // as garbage, which will cause the formatter to badly mangle the JSX. Perform a speculative parse of a JSX\r\n            // element if we see a < token so that we can wrap it in a synthetic binary expression so the formatter\r\n            // does less damage and we can report a better error.\r\n            // Since JSX elements are invalid < operands anyway, this lookahead parse will only occur in error scenarios\r\n            // of one sort or another.\r\n            if (inExpressionContext && token() === SyntaxKind.LessThanToken) {\r\n                const invalidElement = tryParse(() => parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ true));\r\n                if (invalidElement) {\r\n                    parseErrorAtCurrentToken(Diagnostics.JSX_expressions_must_have_one_parent_element);\r\n                    const badNode = <BinaryExpression>createNode(SyntaxKind.BinaryExpression, result.pos);\r\n                    badNode.end = invalidElement.end;\r\n                    badNode.left = result;\r\n                    badNode.right = invalidElement;\r\n                    badNode.operatorToken = createMissingNode(SyntaxKind.CommaToken, /*reportAtCurrentPosition*/ false, /*diagnosticMessage*/ undefined);\r\n                    badNode.operatorToken.pos = badNode.operatorToken.end = badNode.right.pos;\r\n                    return <JsxElement><Node>badNode;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function parseJsxText(): JsxText {\r\n            const node = <JsxText>createNode(SyntaxKind.JsxText);\r\n            node.containsOnlyWhiteSpaces = currentToken === SyntaxKind.JsxTextAllWhiteSpaces;\r\n            currentToken = scanner.scanJsxToken();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxChild(openingTag: JsxOpeningElement | JsxOpeningFragment, token: JsxTokenSyntaxKind): JsxChild | undefined {\r\n            switch (token) {\r\n                case SyntaxKind.EndOfFileToken:\r\n                    // If we hit EOF, issue the error at the tag that lacks the closing element\r\n                    // rather than at the end of the file (which is useless)\r\n                    if (isJsxOpeningFragment(openingTag)) {\r\n                        parseErrorAtRange(openingTag, Diagnostics.JSX_fragment_has_no_corresponding_closing_tag);\r\n                    }\r\n                    else {\r\n                        parseErrorAtRange(openingTag.tagName, Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, getTextOfNodeFromSourceText(sourceText, openingTag.tagName));\r\n                    }\r\n                    return undefined;\r\n                case SyntaxKind.LessThanSlashToken:\r\n                case SyntaxKind.ConflictMarkerTrivia:\r\n                    return undefined;\r\n                case SyntaxKind.JsxText:\r\n                case SyntaxKind.JsxTextAllWhiteSpaces:\r\n                    return parseJsxText();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseJsxExpression(/*inExpressionContext*/ false);\r\n                case SyntaxKind.LessThanToken:\r\n                    return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ false);\r\n                default:\r\n                    return Debug.assertNever(token);\r\n            }\r\n        }\r\n\r\n        function parseJsxChildren(openingTag: JsxOpeningElement | JsxOpeningFragment): NodeArray<JsxChild> {\r\n            const list = [];\r\n            const listPos = getNodePos();\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << ParsingContext.JsxChildren;\r\n\r\n            while (true) {\r\n                const child = parseJsxChild(openingTag, currentToken = scanner.reScanJsxToken());\r\n                if (!child) break;\r\n                list.push(child);\r\n            }\r\n\r\n            parsingContext = saveParsingContext;\r\n            return createNodeArray(list, listPos);\r\n        }\r\n\r\n        function parseJsxAttributes(): JsxAttributes {\r\n            const jsxAttributes = <JsxAttributes>createNode(SyntaxKind.JsxAttributes);\r\n            jsxAttributes.properties = parseList(ParsingContext.JsxAttributes, parseJsxAttribute);\r\n            return finishNode(jsxAttributes);\r\n        }\r\n\r\n        function parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext: boolean): JsxOpeningElement | JsxSelfClosingElement | JsxOpeningFragment {\r\n            const fullStart = scanner.getStartPos();\r\n\r\n            parseExpected(SyntaxKind.LessThanToken);\r\n\r\n            if (token() === SyntaxKind.GreaterThanToken) {\r\n                // See below for explanation of scanJsxText\r\n                const node: JsxOpeningFragment = <JsxOpeningFragment>createNode(SyntaxKind.JsxOpeningFragment, fullStart);\r\n                scanJsxText();\r\n                return finishNode(node);\r\n            }\r\n\r\n            const tagName = parseJsxElementName();\r\n            const typeArguments = tryParseTypeArguments();\r\n            const attributes = parseJsxAttributes();\r\n\r\n            let node: JsxOpeningLikeElement;\r\n\r\n            if (token() === SyntaxKind.GreaterThanToken) {\r\n                // Closing tag, so scan the immediately-following text with the JSX scanning instead\r\n                // of regular scanning to avoid treating illegal characters (e.g. '#') as immediate\r\n                // scanning errors\r\n                node = <JsxOpeningElement>createNode(SyntaxKind.JsxOpeningElement, fullStart);\r\n                scanJsxText();\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.SlashToken);\r\n                if (inExpressionContext) {\r\n                    parseExpected(SyntaxKind.GreaterThanToken);\r\n                }\r\n                else {\r\n                    parseExpected(SyntaxKind.GreaterThanToken, /*diagnostic*/ undefined, /*shouldAdvance*/ false);\r\n                    scanJsxText();\r\n                }\r\n                node = <JsxSelfClosingElement>createNode(SyntaxKind.JsxSelfClosingElement, fullStart);\r\n            }\r\n\r\n            node.tagName = tagName;\r\n            node.typeArguments = typeArguments;\r\n            node.attributes = attributes;\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxElementName(): JsxTagNameExpression {\r\n            scanJsxIdentifier();\r\n            // JsxElement can have name in the form of\r\n            //      propertyAccessExpression\r\n            //      primaryExpression in the form of an identifier and \"this\" keyword\r\n            // We can't just simply use parseLeftHandSideExpressionOrHigher because then we will start consider class,function etc as a keyword\r\n            // We only want to consider \"this\" as a primaryExpression\r\n            let expression: JsxTagNameExpression = token() === SyntaxKind.ThisKeyword ?\r\n                parseTokenNode<PrimaryExpression>() : parseIdentifierName();\r\n            while (parseOptional(SyntaxKind.DotToken)) {\r\n                const propertyAccess: PropertyAccessExpression = <PropertyAccessExpression>createNode(SyntaxKind.PropertyAccessExpression, expression.pos);\r\n                propertyAccess.expression = expression;\r\n                propertyAccess.name = parseRightSideOfDot(/*allowIdentifierNames*/ true);\r\n                expression = finishNode(propertyAccess);\r\n            }\r\n            return expression;\r\n        }\r\n\r\n        function parseJsxExpression(inExpressionContext: boolean): JsxExpression | undefined {\r\n            const node = <JsxExpression>createNode(SyntaxKind.JsxExpression);\r\n\r\n            if (!parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                return undefined;\r\n            }\r\n\r\n            if (token() !== SyntaxKind.CloseBraceToken) {\r\n                node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n                node.expression = parseAssignmentExpressionOrHigher();\r\n            }\r\n            if (inExpressionContext) {\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.CloseBraceToken, /*message*/ undefined, /*shouldAdvance*/ false);\r\n                scanJsxText();\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxAttribute(): JsxAttribute | JsxSpreadAttribute {\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                return parseJsxSpreadAttribute();\r\n            }\r\n\r\n            scanJsxIdentifier();\r\n            const node = <JsxAttribute>createNode(SyntaxKind.JsxAttribute);\r\n            node.name = parseIdentifierName();\r\n            if (token() === SyntaxKind.EqualsToken) {\r\n                switch (scanJsxAttributeValue()) {\r\n                    case SyntaxKind.StringLiteral:\r\n                        node.initializer = <StringLiteral>parseLiteralNode();\r\n                        break;\r\n                    default:\r\n                        node.initializer = parseJsxExpression(/*inExpressionContext*/ true);\r\n                        break;\r\n                }\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxSpreadAttribute(): JsxSpreadAttribute {\r\n            const node = <JsxSpreadAttribute>createNode(SyntaxKind.JsxSpreadAttribute);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            parseExpected(SyntaxKind.DotDotDotToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxClosingElement(inExpressionContext: boolean): JsxClosingElement {\r\n            const node = <JsxClosingElement>createNode(SyntaxKind.JsxClosingElement);\r\n            parseExpected(SyntaxKind.LessThanSlashToken);\r\n            node.tagName = parseJsxElementName();\r\n            if (inExpressionContext) {\r\n                parseExpected(SyntaxKind.GreaterThanToken);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.GreaterThanToken, /*diagnostic*/ undefined, /*shouldAdvance*/ false);\r\n                scanJsxText();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseJsxClosingFragment(inExpressionContext: boolean): JsxClosingFragment {\r\n            const node = <JsxClosingFragment>createNode(SyntaxKind.JsxClosingFragment);\r\n            parseExpected(SyntaxKind.LessThanSlashToken);\r\n            if (tokenIsIdentifierOrKeyword(token())) {\r\n                parseErrorAtRange(parseJsxElementName(), Diagnostics.Expected_corresponding_closing_tag_for_JSX_fragment);\r\n            }\r\n            if (inExpressionContext) {\r\n                parseExpected(SyntaxKind.GreaterThanToken);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.GreaterThanToken, /*diagnostic*/ undefined, /*shouldAdvance*/ false);\r\n                scanJsxText();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeAssertion(): TypeAssertion {\r\n            const node = <TypeAssertion>createNode(SyntaxKind.TypeAssertionExpression);\r\n            parseExpected(SyntaxKind.LessThanToken);\r\n            node.type = parseType();\r\n            parseExpected(SyntaxKind.GreaterThanToken);\r\n            node.expression = parseSimpleUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseMemberExpressionRest(expression: LeftHandSideExpression): MemberExpression {\r\n            while (true) {\r\n                const dotToken = parseOptionalToken(SyntaxKind.DotToken);\r\n                if (dotToken) {\r\n                    const propertyAccess = <PropertyAccessExpression>createNode(SyntaxKind.PropertyAccessExpression, expression.pos);\r\n                    propertyAccess.expression = expression;\r\n                    propertyAccess.name = parseRightSideOfDot(/*allowIdentifierNames*/ true);\r\n                    expression = finishNode(propertyAccess);\r\n                    continue;\r\n                }\r\n\r\n                if (token() === SyntaxKind.ExclamationToken && !scanner.hasPrecedingLineBreak()) {\r\n                    nextToken();\r\n                    const nonNullExpression = <NonNullExpression>createNode(SyntaxKind.NonNullExpression, expression.pos);\r\n                    nonNullExpression.expression = expression;\r\n                    expression = finishNode(nonNullExpression);\r\n                    continue;\r\n                }\r\n\r\n                // when in the [Decorator] context, we do not parse ElementAccess as it could be part of a ComputedPropertyName\r\n                if (!inDecoratorContext() && parseOptional(SyntaxKind.OpenBracketToken)) {\r\n                    const indexedAccess = <ElementAccessExpression>createNode(SyntaxKind.ElementAccessExpression, expression.pos);\r\n                    indexedAccess.expression = expression;\r\n\r\n                    if (token() === SyntaxKind.CloseBracketToken) {\r\n                        indexedAccess.argumentExpression = createMissingNode(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics.An_element_access_expression_should_take_an_argument);\r\n                    }\r\n                    else {\r\n                        const argument = allowInAnd(parseExpression);\r\n                        if (isStringOrNumericLiteral(argument)) {\r\n                            argument.text = internIdentifier(argument.text);\r\n                        }\r\n                        indexedAccess.argumentExpression = argument;\r\n                    }\r\n\r\n                    parseExpected(SyntaxKind.CloseBracketToken);\r\n                    expression = finishNode(indexedAccess);\r\n                    continue;\r\n                }\r\n\r\n                if (isTemplateStartOfTaggedTemplate()) {\r\n                    expression = parseTaggedTemplateRest(expression, /*typeArguments*/ undefined);\r\n                    continue;\r\n                }\r\n\r\n                return <MemberExpression>expression;\r\n            }\r\n        }\r\n\r\n        function isTemplateStartOfTaggedTemplate() {\r\n            return token() === SyntaxKind.NoSubstitutionTemplateLiteral || token() === SyntaxKind.TemplateHead;\r\n        }\r\n\r\n        function parseTaggedTemplateRest(tag: LeftHandSideExpression, typeArguments: NodeArray<TypeNode> | undefined) {\r\n            const tagExpression = <TaggedTemplateExpression>createNode(SyntaxKind.TaggedTemplateExpression, tag.pos);\r\n            tagExpression.tag = tag;\r\n            tagExpression.typeArguments = typeArguments;\r\n            tagExpression.template = token() === SyntaxKind.NoSubstitutionTemplateLiteral\r\n                ? <NoSubstitutionTemplateLiteral>parseLiteralNode()\r\n                : parseTemplateExpression();\r\n            return finishNode(tagExpression);\r\n        }\r\n\r\n        function parseCallExpressionRest(expression: LeftHandSideExpression): LeftHandSideExpression {\r\n            while (true) {\r\n                expression = parseMemberExpressionRest(expression);\r\n                if (token() === SyntaxKind.LessThanToken) {\r\n                    // See if this is the start of a generic invocation.  If so, consume it and\r\n                    // keep checking for postfix expressions.  Otherwise, it's just a '<' that's\r\n                    // part of an arithmetic expression.  Break out so we consume it higher in the\r\n                    // stack.\r\n                    const typeArguments = tryParse(parseTypeArgumentsInExpression);\r\n                    if (!typeArguments) {\r\n                        return expression;\r\n                    }\r\n\r\n                    if (isTemplateStartOfTaggedTemplate()) {\r\n                        expression = parseTaggedTemplateRest(expression, typeArguments);\r\n                        continue;\r\n                    }\r\n\r\n                    const callExpr = <CallExpression>createNode(SyntaxKind.CallExpression, expression.pos);\r\n                    callExpr.expression = expression;\r\n                    callExpr.typeArguments = typeArguments;\r\n                    callExpr.arguments = parseArgumentList();\r\n                    expression = finishNode(callExpr);\r\n                    continue;\r\n                }\r\n                else if (token() === SyntaxKind.OpenParenToken) {\r\n                    const callExpr = <CallExpression>createNode(SyntaxKind.CallExpression, expression.pos);\r\n                    callExpr.expression = expression;\r\n                    callExpr.arguments = parseArgumentList();\r\n                    expression = finishNode(callExpr);\r\n                    continue;\r\n                }\r\n\r\n                return expression;\r\n            }\r\n        }\r\n\r\n        function parseArgumentList() {\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            const result = parseDelimitedList(ParsingContext.ArgumentExpressions, parseArgumentExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return result;\r\n        }\r\n\r\n        function parseTypeArgumentsInExpression() {\r\n            if (!parseOptional(SyntaxKind.LessThanToken)) {\r\n                return undefined;\r\n            }\r\n\r\n            const typeArguments = parseDelimitedList(ParsingContext.TypeArguments, parseType);\r\n            if (!parseExpected(SyntaxKind.GreaterThanToken)) {\r\n                // If it doesn't have the closing `>` then it's definitely not an type argument list.\r\n                return undefined;\r\n            }\r\n\r\n            // If we have a '<', then only parse this as a argument list if the type arguments\r\n            // are complete and we have an open paren.  if we don't, rewind and return nothing.\r\n            return typeArguments && canFollowTypeArgumentsInExpression()\r\n                ? typeArguments\r\n                : undefined;\r\n        }\r\n\r\n        function canFollowTypeArgumentsInExpression(): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.OpenParenToken:                 // foo<x>(\r\n                case SyntaxKind.NoSubstitutionTemplateLiteral:  // foo<T> `...`\r\n                case SyntaxKind.TemplateHead:                   // foo<T> `...${100}...`\r\n                // these are the only tokens can legally follow a type argument\r\n                // list. So we definitely want to treat them as type arg lists.\r\n\r\n                case SyntaxKind.DotToken:                       // foo<x>.\r\n                case SyntaxKind.CloseParenToken:                // foo<x>)\r\n                case SyntaxKind.CloseBracketToken:              // foo<x>]\r\n                case SyntaxKind.ColonToken:                     // foo<x>:\r\n                case SyntaxKind.SemicolonToken:                 // foo<x>;\r\n                case SyntaxKind.QuestionToken:                  // foo<x>?\r\n                case SyntaxKind.EqualsEqualsToken:              // foo<x> ==\r\n                case SyntaxKind.EqualsEqualsEqualsToken:        // foo<x> ===\r\n                case SyntaxKind.ExclamationEqualsToken:         // foo<x> !=\r\n                case SyntaxKind.ExclamationEqualsEqualsToken:   // foo<x> !==\r\n                case SyntaxKind.AmpersandAmpersandToken:        // foo<x> &&\r\n                case SyntaxKind.BarBarToken:                    // foo<x> ||\r\n                case SyntaxKind.CaretToken:                     // foo<x> ^\r\n                case SyntaxKind.AmpersandToken:                 // foo<x> &\r\n                case SyntaxKind.BarToken:                       // foo<x> |\r\n                case SyntaxKind.CloseBraceToken:                // foo<x> }\r\n                case SyntaxKind.EndOfFileToken:                 // foo<x>\r\n                    // these cases can't legally follow a type arg list.  However, they're not legal\r\n                    // expressions either.  The user is probably in the middle of a generic type. So\r\n                    // treat it as such.\r\n                    return true;\r\n\r\n                case SyntaxKind.CommaToken:                     // foo<x>,\r\n                case SyntaxKind.OpenBraceToken:                 // foo<x> {\r\n                // We don't want to treat these as type arguments.  Otherwise we'll parse this\r\n                // as an invocation expression.  Instead, we want to parse out the expression\r\n                // in isolation from the type arguments.\r\n\r\n                default:\r\n                    // Anything else treat as an expression.\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        function parsePrimaryExpression(): PrimaryExpression {\r\n            switch (token()) {\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                    return parseLiteralNode();\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                    return parseTokenNode<PrimaryExpression>();\r\n                case SyntaxKind.OpenParenToken:\r\n                    return parseParenthesizedExpression();\r\n                case SyntaxKind.OpenBracketToken:\r\n                    return parseArrayLiteralExpression();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseObjectLiteralExpression();\r\n                case SyntaxKind.AsyncKeyword:\r\n                    // Async arrow functions are parsed earlier in parseAssignmentExpressionOrHigher.\r\n                    // If we encounter `async [no LineTerminator here] function` then this is an async\r\n                    // function; otherwise, its an identifier.\r\n                    if (!lookAhead(nextTokenIsFunctionKeywordOnSameLine)) {\r\n                        break;\r\n                    }\r\n\r\n                    return parseFunctionExpression();\r\n                case SyntaxKind.ClassKeyword:\r\n                    return parseClassExpression();\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionExpression();\r\n                case SyntaxKind.NewKeyword:\r\n                    return parseNewExpressionOrNewDotTarget();\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.SlashEqualsToken:\r\n                    if (reScanSlashToken() === SyntaxKind.RegularExpressionLiteral) {\r\n                        return parseLiteralNode();\r\n                    }\r\n                    break;\r\n                case SyntaxKind.TemplateHead:\r\n                    return parseTemplateExpression();\r\n            }\r\n\r\n            return parseIdentifier(Diagnostics.Expression_expected);\r\n        }\r\n\r\n        function parseParenthesizedExpression(): ParenthesizedExpression {\r\n            const node = <ParenthesizedExpression>createNodeWithJSDoc(SyntaxKind.ParenthesizedExpression);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseSpreadElement(): Expression {\r\n            const node = <SpreadElement>createNode(SyntaxKind.SpreadElement);\r\n            parseExpected(SyntaxKind.DotDotDotToken);\r\n            node.expression = parseAssignmentExpressionOrHigher();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseArgumentOrArrayLiteralElement(): Expression {\r\n            return token() === SyntaxKind.DotDotDotToken ? parseSpreadElement() :\r\n                token() === SyntaxKind.CommaToken ? <Expression>createNode(SyntaxKind.OmittedExpression) :\r\n                    parseAssignmentExpressionOrHigher();\r\n        }\r\n\r\n        function parseArgumentExpression(): Expression {\r\n            return doOutsideOfContext(disallowInAndDecoratorContext, parseArgumentOrArrayLiteralElement);\r\n        }\r\n\r\n        function parseArrayLiteralExpression(): ArrayLiteralExpression {\r\n            const node = <ArrayLiteralExpression>createNode(SyntaxKind.ArrayLiteralExpression);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                node.multiLine = true;\r\n            }\r\n            node.elements = parseDelimitedList(ParsingContext.ArrayLiteralMembers, parseArgumentOrArrayLiteralElement);\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectLiteralElement(): ObjectLiteralElementLike {\r\n            const node = <ObjectLiteralElementLike>createNodeWithJSDoc(SyntaxKind.Unknown);\r\n\r\n            if (parseOptionalToken(SyntaxKind.DotDotDotToken)) {\r\n                node.kind = SyntaxKind.SpreadAssignment;\r\n                (<SpreadAssignment>node).expression = parseAssignmentExpressionOrHigher();\r\n                return finishNode(node);\r\n            }\r\n\r\n            node.decorators = parseDecorators();\r\n            node.modifiers = parseModifiers();\r\n\r\n            if (parseContextualModifier(SyntaxKind.GetKeyword)) {\r\n                return parseAccessorDeclaration(<AccessorDeclaration>node, SyntaxKind.GetAccessor);\r\n            }\r\n            if (parseContextualModifier(SyntaxKind.SetKeyword)) {\r\n                return parseAccessorDeclaration(<AccessorDeclaration>node, SyntaxKind.SetAccessor);\r\n            }\r\n\r\n            const asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n            const tokenIsIdentifier = isIdentifier();\r\n            node.name = parsePropertyName();\r\n            // Disallowing of optional property assignments happens in the grammar checker.\r\n            (<MethodDeclaration>node).questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            if (asteriskToken || token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return parseMethodDeclaration(<MethodDeclaration>node, asteriskToken);\r\n            }\r\n\r\n            // check if it is short-hand property assignment or normal property assignment\r\n            // NOTE: if token is EqualsToken it is interpreted as CoverInitializedName production\r\n            // CoverInitializedName[Yield] :\r\n            //     IdentifierReference[?Yield] Initializer[In, ?Yield]\r\n            // this is necessary because ObjectLiteral productions are also used to cover grammar for ObjectAssignmentPattern\r\n            const isShorthandPropertyAssignment =\r\n                tokenIsIdentifier && (token() === SyntaxKind.CommaToken || token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.EqualsToken);\r\n            if (isShorthandPropertyAssignment) {\r\n                node.kind = SyntaxKind.ShorthandPropertyAssignment;\r\n                const equalsToken = parseOptionalToken(SyntaxKind.EqualsToken);\r\n                if (equalsToken) {\r\n                    (<ShorthandPropertyAssignment>node).equalsToken = equalsToken;\r\n                    (<ShorthandPropertyAssignment>node).objectAssignmentInitializer = allowInAnd(parseAssignmentExpressionOrHigher);\r\n                }\r\n            }\r\n            else {\r\n                node.kind = SyntaxKind.PropertyAssignment;\r\n                parseExpected(SyntaxKind.ColonToken);\r\n                (<PropertyAssignment>node).initializer = allowInAnd(parseAssignmentExpressionOrHigher);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectLiteralExpression(): ObjectLiteralExpression {\r\n            const node = <ObjectLiteralExpression>createNode(SyntaxKind.ObjectLiteralExpression);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                node.multiLine = true;\r\n            }\r\n\r\n            node.properties = parseDelimitedList(ParsingContext.ObjectLiteralMembers, parseObjectLiteralElement, /*considerSemicolonAsDelimiter*/ true);\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionExpression(): FunctionExpression {\r\n            // GeneratorExpression:\r\n            //      function* BindingIdentifier [Yield][opt](FormalParameters[Yield]){ GeneratorBody }\r\n            //\r\n            // FunctionExpression:\r\n            //      function BindingIdentifier[opt](FormalParameters){ FunctionBody }\r\n            const saveDecoratorContext = inDecoratorContext();\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ false);\r\n            }\r\n\r\n            const node = <FunctionExpression>createNodeWithJSDoc(SyntaxKind.FunctionExpression);\r\n            node.modifiers = parseModifiers();\r\n            parseExpected(SyntaxKind.FunctionKeyword);\r\n            node.asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n\r\n            const isGenerator = node.asteriskToken ? SignatureFlags.Yield : SignatureFlags.None;\r\n            const isAsync = hasModifier(node, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            node.name =\r\n                isGenerator && isAsync ? doInYieldAndAwaitContext(parseOptionalIdentifier) :\r\n                    isGenerator ? doInYieldContext(parseOptionalIdentifier) :\r\n                        isAsync ? doInAwaitContext(parseOptionalIdentifier) :\r\n                            parseOptionalIdentifier();\r\n\r\n            fillSignature(SyntaxKind.ColonToken, isGenerator | isAsync, node);\r\n            node.body = parseFunctionBlock(isGenerator | isAsync);\r\n\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ true);\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseOptionalIdentifier(): Identifier | undefined {\r\n            return isIdentifier() ? parseIdentifier() : undefined;\r\n        }\r\n\r\n        function parseNewExpressionOrNewDotTarget(): NewExpression | MetaProperty {\r\n            const fullStart = scanner.getStartPos();\r\n            parseExpected(SyntaxKind.NewKeyword);\r\n            if (parseOptional(SyntaxKind.DotToken)) {\r\n                const node = <MetaProperty>createNode(SyntaxKind.MetaProperty, fullStart);\r\n                node.keywordToken = SyntaxKind.NewKeyword;\r\n                node.name = parseIdentifierName();\r\n                return finishNode(node);\r\n            }\r\n\r\n            let expression: MemberExpression = parsePrimaryExpression();\r\n            let typeArguments;\r\n            while (true) {\r\n                expression = parseMemberExpressionRest(expression);\r\n                typeArguments = tryParse(parseTypeArgumentsInExpression);\r\n                if (isTemplateStartOfTaggedTemplate()) {\r\n                    Debug.assert(!!typeArguments,\r\n                        \"Expected a type argument list; all plain tagged template starts should be consumed in 'parseMemberExpressionRest'\");\r\n                    expression = parseTaggedTemplateRest(expression, typeArguments);\r\n                    typeArguments = undefined;\r\n                }\r\n                break;\r\n            }\r\n\r\n            const node = <NewExpression>createNode(SyntaxKind.NewExpression, fullStart);\r\n            node.expression = expression;\r\n            node.typeArguments = typeArguments;\r\n            if (node.typeArguments || token() === SyntaxKind.OpenParenToken) {\r\n                node.arguments = parseArgumentList();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        // STATEMENTS\r\n        function parseBlock(ignoreMissingOpenBrace: boolean, diagnosticMessage?: DiagnosticMessage): Block {\r\n            const node = <Block>createNode(SyntaxKind.Block);\r\n            if (parseExpected(SyntaxKind.OpenBraceToken, diagnosticMessage) || ignoreMissingOpenBrace) {\r\n                if (scanner.hasPrecedingLineBreak()) {\r\n                    node.multiLine = true;\r\n                }\r\n\r\n                node.statements = parseList(ParsingContext.BlockStatements, parseStatement);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.statements = createMissingList<Statement>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionBlock(flags: SignatureFlags, diagnosticMessage?: DiagnosticMessage): Block {\r\n            const savedYieldContext = inYieldContext();\r\n            setYieldContext(!!(flags & SignatureFlags.Yield));\r\n\r\n            const savedAwaitContext = inAwaitContext();\r\n            setAwaitContext(!!(flags & SignatureFlags.Await));\r\n\r\n            // We may be in a [Decorator] context when parsing a function expression or\r\n            // arrow function. The body of the function is not in [Decorator] context.\r\n            const saveDecoratorContext = inDecoratorContext();\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ false);\r\n            }\r\n\r\n            const block = parseBlock(!!(flags & SignatureFlags.IgnoreMissingOpenBrace), diagnosticMessage);\r\n\r\n            if (saveDecoratorContext) {\r\n                setDecoratorContext(/*val*/ true);\r\n            }\r\n\r\n            setYieldContext(savedYieldContext);\r\n            setAwaitContext(savedAwaitContext);\r\n\r\n            return block;\r\n        }\r\n\r\n        function parseEmptyStatement(): Statement {\r\n            const node = <Statement>createNode(SyntaxKind.EmptyStatement);\r\n            parseExpected(SyntaxKind.SemicolonToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseIfStatement(): IfStatement {\r\n            const node = <IfStatement>createNode(SyntaxKind.IfStatement);\r\n            parseExpected(SyntaxKind.IfKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.thenStatement = parseStatement();\r\n            node.elseStatement = parseOptional(SyntaxKind.ElseKeyword) ? parseStatement() : undefined;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDoStatement(): DoStatement {\r\n            const node = <DoStatement>createNode(SyntaxKind.DoStatement);\r\n            parseExpected(SyntaxKind.DoKeyword);\r\n            node.statement = parseStatement();\r\n            parseExpected(SyntaxKind.WhileKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n\r\n            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html\r\n            // 157 min --- All allen at wirfs-brock.com CONF --- \"do{;}while(false)false\" prohibited in\r\n            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby\r\n            //  do;while(0)x will have a semicolon inserted before x.\r\n            parseOptional(SyntaxKind.SemicolonToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseWhileStatement(): WhileStatement {\r\n            const node = <WhileStatement>createNode(SyntaxKind.WhileStatement);\r\n            parseExpected(SyntaxKind.WhileKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.statement = parseStatement();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseForOrForInOrForOfStatement(): Statement {\r\n            const pos = getNodePos();\r\n            parseExpected(SyntaxKind.ForKeyword);\r\n            const awaitToken = parseOptionalToken(SyntaxKind.AwaitKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n\r\n            let initializer: VariableDeclarationList | Expression;\r\n            if (token() !== SyntaxKind.SemicolonToken) {\r\n                if (token() === SyntaxKind.VarKeyword || token() === SyntaxKind.LetKeyword || token() === SyntaxKind.ConstKeyword) {\r\n                    initializer = parseVariableDeclarationList(/*inForStatementInitializer*/ true);\r\n                }\r\n                else {\r\n                    initializer = disallowInAnd(parseExpression);\r\n                }\r\n            }\r\n            let forOrForInOrForOfStatement: IterationStatement;\r\n            if (awaitToken ? parseExpected(SyntaxKind.OfKeyword) : parseOptional(SyntaxKind.OfKeyword)) {\r\n                const forOfStatement = <ForOfStatement>createNode(SyntaxKind.ForOfStatement, pos);\r\n                forOfStatement.awaitModifier = awaitToken;\r\n                forOfStatement.initializer = initializer;\r\n                forOfStatement.expression = allowInAnd(parseAssignmentExpressionOrHigher);\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInOrForOfStatement = forOfStatement;\r\n            }\r\n            else if (parseOptional(SyntaxKind.InKeyword)) {\r\n                const forInStatement = <ForInStatement>createNode(SyntaxKind.ForInStatement, pos);\r\n                forInStatement.initializer = initializer;\r\n                forInStatement.expression = allowInAnd(parseExpression);\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInOrForOfStatement = forInStatement;\r\n            }\r\n            else {\r\n                const forStatement = <ForStatement>createNode(SyntaxKind.ForStatement, pos);\r\n                forStatement.initializer = initializer;\r\n                parseExpected(SyntaxKind.SemicolonToken);\r\n                if (token() !== SyntaxKind.SemicolonToken && token() !== SyntaxKind.CloseParenToken) {\r\n                    forStatement.condition = allowInAnd(parseExpression);\r\n                }\r\n                parseExpected(SyntaxKind.SemicolonToken);\r\n                if (token() !== SyntaxKind.CloseParenToken) {\r\n                    forStatement.incrementor = allowInAnd(parseExpression);\r\n                }\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInOrForOfStatement = forStatement;\r\n            }\r\n\r\n            forOrForInOrForOfStatement.statement = parseStatement();\r\n\r\n            return finishNode(forOrForInOrForOfStatement);\r\n        }\r\n\r\n        function parseBreakOrContinueStatement(kind: SyntaxKind): BreakOrContinueStatement {\r\n            const node = <BreakOrContinueStatement>createNode(kind);\r\n\r\n            parseExpected(kind === SyntaxKind.BreakStatement ? SyntaxKind.BreakKeyword : SyntaxKind.ContinueKeyword);\r\n            if (!canParseSemicolon()) {\r\n                node.label = parseIdentifier();\r\n            }\r\n\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseReturnStatement(): ReturnStatement {\r\n            const node = <ReturnStatement>createNode(SyntaxKind.ReturnStatement);\r\n\r\n            parseExpected(SyntaxKind.ReturnKeyword);\r\n            if (!canParseSemicolon()) {\r\n                node.expression = allowInAnd(parseExpression);\r\n            }\r\n\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseWithStatement(): WithStatement {\r\n            const node = <WithStatement>createNode(SyntaxKind.WithStatement);\r\n            parseExpected(SyntaxKind.WithKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.statement = doInsideOfContext(NodeFlags.InWithStatement, parseStatement);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCaseClause(): CaseClause {\r\n            const node = <CaseClause>createNode(SyntaxKind.CaseClause);\r\n            parseExpected(SyntaxKind.CaseKeyword);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.ColonToken);\r\n            node.statements = parseList(ParsingContext.SwitchClauseStatements, parseStatement);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDefaultClause(): DefaultClause {\r\n            const node = <DefaultClause>createNode(SyntaxKind.DefaultClause);\r\n            parseExpected(SyntaxKind.DefaultKeyword);\r\n            parseExpected(SyntaxKind.ColonToken);\r\n            node.statements = parseList(ParsingContext.SwitchClauseStatements, parseStatement);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCaseOrDefaultClause(): CaseOrDefaultClause {\r\n            return token() === SyntaxKind.CaseKeyword ? parseCaseClause() : parseDefaultClause();\r\n        }\r\n\r\n        function parseSwitchStatement(): SwitchStatement {\r\n            const node = <SwitchStatement>createNode(SyntaxKind.SwitchStatement);\r\n            parseExpected(SyntaxKind.SwitchKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = allowInAnd(parseExpression);\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            const caseBlock = <CaseBlock>createNode(SyntaxKind.CaseBlock);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            caseBlock.clauses = parseList(ParsingContext.SwitchClauses, parseCaseOrDefaultClause);\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            node.caseBlock = finishNode(caseBlock);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseThrowStatement(): ThrowStatement {\r\n            // ThrowStatement[Yield] :\r\n            //      throw [no LineTerminator here]Expression[In, ?Yield];\r\n\r\n            // Because of automatic semicolon insertion, we need to report error if this\r\n            // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'\r\n            // directly as that might consume an expression on the following line.\r\n            // We just return 'undefined' in that case.  The actual error will be reported in the\r\n            // grammar walker.\r\n            const node = <ThrowStatement>createNode(SyntaxKind.ThrowStatement);\r\n            parseExpected(SyntaxKind.ThrowKeyword);\r\n            node.expression = scanner.hasPrecedingLineBreak() ? undefined : allowInAnd(parseExpression);\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        // TODO: Review for error recovery\r\n        function parseTryStatement(): TryStatement {\r\n            const node = <TryStatement>createNode(SyntaxKind.TryStatement);\r\n\r\n            parseExpected(SyntaxKind.TryKeyword);\r\n            node.tryBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n            node.catchClause = token() === SyntaxKind.CatchKeyword ? parseCatchClause() : undefined;\r\n\r\n            // If we don't have a catch clause, then we must have a finally clause.  Try to parse\r\n            // one out no matter what.\r\n            if (!node.catchClause || token() === SyntaxKind.FinallyKeyword) {\r\n                parseExpected(SyntaxKind.FinallyKeyword);\r\n                node.finallyBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCatchClause(): CatchClause {\r\n            const result = <CatchClause>createNode(SyntaxKind.CatchClause);\r\n            parseExpected(SyntaxKind.CatchKeyword);\r\n\r\n            if (parseOptional(SyntaxKind.OpenParenToken)) {\r\n                result.variableDeclaration = parseVariableDeclaration();\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n            }\r\n            else {\r\n                // Keep shape of node to avoid degrading performance.\r\n                result.variableDeclaration = undefined;\r\n            }\r\n\r\n            result.block = parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n            return finishNode(result);\r\n        }\r\n\r\n        function parseDebuggerStatement(): Statement {\r\n            const node = <Statement>createNode(SyntaxKind.DebuggerStatement);\r\n            parseExpected(SyntaxKind.DebuggerKeyword);\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExpressionOrLabeledStatement(): ExpressionStatement | LabeledStatement {\r\n            // Avoiding having to do the lookahead for a labeled statement by just trying to parse\r\n            // out an expression, seeing if it is identifier and then seeing if it is followed by\r\n            // a colon.\r\n            const node = <ExpressionStatement | LabeledStatement>createNodeWithJSDoc(SyntaxKind.Unknown);\r\n            const expression = allowInAnd(parseExpression);\r\n            if (expression.kind === SyntaxKind.Identifier && parseOptional(SyntaxKind.ColonToken)) {\r\n                node.kind = SyntaxKind.LabeledStatement;\r\n                (<LabeledStatement>node).label = <Identifier>expression;\r\n                (<LabeledStatement>node).statement = parseStatement();\r\n            }\r\n            else {\r\n                node.kind = SyntaxKind.ExpressionStatement;\r\n                (<ExpressionStatement>node).expression = expression;\r\n                parseSemicolon();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrKeywordOnSameLine() {\r\n            nextToken();\r\n            return tokenIsIdentifierOrKeyword(token()) && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function nextTokenIsClassKeywordOnSameLine() {\r\n            nextToken();\r\n            return token() === SyntaxKind.ClassKeyword && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function nextTokenIsFunctionKeywordOnSameLine() {\r\n            nextToken();\r\n            return token() === SyntaxKind.FunctionKeyword && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine() {\r\n            nextToken();\r\n            return (tokenIsIdentifierOrKeyword(token()) || token() === SyntaxKind.NumericLiteral || token() === SyntaxKind.StringLiteral) && !scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function isDeclaration(): boolean {\r\n            while (true) {\r\n                switch (token()) {\r\n                    case SyntaxKind.VarKeyword:\r\n                    case SyntaxKind.LetKeyword:\r\n                    case SyntaxKind.ConstKeyword:\r\n                    case SyntaxKind.FunctionKeyword:\r\n                    case SyntaxKind.ClassKeyword:\r\n                    case SyntaxKind.EnumKeyword:\r\n                        return true;\r\n\r\n                    // 'declare', 'module', 'namespace', 'interface'* and 'type' are all legal JavaScript identifiers;\r\n                    // however, an identifier cannot be followed by another identifier on the same line. This is what we\r\n                    // count on to parse out the respective declarations. For instance, we exploit this to say that\r\n                    //\r\n                    //    namespace n\r\n                    //\r\n                    // can be none other than the beginning of a namespace declaration, but need to respect that JavaScript sees\r\n                    //\r\n                    //    namespace\r\n                    //    n\r\n                    //\r\n                    // as the identifier 'namespace' on one line followed by the identifier 'n' on another.\r\n                    // We need to look one token ahead to see if it permissible to try parsing a declaration.\r\n                    //\r\n                    // *Note*: 'interface' is actually a strict mode reserved word. So while\r\n                    //\r\n                    //   \"use strict\"\r\n                    //   interface\r\n                    //   I {}\r\n                    //\r\n                    // could be legal, it would add complexity for very little gain.\r\n                    case SyntaxKind.InterfaceKeyword:\r\n                    case SyntaxKind.TypeKeyword:\r\n                        return nextTokenIsIdentifierOnSameLine();\r\n                    case SyntaxKind.ModuleKeyword:\r\n                    case SyntaxKind.NamespaceKeyword:\r\n                        return nextTokenIsIdentifierOrStringLiteralOnSameLine();\r\n                    case SyntaxKind.AbstractKeyword:\r\n                    case SyntaxKind.AsyncKeyword:\r\n                    case SyntaxKind.DeclareKeyword:\r\n                    case SyntaxKind.PrivateKeyword:\r\n                    case SyntaxKind.ProtectedKeyword:\r\n                    case SyntaxKind.PublicKeyword:\r\n                    case SyntaxKind.ReadonlyKeyword:\r\n                        nextToken();\r\n                        // ASI takes effect for this modifier.\r\n                        if (scanner.hasPrecedingLineBreak()) {\r\n                            return false;\r\n                        }\r\n                        continue;\r\n\r\n                    case SyntaxKind.GlobalKeyword:\r\n                        nextToken();\r\n                        return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.Identifier || token() === SyntaxKind.ExportKeyword;\r\n\r\n                    case SyntaxKind.ImportKeyword:\r\n                        nextToken();\r\n                        return token() === SyntaxKind.StringLiteral || token() === SyntaxKind.AsteriskToken ||\r\n                            token() === SyntaxKind.OpenBraceToken || tokenIsIdentifierOrKeyword(token());\r\n                    case SyntaxKind.ExportKeyword:\r\n                        nextToken();\r\n                        if (token() === SyntaxKind.EqualsToken || token() === SyntaxKind.AsteriskToken ||\r\n                            token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.DefaultKeyword ||\r\n                            token() === SyntaxKind.AsKeyword) {\r\n                            return true;\r\n                        }\r\n                        continue;\r\n\r\n                    case SyntaxKind.StaticKeyword:\r\n                        nextToken();\r\n                        continue;\r\n                    default:\r\n                        return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        function isStartOfDeclaration(): boolean {\r\n            return lookAhead(isDeclaration);\r\n        }\r\n\r\n        function isStartOfStatement(): boolean {\r\n            switch (token()) {\r\n                case SyntaxKind.AtToken:\r\n                case SyntaxKind.SemicolonToken:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.VarKeyword:\r\n                case SyntaxKind.LetKeyword:\r\n                case SyntaxKind.FunctionKeyword:\r\n                case SyntaxKind.ClassKeyword:\r\n                case SyntaxKind.EnumKeyword:\r\n                case SyntaxKind.IfKeyword:\r\n                case SyntaxKind.DoKeyword:\r\n                case SyntaxKind.WhileKeyword:\r\n                case SyntaxKind.ForKeyword:\r\n                case SyntaxKind.ContinueKeyword:\r\n                case SyntaxKind.BreakKeyword:\r\n                case SyntaxKind.ReturnKeyword:\r\n                case SyntaxKind.WithKeyword:\r\n                case SyntaxKind.SwitchKeyword:\r\n                case SyntaxKind.ThrowKeyword:\r\n                case SyntaxKind.TryKeyword:\r\n                case SyntaxKind.DebuggerKeyword:\r\n                // 'catch' and 'finally' do not actually indicate that the code is part of a statement,\r\n                // however, we say they are here so that we may gracefully parse them and error later.\r\n                case SyntaxKind.CatchKeyword:\r\n                case SyntaxKind.FinallyKeyword:\r\n                    return true;\r\n\r\n                case SyntaxKind.ImportKeyword:\r\n                    return isStartOfDeclaration() || lookAhead(nextTokenIsOpenParenOrLessThanOrDot);\r\n\r\n                case SyntaxKind.ConstKeyword:\r\n                case SyntaxKind.ExportKeyword:\r\n                    return isStartOfDeclaration();\r\n\r\n                case SyntaxKind.AsyncKeyword:\r\n                case SyntaxKind.DeclareKeyword:\r\n                case SyntaxKind.InterfaceKeyword:\r\n                case SyntaxKind.ModuleKeyword:\r\n                case SyntaxKind.NamespaceKeyword:\r\n                case SyntaxKind.TypeKeyword:\r\n                case SyntaxKind.GlobalKeyword:\r\n                    // When these don't start a declaration, they're an identifier in an expression statement\r\n                    return true;\r\n\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.ProtectedKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                case SyntaxKind.ReadonlyKeyword:\r\n                    // When these don't start a declaration, they may be the start of a class member if an identifier\r\n                    // immediately follows. Otherwise they're an identifier in an expression statement.\r\n                    return isStartOfDeclaration() || !lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);\r\n\r\n                default:\r\n                    return isStartOfExpression();\r\n            }\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrStartOfDestructuring() {\r\n            nextToken();\r\n            return isIdentifier() || token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.OpenBracketToken;\r\n        }\r\n\r\n        function isLetDeclaration() {\r\n            // In ES6 'let' always starts a lexical declaration if followed by an identifier or {\r\n            // or [.\r\n            return lookAhead(nextTokenIsIdentifierOrStartOfDestructuring);\r\n        }\r\n\r\n        function parseStatement(): Statement {\r\n            switch (token()) {\r\n                case SyntaxKind.SemicolonToken:\r\n                    return parseEmptyStatement();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseBlock(/*ignoreMissingOpenBrace*/ false);\r\n                case SyntaxKind.VarKeyword:\r\n                    return parseVariableStatement(<VariableStatement>createNodeWithJSDoc(SyntaxKind.VariableDeclaration));\r\n                case SyntaxKind.LetKeyword:\r\n                    if (isLetDeclaration()) {\r\n                        return parseVariableStatement(<VariableStatement>createNodeWithJSDoc(SyntaxKind.VariableDeclaration));\r\n                    }\r\n                    break;\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionDeclaration(<FunctionDeclaration>createNodeWithJSDoc(SyntaxKind.FunctionDeclaration));\r\n                case SyntaxKind.ClassKeyword:\r\n                    return parseClassDeclaration(<ClassDeclaration>createNodeWithJSDoc(SyntaxKind.ClassDeclaration));\r\n                case SyntaxKind.IfKeyword:\r\n                    return parseIfStatement();\r\n                case SyntaxKind.DoKeyword:\r\n                    return parseDoStatement();\r\n                case SyntaxKind.WhileKeyword:\r\n                    return parseWhileStatement();\r\n                case SyntaxKind.ForKeyword:\r\n                    return parseForOrForInOrForOfStatement();\r\n                case SyntaxKind.ContinueKeyword:\r\n                    return parseBreakOrContinueStatement(SyntaxKind.ContinueStatement);\r\n                case SyntaxKind.BreakKeyword:\r\n                    return parseBreakOrContinueStatement(SyntaxKind.BreakStatement);\r\n                case SyntaxKind.ReturnKeyword:\r\n                    return parseReturnStatement();\r\n                case SyntaxKind.WithKeyword:\r\n                    return parseWithStatement();\r\n                case SyntaxKind.SwitchKeyword:\r\n                    return parseSwitchStatement();\r\n                case SyntaxKind.ThrowKeyword:\r\n                    return parseThrowStatement();\r\n                case SyntaxKind.TryKeyword:\r\n                // Include 'catch' and 'finally' for error recovery.\r\n                case SyntaxKind.CatchKeyword:\r\n                case SyntaxKind.FinallyKeyword:\r\n                    return parseTryStatement();\r\n                case SyntaxKind.DebuggerKeyword:\r\n                    return parseDebuggerStatement();\r\n                case SyntaxKind.AtToken:\r\n                    return parseDeclaration();\r\n                case SyntaxKind.AsyncKeyword:\r\n                case SyntaxKind.InterfaceKeyword:\r\n                case SyntaxKind.TypeKeyword:\r\n                case SyntaxKind.ModuleKeyword:\r\n                case SyntaxKind.NamespaceKeyword:\r\n                case SyntaxKind.DeclareKeyword:\r\n                case SyntaxKind.ConstKeyword:\r\n                case SyntaxKind.EnumKeyword:\r\n                case SyntaxKind.ExportKeyword:\r\n                case SyntaxKind.ImportKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.ProtectedKeyword:\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.AbstractKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                case SyntaxKind.ReadonlyKeyword:\r\n                case SyntaxKind.GlobalKeyword:\r\n                    if (isStartOfDeclaration()) {\r\n                        return parseDeclaration();\r\n                    }\r\n                    break;\r\n            }\r\n            return parseExpressionOrLabeledStatement();\r\n        }\r\n\r\n        function isDeclareModifier(modifier: Modifier) {\r\n            return modifier.kind === SyntaxKind.DeclareKeyword;\r\n        }\r\n\r\n        function parseDeclaration(): Statement {\r\n            const node = <Statement>createNodeWithJSDoc(SyntaxKind.Unknown);\r\n            node.decorators = parseDecorators();\r\n            node.modifiers = parseModifiers();\r\n            if (some(node.modifiers, isDeclareModifier)) {\r\n                for (const m of node.modifiers) {\r\n                    m.flags |= NodeFlags.Ambient;\r\n                }\r\n                return doInsideOfContext(NodeFlags.Ambient, () => parseDeclarationWorker(node));\r\n            }\r\n            else {\r\n                return parseDeclarationWorker(node);\r\n            }\r\n        }\r\n\r\n        function parseDeclarationWorker(node: Statement): Statement {\r\n            switch (token()) {\r\n                case SyntaxKind.VarKeyword:\r\n                case SyntaxKind.LetKeyword:\r\n                case SyntaxKind.ConstKeyword:\r\n                    return parseVariableStatement(<VariableStatement>node);\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionDeclaration(<FunctionDeclaration>node);\r\n                case SyntaxKind.ClassKeyword:\r\n                    return parseClassDeclaration(<ClassDeclaration>node);\r\n                case SyntaxKind.InterfaceKeyword:\r\n                    return parseInterfaceDeclaration(<InterfaceDeclaration>node);\r\n                case SyntaxKind.TypeKeyword:\r\n                    return parseTypeAliasDeclaration(<TypeAliasDeclaration>node);\r\n                case SyntaxKind.EnumKeyword:\r\n                    return parseEnumDeclaration(<EnumDeclaration>node);\r\n                case SyntaxKind.GlobalKeyword:\r\n                case SyntaxKind.ModuleKeyword:\r\n                case SyntaxKind.NamespaceKeyword:\r\n                    return parseModuleDeclaration(<ModuleDeclaration>node);\r\n                case SyntaxKind.ImportKeyword:\r\n                    return parseImportDeclarationOrImportEqualsDeclaration(<ImportDeclaration | ImportEqualsDeclaration>node);\r\n                case SyntaxKind.ExportKeyword:\r\n                    nextToken();\r\n                    switch (token()) {\r\n                        case SyntaxKind.DefaultKeyword:\r\n                        case SyntaxKind.EqualsToken:\r\n                            return parseExportAssignment(<ExportAssignment>node);\r\n                        case SyntaxKind.AsKeyword:\r\n                            return parseNamespaceExportDeclaration(<NamespaceExportDeclaration>node);\r\n                        default:\r\n                            return parseExportDeclaration(<ExportDeclaration>node);\r\n                    }\r\n                default:\r\n                    if (node.decorators || node.modifiers) {\r\n                        // We reached this point because we encountered decorators and/or modifiers and assumed a declaration\r\n                        // would follow. For recovery and error reporting purposes, return an incomplete declaration.\r\n                        const missing = createMissingNode<Statement>(SyntaxKind.MissingDeclaration, /*reportAtCurrentPosition*/ true, Diagnostics.Declaration_expected);\r\n                        missing.pos = node.pos;\r\n                        missing.decorators = node.decorators;\r\n                        missing.modifiers = node.modifiers;\r\n                        return finishNode(missing);\r\n                    }\r\n            }\r\n        }\r\n\r\n        function nextTokenIsIdentifierOrStringLiteralOnSameLine() {\r\n            nextToken();\r\n            return !scanner.hasPrecedingLineBreak() && (isIdentifier() || token() === SyntaxKind.StringLiteral);\r\n        }\r\n\r\n        function parseFunctionBlockOrSemicolon(flags: SignatureFlags, diagnosticMessage?: DiagnosticMessage): Block {\r\n            if (token() !== SyntaxKind.OpenBraceToken && canParseSemicolon()) {\r\n                parseSemicolon();\r\n                return;\r\n            }\r\n\r\n            return parseFunctionBlock(flags, diagnosticMessage);\r\n        }\r\n\r\n        // DECLARATIONS\r\n\r\n        function parseArrayBindingElement(): ArrayBindingElement {\r\n            if (token() === SyntaxKind.CommaToken) {\r\n                return <OmittedExpression>createNode(SyntaxKind.OmittedExpression);\r\n            }\r\n            const node = <BindingElement>createNode(SyntaxKind.BindingElement);\r\n            node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n            node.name = parseIdentifierOrPattern();\r\n            node.initializer = parseInitializer();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectBindingElement(): BindingElement {\r\n            const node = <BindingElement>createNode(SyntaxKind.BindingElement);\r\n            node.dotDotDotToken = parseOptionalToken(SyntaxKind.DotDotDotToken);\r\n            const tokenIsIdentifier = isIdentifier();\r\n            const propertyName = parsePropertyName();\r\n            if (tokenIsIdentifier && token() !== SyntaxKind.ColonToken) {\r\n                node.name = <Identifier>propertyName;\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.ColonToken);\r\n                node.propertyName = propertyName;\r\n                node.name = parseIdentifierOrPattern();\r\n            }\r\n            node.initializer = parseInitializer();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectBindingPattern(): ObjectBindingPattern {\r\n            const node = <ObjectBindingPattern>createNode(SyntaxKind.ObjectBindingPattern);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            node.elements = parseDelimitedList(ParsingContext.ObjectBindingElements, parseObjectBindingElement);\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseArrayBindingPattern(): ArrayBindingPattern {\r\n            const node = <ArrayBindingPattern>createNode(SyntaxKind.ArrayBindingPattern);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n            node.elements = parseDelimitedList(ParsingContext.ArrayBindingElements, parseArrayBindingElement);\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isIdentifierOrPattern() {\r\n            return token() === SyntaxKind.OpenBraceToken || token() === SyntaxKind.OpenBracketToken || isIdentifier();\r\n        }\r\n\r\n        function parseIdentifierOrPattern(): Identifier | BindingPattern {\r\n            if (token() === SyntaxKind.OpenBracketToken) {\r\n                return parseArrayBindingPattern();\r\n            }\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                return parseObjectBindingPattern();\r\n            }\r\n            return parseIdentifier();\r\n        }\r\n\r\n        function parseVariableDeclarationAllowExclamation() {\r\n            return parseVariableDeclaration(/*allowExclamation*/ true);\r\n        }\r\n\r\n        function parseVariableDeclaration(allowExclamation?: boolean): VariableDeclaration {\r\n            const node = <VariableDeclaration>createNode(SyntaxKind.VariableDeclaration);\r\n            node.name = parseIdentifierOrPattern();\r\n            if (allowExclamation && node.name.kind === SyntaxKind.Identifier &&\r\n                token() === SyntaxKind.ExclamationToken && !scanner.hasPrecedingLineBreak()) {\r\n                node.exclamationToken = parseTokenNode();\r\n            }\r\n            node.type = parseTypeAnnotation();\r\n            if (!isInOrOfKeyword(token())) {\r\n                node.initializer = parseInitializer();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseVariableDeclarationList(inForStatementInitializer: boolean): VariableDeclarationList {\r\n            const node = <VariableDeclarationList>createNode(SyntaxKind.VariableDeclarationList);\r\n\r\n            switch (token()) {\r\n                case SyntaxKind.VarKeyword:\r\n                    break;\r\n                case SyntaxKind.LetKeyword:\r\n                    node.flags |= NodeFlags.Let;\r\n                    break;\r\n                case SyntaxKind.ConstKeyword:\r\n                    node.flags |= NodeFlags.Const;\r\n                    break;\r\n                default:\r\n                    Debug.fail();\r\n            }\r\n\r\n            nextToken();\r\n\r\n            // The user may have written the following:\r\n            //\r\n            //    for (let of X) { }\r\n            //\r\n            // In this case, we want to parse an empty declaration list, and then parse 'of'\r\n            // as a keyword. The reason this is not automatic is that 'of' is a valid identifier.\r\n            // So we need to look ahead to determine if 'of' should be treated as a keyword in\r\n            // this context.\r\n            // The checker will then give an error that there is an empty declaration list.\r\n            if (token() === SyntaxKind.OfKeyword && lookAhead(canFollowContextualOfKeyword)) {\r\n                node.declarations = createMissingList<VariableDeclaration>();\r\n            }\r\n            else {\r\n                const savedDisallowIn = inDisallowInContext();\r\n                setDisallowInContext(inForStatementInitializer);\r\n\r\n                node.declarations = parseDelimitedList(ParsingContext.VariableDeclarations,\r\n                    inForStatementInitializer ? parseVariableDeclaration : parseVariableDeclarationAllowExclamation);\r\n\r\n                setDisallowInContext(savedDisallowIn);\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function canFollowContextualOfKeyword(): boolean {\r\n            return nextTokenIsIdentifier() && nextToken() === SyntaxKind.CloseParenToken;\r\n        }\r\n\r\n        function parseVariableStatement(node: VariableStatement): VariableStatement {\r\n            node.kind = SyntaxKind.VariableStatement;\r\n            node.declarationList = parseVariableDeclarationList(/*inForStatementInitializer*/ false);\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionDeclaration(node: FunctionDeclaration): FunctionDeclaration {\r\n            node.kind = SyntaxKind.FunctionDeclaration;\r\n            parseExpected(SyntaxKind.FunctionKeyword);\r\n            node.asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n            node.name = hasModifier(node, ModifierFlags.Default) ? parseOptionalIdentifier() : parseIdentifier();\r\n            const isGenerator = node.asteriskToken ? SignatureFlags.Yield : SignatureFlags.None;\r\n            const isAsync = hasModifier(node, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            fillSignature(SyntaxKind.ColonToken, isGenerator | isAsync, node);\r\n            node.body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, Diagnostics.or_expected);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseConstructorDeclaration(node: ConstructorDeclaration): ConstructorDeclaration {\r\n            node.kind = SyntaxKind.Constructor;\r\n            parseExpected(SyntaxKind.ConstructorKeyword);\r\n            fillSignature(SyntaxKind.ColonToken, SignatureFlags.None, node);\r\n            node.body = parseFunctionBlockOrSemicolon(SignatureFlags.None, Diagnostics.or_expected);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseMethodDeclaration(node: MethodDeclaration, asteriskToken: AsteriskToken, diagnosticMessage?: DiagnosticMessage): MethodDeclaration {\r\n            node.kind = SyntaxKind.MethodDeclaration;\r\n            node.asteriskToken = asteriskToken;\r\n            const isGenerator = asteriskToken ? SignatureFlags.Yield : SignatureFlags.None;\r\n            const isAsync = hasModifier(node, ModifierFlags.Async) ? SignatureFlags.Await : SignatureFlags.None;\r\n            fillSignature(SyntaxKind.ColonToken, isGenerator | isAsync, node);\r\n            node.body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, diagnosticMessage);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parsePropertyDeclaration(node: PropertyDeclaration): PropertyDeclaration {\r\n            node.kind = SyntaxKind.PropertyDeclaration;\r\n            if (!node.questionToken && token() === SyntaxKind.ExclamationToken && !scanner.hasPrecedingLineBreak()) {\r\n                node.exclamationToken = parseTokenNode();\r\n            }\r\n            node.type = parseTypeAnnotation();\r\n\r\n            // For instance properties specifically, since they are evaluated inside the constructor,\r\n            // we do *not * want to parse yield expressions, so we specifically turn the yield context\r\n            // off. The grammar would look something like this:\r\n            //\r\n            //    MemberVariableDeclaration[Yield]:\r\n            //        AccessibilityModifier_opt PropertyName TypeAnnotation_opt Initializer_opt[In];\r\n            //        AccessibilityModifier_opt static_opt PropertyName TypeAnnotation_opt Initializer_opt[In, ?Yield];\r\n            //\r\n            // The checker may still error in the static case to explicitly disallow the yield expression.\r\n            node.initializer = hasModifier(node, ModifierFlags.Static)\r\n                ? allowInAnd(parseInitializer)\r\n                : doOutsideOfContext(NodeFlags.YieldContext | NodeFlags.DisallowInContext, parseInitializer);\r\n\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parsePropertyOrMethodDeclaration(node: PropertyDeclaration | MethodDeclaration): PropertyDeclaration | MethodDeclaration {\r\n            const asteriskToken = parseOptionalToken(SyntaxKind.AsteriskToken);\r\n            node.name = parsePropertyName();\r\n            // Note: this is not legal as per the grammar.  But we allow it in the parser and\r\n            // report an error in the grammar checker.\r\n            node.questionToken = parseOptionalToken(SyntaxKind.QuestionToken);\r\n            if (asteriskToken || token() === SyntaxKind.OpenParenToken || token() === SyntaxKind.LessThanToken) {\r\n                return parseMethodDeclaration(<MethodDeclaration>node, asteriskToken, Diagnostics.or_expected);\r\n            }\r\n            return parsePropertyDeclaration(<PropertyDeclaration>node);\r\n        }\r\n\r\n        function parseAccessorDeclaration(node: AccessorDeclaration, kind: AccessorDeclaration[\"kind\"]): AccessorDeclaration {\r\n            node.kind = kind;\r\n            node.name = parsePropertyName();\r\n            fillSignature(SyntaxKind.ColonToken, SignatureFlags.None, node);\r\n            node.body = parseFunctionBlockOrSemicolon(SignatureFlags.None);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isClassMemberStart(): boolean {\r\n            let idToken: SyntaxKind;\r\n\r\n            if (token() === SyntaxKind.AtToken) {\r\n                return true;\r\n            }\r\n\r\n            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier.\r\n            while (isModifierKind(token())) {\r\n                idToken = token();\r\n                // If the idToken is a class modifier (protected, private, public, and static), it is\r\n                // certain that we are starting to parse class member. This allows better error recovery\r\n                // Example:\r\n                //      public foo() ...     // true\r\n                //      public @dec blah ... // true; we will then report an error later\r\n                //      export public ...    // true; we will then report an error later\r\n                if (isClassMemberModifier(idToken)) {\r\n                    return true;\r\n                }\r\n\r\n                nextToken();\r\n            }\r\n\r\n            if (token() === SyntaxKind.AsteriskToken) {\r\n                return true;\r\n            }\r\n\r\n            // Try to get the first property-like token following all modifiers.\r\n            // This can either be an identifier or the 'get' or 'set' keywords.\r\n            if (isLiteralPropertyName()) {\r\n                idToken = token();\r\n                nextToken();\r\n            }\r\n\r\n            // Index signatures and computed properties are class members; we can parse.\r\n            if (token() === SyntaxKind.OpenBracketToken) {\r\n                return true;\r\n            }\r\n\r\n            // If we were able to get any potential identifier...\r\n            if (idToken !== undefined) {\r\n                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.\r\n                if (!isKeyword(idToken) || idToken === SyntaxKind.SetKeyword || idToken === SyntaxKind.GetKeyword) {\r\n                    return true;\r\n                }\r\n\r\n                // If it *is* a keyword, but not an accessor, check a little farther along\r\n                // to see if it should actually be parsed as a class member.\r\n                switch (token()) {\r\n                    case SyntaxKind.OpenParenToken:     // Method declaration\r\n                    case SyntaxKind.LessThanToken:      // Generic Method declaration\r\n                    case SyntaxKind.ExclamationToken:   // Non-null assertion on property name\r\n                    case SyntaxKind.ColonToken:         // Type Annotation for declaration\r\n                    case SyntaxKind.EqualsToken:        // Initializer for declaration\r\n                    case SyntaxKind.QuestionToken:      // Not valid, but permitted so that it gets caught later on.\r\n                        return true;\r\n                    default:\r\n                        // Covers\r\n                        //  - Semicolons     (declaration termination)\r\n                        //  - Closing braces (end-of-class, must be declaration)\r\n                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)\r\n                        //  - Line-breaks    (enabling *automatic semicolon insertion*)\r\n                        return canParseSemicolon();\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function parseDecorators(): NodeArray<Decorator> | undefined {\r\n            let list: Decorator[] | undefined;\r\n            const listPos = getNodePos();\r\n            while (true) {\r\n                const decoratorStart = getNodePos();\r\n                if (!parseOptional(SyntaxKind.AtToken)) {\r\n                    break;\r\n                }\r\n                const decorator = <Decorator>createNode(SyntaxKind.Decorator, decoratorStart);\r\n                decorator.expression = doInDecoratorContext(parseLeftHandSideExpressionOrHigher);\r\n                finishNode(decorator);\r\n                (list || (list = [])).push(decorator);\r\n            }\r\n            return list && createNodeArray(list, listPos);\r\n        }\r\n\r\n        /*\r\n         * There are situations in which a modifier like 'const' will appear unexpectedly, such as on a class member.\r\n         * In those situations, if we are entirely sure that 'const' is not valid on its own (such as when ASI takes effect\r\n         * and turns it into a standalone declaration), then it is better to parse it and report an error later.\r\n         *\r\n         * In such situations, 'permitInvalidConstAsModifier' should be set to true.\r\n         */\r\n        function parseModifiers(permitInvalidConstAsModifier?: boolean): NodeArray<Modifier> | undefined {\r\n            let list: Modifier[];\r\n            const listPos = getNodePos();\r\n            while (true) {\r\n                const modifierStart = scanner.getStartPos();\r\n                const modifierKind = token();\r\n\r\n                if (token() === SyntaxKind.ConstKeyword && permitInvalidConstAsModifier) {\r\n                    // We need to ensure that any subsequent modifiers appear on the same line\r\n                    // so that when 'const' is a standalone declaration, we don't issue an error.\r\n                    if (!tryParse(nextTokenIsOnSameLineAndCanFollowModifier)) {\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (!parseAnyContextualModifier()) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                const modifier = finishNode(<Modifier>createNode(modifierKind, modifierStart));\r\n                (list || (list = [])).push(modifier);\r\n            }\r\n            return list && createNodeArray(list, listPos);\r\n        }\r\n\r\n        function parseModifiersForArrowFunction(): NodeArray<Modifier> {\r\n            let modifiers: NodeArray<Modifier>;\r\n            if (token() === SyntaxKind.AsyncKeyword) {\r\n                const modifierStart = scanner.getStartPos();\r\n                const modifierKind = token();\r\n                nextToken();\r\n                const modifier = finishNode(<Modifier>createNode(modifierKind, modifierStart));\r\n                modifiers = createNodeArray<Modifier>([modifier], modifierStart);\r\n            }\r\n            return modifiers;\r\n        }\r\n\r\n        function parseClassElement(): ClassElement {\r\n            if (token() === SyntaxKind.SemicolonToken) {\r\n                const result = <SemicolonClassElement>createNode(SyntaxKind.SemicolonClassElement);\r\n                nextToken();\r\n                return finishNode(result);\r\n            }\r\n\r\n            const node = <ClassElement>createNodeWithJSDoc(SyntaxKind.Unknown);\r\n            node.decorators = parseDecorators();\r\n            node.modifiers = parseModifiers(/*permitInvalidConstAsModifier*/ true);\r\n\r\n            if (parseContextualModifier(SyntaxKind.GetKeyword)) {\r\n                return parseAccessorDeclaration(<AccessorDeclaration>node, SyntaxKind.GetAccessor);\r\n            }\r\n\r\n            if (parseContextualModifier(SyntaxKind.SetKeyword)) {\r\n                return parseAccessorDeclaration(<AccessorDeclaration>node, SyntaxKind.SetAccessor);\r\n            }\r\n\r\n            if (token() === SyntaxKind.ConstructorKeyword) {\r\n                return parseConstructorDeclaration(<ConstructorDeclaration>node);\r\n            }\r\n\r\n            if (isIndexSignature()) {\r\n                return parseIndexSignatureDeclaration(<IndexSignatureDeclaration>node);\r\n            }\r\n\r\n            // It is very important that we check this *after* checking indexers because\r\n            // the [ token can start an index signature or a computed property name\r\n            if (tokenIsIdentifierOrKeyword(token()) ||\r\n                token() === SyntaxKind.StringLiteral ||\r\n                token() === SyntaxKind.NumericLiteral ||\r\n                token() === SyntaxKind.AsteriskToken ||\r\n                token() === SyntaxKind.OpenBracketToken) {\r\n\r\n                return parsePropertyOrMethodDeclaration(<PropertyDeclaration | MethodDeclaration>node);\r\n            }\r\n\r\n            if (node.decorators || node.modifiers) {\r\n                // treat this as a property declaration with a missing name.\r\n                node.name = createMissingNode<Identifier>(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics.Declaration_expected);\r\n                return parsePropertyDeclaration(<PropertyDeclaration>node);\r\n            }\r\n\r\n            // 'isClassMemberStart' should have hinted not to attempt parsing.\r\n            Debug.fail(\"Should not have attempted to parse class member declaration.\");\r\n        }\r\n\r\n        function parseClassExpression(): ClassExpression {\r\n            return <ClassExpression>parseClassDeclarationOrExpression(<ClassLikeDeclaration>createNodeWithJSDoc(SyntaxKind.Unknown), SyntaxKind.ClassExpression);\r\n        }\r\n\r\n        function parseClassDeclaration(node: ClassLikeDeclaration): ClassDeclaration {\r\n            return <ClassDeclaration>parseClassDeclarationOrExpression(node, SyntaxKind.ClassDeclaration);\r\n        }\r\n\r\n        function parseClassDeclarationOrExpression(node: ClassLikeDeclaration, kind: ClassLikeDeclaration[\"kind\"]): ClassLikeDeclaration {\r\n            node.kind = kind;\r\n            parseExpected(SyntaxKind.ClassKeyword);\r\n            node.name = parseNameOfClassDeclarationOrExpression();\r\n            node.typeParameters = parseTypeParameters();\r\n            node.heritageClauses = parseHeritageClauses();\r\n\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                // ClassTail[Yield,Await] : (Modified) See 14.5\r\n                //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }\r\n                node.members = parseClassMembers();\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.members = createMissingList<ClassElement>();\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseNameOfClassDeclarationOrExpression(): Identifier | undefined {\r\n            // implements is a future reserved word so\r\n            // 'class implements' might mean either\r\n            // - class expression with omitted name, 'implements' starts heritage clause\r\n            // - class with name 'implements'\r\n            // 'isImplementsClause' helps to disambiguate between these two cases\r\n            return isIdentifier() && !isImplementsClause()\r\n                ? parseIdentifier()\r\n                : undefined;\r\n        }\r\n\r\n        function isImplementsClause() {\r\n            return token() === SyntaxKind.ImplementsKeyword && lookAhead(nextTokenIsIdentifierOrKeyword);\r\n        }\r\n\r\n        function parseHeritageClauses(): NodeArray<HeritageClause> | undefined {\r\n            // ClassTail[Yield,Await] : (Modified) See 14.5\r\n            //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }\r\n\r\n            if (isHeritageClause()) {\r\n                return parseList(ParsingContext.HeritageClauses, parseHeritageClause);\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function parseHeritageClause(): HeritageClause | undefined {\r\n            const tok = token();\r\n            if (tok === SyntaxKind.ExtendsKeyword || tok === SyntaxKind.ImplementsKeyword) {\r\n                const node = <HeritageClause>createNode(SyntaxKind.HeritageClause);\r\n                node.token = tok;\r\n                nextToken();\r\n                node.types = parseDelimitedList(ParsingContext.HeritageClauseElement, parseExpressionWithTypeArguments);\r\n                return finishNode(node);\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function parseExpressionWithTypeArguments(): ExpressionWithTypeArguments {\r\n            const node = <ExpressionWithTypeArguments>createNode(SyntaxKind.ExpressionWithTypeArguments);\r\n            node.expression = parseLeftHandSideExpressionOrHigher();\r\n            node.typeArguments = tryParseTypeArguments();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function tryParseTypeArguments(): NodeArray<TypeNode> | undefined {\r\n            return token() === SyntaxKind.LessThanToken\r\n               ? parseBracketedList(ParsingContext.TypeArguments, parseType, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken)\r\n               : undefined;\r\n        }\r\n\r\n        function isHeritageClause(): boolean {\r\n            return token() === SyntaxKind.ExtendsKeyword || token() === SyntaxKind.ImplementsKeyword;\r\n        }\r\n\r\n        function parseClassMembers(): NodeArray<ClassElement> {\r\n            return parseList(ParsingContext.ClassMembers, parseClassElement);\r\n        }\r\n\r\n        function parseInterfaceDeclaration(node: InterfaceDeclaration): InterfaceDeclaration {\r\n            node.kind = SyntaxKind.InterfaceDeclaration;\r\n            parseExpected(SyntaxKind.InterfaceKeyword);\r\n            node.name = parseIdentifier();\r\n            node.typeParameters = parseTypeParameters();\r\n            node.heritageClauses = parseHeritageClauses();\r\n            node.members = parseObjectTypeMembers();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeAliasDeclaration(node: TypeAliasDeclaration): TypeAliasDeclaration {\r\n            node.kind = SyntaxKind.TypeAliasDeclaration;\r\n            parseExpected(SyntaxKind.TypeKeyword);\r\n            node.name = parseIdentifier();\r\n            node.typeParameters = parseTypeParameters();\r\n            parseExpected(SyntaxKind.EqualsToken);\r\n            node.type = parseType();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        // In an ambient declaration, the grammar only allows integer literals as initializers.\r\n        // In a non-ambient declaration, the grammar allows uninitialized members only in a\r\n        // ConstantEnumMemberSection, which starts at the beginning of an enum declaration\r\n        // or any time an integer literal initializer is encountered.\r\n        function parseEnumMember(): EnumMember {\r\n            const node = <EnumMember>createNodeWithJSDoc(SyntaxKind.EnumMember);\r\n            node.name = parsePropertyName();\r\n            node.initializer = allowInAnd(parseInitializer);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseEnumDeclaration(node: EnumDeclaration): EnumDeclaration {\r\n            node.kind = SyntaxKind.EnumDeclaration;\r\n            parseExpected(SyntaxKind.EnumKeyword);\r\n            node.name = parseIdentifier();\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.members = parseDelimitedList(ParsingContext.EnumMembers, parseEnumMember);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.members = createMissingList<EnumMember>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleBlock(): ModuleBlock {\r\n            const node = <ModuleBlock>createNode(SyntaxKind.ModuleBlock);\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.statements = parseList(ParsingContext.BlockStatements, parseStatement);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.statements = createMissingList<Statement>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleOrNamespaceDeclaration(node: ModuleDeclaration, flags: NodeFlags): ModuleDeclaration {\r\n            node.kind = SyntaxKind.ModuleDeclaration;\r\n            // If we are parsing a dotted namespace name, we want to\r\n            // propagate the 'Namespace' flag across the names if set.\r\n            const namespaceFlag = flags & NodeFlags.Namespace;\r\n            node.flags |= flags;\r\n            node.name = parseIdentifier();\r\n            node.body = parseOptional(SyntaxKind.DotToken)\r\n                ? <NamespaceDeclaration>parseModuleOrNamespaceDeclaration(<ModuleDeclaration>createNode(SyntaxKind.Unknown), NodeFlags.NestedNamespace | namespaceFlag)\r\n                : parseModuleBlock();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseAmbientExternalModuleDeclaration(node: ModuleDeclaration): ModuleDeclaration {\r\n            node.kind = SyntaxKind.ModuleDeclaration;\r\n            if (token() === SyntaxKind.GlobalKeyword) {\r\n                // parse 'global' as name of global scope augmentation\r\n                node.name = parseIdentifier();\r\n                node.flags |= NodeFlags.GlobalAugmentation;\r\n            }\r\n            else {\r\n                node.name = <StringLiteral>parseLiteralNode();\r\n                node.name.text = internIdentifier(node.name.text);\r\n            }\r\n            if (token() === SyntaxKind.OpenBraceToken) {\r\n                node.body = parseModuleBlock();\r\n            }\r\n            else {\r\n                parseSemicolon();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleDeclaration(node: ModuleDeclaration): ModuleDeclaration {\r\n            let flags: NodeFlags = 0;\r\n            if (token() === SyntaxKind.GlobalKeyword) {\r\n                // global augmentation\r\n                return parseAmbientExternalModuleDeclaration(node);\r\n            }\r\n            else if (parseOptional(SyntaxKind.NamespaceKeyword)) {\r\n                flags |= NodeFlags.Namespace;\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.ModuleKeyword);\r\n                if (token() === SyntaxKind.StringLiteral) {\r\n                    return parseAmbientExternalModuleDeclaration(node);\r\n                }\r\n            }\r\n            return parseModuleOrNamespaceDeclaration(node, flags);\r\n        }\r\n\r\n        function isExternalModuleReference() {\r\n            return token() === SyntaxKind.RequireKeyword &&\r\n                lookAhead(nextTokenIsOpenParen);\r\n        }\r\n\r\n        function nextTokenIsOpenParen() {\r\n            return nextToken() === SyntaxKind.OpenParenToken;\r\n        }\r\n\r\n        function nextTokenIsSlash() {\r\n            return nextToken() === SyntaxKind.SlashToken;\r\n        }\r\n\r\n        function parseNamespaceExportDeclaration(node: NamespaceExportDeclaration): NamespaceExportDeclaration {\r\n            node.kind = SyntaxKind.NamespaceExportDeclaration;\r\n            parseExpected(SyntaxKind.AsKeyword);\r\n            parseExpected(SyntaxKind.NamespaceKeyword);\r\n            node.name = parseIdentifier();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseImportDeclarationOrImportEqualsDeclaration(node: ImportEqualsDeclaration | ImportDeclaration): ImportEqualsDeclaration | ImportDeclaration {\r\n            parseExpected(SyntaxKind.ImportKeyword);\r\n            const afterImportPos = scanner.getStartPos();\r\n\r\n            let identifier: Identifier;\r\n            if (isIdentifier()) {\r\n                identifier = parseIdentifier();\r\n                if (token() !== SyntaxKind.CommaToken && token() !== SyntaxKind.FromKeyword) {\r\n                    return parseImportEqualsDeclaration(<ImportEqualsDeclaration>node, identifier);\r\n                }\r\n            }\r\n\r\n            // Import statement\r\n            node.kind = SyntaxKind.ImportDeclaration;\r\n            // ImportDeclaration:\r\n            //  import ImportClause from ModuleSpecifier ;\r\n            //  import ModuleSpecifier;\r\n            if (identifier || // import id\r\n                token() === SyntaxKind.AsteriskToken || // import *\r\n                token() === SyntaxKind.OpenBraceToken) { // import {\r\n                (<ImportDeclaration>node).importClause = parseImportClause(identifier, afterImportPos);\r\n                parseExpected(SyntaxKind.FromKeyword);\r\n            }\r\n\r\n            (<ImportDeclaration>node).moduleSpecifier = parseModuleSpecifier();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseImportEqualsDeclaration(node: ImportEqualsDeclaration, identifier: Identifier): ImportEqualsDeclaration {\r\n            node.kind = SyntaxKind.ImportEqualsDeclaration;\r\n            node.name = identifier;\r\n            parseExpected(SyntaxKind.EqualsToken);\r\n            node.moduleReference = parseModuleReference();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseImportClause(identifier: Identifier, fullStart: number) {\r\n            // ImportClause:\r\n            //  ImportedDefaultBinding\r\n            //  NameSpaceImport\r\n            //  NamedImports\r\n            //  ImportedDefaultBinding, NameSpaceImport\r\n            //  ImportedDefaultBinding, NamedImports\r\n\r\n            const importClause = <ImportClause>createNode(SyntaxKind.ImportClause, fullStart);\r\n            if (identifier) {\r\n                // ImportedDefaultBinding:\r\n                //  ImportedBinding\r\n                importClause.name = identifier;\r\n            }\r\n\r\n            // If there was no default import or if there is comma token after default import\r\n            // parse namespace or named imports\r\n            if (!importClause.name ||\r\n                parseOptional(SyntaxKind.CommaToken)) {\r\n                importClause.namedBindings = token() === SyntaxKind.AsteriskToken ? parseNamespaceImport() : parseNamedImportsOrExports(SyntaxKind.NamedImports);\r\n            }\r\n\r\n            return finishNode(importClause);\r\n        }\r\n\r\n        function parseModuleReference() {\r\n            return isExternalModuleReference()\r\n                ? parseExternalModuleReference()\r\n                : parseEntityName(/*allowReservedWords*/ false);\r\n        }\r\n\r\n        function parseExternalModuleReference() {\r\n            const node = <ExternalModuleReference>createNode(SyntaxKind.ExternalModuleReference);\r\n            parseExpected(SyntaxKind.RequireKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseModuleSpecifier();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleSpecifier(): Expression {\r\n            if (token() === SyntaxKind.StringLiteral) {\r\n                const result = parseLiteralNode();\r\n                result.text = internIdentifier(result.text);\r\n                return result;\r\n            }\r\n            else {\r\n                // We allow arbitrary expressions here, even though the grammar only allows string\r\n                // literals.  We check to ensure that it is only a string literal later in the grammar\r\n                // check pass.\r\n                return parseExpression();\r\n            }\r\n        }\r\n\r\n        function parseNamespaceImport(): NamespaceImport {\r\n            // NameSpaceImport:\r\n            //  * as ImportedBinding\r\n            const namespaceImport = <NamespaceImport>createNode(SyntaxKind.NamespaceImport);\r\n            parseExpected(SyntaxKind.AsteriskToken);\r\n            parseExpected(SyntaxKind.AsKeyword);\r\n            namespaceImport.name = parseIdentifier();\r\n            return finishNode(namespaceImport);\r\n        }\r\n\r\n        function parseNamedImportsOrExports(kind: SyntaxKind.NamedImports): NamedImports;\r\n        function parseNamedImportsOrExports(kind: SyntaxKind.NamedExports): NamedExports;\r\n        function parseNamedImportsOrExports(kind: SyntaxKind): NamedImportsOrExports {\r\n            const node = <NamedImports | NamedExports>createNode(kind);\r\n\r\n            // NamedImports:\r\n            //  { }\r\n            //  { ImportsList }\r\n            //  { ImportsList, }\r\n\r\n            // ImportsList:\r\n            //  ImportSpecifier\r\n            //  ImportsList, ImportSpecifier\r\n            node.elements = <NodeArray<ImportSpecifier> | NodeArray<ExportSpecifier>>parseBracketedList(ParsingContext.ImportOrExportSpecifiers,\r\n                kind === SyntaxKind.NamedImports ? parseImportSpecifier : parseExportSpecifier,\r\n                SyntaxKind.OpenBraceToken, SyntaxKind.CloseBraceToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExportSpecifier() {\r\n            return parseImportOrExportSpecifier(SyntaxKind.ExportSpecifier);\r\n        }\r\n\r\n        function parseImportSpecifier() {\r\n            return parseImportOrExportSpecifier(SyntaxKind.ImportSpecifier);\r\n        }\r\n\r\n        function parseImportOrExportSpecifier(kind: SyntaxKind): ImportOrExportSpecifier {\r\n            const node = <ImportSpecifier>createNode(kind);\r\n            // ImportSpecifier:\r\n            //   BindingIdentifier\r\n            //   IdentifierName as BindingIdentifier\r\n            // ExportSpecifier:\r\n            //   IdentifierName\r\n            //   IdentifierName as IdentifierName\r\n            let checkIdentifierIsKeyword = isKeyword(token()) && !isIdentifier();\r\n            let checkIdentifierStart = scanner.getTokenPos();\r\n            let checkIdentifierEnd = scanner.getTextPos();\r\n            const identifierName = parseIdentifierName();\r\n            if (token() === SyntaxKind.AsKeyword) {\r\n                node.propertyName = identifierName;\r\n                parseExpected(SyntaxKind.AsKeyword);\r\n                checkIdentifierIsKeyword = isKeyword(token()) && !isIdentifier();\r\n                checkIdentifierStart = scanner.getTokenPos();\r\n                checkIdentifierEnd = scanner.getTextPos();\r\n                node.name = parseIdentifierName();\r\n            }\r\n            else {\r\n                node.name = identifierName;\r\n            }\r\n            if (kind === SyntaxKind.ImportSpecifier && checkIdentifierIsKeyword) {\r\n                parseErrorAt(checkIdentifierStart, checkIdentifierEnd, Diagnostics.Identifier_expected);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExportDeclaration(node: ExportDeclaration): ExportDeclaration {\r\n            node.kind = SyntaxKind.ExportDeclaration;\r\n            if (parseOptional(SyntaxKind.AsteriskToken)) {\r\n                parseExpected(SyntaxKind.FromKeyword);\r\n                node.moduleSpecifier = parseModuleSpecifier();\r\n            }\r\n            else {\r\n                node.exportClause = parseNamedImportsOrExports(SyntaxKind.NamedExports);\r\n                // It is not uncommon to accidentally omit the 'from' keyword. Additionally, in editing scenarios,\r\n                // the 'from' keyword can be parsed as a named export when the export clause is unterminated (i.e. `export { from \"moduleName\";`)\r\n                // If we don't have a 'from' keyword, see if we have a string literal such that ASI won't take effect.\r\n                if (token() === SyntaxKind.FromKeyword || (token() === SyntaxKind.StringLiteral && !scanner.hasPrecedingLineBreak())) {\r\n                    parseExpected(SyntaxKind.FromKeyword);\r\n                    node.moduleSpecifier = parseModuleSpecifier();\r\n                }\r\n            }\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExportAssignment(node: ExportAssignment): ExportAssignment {\r\n            node.kind = SyntaxKind.ExportAssignment;\r\n            if (parseOptional(SyntaxKind.EqualsToken)) {\r\n                node.isExportEquals = true;\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.DefaultKeyword);\r\n            }\r\n            node.expression = parseAssignmentExpressionOrHigher();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function setExternalModuleIndicator(sourceFile: SourceFile) {\r\n            // Try to use the first top-level import/export when available, then\r\n            // fall back to looking for an 'import.meta' somewhere in the tree if necessary.\r\n            sourceFile.externalModuleIndicator =\r\n                    forEach(sourceFile.statements, isAnExternalModuleIndicatorNode) ||\r\n                    getImportMetaIfNecessary(sourceFile);\r\n        }\r\n\r\n        function isAnExternalModuleIndicatorNode(node: Node) {\r\n            return hasModifier(node, ModifierFlags.Export)\r\n                || node.kind === SyntaxKind.ImportEqualsDeclaration && (<ImportEqualsDeclaration>node).moduleReference.kind === SyntaxKind.ExternalModuleReference\r\n                || node.kind === SyntaxKind.ImportDeclaration\r\n                || node.kind === SyntaxKind.ExportAssignment\r\n                || node.kind === SyntaxKind.ExportDeclaration\r\n                    ? node\r\n                    : undefined;\r\n        }\r\n\r\n        function getImportMetaIfNecessary(sourceFile: SourceFile) {\r\n            return sourceFile.flags & NodeFlags.PossiblyContainsImportMeta ?\r\n                walkTreeForExternalModuleIndicators(sourceFile) :\r\n                undefined;\r\n        }\r\n\r\n        function walkTreeForExternalModuleIndicators(node: Node): Node {\r\n            return isImportMeta(node) ? node : forEachChild(node, walkTreeForExternalModuleIndicators);\r\n        }\r\n\r\n        function isImportMeta(node: Node): boolean {\r\n            return isMetaProperty(node) && node.keywordToken === SyntaxKind.ImportKeyword && node.name.escapedText === \"meta\";\r\n        }\r\n\r\n        const enum ParsingContext {\r\n            SourceElements,            // Elements in source file\r\n            BlockStatements,           // Statements in block\r\n            SwitchClauses,             // Clauses in switch statement\r\n            SwitchClauseStatements,    // Statements in switch clause\r\n            TypeMembers,               // Members in interface or type literal\r\n            ClassMembers,              // Members in class declaration\r\n            EnumMembers,               // Members in enum declaration\r\n            HeritageClauseElement,     // Elements in a heritage clause\r\n            VariableDeclarations,      // Variable declarations in variable statement\r\n            ObjectBindingElements,     // Binding elements in object binding list\r\n            ArrayBindingElements,      // Binding elements in array binding list\r\n            ArgumentExpressions,       // Expressions in argument list\r\n            ObjectLiteralMembers,      // Members in object literal\r\n            JsxAttributes,             // Attributes in jsx element\r\n            JsxChildren,               // Things between opening and closing JSX tags\r\n            ArrayLiteralMembers,       // Members in array literal\r\n            Parameters,                // Parameters in parameter list\r\n            RestProperties,            // Property names in a rest type list\r\n            TypeParameters,            // Type parameters in type parameter list\r\n            TypeArguments,             // Type arguments in type argument list\r\n            TupleElementTypes,         // Element types in tuple element type list\r\n            HeritageClauses,           // Heritage clauses for a class or interface declaration.\r\n            ImportOrExportSpecifiers,  // Named import clause's import specifier list\r\n            Count                      // Number of parsing contexts\r\n        }\r\n\r\n        const enum Tristate {\r\n            False,\r\n            True,\r\n            Unknown\r\n        }\r\n\r\n        export namespace JSDocParser {\r\n            export function parseJSDocTypeExpressionForTests(content: string, start: number, length: number): { jsDocTypeExpression: JSDocTypeExpression, diagnostics: Diagnostic[] } | undefined {\r\n                initializeState(content, ScriptTarget.Latest, /*_syntaxCursor:*/ undefined, ScriptKind.JS);\r\n                sourceFile = createSourceFile(\"file.js\", ScriptTarget.Latest, ScriptKind.JS, /*isDeclarationFile*/ false);\r\n                scanner.setText(content, start, length);\r\n                currentToken = scanner.scan();\r\n                const jsDocTypeExpression = parseJSDocTypeExpression();\r\n                const diagnostics = parseDiagnostics;\r\n                clearState();\r\n\r\n                return jsDocTypeExpression ? { jsDocTypeExpression, diagnostics } : undefined;\r\n            }\r\n\r\n            // Parses out a JSDoc type expression.\r\n            export function parseJSDocTypeExpression(mayOmitBraces?: boolean): JSDocTypeExpression {\r\n                const result = <JSDocTypeExpression>createNode(SyntaxKind.JSDocTypeExpression, scanner.getTokenPos());\r\n\r\n                const hasBrace = (mayOmitBraces ? parseOptional : parseExpected)(SyntaxKind.OpenBraceToken);\r\n                result.type = doInsideOfContext(NodeFlags.JSDoc, parseJSDocType);\r\n                if (!mayOmitBraces || hasBrace) {\r\n                    parseExpected(SyntaxKind.CloseBraceToken);\r\n                }\r\n\r\n                fixupParentReferences(result);\r\n                return finishNode(result);\r\n            }\r\n\r\n            export function parseIsolatedJSDocComment(content: string, start: number, length: number): { jsDoc: JSDoc, diagnostics: Diagnostic[] } | undefined {\r\n                initializeState(content, ScriptTarget.Latest, /*_syntaxCursor:*/ undefined, ScriptKind.JS);\r\n                sourceFile = <SourceFile>{ languageVariant: LanguageVariant.Standard, text: content }; // tslint:disable-line no-object-literal-type-assertion\r\n                const jsDoc = parseJSDocCommentWorker(start, length);\r\n                const diagnostics = parseDiagnostics;\r\n                clearState();\r\n\r\n                return jsDoc ? { jsDoc, diagnostics } : undefined;\r\n            }\r\n\r\n            export function parseJSDocComment(parent: HasJSDoc, start: number, length: number): JSDoc {\r\n                const saveToken = currentToken;\r\n                const saveParseDiagnosticsLength = parseDiagnostics.length;\r\n                const saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;\r\n\r\n                const comment = parseJSDocCommentWorker(start, length);\r\n                if (comment) {\r\n                    comment.parent = parent;\r\n                }\r\n\r\n                if (contextFlags & NodeFlags.JavaScriptFile) {\r\n                    if (!sourceFile.jsDocDiagnostics) {\r\n                        sourceFile.jsDocDiagnostics = [];\r\n                    }\r\n                    sourceFile.jsDocDiagnostics.push(...parseDiagnostics);\r\n                }\r\n                currentToken = saveToken;\r\n                parseDiagnostics.length = saveParseDiagnosticsLength;\r\n                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;\r\n\r\n                return comment;\r\n            }\r\n\r\n            const enum JSDocState {\r\n                BeginningOfLine,\r\n                SawAsterisk,\r\n                SavingComments,\r\n            }\r\n\r\n            const enum PropertyLikeParse {\r\n                Property,\r\n                Parameter,\r\n            }\r\n\r\n            export function parseJSDocCommentWorker(start: number, length: number): JSDoc {\r\n                const content = sourceText;\r\n                start = start || 0;\r\n                const end = length === undefined ? content.length : start + length;\r\n                length = end - start;\r\n\r\n                Debug.assert(start >= 0);\r\n                Debug.assert(start <= end);\r\n                Debug.assert(end <= content.length);\r\n\r\n                let tags: JSDocTag[];\r\n                let tagsPos: number;\r\n                let tagsEnd: number;\r\n                const comments: string[] = [];\r\n                let result: JSDoc;\r\n\r\n                // Check for /** (JSDoc opening part)\r\n                if (!isJSDocLikeText(content, start)) {\r\n                    return result;\r\n                }\r\n\r\n                // + 3 for leading /**, - 5 in total for /** */\r\n                scanner.scanRange(start + 3, length - 5, () => {\r\n                    // Initially we can parse out a tag.  We also have seen a starting asterisk.\r\n                    // This is so that /** * @type */ doesn't parse.\r\n                    let state = JSDocState.SawAsterisk;\r\n                    let margin: number | undefined;\r\n                    // + 4 for leading '/** '\r\n                    let indent = start - Math.max(content.lastIndexOf(\"\\n\", start), 0) + 4;\r\n                    function pushComment(text: string) {\r\n                        if (!margin) {\r\n                            margin = indent;\r\n                        }\r\n                        comments.push(text);\r\n                        indent += text.length;\r\n                    }\r\n\r\n                    let t = nextJSDocToken();\r\n                    while (t === SyntaxKind.WhitespaceTrivia) {\r\n                        t = nextJSDocToken();\r\n                    }\r\n                    if (t === SyntaxKind.NewLineTrivia) {\r\n                        state = JSDocState.BeginningOfLine;\r\n                        indent = 0;\r\n                        t = nextJSDocToken();\r\n                    }\r\n                    loop: while (true) {\r\n                        switch (t) {\r\n                            case SyntaxKind.AtToken:\r\n                                if (state === JSDocState.BeginningOfLine || state === JSDocState.SawAsterisk) {\r\n                                    removeTrailingNewlines(comments);\r\n                                    parseTag(indent);\r\n                                    // NOTE: According to usejsdoc.org, a tag goes to end of line, except the last tag.\r\n                                    // Real-world comments may break this rule, so \"BeginningOfLine\" will not be a real line beginning\r\n                                    // for malformed examples like `/** @param {string} x @returns {number} the length */`\r\n                                    state = JSDocState.BeginningOfLine;\r\n                                    margin = undefined;\r\n                                    indent++;\r\n                                }\r\n                                else {\r\n                                    pushComment(scanner.getTokenText());\r\n                                }\r\n                                break;\r\n                            case SyntaxKind.NewLineTrivia:\r\n                                comments.push(scanner.getTokenText());\r\n                                state = JSDocState.BeginningOfLine;\r\n                                indent = 0;\r\n                                break;\r\n                            case SyntaxKind.AsteriskToken:\r\n                                const asterisk = scanner.getTokenText();\r\n                                if (state === JSDocState.SawAsterisk || state === JSDocState.SavingComments) {\r\n                                    // If we've already seen an asterisk, then we can no longer parse a tag on this line\r\n                                    state = JSDocState.SavingComments;\r\n                                    pushComment(asterisk);\r\n                                }\r\n                                else {\r\n                                    // Ignore the first asterisk on a line\r\n                                    state = JSDocState.SawAsterisk;\r\n                                    indent += asterisk.length;\r\n                                }\r\n                                break;\r\n                            case SyntaxKind.Identifier:\r\n                                // Anything else is doc comment text. We just save it. Because it\r\n                                // wasn't a tag, we can no longer parse a tag on this line until we hit the next\r\n                                // line break.\r\n                                pushComment(scanner.getTokenText());\r\n                                state = JSDocState.SavingComments;\r\n                                break;\r\n                            case SyntaxKind.WhitespaceTrivia:\r\n                                // only collect whitespace if we're already saving comments or have just crossed the comment indent margin\r\n                                const whitespace = scanner.getTokenText();\r\n                                if (state === JSDocState.SavingComments) {\r\n                                    comments.push(whitespace);\r\n                                }\r\n                                else if (margin !== undefined && indent + whitespace.length > margin) {\r\n                                    comments.push(whitespace.slice(margin - indent - 1));\r\n                                }\r\n                                indent += whitespace.length;\r\n                                break;\r\n                            case SyntaxKind.EndOfFileToken:\r\n                                break loop;\r\n                            default:\r\n                                // anything other than whitespace or asterisk at the beginning of the line starts the comment text\r\n                                state = JSDocState.SavingComments;\r\n                                pushComment(scanner.getTokenText());\r\n                                break;\r\n                        }\r\n                        t = nextJSDocToken();\r\n                    }\r\n                    removeLeadingNewlines(comments);\r\n                    removeTrailingNewlines(comments);\r\n                    result = createJSDocComment();\r\n\r\n                });\r\n\r\n                return result;\r\n\r\n                function removeLeadingNewlines(comments: string[]) {\r\n                    while (comments.length && (comments[0] === \"\\n\" || comments[0] === \"\\r\")) {\r\n                        comments.shift();\r\n                    }\r\n                }\r\n\r\n                function removeTrailingNewlines(comments: string[]) {\r\n                    while (comments.length && (comments[comments.length - 1] === \"\\n\" || comments[comments.length - 1] === \"\\r\")) {\r\n                        comments.pop();\r\n                    }\r\n                }\r\n\r\n                function createJSDocComment(): JSDoc {\r\n                    const result = <JSDoc>createNode(SyntaxKind.JSDocComment, start);\r\n                    result.tags = tags && createNodeArray(tags, tagsPos, tagsEnd);\r\n                    result.comment = comments.length ? comments.join(\"\") : undefined;\r\n                    return finishNode(result, end);\r\n                }\r\n\r\n                function skipWhitespace(): void {\r\n                    while (token() === SyntaxKind.WhitespaceTrivia || token() === SyntaxKind.NewLineTrivia) {\r\n                        nextJSDocToken();\r\n                    }\r\n                }\r\n\r\n                function parseTag(indent: number) {\r\n                    Debug.assert(token() === SyntaxKind.AtToken);\r\n                    const atToken = <AtToken>createNode(SyntaxKind.AtToken, scanner.getTokenPos());\r\n                    atToken.end = scanner.getTextPos();\r\n                    nextJSDocToken();\r\n\r\n                    const tagName = parseJSDocIdentifierName();\r\n                    skipWhitespace();\r\n                    if (!tagName) {\r\n                        return;\r\n                    }\r\n\r\n                    let tag: JSDocTag;\r\n                    if (tagName) {\r\n                        switch (tagName.escapedText) {\r\n                            case \"augments\":\r\n                            case \"extends\":\r\n                                tag = parseAugmentsTag(atToken, tagName);\r\n                                break;\r\n                            case \"class\":\r\n                            case \"constructor\":\r\n                                tag = parseClassTag(atToken, tagName);\r\n                                break;\r\n                            case \"arg\":\r\n                            case \"argument\":\r\n                            case \"param\":\r\n                                addTag(parseParameterOrPropertyTag(atToken, tagName, PropertyLikeParse.Parameter, indent));\r\n                                return;\r\n                            case \"return\":\r\n                            case \"returns\":\r\n                                tag = parseReturnTag(atToken, tagName);\r\n                                break;\r\n                            case \"template\":\r\n                                tag = parseTemplateTag(atToken, tagName);\r\n                                break;\r\n                            case \"type\":\r\n                                tag = parseTypeTag(atToken, tagName);\r\n                                break;\r\n                            case \"typedef\":\r\n                                tag = parseTypedefTag(atToken, tagName);\r\n                                break;\r\n                            default:\r\n                                tag = parseUnknownTag(atToken, tagName);\r\n                                break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        tag = parseUnknownTag(atToken, tagName);\r\n                    }\r\n\r\n                    if (!tag) {\r\n                        // a badly malformed tag should not be added to the list of tags\r\n                        return;\r\n                    }\r\n                    tag.comment = parseTagComments(indent + tag.end - tag.pos);\r\n                    addTag(tag);\r\n                }\r\n\r\n                function parseTagComments(indent: number): string | undefined {\r\n                    const comments: string[] = [];\r\n                    let state = JSDocState.BeginningOfLine;\r\n                    let margin: number | undefined;\r\n                    function pushComment(text: string) {\r\n                        if (!margin) {\r\n                            margin = indent;\r\n                        }\r\n                        comments.push(text);\r\n                        indent += text.length;\r\n                    }\r\n                    let tok = token() as JsDocSyntaxKind;\r\n                    loop: while (true) {\r\n                        switch (tok) {\r\n                            case SyntaxKind.NewLineTrivia:\r\n                                if (state >= JSDocState.SawAsterisk) {\r\n                                    state = JSDocState.BeginningOfLine;\r\n                                    comments.push(scanner.getTokenText());\r\n                                }\r\n                                indent = 0;\r\n                                break;\r\n                            case SyntaxKind.AtToken:\r\n                                scanner.setTextPos(scanner.getTextPos() - 1);\r\n                                // falls through\r\n                            case SyntaxKind.EndOfFileToken:\r\n                                // Done\r\n                                break loop;\r\n                            case SyntaxKind.WhitespaceTrivia:\r\n                                if (state === JSDocState.SavingComments) {\r\n                                    pushComment(scanner.getTokenText());\r\n                                }\r\n                                else {\r\n                                    const whitespace = scanner.getTokenText();\r\n                                    // if the whitespace crosses the margin, take only the whitespace that passes the margin\r\n                                    if (margin !== undefined && indent + whitespace.length > margin) {\r\n                                        comments.push(whitespace.slice(margin - indent - 1));\r\n                                    }\r\n                                    indent += whitespace.length;\r\n                                }\r\n                                break;\r\n                            case SyntaxKind.AsteriskToken:\r\n                                if (state === JSDocState.BeginningOfLine) {\r\n                                    // leading asterisks start recording on the *next* (non-whitespace) token\r\n                                    state = JSDocState.SawAsterisk;\r\n                                    indent += 1;\r\n                                    break;\r\n                                }\r\n                                // record the * as a comment\r\n                                // falls through\r\n                            default:\r\n                                state = JSDocState.SavingComments; // leading identifiers start recording as well\r\n                                pushComment(scanner.getTokenText());\r\n                                break;\r\n                        }\r\n                        tok = nextJSDocToken();\r\n                    }\r\n\r\n                    removeLeadingNewlines(comments);\r\n                    removeTrailingNewlines(comments);\r\n                    return comments.length === 0 ? undefined : comments.join(\"\");\r\n                }\r\n\r\n                function parseUnknownTag(atToken: AtToken, tagName: Identifier) {\r\n                    const result = <JSDocTag>createNode(SyntaxKind.JSDocTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function addTag(tag: JSDocTag): void {\r\n                    if (!tags) {\r\n                        tags = [tag];\r\n                        tagsPos = tag.pos;\r\n                    }\r\n                    else {\r\n                        tags.push(tag);\r\n                    }\r\n                    tagsEnd = tag.end;\r\n                }\r\n\r\n                function tryParseTypeExpression(): JSDocTypeExpression | undefined {\r\n                    skipWhitespace();\r\n                    return token() === SyntaxKind.OpenBraceToken ? parseJSDocTypeExpression() : undefined;\r\n                }\r\n\r\n                function parseBracketNameInPropertyAndParamTag(): { name: EntityName, isBracketed: boolean } {\r\n                    if (token() === SyntaxKind.NoSubstitutionTemplateLiteral) {\r\n                        // a markdown-quoted name: `arg` is not legal jsdoc, but occurs in the wild\r\n                        return { name: createIdentifier(/*isIdentifier*/ true), isBracketed: false };\r\n                    }\r\n                    // Looking for something like '[foo]', 'foo', '[foo.bar]' or 'foo.bar'\r\n                    const isBracketed = parseOptional(SyntaxKind.OpenBracketToken);\r\n                    const name = parseJSDocEntityName();\r\n                    if (isBracketed) {\r\n                        skipWhitespace();\r\n\r\n                        // May have an optional default, e.g. '[foo = 42]'\r\n                        if (parseOptionalToken(SyntaxKind.EqualsToken)) {\r\n                            parseExpression();\r\n                        }\r\n\r\n                        parseExpected(SyntaxKind.CloseBracketToken);\r\n                    }\r\n\r\n                    return { name, isBracketed };\r\n                }\r\n\r\n                function isObjectOrObjectArrayTypeReference(node: TypeNode): boolean {\r\n                    switch (node.kind) {\r\n                        case SyntaxKind.ObjectKeyword:\r\n                            return true;\r\n                        case SyntaxKind.ArrayType:\r\n                            return isObjectOrObjectArrayTypeReference((node as ArrayTypeNode).elementType);\r\n                        default:\r\n                            return isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.escapedText === \"Object\";\r\n                    }\r\n                }\r\n\r\n                function parseParameterOrPropertyTag(atToken: AtToken, tagName: Identifier, target: PropertyLikeParse, indent: number | undefined): JSDocParameterTag | JSDocPropertyTag {\r\n                    let typeExpression = tryParseTypeExpression();\r\n                    let isNameFirst = !typeExpression;\r\n                    skipWhitespace();\r\n\r\n                    const { name, isBracketed } = parseBracketNameInPropertyAndParamTag();\r\n                    skipWhitespace();\r\n\r\n                    if (isNameFirst) {\r\n                        typeExpression = tryParseTypeExpression();\r\n                    }\r\n\r\n                    const result = target === PropertyLikeParse.Parameter ?\r\n                        <JSDocParameterTag>createNode(SyntaxKind.JSDocParameterTag, atToken.pos) :\r\n                        <JSDocPropertyTag>createNode(SyntaxKind.JSDocPropertyTag, atToken.pos);\r\n                    let comment: string | undefined;\r\n                    if (indent !== undefined) comment = parseTagComments(indent + scanner.getStartPos() - atToken.pos);\r\n                    const nestedTypeLiteral = parseNestedTypeLiteral(typeExpression, name, target);\r\n                    if (nestedTypeLiteral) {\r\n                        typeExpression = nestedTypeLiteral;\r\n                        isNameFirst = true;\r\n                    }\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeExpression = typeExpression;\r\n                    result.name = name;\r\n                    result.isNameFirst = isNameFirst;\r\n                    result.isBracketed = isBracketed;\r\n                    result.comment = comment;\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function parseNestedTypeLiteral(typeExpression: JSDocTypeExpression, name: EntityName, target: PropertyLikeParse) {\r\n                    if (typeExpression && isObjectOrObjectArrayTypeReference(typeExpression.type)) {\r\n                        const typeLiteralExpression = <JSDocTypeExpression>createNode(SyntaxKind.JSDocTypeExpression, scanner.getTokenPos());\r\n                        let child: JSDocPropertyLikeTag | JSDocTypeTag | false;\r\n                        let jsdocTypeLiteral: JSDocTypeLiteral;\r\n                        const start = scanner.getStartPos();\r\n                        let children: JSDocPropertyLikeTag[];\r\n                        while (child = tryParse(() => parseChildParameterOrPropertyTag(target, name))) {\r\n                            if (child.kind === SyntaxKind.JSDocParameterTag || child.kind === SyntaxKind.JSDocPropertyTag) {\r\n                                children = append(children, child);\r\n                            }\r\n                        }\r\n                        if (children) {\r\n                            jsdocTypeLiteral = <JSDocTypeLiteral>createNode(SyntaxKind.JSDocTypeLiteral, start);\r\n                            jsdocTypeLiteral.jsDocPropertyTags = children;\r\n                            if (typeExpression.type.kind === SyntaxKind.ArrayType) {\r\n                                jsdocTypeLiteral.isArrayType = true;\r\n                            }\r\n                            typeLiteralExpression.type = finishNode(jsdocTypeLiteral);\r\n                            return finishNode(typeLiteralExpression);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                function parseReturnTag(atToken: AtToken, tagName: Identifier): JSDocReturnTag {\r\n                    if (forEach(tags, t => t.kind === SyntaxKind.JSDocReturnTag)) {\r\n                        parseErrorAt(tagName.pos, scanner.getTokenPos(), Diagnostics._0_tag_already_specified, tagName.escapedText);\r\n                    }\r\n\r\n                    const result = <JSDocReturnTag>createNode(SyntaxKind.JSDocReturnTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeExpression = tryParseTypeExpression();\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function parseTypeTag(atToken: AtToken, tagName: Identifier): JSDocTypeTag {\r\n                    if (forEach(tags, t => t.kind === SyntaxKind.JSDocTypeTag)) {\r\n                        parseErrorAt(tagName.pos, scanner.getTokenPos(), Diagnostics._0_tag_already_specified, tagName.escapedText);\r\n                    }\r\n\r\n                    const result = <JSDocTypeTag>createNode(SyntaxKind.JSDocTypeTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeExpression = parseJSDocTypeExpression(/*mayOmitBraces*/ true);\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function parseAugmentsTag(atToken: AtToken, tagName: Identifier): JSDocAugmentsTag {\r\n                    const result = <JSDocAugmentsTag>createNode(SyntaxKind.JSDocAugmentsTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.class = parseExpressionWithTypeArgumentsForAugments();\r\n                    return finishNode(result);\r\n                }\r\n\r\n                function parseExpressionWithTypeArgumentsForAugments(): ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression } {\r\n                    const usedBrace = parseOptional(SyntaxKind.OpenBraceToken);\r\n                    const node = createNode(SyntaxKind.ExpressionWithTypeArguments) as ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression };\r\n                    node.expression = parsePropertyAccessEntityNameExpression();\r\n                    node.typeArguments = tryParseTypeArguments();\r\n                    const res = finishNode(node);\r\n                    if (usedBrace) {\r\n                        parseExpected(SyntaxKind.CloseBraceToken);\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                function parsePropertyAccessEntityNameExpression() {\r\n                    let node: Identifier | PropertyAccessEntityNameExpression = parseJSDocIdentifierName(/*createIfMissing*/ true);\r\n                    while (parseOptional(SyntaxKind.DotToken)) {\r\n                        const prop: PropertyAccessEntityNameExpression = createNode(SyntaxKind.PropertyAccessExpression, node.pos) as PropertyAccessEntityNameExpression;\r\n                        prop.expression = node;\r\n                        prop.name = parseJSDocIdentifierName();\r\n                        node = finishNode(prop);\r\n                    }\r\n                    return node;\r\n                }\r\n\r\n                function parseClassTag(atToken: AtToken, tagName: Identifier): JSDocClassTag {\r\n                    const tag = <JSDocClassTag>createNode(SyntaxKind.JSDocClassTag, atToken.pos);\r\n                    tag.atToken = atToken;\r\n                    tag.tagName = tagName;\r\n                    return finishNode(tag);\r\n                }\r\n\r\n                function parseTypedefTag(atToken: AtToken, tagName: Identifier): JSDocTypedefTag {\r\n                    const typeExpression = tryParseTypeExpression();\r\n                    skipWhitespace();\r\n\r\n                    const typedefTag = <JSDocTypedefTag>createNode(SyntaxKind.JSDocTypedefTag, atToken.pos);\r\n                    typedefTag.atToken = atToken;\r\n                    typedefTag.tagName = tagName;\r\n                    typedefTag.fullName = parseJSDocTypeNameWithNamespace(/*flags*/ 0);\r\n                    if (typedefTag.fullName) {\r\n                        let rightNode = typedefTag.fullName;\r\n                        while (true) {\r\n                            if (rightNode.kind === SyntaxKind.Identifier || !rightNode.body) {\r\n                                // if node is identifier - use it as name\r\n                                // otherwise use name of the rightmost part that we were able to parse\r\n                                typedefTag.name = rightNode.kind === SyntaxKind.Identifier ? rightNode : rightNode.name;\r\n                                break;\r\n                            }\r\n                            rightNode = rightNode.body;\r\n                        }\r\n                    }\r\n                    skipWhitespace();\r\n\r\n                    typedefTag.typeExpression = typeExpression;\r\n                    if (!typeExpression || isObjectOrObjectArrayTypeReference(typeExpression.type)) {\r\n                        let child: JSDocTypeTag | JSDocPropertyTag | false;\r\n                        let jsdocTypeLiteral: JSDocTypeLiteral;\r\n                        let childTypeTag: JSDocTypeTag;\r\n                        const start = scanner.getStartPos();\r\n                        while (child = tryParse(() => parseChildPropertyTag())) {\r\n                            if (!jsdocTypeLiteral) {\r\n                                jsdocTypeLiteral = <JSDocTypeLiteral>createNode(SyntaxKind.JSDocTypeLiteral, start);\r\n                            }\r\n                            if (child.kind === SyntaxKind.JSDocTypeTag) {\r\n                                if (childTypeTag) {\r\n                                    break;\r\n                                }\r\n                                else {\r\n                                    childTypeTag = child;\r\n                                }\r\n                            }\r\n                            else {\r\n                                jsdocTypeLiteral.jsDocPropertyTags = append(jsdocTypeLiteral.jsDocPropertyTags as MutableNodeArray<JSDocPropertyTag>, child);\r\n                            }\r\n                        }\r\n                        if (jsdocTypeLiteral) {\r\n                            if (typeExpression && typeExpression.type.kind === SyntaxKind.ArrayType) {\r\n                                jsdocTypeLiteral.isArrayType = true;\r\n                            }\r\n                            typedefTag.typeExpression = childTypeTag && childTypeTag.typeExpression && !isObjectOrObjectArrayTypeReference(childTypeTag.typeExpression.type) ?\r\n                                childTypeTag.typeExpression :\r\n                                finishNode(jsdocTypeLiteral);\r\n                        }\r\n                    }\r\n\r\n                    return finishNode(typedefTag);\r\n\r\n                    function parseJSDocTypeNameWithNamespace(flags: NodeFlags) {\r\n                        const pos = scanner.getTokenPos();\r\n                        const typeNameOrNamespaceName = parseJSDocIdentifierName();\r\n\r\n                        if (typeNameOrNamespaceName && parseOptional(SyntaxKind.DotToken)) {\r\n                            const jsDocNamespaceNode = <JSDocNamespaceDeclaration>createNode(SyntaxKind.ModuleDeclaration, pos);\r\n                            jsDocNamespaceNode.flags |= flags;\r\n                            jsDocNamespaceNode.name = typeNameOrNamespaceName;\r\n                            jsDocNamespaceNode.body = parseJSDocTypeNameWithNamespace(NodeFlags.NestedNamespace);\r\n                            return finishNode(jsDocNamespaceNode);\r\n                        }\r\n\r\n                        if (typeNameOrNamespaceName && flags & NodeFlags.NestedNamespace) {\r\n                            typeNameOrNamespaceName.isInJSDocNamespace = true;\r\n                        }\r\n                        return typeNameOrNamespaceName;\r\n                    }\r\n                }\r\n\r\n                function escapedTextsEqual(a: EntityName, b: EntityName): boolean {\r\n                    while (!ts.isIdentifier(a) || !ts.isIdentifier(b)) {\r\n                        if (!ts.isIdentifier(a) && !ts.isIdentifier(b) && a.right.escapedText === b.right.escapedText) {\r\n                            a = a.left;\r\n                            b = b.left;\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return a.escapedText === b.escapedText;\r\n                }\r\n\r\n                function parseChildPropertyTag() {\r\n                    return parseChildParameterOrPropertyTag(PropertyLikeParse.Property) as JSDocTypeTag | JSDocPropertyTag | false;\r\n                }\r\n\r\n                function parseChildParameterOrPropertyTag(target: PropertyLikeParse, name?: EntityName): JSDocTypeTag | JSDocPropertyTag | JSDocParameterTag | false {\r\n                    let canParseTag = true;\r\n                    let seenAsterisk = false;\r\n                    while (true) {\r\n                        switch (nextJSDocToken()) {\r\n                            case SyntaxKind.AtToken:\r\n                                if (canParseTag) {\r\n                                    const child = tryParseChildTag(target);\r\n                                    if (child && child.kind === SyntaxKind.JSDocParameterTag &&\r\n                                        (ts.isIdentifier(child.name) || !escapedTextsEqual(name, child.name.left))) {\r\n                                        return false;\r\n                                    }\r\n                                    return child;\r\n                                }\r\n                                seenAsterisk = false;\r\n                                break;\r\n                            case SyntaxKind.NewLineTrivia:\r\n                                canParseTag = true;\r\n                                seenAsterisk = false;\r\n                                break;\r\n                            case SyntaxKind.AsteriskToken:\r\n                                if (seenAsterisk) {\r\n                                    canParseTag = false;\r\n                                }\r\n                                seenAsterisk = true;\r\n                                break;\r\n                            case SyntaxKind.Identifier:\r\n                                canParseTag = false;\r\n                                break;\r\n                            case SyntaxKind.EndOfFileToken:\r\n                                return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                function tryParseChildTag(target: PropertyLikeParse): JSDocTypeTag | JSDocPropertyTag | JSDocParameterTag | false {\r\n                    Debug.assert(token() === SyntaxKind.AtToken);\r\n                    const atToken = <AtToken>createNode(SyntaxKind.AtToken);\r\n                    atToken.end = scanner.getTextPos();\r\n                    nextJSDocToken();\r\n\r\n                    const tagName = parseJSDocIdentifierName();\r\n                    skipWhitespace();\r\n                    if (!tagName) {\r\n                        return false;\r\n                    }\r\n                    let t: PropertyLikeParse;\r\n                    switch (tagName.escapedText) {\r\n                        case \"type\":\r\n                            return target === PropertyLikeParse.Property && parseTypeTag(atToken, tagName);\r\n                        case \"prop\":\r\n                        case \"property\":\r\n                            t = PropertyLikeParse.Property;\r\n                            break;\r\n                        case \"arg\":\r\n                        case \"argument\":\r\n                        case \"param\":\r\n                            t = PropertyLikeParse.Parameter;\r\n                            break;\r\n                        default:\r\n                            return false;\r\n                    }\r\n                    if (target !== t) {\r\n                        return false;\r\n                    }\r\n                    const tag = parseParameterOrPropertyTag(atToken, tagName, target, /*indent*/ undefined);\r\n                    tag.comment = parseTagComments(tag.end - tag.pos);\r\n                    return tag;\r\n                }\r\n\r\n                function parseTemplateTag(atToken: AtToken, tagName: Identifier): JSDocTemplateTag | undefined {\r\n                    if (some(tags, isJSDocTemplateTag)) {\r\n                        parseErrorAt(tagName.pos, scanner.getTokenPos(), Diagnostics._0_tag_already_specified, tagName.escapedText);\r\n                    }\r\n\r\n                    // Type parameter list looks like '@template T,U,V'\r\n                    const typeParameters = [];\r\n                    const typeParametersPos = getNodePos();\r\n\r\n                    while (true) {\r\n                        const typeParameter = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter);\r\n                        const name = parseJSDocIdentifierNameWithOptionalBraces();\r\n                        skipWhitespace();\r\n                        if (!name) {\r\n                            parseErrorAtPosition(scanner.getStartPos(), 0, Diagnostics.Identifier_expected);\r\n                            return undefined;\r\n                        }\r\n\r\n                        typeParameter.name = name;\r\n                        finishNode(typeParameter);\r\n\r\n                        typeParameters.push(typeParameter);\r\n\r\n                        if (token() === SyntaxKind.CommaToken) {\r\n                            nextJSDocToken();\r\n                            skipWhitespace();\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    const result = <JSDocTemplateTag>createNode(SyntaxKind.JSDocTemplateTag, atToken.pos);\r\n                    result.atToken = atToken;\r\n                    result.tagName = tagName;\r\n                    result.typeParameters = createNodeArray(typeParameters, typeParametersPos);\r\n                    finishNode(result);\r\n                    return result;\r\n                }\r\n\r\n                function parseJSDocIdentifierNameWithOptionalBraces(): Identifier | undefined {\r\n                    const parsedBrace = parseOptional(SyntaxKind.OpenBraceToken);\r\n                    const res = parseJSDocIdentifierName();\r\n                    if (parsedBrace) {\r\n                        parseExpected(SyntaxKind.CloseBraceToken);\r\n                    }\r\n                    return res;\r\n                }\r\n\r\n                function nextJSDocToken(): JsDocSyntaxKind {\r\n                    return currentToken = scanner.scanJSDocToken();\r\n                }\r\n\r\n                function parseJSDocEntityName(): EntityName {\r\n                    let entity: EntityName = parseJSDocIdentifierName(/*createIfMissing*/ true);\r\n                    if (parseOptional(SyntaxKind.OpenBracketToken)) {\r\n                        parseExpected(SyntaxKind.CloseBracketToken);\r\n                        // Note that y[] is accepted as an entity name, but the postfix brackets are not saved for checking.\r\n                        // Technically usejsdoc.org requires them for specifying a property of a type equivalent to Array<{ x: ...}>\r\n                        // but it's not worth it to enforce that restriction.\r\n                    }\r\n                    while (parseOptional(SyntaxKind.DotToken)) {\r\n                        const name = parseJSDocIdentifierName(/*createIfMissing*/ true);\r\n                        if (parseOptional(SyntaxKind.OpenBracketToken)) {\r\n                            parseExpected(SyntaxKind.CloseBracketToken);\r\n                        }\r\n                        entity = createQualifiedName(entity, name);\r\n                    }\r\n                    return entity;\r\n                }\r\n\r\n                function parseJSDocIdentifierName(): Identifier | undefined;\r\n                function parseJSDocIdentifierName(createIfMissing: true): Identifier;\r\n                function parseJSDocIdentifierName(createIfMissing = false): Identifier | undefined {\r\n                    if (!tokenIsIdentifierOrKeyword(token())) {\r\n                        if (createIfMissing) {\r\n                            return createMissingNode<Identifier>(SyntaxKind.Identifier, /*reportAtCurrentPosition*/ true, Diagnostics.Identifier_expected);\r\n                        }\r\n                        else {\r\n                            parseErrorAtCurrentToken(Diagnostics.Identifier_expected);\r\n                            return undefined;\r\n                        }\r\n                    }\r\n\r\n                    const pos = scanner.getTokenPos();\r\n                    const end = scanner.getTextPos();\r\n                    const result = <Identifier>createNode(SyntaxKind.Identifier, pos);\r\n                    result.escapedText = escapeLeadingUnderscores(content.substring(pos, end));\r\n                    finishNode(result, end);\r\n\r\n                    nextJSDocToken();\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    namespace IncrementalParser {\r\n        export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks: boolean): SourceFile {\r\n            aggressiveChecks = aggressiveChecks || Debug.shouldAssert(AssertionLevel.Aggressive);\r\n\r\n            checkChangeRange(sourceFile, newText, textChangeRange, aggressiveChecks);\r\n            if (textChangeRangeIsUnchanged(textChangeRange)) {\r\n                // if the text didn't change, then we can just return our current source file as-is.\r\n                return sourceFile;\r\n            }\r\n\r\n            if (sourceFile.statements.length === 0) {\r\n                // If we don't have any statements in the current source file, then there's no real\r\n                // way to incrementally parse.  So just do a full parse instead.\r\n                return Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, /*syntaxCursor*/ undefined, /*setParentNodes*/ true, sourceFile.scriptKind);\r\n            }\r\n\r\n            // Make sure we're not trying to incrementally update a source file more than once.  Once\r\n            // we do an update the original source file is considered unusable from that point onwards.\r\n            //\r\n            // This is because we do incremental parsing in-place.  i.e. we take nodes from the old\r\n            // tree and give them new positions and parents.  From that point on, trusting the old\r\n            // tree at all is not possible as far too much of it may violate invariants.\r\n            const incrementalSourceFile = <IncrementalNode><Node>sourceFile;\r\n            Debug.assert(!incrementalSourceFile.hasBeenIncrementallyParsed);\r\n            incrementalSourceFile.hasBeenIncrementallyParsed = true;\r\n\r\n            const oldText = sourceFile.text;\r\n            const syntaxCursor = createSyntaxCursor(sourceFile);\r\n\r\n            // Make the actual change larger so that we know to reparse anything whose lookahead\r\n            // might have intersected the change.\r\n            const changeRange = extendToAffectedRange(sourceFile, textChangeRange);\r\n            checkChangeRange(sourceFile, newText, changeRange, aggressiveChecks);\r\n\r\n            // Ensure that extending the affected range only moved the start of the change range\r\n            // earlier in the file.\r\n            Debug.assert(changeRange.span.start <= textChangeRange.span.start);\r\n            Debug.assert(textSpanEnd(changeRange.span) === textSpanEnd(textChangeRange.span));\r\n            Debug.assert(textSpanEnd(textChangeRangeNewSpan(changeRange)) === textSpanEnd(textChangeRangeNewSpan(textChangeRange)));\r\n\r\n            // The is the amount the nodes after the edit range need to be adjusted.  It can be\r\n            // positive (if the edit added characters), negative (if the edit deleted characters)\r\n            // or zero (if this was a pure overwrite with nothing added/removed).\r\n            const delta = textChangeRangeNewSpan(changeRange).length - changeRange.span.length;\r\n\r\n            // If we added or removed characters during the edit, then we need to go and adjust all\r\n            // the nodes after the edit.  Those nodes may move forward (if we inserted chars) or they\r\n            // may move backward (if we deleted chars).\r\n            //\r\n            // Doing this helps us out in two ways.  First, it means that any nodes/tokens we want\r\n            // to reuse are already at the appropriate position in the new text.  That way when we\r\n            // reuse them, we don't have to figure out if they need to be adjusted.  Second, it makes\r\n            // it very easy to determine if we can reuse a node.  If the node's position is at where\r\n            // we are in the text, then we can reuse it.  Otherwise we can't.  If the node's position\r\n            // is ahead of us, then we'll need to rescan tokens.  If the node's position is behind\r\n            // us, then we'll need to skip it or crumble it as appropriate\r\n            //\r\n            // We will also adjust the positions of nodes that intersect the change range as well.\r\n            // By doing this, we ensure that all the positions in the old tree are consistent, not\r\n            // just the positions of nodes entirely before/after the change range.  By being\r\n            // consistent, we can then easily map from positions to nodes in the old tree easily.\r\n            //\r\n            // Also, mark any syntax elements that intersect the changed span.  We know, up front,\r\n            // that we cannot reuse these elements.\r\n            updateTokenPositionsAndMarkElements(incrementalSourceFile,\r\n                changeRange.span.start, textSpanEnd(changeRange.span), textSpanEnd(textChangeRangeNewSpan(changeRange)), delta, oldText, newText, aggressiveChecks);\r\n\r\n            // Now that we've set up our internal incremental state just proceed and parse the\r\n            // source file in the normal fashion.  When possible the parser will retrieve and\r\n            // reuse nodes from the old tree.\r\n            //\r\n            // Note: passing in 'true' for setNodeParents is very important.  When incrementally\r\n            // parsing, we will be reusing nodes from the old tree, and placing it into new\r\n            // parents.  If we don't set the parents now, we'll end up with an observably\r\n            // inconsistent tree.  Setting the parents on the new tree should be very fast.  We\r\n            // will immediately bail out of walking any subtrees when we can see that their parents\r\n            // are already correct.\r\n            const result = Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, syntaxCursor, /*setParentNodes*/ true, sourceFile.scriptKind);\r\n\r\n            return result;\r\n        }\r\n\r\n        function moveElementEntirelyPastChangeRange(element: IncrementalElement, isArray: boolean, delta: number, oldText: string, newText: string, aggressiveChecks: boolean) {\r\n            if (isArray) {\r\n                visitArray(<IncrementalNodeArray>element);\r\n            }\r\n            else {\r\n                visitNode(<IncrementalNode>element);\r\n            }\r\n            return;\r\n\r\n            function visitNode(node: IncrementalNode) {\r\n                let text = \"\";\r\n                if (aggressiveChecks && shouldCheckNode(node)) {\r\n                    text = oldText.substring(node.pos, node.end);\r\n                }\r\n\r\n                // Ditch any existing LS children we may have created.  This way we can avoid\r\n                // moving them forward.\r\n                if (node._children) {\r\n                    node._children = undefined;\r\n                }\r\n\r\n                node.pos += delta;\r\n                node.end += delta;\r\n\r\n                if (aggressiveChecks && shouldCheckNode(node)) {\r\n                    Debug.assert(text === newText.substring(node.pos, node.end));\r\n                }\r\n\r\n                forEachChild(node, visitNode, visitArray);\r\n                if (hasJSDocNodes(node)) {\r\n                    for (const jsDocComment of node.jsDoc) {\r\n                        visitNode(<IncrementalNode><Node>jsDocComment);\r\n                    }\r\n                }\r\n                checkNodePositions(node, aggressiveChecks);\r\n            }\r\n\r\n            function visitArray(array: IncrementalNodeArray) {\r\n                array._children = undefined;\r\n                array.pos += delta;\r\n                array.end += delta;\r\n\r\n                for (const node of array) {\r\n                    visitNode(node);\r\n                }\r\n            }\r\n        }\r\n\r\n        function shouldCheckNode(node: Node) {\r\n            switch (node.kind) {\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.Identifier:\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function adjustIntersectingElement(element: IncrementalElement, changeStart: number, changeRangeOldEnd: number, changeRangeNewEnd: number, delta: number) {\r\n            Debug.assert(element.end >= changeStart, \"Adjusting an element that was entirely before the change range\");\r\n            Debug.assert(element.pos <= changeRangeOldEnd, \"Adjusting an element that was entirely after the change range\");\r\n            Debug.assert(element.pos <= element.end);\r\n\r\n            // We have an element that intersects the change range in some way.  It may have its\r\n            // start, or its end (or both) in the changed range.  We want to adjust any part\r\n            // that intersects such that the final tree is in a consistent state.  i.e. all\r\n            // children have spans within the span of their parent, and all siblings are ordered\r\n            // properly.\r\n\r\n            // We may need to update both the 'pos' and the 'end' of the element.\r\n\r\n            // If the 'pos' is before the start of the change, then we don't need to touch it.\r\n            // If it isn't, then the 'pos' must be inside the change.  How we update it will\r\n            // depend if delta is positive or negative. If delta is positive then we have\r\n            // something like:\r\n            //\r\n            //  -------------------AAA-----------------\r\n            //  -------------------BBBCCCCCCC-----------------\r\n            //\r\n            // In this case, we consider any node that started in the change range to still be\r\n            // starting at the same position.\r\n            //\r\n            // however, if the delta is negative, then we instead have something like this:\r\n            //\r\n            //  -------------------XXXYYYYYYY-----------------\r\n            //  -------------------ZZZ-----------------\r\n            //\r\n            // In this case, any element that started in the 'X' range will keep its position.\r\n            // However any element that started after that will have their pos adjusted to be\r\n            // at the end of the new range.  i.e. any node that started in the 'Y' range will\r\n            // be adjusted to have their start at the end of the 'Z' range.\r\n            //\r\n            // The element will keep its position if possible.  Or Move backward to the new-end\r\n            // if it's in the 'Y' range.\r\n            element.pos = Math.min(element.pos, changeRangeNewEnd);\r\n\r\n            // If the 'end' is after the change range, then we always adjust it by the delta\r\n            // amount.  However, if the end is in the change range, then how we adjust it\r\n            // will depend on if delta is positive or negative.  If delta is positive then we\r\n            // have something like:\r\n            //\r\n            //  -------------------AAA-----------------\r\n            //  -------------------BBBCCCCCCC-----------------\r\n            //\r\n            // In this case, we consider any node that ended inside the change range to keep its\r\n            // end position.\r\n            //\r\n            // however, if the delta is negative, then we instead have something like this:\r\n            //\r\n            //  -------------------XXXYYYYYYY-----------------\r\n            //  -------------------ZZZ-----------------\r\n            //\r\n            // In this case, any element that ended in the 'X' range will keep its position.\r\n            // However any element that ended after that will have their pos adjusted to be\r\n            // at the end of the new range.  i.e. any node that ended in the 'Y' range will\r\n            // be adjusted to have their end at the end of the 'Z' range.\r\n            if (element.end >= changeRangeOldEnd) {\r\n                // Element ends after the change range.  Always adjust the end pos.\r\n                element.end += delta;\r\n            }\r\n            else {\r\n                // Element ends in the change range.  The element will keep its position if\r\n                // possible. Or Move backward to the new-end if it's in the 'Y' range.\r\n                element.end = Math.min(element.end, changeRangeNewEnd);\r\n            }\r\n\r\n            Debug.assert(element.pos <= element.end);\r\n            if (element.parent) {\r\n                Debug.assert(element.pos >= element.parent.pos);\r\n                Debug.assert(element.end <= element.parent.end);\r\n            }\r\n        }\r\n\r\n        function checkNodePositions(node: Node, aggressiveChecks: boolean) {\r\n            if (aggressiveChecks) {\r\n                let pos = node.pos;\r\n                const visitNode = (child: Node) => {\r\n                    Debug.assert(child.pos >= pos);\r\n                    pos = child.end;\r\n                };\r\n                if (hasJSDocNodes(node)) {\r\n                    for (const jsDocComment of node.jsDoc) {\r\n                        visitNode(jsDocComment);\r\n                    }\r\n                }\r\n                forEachChild(node, visitNode);\r\n                Debug.assert(pos <= node.end);\r\n            }\r\n        }\r\n\r\n        function updateTokenPositionsAndMarkElements(\r\n            sourceFile: IncrementalNode,\r\n            changeStart: number,\r\n            changeRangeOldEnd: number,\r\n            changeRangeNewEnd: number,\r\n            delta: number,\r\n            oldText: string,\r\n            newText: string,\r\n            aggressiveChecks: boolean): void {\r\n\r\n            visitNode(sourceFile);\r\n            return;\r\n\r\n            function visitNode(child: IncrementalNode) {\r\n                Debug.assert(child.pos <= child.end);\r\n                if (child.pos > changeRangeOldEnd) {\r\n                    // Node is entirely past the change range.  We need to move both its pos and\r\n                    // end, forward or backward appropriately.\r\n                    moveElementEntirelyPastChangeRange(child, /*isArray*/ false, delta, oldText, newText, aggressiveChecks);\r\n                    return;\r\n                }\r\n\r\n                // Check if the element intersects the change range.  If it does, then it is not\r\n                // reusable.  Also, we'll need to recurse to see what constituent portions we may\r\n                // be able to use.\r\n                const fullEnd = child.end;\r\n                if (fullEnd >= changeStart) {\r\n                    child.intersectsChange = true;\r\n                    child._children = undefined;\r\n\r\n                    // Adjust the pos or end (or both) of the intersecting element accordingly.\r\n                    adjustIntersectingElement(child, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);\r\n                    forEachChild(child, visitNode, visitArray);\r\n                    if (hasJSDocNodes(child)) {\r\n                        for (const jsDocComment of child.jsDoc) {\r\n                            visitNode(<IncrementalNode><Node>jsDocComment);\r\n                        }\r\n                    }\r\n                    checkNodePositions(child, aggressiveChecks);\r\n                    return;\r\n                }\r\n\r\n                // Otherwise, the node is entirely before the change range.  No need to do anything with it.\r\n                Debug.assert(fullEnd < changeStart);\r\n            }\r\n\r\n            function visitArray(array: IncrementalNodeArray) {\r\n                Debug.assert(array.pos <= array.end);\r\n                if (array.pos > changeRangeOldEnd) {\r\n                    // Array is entirely after the change range.  We need to move it, and move any of\r\n                    // its children.\r\n                    moveElementEntirelyPastChangeRange(array, /*isArray*/ true, delta, oldText, newText, aggressiveChecks);\r\n                    return;\r\n                }\r\n\r\n                // Check if the element intersects the change range.  If it does, then it is not\r\n                // reusable.  Also, we'll need to recurse to see what constituent portions we may\r\n                // be able to use.\r\n                const fullEnd = array.end;\r\n                if (fullEnd >= changeStart) {\r\n                    array.intersectsChange = true;\r\n                    array._children = undefined;\r\n\r\n                    // Adjust the pos or end (or both) of the intersecting array accordingly.\r\n                    adjustIntersectingElement(array, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);\r\n                    for (const node of array) {\r\n                        visitNode(node);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                // Otherwise, the array is entirely before the change range.  No need to do anything with it.\r\n                Debug.assert(fullEnd < changeStart);\r\n            }\r\n        }\r\n\r\n        function extendToAffectedRange(sourceFile: SourceFile, changeRange: TextChangeRange): TextChangeRange {\r\n            // Consider the following code:\r\n            //      void foo() { /; }\r\n            //\r\n            // If the text changes with an insertion of / just before the semicolon then we end up with:\r\n            //      void foo() { //; }\r\n            //\r\n            // If we were to just use the changeRange a is, then we would not rescan the { token\r\n            // (as it does not intersect the actual original change range).  Because an edit may\r\n            // change the token touching it, we actually need to look back *at least* one token so\r\n            // that the prior token sees that change.\r\n            const maxLookahead = 1;\r\n\r\n            let start = changeRange.span.start;\r\n\r\n            // the first iteration aligns us with the change start. subsequent iteration move us to\r\n            // the left by maxLookahead tokens.  We only need to do this as long as we're not at the\r\n            // start of the tree.\r\n            for (let i = 0; start > 0 && i <= maxLookahead; i++) {\r\n                const nearestNode = findNearestNodeStartingBeforeOrAtPosition(sourceFile, start);\r\n                Debug.assert(nearestNode.pos <= start);\r\n                const position = nearestNode.pos;\r\n\r\n                start = Math.max(0, position - 1);\r\n            }\r\n\r\n            const finalSpan = createTextSpanFromBounds(start, textSpanEnd(changeRange.span));\r\n            const finalLength = changeRange.newLength + (changeRange.span.start - start);\r\n\r\n            return createTextChangeRange(finalSpan, finalLength);\r\n        }\r\n\r\n        function findNearestNodeStartingBeforeOrAtPosition(sourceFile: SourceFile, position: number): Node {\r\n            let bestResult: Node = sourceFile;\r\n            let lastNodeEntirelyBeforePosition: Node;\r\n\r\n            forEachChild(sourceFile, visit);\r\n\r\n            if (lastNodeEntirelyBeforePosition) {\r\n                const lastChildOfLastEntireNodeBeforePosition = getLastDescendant(lastNodeEntirelyBeforePosition);\r\n                if (lastChildOfLastEntireNodeBeforePosition.pos > bestResult.pos) {\r\n                    bestResult = lastChildOfLastEntireNodeBeforePosition;\r\n                }\r\n            }\r\n\r\n            return bestResult;\r\n\r\n            function getLastDescendant(node: Node): Node {\r\n                while (true) {\r\n                    const lastChild = getLastChild(node);\r\n                    if (lastChild) {\r\n                        node = lastChild;\r\n                    }\r\n                    else {\r\n                        return node;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function visit(child: Node) {\r\n                if (nodeIsMissing(child)) {\r\n                    // Missing nodes are effectively invisible to us.  We never even consider them\r\n                    // When trying to find the nearest node before us.\r\n                    return;\r\n                }\r\n\r\n                // If the child intersects this position, then this node is currently the nearest\r\n                // node that starts before the position.\r\n                if (child.pos <= position) {\r\n                    if (child.pos >= bestResult.pos) {\r\n                        // This node starts before the position, and is closer to the position than\r\n                        // the previous best node we found.  It is now the new best node.\r\n                        bestResult = child;\r\n                    }\r\n\r\n                    // Now, the node may overlap the position, or it may end entirely before the\r\n                    // position.  If it overlaps with the position, then either it, or one of its\r\n                    // children must be the nearest node before the position.  So we can just\r\n                    // recurse into this child to see if we can find something better.\r\n                    if (position < child.end) {\r\n                        // The nearest node is either this child, or one of the children inside\r\n                        // of it.  We've already marked this child as the best so far.  Recurse\r\n                        // in case one of the children is better.\r\n                        forEachChild(child, visit);\r\n\r\n                        // Once we look at the children of this node, then there's no need to\r\n                        // continue any further.\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        Debug.assert(child.end <= position);\r\n                        // The child ends entirely before this position.  Say you have the following\r\n                        // (where $ is the position)\r\n                        //\r\n                        //      <complex expr 1> ? <complex expr 2> $ : <...> <...>\r\n                        //\r\n                        // We would want to find the nearest preceding node in \"complex expr 2\".\r\n                        // To support that, we keep track of this node, and once we're done searching\r\n                        // for a best node, we recurse down this node to see if we can find a good\r\n                        // result in it.\r\n                        //\r\n                        // This approach allows us to quickly skip over nodes that are entirely\r\n                        // before the position, while still allowing us to find any nodes in the\r\n                        // last one that might be what we want.\r\n                        lastNodeEntirelyBeforePosition = child;\r\n                    }\r\n                }\r\n                else {\r\n                    Debug.assert(child.pos > position);\r\n                    // We're now at a node that is entirely past the position we're searching for.\r\n                    // This node (and all following nodes) could never contribute to the result,\r\n                    // so just skip them by returning 'true' here.\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkChangeRange(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks: boolean) {\r\n            const oldText = sourceFile.text;\r\n            if (textChangeRange) {\r\n                Debug.assert((oldText.length - textChangeRange.span.length + textChangeRange.newLength) === newText.length);\r\n\r\n                if (aggressiveChecks || Debug.shouldAssert(AssertionLevel.VeryAggressive)) {\r\n                    const oldTextPrefix = oldText.substr(0, textChangeRange.span.start);\r\n                    const newTextPrefix = newText.substr(0, textChangeRange.span.start);\r\n                    Debug.assert(oldTextPrefix === newTextPrefix);\r\n\r\n                    const oldTextSuffix = oldText.substring(textSpanEnd(textChangeRange.span), oldText.length);\r\n                    const newTextSuffix = newText.substring(textSpanEnd(textChangeRangeNewSpan(textChangeRange)), newText.length);\r\n                    Debug.assert(oldTextSuffix === newTextSuffix);\r\n                }\r\n            }\r\n        }\r\n\r\n        interface IncrementalElement extends TextRange {\r\n            parent?: Node;\r\n            intersectsChange: boolean;\r\n            length?: number;\r\n            _children: Node[];\r\n        }\r\n\r\n        export interface IncrementalNode extends Node, IncrementalElement {\r\n            hasBeenIncrementallyParsed: boolean;\r\n        }\r\n\r\n        interface IncrementalNodeArray extends NodeArray<IncrementalNode>, IncrementalElement {\r\n            length: number;\r\n        }\r\n\r\n        // Allows finding nodes in the source file at a certain position in an efficient manner.\r\n        // The implementation takes advantage of the calling pattern it knows the parser will\r\n        // make in order to optimize finding nodes as quickly as possible.\r\n        export interface SyntaxCursor {\r\n            currentNode(position: number): IncrementalNode;\r\n        }\r\n\r\n        function createSyntaxCursor(sourceFile: SourceFile): SyntaxCursor {\r\n            let currentArray: NodeArray<Node> = sourceFile.statements;\r\n            let currentArrayIndex = 0;\r\n\r\n            Debug.assert(currentArrayIndex < currentArray.length);\r\n            let current = currentArray[currentArrayIndex];\r\n            let lastQueriedPosition = InvalidPosition.Value;\r\n\r\n            return {\r\n                currentNode(position: number) {\r\n                    // Only compute the current node if the position is different than the last time\r\n                    // we were asked.  The parser commonly asks for the node at the same position\r\n                    // twice.  Once to know if can read an appropriate list element at a certain point,\r\n                    // and then to actually read and consume the node.\r\n                    if (position !== lastQueriedPosition) {\r\n                        // Much of the time the parser will need the very next node in the array that\r\n                        // we just returned a node from.So just simply check for that case and move\r\n                        // forward in the array instead of searching for the node again.\r\n                        if (current && current.end === position && currentArrayIndex < (currentArray.length - 1)) {\r\n                            currentArrayIndex++;\r\n                            current = currentArray[currentArrayIndex];\r\n                        }\r\n\r\n                        // If we don't have a node, or the node we have isn't in the right position,\r\n                        // then try to find a viable node at the position requested.\r\n                        if (!current || current.pos !== position) {\r\n                            findHighestListElementThatStartsAtPosition(position);\r\n                        }\r\n                    }\r\n\r\n                    // Cache this query so that we don't do any extra work if the parser calls back\r\n                    // into us.  Note: this is very common as the parser will make pairs of calls like\r\n                    // 'isListElement -> parseListElement'.  If we were unable to find a node when\r\n                    // called with 'isListElement', we don't want to redo the work when parseListElement\r\n                    // is called immediately after.\r\n                    lastQueriedPosition = position;\r\n\r\n                    // Either we don'd have a node, or we have a node at the position being asked for.\r\n                    Debug.assert(!current || current.pos === position);\r\n                    return <IncrementalNode>current;\r\n                }\r\n            };\r\n\r\n            // Finds the highest element in the tree we can find that starts at the provided position.\r\n            // The element must be a direct child of some node list in the tree.  This way after we\r\n            // return it, we can easily return its next sibling in the list.\r\n            function findHighestListElementThatStartsAtPosition(position: number) {\r\n                // Clear out any cached state about the last node we found.\r\n                currentArray = undefined;\r\n                currentArrayIndex = InvalidPosition.Value;\r\n                current = undefined;\r\n\r\n                // Recurse into the source file to find the highest node at this position.\r\n                forEachChild(sourceFile, visitNode, visitArray);\r\n                return;\r\n\r\n                function visitNode(node: Node) {\r\n                    if (position >= node.pos && position < node.end) {\r\n                        // Position was within this node.  Keep searching deeper to find the node.\r\n                        forEachChild(node, visitNode, visitArray);\r\n\r\n                        // don't proceed any further in the search.\r\n                        return true;\r\n                    }\r\n\r\n                    // position wasn't in this node, have to keep searching.\r\n                    return false;\r\n                }\r\n\r\n                function visitArray(array: NodeArray<Node>) {\r\n                    if (position >= array.pos && position < array.end) {\r\n                        // position was in this array.  Search through this array to see if we find a\r\n                        // viable element.\r\n                        for (let i = 0; i < array.length; i++) {\r\n                            const child = array[i];\r\n                            if (child) {\r\n                                if (child.pos === position) {\r\n                                    // Found the right node.  We're done.\r\n                                    currentArray = array;\r\n                                    currentArrayIndex = i;\r\n                                    current = child;\r\n                                    return true;\r\n                                }\r\n                                else {\r\n                                    if (child.pos < position && position < child.end) {\r\n                                        // Position in somewhere within this child.  Search in it and\r\n                                        // stop searching in this array.\r\n                                        forEachChild(child, visitNode, visitArray);\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // position wasn't in this array, have to keep searching.\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        const enum InvalidPosition {\r\n            Value = -1\r\n        }\r\n    }\r\n\r\n    function isDeclarationFileName(fileName: string): boolean {\r\n        return fileExtensionIs(fileName, Extension.Dts);\r\n    }\r\n\r\n    /*@internal*/\r\n    export interface PragmaContext {\r\n        languageVersion: ScriptTarget;\r\n        pragmas?: PragmaMap;\r\n        checkJsDirective?: CheckJsDirective;\r\n        referencedFiles: FileReference[];\r\n        typeReferenceDirectives: FileReference[];\r\n        amdDependencies: AmdDependency[];\r\n        hasNoDefaultLib?: boolean;\r\n        moduleName?: string;\r\n    }\r\n\r\n    /*@internal*/\r\n    export function processCommentPragmas(context: PragmaContext, sourceText: string): void {\r\n        const triviaScanner = createScanner(context.languageVersion, /*skipTrivia*/ false, LanguageVariant.Standard, sourceText);\r\n        const pragmas: PragmaPsuedoMapEntry[] = [];\r\n\r\n        // Keep scanning all the leading trivia in the file until we get to something that\r\n        // isn't trivia.  Any single line comment will be analyzed to see if it is a\r\n        // reference comment.\r\n        while (true) {\r\n            const kind = triviaScanner.scan();\r\n            if (!isTrivia(kind)) {\r\n                break;\r\n            }\r\n\r\n            const range = {\r\n                kind: <SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia>triviaScanner.getToken(),\r\n                pos: triviaScanner.getTokenPos(),\r\n                end: triviaScanner.getTextPos(),\r\n            };\r\n\r\n            const comment = sourceText.substring(range.pos, range.end);\r\n            extractPragmas(pragmas, range, comment);\r\n        }\r\n\r\n        context.pragmas = createMap() as PragmaMap;\r\n        for (const pragma of pragmas) {\r\n            if (context.pragmas.has(pragma.name)) {\r\n                const currentValue = context.pragmas.get(pragma.name);\r\n                if (currentValue instanceof Array) {\r\n                    currentValue.push(pragma.args);\r\n                }\r\n                else {\r\n                    context.pragmas.set(pragma.name, [currentValue, pragma.args]);\r\n                }\r\n                continue;\r\n            }\r\n            context.pragmas.set(pragma.name, pragma.args);\r\n        }\r\n    }\r\n\r\n    /*@internal*/\r\n    type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;\r\n\r\n    /*@internal*/\r\n    export function processPragmasIntoFields(context: PragmaContext, reportDiagnostic: PragmaDiagnosticReporter): void {\r\n        context.checkJsDirective = undefined;\r\n        context.referencedFiles = [];\r\n        context.typeReferenceDirectives = [];\r\n        context.amdDependencies = [];\r\n        context.hasNoDefaultLib = false;\r\n        context.pragmas.forEach((entryOrList, key) => {\r\n            // TODO: The below should be strongly type-guarded and not need casts/explicit annotations, since entryOrList is related to\r\n            // key and key is constrained to a union; but it's not (see GH#21483 for at least partial fix) :(\r\n            switch (key) {\r\n                case \"reference\": {\r\n                    const referencedFiles = context.referencedFiles;\r\n                    const typeReferenceDirectives = context.typeReferenceDirectives;\r\n                    forEach(toArray(entryOrList), (arg: PragmaPsuedoMap[\"reference\"]) => {\r\n                        if (arg.arguments[\"no-default-lib\"]) {\r\n                            context.hasNoDefaultLib = true;\r\n                        }\r\n                        else if (arg.arguments.types) {\r\n                            typeReferenceDirectives.push({ pos: arg.arguments.types.pos, end: arg.arguments.types.end, fileName: arg.arguments.types.value });\r\n                        }\r\n                        else if (arg.arguments.path) {\r\n                            referencedFiles.push({ pos: arg.arguments.path.pos, end: arg.arguments.path.end, fileName: arg.arguments.path.value });\r\n                        }\r\n                        else {\r\n                            reportDiagnostic(arg.range.pos, arg.range.end - arg.range.pos, Diagnostics.Invalid_reference_directive_syntax);\r\n                        }\r\n                    });\r\n                    break;\r\n                }\r\n                case \"amd-dependency\": {\r\n                    context.amdDependencies = map(\r\n                        toArray(entryOrList),\r\n                        ({ arguments: { name, path } }: PragmaPsuedoMap[\"amd-dependency\"]) => ({ name, path })\r\n                    );\r\n                    break;\r\n                }\r\n                case \"amd-module\": {\r\n                    if (entryOrList instanceof Array) {\r\n                        for (const entry of entryOrList) {\r\n                            if (context.moduleName) {\r\n                                // TODO: It's probably fine to issue this diagnostic on all instances of the pragma\r\n                                reportDiagnostic(entry.range.pos, entry.range.end - entry.range.pos, Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments);\r\n                            }\r\n                            context.moduleName = (entry as PragmaPsuedoMap[\"amd-module\"]).arguments.name;\r\n                        }\r\n                    }\r\n                    else {\r\n                        context.moduleName = (entryOrList as PragmaPsuedoMap[\"amd-module\"]).arguments.name;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"ts-nocheck\":\r\n                case \"ts-check\": {\r\n                    // _last_ of either nocheck or check in a file is the \"winner\"\r\n                    forEach(toArray(entryOrList), entry => {\r\n                        if (!context.checkJsDirective || entry.range.pos > context.checkJsDirective.pos) {\r\n                            context.checkJsDirective = {\r\n                                enabled: key === \"ts-check\",\r\n                                end: entry.range.end,\r\n                                pos: entry.range.pos\r\n                            };\r\n                        }\r\n                    });\r\n                    break;\r\n                }\r\n                case \"jsx\": return; // Accessed directly\r\n                default: Debug.fail(\"Unhandled pragma kind\"); // Can this be made into an assertNever in the future?\r\n            }\r\n        });\r\n    }\r\n\r\n    const namedArgRegExCache = createMap<RegExp>();\r\n    function getNamedArgRegEx(name: string) {\r\n        if (namedArgRegExCache.has(name)) {\r\n            return namedArgRegExCache.get(name);\r\n        }\r\n        const result = new RegExp(`(\\\\s${name}\\\\s*=\\\\s*)('|\")(.+?)\\\\2`, \"im\");\r\n        namedArgRegExCache.set(name, result);\r\n        return result;\r\n    }\r\n\r\n    const tripleSlashXMLCommentStartRegEx = /^\\/\\/\\/\\s*<(\\S+)\\s.*?\\/>/im;\r\n    const singleLinePragmaRegEx = /^\\/\\/\\/?\\s*@(\\S+)\\s*(.*)\\s*$/im;\r\n    function extractPragmas(pragmas: PragmaPsuedoMapEntry[], range: CommentRange, text: string) {\r\n        const tripleSlash = range.kind === SyntaxKind.SingleLineCommentTrivia && tripleSlashXMLCommentStartRegEx.exec(text);\r\n        if (tripleSlash) {\r\n            const name = tripleSlash[1].toLowerCase() as keyof PragmaPsuedoMap; // Technically unsafe cast, but we do it so the below check to make it safe typechecks\r\n            const pragma = commentPragmas[name] as PragmaDefinition;\r\n            if (!pragma || !(pragma.kind & PragmaKindFlags.TripleSlashXML)) {\r\n                return;\r\n            }\r\n            if (pragma.args) {\r\n                const argument: {[index: string]: string | {value: string, pos: number, end: number}} = {};\r\n                for (const arg of pragma.args) {\r\n                    const matcher = getNamedArgRegEx(arg.name);\r\n                    const matchResult = matcher.exec(text);\r\n                    if (!matchResult && !arg.optional) {\r\n                        return; // Missing required argument, don't parse\r\n                    }\r\n                    else if (matchResult) {\r\n                        if (arg.captureSpan) {\r\n                            const startPos = range.pos + matchResult.index + matchResult[1].length + matchResult[2].length;\r\n                            argument[arg.name] = {\r\n                                value: matchResult[3],\r\n                                pos: startPos,\r\n                                end: startPos + matchResult[3].length\r\n                            };\r\n                        }\r\n                        else {\r\n                            argument[arg.name] = matchResult[3];\r\n                        }\r\n                    }\r\n                }\r\n                pragmas.push({ name, args: { arguments: argument, range } } as PragmaPsuedoMapEntry);\r\n            }\r\n            else {\r\n                pragmas.push({ name, args: { arguments: {}, range } } as PragmaPsuedoMapEntry);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const singleLine = range.kind === SyntaxKind.SingleLineCommentTrivia && singleLinePragmaRegEx.exec(text);\r\n        if (singleLine) {\r\n            return addPragmaForMatch(pragmas, range, PragmaKindFlags.SingleLine, singleLine);\r\n        }\r\n\r\n        if (range.kind === SyntaxKind.MultiLineCommentTrivia) {\r\n            const multiLinePragmaRegEx = /\\s*@(\\S+)\\s*(.*)\\s*$/gim; // Defined inline since it uses the \"g\" flag, which keeps a persistent index (for iterating)\r\n            let multiLineMatch: RegExpExecArray;\r\n            while (multiLineMatch = multiLinePragmaRegEx.exec(text)) {\r\n                addPragmaForMatch(pragmas, range, PragmaKindFlags.MultiLine, multiLineMatch);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addPragmaForMatch(pragmas: PragmaPsuedoMapEntry[], range: CommentRange, kind: PragmaKindFlags, match: RegExpExecArray) {\r\n        if (!match) return;\r\n        const name = match[1].toLowerCase() as keyof PragmaPsuedoMap; // Technically unsafe cast, but we do it so they below check to make it safe typechecks\r\n        const pragma = commentPragmas[name] as PragmaDefinition;\r\n        if (!pragma || !(pragma.kind & kind)) {\r\n            return;\r\n        }\r\n        const args = match[2]; // Split on spaces and match up positionally with definition\r\n        const argument = getNamedPragmaArguments(pragma, args);\r\n        if (argument === \"fail\") return; // Missing required argument, fail to parse it\r\n        pragmas.push({ name, args: { arguments: argument, range } } as PragmaPsuedoMapEntry);\r\n        return;\r\n    }\r\n\r\n    function getNamedPragmaArguments(pragma: PragmaDefinition, text: string | undefined): {[index: string]: string} | \"fail\" {\r\n        if (!text) return {};\r\n        if (!pragma.args) return {};\r\n        const args = text.split(/\\s+/);\r\n        const argMap: {[index: string]: string} = {};\r\n        for (let i = 0; i < pragma.args.length; i++) {\r\n            const argument = pragma.args[i];\r\n            if (!args[i] && !argument.optional) {\r\n                return \"fail\";\r\n            }\r\n            if (argument.captureSpan) {\r\n                return Debug.fail(\"Capture spans not yet implemented for non-xml pragmas\");\r\n            }\r\n            argMap[argument.name] = args[i];\r\n        }\r\n        return argMap;\r\n    }\r\n}\r\n","namespace ts {\r\n    /* @internal */\r\n    export const compileOnSaveCommandLineOption: CommandLineOption = { name: \"compileOnSave\", type: \"boolean\" };\r\n    /* @internal */\r\n    export const optionDeclarations: CommandLineOption[] = [\r\n        // CommandLine only options\r\n        {\r\n            name: \"help\",\r\n            shortName: \"h\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Print_this_message,\r\n        },\r\n        {\r\n            name: \"help\",\r\n            shortName: \"?\",\r\n            type: \"boolean\"\r\n        },\r\n        {\r\n            name: \"all\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Show_all_compiler_options,\r\n        },\r\n        {\r\n            name: \"version\",\r\n            shortName: \"v\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Print_the_compiler_s_version,\r\n        },\r\n        {\r\n            name: \"init\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file,\r\n        },\r\n        {\r\n            name: \"project\",\r\n            shortName: \"p\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            paramType: Diagnostics.FILE_OR_DIRECTORY,\r\n            description: Diagnostics.Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json,\r\n        },\r\n        {\r\n            name: \"pretty\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Stylize_errors_and_messages_using_color_and_context_experimental\r\n        },\r\n        {\r\n            name: \"preserveWatchOutput\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: false,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen,\r\n        },\r\n        {\r\n            name: \"watch\",\r\n            shortName: \"w\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Command_line_Options,\r\n            description: Diagnostics.Watch_input_files,\r\n        },\r\n\r\n        // Basic\r\n        {\r\n            name: \"target\",\r\n            shortName: \"t\",\r\n            type: createMapFromTemplate({\r\n                es3: ScriptTarget.ES3,\r\n                es5: ScriptTarget.ES5,\r\n                es6: ScriptTarget.ES2015,\r\n                es2015: ScriptTarget.ES2015,\r\n                es2016: ScriptTarget.ES2016,\r\n                es2017: ScriptTarget.ES2017,\r\n                es2018: ScriptTarget.ES2018,\r\n                esnext: ScriptTarget.ESNext,\r\n            }),\r\n            paramType: Diagnostics.VERSION,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_ES2018_or_ESNEXT,\r\n        },\r\n        {\r\n            name: \"module\",\r\n            shortName: \"m\",\r\n            type: createMapFromTemplate({\r\n                none: ModuleKind.None,\r\n                commonjs: ModuleKind.CommonJS,\r\n                amd: ModuleKind.AMD,\r\n                system: ModuleKind.System,\r\n                umd: ModuleKind.UMD,\r\n                es6: ModuleKind.ES2015,\r\n                es2015: ModuleKind.ES2015,\r\n                esnext: ModuleKind.ESNext\r\n            }),\r\n            paramType: Diagnostics.KIND,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_or_ESNext,\r\n        },\r\n        {\r\n            name: \"lib\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"lib\",\r\n                type: createMapFromTemplate({\r\n                    // JavaScript only\r\n                    \"es5\": \"lib.es5.d.ts\",\r\n                    \"es6\": \"lib.es2015.d.ts\",\r\n                    \"es2015\": \"lib.es2015.d.ts\",\r\n                    \"es7\": \"lib.es2016.d.ts\",\r\n                    \"es2016\": \"lib.es2016.d.ts\",\r\n                    \"es2017\": \"lib.es2017.d.ts\",\r\n                    \"es2018\": \"lib.es2018.d.ts\",\r\n                    \"esnext\": \"lib.esnext.d.ts\",\r\n                    // Host only\r\n                    \"dom\": \"lib.dom.d.ts\",\r\n                    \"dom.iterable\": \"lib.dom.iterable.d.ts\",\r\n                    \"webworker\": \"lib.webworker.d.ts\",\r\n                    \"scripthost\": \"lib.scripthost.d.ts\",\r\n                    // ES2015 Or ESNext By-feature options\r\n                    \"es2015.core\": \"lib.es2015.core.d.ts\",\r\n                    \"es2015.collection\": \"lib.es2015.collection.d.ts\",\r\n                    \"es2015.generator\": \"lib.es2015.generator.d.ts\",\r\n                    \"es2015.iterable\": \"lib.es2015.iterable.d.ts\",\r\n                    \"es2015.promise\": \"lib.es2015.promise.d.ts\",\r\n                    \"es2015.proxy\": \"lib.es2015.proxy.d.ts\",\r\n                    \"es2015.reflect\": \"lib.es2015.reflect.d.ts\",\r\n                    \"es2015.symbol\": \"lib.es2015.symbol.d.ts\",\r\n                    \"es2015.symbol.wellknown\": \"lib.es2015.symbol.wellknown.d.ts\",\r\n                    \"es2016.array.include\": \"lib.es2016.array.include.d.ts\",\r\n                    \"es2017.object\": \"lib.es2017.object.d.ts\",\r\n                    \"es2017.sharedmemory\": \"lib.es2017.sharedmemory.d.ts\",\r\n                    \"es2017.string\": \"lib.es2017.string.d.ts\",\r\n                    \"es2017.intl\": \"lib.es2017.intl.d.ts\",\r\n                    \"es2017.typedarrays\": \"lib.es2017.typedarrays.d.ts\",\r\n                    \"es2018.intl\": \"lib.es2018.intl.d.ts\",\r\n                    \"es2018.promise\": \"lib.es2018.promise.d.ts\",\r\n                    \"es2018.regexp\": \"lib.es2018.regexp.d.ts\",\r\n                    \"esnext.array\": \"lib.esnext.array.d.ts\",\r\n                    \"esnext.asynciterable\": \"lib.esnext.asynciterable.d.ts\",\r\n                }),\r\n            },\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_library_files_to_be_included_in_the_compilation\r\n        },\r\n        {\r\n            name: \"allowJs\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Allow_javascript_files_to_be_compiled\r\n        },\r\n        {\r\n            name: \"checkJs\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Report_errors_in_js_files\r\n        },\r\n        {\r\n            name: \"jsx\",\r\n            type: createMapFromTemplate({\r\n                \"preserve\": JsxEmit.Preserve,\r\n                \"react-native\": JsxEmit.ReactNative,\r\n                \"react\": JsxEmit.React\r\n            }),\r\n            paramType: Diagnostics.KIND,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_JSX_code_generation_Colon_preserve_react_native_or_react,\r\n        },\r\n        {\r\n            name: \"declaration\",\r\n            shortName: \"d\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Generates_corresponding_d_ts_file,\r\n        },\r\n        {\r\n            name: \"declarationMap\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Generates_a_sourcemap_for_each_corresponding_d_ts_file,\r\n        },\r\n        {\r\n            name: \"emitDeclarationOnly\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Only_emit_d_ts_declaration_files,\r\n        },\r\n        {\r\n            name: \"sourceMap\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Generates_corresponding_map_file,\r\n        },\r\n        {\r\n            name: \"outFile\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.FILE,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Concatenate_and_emit_output_to_single_file,\r\n        },\r\n        {\r\n            name: \"outDir\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.DIRECTORY,\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Redirect_output_structure_to_the_directory,\r\n        },\r\n        {\r\n            name: \"rootDir\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.LOCATION,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir,\r\n        },\r\n        {\r\n            name: \"removeComments\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Do_not_emit_comments_to_output,\r\n        },\r\n        {\r\n            name: \"noEmit\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Do_not_emit_outputs,\r\n        },\r\n        {\r\n            name: \"importHelpers\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Import_emit_helpers_from_tslib\r\n        },\r\n        {\r\n            name: \"downlevelIteration\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3\r\n        },\r\n        {\r\n            name: \"isolatedModules\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Basic_Options,\r\n            description: Diagnostics.Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule\r\n        },\r\n\r\n        // Strict Type Checks\r\n        {\r\n            name: \"strict\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Enable_all_strict_type_checking_options\r\n        },\r\n        {\r\n            name: \"noImplicitAny\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Raise_error_on_expressions_and_declarations_with_an_implied_any_type,\r\n        },\r\n        {\r\n            name: \"strictNullChecks\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Enable_strict_null_checks\r\n        },\r\n        {\r\n            name: \"strictFunctionTypes\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Enable_strict_checking_of_function_types\r\n        },\r\n        {\r\n            name: \"strictPropertyInitialization\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Enable_strict_checking_of_property_initialization_in_classes\r\n        },\r\n        {\r\n            name: \"noImplicitThis\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Raise_error_on_this_expressions_with_an_implied_any_type,\r\n        },\r\n        {\r\n            name: \"alwaysStrict\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Strict_Type_Checking_Options,\r\n            description: Diagnostics.Parse_in_strict_mode_and_emit_use_strict_for_each_source_file\r\n        },\r\n\r\n        // Additional Checks\r\n        {\r\n            name: \"noUnusedLocals\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_errors_on_unused_locals,\r\n        },\r\n        {\r\n            name: \"noUnusedParameters\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_errors_on_unused_parameters,\r\n        },\r\n        {\r\n            name: \"noImplicitReturns\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_error_when_not_all_code_paths_in_function_return_a_value\r\n        },\r\n        {\r\n            name: \"noFallthroughCasesInSwitch\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Additional_Checks,\r\n            description: Diagnostics.Report_errors_for_fallthrough_cases_in_switch_statement\r\n        },\r\n\r\n        // Module Resolution\r\n        {\r\n            name: \"moduleResolution\",\r\n            type: createMapFromTemplate({\r\n                node: ModuleResolutionKind.NodeJs,\r\n                classic: ModuleResolutionKind.Classic,\r\n            }),\r\n            paramType: Diagnostics.STRATEGY,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6,\r\n        },\r\n        {\r\n            name: \"baseUrl\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Base_directory_to_resolve_non_absolute_module_names\r\n        },\r\n        {\r\n            // this option can only be specified in tsconfig.json\r\n            // use type = object to copy the value as-is\r\n            name: \"paths\",\r\n            type: \"object\",\r\n            isTSConfigOnly: true,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl\r\n        },\r\n        {\r\n            // this option can only be specified in tsconfig.json\r\n            // use type = object to copy the value as-is\r\n            name: \"rootDirs\",\r\n            type: \"list\",\r\n            isTSConfigOnly: true,\r\n            element: {\r\n                name: \"rootDirs\",\r\n                type: \"string\",\r\n                isFilePath: true\r\n            },\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime\r\n        },\r\n        {\r\n            name: \"typeRoots\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"typeRoots\",\r\n                type: \"string\",\r\n                isFilePath: true\r\n            },\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.List_of_folders_to_include_type_definitions_from\r\n        },\r\n        {\r\n            name: \"types\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"types\",\r\n                type: \"string\"\r\n            },\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Type_declaration_files_to_be_included_in_compilation\r\n        },\r\n        {\r\n            name: \"allowSyntheticDefaultImports\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking\r\n        },\r\n        {\r\n            name: \"esModuleInterop\",\r\n            type: \"boolean\",\r\n            showInSimplifiedHelpView: true,\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports\r\n        },\r\n        {\r\n            name: \"preserveSymlinks\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Module_Resolution_Options,\r\n            description: Diagnostics.Do_not_resolve_the_real_path_of_symlinks,\r\n        },\r\n\r\n        // Source Maps\r\n        {\r\n            name: \"sourceRoot\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.LOCATION,\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations,\r\n        },\r\n        {\r\n            name: \"mapRoot\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.LOCATION,\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,\r\n        },\r\n        {\r\n            name: \"inlineSourceMap\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file\r\n        },\r\n        {\r\n            name: \"inlineSources\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Source_Map_Options,\r\n            description: Diagnostics.Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set\r\n        },\r\n\r\n        // Experimental\r\n        {\r\n            name: \"experimentalDecorators\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Experimental_Options,\r\n            description: Diagnostics.Enables_experimental_support_for_ES7_decorators\r\n        },\r\n        {\r\n            name: \"emitDecoratorMetadata\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Experimental_Options,\r\n            description: Diagnostics.Enables_experimental_support_for_emitting_type_metadata_for_decorators\r\n        },\r\n\r\n        // Advanced\r\n        {\r\n            name: \"jsxFactory\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h\r\n        },\r\n        {\r\n            name: \"diagnostics\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Show_diagnostic_information\r\n        },\r\n        {\r\n            name: \"extendedDiagnostics\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Show_verbose_diagnostic_information\r\n        },\r\n        {\r\n            name: \"traceResolution\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Enable_tracing_of_the_name_resolution_process\r\n        },\r\n        {\r\n            name: \"listFiles\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Print_names_of_files_part_of_the_compilation\r\n        },\r\n        {\r\n            name: \"listEmittedFiles\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Print_names_of_generated_files_part_of_the_compilation\r\n        },\r\n\r\n        {\r\n            name: \"out\",\r\n            type: \"string\",\r\n            isFilePath: false, // This is intentionally broken to support compatability with existing tsconfig files\r\n            // for correct behaviour, please use outFile\r\n            category: Diagnostics.Advanced_Options,\r\n            paramType: Diagnostics.FILE,\r\n            description: Diagnostics.Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file,\r\n        },\r\n        {\r\n            name: \"reactNamespace\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit\r\n        },\r\n        {\r\n            name: \"skipDefaultLibCheck\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files\r\n        },\r\n        {\r\n            name: \"charset\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.The_character_set_of_the_input_files\r\n        },\r\n        {\r\n            name: \"emitBOM\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files\r\n        },\r\n        {\r\n            name: \"locale\",\r\n            type: \"string\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.The_locale_used_when_displaying_messages_to_the_user_e_g_en_us\r\n        },\r\n        {\r\n            name: \"newLine\",\r\n            type: createMapFromTemplate({\r\n                crlf: NewLineKind.CarriageReturnLineFeed,\r\n                lf: NewLineKind.LineFeed\r\n            }),\r\n            paramType: Diagnostics.NEWLINE,\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix,\r\n        },\r\n        {\r\n            name: \"noErrorTruncation\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_truncate_error_messages\r\n        },\r\n        {\r\n            name: \"noLib\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_include_the_default_library_file_lib_d_ts\r\n        },\r\n        {\r\n            name: \"noResolve\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files\r\n        },\r\n        {\r\n            name: \"stripInternal\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_emit_declarations_for_code_that_has_an_internal_annotation,\r\n        },\r\n        {\r\n            name: \"disableSizeLimit\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Disable_size_limitations_on_JavaScript_projects\r\n        },\r\n        {\r\n            name: \"noImplicitUseStrict\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_emit_use_strict_directives_in_module_output\r\n        },\r\n        {\r\n            name: \"noEmitHelpers\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_generate_custom_helper_functions_like_extends_in_compiled_output\r\n        },\r\n        {\r\n            name: \"noEmitOnError\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_emit_outputs_if_any_errors_were_reported,\r\n        },\r\n        {\r\n            name: \"preserveConstEnums\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_erase_const_enum_declarations_in_generated_code\r\n        },\r\n        {\r\n            name: \"declarationDir\",\r\n            type: \"string\",\r\n            isFilePath: true,\r\n            paramType: Diagnostics.DIRECTORY,\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Output_directory_for_generated_declaration_files\r\n        },\r\n        {\r\n            name: \"skipLibCheck\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Skip_type_checking_of_declaration_files,\r\n        },\r\n        {\r\n            name: \"allowUnusedLabels\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_report_errors_on_unused_labels\r\n        },\r\n        {\r\n            name: \"allowUnreachableCode\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Do_not_report_errors_on_unreachable_code\r\n        },\r\n        {\r\n            name: \"suppressExcessPropertyErrors\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Suppress_excess_property_checks_for_object_literals,\r\n        },\r\n        {\r\n            name: \"suppressImplicitAnyIndexErrors\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures,\r\n        },\r\n        {\r\n            name: \"forceConsistentCasingInFileNames\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Disallow_inconsistently_cased_references_to_the_same_file\r\n        },\r\n        {\r\n            name: \"maxNodeModuleJsDepth\",\r\n            type: \"number\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files\r\n        },\r\n        {\r\n            name: \"noStrictGenericChecks\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Disable_strict_checking_of_generic_signatures_in_function_types,\r\n        },\r\n        {\r\n            name: \"keyofStringsOnly\",\r\n            type: \"boolean\",\r\n            category: Diagnostics.Advanced_Options,\r\n            description: Diagnostics.Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols,\r\n        },\r\n        {\r\n            // A list of plugins to load in the language service\r\n            name: \"plugins\",\r\n            type: \"list\",\r\n            isTSConfigOnly: true,\r\n            element: {\r\n                name: \"plugin\",\r\n                type: \"object\"\r\n            },\r\n            description: Diagnostics.List_of_language_service_plugins\r\n        }\r\n    ];\r\n\r\n    /* @internal */\r\n    export const typeAcquisitionDeclarations: CommandLineOption[] = [\r\n        {\r\n            /* @deprecated typingOptions.enableAutoDiscovery\r\n             * Use typeAcquisition.enable instead.\r\n             */\r\n            name: \"enableAutoDiscovery\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"enable\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"include\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"include\",\r\n                type: \"string\"\r\n            }\r\n        },\r\n        {\r\n            name: \"exclude\",\r\n            type: \"list\",\r\n            element: {\r\n                name: \"exclude\",\r\n                type: \"string\"\r\n            }\r\n        }\r\n    ];\r\n\r\n    /* @internal */\r\n    export interface OptionNameMap {\r\n        optionNameMap: Map<CommandLineOption>;\r\n        shortOptionNames: Map<string>;\r\n    }\r\n\r\n    /* @internal */\r\n    export const defaultInitCompilerOptions: CompilerOptions = {\r\n        module: ModuleKind.CommonJS,\r\n        target: ScriptTarget.ES5,\r\n        strict: true,\r\n        esModuleInterop: true\r\n    };\r\n\r\n    let optionNameMapCache: OptionNameMap;\r\n\r\n    /* @internal */\r\n    export function convertEnableAutoDiscoveryToEnable(typeAcquisition: TypeAcquisition): TypeAcquisition {\r\n        // Convert deprecated typingOptions.enableAutoDiscovery to typeAcquisition.enable\r\n        if (typeAcquisition && typeAcquisition.enableAutoDiscovery !== undefined && typeAcquisition.enable === undefined) {\r\n            return {\r\n                enable: typeAcquisition.enableAutoDiscovery,\r\n                include: typeAcquisition.include || [],\r\n                exclude: typeAcquisition.exclude || []\r\n            };\r\n        }\r\n        return typeAcquisition;\r\n    }\r\n\r\n    function getOptionNameMap(): OptionNameMap {\r\n        if (optionNameMapCache) {\r\n            return optionNameMapCache;\r\n        }\r\n\r\n        const optionNameMap = createMap<CommandLineOption>();\r\n        const shortOptionNames = createMap<string>();\r\n        forEach(optionDeclarations, option => {\r\n            optionNameMap.set(option.name.toLowerCase(), option);\r\n            if (option.shortName) {\r\n                shortOptionNames.set(option.shortName, option.name);\r\n            }\r\n        });\r\n\r\n        optionNameMapCache = { optionNameMap, shortOptionNames };\r\n        return optionNameMapCache;\r\n    }\r\n\r\n    /* @internal */\r\n    export function createCompilerDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType): Diagnostic {\r\n        return createDiagnosticForInvalidCustomType(opt, createCompilerDiagnostic);\r\n    }\r\n\r\n    function createDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType, createDiagnostic: (message: DiagnosticMessage, arg0: string, arg1: string) => Diagnostic): Diagnostic {\r\n        const namesOfType = arrayFrom(opt.type.keys()).map(key => `'${key}'`).join(\", \");\r\n        return createDiagnostic(Diagnostics.Argument_for_0_option_must_be_Colon_1, `--${opt.name}`, namesOfType);\r\n    }\r\n\r\n    /* @internal */\r\n    export function parseCustomTypeOption(opt: CommandLineOptionOfCustomType, value: string, errors: Push<Diagnostic>) {\r\n        return convertJsonOptionOfCustomType(opt, trimString(value || \"\"), errors);\r\n    }\r\n\r\n    /* @internal */\r\n    export function parseListTypeOption(opt: CommandLineOptionOfListType, value = \"\", errors: Push<Diagnostic>): (string | number)[] | undefined {\r\n        value = trimString(value);\r\n        if (startsWith(value, \"-\")) {\r\n            return undefined;\r\n        }\r\n        if (value === \"\") {\r\n            return [];\r\n        }\r\n        const values = value.split(\",\");\r\n        switch (opt.element.type) {\r\n            case \"number\":\r\n                return map(values, parseInt);\r\n            case \"string\":\r\n                return map(values, v => v || \"\");\r\n            default:\r\n                return filter(map(values, v => parseCustomTypeOption(<CommandLineOptionOfCustomType>opt.element, v, errors)), v => !!v);\r\n        }\r\n    }\r\n\r\n    export function parseCommandLine(commandLine: ReadonlyArray<string>, readFile?: (path: string) => string | undefined): ParsedCommandLine {\r\n        const options: CompilerOptions = {};\r\n        const fileNames: string[] = [];\r\n        const errors: Diagnostic[] = [];\r\n\r\n        parseStrings(commandLine);\r\n        return {\r\n            options,\r\n            fileNames,\r\n            errors\r\n        };\r\n\r\n        function parseStrings(args: ReadonlyArray<string>) {\r\n            let i = 0;\r\n            while (i < args.length) {\r\n                const s = args[i];\r\n                i++;\r\n                if (s.charCodeAt(0) === CharacterCodes.at) {\r\n                    parseResponseFile(s.slice(1));\r\n                }\r\n                else if (s.charCodeAt(0) === CharacterCodes.minus) {\r\n                    const opt = getOptionFromName(s.slice(s.charCodeAt(1) === CharacterCodes.minus ? 2 : 1), /*allowShort*/ true);\r\n                    if (opt) {\r\n                        if (opt.isTSConfigOnly) {\r\n                            errors.push(createCompilerDiagnostic(Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file, opt.name));\r\n                        }\r\n                        else {\r\n                            // Check to see if no argument was provided (e.g. \"--locale\" is the last command-line argument).\r\n                            if (!args[i] && opt.type !== \"boolean\") {\r\n                                errors.push(createCompilerDiagnostic(Diagnostics.Compiler_option_0_expects_an_argument, opt.name));\r\n                            }\r\n\r\n                            switch (opt.type) {\r\n                                case \"number\":\r\n                                    options[opt.name] = parseInt(args[i]);\r\n                                    i++;\r\n                                    break;\r\n                                case \"boolean\":\r\n                                    // boolean flag has optional value true, false, others\r\n                                    const optValue = args[i];\r\n                                    options[opt.name] = optValue !== \"false\";\r\n                                    // consume next argument as boolean flag value\r\n                                    if (optValue === \"false\" || optValue === \"true\") {\r\n                                        i++;\r\n                                    }\r\n                                    break;\r\n                                case \"string\":\r\n                                    options[opt.name] = args[i] || \"\";\r\n                                    i++;\r\n                                    break;\r\n                                case \"list\":\r\n                                    const result = parseListTypeOption(<CommandLineOptionOfListType>opt, args[i], errors);\r\n                                    options[opt.name] = result || [];\r\n                                    if (result) {\r\n                                        i++;\r\n                                    }\r\n                                    break;\r\n                                // If not a primitive, the possible types are specified in what is effectively a map of options.\r\n                                default:\r\n                                    options[opt.name] = parseCustomTypeOption(<CommandLineOptionOfCustomType>opt, args[i], errors);\r\n                                    i++;\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        errors.push(createCompilerDiagnostic(Diagnostics.Unknown_compiler_option_0, s));\r\n                    }\r\n                }\r\n                else {\r\n                    fileNames.push(s);\r\n                }\r\n            }\r\n        }\r\n\r\n        function parseResponseFile(fileName: string) {\r\n            const text = readFile ? readFile(fileName) : sys.readFile(fileName);\r\n\r\n            if (!text) {\r\n                errors.push(createCompilerDiagnostic(Diagnostics.File_0_not_found, fileName));\r\n                return;\r\n            }\r\n\r\n            const args: string[] = [];\r\n            let pos = 0;\r\n            while (true) {\r\n                while (pos < text.length && text.charCodeAt(pos) <= CharacterCodes.space) pos++;\r\n                if (pos >= text.length) break;\r\n                const start = pos;\r\n                if (text.charCodeAt(start) === CharacterCodes.doubleQuote) {\r\n                    pos++;\r\n                    while (pos < text.length && text.charCodeAt(pos) !== CharacterCodes.doubleQuote) pos++;\r\n                    if (pos < text.length) {\r\n                        args.push(text.substring(start + 1, pos));\r\n                        pos++;\r\n                    }\r\n                    else {\r\n                        errors.push(createCompilerDiagnostic(Diagnostics.Unterminated_quoted_string_in_response_file_0, fileName));\r\n                    }\r\n                }\r\n                else {\r\n                    while (text.charCodeAt(pos) > CharacterCodes.space) pos++;\r\n                    args.push(text.substring(start, pos));\r\n                }\r\n            }\r\n            parseStrings(args);\r\n        }\r\n    }\r\n\r\n    function getOptionFromName(optionName: string, allowShort = false): CommandLineOption | undefined {\r\n        optionName = optionName.toLowerCase();\r\n        const { optionNameMap, shortOptionNames } = getOptionNameMap();\r\n        // Try to translate short option names to their full equivalents.\r\n        if (allowShort) {\r\n            const short = shortOptionNames.get(optionName);\r\n            if (short !== undefined) {\r\n                optionName = short;\r\n            }\r\n        }\r\n        return optionNameMap.get(optionName);\r\n    }\r\n\r\n    /**\r\n     * Read tsconfig.json file\r\n     * @param fileName The path to the config file\r\n     */\r\n    export function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): { config?: any; error?: Diagnostic } {\r\n        const textOrDiagnostic = tryReadFile(fileName, readFile);\r\n        return isString(textOrDiagnostic) ? parseConfigFileTextToJson(fileName, textOrDiagnostic) : { config: {}, error: textOrDiagnostic };\r\n    }\r\n\r\n    /**\r\n     * Parse the text of the tsconfig.json file\r\n     * @param fileName The path to the config file\r\n     * @param jsonText The text of the config file\r\n     */\r\n    export function parseConfigFileTextToJson(fileName: string, jsonText: string): { config?: any; error?: Diagnostic } {\r\n        const jsonSourceFile = parseJsonText(fileName, jsonText);\r\n        return {\r\n            config: convertToObject(jsonSourceFile, jsonSourceFile.parseDiagnostics),\r\n            error: jsonSourceFile.parseDiagnostics.length ? jsonSourceFile.parseDiagnostics[0] : undefined\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Read tsconfig.json file\r\n     * @param fileName The path to the config file\r\n     */\r\n    export function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): JsonSourceFile {\r\n        const textOrDiagnostic = tryReadFile(fileName, readFile);\r\n        return isString(textOrDiagnostic) ? parseJsonText(fileName, textOrDiagnostic) : <JsonSourceFile>{ parseDiagnostics: [textOrDiagnostic] };\r\n    }\r\n\r\n    function tryReadFile(fileName: string, readFile: (path: string) => string | undefined): string | Diagnostic {\r\n        let text: string | undefined;\r\n        try {\r\n            text = readFile(fileName);\r\n        }\r\n        catch (e) {\r\n            return createCompilerDiagnostic(Diagnostics.Cannot_read_file_0_Colon_1, fileName, e.message);\r\n        }\r\n        return text === undefined ? createCompilerDiagnostic(Diagnostics.The_specified_path_does_not_exist_Colon_0, fileName) : text;\r\n    }\r\n\r\n    function commandLineOptionsToMap(options: ReadonlyArray<CommandLineOption>) {\r\n        return arrayToMap(options, option => option.name);\r\n    }\r\n\r\n    let _tsconfigRootOptions: Map<CommandLineOption>;\r\n    function getTsconfigRootOptionsMap() {\r\n        if (_tsconfigRootOptions === undefined) {\r\n            _tsconfigRootOptions = commandLineOptionsToMap([\r\n                {\r\n                    name: \"compilerOptions\",\r\n                    type: \"object\",\r\n                    elementOptions: commandLineOptionsToMap(optionDeclarations),\r\n                    extraKeyDiagnosticMessage: Diagnostics.Unknown_compiler_option_0\r\n                },\r\n                {\r\n                    name: \"typingOptions\",\r\n                    type: \"object\",\r\n                    elementOptions: commandLineOptionsToMap(typeAcquisitionDeclarations),\r\n                    extraKeyDiagnosticMessage: Diagnostics.Unknown_type_acquisition_option_0\r\n                },\r\n                {\r\n                    name: \"typeAcquisition\",\r\n                    type: \"object\",\r\n                    elementOptions: commandLineOptionsToMap(typeAcquisitionDeclarations),\r\n                    extraKeyDiagnosticMessage: Diagnostics.Unknown_type_acquisition_option_0\r\n                },\r\n                {\r\n                    name: \"extends\",\r\n                    type: \"string\"\r\n                },\r\n                {\r\n                    name: \"files\",\r\n                    type: \"list\",\r\n                    element: {\r\n                        name: \"files\",\r\n                        type: \"string\"\r\n                    }\r\n                },\r\n                {\r\n                    name: \"include\",\r\n                    type: \"list\",\r\n                    element: {\r\n                        name: \"include\",\r\n                        type: \"string\"\r\n                    }\r\n                },\r\n                {\r\n                    name: \"exclude\",\r\n                    type: \"list\",\r\n                    element: {\r\n                        name: \"exclude\",\r\n                        type: \"string\"\r\n                    }\r\n                },\r\n                compileOnSaveCommandLineOption\r\n            ]);\r\n        }\r\n        return _tsconfigRootOptions;\r\n    }\r\n\r\n    interface JsonConversionNotifier {\r\n        /**\r\n         * Notifies parent option object is being set with the optionKey and a valid optionValue\r\n         * Currently it notifies only if there is element with type object (parentOption) and\r\n         * has element's option declarations map associated with it\r\n         * @param parentOption parent option name in which the option and value are being set\r\n         * @param option option declaration which is being set with the value\r\n         * @param value value of the option\r\n         */\r\n        onSetValidOptionKeyValueInParent(parentOption: string, option: CommandLineOption, value: CompilerOptionsValue): void;\r\n        /**\r\n         * Notify when valid root key value option is being set\r\n         * @param key option key\r\n         * @param keyNode node corresponding to node in the source file\r\n         * @param value computed value of the key\r\n         * @param ValueNode node corresponding to value in the source file\r\n         */\r\n        onSetValidOptionKeyValueInRoot(key: string, keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression): void;\r\n        /**\r\n         * Notify when unknown root key value option is being set\r\n         * @param key option key\r\n         * @param keyNode node corresponding to node in the source file\r\n         * @param value computed value of the key\r\n         * @param ValueNode node corresponding to value in the source file\r\n         */\r\n        onSetUnknownOptionKeyValueInRoot(key: string, keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression): void;\r\n    }\r\n\r\n    /**\r\n     * Convert the json syntax tree into the json value\r\n     */\r\n    export function convertToObject(sourceFile: JsonSourceFile, errors: Push<Diagnostic>): any {\r\n        return convertToObjectWorker(sourceFile, errors, /*knownRootOptions*/ undefined, /*jsonConversionNotifier*/ undefined);\r\n    }\r\n\r\n    /**\r\n     * Convert the json syntax tree into the json value\r\n     */\r\n    function convertToObjectWorker(\r\n        sourceFile: JsonSourceFile,\r\n        errors: Push<Diagnostic>,\r\n        knownRootOptions: Map<CommandLineOption> | undefined,\r\n        jsonConversionNotifier: JsonConversionNotifier | undefined): any {\r\n        if (!sourceFile.jsonObject) {\r\n            return {};\r\n        }\r\n\r\n        return convertObjectLiteralExpressionToJson(sourceFile.jsonObject, knownRootOptions,\r\n            /*extraKeyDiagnosticMessage*/ undefined, /*parentOption*/ undefined);\r\n\r\n        function convertObjectLiteralExpressionToJson(\r\n            node: ObjectLiteralExpression,\r\n            knownOptions: Map<CommandLineOption> | undefined,\r\n            extraKeyDiagnosticMessage: DiagnosticMessage | undefined,\r\n            parentOption: string | undefined\r\n        ): any {\r\n            const result: any = {};\r\n            for (const element of node.properties) {\r\n                if (element.kind !== SyntaxKind.PropertyAssignment) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element, Diagnostics.Property_assignment_expected));\r\n                    continue;\r\n                }\r\n\r\n                if (element.questionToken) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element.questionToken, Diagnostics._0_can_only_be_used_in_a_ts_file, \"?\"));\r\n                }\r\n                if (!isDoubleQuotedString(element.name)) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element.name, Diagnostics.String_literal_with_double_quotes_expected));\r\n                }\r\n\r\n                const keyText = unescapeLeadingUnderscores(getTextOfPropertyName(element.name));\r\n                const option = knownOptions ? knownOptions.get(keyText) : undefined;\r\n                if (extraKeyDiagnosticMessage && !option) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, element.name, extraKeyDiagnosticMessage, keyText));\r\n                }\r\n                const value = convertPropertyValueToJson(element.initializer, option);\r\n                if (typeof keyText !== \"undefined\") {\r\n                    result[keyText] = value;\r\n                    // Notify key value set, if user asked for it\r\n                    if (jsonConversionNotifier &&\r\n                        // Current callbacks are only on known parent option or if we are setting values in the root\r\n                        (parentOption || knownOptions === knownRootOptions)) {\r\n                        const isValidOptionValue = isCompilerOptionsValue(option, value);\r\n                        if (parentOption) {\r\n                            if (isValidOptionValue) {\r\n                                // Notify option set in the parent if its a valid option value\r\n                                jsonConversionNotifier.onSetValidOptionKeyValueInParent(parentOption, option, value);\r\n                            }\r\n                        }\r\n                        else if (knownOptions === knownRootOptions) {\r\n                            if (isValidOptionValue) {\r\n                                // Notify about the valid root key value being set\r\n                                jsonConversionNotifier.onSetValidOptionKeyValueInRoot(keyText, element.name, value, element.initializer);\r\n                            }\r\n                            else if (!option) {\r\n                                // Notify about the unknown root key value being set\r\n                                jsonConversionNotifier.onSetUnknownOptionKeyValueInRoot(keyText, element.name, value, element.initializer);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function convertArrayLiteralExpressionToJson(\r\n            elements: NodeArray<Expression>,\r\n            elementOption: CommandLineOption | undefined\r\n        ): any[] {\r\n            return elements.map(element => convertPropertyValueToJson(element, elementOption));\r\n        }\r\n\r\n        function convertPropertyValueToJson(valueExpression: Expression, option: CommandLineOption): any {\r\n            switch (valueExpression.kind) {\r\n                case SyntaxKind.TrueKeyword:\r\n                    reportInvalidOptionValue(option && option.type !== \"boolean\");\r\n                    return true;\r\n\r\n                case SyntaxKind.FalseKeyword:\r\n                    reportInvalidOptionValue(option && option.type !== \"boolean\");\r\n                    return false;\r\n\r\n                case SyntaxKind.NullKeyword:\r\n                    reportInvalidOptionValue(option && option.name === \"extends\"); // \"extends\" is the only option we don't allow null/undefined for\r\n                    return null; // tslint:disable-line:no-null-keyword\r\n\r\n                case SyntaxKind.StringLiteral:\r\n                    if (!isDoubleQuotedString(valueExpression)) {\r\n                        errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, Diagnostics.String_literal_with_double_quotes_expected));\r\n                    }\r\n                    reportInvalidOptionValue(option && (isString(option.type) && option.type !== \"string\"));\r\n                    const text = (<StringLiteral>valueExpression).text;\r\n                    if (option && !isString(option.type)) {\r\n                        const customOption = <CommandLineOptionOfCustomType>option;\r\n                        // Validate custom option type\r\n                        if (!customOption.type.has(text.toLowerCase())) {\r\n                            errors.push(\r\n                                createDiagnosticForInvalidCustomType(\r\n                                    customOption,\r\n                                    (message, arg0, arg1) => createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, message, arg0, arg1)\r\n                                )\r\n                            );\r\n                        }\r\n                    }\r\n                    return text;\r\n\r\n                case SyntaxKind.NumericLiteral:\r\n                    reportInvalidOptionValue(option && option.type !== \"number\");\r\n                    return Number((<NumericLiteral>valueExpression).text);\r\n\r\n                case SyntaxKind.PrefixUnaryExpression:\r\n                    if ((<PrefixUnaryExpression>valueExpression).operator !== SyntaxKind.MinusToken || (<PrefixUnaryExpression>valueExpression).operand.kind !== SyntaxKind.NumericLiteral) {\r\n                        break; // not valid JSON syntax\r\n                    }\r\n                    reportInvalidOptionValue(option && option.type !== \"number\");\r\n                    return -Number((<NumericLiteral>(<PrefixUnaryExpression>valueExpression).operand).text);\r\n\r\n                case SyntaxKind.ObjectLiteralExpression:\r\n                    reportInvalidOptionValue(option && option.type !== \"object\");\r\n                    const objectLiteralExpression = <ObjectLiteralExpression>valueExpression;\r\n\r\n                    // Currently having element option declaration in the tsconfig with type \"object\"\r\n                    // determines if it needs onSetValidOptionKeyValueInParent callback or not\r\n                    // At moment there are only \"compilerOptions\", \"typeAcquisition\" and \"typingOptions\"\r\n                    // that satifies it and need it to modify options set in them (for normalizing file paths)\r\n                    // vs what we set in the json\r\n                    // If need arises, we can modify this interface and callbacks as needed\r\n                    if (option) {\r\n                        const { elementOptions, extraKeyDiagnosticMessage, name: optionName } = <TsConfigOnlyOption>option;\r\n                        return convertObjectLiteralExpressionToJson(objectLiteralExpression,\r\n                            elementOptions, extraKeyDiagnosticMessage, optionName);\r\n                    }\r\n                    else {\r\n                        return convertObjectLiteralExpressionToJson(\r\n                            objectLiteralExpression, /* knownOptions*/ undefined,\r\n                            /*extraKeyDiagnosticMessage */ undefined, /*parentOption*/ undefined);\r\n                    }\r\n\r\n                case SyntaxKind.ArrayLiteralExpression:\r\n                    reportInvalidOptionValue(option && option.type !== \"list\");\r\n                    return convertArrayLiteralExpressionToJson(\r\n                        (<ArrayLiteralExpression>valueExpression).elements,\r\n                        option && (<CommandLineOptionOfListType>option).element);\r\n            }\r\n\r\n            // Not in expected format\r\n            if (option) {\r\n                reportInvalidOptionValue(/*isError*/ true);\r\n            }\r\n            else {\r\n                errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, Diagnostics.Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal));\r\n            }\r\n\r\n            return undefined;\r\n\r\n            function reportInvalidOptionValue(isError: boolean) {\r\n                if (isError) {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, Diagnostics.Compiler_option_0_requires_a_value_of_type_1, option.name, getCompilerOptionValueTypeString(option)));\r\n                }\r\n            }\r\n        }\r\n\r\n        function isDoubleQuotedString(node: Node): boolean {\r\n            return isStringLiteral(node) && isStringDoubleQuoted(node, sourceFile);\r\n        }\r\n    }\r\n\r\n    function getCompilerOptionValueTypeString(option: CommandLineOption) {\r\n        return option.type === \"list\" ?\r\n            \"Array\" :\r\n            isString(option.type) ? option.type : \"string\";\r\n    }\r\n\r\n    function isCompilerOptionsValue(option: CommandLineOption, value: any): value is CompilerOptionsValue {\r\n        if (option) {\r\n            if (isNullOrUndefined(value)) return true; // All options are undefinable/nullable\r\n            if (option.type === \"list\") {\r\n                return isArray(value);\r\n            }\r\n            const expectedType = isString(option.type) ? option.type : \"string\";\r\n            return typeof value === expectedType;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate tsconfig configuration when running command line \"--init\"\r\n     * @param options commandlineOptions to be generated into tsconfig.json\r\n     * @param fileNames array of filenames to be generated into tsconfig.json\r\n     */\r\n    /* @internal */\r\n    export function generateTSConfig(options: CompilerOptions, fileNames: ReadonlyArray<string>, newLine: string): string {\r\n        const compilerOptions = extend(options, defaultInitCompilerOptions);\r\n        const compilerOptionsMap = serializeCompilerOptions(compilerOptions);\r\n        return writeConfigurations();\r\n\r\n        function getCustomTypeMapOfCommandLineOption(optionDefinition: CommandLineOption): Map<string | number> | undefined {\r\n            if (optionDefinition.type === \"string\" || optionDefinition.type === \"number\" || optionDefinition.type === \"boolean\") {\r\n                // this is of a type CommandLineOptionOfPrimitiveType\r\n                return undefined;\r\n            }\r\n            else if (optionDefinition.type === \"list\") {\r\n                return getCustomTypeMapOfCommandLineOption((<CommandLineOptionOfListType>optionDefinition).element);\r\n            }\r\n            else {\r\n                return (<CommandLineOptionOfCustomType>optionDefinition).type;\r\n            }\r\n        }\r\n\r\n        function getNameOfCompilerOptionValue(value: CompilerOptionsValue, customTypeMap: Map<string | number>): string | undefined {\r\n            // There is a typeMap associated with this command-line option so use it to map value back to its name\r\n            return forEachEntry(customTypeMap, (mapValue, key) => {\r\n                if (mapValue === value) {\r\n                    return key;\r\n                }\r\n            });\r\n        }\r\n\r\n        function serializeCompilerOptions(options: CompilerOptions): Map<CompilerOptionsValue> {\r\n            const result = createMap<CompilerOptionsValue>();\r\n            const optionsNameMap = getOptionNameMap().optionNameMap;\r\n\r\n            for (const name in options) {\r\n                if (hasProperty(options, name)) {\r\n                    // tsconfig only options cannot be specified via command line,\r\n                    // so we can assume that only types that can appear here string | number | boolean\r\n                    if (optionsNameMap.has(name) && optionsNameMap.get(name).category === Diagnostics.Command_line_Options) {\r\n                        continue;\r\n                    }\r\n                    const value = <CompilerOptionsValue>options[name];\r\n                    const optionDefinition = optionsNameMap.get(name.toLowerCase());\r\n                    if (optionDefinition) {\r\n                        const customTypeMap = getCustomTypeMapOfCommandLineOption(optionDefinition);\r\n                        if (!customTypeMap) {\r\n                            // There is no map associated with this compiler option then use the value as-is\r\n                            // This is the case if the value is expect to be string, number, boolean or list of string\r\n                            result.set(name, value);\r\n                        }\r\n                        else {\r\n                            if (optionDefinition.type === \"list\") {\r\n                                result.set(name, (value as ReadonlyArray<string | number>).map(element => getNameOfCompilerOptionValue(element, customTypeMap)));\r\n                            }\r\n                            else {\r\n                                // There is a typeMap associated with this command-line option so use it to map value back to its name\r\n                                result.set(name, getNameOfCompilerOptionValue(value, customTypeMap));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function getDefaultValueForOption(option: CommandLineOption) {\r\n            switch (option.type) {\r\n                case \"number\":\r\n                    return 1;\r\n                case \"boolean\":\r\n                    return true;\r\n                case \"string\":\r\n                    return option.isFilePath ? \"./\" : \"\";\r\n                case \"list\":\r\n                    return [];\r\n                case \"object\":\r\n                    return {};\r\n                default:\r\n                    return (option as CommandLineOptionOfCustomType).type.keys().next().value;\r\n            }\r\n        }\r\n\r\n        function makePadding(paddingLength: number): string {\r\n            return Array(paddingLength + 1).join(\" \");\r\n        }\r\n\r\n        function isAllowedOption({ category, name }: CommandLineOption): boolean {\r\n            // Skip options which do not have a category or have category `Command_line_Options`\r\n            // Exclude all possible `Advanced_Options` in tsconfig.json which were NOT defined in command line\r\n            return category !== undefined\r\n                && category !== Diagnostics.Command_line_Options\r\n                && (category !== Diagnostics.Advanced_Options || compilerOptionsMap.has(name));\r\n        }\r\n\r\n        function writeConfigurations() {\r\n            // Filter applicable options to place in the file\r\n            const categorizedOptions = createMultiMap<CommandLineOption>();\r\n            for (const option of optionDeclarations) {\r\n                const { category } = option;\r\n\r\n                if (isAllowedOption(option)) {\r\n                    categorizedOptions.add(getLocaleSpecificMessage(category), option);\r\n                }\r\n            }\r\n\r\n            // Serialize all options and their descriptions\r\n            let marginLength = 0;\r\n            let seenKnownKeys = 0;\r\n            const nameColumn: string[] = [];\r\n            const descriptionColumn: string[] = [];\r\n            categorizedOptions.forEach((options, category) => {\r\n                if (nameColumn.length !== 0) {\r\n                    nameColumn.push(\"\");\r\n                    descriptionColumn.push(\"\");\r\n                }\r\n                nameColumn.push(`/* ${category} */`);\r\n                descriptionColumn.push(\"\");\r\n                for (const option of options) {\r\n                    let optionName;\r\n                    if (compilerOptionsMap.has(option.name)) {\r\n                        optionName = `\"${option.name}\": ${JSON.stringify(compilerOptionsMap.get(option.name))}${(seenKnownKeys += 1) === compilerOptionsMap.size ? \"\" : \",\"}`;\r\n                    }\r\n                    else {\r\n                        optionName = `// \"${option.name}\": ${JSON.stringify(getDefaultValueForOption(option))},`;\r\n                    }\r\n                    nameColumn.push(optionName);\r\n                    descriptionColumn.push(`/* ${option.description && getLocaleSpecificMessage(option.description) || option.name} */`);\r\n                    marginLength = Math.max(optionName.length, marginLength);\r\n                }\r\n            });\r\n\r\n            // Write the output\r\n            const tab = makePadding(2);\r\n            const result: string[] = [];\r\n            result.push(`{`);\r\n            result.push(`${tab}\"compilerOptions\": {`);\r\n            // Print out each row, aligning all the descriptions on the same column.\r\n            for (let i = 0; i < nameColumn.length; i++) {\r\n                const optionName = nameColumn[i];\r\n                const description = descriptionColumn[i];\r\n                result.push(optionName && `${tab}${tab}${optionName}${ description && (makePadding(marginLength - optionName.length + 2) + description)}`);\r\n            }\r\n            if (fileNames.length) {\r\n                result.push(`${tab}},`);\r\n                result.push(`${tab}\"files\": [`);\r\n                for (let i = 0; i < fileNames.length; i++) {\r\n                    result.push(`${tab}${tab}${JSON.stringify(fileNames[i])}${i === fileNames.length - 1 ? \"\" : \",\"}`);\r\n                }\r\n                result.push(`${tab}]`);\r\n            }\r\n            else {\r\n                result.push(`${tab}}`);\r\n            }\r\n            result.push(`}`);\r\n\r\n            return result.join(newLine);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse the contents of a config file (tsconfig.json).\r\n     * @param json The contents of the config file to parse\r\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\r\n     * @param basePath A root directory to resolve relative path entries in the config\r\n     *    file to. e.g. outDir\r\n     */\r\n    export function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>): ParsedCommandLine {\r\n        return parseJsonConfigFileContentWorker(json, /*sourceFile*/ undefined, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions);\r\n    }\r\n\r\n    /**\r\n     * Parse the contents of a config file (tsconfig.json).\r\n     * @param jsonNode The contents of the config file to parse\r\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\r\n     * @param basePath A root directory to resolve relative path entries in the config\r\n     *    file to. e.g. outDir\r\n     */\r\n    export function parseJsonSourceFileConfigFileContent(sourceFile: JsonSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: ReadonlyArray<JsFileExtensionInfo>): ParsedCommandLine {\r\n        return parseJsonConfigFileContentWorker(/*json*/ undefined, sourceFile, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions);\r\n    }\r\n\r\n    /*@internal*/\r\n    export function setConfigFileInOptions(options: CompilerOptions, configFile: JsonSourceFile) {\r\n        if (configFile) {\r\n            Object.defineProperty(options, \"configFile\", { enumerable: false, writable: false, value: configFile });\r\n        }\r\n    }\r\n\r\n    function isNullOrUndefined(x: any): x is null | undefined {\r\n        // tslint:disable-next-line:no-null-keyword\r\n        return x === undefined || x === null;\r\n    }\r\n\r\n    function directoryOfCombinedPath(fileName: string, basePath: string) {\r\n        // Use the `getNormalizedAbsolutePath` function to avoid canonicalizing the path, as it must remain noncanonical\r\n        // until consistient casing errors are reported\r\n        return getDirectoryPath(getNormalizedAbsolutePath(fileName, basePath));\r\n    }\r\n\r\n    /**\r\n     * Parse the contents of a config file from json or json source file (tsconfig.json).\r\n     * @param json The contents of the config file to parse\r\n     * @param sourceFile sourceFile corresponding to the Json\r\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\r\n     * @param basePath A root directory to resolve relative path entries in the config\r\n     *    file to. e.g. outDir\r\n     * @param resolutionStack Only present for backwards-compatibility. Should be empty.\r\n     */\r\n    function parseJsonConfigFileContentWorker(\r\n        json: any,\r\n        sourceFile: JsonSourceFile,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        existingOptions: CompilerOptions = {},\r\n        configFileName?: string,\r\n        resolutionStack: Path[] = [],\r\n        extraFileExtensions: ReadonlyArray<JsFileExtensionInfo> = [],\r\n    ): ParsedCommandLine {\r\n        Debug.assert((json === undefined && sourceFile !== undefined) || (json !== undefined && sourceFile === undefined));\r\n        const errors: Diagnostic[] = [];\r\n\r\n        const parsedConfig = parseConfig(json, sourceFile, host, basePath, configFileName, resolutionStack, errors);\r\n        const { raw } = parsedConfig;\r\n        const options = extend(existingOptions, parsedConfig.options || {});\r\n        options.configFilePath = configFileName;\r\n        setConfigFileInOptions(options, sourceFile);\r\n        const { fileNames, wildcardDirectories, spec } = getFileNames();\r\n        return {\r\n            options,\r\n            fileNames,\r\n            typeAcquisition: parsedConfig.typeAcquisition || getDefaultTypeAcquisition(),\r\n            raw,\r\n            errors,\r\n            wildcardDirectories,\r\n            compileOnSave: !!raw.compileOnSave,\r\n            configFileSpecs: spec\r\n        };\r\n\r\n        function getFileNames(): ExpandResult {\r\n            let filesSpecs: ReadonlyArray<string>;\r\n            if (hasProperty(raw, \"files\") && !isNullOrUndefined(raw.files)) {\r\n                if (isArray(raw.files)) {\r\n                    filesSpecs = <ReadonlyArray<string>>raw.files;\r\n                    if (filesSpecs.length === 0) {\r\n                        createCompilerDiagnosticOnlyIfJson(Diagnostics.The_files_list_in_config_file_0_is_empty, configFileName || \"tsconfig.json\");\r\n                    }\r\n                }\r\n                else {\r\n                    createCompilerDiagnosticOnlyIfJson(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"files\", \"Array\");\r\n                }\r\n            }\r\n\r\n            let includeSpecs: ReadonlyArray<string>;\r\n            if (hasProperty(raw, \"include\") && !isNullOrUndefined(raw.include)) {\r\n                if (isArray(raw.include)) {\r\n                    includeSpecs = <ReadonlyArray<string>>raw.include;\r\n                }\r\n                else {\r\n                    createCompilerDiagnosticOnlyIfJson(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"include\", \"Array\");\r\n                }\r\n            }\r\n\r\n            let excludeSpecs: ReadonlyArray<string>;\r\n            if (hasProperty(raw, \"exclude\") && !isNullOrUndefined(raw.exclude)) {\r\n                if (isArray(raw.exclude)) {\r\n                    excludeSpecs = <ReadonlyArray<string>>raw.exclude;\r\n                }\r\n                else {\r\n                    createCompilerDiagnosticOnlyIfJson(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"exclude\", \"Array\");\r\n                }\r\n            }\r\n            else {\r\n                const outDir = raw.compilerOptions && raw.compilerOptions.outDir;\r\n                if (outDir) {\r\n                    excludeSpecs = [outDir];\r\n                }\r\n            }\r\n\r\n            if (filesSpecs === undefined && includeSpecs === undefined) {\r\n                includeSpecs = [\"**/*\"];\r\n            }\r\n\r\n            const result = matchFileNames(filesSpecs, includeSpecs, excludeSpecs, configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath, options, host, errors, extraFileExtensions, sourceFile);\r\n            if (result.fileNames.length === 0 && !hasProperty(raw, \"files\") && resolutionStack.length === 0) {\r\n                errors.push(getErrorForNoInputFiles(result.spec, configFileName));\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function createCompilerDiagnosticOnlyIfJson(message: DiagnosticMessage, arg0?: string, arg1?: string) {\r\n            if (!sourceFile) {\r\n                errors.push(createCompilerDiagnostic(message, arg0, arg1));\r\n            }\r\n        }\r\n    }\r\n\r\n    /*@internal*/\r\n    export function isErrorNoInputFiles(error: Diagnostic) {\r\n        return error.code === Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code;\r\n    }\r\n\r\n    /*@internal*/\r\n    export function getErrorForNoInputFiles({ includeSpecs, excludeSpecs }: ConfigFileSpecs, configFileName: string | undefined) {\r\n        return createCompilerDiagnostic(\r\n            Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2,\r\n            configFileName || \"tsconfig.json\",\r\n            JSON.stringify(includeSpecs || []),\r\n            JSON.stringify(excludeSpecs || []));\r\n    }\r\n\r\n    interface ParsedTsconfig {\r\n        raw: any;\r\n        options?: CompilerOptions;\r\n        typeAcquisition?: TypeAcquisition;\r\n        /**\r\n         * Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet\r\n         */\r\n        extendedConfigPath?: string;\r\n    }\r\n\r\n    function isSuccessfulParsedTsconfig(value: ParsedTsconfig) {\r\n        return !!value.options;\r\n    }\r\n\r\n    /**\r\n     * This *just* extracts options/include/exclude/files out of a config file.\r\n     * It does *not* resolve the included files.\r\n     */\r\n    function parseConfig(\r\n            json: any,\r\n            sourceFile: JsonSourceFile,\r\n            host: ParseConfigHost,\r\n            basePath: string,\r\n            configFileName: string,\r\n            resolutionStack: string[],\r\n            errors: Push<Diagnostic>,\r\n    ): ParsedTsconfig {\r\n        basePath = normalizeSlashes(basePath);\r\n        const resolvedPath = getNormalizedAbsolutePath(configFileName || \"\", basePath);\r\n\r\n        if (resolutionStack.indexOf(resolvedPath) >= 0) {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Circularity_detected_while_resolving_configuration_Colon_0, [...resolutionStack, resolvedPath].join(\" -> \")));\r\n            return { raw: json || convertToObject(sourceFile, errors) };\r\n        }\r\n\r\n        const ownConfig = json ?\r\n            parseOwnConfigOfJson(json, host, basePath, configFileName, errors) :\r\n            parseOwnConfigOfJsonSourceFile(sourceFile, host, basePath, configFileName, errors);\r\n\r\n        if (ownConfig.extendedConfigPath) {\r\n            // copy the resolution stack so it is never reused between branches in potential diamond-problem scenarios.\r\n            resolutionStack = resolutionStack.concat([resolvedPath]);\r\n            const extendedConfig = getExtendedConfig(sourceFile, ownConfig.extendedConfigPath, host, basePath, resolutionStack, errors);\r\n            if (extendedConfig && isSuccessfulParsedTsconfig(extendedConfig)) {\r\n                const baseRaw = extendedConfig.raw;\r\n                const raw = ownConfig.raw;\r\n                const setPropertyInRawIfNotUndefined = (propertyName: string) => {\r\n                    const value = raw[propertyName] || baseRaw[propertyName];\r\n                    if (value) {\r\n                        raw[propertyName] = value;\r\n                    }\r\n                };\r\n                setPropertyInRawIfNotUndefined(\"include\");\r\n                setPropertyInRawIfNotUndefined(\"exclude\");\r\n                setPropertyInRawIfNotUndefined(\"files\");\r\n                if (raw.compileOnSave === undefined) {\r\n                    raw.compileOnSave = baseRaw.compileOnSave;\r\n                }\r\n                ownConfig.options = assign({}, extendedConfig.options, ownConfig.options);\r\n                // TODO extend type typeAcquisition\r\n            }\r\n        }\r\n\r\n        return ownConfig;\r\n    }\r\n\r\n    function parseOwnConfigOfJson(\r\n        json: any,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        configFileName: string | undefined,\r\n        errors: Push<Diagnostic>\r\n    ): ParsedTsconfig {\r\n        if (hasProperty(json, \"excludes\")) {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));\r\n        }\r\n\r\n        const options = convertCompilerOptionsFromJsonWorker(json.compilerOptions, basePath, errors, configFileName);\r\n        // typingOptions has been deprecated and is only supported for backward compatibility purposes.\r\n        // It should be removed in future releases - use typeAcquisition instead.\r\n        const typeAcquisition = convertTypeAcquisitionFromJsonWorker(json.typeAcquisition || json.typingOptions, basePath, errors, configFileName);\r\n        json.compileOnSave = convertCompileOnSaveOptionFromJson(json, basePath, errors);\r\n        let extendedConfigPath: string;\r\n\r\n        if (json.extends) {\r\n            if (!isString(json.extends)) {\r\n                errors.push(createCompilerDiagnostic(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, \"extends\", \"string\"));\r\n            }\r\n            else {\r\n                const newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;\r\n                extendedConfigPath = getExtendsConfigPath(json.extends, host, newBase, errors, createCompilerDiagnostic);\r\n            }\r\n        }\r\n        return { raw: json, options, typeAcquisition, extendedConfigPath };\r\n    }\r\n\r\n    function parseOwnConfigOfJsonSourceFile(\r\n        sourceFile: JsonSourceFile,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        configFileName: string | undefined,\r\n        errors: Push<Diagnostic>\r\n    ): ParsedTsconfig {\r\n        const options = getDefaultCompilerOptions(configFileName);\r\n        let typeAcquisition: TypeAcquisition, typingOptionstypeAcquisition: TypeAcquisition;\r\n        let extendedConfigPath: string;\r\n\r\n        const optionsIterator: JsonConversionNotifier = {\r\n            onSetValidOptionKeyValueInParent(parentOption: string, option: CommandLineOption, value: CompilerOptionsValue) {\r\n                Debug.assert(parentOption === \"compilerOptions\" || parentOption === \"typeAcquisition\" || parentOption === \"typingOptions\");\r\n                const currentOption = parentOption === \"compilerOptions\" ?\r\n                    options :\r\n                    parentOption === \"typeAcquisition\" ?\r\n                        (typeAcquisition || (typeAcquisition = getDefaultTypeAcquisition(configFileName))) :\r\n                        (typingOptionstypeAcquisition || (typingOptionstypeAcquisition = getDefaultTypeAcquisition(configFileName)));\r\n\r\n                currentOption[option.name] = normalizeOptionValue(option, basePath, value);\r\n            },\r\n            onSetValidOptionKeyValueInRoot(key: string, _keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression) {\r\n                switch (key) {\r\n                    case \"extends\":\r\n                        const newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;\r\n                        extendedConfigPath = getExtendsConfigPath(\r\n                            <string>value,\r\n                            host,\r\n                            newBase,\r\n                            errors,\r\n                            (message, arg0) =>\r\n                                createDiagnosticForNodeInSourceFile(sourceFile, valueNode, message, arg0)\r\n                        );\r\n                        return;\r\n                    case \"files\":\r\n                        if ((<ReadonlyArray<string>>value).length === 0) {\r\n                            errors.push(createDiagnosticForNodeInSourceFile(sourceFile, valueNode, Diagnostics.The_files_list_in_config_file_0_is_empty, configFileName || \"tsconfig.json\"));\r\n                        }\r\n                        return;\r\n                }\r\n            },\r\n            onSetUnknownOptionKeyValueInRoot(key: string, keyNode: PropertyName, _value: CompilerOptionsValue, _valueNode: Expression) {\r\n                if (key === \"excludes\") {\r\n                    errors.push(createDiagnosticForNodeInSourceFile(sourceFile, keyNode, Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));\r\n                }\r\n            }\r\n        };\r\n        const json = convertToObjectWorker(sourceFile, errors, getTsconfigRootOptionsMap(), optionsIterator);\r\n        if (!typeAcquisition) {\r\n            if (typingOptionstypeAcquisition) {\r\n                typeAcquisition = (typingOptionstypeAcquisition.enableAutoDiscovery !== undefined) ?\r\n                    {\r\n                        enable: typingOptionstypeAcquisition.enableAutoDiscovery,\r\n                        include: typingOptionstypeAcquisition.include,\r\n                        exclude: typingOptionstypeAcquisition.exclude\r\n                    } :\r\n                    typingOptionstypeAcquisition;\r\n            }\r\n            else {\r\n                typeAcquisition = getDefaultTypeAcquisition(configFileName);\r\n            }\r\n        }\r\n\r\n        return { raw: json, options, typeAcquisition, extendedConfigPath };\r\n    }\r\n\r\n    function getExtendsConfigPath(\r\n        extendedConfig: string,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        errors: Push<Diagnostic>,\r\n        createDiagnostic: (message: DiagnosticMessage, arg1?: string) => Diagnostic) {\r\n        extendedConfig = normalizeSlashes(extendedConfig);\r\n        // If the path isn't a rooted or relative path, don't try to resolve it (we reserve the right to special case module-id like paths in the future)\r\n        if (!(isRootedDiskPath(extendedConfig) || startsWith(extendedConfig, \"./\") || startsWith(extendedConfig, \"../\"))) {\r\n            errors.push(createDiagnostic(Diagnostics.A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not, extendedConfig));\r\n            return undefined;\r\n        }\r\n        let extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);\r\n        if (!host.fileExists(extendedConfigPath) && !endsWith(extendedConfigPath, Extension.Json)) {\r\n            extendedConfigPath = `${extendedConfigPath}.json`;\r\n            if (!host.fileExists(extendedConfigPath)) {\r\n                errors.push(createDiagnostic(Diagnostics.File_0_does_not_exist, extendedConfig));\r\n                return undefined;\r\n            }\r\n        }\r\n        return extendedConfigPath;\r\n    }\r\n\r\n    function getExtendedConfig(\r\n        sourceFile: JsonSourceFile,\r\n        extendedConfigPath: string,\r\n        host: ParseConfigHost,\r\n        basePath: string,\r\n        resolutionStack: string[],\r\n        errors: Push<Diagnostic>,\r\n    ): ParsedTsconfig | undefined {\r\n        const extendedResult = readJsonConfigFile(extendedConfigPath, path => host.readFile(path));\r\n        if (sourceFile) {\r\n            (sourceFile.extendedSourceFiles || (sourceFile.extendedSourceFiles = [])).push(extendedResult.fileName);\r\n        }\r\n        if (extendedResult.parseDiagnostics.length) {\r\n            errors.push(...extendedResult.parseDiagnostics);\r\n            return undefined;\r\n        }\r\n\r\n        const extendedDirname = getDirectoryPath(extendedConfigPath);\r\n        const extendedConfig = parseConfig(/*json*/ undefined, extendedResult, host, extendedDirname,\r\n            getBaseFileName(extendedConfigPath), resolutionStack, errors);\r\n        if (sourceFile) {\r\n            sourceFile.extendedSourceFiles.push(...extendedResult.extendedSourceFiles);\r\n        }\r\n\r\n        if (isSuccessfulParsedTsconfig(extendedConfig)) {\r\n            // Update the paths to reflect base path\r\n            const relativeDifference = convertToRelativePath(extendedDirname, basePath, identity);\r\n            const updatePath = (path: string) => isRootedDiskPath(path) ? path : combinePaths(relativeDifference, path);\r\n            const mapPropertiesInRawIfNotUndefined = (propertyName: string) => {\r\n                if (raw[propertyName]) {\r\n                    raw[propertyName] = map(raw[propertyName], updatePath);\r\n                }\r\n            };\r\n\r\n            const { raw } = extendedConfig;\r\n            mapPropertiesInRawIfNotUndefined(\"include\");\r\n            mapPropertiesInRawIfNotUndefined(\"exclude\");\r\n            mapPropertiesInRawIfNotUndefined(\"files\");\r\n        }\r\n\r\n        return extendedConfig;\r\n    }\r\n\r\n    function convertCompileOnSaveOptionFromJson(jsonOption: any, basePath: string, errors: Push<Diagnostic>): boolean {\r\n        if (!hasProperty(jsonOption, compileOnSaveCommandLineOption.name)) {\r\n            return undefined;\r\n        }\r\n        const result = convertJsonOption(compileOnSaveCommandLineOption, jsonOption.compileOnSave, basePath, errors);\r\n        if (typeof result === \"boolean\" && result) {\r\n            return result;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): { options: CompilerOptions, errors: Diagnostic[] } {\r\n        const errors: Diagnostic[] = [];\r\n        const options = convertCompilerOptionsFromJsonWorker(jsonOptions, basePath, errors, configFileName);\r\n        return { options, errors };\r\n    }\r\n\r\n    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): { options: TypeAcquisition, errors: Diagnostic[] } {\r\n        const errors: Diagnostic[] = [];\r\n        const options = convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName);\r\n        return { options, errors };\r\n    }\r\n\r\n    function getDefaultCompilerOptions(configFileName?: string) {\r\n        const options: CompilerOptions = getBaseFileName(configFileName) === \"jsconfig.json\"\r\n            ? { allowJs: true, maxNodeModuleJsDepth: 2, allowSyntheticDefaultImports: true, skipLibCheck: true, noEmit: true }\r\n            : {};\r\n        return options;\r\n    }\r\n\r\n    function convertCompilerOptionsFromJsonWorker(jsonOptions: any,\r\n        basePath: string, errors: Push<Diagnostic>, configFileName?: string): CompilerOptions {\r\n\r\n        const options = getDefaultCompilerOptions(configFileName);\r\n        convertOptionsFromJson(optionDeclarations, jsonOptions, basePath, options, Diagnostics.Unknown_compiler_option_0, errors);\r\n        return options;\r\n    }\r\n\r\n    function getDefaultTypeAcquisition(configFileName?: string): TypeAcquisition {\r\n        return { enable: getBaseFileName(configFileName) === \"jsconfig.json\", include: [], exclude: [] };\r\n    }\r\n\r\n    function convertTypeAcquisitionFromJsonWorker(jsonOptions: any,\r\n        basePath: string, errors: Push<Diagnostic>, configFileName?: string): TypeAcquisition {\r\n\r\n        const options = getDefaultTypeAcquisition(configFileName);\r\n        const typeAcquisition = convertEnableAutoDiscoveryToEnable(jsonOptions);\r\n        convertOptionsFromJson(typeAcquisitionDeclarations, typeAcquisition, basePath, options, Diagnostics.Unknown_type_acquisition_option_0, errors);\r\n\r\n        return options;\r\n    }\r\n\r\n    function convertOptionsFromJson(optionDeclarations: ReadonlyArray<CommandLineOption>, jsonOptions: any, basePath: string,\r\n        defaultOptions: CompilerOptions | TypeAcquisition, diagnosticMessage: DiagnosticMessage, errors: Push<Diagnostic>) {\r\n\r\n        if (!jsonOptions) {\r\n            return;\r\n        }\r\n\r\n        const optionNameMap = commandLineOptionsToMap(optionDeclarations);\r\n\r\n        for (const id in jsonOptions) {\r\n            const opt = optionNameMap.get(id);\r\n            if (opt) {\r\n                defaultOptions[opt.name] = convertJsonOption(opt, jsonOptions[id], basePath, errors);\r\n            }\r\n            else {\r\n                errors.push(createCompilerDiagnostic(diagnosticMessage, id));\r\n            }\r\n        }\r\n    }\r\n\r\n    function convertJsonOption(opt: CommandLineOption, value: any, basePath: string, errors: Push<Diagnostic>): CompilerOptionsValue {\r\n        if (isCompilerOptionsValue(opt, value)) {\r\n            const optType = opt.type;\r\n            if (optType === \"list\" && isArray(value)) {\r\n                return convertJsonOptionOfListType(<CommandLineOptionOfListType>opt, value, basePath, errors);\r\n            }\r\n            else if (!isString(optType)) {\r\n                return convertJsonOptionOfCustomType(<CommandLineOptionOfCustomType>opt, <string>value, errors);\r\n            }\r\n            return normalizeNonListOptionValue(opt, basePath, value);\r\n        }\r\n        else {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Compiler_option_0_requires_a_value_of_type_1, opt.name, getCompilerOptionValueTypeString(opt)));\r\n        }\r\n    }\r\n\r\n    function normalizeOptionValue(option: CommandLineOption, basePath: string, value: any): CompilerOptionsValue {\r\n        if (isNullOrUndefined(value)) return undefined;\r\n        if (option.type === \"list\") {\r\n            const listOption = <CommandLineOptionOfListType>option;\r\n            if (listOption.element.isFilePath || !isString(listOption.element.type)) {\r\n                return <CompilerOptionsValue>filter(map(value, v => normalizeOptionValue(listOption.element, basePath, v)), v => !!v);\r\n            }\r\n            return value;\r\n        }\r\n        else if (!isString(option.type)) {\r\n            return option.type.get(isString(value) ? value.toLowerCase() : value);\r\n        }\r\n        return normalizeNonListOptionValue(option, basePath, value);\r\n    }\r\n\r\n    function normalizeNonListOptionValue(option: CommandLineOption, basePath: string, value: any): CompilerOptionsValue {\r\n        if (option.isFilePath) {\r\n            value = normalizePath(combinePaths(basePath, value));\r\n            if (value === \"\") {\r\n                value = \".\";\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function convertJsonOptionOfCustomType(opt: CommandLineOptionOfCustomType, value: string, errors: Push<Diagnostic>) {\r\n        if (isNullOrUndefined(value)) return undefined;\r\n        const key = value.toLowerCase();\r\n        const val = opt.type.get(key);\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n        else {\r\n            errors.push(createCompilerDiagnosticForInvalidCustomType(opt));\r\n        }\r\n    }\r\n\r\n    function convertJsonOptionOfListType(option: CommandLineOptionOfListType, values: ReadonlyArray<any>, basePath: string, errors: Push<Diagnostic>): any[] {\r\n        return filter(map(values, v => convertJsonOption(option.element, v, basePath, errors)), v => !!v);\r\n    }\r\n\r\n    function trimString(s: string) {\r\n        return typeof s.trim === \"function\" ? s.trim() : s.replace(/^[\\s]+|[\\s]+$/g, \"\");\r\n    }\r\n\r\n    /**\r\n     * Tests for a path that ends in a recursive directory wildcard.\r\n     * Matches **, \\**, **\\, and \\**\\, but not a**b.\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  (^|\\/)      # matches either the beginning of the string or a directory separator.\r\n     *  \\*\\*        # matches the recursive directory wildcard \"**\".\r\n     *  \\/?$        # matches an optional trailing directory separator at the end of the string.\r\n     */\r\n    const invalidTrailingRecursionPattern = /(^|\\/)\\*\\*\\/?$/;\r\n\r\n    /**\r\n     * Tests for a path where .. appears after a recursive directory wildcard.\r\n     * Matches **\\..\\*, **\\a\\..\\*, and **\\.., but not ..\\**\\*\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  (^|\\/)      # matches either the beginning of the string or a directory separator.\r\n     *  \\*\\*\\/      # matches a recursive directory wildcard \"**\" followed by a directory separator.\r\n     *  (.*\\/)?     # optionally matches any number of characters followed by a directory separator.\r\n     *  \\.\\.        # matches a parent directory path component \"..\"\r\n     *  ($|\\/)      # matches either the end of the string or a directory separator.\r\n     */\r\n    const invalidDotDotAfterRecursiveWildcardPattern = /(^|\\/)\\*\\*\\/(.*\\/)?\\.\\.($|\\/)/;\r\n\r\n    /**\r\n     * Tests for a path containing a wildcard character in a directory component of the path.\r\n     * Matches \\*\\, \\?\\, and \\a*b\\, but not \\a\\ or \\a\\*.\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  \\/          # matches a directory separator.\r\n     *  [^/]*?      # matches any number of characters excluding directory separators (non-greedy).\r\n     *  [*?]        # matches either a wildcard character (* or ?)\r\n     *  [^/]*       # matches any number of characters excluding directory separators (greedy).\r\n     *  \\/          # matches a directory separator.\r\n     */\r\n    const watchRecursivePattern = /\\/[^/]*?[*?][^/]*\\//;\r\n\r\n    /**\r\n     * Matches the portion of a wildcard path that does not contain wildcards.\r\n     * Matches \\a of \\a\\*, or \\a\\b\\c of \\a\\b\\c\\?\\d.\r\n     *\r\n     * NOTE: used \\ in place of / above to avoid issues with multiline comments.\r\n     *\r\n     * Breakdown:\r\n     *  ^                   # matches the beginning of the string\r\n     *  [^*?]*              # matches any number of non-wildcard characters\r\n     *  (?=\\/[^/]*[*?])     # lookahead that matches a directory separator followed by\r\n     *                      # a path component that contains at least one wildcard character (* or ?).\r\n     */\r\n    const wildcardDirectoryPattern = /^[^*?]*(?=\\/[^/]*[*?])/;\r\n\r\n    /**\r\n     * Expands an array of file specifications.\r\n     *\r\n     * @param filesSpecs The literal file names to include.\r\n     * @param includeSpecs The wildcard file specifications to include.\r\n     * @param excludeSpecs The wildcard file specifications to exclude.\r\n     * @param basePath The base path for any relative file specifications.\r\n     * @param options Compiler options.\r\n     * @param host The host used to resolve files and directories.\r\n     * @param errors An array for diagnostic reporting.\r\n     */\r\n    function matchFileNames(\r\n        filesSpecs: ReadonlyArray<string>,\r\n        includeSpecs: ReadonlyArray<string>,\r\n        excludeSpecs: ReadonlyArray<string>,\r\n        basePath: string,\r\n        options: CompilerOptions,\r\n        host: ParseConfigHost,\r\n        errors: Push<Diagnostic>,\r\n        extraFileExtensions: ReadonlyArray<JsFileExtensionInfo>,\r\n        jsonSourceFile: JsonSourceFile\r\n    ): ExpandResult {\r\n        basePath = normalizePath(basePath);\r\n        let validatedIncludeSpecs: ReadonlyArray<string>, validatedExcludeSpecs: ReadonlyArray<string>;\r\n\r\n        // The exclude spec list is converted into a regular expression, which allows us to quickly\r\n        // test whether a file or directory should be excluded before recursively traversing the\r\n        // file system.\r\n\r\n        if (includeSpecs) {\r\n            validatedIncludeSpecs = validateSpecs(includeSpecs, errors, /*allowTrailingRecursion*/ false, jsonSourceFile, \"include\");\r\n        }\r\n\r\n        if (excludeSpecs) {\r\n            validatedExcludeSpecs = validateSpecs(excludeSpecs, errors, /*allowTrailingRecursion*/ true, jsonSourceFile, \"exclude\");\r\n        }\r\n\r\n        // Wildcard directories (provided as part of a wildcard path) are stored in a\r\n        // file map that marks whether it was a regular wildcard match (with a `*` or `?` token),\r\n        // or a recursive directory. This information is used by filesystem watchers to monitor for\r\n        // new entries in these paths.\r\n        const wildcardDirectories = getWildcardDirectories(validatedIncludeSpecs, validatedExcludeSpecs, basePath, host.useCaseSensitiveFileNames);\r\n\r\n        const spec: ConfigFileSpecs = { filesSpecs, includeSpecs, excludeSpecs, validatedIncludeSpecs, validatedExcludeSpecs, wildcardDirectories };\r\n        return getFileNamesFromConfigSpecs(spec, basePath, options, host, extraFileExtensions);\r\n    }\r\n\r\n    /**\r\n     * Gets the file names from the provided config file specs that contain, files, include, exclude and\r\n     * other properties needed to resolve the file names\r\n     * @param spec The config file specs extracted with file names to include, wildcards to include/exclude and other details\r\n     * @param basePath The base path for any relative file specifications.\r\n     * @param options Compiler options.\r\n     * @param host The host used to resolve files and directories.\r\n     * @param extraFileExtensions optionaly file extra file extension information from host\r\n     */\r\n    /* @internal */\r\n    export function getFileNamesFromConfigSpecs(spec: ConfigFileSpecs, basePath: string, options: CompilerOptions, host: ParseConfigHost, extraFileExtensions: ReadonlyArray<JsFileExtensionInfo> = []): ExpandResult {\r\n        basePath = normalizePath(basePath);\r\n\r\n        const keyMapper = host.useCaseSensitiveFileNames ? identity : toLowerCase;\r\n\r\n        // Literal file names (provided via the \"files\" array in tsconfig.json) are stored in a\r\n        // file map with a possibly case insensitive key. We use this map later when when including\r\n        // wildcard paths.\r\n        const literalFileMap = createMap<string>();\r\n\r\n        // Wildcard paths (provided via the \"includes\" array in tsconfig.json) are stored in a\r\n        // file map with a possibly case insensitive key. We use this map to store paths matched\r\n        // via wildcard, and to handle extension priority.\r\n        const wildcardFileMap = createMap<string>();\r\n\r\n        const { filesSpecs, validatedIncludeSpecs, validatedExcludeSpecs, wildcardDirectories } = spec;\r\n\r\n        // Rather than requery this for each file and filespec, we query the supported extensions\r\n        // once and store it on the expansion context.\r\n        const supportedExtensions = getSupportedExtensions(options, extraFileExtensions);\r\n\r\n        // Literal files are always included verbatim. An \"include\" or \"exclude\" specification cannot\r\n        // remove a literal file.\r\n        if (filesSpecs) {\r\n            for (const fileName of filesSpecs) {\r\n                const file = getNormalizedAbsolutePath(fileName, basePath);\r\n                literalFileMap.set(keyMapper(file), file);\r\n            }\r\n        }\r\n\r\n        if (validatedIncludeSpecs && validatedIncludeSpecs.length > 0) {\r\n            for (const file of host.readDirectory(basePath, supportedExtensions, validatedExcludeSpecs, validatedIncludeSpecs, /*depth*/ undefined)) {\r\n                // If we have already included a literal or wildcard path with a\r\n                // higher priority extension, we should skip this file.\r\n                //\r\n                // This handles cases where we may encounter both <file>.ts and\r\n                // <file>.d.ts (or <file>.js if \"allowJs\" is enabled) in the same\r\n                // directory when they are compilation outputs.\r\n                if (hasFileWithHigherPriorityExtension(file, literalFileMap, wildcardFileMap, supportedExtensions, keyMapper)) {\r\n                    continue;\r\n                }\r\n\r\n                // We may have included a wildcard path with a lower priority\r\n                // extension due to the user-defined order of entries in the\r\n                // \"include\" array. If there is a lower priority extension in the\r\n                // same directory, we should remove it.\r\n                removeWildcardFilesWithLowerPriorityExtension(file, wildcardFileMap, supportedExtensions, keyMapper);\r\n\r\n                const key = keyMapper(file);\r\n                if (!literalFileMap.has(key) && !wildcardFileMap.has(key)) {\r\n                    wildcardFileMap.set(key, file);\r\n                }\r\n            }\r\n        }\r\n\r\n        const literalFiles = arrayFrom(literalFileMap.values());\r\n        const wildcardFiles = arrayFrom(wildcardFileMap.values());\r\n        return {\r\n            fileNames: literalFiles.concat(wildcardFiles),\r\n            wildcardDirectories,\r\n            spec\r\n        };\r\n    }\r\n\r\n    function validateSpecs(specs: ReadonlyArray<string>, errors: Push<Diagnostic>, allowTrailingRecursion: boolean, jsonSourceFile: JsonSourceFile, specKey: string): ReadonlyArray<string> {\r\n        return specs.filter(spec => {\r\n            const diag = specToDiagnostic(spec, allowTrailingRecursion);\r\n            if (diag !== undefined) {\r\n                errors.push(createDiagnostic(diag, spec));\r\n            }\r\n            return diag === undefined;\r\n        });\r\n\r\n        function createDiagnostic(message: DiagnosticMessage, spec: string): Diagnostic {\r\n            if (jsonSourceFile && jsonSourceFile.jsonObject) {\r\n                for (const property of getPropertyAssignment(jsonSourceFile.jsonObject, specKey)) {\r\n                    if (isArrayLiteralExpression(property.initializer)) {\r\n                        for (const element of property.initializer.elements) {\r\n                            if (isStringLiteral(element) && element.text === spec) {\r\n                                return createDiagnosticForNodeInSourceFile(jsonSourceFile, element, message, spec);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return createCompilerDiagnostic(message, spec);\r\n        }\r\n    }\r\n\r\n    function specToDiagnostic(spec: string, allowTrailingRecursion: boolean): DiagnosticMessage | undefined {\r\n        if (!allowTrailingRecursion && invalidTrailingRecursionPattern.test(spec)) {\r\n            return Diagnostics.File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0;\r\n        }\r\n        else if (invalidDotDotAfterRecursiveWildcardPattern.test(spec)) {\r\n            return Diagnostics.File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets directories in a set of include patterns that should be watched for changes.\r\n     */\r\n    function getWildcardDirectories(include: ReadonlyArray<string>, exclude: ReadonlyArray<string>, path: string, useCaseSensitiveFileNames: boolean): MapLike<WatchDirectoryFlags> {\r\n        // We watch a directory recursively if it contains a wildcard anywhere in a directory segment\r\n        // of the pattern:\r\n        //\r\n        //  /a/b/**/d   - Watch /a/b recursively to catch changes to any d in any subfolder recursively\r\n        //  /a/b/*/d    - Watch /a/b recursively to catch any d in any immediate subfolder, even if a new subfolder is added\r\n        //  /a/b        - Watch /a/b recursively to catch changes to anything in any recursive subfoler\r\n        //\r\n        // We watch a directory without recursion if it contains a wildcard in the file segment of\r\n        // the pattern:\r\n        //\r\n        //  /a/b/*      - Watch /a/b directly to catch any new file\r\n        //  /a/b/a?z    - Watch /a/b directly to catch any new file matching a?z\r\n        const rawExcludeRegex = getRegularExpressionForWildcard(exclude, path, \"exclude\");\r\n        const excludeRegex = rawExcludeRegex && new RegExp(rawExcludeRegex, useCaseSensitiveFileNames ? \"\" : \"i\");\r\n        const wildcardDirectories: MapLike<WatchDirectoryFlags> = {};\r\n        if (include !== undefined) {\r\n            const recursiveKeys: string[] = [];\r\n            for (const file of include) {\r\n                const spec = normalizePath(combinePaths(path, file));\r\n                if (excludeRegex && excludeRegex.test(spec)) {\r\n                    continue;\r\n                }\r\n\r\n                const match = getWildcardDirectoryFromSpec(spec, useCaseSensitiveFileNames);\r\n                if (match) {\r\n                    const { key, flags } = match;\r\n                    const existingFlags = wildcardDirectories[key];\r\n                    if (existingFlags === undefined || existingFlags < flags) {\r\n                        wildcardDirectories[key] = flags;\r\n                        if (flags === WatchDirectoryFlags.Recursive) {\r\n                            recursiveKeys.push(key);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Remove any subpaths under an existing recursively watched directory.\r\n            for (const key in wildcardDirectories) {\r\n                if (hasProperty(wildcardDirectories, key)) {\r\n                    for (const recursiveKey of recursiveKeys) {\r\n                        if (key !== recursiveKey && containsPath(recursiveKey, key, path, !useCaseSensitiveFileNames)) {\r\n                            delete wildcardDirectories[key];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return wildcardDirectories;\r\n    }\r\n\r\n    function getWildcardDirectoryFromSpec(spec: string, useCaseSensitiveFileNames: boolean): { key: string, flags: WatchDirectoryFlags } | undefined {\r\n        const match = wildcardDirectoryPattern.exec(spec);\r\n        if (match) {\r\n            return {\r\n                key: useCaseSensitiveFileNames ? match[0] : match[0].toLowerCase(),\r\n                flags: watchRecursivePattern.test(spec) ? WatchDirectoryFlags.Recursive : WatchDirectoryFlags.None\r\n            };\r\n        }\r\n        if (isImplicitGlob(spec)) {\r\n            return { key: spec, flags: WatchDirectoryFlags.Recursive };\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a literal or wildcard file has already been included that has a higher\r\n     * extension priority.\r\n     *\r\n     * @param file The path to the file.\r\n     * @param extensionPriority The priority of the extension.\r\n     * @param context The expansion context.\r\n     */\r\n    function hasFileWithHigherPriorityExtension(file: string, literalFiles: Map<string>, wildcardFiles: Map<string>, extensions: ReadonlyArray<string>, keyMapper: (value: string) => string) {\r\n        const extensionPriority = getExtensionPriority(file, extensions);\r\n        const adjustedExtensionPriority = adjustExtensionPriority(extensionPriority, extensions);\r\n        for (let i = ExtensionPriority.Highest; i < adjustedExtensionPriority; i++) {\r\n            const higherPriorityExtension = extensions[i];\r\n            const higherPriorityPath = keyMapper(changeExtension(file, higherPriorityExtension));\r\n            if (literalFiles.has(higherPriorityPath) || wildcardFiles.has(higherPriorityPath)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Removes files included via wildcard expansion with a lower extension priority that have\r\n     * already been included.\r\n     *\r\n     * @param file The path to the file.\r\n     * @param extensionPriority The priority of the extension.\r\n     * @param context The expansion context.\r\n     */\r\n    function removeWildcardFilesWithLowerPriorityExtension(file: string, wildcardFiles: Map<string>, extensions: ReadonlyArray<string>, keyMapper: (value: string) => string) {\r\n        const extensionPriority = getExtensionPriority(file, extensions);\r\n        const nextExtensionPriority = getNextLowestExtensionPriority(extensionPriority, extensions);\r\n        for (let i = nextExtensionPriority; i < extensions.length; i++) {\r\n            const lowerPriorityExtension = extensions[i];\r\n            const lowerPriorityPath = keyMapper(changeExtension(file, lowerPriorityExtension));\r\n            wildcardFiles.delete(lowerPriorityPath);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Produces a cleaned version of compiler options with personally identifiying info (aka, paths) removed.\r\n     * Also converts enum values back to strings.\r\n     */\r\n    /* @internal */\r\n    export function convertCompilerOptionsForTelemetry(opts: CompilerOptions): CompilerOptions {\r\n        const out: CompilerOptions = {};\r\n        for (const key in opts) {\r\n            if (opts.hasOwnProperty(key)) {\r\n                const type = getOptionFromName(key);\r\n                if (type !== undefined) { // Ignore unknown options\r\n                    out[key] = getOptionValueWithEmptyStrings(opts[key], type);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function getOptionValueWithEmptyStrings(value: any, option: CommandLineOption): {} {\r\n        switch (option.type) {\r\n            case \"object\": // \"paths\". Can't get any useful information from the value since we blank out strings, so just return \"\".\r\n                return \"\";\r\n            case \"string\": // Could be any arbitrary string -- use empty string instead.\r\n                return \"\";\r\n            case \"number\": // Allow numbers, but be sure to check it's actually a number.\r\n                return typeof value === \"number\" ? value : \"\";\r\n            case \"boolean\":\r\n                return typeof value === \"boolean\" ? value : \"\";\r\n            case \"list\":\r\n                const elementType = (option as CommandLineOptionOfListType).element;\r\n                return isArray(value) ? value.map(v => getOptionValueWithEmptyStrings(v, elementType)) : \"\";\r\n            default:\r\n                return forEachEntry(option.type, (optionEnumValue, optionStringValue) => {\r\n                    if (optionEnumValue === value) {\r\n                        return optionStringValue;\r\n                    }\r\n                });\r\n        }\r\n    }\r\n}\r\n","namespace ts {\r\n    /* @internal */\r\n    export function trace(host: ModuleResolutionHost, message: DiagnosticMessage, ...args: any[]): void;\r\n    export function trace(host: ModuleResolutionHost): void {\r\n        host.trace(formatMessage.apply(undefined, arguments));\r\n    }\r\n\r\n    /* @internal */\r\n    export function isTraceEnabled(compilerOptions: CompilerOptions, host: ModuleResolutionHost): boolean {\r\n        return compilerOptions.traceResolution && host.trace !== undefined;\r\n    }\r\n\r\n    /** Array that is only intended to be pushed to, never read. */\r\n    /* @internal */\r\n    export interface Push<T> {\r\n        push(value: T): void;\r\n    }\r\n\r\n    function withPackageId(packageId: PackageId | undefined, r: PathAndExtension | undefined): Resolved {\r\n        return r && { path: r.path, extension: r.ext, packageId };\r\n    }\r\n\r\n    function noPackageId(r: PathAndExtension | undefined): Resolved {\r\n        return withPackageId(/*packageId*/ undefined, r);\r\n    }\r\n\r\n    /** Result of trying to resolve a module. */\r\n    interface Resolved {\r\n        path: string;\r\n        extension: Extension;\r\n        packageId: PackageId | undefined;\r\n    }\r\n\r\n    /** Result of trying to resolve a module at a file. Needs to have 'packageId' added later. */\r\n    interface PathAndExtension {\r\n        path: string;\r\n        // (Use a different name than `extension` to make sure Resolved isn't assignable to PathAndExtension.)\r\n        ext: Extension;\r\n    }\r\n\r\n    /**\r\n     * Kinds of file that we are currently looking for.\r\n     * Typically there is one pass with Extensions.TypeScript, then a second pass with Extensions.JavaScript.\r\n     */\r\n    enum Extensions {\r\n        TypeScript, /** '.ts', '.tsx', or '.d.ts' */\r\n        JavaScript, /** '.js' or '.jsx' */\r\n        DtsOnly /** Only '.d.ts' */\r\n    }\r\n\r\n    interface PathAndPackageId {\r\n        readonly fileName: string;\r\n        readonly packageId: PackageId;\r\n    }\r\n    /** Used with `Extensions.DtsOnly` to extract the path from TypeScript results. */\r\n    function resolvedTypeScriptOnly(resolved: Resolved | undefined): PathAndPackageId | undefined {\r\n        if (!resolved) {\r\n            return undefined;\r\n        }\r\n        Debug.assert(extensionIsTypeScript(resolved.extension));\r\n        return { fileName: resolved.path, packageId: resolved.packageId };\r\n    }\r\n\r\n    function createResolvedModuleWithFailedLookupLocations(resolved: Resolved | undefined, originalPath: string | undefined, isExternalLibraryImport: boolean, failedLookupLocations: string[]): ResolvedModuleWithFailedLookupLocations {\r\n        return {\r\n            resolvedModule: resolved && { resolvedFileName: resolved.path, originalPath, extension: resolved.extension, isExternalLibraryImport, packageId: resolved.packageId },\r\n            failedLookupLocations\r\n        };\r\n    }\r\n\r\n    interface ModuleResolutionState {\r\n        host: ModuleResolutionHost;\r\n        compilerOptions: CompilerOptions;\r\n        traceEnabled: boolean;\r\n    }\r\n\r\n    /** Just the fields that we use for module resolution. */\r\n    interface PackageJsonPathFields {\r\n        typings?: string;\r\n        types?: string;\r\n        main?: string;\r\n    }\r\n\r\n    interface PackageJson extends PackageJsonPathFields {\r\n        name?: string;\r\n        version?: string;\r\n    }\r\n\r\n    /** Reads from \"main\" or \"types\"/\"typings\" depending on `extensions`. */\r\n    function tryReadPackageJsonFields(readTypes: boolean, jsonContent: PackageJsonPathFields, baseDirectory: string, state: ModuleResolutionState): string | undefined {\r\n        return readTypes ? tryReadFromField(\"typings\") || tryReadFromField(\"types\") : tryReadFromField(\"main\");\r\n\r\n        function tryReadFromField(fieldName: \"typings\" | \"types\" | \"main\"): string | undefined {\r\n            if (!hasProperty(jsonContent, fieldName)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.package_json_does_not_have_a_0_field, fieldName);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const fileName = jsonContent[fieldName];\r\n            if (!isString(fileName)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Expected_type_of_0_field_in_package_json_to_be_string_got_1, fieldName, typeof fileName);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const path = normalizePath(combinePaths(baseDirectory, fileName));\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.package_json_has_0_field_1_that_references_2, fieldName, fileName, path);\r\n            }\r\n            return path;\r\n        }\r\n    }\r\n\r\n    /* @internal */\r\n    export function readJson(path: string, host: { readFile(fileName: string): string | undefined }): object {\r\n        try {\r\n            const jsonText = host.readFile(path);\r\n            return jsonText ? JSON.parse(jsonText) : {};\r\n        }\r\n        catch (e) {\r\n            // gracefully handle if readFile fails or returns not JSON\r\n            return {};\r\n        }\r\n    }\r\n\r\n    export interface GetEffectiveTypeRootsHost {\r\n        directoryExists?(directoryName: string): boolean;\r\n        getCurrentDirectory?(): string;\r\n    }\r\n    export function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined {\r\n        if (options.typeRoots) {\r\n            return options.typeRoots;\r\n        }\r\n\r\n        let currentDirectory: string;\r\n        if (options.configFilePath) {\r\n            currentDirectory = getDirectoryPath(options.configFilePath);\r\n        }\r\n        else if (host.getCurrentDirectory) {\r\n            currentDirectory = host.getCurrentDirectory();\r\n        }\r\n\r\n        if (currentDirectory !== undefined) {\r\n            return getDefaultTypeRoots(currentDirectory, host);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the path to every node_modules/@types directory from some ancestor directory.\r\n     * Returns undefined if there are none.\r\n     */\r\n    function getDefaultTypeRoots(currentDirectory: string, host: { directoryExists?: (directoryName: string) => boolean }): string[] | undefined {\r\n        if (!host.directoryExists) {\r\n            return [combinePaths(currentDirectory, nodeModulesAtTypes)];\r\n            // And if it doesn't exist, tough.\r\n        }\r\n\r\n        let typeRoots: string[];\r\n        forEachAncestorDirectory(normalizePath(currentDirectory), directory => {\r\n            const atTypes = combinePaths(directory, nodeModulesAtTypes);\r\n            if (host.directoryExists(atTypes)) {\r\n                (typeRoots || (typeRoots = [])).push(atTypes);\r\n            }\r\n            return undefined;\r\n        });\r\n        return typeRoots;\r\n    }\r\n    const nodeModulesAtTypes = combinePaths(\"node_modules\", \"@types\");\r\n\r\n    /**\r\n     * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\r\n     * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\r\n     * is assumed to be the same as root directory of the project.\r\n     */\r\n    export function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost): ResolvedTypeReferenceDirectiveWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(options, host);\r\n        const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled };\r\n\r\n        const typeRoots = getEffectiveTypeRoots(options, host);\r\n        if (traceEnabled) {\r\n            if (containingFile === undefined) {\r\n                if (typeRoots === undefined) {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set, typeReferenceDirectiveName);\r\n                }\r\n                else {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1, typeReferenceDirectiveName, typeRoots);\r\n                }\r\n            }\r\n            else {\r\n                if (typeRoots === undefined) {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set, typeReferenceDirectiveName, containingFile);\r\n                }\r\n                else {\r\n                    trace(host, Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_2, typeReferenceDirectiveName, containingFile, typeRoots);\r\n                }\r\n            }\r\n        }\r\n\r\n        const failedLookupLocations: string[] = [];\r\n\r\n        let resolved = primaryLookup();\r\n        let primary = true;\r\n        if (!resolved) {\r\n            resolved = secondaryLookup();\r\n            primary = false;\r\n        }\r\n\r\n        let resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;\r\n        if (resolved) {\r\n            if (!options.preserveSymlinks) {\r\n                resolved = { ...resolved, fileName: realPath(resolved.fileName, host, traceEnabled) };\r\n            }\r\n\r\n            if (traceEnabled) {\r\n                trace(host, Diagnostics.Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2, typeReferenceDirectiveName, resolved.fileName, primary);\r\n            }\r\n            resolvedTypeReferenceDirective = { primary, resolvedFileName: resolved.fileName, packageId: resolved.packageId };\r\n        }\r\n\r\n        return { resolvedTypeReferenceDirective, failedLookupLocations };\r\n\r\n        function primaryLookup(): PathAndPackageId | undefined {\r\n            // Check primary library paths\r\n            if (typeRoots && typeRoots.length) {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Resolving_with_primary_search_path_0, typeRoots.join(\", \"));\r\n                }\r\n                return forEach(typeRoots, typeRoot => {\r\n                    const candidate = combinePaths(typeRoot, typeReferenceDirectiveName);\r\n                    const candidateDirectory = getDirectoryPath(candidate);\r\n                    const directoryExists = directoryProbablyExists(candidateDirectory, host);\r\n                    if (!directoryExists && traceEnabled) {\r\n                        trace(host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);\r\n                    }\r\n                    return resolvedTypeScriptOnly(\r\n                        loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, failedLookupLocations,\r\n                            !directoryExists, moduleResolutionState));\r\n                });\r\n            }\r\n            else {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Root_directory_cannot_be_determined_skipping_primary_search_paths);\r\n                }\r\n            }\r\n        }\r\n\r\n        function secondaryLookup(): PathAndPackageId | undefined {\r\n            let resolvedFile: PathAndPackageId;\r\n            const initialLocationForSecondaryLookup = containingFile && getDirectoryPath(containingFile);\r\n\r\n            if (initialLocationForSecondaryLookup !== undefined) {\r\n                // check secondary locations\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Looking_up_in_node_modules_folder_initial_location_0, initialLocationForSecondaryLookup);\r\n                }\r\n                const result = loadModuleFromNodeModules(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, failedLookupLocations, moduleResolutionState, /*cache*/ undefined);\r\n                resolvedFile = resolvedTypeScriptOnly(result && result.value);\r\n                if (!resolvedFile && traceEnabled) {\r\n                    trace(host, Diagnostics.Type_reference_directive_0_was_not_resolved, typeReferenceDirectiveName);\r\n                }\r\n                return resolvedFile;\r\n            }\r\n            else {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a set of options, returns the set of type directive names\r\n     *   that should be included for this program automatically.\r\n     * This list could either come from the config file,\r\n     *   or from enumerating the types root + initial secondary types lookup location.\r\n     * More type directives might appear in the program later as a result of loading actual source files;\r\n     *   this list is only the set of defaults that are implicitly included.\r\n     */\r\n    export function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[] {\r\n        // Use explicit type list from tsconfig.json\r\n        if (options.types) {\r\n            return options.types;\r\n        }\r\n\r\n        // Walk the primary type lookup locations\r\n        const result: string[] = [];\r\n        if (host.directoryExists && host.getDirectories) {\r\n            const typeRoots = getEffectiveTypeRoots(options, host);\r\n            if (typeRoots) {\r\n                for (const root of typeRoots) {\r\n                    if (host.directoryExists(root)) {\r\n                        for (const typeDirectivePath of host.getDirectories(root)) {\r\n                            const normalized = normalizePath(typeDirectivePath);\r\n                            const packageJsonPath = pathToPackageJson(combinePaths(root, normalized));\r\n                            // `types-publisher` sometimes creates packages with `\"typings\": null` for packages that don't provide their own types.\r\n                            // See `createNotNeededPackageJSON` in the types-publisher` repo.\r\n                            // tslint:disable-next-line:no-null-keyword\r\n                            const isNotNeededPackage = host.fileExists(packageJsonPath) && (readJson(packageJsonPath, host) as PackageJson).typings === null;\r\n                            if (!isNotNeededPackage) {\r\n                                // Return just the type directive names\r\n                                result.push(getBaseFileName(normalized));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Cached module resolutions per containing directory.\r\n     * This assumes that any module id will have the same resolution for sibling files located in the same folder.\r\n     */\r\n    export interface ModuleResolutionCache extends NonRelativeModuleNameResolutionCache {\r\n        getOrCreateCacheForDirectory(directoryName: string): Map<ResolvedModuleWithFailedLookupLocations>;\r\n    }\r\n\r\n    /**\r\n     * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory\r\n     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.\r\n     */\r\n    export interface NonRelativeModuleNameResolutionCache {\r\n        getOrCreateCacheForModuleName(nonRelativeModuleName: string): PerModuleNameCache;\r\n    }\r\n\r\n    export interface PerModuleNameCache {\r\n        get(directory: string): ResolvedModuleWithFailedLookupLocations;\r\n        set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;\r\n    }\r\n\r\n    export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string): ModuleResolutionCache {\r\n        return createModuleResolutionCacheWithMaps(\r\n            createMap<Map<ResolvedModuleWithFailedLookupLocations>>(),\r\n            createMap<PerModuleNameCache>(),\r\n            currentDirectory,\r\n            getCanonicalFileName\r\n        );\r\n    }\r\n\r\n    /*@internal*/\r\n    export function createModuleResolutionCacheWithMaps(\r\n        directoryToModuleNameMap: Map<Map<ResolvedModuleWithFailedLookupLocations>>,\r\n        moduleNameToDirectoryMap: Map<PerModuleNameCache>,\r\n        currentDirectory: string,\r\n        getCanonicalFileName: GetCanonicalFileName): ModuleResolutionCache {\r\n\r\n        return { getOrCreateCacheForDirectory, getOrCreateCacheForModuleName };\r\n\r\n        function getOrCreateCacheForDirectory(directoryName: string) {\r\n            const path = toPath(directoryName, currentDirectory, getCanonicalFileName);\r\n            let perFolderCache = directoryToModuleNameMap.get(path);\r\n            if (!perFolderCache) {\r\n                perFolderCache = createMap<ResolvedModuleWithFailedLookupLocations>();\r\n                directoryToModuleNameMap.set(path, perFolderCache);\r\n            }\r\n            return perFolderCache;\r\n        }\r\n\r\n        function getOrCreateCacheForModuleName(nonRelativeModuleName: string) {\r\n            if (isExternalModuleNameRelative(nonRelativeModuleName)) {\r\n                return undefined;\r\n            }\r\n            let perModuleNameCache = moduleNameToDirectoryMap.get(nonRelativeModuleName);\r\n            if (!perModuleNameCache) {\r\n                perModuleNameCache = createPerModuleNameCache();\r\n                moduleNameToDirectoryMap.set(nonRelativeModuleName, perModuleNameCache);\r\n            }\r\n            return perModuleNameCache;\r\n        }\r\n\r\n        function createPerModuleNameCache(): PerModuleNameCache {\r\n            const directoryPathMap = createMap<ResolvedModuleWithFailedLookupLocations>();\r\n\r\n            return { get, set };\r\n\r\n            function get(directory: string): ResolvedModuleWithFailedLookupLocations {\r\n                return directoryPathMap.get(toPath(directory, currentDirectory, getCanonicalFileName));\r\n            }\r\n\r\n            /**\r\n             * At first this function add entry directory -> module resolution result to the table.\r\n             * Then it computes the set of parent folders for 'directory' that should have the same module resolution result\r\n             * and for every parent folder in set it adds entry: parent -> module resolution. .\r\n             * Lets say we first directory name: /a/b/c/d/e and resolution result is: /a/b/bar.ts.\r\n             * Set of parent folders that should have the same result will be:\r\n             * [\r\n             *     /a/b/c/d, /a/b/c, /a/b\r\n             * ]\r\n             * this means that request for module resolution from file in any of these folder will be immediately found in cache.\r\n             */\r\n            function set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void {\r\n                const path = toPath(directory, currentDirectory, getCanonicalFileName);\r\n                // if entry is already in cache do nothing\r\n                if (directoryPathMap.has(path)) {\r\n                    return;\r\n                }\r\n                directoryPathMap.set(path, result);\r\n\r\n                const resolvedFileName = result.resolvedModule && result.resolvedModule.resolvedFileName;\r\n                // find common prefix between directory and resolved file name\r\n                // this common prefix should be the shorted path that has the same resolution\r\n                // directory: /a/b/c/d/e\r\n                // resolvedFileName: /a/b/foo.d.ts\r\n                const commonPrefix = getCommonPrefix(path, resolvedFileName);\r\n                let current = path;\r\n                while (true) {\r\n                    const parent = getDirectoryPath(current);\r\n                    if (parent === current || directoryPathMap.has(parent)) {\r\n                        break;\r\n                    }\r\n                    directoryPathMap.set(parent, result);\r\n                    current = parent;\r\n\r\n                    if (current === commonPrefix) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function getCommonPrefix(directory: Path, resolution: string) {\r\n                if (resolution === undefined) {\r\n                    return undefined;\r\n                }\r\n                const resolutionDirectory = toPath(getDirectoryPath(resolution), currentDirectory, getCanonicalFileName);\r\n\r\n                // find first position where directory and resolution differs\r\n                let i = 0;\r\n                while (i < Math.min(directory.length, resolutionDirectory.length) && directory.charCodeAt(i) === resolutionDirectory.charCodeAt(i)) {\r\n                    i++;\r\n                }\r\n\r\n                // find last directory separator before position i\r\n                const sep = directory.lastIndexOf(directorySeparator, i);\r\n                if (sep < 0) {\r\n                    return undefined;\r\n                }\r\n\r\n                return directory.substr(0, sep);\r\n            }\r\n        }\r\n    }\r\n\r\n    export function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations | undefined {\r\n        const containingDirectory = getDirectoryPath(containingFile);\r\n        const perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);\r\n        return perFolderCache && perFolderCache.get(moduleName);\r\n    }\r\n\r\n    export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n        if (traceEnabled) {\r\n            trace(host, Diagnostics.Resolving_module_0_from_1, moduleName, containingFile);\r\n        }\r\n        const containingDirectory = getDirectoryPath(containingFile);\r\n        const perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);\r\n        let result = perFolderCache && perFolderCache.get(moduleName);\r\n\r\n        if (result) {\r\n            if (traceEnabled) {\r\n                trace(host, Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);\r\n            }\r\n        }\r\n        else {\r\n            let moduleResolution = compilerOptions.moduleResolution;\r\n            if (moduleResolution === undefined) {\r\n                moduleResolution = getEmitModuleKind(compilerOptions) === ModuleKind.CommonJS ? ModuleResolutionKind.NodeJs : ModuleResolutionKind.Classic;\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Module_resolution_kind_is_not_specified_using_0, ModuleResolutionKind[moduleResolution]);\r\n                }\r\n            }\r\n            else {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Explicitly_specified_module_resolution_kind_Colon_0, ModuleResolutionKind[moduleResolution]);\r\n                }\r\n            }\r\n\r\n            switch (moduleResolution) {\r\n                case ModuleResolutionKind.NodeJs:\r\n                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache);\r\n                    break;\r\n                case ModuleResolutionKind.Classic:\r\n                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache);\r\n                    break;\r\n                default:\r\n                    Debug.fail(`Unexpected moduleResolution: ${moduleResolution}`);\r\n            }\r\n\r\n            if (perFolderCache) {\r\n                perFolderCache.set(moduleName, result);\r\n                // put result in per-module name cache\r\n                const perModuleNameCache = cache.getOrCreateCacheForModuleName(moduleName);\r\n                if (perModuleNameCache) {\r\n                    perModuleNameCache.set(containingDirectory, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (traceEnabled) {\r\n            if (result.resolvedModule) {\r\n                trace(host, Diagnostics.Module_name_0_was_successfully_resolved_to_1, moduleName, result.resolvedModule.resolvedFileName);\r\n            }\r\n            else {\r\n                trace(host, Diagnostics.Module_name_0_was_not_resolved, moduleName);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /*\r\n     * Every module resolution kind can has its specific understanding how to load module from a specific path on disk\r\n     * I.e. for path '/a/b/c':\r\n     * - Node loader will first to try to check if '/a/b/c' points to a file with some supported extension and if this fails\r\n     * it will try to load module from directory: directory '/a/b/c' should exist and it should have either 'package.json' with\r\n     * 'typings' entry or file 'index' with some supported extension\r\n     * - Classic loader will only try to interpret '/a/b/c' as file.\r\n     */\r\n    type ResolutionKindSpecificLoader = (extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState) => Resolved | undefined;\r\n\r\n    /**\r\n     * Any module resolution kind can be augmented with optional settings: 'baseUrl', 'paths' and 'rootDirs' - they are used to\r\n     * mitigate differences between design time structure of the project and its runtime counterpart so the same import name\r\n     * can be resolved successfully by TypeScript compiler and runtime module loader.\r\n     * If these settings are set then loading procedure will try to use them to resolve module name and it can of failure it will\r\n     * fallback to standard resolution routine.\r\n     *\r\n     * - baseUrl - this setting controls how non-relative module names are resolved. If this setting is specified then non-relative\r\n     * names will be resolved relative to baseUrl: i.e. if baseUrl is '/a/b' then candidate location to resolve module name 'c/d' will\r\n     * be '/a/b/c/d'\r\n     * - paths - this setting can only be used when baseUrl is specified. allows to tune how non-relative module names\r\n     * will be resolved based on the content of the module name.\r\n     * Structure of 'paths' compiler options\r\n     * 'paths': {\r\n     *    pattern-1: [...substitutions],\r\n     *    pattern-2: [...substitutions],\r\n     *    ...\r\n     *    pattern-n: [...substitutions]\r\n     * }\r\n     * Pattern here is a string that can contain zero or one '*' character. During module resolution module name will be matched against\r\n     * all patterns in the list. Matching for patterns that don't contain '*' means that module name must be equal to pattern respecting the case.\r\n     * If pattern contains '*' then to match pattern \"<prefix>*<suffix>\" module name must start with the <prefix> and end with <suffix>.\r\n     * <MatchedStar> denotes part of the module name between <prefix> and <suffix>.\r\n     * If module name can be matches with multiple patterns then pattern with the longest prefix will be picked.\r\n     * After selecting pattern we'll use list of substitutions to get candidate locations of the module and the try to load module\r\n     * from the candidate location.\r\n     * Substitution is a string that can contain zero or one '*'. To get candidate location from substitution we'll pick every\r\n     * substitution in the list and replace '*' with <MatchedStar> string. If candidate location is not rooted it\r\n     * will be converted to absolute using baseUrl.\r\n     * For example:\r\n     * baseUrl: /a/b/c\r\n     * \"paths\": {\r\n     *     // match all module names\r\n     *     \"*\": [\r\n     *         \"*\",        // use matched name as is,\r\n     *                     // <matched name> will be looked as /a/b/c/<matched name>\r\n     *\r\n     *         \"folder1/*\" // substitution will convert matched name to 'folder1/<matched name>',\r\n     *                     // since it is not rooted then final candidate location will be /a/b/c/folder1/<matched name>\r\n     *     ],\r\n     *     // match module names that start with 'components/'\r\n     *     \"components/*\": [ \"/root/components/*\" ] // substitution will convert /components/folder1/<matched name> to '/root/components/folder1/<matched name>',\r\n     *                                              // it is rooted so it will be final candidate location\r\n     * }\r\n     *\r\n     * 'rootDirs' allows the project to be spreaded across multiple locations and resolve modules with relative names as if\r\n     * they were in the same location. For example lets say there are two files\r\n     * '/local/src/content/file1.ts'\r\n     * '/shared/components/contracts/src/content/protocols/file2.ts'\r\n     * After bundling content of '/shared/components/contracts/src' will be merged with '/local/src' so\r\n     * if file1 has the following import 'import {x} from \"./protocols/file2\"' it will be resolved successfully in runtime.\r\n     * 'rootDirs' provides the way to tell compiler that in order to get the whole project it should behave as if content of all\r\n     * root dirs were merged together.\r\n     * I.e. for the example above 'rootDirs' will have two entries: [ '/local/src', '/shared/components/contracts/src' ].\r\n     * Compiler will first convert './protocols/file2' into absolute path relative to the location of containing file:\r\n     * '/local/src/content/protocols/file2' and try to load it - failure.\r\n     * Then it will search 'rootDirs' looking for a longest matching prefix of this absolute path and if such prefix is found - absolute path will\r\n     * be converted to a path relative to found rootDir entry './content/protocols/file2' (*). As a last step compiler will check all remaining\r\n     * entries in 'rootDirs', use them to build absolute path out of (*) and try to resolve module from this location.\r\n     */\r\n    function tryLoadModuleUsingOptionalResolutionSettings(extensions: Extensions, moduleName: string, containingDirectory: string, loader: ResolutionKindSpecificLoader,\r\n        failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n\r\n        if (!isExternalModuleNameRelative(moduleName)) {\r\n            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, failedLookupLocations, state);\r\n        }\r\n        else {\r\n            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, failedLookupLocations, state);\r\n        }\r\n    }\r\n\r\n    function tryLoadModuleUsingRootDirs(extensions: Extensions, moduleName: string, containingDirectory: string, loader: ResolutionKindSpecificLoader,\r\n        failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n\r\n        if (!state.compilerOptions.rootDirs) {\r\n            return undefined;\r\n        }\r\n\r\n        if (state.traceEnabled) {\r\n            trace(state.host, Diagnostics.rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0, moduleName);\r\n        }\r\n\r\n        const candidate = normalizePath(combinePaths(containingDirectory, moduleName));\r\n\r\n        let matchedRootDir: string;\r\n        let matchedNormalizedPrefix: string;\r\n        for (const rootDir of state.compilerOptions.rootDirs) {\r\n            // rootDirs are expected to be absolute\r\n            // in case of tsconfig.json this will happen automatically - compiler will expand relative names\r\n            // using location of tsconfig.json as base location\r\n            let normalizedRoot = normalizePath(rootDir);\r\n            if (!endsWith(normalizedRoot, directorySeparator)) {\r\n                normalizedRoot += directorySeparator;\r\n            }\r\n            const isLongestMatchingPrefix =\r\n                startsWith(candidate, normalizedRoot) &&\r\n                (matchedNormalizedPrefix === undefined || matchedNormalizedPrefix.length < normalizedRoot.length);\r\n\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Checking_if_0_is_the_longest_matching_prefix_for_1_2, normalizedRoot, candidate, isLongestMatchingPrefix);\r\n            }\r\n\r\n            if (isLongestMatchingPrefix) {\r\n                matchedNormalizedPrefix = normalizedRoot;\r\n                matchedRootDir = rootDir;\r\n            }\r\n        }\r\n        if (matchedNormalizedPrefix) {\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Longest_matching_prefix_for_0_is_1, candidate, matchedNormalizedPrefix);\r\n            }\r\n            const suffix = candidate.substr(matchedNormalizedPrefix.length);\r\n\r\n            // first - try to load from a initial location\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);\r\n            }\r\n            const resolvedFileName = loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(containingDirectory, state.host), state);\r\n            if (resolvedFileName) {\r\n                return resolvedFileName;\r\n            }\r\n\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Trying_other_entries_in_rootDirs);\r\n            }\r\n            // then try to resolve using remaining entries in rootDirs\r\n            for (const rootDir of state.compilerOptions.rootDirs) {\r\n                if (rootDir === matchedRootDir) {\r\n                    // skip the initially matched entry\r\n                    continue;\r\n                }\r\n                const candidate = combinePaths(normalizePath(rootDir), suffix);\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate);\r\n                }\r\n                const baseDirectory = getDirectoryPath(candidate);\r\n                const resolvedFileName = loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(baseDirectory, state.host), state);\r\n                if (resolvedFileName) {\r\n                    return resolvedFileName;\r\n                }\r\n            }\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Module_resolution_using_rootDirs_has_failed);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    function tryLoadModuleUsingBaseUrl(extensions: Extensions, moduleName: string, loader: ResolutionKindSpecificLoader, failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n        if (!state.compilerOptions.baseUrl) {\r\n            return undefined;\r\n        }\r\n        if (state.traceEnabled) {\r\n            trace(state.host, Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, state.compilerOptions.baseUrl, moduleName);\r\n        }\r\n\r\n        // string is for exact match\r\n        let matchedPattern: Pattern | string | undefined;\r\n        if (state.compilerOptions.paths) {\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);\r\n            }\r\n            matchedPattern = matchPatternOrExact(getOwnKeys(state.compilerOptions.paths), moduleName);\r\n        }\r\n\r\n        if (matchedPattern) {\r\n            const matchedStar = isString(matchedPattern) ? undefined : matchedText(matchedPattern, moduleName);\r\n            const matchedPatternText = isString(matchedPattern) ? matchedPattern : patternText(matchedPattern);\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Module_name_0_matched_pattern_1, moduleName, matchedPatternText);\r\n            }\r\n            return forEach(state.compilerOptions.paths[matchedPatternText], subst => {\r\n                const path = matchedStar ? subst.replace(\"*\", matchedStar) : subst;\r\n                const candidate = normalizePath(combinePaths(state.compilerOptions.baseUrl, path));\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Trying_substitution_0_candidate_module_location_Colon_1, subst, path);\r\n                }\r\n                // A path mapping may have an extension, in contrast to an import, which should omit it.\r\n                const extension = tryGetExtensionFromPath(candidate);\r\n                if (extension !== undefined) {\r\n                    const path = tryFile(candidate, failedLookupLocations, /*onlyRecordFailures*/ false, state);\r\n                    if (path !== undefined) {\r\n                        return noPackageId({ path, ext: extension });\r\n                    }\r\n                }\r\n\r\n                return loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(getDirectoryPath(candidate), state.host), state);\r\n            });\r\n        }\r\n        else {\r\n            const candidate = normalizePath(combinePaths(state.compilerOptions.baseUrl, moduleName));\r\n\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, state.compilerOptions.baseUrl, candidate);\r\n            }\r\n\r\n            return loader(extensions, candidate, failedLookupLocations, !directoryProbablyExists(getDirectoryPath(candidate), state.host), state);\r\n        }\r\n    }\r\n\r\n    export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations {\r\n        return nodeModuleNameResolverWorker(moduleName, getDirectoryPath(containingFile), compilerOptions, host, cache, /*jsOnly*/ false);\r\n    }\r\n\r\n    /**\r\n     * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.\r\n     * No way to do this with `require()`: https://github.com/nodejs/node/issues/5963\r\n     * Throws an error if the module can't be resolved.\r\n     */\r\n    /* @internal */\r\n    export function resolveJavaScriptModule(moduleName: string, initialDir: string, host: ModuleResolutionHost): string {\r\n        const { resolvedModule, failedLookupLocations } =\r\n            nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, /*jsOnly*/ true);\r\n        if (!resolvedModule) {\r\n            throw new Error(`Could not resolve JS module '${moduleName}' starting at '${initialDir}'. Looked in: ${failedLookupLocations.join(\", \")}`);\r\n        }\r\n        return resolvedModule.resolvedFileName;\r\n    }\r\n\r\n    function nodeModuleNameResolverWorker(moduleName: string, containingDirectory: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache: ModuleResolutionCache | undefined, jsOnly: boolean): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n\r\n        const failedLookupLocations: string[] = [];\r\n        const state: ModuleResolutionState = { compilerOptions, host, traceEnabled };\r\n\r\n        const result = jsOnly ? tryResolve(Extensions.JavaScript) : (tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript));\r\n        if (result && result.value) {\r\n            const { resolved, originalPath, isExternalLibraryImport } = result.value;\r\n            return createResolvedModuleWithFailedLookupLocations(resolved, originalPath, isExternalLibraryImport, failedLookupLocations);\r\n        }\r\n        return { resolvedModule: undefined, failedLookupLocations };\r\n\r\n        function tryResolve(extensions: Extensions): SearchResult<{ resolved: Resolved, originalPath?: string, isExternalLibraryImport: boolean }> {\r\n            const loader: ResolutionKindSpecificLoader = (extensions, candidate, failedLookupLocations, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, failedLookupLocations, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n            const resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, failedLookupLocations, state);\r\n            if (resolved) {\r\n                return toSearchResult({ resolved, isExternalLibraryImport: false });\r\n            }\r\n\r\n            if (!isExternalModuleNameRelative(moduleName)) {\r\n                if (traceEnabled) {\r\n                    trace(host, Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\r\n                }\r\n                const resolved = loadModuleFromNodeModules(extensions, moduleName, containingDirectory, failedLookupLocations, state, cache);\r\n                if (!resolved) return undefined;\r\n\r\n                let resolvedValue = resolved.value;\r\n                let originalPath: string | undefined;\r\n                if (!compilerOptions.preserveSymlinks && resolvedValue) {\r\n                    originalPath = resolvedValue.path;\r\n                    const path = realPath(resolved.value.path, host, traceEnabled);\r\n                    if (path === originalPath) {\r\n                        originalPath = undefined;\r\n                    }\r\n                    resolvedValue = { ...resolvedValue, path };\r\n                }\r\n                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\r\n                return { value: resolvedValue && { resolved: resolvedValue, originalPath, isExternalLibraryImport: true } };\r\n            }\r\n            else {\r\n                const { path: candidate, parts } = normalizePathAndParts(combinePaths(containingDirectory, moduleName));\r\n                const resolved = nodeLoadModuleByRelativeName(extensions, candidate, failedLookupLocations, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);\r\n                // Treat explicit \"node_modules\" import as an external library import.\r\n                return resolved && toSearchResult({ resolved, isExternalLibraryImport: contains(parts, \"node_modules\") });\r\n            }\r\n        }\r\n    }\r\n\r\n    function realPath(path: string, host: ModuleResolutionHost, traceEnabled: boolean): string {\r\n        if (!host.realpath) {\r\n            return path;\r\n        }\r\n\r\n        const real = normalizePath(host.realpath(path));\r\n        if (traceEnabled) {\r\n            trace(host, Diagnostics.Resolving_real_path_for_0_result_1, path, real);\r\n        }\r\n        Debug.assert(host.fileExists(real), `${path} linked to nonexistent file ${real}`); // tslint:disable-line\r\n        return real;\r\n    }\r\n\r\n    function nodeLoadModuleByRelativeName(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState, considerPackageJson: boolean): Resolved | undefined {\r\n        if (state.traceEnabled) {\r\n            trace(state.host, Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);\r\n        }\r\n        if (!pathEndsWithDirectorySeparator(candidate)) {\r\n            if (!onlyRecordFailures) {\r\n                const parentOfCandidate = getDirectoryPath(candidate);\r\n                if (!directoryProbablyExists(parentOfCandidate, state.host)) {\r\n                    if (state.traceEnabled) {\r\n                        trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, parentOfCandidate);\r\n                    }\r\n                    onlyRecordFailures = true;\r\n                }\r\n            }\r\n            const resolvedFromFile = loadModuleFromFile(extensions, candidate, failedLookupLocations, onlyRecordFailures, state);\r\n            if (resolvedFromFile) {\r\n                const nm = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile) : undefined;\r\n                const packageId = nm && getPackageJsonInfo(nm.packageDirectory, nm.subModuleName, failedLookupLocations, /*onlyRecordFailures*/ false, state).packageId;\r\n                return withPackageId(packageId, resolvedFromFile);\r\n            }\r\n        }\r\n        if (!onlyRecordFailures) {\r\n            const candidateExists = directoryProbablyExists(candidate, state.host);\r\n            if (!candidateExists) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidate);\r\n                }\r\n                onlyRecordFailures = true;\r\n            }\r\n        }\r\n        return loadNodeModuleFromDirectory(extensions, candidate, failedLookupLocations, onlyRecordFailures, state, considerPackageJson);\r\n    }\r\n\r\n    const nodeModulesPathPart = \"/node_modules/\";\r\n\r\n    /**\r\n     * This will be called on the successfully resolved path from `loadModuleFromFile`.\r\n     * (Not neeeded for `loadModuleFromNodeModules` as that looks up the `package.json` as part of resolution.)\r\n     *\r\n     * packageDirectory is the directory of the package itself.\r\n     * subModuleName is the path within the package.\r\n     *   For `blah/node_modules/foo/index.d.ts` this is { packageDirectory: \"foo\", subModuleName: \"index.d.ts\" }. (Part before \"/node_modules/\" is ignored.)\r\n     *   For `/node_modules/foo/bar.d.ts` this is { packageDirectory: \"foo\", subModuleName\": \"bar/index.d.ts\" }.\r\n     *   For `/node_modules/@types/foo/bar/index.d.ts` this is { packageDirectory: \"@types/foo\", subModuleName: \"bar/index.d.ts\" }.\r\n     *   For `/node_modules/foo/bar/index.d.ts` this is { packageDirectory: \"foo\", subModuleName\": \"bar/index.d.ts\" }.\r\n     */\r\n    function parseNodeModuleFromPath(resolved: PathAndExtension): { packageDirectory: string, subModuleName: string } | undefined {\r\n        const path = normalizePath(resolved.path);\r\n        const idx = path.lastIndexOf(nodeModulesPathPart);\r\n        if (idx === -1) {\r\n            return undefined;\r\n        }\r\n\r\n        const indexAfterNodeModules = idx + nodeModulesPathPart.length;\r\n        let indexAfterPackageName = moveToNextDirectorySeparatorIfAvailable(path, indexAfterNodeModules);\r\n        if (path.charCodeAt(indexAfterNodeModules) === CharacterCodes.at) {\r\n            indexAfterPackageName = moveToNextDirectorySeparatorIfAvailable(path, indexAfterPackageName);\r\n        }\r\n        const packageDirectory = path.slice(0, indexAfterPackageName);\r\n        const subModuleName = removeExtension(path.slice(indexAfterPackageName + 1), resolved.ext) + Extension.Dts;\r\n        return { packageDirectory, subModuleName };\r\n    }\r\n\r\n    function moveToNextDirectorySeparatorIfAvailable(path: string, prevSeparatorIndex: number): number {\r\n        const nextSeparatorIndex = path.indexOf(directorySeparator, prevSeparatorIndex + 1);\r\n        return nextSeparatorIndex === -1 ? prevSeparatorIndex : nextSeparatorIndex;\r\n    }\r\n\r\n    function addExtensionAndIndex(path: string): string {\r\n        if (path === \"\") {\r\n            return \"index.d.ts\";\r\n        }\r\n        if (endsWith(path, \".d.ts\")) {\r\n            return path;\r\n        }\r\n        if (endsWith(path, \"/index\")) {\r\n            return path + \".d.ts\";\r\n        }\r\n        return path + \"/index.d.ts\";\r\n    }\r\n\r\n    /* @internal */\r\n    export function directoryProbablyExists(directoryName: string, host: { directoryExists?: (directoryName: string) => boolean }): boolean {\r\n        // if host does not support 'directoryExists' assume that directory will exist\r\n        return !host.directoryExists || host.directoryExists(directoryName);\r\n    }\r\n\r\n    function loadModuleFromFileNoPackageId(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): Resolved {\r\n        return noPackageId(loadModuleFromFile(extensions, candidate, failedLookupLocations, onlyRecordFailures, state));\r\n    }\r\n\r\n    /**\r\n     * @param {boolean} onlyRecordFailures - if true then function won't try to actually load files but instead record all attempts as failures. This flag is necessary\r\n     * in cases when we know upfront that all load attempts will fail (because containing folder does not exists) however we still need to record all failed lookup locations.\r\n     */\r\n    function loadModuleFromFile(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): PathAndExtension | undefined {\r\n        // First, try adding an extension. An import of \"foo\" could be matched by a file \"foo.ts\", or \"foo.js\" by \"foo.js.ts\"\r\n        const resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, failedLookupLocations, onlyRecordFailures, state);\r\n        if (resolvedByAddingExtension) {\r\n            return resolvedByAddingExtension;\r\n        }\r\n\r\n        // If that didn't work, try stripping a \".js\" or \".jsx\" extension and replacing it with a TypeScript one;\r\n        // e.g. \"./foo.js\" can be matched by \"./foo.ts\" or \"./foo.d.ts\"\r\n        if (hasJavaScriptFileExtension(candidate)) {\r\n            const extensionless = removeFileExtension(candidate);\r\n            if (state.traceEnabled) {\r\n                const extension = candidate.substring(extensionless.length);\r\n                trace(state.host, Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);\r\n            }\r\n            return tryAddingExtensions(extensionless, extensions, failedLookupLocations, onlyRecordFailures, state);\r\n        }\r\n    }\r\n\r\n    /** Try to return an existing file that adds one of the `extensions` to `candidate`. */\r\n    function tryAddingExtensions(candidate: string, extensions: Extensions, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): PathAndExtension | undefined {\r\n        if (!onlyRecordFailures) {\r\n            // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing\r\n            const directory = getDirectoryPath(candidate);\r\n            if (directory) {\r\n                onlyRecordFailures = !directoryProbablyExists(directory, state.host);\r\n            }\r\n        }\r\n\r\n        switch (extensions) {\r\n            case Extensions.DtsOnly:\r\n                return tryExtension(Extension.Dts);\r\n            case Extensions.TypeScript:\r\n                return tryExtension(Extension.Ts) || tryExtension(Extension.Tsx) || tryExtension(Extension.Dts);\r\n            case Extensions.JavaScript:\r\n                return tryExtension(Extension.Js) || tryExtension(Extension.Jsx);\r\n        }\r\n\r\n        function tryExtension(ext: Extension): PathAndExtension | undefined {\r\n            const path = tryFile(candidate + ext, failedLookupLocations, onlyRecordFailures, state);\r\n            return path && { path, ext };\r\n        }\r\n    }\r\n\r\n    /** Return the file if it exists. */\r\n    function tryFile(fileName: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState): string | undefined {\r\n        if (!onlyRecordFailures) {\r\n            if (state.host.fileExists(fileName)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.File_0_exist_use_it_as_a_name_resolution_result, fileName);\r\n                }\r\n                return fileName;\r\n            }\r\n            else {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.File_0_does_not_exist, fileName);\r\n                }\r\n            }\r\n        }\r\n        failedLookupLocations.push(fileName);\r\n        return undefined;\r\n    }\r\n\r\n    function loadNodeModuleFromDirectory(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState, considerPackageJson = true) {\r\n        const { packageJsonContent, packageId } = considerPackageJson\r\n            ? getPackageJsonInfo(candidate, \"\", failedLookupLocations, onlyRecordFailures, state)\r\n            : { packageJsonContent: undefined, packageId: undefined };\r\n        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, failedLookupLocations, onlyRecordFailures, state, packageJsonContent));\r\n    }\r\n\r\n    function loadNodeModuleFromDirectoryWorker(extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, onlyRecordFailures: boolean, state: ModuleResolutionState, packageJsonContent: PackageJsonPathFields | undefined): PathAndExtension | undefined {\r\n        const fromPackageJson = packageJsonContent && loadModuleFromPackageJson(packageJsonContent, extensions, candidate, failedLookupLocations, state);\r\n        if (fromPackageJson) {\r\n            return fromPackageJson;\r\n        }\r\n        const directoryExists = !onlyRecordFailures && directoryProbablyExists(candidate, state.host);\r\n        return loadModuleFromFile(extensions, combinePaths(candidate, \"index\"), failedLookupLocations, !directoryExists, state);\r\n    }\r\n\r\n    function getPackageJsonInfo(\r\n        nodeModuleDirectory: string,\r\n        subModuleName: string,\r\n        failedLookupLocations: Push<string>,\r\n        onlyRecordFailures: boolean,\r\n        state: ModuleResolutionState,\r\n    ): { found: boolean, packageJsonContent: PackageJsonPathFields | undefined, packageId: PackageId | undefined } {\r\n        const { host, traceEnabled } = state;\r\n        const directoryExists = !onlyRecordFailures && directoryProbablyExists(nodeModuleDirectory, host);\r\n        const packageJsonPath = pathToPackageJson(nodeModuleDirectory);\r\n        if (directoryExists && host.fileExists(packageJsonPath)) {\r\n            const packageJsonContent = readJson(packageJsonPath, host) as PackageJson;\r\n            if (subModuleName === \"\") { // looking up the root - need to handle types/typings/main redirects for subModuleName\r\n                const path = tryReadPackageJsonFields(/*readTypes*/ true, packageJsonContent, nodeModuleDirectory, state);\r\n                if (typeof path === \"string\") {\r\n                    subModuleName = addExtensionAndIndex(path.substring(nodeModuleDirectory.length + 1));\r\n                }\r\n                else {\r\n                    const jsPath = tryReadPackageJsonFields(/*readTypes*/ false, packageJsonContent, nodeModuleDirectory, state);\r\n                    if (typeof jsPath === \"string\") {\r\n                        subModuleName = removeExtension(removeExtension(jsPath.substring(nodeModuleDirectory.length + 1), Extension.Js), Extension.Jsx) + Extension.Dts;\r\n                    }\r\n                    else {\r\n                        subModuleName = \"index.d.ts\";\r\n                    }\r\n                }\r\n            }\r\n            if (!endsWith(subModuleName, Extension.Dts)) {\r\n                subModuleName = addExtensionAndIndex(subModuleName);\r\n            }\r\n            const packageId: PackageId = typeof packageJsonContent.name === \"string\" && typeof packageJsonContent.version === \"string\"\r\n                ? { name: packageJsonContent.name, subModuleName, version: packageJsonContent.version }\r\n                : undefined;\r\n            if (traceEnabled) {\r\n                if (packageId) {\r\n                    trace(host, Diagnostics.Found_package_json_at_0_Package_ID_is_1, packageJsonPath, packageIdToString(packageId));\r\n                }\r\n                else {\r\n                    trace(host, Diagnostics.Found_package_json_at_0, packageJsonPath);\r\n                }\r\n            }\r\n            return { found: true, packageJsonContent, packageId };\r\n        }\r\n        else {\r\n            if (directoryExists && traceEnabled) {\r\n                trace(host, Diagnostics.File_0_does_not_exist, packageJsonPath);\r\n            }\r\n            // record package json as one of failed lookup locations - in the future if this file will appear it will invalidate resolution results\r\n            failedLookupLocations.push(packageJsonPath);\r\n            return { found: false, packageJsonContent: undefined, packageId: undefined };\r\n        }\r\n    }\r\n\r\n    function loadModuleFromPackageJson(jsonContent: PackageJsonPathFields, extensions: Extensions, candidate: string, failedLookupLocations: Push<string>, state: ModuleResolutionState): PathAndExtension | undefined {\r\n        const file = tryReadPackageJsonFields(extensions !== Extensions.JavaScript, jsonContent, candidate, state);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n\r\n        const onlyRecordFailures = !directoryProbablyExists(getDirectoryPath(file), state.host);\r\n        const fromFile = tryFile(file, failedLookupLocations, onlyRecordFailures, state);\r\n        if (fromFile) {\r\n            const resolved = resolvedIfExtensionMatches(extensions, fromFile);\r\n            if (resolved) {\r\n                return resolved;\r\n            }\r\n            if (state.traceEnabled) {\r\n                trace(state.host, Diagnostics.File_0_has_an_unsupported_extension_so_skipping_it, fromFile);\r\n            }\r\n        }\r\n\r\n        // Even if extensions is DtsOnly, we can still look up a .ts file as a result of package.json \"types\"\r\n        const nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;\r\n        // Don't do package.json lookup recursively, because Node.js' package lookup doesn't.\r\n        const result = nodeLoadModuleByRelativeName(nextExtensions, file, failedLookupLocations, onlyRecordFailures, state, /*considerPackageJson*/ false);\r\n        if (result) {\r\n            // It won't have a `packageId` set, because we disabled `considerPackageJson`.\r\n            Debug.assert(result.packageId === undefined);\r\n            return { path: result.path, ext: result.extension };\r\n        }\r\n    }\r\n\r\n    /** Resolve from an arbitrarily specified file. Return `undefined` if it has an unsupported extension. */\r\n    function resolvedIfExtensionMatches(extensions: Extensions, path: string): PathAndExtension | undefined {\r\n        const ext = tryGetExtensionFromPath(path);\r\n        return ext !== undefined && extensionIsOk(extensions, ext) ? { path, ext } : undefined;\r\n    }\r\n\r\n    /** True if `extension` is one of the supported `extensions`. */\r\n    function extensionIsOk(extensions: Extensions, extension: Extension): boolean {\r\n        switch (extensions) {\r\n            case Extensions.JavaScript:\r\n                return extension === Extension.Js || extension === Extension.Jsx;\r\n            case Extensions.TypeScript:\r\n                return extension === Extension.Ts || extension === Extension.Tsx || extension === Extension.Dts;\r\n            case Extensions.DtsOnly:\r\n                return extension === Extension.Dts;\r\n        }\r\n    }\r\n\r\n    function pathToPackageJson(directory: string): string {\r\n        return combinePaths(directory, \"package.json\");\r\n    }\r\n\r\n    function loadModuleFromNodeModulesFolder(extensions: Extensions, moduleName: string, nodeModulesFolder: string, nodeModulesFolderExists: boolean, failedLookupLocations: Push<string>, state: ModuleResolutionState): Resolved | undefined {\r\n        const candidate = normalizePath(combinePaths(nodeModulesFolder, moduleName));\r\n        // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.\r\n        let packageJsonContent: PackageJsonPathFields | undefined;\r\n        let packageId: PackageId | undefined;\r\n        const packageInfo = getPackageJsonInfo(candidate, \"\", failedLookupLocations, /*onlyRecordFailures*/ !nodeModulesFolderExists, state);\r\n        if (packageInfo.found) {\r\n            ({ packageJsonContent, packageId } = packageInfo);\r\n        }\r\n        else {\r\n            const { packageName, rest } = getPackageName(moduleName);\r\n            if (rest !== \"\") { // If \"rest\" is empty, we just did this search above.\r\n                const packageRootPath = combinePaths(nodeModulesFolder, packageName);\r\n                // Don't use a \"types\" or \"main\" from here because we're not loading the root, but a subdirectory -- just here for the packageId.\r\n                packageId = getPackageJsonInfo(packageRootPath, rest, failedLookupLocations, !nodeModulesFolderExists, state).packageId;\r\n            }\r\n        }\r\n        const pathAndExtension = loadModuleFromFile(extensions, candidate, failedLookupLocations, !nodeModulesFolderExists, state) ||\r\n            loadNodeModuleFromDirectoryWorker(extensions, candidate, failedLookupLocations, !nodeModulesFolderExists, state, packageJsonContent);\r\n        return withPackageId(packageId, pathAndExtension);\r\n    }\r\n\r\n    /* @internal */\r\n    export function getPackageName(moduleName: string): { packageName: string, rest: string } {\r\n        let idx = moduleName.indexOf(directorySeparator);\r\n        if (moduleName[0] === \"@\") {\r\n            idx = moduleName.indexOf(directorySeparator, idx + 1);\r\n        }\r\n        return idx === -1 ? { packageName: moduleName, rest: \"\" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };\r\n    }\r\n\r\n    function loadModuleFromNodeModules(extensions: Extensions, moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState, cache: NonRelativeModuleNameResolutionCache): SearchResult<Resolved> {\r\n        return loadModuleFromNodeModulesWorker(extensions, moduleName, directory, failedLookupLocations, state, /*typesOnly*/ false, cache);\r\n    }\r\n    function loadModuleFromNodeModulesAtTypes(moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState): SearchResult<Resolved> {\r\n        // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.\r\n        return loadModuleFromNodeModulesWorker(Extensions.DtsOnly, moduleName, directory, failedLookupLocations, state, /*typesOnly*/ true, /*cache*/ undefined);\r\n    }\r\n\r\n    function loadModuleFromNodeModulesWorker(extensions: Extensions, moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState, typesOnly: boolean, cache: NonRelativeModuleNameResolutionCache): SearchResult<Resolved> {\r\n        const perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName);\r\n        return forEachAncestorDirectory(normalizeSlashes(directory), ancestorDirectory => {\r\n            if (getBaseFileName(ancestorDirectory) !== \"node_modules\") {\r\n                const resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state.traceEnabled, state.host, failedLookupLocations);\r\n                if (resolutionFromCache) {\r\n                    return resolutionFromCache;\r\n                }\r\n                return toSearchResult(loadModuleFromNodeModulesOneLevel(extensions, moduleName, ancestorDirectory, failedLookupLocations, state, typesOnly));\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Load a module from a single node_modules directory, but not from any ancestors' node_modules directories. */\r\n    function loadModuleFromNodeModulesOneLevel(extensions: Extensions, moduleName: string, directory: string, failedLookupLocations: Push<string>, state: ModuleResolutionState, typesOnly = false): Resolved | undefined {\r\n        const nodeModulesFolder = combinePaths(directory, \"node_modules\");\r\n        const nodeModulesFolderExists = directoryProbablyExists(nodeModulesFolder, state.host);\r\n        if (!nodeModulesFolderExists && state.traceEnabled) {\r\n            trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);\r\n        }\r\n\r\n        const packageResult = typesOnly ? undefined : loadModuleFromNodeModulesFolder(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, failedLookupLocations, state);\r\n        if (packageResult) {\r\n            return packageResult;\r\n        }\r\n        if (extensions !== Extensions.JavaScript) {\r\n            const nodeModulesAtTypes = combinePaths(nodeModulesFolder, \"@types\");\r\n            let nodeModulesAtTypesExists = nodeModulesFolderExists;\r\n            if (nodeModulesFolderExists && !directoryProbablyExists(nodeModulesAtTypes, state.host)) {\r\n                if (state.traceEnabled) {\r\n                    trace(state.host, Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesAtTypes);\r\n                }\r\n                nodeModulesAtTypesExists = false;\r\n            }\r\n            return loadModuleFromNodeModulesFolder(Extensions.DtsOnly, mangleScopedPackage(moduleName, state), nodeModulesAtTypes, nodeModulesAtTypesExists, failedLookupLocations, state);\r\n        }\r\n    }\r\n\r\n    /** Double underscores are used in DefinitelyTyped to delimit scoped packages. */\r\n    const mangledScopedPackageSeparator = \"__\";\r\n\r\n    /** For a scoped package, we must look in `@types/foo__bar` instead of `@types/@foo/bar`. */\r\n    function mangleScopedPackage(packageName: string, state: ModuleResolutionState): string {\r\n        const mangled = getMangledNameForScopedPackage(packageName);\r\n        if (state.traceEnabled && mangled !== packageName) {\r\n            trace(state.host, Diagnostics.Scoped_package_detected_looking_in_0, mangled);\r\n        }\r\n        return mangled;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getTypesPackageName(packageName: string): string {\r\n        return `@types/${getMangledNameForScopedPackage(packageName)}`;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getMangledNameForScopedPackage(packageName: string): string {\r\n        if (startsWith(packageName, \"@\")) {\r\n            const replaceSlash = packageName.replace(directorySeparator, mangledScopedPackageSeparator);\r\n            if (replaceSlash !== packageName) {\r\n                return replaceSlash.slice(1); // Take off the \"@\"\r\n            }\r\n        }\r\n        return packageName;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getPackageNameFromAtTypesDirectory(mangledName: string): string {\r\n        const withoutAtTypePrefix = removePrefix(mangledName, \"@types/\");\r\n        if (withoutAtTypePrefix !== mangledName) {\r\n            return getUnmangledNameForScopedPackage(withoutAtTypePrefix);\r\n        }\r\n        return mangledName;\r\n    }\r\n\r\n    /* @internal */\r\n    export function getUnmangledNameForScopedPackage(typesPackageName: string): string {\r\n        return stringContains(typesPackageName, mangledScopedPackageSeparator) ?\r\n            \"@\" + typesPackageName.replace(mangledScopedPackageSeparator, directorySeparator) :\r\n            typesPackageName;\r\n    }\r\n\r\n    function tryFindNonRelativeModuleNameInCache(cache: PerModuleNameCache | undefined, moduleName: string, containingDirectory: string, traceEnabled: boolean, host: ModuleResolutionHost, failedLookupLocations: Push<string>): SearchResult<Resolved> {\r\n        const result = cache && cache.get(containingDirectory);\r\n        if (result) {\r\n            if (traceEnabled) {\r\n                trace(host, Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);\r\n            }\r\n            failedLookupLocations.push(...result.failedLookupLocations);\r\n            return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };\r\n        }\r\n    }\r\n\r\n    export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n        const state: ModuleResolutionState = { compilerOptions, host, traceEnabled };\r\n        const failedLookupLocations: string[] = [];\r\n        const containingDirectory = getDirectoryPath(containingFile);\r\n\r\n        const resolved = tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript);\r\n        // No originalPath because classic resolution doesn't resolve realPath\r\n        return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, /*originalPath*/ undefined, /*isExternalLibraryImport*/ false, failedLookupLocations);\r\n\r\n        function tryResolve(extensions: Extensions): SearchResult<Resolved> {\r\n            const resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, failedLookupLocations, state);\r\n            if (resolvedUsingSettings) {\r\n                return { value: resolvedUsingSettings };\r\n            }\r\n            const perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName);\r\n\r\n            if (!isExternalModuleNameRelative(moduleName)) {\r\n                // Climb up parent directories looking for a module.\r\n                const resolved = forEachAncestorDirectory(containingDirectory, directory => {\r\n                    const resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, directory, traceEnabled, host, failedLookupLocations);\r\n                    if (resolutionFromCache) {\r\n                        return resolutionFromCache;\r\n                    }\r\n                    const searchName = normalizePath(combinePaths(directory, moduleName));\r\n                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, failedLookupLocations, /*onlyRecordFailures*/ false, state));\r\n                });\r\n                if (resolved) {\r\n                    return resolved;\r\n                }\r\n                if (extensions === Extensions.TypeScript) {\r\n                    // If we didn't find the file normally, look it up in @types.\r\n                    return loadModuleFromNodeModulesAtTypes(moduleName, containingDirectory, failedLookupLocations, state);\r\n                }\r\n            }\r\n            else {\r\n                const candidate = normalizePath(combinePaths(containingDirectory, moduleName));\r\n                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, failedLookupLocations, /*onlyRecordFailures*/ false, state));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * LSHost may load a module from a global cache of typings.\r\n     * This is the minumum code needed to expose that functionality; the rest is in LSHost.\r\n     */\r\n    /* @internal */\r\n    export function loadModuleFromGlobalCache(moduleName: string, projectName: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, globalCache: string): ResolvedModuleWithFailedLookupLocations {\r\n        const traceEnabled = isTraceEnabled(compilerOptions, host);\r\n        if (traceEnabled) {\r\n            trace(host, Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);\r\n        }\r\n        const state: ModuleResolutionState = { compilerOptions, host, traceEnabled };\r\n        const failedLookupLocations: string[] = [];\r\n        const resolved = loadModuleFromNodeModulesOneLevel(Extensions.DtsOnly, moduleName, globalCache, failedLookupLocations, state);\r\n        return createResolvedModuleWithFailedLookupLocations(resolved, /*originalPath*/ undefined, /*isExternalLibraryImport*/ true, failedLookupLocations);\r\n    }\r\n\r\n    /**\r\n     * Represents result of search. Normally when searching among several alternatives we treat value `undefined` as indicator\r\n     * that search fails and we should try another option.\r\n     * However this does not allow us to represent final result that should be used instead of further searching (i.e. a final result that was found in cache).\r\n     * SearchResult is used to deal with this issue, its values represents following outcomes:\r\n     * - undefined - not found, continue searching\r\n     * - { value: undefined } - not found - stop searching\r\n     * - { value: <some-value> } - found - stop searching\r\n     */\r\n    type SearchResult<T> = { value: T | undefined } | undefined;\r\n\r\n    /**\r\n     * Wraps value to SearchResult.\r\n     * @returns undefined if value is undefined or { value } otherwise\r\n     */\r\n    function toSearchResult<T>(value: T | undefined): SearchResult<T> {\r\n        return value !== undefined ? { value } : undefined;\r\n    }\r\n}\r\n","/* @internal */\r\nnamespace ts {\r\n    function stringToInt(str: string): number {\r\n        const n = parseInt(str, 10);\r\n        if (isNaN(n)) {\r\n            throw new Error(`Error in parseInt(${JSON.stringify(str)})`);\r\n        }\r\n        return n;\r\n    }\r\n\r\n    const isPrereleaseRegex = /^(.*)-next.\\d+/;\r\n    const prereleaseSemverRegex = /^(\\d+)\\.(\\d+)\\.0-next.(\\d+)$/;\r\n    const semverRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)$/;\r\n\r\n    export class Semver {\r\n        static parse(semver: string): Semver {\r\n            const isPrerelease = isPrereleaseRegex.test(semver);\r\n            const result = Semver.tryParse(semver, isPrerelease);\r\n            if (!result) {\r\n                throw new Error(`Unexpected semver: ${semver} (isPrerelease: ${isPrerelease})`);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        static fromRaw({ major, minor, patch, isPrerelease }: Semver): Semver {\r\n            return new Semver(major, minor, patch, isPrerelease);\r\n        }\r\n\r\n        // This must parse the output of `versionString`.\r\n        private static tryParse(semver: string, isPrerelease: boolean): Semver | undefined {\r\n            // Per the semver spec <http://semver.org/#spec-item-2>:\r\n            // \"A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers, and MUST NOT contain leading zeroes.\"\r\n            const rgx = isPrerelease ? prereleaseSemverRegex : semverRegex;\r\n            const match = rgx.exec(semver);\r\n            return match ? new Semver(stringToInt(match[1]), stringToInt(match[2]), stringToInt(match[3]), isPrerelease) : undefined;\r\n        }\r\n\r\n        private constructor(\r\n            readonly major: number, readonly minor: number, readonly patch: number,\r\n            /**\r\n             * If true, this is `major.minor.0-next.patch`.\r\n             * If false, this is `major.minor.patch`.\r\n             */\r\n            readonly isPrerelease: boolean) { }\r\n\r\n        get versionString(): string {\r\n            return this.isPrerelease ? `${this.major}.${this.minor}.0-next.${this.patch}` : `${this.major}.${this.minor}.${this.patch}`;\r\n        }\r\n\r\n        equals(sem: Semver): boolean {\r\n            return this.major === sem.major && this.minor === sem.minor && this.patch === sem.patch && this.isPrerelease === sem.isPrerelease;\r\n        }\r\n\r\n        greaterThan(sem: Semver): boolean {\r\n            return this.major > sem.major || this.major === sem.major\r\n                && (this.minor > sem.minor || this.minor === sem.minor\r\n                && (!this.isPrerelease && sem.isPrerelease || this.isPrerelease === sem.isPrerelease\r\n                && this.patch > sem.patch));\r\n        }\r\n    }\r\n}","/* @internal */\r\nnamespace ts.JsTyping {\r\n\r\n    export interface TypingResolutionHost {\r\n        directoryExists(path: string): boolean;\r\n        fileExists(fileName: string): boolean;\r\n        readFile(path: string, encoding?: string): string | undefined;\r\n        readDirectory(rootDir: string, extensions: ReadonlyArray<string>, excludes: ReadonlyArray<string>, includes: ReadonlyArray<string>, depth?: number): string[];\r\n    }\r\n\r\n    interface PackageJson {\r\n        _requiredBy?: string[];\r\n        dependencies?: MapLike<string>;\r\n        devDependencies?: MapLike<string>;\r\n        name?: string;\r\n        optionalDependencies?: MapLike<string>;\r\n        peerDependencies?: MapLike<string>;\r\n        types?: string;\r\n        typings?: string;\r\n    }\r\n\r\n    export interface CachedTyping {\r\n        typingLocation: string;\r\n        version: Semver;\r\n    }\r\n\r\n    /* @internal */\r\n    export function isTypingUpToDate(cachedTyping: CachedTyping, availableTypingVersions: MapLike<string>) {\r\n        const availableVersion = Semver.parse(getProperty(availableTypingVersions, `ts${versionMajorMinor}`) || getProperty(availableTypingVersions, \"latest\"));\r\n        return !availableVersion.greaterThan(cachedTyping.version);\r\n    }\r\n\r\n    /* @internal */\r\n    export const nodeCoreModuleList: ReadonlyArray<string> = [\r\n        \"buffer\", \"querystring\", \"events\", \"http\", \"cluster\",\r\n        \"zlib\", \"os\", \"https\", \"punycode\", \"repl\", \"readline\",\r\n        \"vm\", \"child_process\", \"url\", \"dns\", \"net\",\r\n        \"dgram\", \"fs\", \"path\", \"string_decoder\", \"tls\",\r\n        \"crypto\", \"stream\", \"util\", \"assert\", \"tty\", \"domain\",\r\n        \"constants\", \"process\", \"v8\", \"timers\", \"console\"];\r\n\r\n    /* @internal */\r\n    export const nodeCoreModules = arrayToSet(nodeCoreModuleList);\r\n\r\n    /**\r\n     * A map of loose file names to library names that we are confident require typings\r\n     */\r\n    export type SafeList = ReadonlyMap<string>;\r\n\r\n    export function loadSafeList(host: TypingResolutionHost, safeListPath: Path): SafeList {\r\n        const result = readConfigFile(safeListPath, path => host.readFile(path));\r\n        return createMapFromTemplate<string>(result.config);\r\n    }\r\n\r\n    export function loadTypesMap(host: TypingResolutionHost, typesMapPath: Path): SafeList | undefined {\r\n        const result = readConfigFile(typesMapPath, path => host.readFile(path));\r\n        if (result.config) {\r\n            return createMapFromTemplate<string>(result.config.simpleMap);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * @param host is the object providing I/O related operations.\r\n     * @param fileNames are the file names that belong to the same project\r\n     * @param projectRootPath is the path to the project root directory\r\n     * @param safeListPath is the path used to retrieve the safe list\r\n     * @param packageNameToTypingLocation is the map of package names to their cached typing locations and installed versions\r\n     * @param typeAcquisition is used to customize the typing acquisition process\r\n     * @param compilerOptions are used as a source for typing inference\r\n     */\r\n    export function discoverTypings(\r\n        host: TypingResolutionHost,\r\n        log: ((message: string) => void) | undefined,\r\n        fileNames: string[],\r\n        projectRootPath: Path,\r\n        safeList: SafeList,\r\n        packageNameToTypingLocation: ReadonlyMap<CachedTyping>,\r\n        typeAcquisition: TypeAcquisition,\r\n        unresolvedImports: ReadonlyArray<string>,\r\n        typesRegistry: ReadonlyMap<MapLike<string>>):\r\n        { cachedTypingPaths: string[], newTypingNames: string[], filesToWatch: string[] } {\r\n\r\n        if (!typeAcquisition || !typeAcquisition.enable) {\r\n            return { cachedTypingPaths: [], newTypingNames: [], filesToWatch: [] };\r\n        }\r\n\r\n        // A typing name to typing file path mapping\r\n        const inferredTypings = createMap<string>();\r\n\r\n        // Only infer typings for .js and .jsx files\r\n        fileNames = mapDefined(fileNames, fileName => {\r\n            const path = normalizePath(fileName);\r\n            if (hasJavaScriptFileExtension(path)) {\r\n                return path;\r\n            }\r\n        });\r\n\r\n        const filesToWatch: string[] = [];\r\n\r\n        if (typeAcquisition.include) addInferredTypings(typeAcquisition.include, \"Explicitly included types\");\r\n        const exclude = typeAcquisition.exclude || [];\r\n\r\n        // Directories to search for package.json, bower.json and other typing information\r\n        const possibleSearchDirs = arrayToSet(fileNames, getDirectoryPath);\r\n        possibleSearchDirs.set(projectRootPath, true);\r\n        possibleSearchDirs.forEach((_true, searchDir) => {\r\n            const packageJsonPath = combinePaths(searchDir, \"package.json\");\r\n            getTypingNamesFromJson(packageJsonPath, filesToWatch);\r\n\r\n            const bowerJsonPath = combinePaths(searchDir, \"bower.json\");\r\n            getTypingNamesFromJson(bowerJsonPath, filesToWatch);\r\n\r\n            const bowerComponentsPath = combinePaths(searchDir, \"bower_components\");\r\n            getTypingNamesFromPackagesFolder(bowerComponentsPath, filesToWatch);\r\n\r\n            const nodeModulesPath = combinePaths(searchDir, \"node_modules\");\r\n            getTypingNamesFromPackagesFolder(nodeModulesPath, filesToWatch);\r\n        });\r\n        getTypingNamesFromSourceFileNames(fileNames);\r\n\r\n        // add typings for unresolved imports\r\n        if (unresolvedImports) {\r\n            const module = deduplicate(\r\n                unresolvedImports.map(moduleId => nodeCoreModules.has(moduleId) ? \"node\" : moduleId),\r\n                equateStringsCaseSensitive,\r\n                compareStringsCaseSensitive);\r\n            addInferredTypings(module, \"Inferred typings from unresolved imports\");\r\n        }\r\n        // Add the cached typing locations for inferred typings that are already installed\r\n        packageNameToTypingLocation.forEach((typing, name) => {\r\n            if (inferredTypings.has(name) && inferredTypings.get(name) === undefined && isTypingUpToDate(typing, typesRegistry.get(name))) {\r\n                inferredTypings.set(name, typing.typingLocation);\r\n            }\r\n        });\r\n\r\n        // Remove typings that the user has added to the exclude list\r\n        for (const excludeTypingName of exclude) {\r\n            const didDelete = inferredTypings.delete(excludeTypingName);\r\n            if (didDelete && log) log(`Typing for ${excludeTypingName} is in exclude list, will be ignored.`);\r\n        }\r\n\r\n        const newTypingNames: string[] = [];\r\n        const cachedTypingPaths: string[] = [];\r\n        inferredTypings.forEach((inferred, typing) => {\r\n            if (inferred !== undefined) {\r\n                cachedTypingPaths.push(inferred);\r\n            }\r\n            else {\r\n                newTypingNames.push(typing);\r\n            }\r\n        });\r\n        const result = { cachedTypingPaths, newTypingNames, filesToWatch };\r\n        if (log) log(`Result: ${JSON.stringify(result)}`);\r\n        return result;\r\n\r\n        function addInferredTyping(typingName: string) {\r\n            if (!inferredTypings.has(typingName)) {\r\n                inferredTypings.set(typingName, undefined);\r\n            }\r\n        }\r\n        function addInferredTypings(typingNames: ReadonlyArray<string>, message: string) {\r\n            if (log) log(`${message}: ${JSON.stringify(typingNames)}`);\r\n            forEach(typingNames, addInferredTyping);\r\n        }\r\n\r\n        /**\r\n         * Get the typing info from common package manager json files like package.json or bower.json\r\n         */\r\n        function getTypingNamesFromJson(jsonPath: string, filesToWatch: Push<string>) {\r\n            if (!host.fileExists(jsonPath)) {\r\n                return;\r\n            }\r\n\r\n            filesToWatch.push(jsonPath);\r\n            const jsonConfig: PackageJson = readConfigFile(jsonPath, path => host.readFile(path)).config;\r\n            const jsonTypingNames = flatMap([jsonConfig.dependencies, jsonConfig.devDependencies, jsonConfig.optionalDependencies, jsonConfig.peerDependencies], getOwnKeys);\r\n            addInferredTypings(jsonTypingNames, `Typing names in '${jsonPath}' dependencies`);\r\n        }\r\n\r\n        /**\r\n         * Infer typing names from given file names. For example, the file name \"jquery-min.2.3.4.js\"\r\n         * should be inferred to the 'jquery' typing name; and \"angular-route.1.2.3.js\" should be inferred\r\n         * to the 'angular-route' typing name.\r\n         * @param fileNames are the names for source files in the project\r\n         */\r\n        function getTypingNamesFromSourceFileNames(fileNames: string[]) {\r\n            const fromFileNames = mapDefined(fileNames, j => {\r\n                if (!hasJavaScriptFileExtension(j)) return undefined;\r\n\r\n                const inferredTypingName = removeFileExtension(getBaseFileName(j.toLowerCase()));\r\n                const cleanedTypingName = removeMinAndVersionNumbers(inferredTypingName);\r\n                return safeList.get(cleanedTypingName);\r\n            });\r\n            if (fromFileNames.length) {\r\n                addInferredTypings(fromFileNames, \"Inferred typings from file names\");\r\n            }\r\n\r\n            const hasJsxFile = some(fileNames, f => fileExtensionIs(f, Extension.Jsx));\r\n            if (hasJsxFile) {\r\n                if (log) log(`Inferred 'react' typings due to presence of '.jsx' extension`);\r\n                addInferredTyping(\"react\");\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Infer typing names from packages folder (ex: node_module, bower_components)\r\n         * @param packagesFolderPath is the path to the packages folder\r\n         */\r\n        function getTypingNamesFromPackagesFolder(packagesFolderPath: string, filesToWatch: Push<string>) {\r\n            filesToWatch.push(packagesFolderPath);\r\n\r\n            // Todo: add support for ModuleResolutionHost too\r\n            if (!host.directoryExists(packagesFolderPath)) {\r\n                return;\r\n            }\r\n\r\n            // depth of 2, so we access `node_modules/foo` but not `node_modules/foo/bar`\r\n            const fileNames = host.readDirectory(packagesFolderPath, [Extension.Json], /*excludes*/ undefined, /*includes*/ undefined, /*depth*/ 2);\r\n            if (log) log(`Searching for typing names in ${packagesFolderPath}; all files: ${JSON.stringify(fileNames)}`);\r\n            const packageNames: string[] = [];\r\n            for (const fileName of fileNames) {\r\n                const normalizedFileName = normalizePath(fileName);\r\n                const baseFileName = getBaseFileName(normalizedFileName);\r\n                if (baseFileName !== \"package.json\" && baseFileName !== \"bower.json\") {\r\n                    continue;\r\n                }\r\n                const result = readConfigFile(normalizedFileName, (path: string) => host.readFile(path));\r\n                const packageJson: PackageJson = result.config;\r\n\r\n                // npm 3's package.json contains a \"_requiredBy\" field\r\n                // we should include all the top level module names for npm 2, and only module names whose\r\n                // \"_requiredBy\" field starts with \"#\" or equals \"/\" for npm 3.\r\n                if (baseFileName === \"package.json\" && packageJson._requiredBy &&\r\n                    filter(packageJson._requiredBy, (r: string) => r[0] === \"#\" || r === \"/\").length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                // If the package has its own d.ts typings, those will take precedence. Otherwise the package name will be used\r\n                // to download d.ts files from DefinitelyTyped\r\n                if (!packageJson.name) {\r\n                    continue;\r\n                }\r\n                const ownTypes = packageJson.types || packageJson.typings;\r\n                if (ownTypes) {\r\n                    const absolutePath = getNormalizedAbsolutePath(ownTypes, getDirectoryPath(normalizedFileName));\r\n                    if (log) log(`    Package '${packageJson.name}' provides its own types.`);\r\n                    inferredTypings.set(packageJson.name, absolutePath);\r\n                }\r\n                else {\r\n                    packageNames.push(packageJson.name);\r\n                }\r\n            }\r\n            addInferredTypings(packageNames, \"    Found package names\");\r\n        }\r\n\r\n    }\r\n\r\n    export const enum PackageNameValidationResult {\r\n        Ok,\r\n        ScopedPackagesNotSupported,\r\n        EmptyName,\r\n        NameTooLong,\r\n        NameStartsWithDot,\r\n        NameStartsWithUnderscore,\r\n        NameContainsNonURISafeCharacters\r\n    }\r\n\r\n    const maxPackageNameLength = 214;\r\n\r\n    /**\r\n     * Validates package name using rules defined at https://docs.npmjs.com/files/package.json\r\n     */\r\n    export function validatePackageName(packageName: string): PackageNameValidationResult {\r\n        if (!packageName) {\r\n            return PackageNameValidationResult.EmptyName;\r\n        }\r\n        if (packageName.length > maxPackageNameLength) {\r\n            return PackageNameValidationResult.NameTooLong;\r\n        }\r\n        if (packageName.charCodeAt(0) === CharacterCodes.dot) {\r\n            return PackageNameValidationResult.NameStartsWithDot;\r\n        }\r\n        if (packageName.charCodeAt(0) === CharacterCodes._) {\r\n            return PackageNameValidationResult.NameStartsWithUnderscore;\r\n        }\r\n        // check if name is scope package like: starts with @ and has one '/' in the middle\r\n        // scoped packages are not currently supported\r\n        // TODO: when support will be added we'll need to split and check both scope and package name\r\n        if (/^@[^/]+\\/[^/]+$/.test(packageName)) {\r\n            return PackageNameValidationResult.ScopedPackagesNotSupported;\r\n        }\r\n        if (encodeURIComponent(packageName) !== packageName) {\r\n            return PackageNameValidationResult.NameContainsNonURISafeCharacters;\r\n        }\r\n        return PackageNameValidationResult.Ok;\r\n    }\r\n\r\n    export function renderPackageNameValidationFailure(result: PackageNameValidationResult, typing: string): string {\r\n        switch (result) {\r\n            case PackageNameValidationResult.EmptyName:\r\n                return `Package name '${typing}' cannot be empty`;\r\n            case PackageNameValidationResult.NameTooLong:\r\n                return `Package name '${typing}' should be less than ${maxPackageNameLength} characters`;\r\n            case PackageNameValidationResult.NameStartsWithDot:\r\n                return `Package name '${typing}' cannot start with '.'`;\r\n            case PackageNameValidationResult.NameStartsWithUnderscore:\r\n                return `Package name '${typing}' cannot start with '_'`;\r\n            case PackageNameValidationResult.ScopedPackagesNotSupported:\r\n                return `Package '${typing}' is scoped and currently is not supported`;\r\n            case PackageNameValidationResult.NameContainsNonURISafeCharacters:\r\n                return `Package name '${typing}' contains non URI safe characters`;\r\n            case PackageNameValidationResult.Ok:\r\n                return Debug.fail(); // Shouldn't have called this.\r\n            default:\r\n                Debug.assertNever(result);\r\n        }\r\n    }\r\n}\r\n","namespace ts.server {\r\n    // tslint:disable variable-name\r\n    export const ActionSet: ActionSet = \"action::set\";\r\n    export const ActionInvalidate: ActionInvalidate = \"action::invalidate\";\r\n    export const ActionPackageInstalled: ActionPackageInstalled = \"action::packageInstalled\";\r\n    export const EventTypesRegistry: EventTypesRegistry = \"event::typesRegistry\";\r\n    export const EventBeginInstallTypes: EventBeginInstallTypes = \"event::beginInstallTypes\";\r\n    export const EventEndInstallTypes: EventEndInstallTypes = \"event::endInstallTypes\";\r\n    export const EventInitializationFailed: EventInitializationFailed = \"event::initializationFailed\";\r\n\r\n    export namespace Arguments {\r\n        export const GlobalCacheLocation = \"--globalTypingsCacheLocation\";\r\n        export const LogFile = \"--logFile\";\r\n        export const EnableTelemetry = \"--enableTelemetry\";\r\n        export const TypingSafeListLocation = \"--typingSafeListLocation\";\r\n        export const TypesMapLocation = \"--typesMapLocation\";\r\n        /**\r\n         * This argument specifies the location of the NPM executable.\r\n         * typingsInstaller will run the command with `${npmLocation} install ...`.\r\n         */\r\n        export const NpmLocation = \"--npmLocation\";\r\n    }\r\n\r\n    export function hasArgument(argumentName: string) {\r\n        return sys.args.indexOf(argumentName) >= 0;\r\n    }\r\n\r\n    export function findArgument(argumentName: string): string | undefined {\r\n        const index = sys.args.indexOf(argumentName);\r\n        return index >= 0 && index < sys.args.length - 1\r\n            ? sys.args[index + 1]\r\n            : undefined;\r\n    }\r\n\r\n    /*@internal*/\r\n    export function nowString() {\r\n        // E.g. \"12:34:56.789\"\r\n        const d = new Date();\r\n        return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${d.getMilliseconds()}`;\r\n    }\r\n}\r\n","namespace ts.server.typingsInstaller {\r\n    interface NpmConfig {\r\n        devDependencies: MapLike<any>;\r\n    }\r\n\r\n    interface NpmLock {\r\n        dependencies: { [packageName: string]: { version: string } };\r\n    }\r\n\r\n    export interface Log {\r\n        isEnabled(): boolean;\r\n        writeLine(text: string): void;\r\n    }\r\n\r\n    const nullLog: Log = {\r\n        isEnabled: () => false,\r\n        writeLine: noop\r\n    };\r\n\r\n    function typingToFileName(cachePath: string, packageName: string, installTypingHost: InstallTypingHost, log: Log): string {\r\n        try {\r\n            const result = resolveModuleName(packageName, combinePaths(cachePath, \"index.d.ts\"), { moduleResolution: ModuleResolutionKind.NodeJs }, installTypingHost);\r\n            return result.resolvedModule && result.resolvedModule.resolvedFileName;\r\n        }\r\n        catch (e) {\r\n            if (log.isEnabled()) {\r\n                log.writeLine(`Failed to resolve ${packageName} in folder '${cachePath}': ${(<Error>e).message}`);\r\n            }\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /*@internal*/\r\n    export function installNpmPackages(npmPath: string, tsVersion: string, packageNames: string[], install: (command: string) => boolean) {\r\n        let hasError = false;\r\n        for (let remaining = packageNames.length; remaining > 0;) {\r\n            const result = getNpmCommandForInstallation(npmPath, tsVersion, packageNames, remaining);\r\n            remaining = result.remaining;\r\n            hasError = install(result.command) || hasError;\r\n        }\r\n        return hasError;\r\n    }\r\n\r\n    /*@internal*/\r\n    export function getNpmCommandForInstallation(npmPath: string, tsVersion: string, packageNames: string[], remaining: number) {\r\n        const sliceStart = packageNames.length - remaining;\r\n        let command: string, toSlice = remaining;\r\n        while (true) {\r\n            command = `${npmPath} install --ignore-scripts ${(toSlice === packageNames.length ? packageNames : packageNames.slice(sliceStart, sliceStart + toSlice)).join(\" \")} --save-dev --user-agent=\"typesInstaller/${tsVersion}\"`;\r\n            if (command.length < 8000) {\r\n                break;\r\n            }\r\n\r\n            toSlice = toSlice - Math.floor(toSlice / 2);\r\n        }\r\n        return { command, remaining: remaining - toSlice };\r\n    }\r\n\r\n    export type RequestCompletedAction = (success: boolean) => void;\r\n    interface PendingRequest {\r\n        requestId: number;\r\n        packageNames: string[];\r\n        cwd: string;\r\n        onRequestCompleted: RequestCompletedAction;\r\n    }\r\n\r\n    function isPackageOrBowerJson(fileName: string) {\r\n        const base = getBaseFileName(fileName);\r\n        return base === \"package.json\" || base === \"bower.json\";\r\n    }\r\n\r\n    function getDirectoryExcludingNodeModulesOrBowerComponents(f: string) {\r\n        const indexOfNodeModules = f.indexOf(\"/node_modules/\");\r\n        const indexOfBowerComponents = f.indexOf(\"/bower_components/\");\r\n        const subStrLength = indexOfNodeModules === -1 || indexOfBowerComponents === -1 ?\r\n            Math.max(indexOfNodeModules, indexOfBowerComponents) :\r\n            Math.min(indexOfNodeModules, indexOfBowerComponents);\r\n        return subStrLength === -1 ? f : f.substr(0, subStrLength);\r\n    }\r\n\r\n    type ProjectWatchers = Map<FileWatcher> & { isInvoked?: boolean; };\r\n\r\n    export abstract class TypingsInstaller {\r\n        private readonly packageNameToTypingLocation: Map<JsTyping.CachedTyping> = createMap<JsTyping.CachedTyping>();\r\n        private readonly missingTypingsSet: Map<true> = createMap<true>();\r\n        private readonly knownCachesSet: Map<true> = createMap<true>();\r\n        private readonly projectWatchers = createMap<ProjectWatchers>();\r\n        private safeList: JsTyping.SafeList | undefined;\r\n        readonly pendingRunRequests: PendingRequest[] = [];\r\n        private readonly toCanonicalFileName: GetCanonicalFileName;\r\n        private readonly globalCacheCanonicalPackageJsonPath: string;\r\n\r\n        private installRunCount = 1;\r\n        private inFlightRequestCount = 0;\r\n\r\n        abstract readonly typesRegistry: Map<MapLike<string>>;\r\n\r\n        constructor(\r\n            protected readonly installTypingHost: InstallTypingHost,\r\n            private readonly globalCachePath: string,\r\n            private readonly safeListPath: Path,\r\n            private readonly typesMapLocation: Path,\r\n            private readonly throttleLimit: number,\r\n            protected readonly log = nullLog) {\r\n            this.toCanonicalFileName = createGetCanonicalFileName(installTypingHost.useCaseSensitiveFileNames);\r\n            this.globalCacheCanonicalPackageJsonPath = combinePaths(this.toCanonicalFileName(globalCachePath), \"package.json\");\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Global cache location '${globalCachePath}', safe file path '${safeListPath}', types map path ${typesMapLocation}`);\r\n            }\r\n            this.processCacheLocation(this.globalCachePath);\r\n        }\r\n\r\n        closeProject(req: CloseProject) {\r\n            this.closeWatchers(req.projectName);\r\n        }\r\n\r\n        private closeWatchers(projectName: string): void {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Closing file watchers for project '${projectName}'`);\r\n            }\r\n            const watchers = this.projectWatchers.get(projectName);\r\n            if (!watchers) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`No watchers are registered for project '${projectName}'`);\r\n                }\r\n                return;\r\n            }\r\n            clearMap(watchers, closeFileWatcher);\r\n            this.projectWatchers.delete(projectName);\r\n\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Closing file watchers for project '${projectName}' - done.`);\r\n            }\r\n        }\r\n\r\n        install(req: DiscoverTypings) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Got install request ${JSON.stringify(req)}`);\r\n            }\r\n\r\n            // load existing typing information from the cache\r\n            if (req.cachePath) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Request specifies cache path '${req.cachePath}', loading cached information...`);\r\n                }\r\n                this.processCacheLocation(req.cachePath);\r\n            }\r\n\r\n            if (this.safeList === undefined) {\r\n                this.initializeSafeList();\r\n            }\r\n            const discoverTypingsResult = JsTyping.discoverTypings(\r\n                this.installTypingHost,\r\n                this.log.isEnabled() ? (s => this.log.writeLine(s)) : undefined,\r\n                req.fileNames,\r\n                req.projectRootPath,\r\n                this.safeList,\r\n                this.packageNameToTypingLocation,\r\n                req.typeAcquisition,\r\n                req.unresolvedImports,\r\n                this.typesRegistry);\r\n\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Finished typings discovery: ${JSON.stringify(discoverTypingsResult)}`);\r\n            }\r\n\r\n            // start watching files\r\n            this.watchFiles(req.projectName, discoverTypingsResult.filesToWatch, req.projectRootPath);\r\n\r\n            // install typings\r\n            if (discoverTypingsResult.newTypingNames.length) {\r\n                this.installTypings(req, req.cachePath || this.globalCachePath, discoverTypingsResult.cachedTypingPaths, discoverTypingsResult.newTypingNames);\r\n            }\r\n            else {\r\n                this.sendResponse(this.createSetTypings(req, discoverTypingsResult.cachedTypingPaths));\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`No new typings were requested as a result of typings discovery`);\r\n                }\r\n            }\r\n        }\r\n\r\n        private initializeSafeList() {\r\n            // Prefer the safe list from the types map if it exists\r\n            if (this.typesMapLocation) {\r\n                const safeListFromMap = JsTyping.loadTypesMap(this.installTypingHost, this.typesMapLocation);\r\n                if (safeListFromMap) {\r\n                    this.log.writeLine(`Loaded safelist from types map file '${this.typesMapLocation}'`);\r\n                    this.safeList = safeListFromMap;\r\n                    return;\r\n                }\r\n                this.log.writeLine(`Failed to load safelist from types map file '${this.typesMapLocation}'`);\r\n            }\r\n            this.safeList = JsTyping.loadSafeList(this.installTypingHost, this.safeListPath);\r\n        }\r\n\r\n        private processCacheLocation(cacheLocation: string) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Processing cache location '${cacheLocation}'`);\r\n            }\r\n            if (this.knownCachesSet.has(cacheLocation)) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Cache location was already processed...`);\r\n                }\r\n                return;\r\n            }\r\n            const packageJson = combinePaths(cacheLocation, \"package.json\");\r\n            const packageLockJson = combinePaths(cacheLocation, \"package-lock.json\");\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Trying to find '${packageJson}'...`);\r\n            }\r\n            if (this.installTypingHost.fileExists(packageJson) && this.installTypingHost.fileExists(packageLockJson)) {\r\n                const npmConfig = <NpmConfig>JSON.parse(this.installTypingHost.readFile(packageJson));\r\n                const npmLock = <NpmLock>JSON.parse(this.installTypingHost.readFile(packageLockJson));\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Loaded content of '${packageJson}': ${JSON.stringify(npmConfig)}`);\r\n                    this.log.writeLine(`Loaded content of '${packageLockJson}'`);\r\n                }\r\n                if (npmConfig.devDependencies && npmLock.dependencies) {\r\n                    for (const key in npmConfig.devDependencies) {\r\n                        if (!hasProperty(npmLock.dependencies, key)) {\r\n                            // if package in package.json but not package-lock.json, skip adding to cache so it is reinstalled on next use\r\n                            continue;\r\n                        }\r\n                        // key is @types/<package name>\r\n                        const packageName = getBaseFileName(key);\r\n                        if (!packageName) {\r\n                            continue;\r\n                        }\r\n                        const typingFile = typingToFileName(cacheLocation, packageName, this.installTypingHost, this.log);\r\n                        if (!typingFile) {\r\n                            this.missingTypingsSet.set(packageName, true);\r\n                            continue;\r\n                        }\r\n                        const existingTypingFile = this.packageNameToTypingLocation.get(packageName);\r\n                        if (existingTypingFile) {\r\n                            if (existingTypingFile.typingLocation === typingFile) {\r\n                                continue;\r\n                            }\r\n\r\n                            if (this.log.isEnabled()) {\r\n                                this.log.writeLine(`New typing for package ${packageName} from '${typingFile}' conflicts with existing typing file '${existingTypingFile}'`);\r\n                            }\r\n                        }\r\n                        if (this.log.isEnabled()) {\r\n                            this.log.writeLine(`Adding entry into typings cache: '${packageName}' => '${typingFile}'`);\r\n                        }\r\n                        const info = getProperty(npmLock.dependencies, key);\r\n                        const version = info && info.version;\r\n                        const semver = Semver.parse(version);\r\n                        const newTyping: JsTyping.CachedTyping = { typingLocation: typingFile, version: semver };\r\n                        this.packageNameToTypingLocation.set(packageName, newTyping);\r\n                    }\r\n                }\r\n            }\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Finished processing cache location '${cacheLocation}'`);\r\n            }\r\n            this.knownCachesSet.set(cacheLocation, true);\r\n        }\r\n\r\n        private filterTypings(typingsToInstall: ReadonlyArray<string>): ReadonlyArray<string> {\r\n            return typingsToInstall.filter(typing => {\r\n                if (this.missingTypingsSet.get(typing)) {\r\n                    if (this.log.isEnabled()) this.log.writeLine(`'${typing}' is in missingTypingsSet - skipping...`);\r\n                    return false;\r\n                }\r\n                const validationResult = JsTyping.validatePackageName(typing);\r\n                if (validationResult !== JsTyping.PackageNameValidationResult.Ok) {\r\n                    // add typing name to missing set so we won't process it again\r\n                    this.missingTypingsSet.set(typing, true);\r\n                    if (this.log.isEnabled()) this.log.writeLine(JsTyping.renderPackageNameValidationFailure(validationResult, typing));\r\n                    return false;\r\n                }\r\n                if (!this.typesRegistry.has(typing)) {\r\n                    if (this.log.isEnabled()) this.log.writeLine(`Entry for package '${typing}' does not exist in local types registry - skipping...`);\r\n                    return false;\r\n                }\r\n                if (this.packageNameToTypingLocation.get(typing) && JsTyping.isTypingUpToDate(this.packageNameToTypingLocation.get(typing), this.typesRegistry.get(typing))) {\r\n                    if (this.log.isEnabled()) this.log.writeLine(`'${typing}' already has an up-to-date typing - skipping...`);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n\r\n        protected ensurePackageDirectoryExists(directory: string) {\r\n            const npmConfigPath = combinePaths(directory, \"package.json\");\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Npm config file: ${npmConfigPath}`);\r\n            }\r\n            if (!this.installTypingHost.fileExists(npmConfigPath)) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Npm config file: '${npmConfigPath}' is missing, creating new one...`);\r\n                }\r\n                this.ensureDirectoryExists(directory, this.installTypingHost);\r\n                this.installTypingHost.writeFile(npmConfigPath, '{ \"private\": true }');\r\n            }\r\n        }\r\n\r\n        private installTypings(req: DiscoverTypings, cachePath: string, currentlyCachedTypings: string[], typingsToInstall: string[]) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Installing typings ${JSON.stringify(typingsToInstall)}`);\r\n            }\r\n            const filteredTypings = this.filterTypings(typingsToInstall);\r\n            if (filteredTypings.length === 0) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`All typings are known to be missing or invalid - no need to install more typings`);\r\n                }\r\n                this.sendResponse(this.createSetTypings(req, currentlyCachedTypings));\r\n                return;\r\n            }\r\n\r\n            this.ensurePackageDirectoryExists(cachePath);\r\n\r\n            const requestId = this.installRunCount;\r\n            this.installRunCount++;\r\n\r\n            // send progress event\r\n            this.sendResponse(<BeginInstallTypes>{\r\n                kind: EventBeginInstallTypes,\r\n                eventId: requestId,\r\n                typingsInstallerVersion: ts.version, // tslint:disable-line no-unnecessary-qualifier (qualified explicitly to prevent occasional shadowing)\r\n                projectName: req.projectName\r\n            });\r\n\r\n            const scopedTypings = filteredTypings.map(typingsName);\r\n            this.installTypingsAsync(requestId, scopedTypings, cachePath, ok => {\r\n                try {\r\n                    if (!ok) {\r\n                        if (this.log.isEnabled()) {\r\n                            this.log.writeLine(`install request failed, marking packages as missing to prevent repeated requests: ${JSON.stringify(filteredTypings)}`);\r\n                        }\r\n                        for (const typing of filteredTypings) {\r\n                            this.missingTypingsSet.set(typing, true);\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    // TODO: watch project directory\r\n                    if (this.log.isEnabled()) {\r\n                        this.log.writeLine(`Installed typings ${JSON.stringify(scopedTypings)}`);\r\n                    }\r\n                    const installedTypingFiles: string[] = [];\r\n                    for (const packageName of filteredTypings) {\r\n                        const typingFile = typingToFileName(cachePath, packageName, this.installTypingHost, this.log);\r\n                        if (!typingFile) {\r\n                            this.missingTypingsSet.set(packageName, true);\r\n                            continue;\r\n                        }\r\n\r\n                        // packageName is guaranteed to exist in typesRegistry by filterTypings\r\n                        const distTags = this.typesRegistry.get(packageName);\r\n                        const newVersion = Semver.parse(distTags[`ts${versionMajorMinor}`] || distTags[latestDistTag]);\r\n                        const newTyping: JsTyping.CachedTyping = { typingLocation: typingFile, version: newVersion };\r\n                        this.packageNameToTypingLocation.set(packageName, newTyping);\r\n                        installedTypingFiles.push(typingFile);\r\n                    }\r\n                    if (this.log.isEnabled()) {\r\n                        this.log.writeLine(`Installed typing files ${JSON.stringify(installedTypingFiles)}`);\r\n                    }\r\n\r\n                    this.sendResponse(this.createSetTypings(req, currentlyCachedTypings.concat(installedTypingFiles)));\r\n                }\r\n                finally {\r\n                    const response: EndInstallTypes = {\r\n                        kind: EventEndInstallTypes,\r\n                        eventId: requestId,\r\n                        projectName: req.projectName,\r\n                        packagesToInstall: scopedTypings,\r\n                        installSuccess: ok,\r\n                        typingsInstallerVersion: ts.version // tslint:disable-line no-unnecessary-qualifier (qualified explicitly to prevent occasional shadowing)\r\n                    };\r\n                    this.sendResponse(response);\r\n                }\r\n            });\r\n        }\r\n\r\n        private ensureDirectoryExists(directory: string, host: InstallTypingHost): void {\r\n            const directoryName = getDirectoryPath(directory);\r\n            if (!host.directoryExists(directoryName)) {\r\n                this.ensureDirectoryExists(directoryName, host);\r\n            }\r\n            if (!host.directoryExists(directory)) {\r\n                host.createDirectory(directory);\r\n            }\r\n        }\r\n\r\n        private watchFiles(projectName: string, files: string[], projectRootPath: Path) {\r\n            if (!files.length) {\r\n                // shut down existing watchers\r\n                this.closeWatchers(projectName);\r\n                return;\r\n            }\r\n\r\n            let watchers = this.projectWatchers.get(projectName);\r\n            const toRemove = createMap<FileWatcher>();\r\n            if (!watchers) {\r\n                watchers = createMap();\r\n                this.projectWatchers.set(projectName, watchers);\r\n            }\r\n            else {\r\n                copyEntries(watchers, toRemove);\r\n            }\r\n\r\n            // handler should be invoked once for the entire set of files since it will trigger full rediscovery of typings\r\n            watchers.isInvoked = false;\r\n\r\n            const isLoggingEnabled = this.log.isEnabled();\r\n            const createProjectWatcher = (path: string, createWatch: (path: string) => FileWatcher) => {\r\n                toRemove.delete(path);\r\n                if (watchers.has(path)) {\r\n                    return;\r\n                }\r\n\r\n                watchers.set(path, createWatch(path));\r\n            };\r\n            const createProjectFileWatcher = (file: string): FileWatcher => {\r\n                if (isLoggingEnabled) {\r\n                    this.log.writeLine(`FileWatcher:: Added:: WatchInfo: ${file}`);\r\n                }\r\n                const watcher = this.installTypingHost.watchFile(file, (f, eventKind) => {\r\n                    if (isLoggingEnabled) {\r\n                        this.log.writeLine(`FileWatcher:: Triggered with ${f} eventKind: ${FileWatcherEventKind[eventKind]}:: WatchInfo: ${file}:: handler is already invoked '${watchers.isInvoked}'`);\r\n                    }\r\n                    if (!watchers.isInvoked) {\r\n                        watchers.isInvoked = true;\r\n                        this.sendResponse({ projectName, kind: ActionInvalidate });\r\n                    }\r\n                }, /*pollingInterval*/ 2000);\r\n\r\n                return isLoggingEnabled ? {\r\n                    close: () => {\r\n                        this.log.writeLine(`FileWatcher:: Closed:: WatchInfo: ${file}`);\r\n                        watcher.close();\r\n                    }\r\n                } : watcher;\r\n            };\r\n            const createProjectDirectoryWatcher = (dir: string): FileWatcher => {\r\n                if (isLoggingEnabled) {\r\n                    this.log.writeLine(`DirectoryWatcher:: Added:: WatchInfo: ${dir} recursive`);\r\n                }\r\n                const watcher = this.installTypingHost.watchDirectory(dir, f => {\r\n                    if (isLoggingEnabled) {\r\n                        this.log.writeLine(`DirectoryWatcher:: Triggered with ${f} :: WatchInfo: ${dir} recursive :: handler is already invoked '${watchers.isInvoked}'`);\r\n                    }\r\n                    if (watchers.isInvoked) {\r\n                        return;\r\n                    }\r\n                    f = this.toCanonicalFileName(f);\r\n                    if (f !== this.globalCacheCanonicalPackageJsonPath && isPackageOrBowerJson(f)) {\r\n                        watchers.isInvoked = true;\r\n                        this.sendResponse({ projectName, kind: ActionInvalidate });\r\n                    }\r\n                }, /*recursive*/ true);\r\n\r\n                return isLoggingEnabled ? {\r\n                    close: () => {\r\n                        this.log.writeLine(`DirectoryWatcher:: Closed:: WatchInfo: ${dir} recursive`);\r\n                        watcher.close();\r\n                    }\r\n                } : watcher;\r\n            };\r\n\r\n            // Create watches from list of files\r\n            for (const file of files) {\r\n                const filePath = this.toCanonicalFileName(file);\r\n                if (isPackageOrBowerJson(filePath)) {\r\n                    // package.json or bower.json exists, watch the file to detect changes and update typings\r\n                    createProjectWatcher(filePath, createProjectFileWatcher);\r\n                    continue;\r\n                }\r\n\r\n                // path in projectRoot, watch project root\r\n                if (containsPath(projectRootPath, filePath, projectRootPath, !this.installTypingHost.useCaseSensitiveFileNames)) {\r\n                    createProjectWatcher(projectRootPath, createProjectDirectoryWatcher);\r\n                    continue;\r\n                }\r\n\r\n                // path in global cache, watch global cache\r\n                if (containsPath(this.globalCachePath, filePath, projectRootPath, !this.installTypingHost.useCaseSensitiveFileNames)) {\r\n                    createProjectWatcher(this.globalCachePath, createProjectDirectoryWatcher);\r\n                    continue;\r\n                }\r\n\r\n                // Get path without node_modules and bower_components\r\n                createProjectWatcher(getDirectoryExcludingNodeModulesOrBowerComponents(getDirectoryPath(filePath)), createProjectDirectoryWatcher);\r\n            }\r\n\r\n            // Remove unused watches\r\n            toRemove.forEach((watch, path) => {\r\n                watch.close();\r\n                watchers.delete(path);\r\n            });\r\n        }\r\n\r\n        private createSetTypings(request: DiscoverTypings, typings: string[]): SetTypings {\r\n            return {\r\n                projectName: request.projectName,\r\n                typeAcquisition: request.typeAcquisition,\r\n                compilerOptions: request.compilerOptions,\r\n                typings,\r\n                unresolvedImports: request.unresolvedImports,\r\n                kind: ActionSet\r\n            };\r\n        }\r\n\r\n        private installTypingsAsync(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void {\r\n            this.pendingRunRequests.unshift({ requestId, packageNames, cwd, onRequestCompleted });\r\n            this.executeWithThrottling();\r\n        }\r\n\r\n        private executeWithThrottling() {\r\n            while (this.inFlightRequestCount < this.throttleLimit && this.pendingRunRequests.length) {\r\n                this.inFlightRequestCount++;\r\n                const request = this.pendingRunRequests.pop();\r\n                this.installWorker(request.requestId, request.packageNames, request.cwd, ok => {\r\n                    this.inFlightRequestCount--;\r\n                    request.onRequestCompleted(ok);\r\n                    this.executeWithThrottling();\r\n                });\r\n            }\r\n        }\r\n\r\n        protected abstract installWorker(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void;\r\n        protected abstract sendResponse(response: SetTypings | InvalidateCachedTypings | BeginInstallTypes | EndInstallTypes): void;\r\n    }\r\n\r\n    /* @internal */\r\n    export function typingsName(packageName: string): string {\r\n        return `@types/${packageName}@ts${versionMajorMinor}`;\r\n    }\r\n\r\n    const latestDistTag = \"latest\";\r\n}\r\n","/// <reference types=\"node\" />\r\n\r\nnamespace ts.server.typingsInstaller {\r\n    const fs: {\r\n        appendFileSync(file: string, content: string): void\r\n    } = require(\"fs\");\r\n\r\n    const path: {\r\n        join(...parts: string[]): string;\r\n        dirname(path: string): string;\r\n        basename(path: string, extension?: string): string;\r\n    } = require(\"path\");\r\n\r\n    class FileLog implements Log {\r\n        private logEnabled = true;\r\n        constructor(private readonly logFile?: string) {\r\n        }\r\n\r\n        isEnabled = () => {\r\n            return this.logEnabled && this.logFile !== undefined;\r\n        }\r\n        writeLine = (text: string) => {\r\n            try {\r\n                fs.appendFileSync(this.logFile, `[${nowString()}] ${text}${sys.newLine}`);\r\n            }\r\n            catch (e) {\r\n                this.logEnabled = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Used if `--npmLocation` is not passed. */\r\n    function getDefaultNPMLocation(processName: string) {\r\n        if (path.basename(processName).indexOf(\"node\") === 0) {\r\n            return `\"${path.join(path.dirname(process.argv[0]), \"npm\")}\"`;\r\n        }\r\n        else {\r\n            return \"npm\";\r\n        }\r\n    }\r\n\r\n    interface TypesRegistryFile {\r\n        entries: MapLike<MapLike<string>>;\r\n    }\r\n\r\n    function loadTypesRegistryFile(typesRegistryFilePath: string, host: InstallTypingHost, log: Log): Map<MapLike<string>> {\r\n        if (!host.fileExists(typesRegistryFilePath)) {\r\n            if (log.isEnabled()) {\r\n                log.writeLine(`Types registry file '${typesRegistryFilePath}' does not exist`);\r\n            }\r\n            return createMap<MapLike<string>>();\r\n        }\r\n        try {\r\n            const content = <TypesRegistryFile>JSON.parse(host.readFile(typesRegistryFilePath));\r\n            return createMapFromTemplate(content.entries);\r\n        }\r\n        catch (e) {\r\n            if (log.isEnabled()) {\r\n                log.writeLine(`Error when loading types registry file '${typesRegistryFilePath}': ${(<Error>e).message}, ${(<Error>e).stack}`);\r\n            }\r\n            return createMap<MapLike<string>>();\r\n        }\r\n    }\r\n\r\n    const typesRegistryPackageName = \"types-registry\";\r\n    function getTypesRegistryFileLocation(globalTypingsCacheLocation: string): string {\r\n        return combinePaths(normalizeSlashes(globalTypingsCacheLocation), `node_modules/${typesRegistryPackageName}/index.json`);\r\n    }\r\n\r\n    interface ExecSyncOptions {\r\n        cwd: string;\r\n        encoding: \"utf-8\";\r\n    }\r\n    type ExecSync = (command: string, options: ExecSyncOptions) => string;\r\n\r\n    export class NodeTypingsInstaller extends TypingsInstaller {\r\n        private readonly nodeExecSync: ExecSync;\r\n        private readonly npmPath: string;\r\n        readonly typesRegistry: Map<MapLike<string>>;\r\n\r\n        private delayedInitializationError: InitializationFailedResponse | undefined;\r\n\r\n        constructor(globalTypingsCacheLocation: string, typingSafeListLocation: string, typesMapLocation: string, npmLocation: string | undefined, throttleLimit: number, log: Log) {\r\n            super(\r\n                sys,\r\n                globalTypingsCacheLocation,\r\n                typingSafeListLocation ? toPath(typingSafeListLocation, \"\", createGetCanonicalFileName(sys.useCaseSensitiveFileNames)) : toPath(\"typingSafeList.json\", __dirname, createGetCanonicalFileName(sys.useCaseSensitiveFileNames)),\r\n                typesMapLocation ? toPath(typesMapLocation, \"\", createGetCanonicalFileName(sys.useCaseSensitiveFileNames)) : toPath(\"typesMap.json\", __dirname, createGetCanonicalFileName(sys.useCaseSensitiveFileNames)),\r\n                throttleLimit,\r\n                log);\r\n            this.npmPath = npmLocation !== undefined ? npmLocation : getDefaultNPMLocation(process.argv[0]);\r\n\r\n            // If the NPM path contains spaces and isn't wrapped in quotes, do so.\r\n            if (stringContains(this.npmPath, \" \") && this.npmPath[0] !== `\"`) {\r\n                this.npmPath = `\"${this.npmPath}\"`;\r\n            }\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Process id: ${process.pid}`);\r\n                this.log.writeLine(`NPM location: ${this.npmPath} (explicit '${Arguments.NpmLocation}' ${npmLocation === undefined ? \"not \" : \"\"} provided)`);\r\n            }\r\n            ({ execSync: this.nodeExecSync } = require(\"child_process\"));\r\n\r\n            this.ensurePackageDirectoryExists(globalTypingsCacheLocation);\r\n\r\n            try {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Updating ${typesRegistryPackageName} npm package...`);\r\n                }\r\n                this.execSyncAndLog(`${this.npmPath} install --ignore-scripts ${typesRegistryPackageName}`, { cwd: globalTypingsCacheLocation });\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Updated ${typesRegistryPackageName} npm package`);\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`Error updating ${typesRegistryPackageName} package: ${(<Error>e).message}`);\r\n                }\r\n                // store error info to report it later when it is known that server is already listening to events from typings installer\r\n                this.delayedInitializationError = {\r\n                    kind: \"event::initializationFailed\",\r\n                    message: (<Error>e).message\r\n                };\r\n            }\r\n\r\n            this.typesRegistry = loadTypesRegistryFile(getTypesRegistryFileLocation(globalTypingsCacheLocation), this.installTypingHost, this.log);\r\n        }\r\n\r\n        listen() {\r\n            process.on(\"message\", (req: TypingInstallerRequestUnion) => {\r\n                if (this.delayedInitializationError) {\r\n                    // report initializationFailed error\r\n                    this.sendResponse(this.delayedInitializationError);\r\n                    this.delayedInitializationError = undefined;\r\n                }\r\n                switch (req.kind) {\r\n                    case \"discover\":\r\n                        this.install(req);\r\n                        break;\r\n                    case \"closeProject\":\r\n                        this.closeProject(req);\r\n                        break;\r\n                    case \"typesRegistry\": {\r\n                        const typesRegistry: { [key: string]: MapLike<string> } = {};\r\n                        this.typesRegistry.forEach((value, key) => {\r\n                            typesRegistry[key] = value;\r\n                        });\r\n                        const response: TypesRegistryResponse = { kind: EventTypesRegistry, typesRegistry };\r\n                        this.sendResponse(response);\r\n                        break;\r\n                    }\r\n                    case \"installPackage\": {\r\n                        const { fileName, packageName, projectName, projectRootPath } = req;\r\n                        const cwd = getDirectoryOfPackageJson(fileName, this.installTypingHost) || projectRootPath;\r\n                        if (cwd) {\r\n                            this.installWorker(-1, [packageName], cwd, success => {\r\n                                const message = success ? `Package ${packageName} installed.` : `There was an error installing ${packageName}.`;\r\n                                const response: PackageInstalledResponse = { kind: ActionPackageInstalled, projectName, success, message };\r\n                                this.sendResponse(response);\r\n                            });\r\n                        }\r\n                        else {\r\n                            const response: PackageInstalledResponse = { kind: ActionPackageInstalled, projectName, success: false, message: \"Could not determine a project root path.\" };\r\n                            this.sendResponse(response);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Debug.assertNever(req);\r\n                }\r\n            });\r\n        }\r\n\r\n        protected sendResponse(response: TypingInstallerResponseUnion) {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Sending response:\\n    ${JSON.stringify(response)}`);\r\n            }\r\n            process.send(response);\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Response has been sent.`);\r\n            }\r\n        }\r\n\r\n        protected installWorker(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`#${requestId} with arguments'${JSON.stringify(packageNames)}'.`);\r\n            }\r\n            const start = Date.now();\r\n            const hasError = installNpmPackages(this.npmPath, version, packageNames, command => this.execSyncAndLog(command, { cwd }));\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`npm install #${requestId} took: ${Date.now() - start} ms`);\r\n            }\r\n            onRequestCompleted(!hasError);\r\n        }\r\n\r\n        /** Returns 'true' in case of error. */\r\n        private execSyncAndLog(command: string, options: Pick<ExecSyncOptions, \"cwd\">): boolean {\r\n            if (this.log.isEnabled()) {\r\n                this.log.writeLine(`Exec: ${command}`);\r\n            }\r\n            try {\r\n                const stdout = this.nodeExecSync(command, { ...options, encoding: \"utf-8\" });\r\n                if (this.log.isEnabled()) {\r\n                    this.log.writeLine(`    Succeeded. stdout:${indent(sys.newLine, stdout)}`);\r\n                }\r\n                return false;\r\n            }\r\n            catch (error) {\r\n                const { stdout, stderr } = error;\r\n                this.log.writeLine(`    Failed. stdout:${indent(sys.newLine, stdout)}${sys.newLine}    stderr:${indent(sys.newLine, stderr)}`);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDirectoryOfPackageJson(fileName: string, host: InstallTypingHost): string | undefined {\r\n        return forEachAncestorDirectory(getDirectoryPath(fileName), directory => {\r\n            if (host.fileExists(combinePaths(directory, \"package.json\"))) {\r\n                return directory;\r\n            }\r\n        });\r\n    }\r\n\r\n    const logFilePath = findArgument(Arguments.LogFile);\r\n    const globalTypingsCacheLocation = findArgument(Arguments.GlobalCacheLocation);\r\n    const typingSafeListLocation = findArgument(Arguments.TypingSafeListLocation);\r\n    const typesMapLocation = findArgument(Arguments.TypesMapLocation);\r\n    const npmLocation = findArgument(Arguments.NpmLocation);\r\n\r\n    const log = new FileLog(logFilePath);\r\n    if (log.isEnabled()) {\r\n        process.on(\"uncaughtException\", (e: Error) => {\r\n            log.writeLine(`Unhandled exception: ${e} at ${e.stack}`);\r\n        });\r\n    }\r\n    process.on(\"disconnect\", () => {\r\n        if (log.isEnabled()) {\r\n            log.writeLine(`Parent process has exited, shutting down...`);\r\n        }\r\n        process.exit(0);\r\n    });\r\n    const installer = new NodeTypingsInstaller(globalTypingsCacheLocation, typingSafeListLocation, typesMapLocation, npmLocation, /*throttleLimit*/5, log);\r\n    installer.listen();\r\n\r\n    function indent(newline: string, str: string): string {\r\n        return `${newline}    ` + str.replace(/\\r?\\n/, `${newline}    `);\r\n    }\r\n}\r\n","declare namespace ts.server {\r\n    export interface CompressedData {\r\n        length: number;\r\n        compressionKind: string;\r\n        data: any;\r\n    }\r\n\r\n    type RequireResult = { module: {}, error: undefined } | { module: undefined, error: { stack?: string, message?: string } };\r\n    export interface ServerHost extends System {\r\n        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number): FileWatcher;\r\n        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean): FileWatcher;\r\n        setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\r\n        clearTimeout(timeoutId: any): void;\r\n        setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;\r\n        clearImmediate(timeoutId: any): void;\r\n        gc?(): void;\r\n        trace?(s: string): void;\r\n        require?(initialPath: string, moduleName: string): RequireResult;\r\n    }\r\n\r\n    export interface SortedReadonlyArray<T> extends ReadonlyArray<T> {\r\n        \" __sortedArrayBrand\": any;\r\n    }\r\n\r\n    export interface TypingInstallerRequestWithProjectName {\r\n        readonly projectName: string;\r\n    }\r\n\r\n    /* @internal */\r\n    export type TypingInstallerRequestUnion = DiscoverTypings | CloseProject | TypesRegistryRequest | InstallPackageRequest;\r\n\r\n    export interface DiscoverTypings extends TypingInstallerRequestWithProjectName {\r\n        readonly fileNames: string[];\r\n        readonly projectRootPath: Path;\r\n        readonly compilerOptions: CompilerOptions;\r\n        readonly typeAcquisition: TypeAcquisition;\r\n        readonly unresolvedImports: SortedReadonlyArray<string>;\r\n        readonly cachePath?: string;\r\n        readonly kind: \"discover\";\r\n    }\r\n\r\n    export interface CloseProject extends TypingInstallerRequestWithProjectName {\r\n        readonly kind: \"closeProject\";\r\n    }\r\n\r\n    export interface TypesRegistryRequest {\r\n        readonly kind: \"typesRegistry\";\r\n    }\r\n\r\n    export interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {\r\n        readonly kind: \"installPackage\";\r\n        readonly fileName: Path;\r\n        readonly packageName: string;\r\n        readonly projectRootPath: Path;\r\n    }\r\n\r\n    export type ActionSet = \"action::set\";\r\n    export type ActionInvalidate = \"action::invalidate\";\r\n    export type ActionPackageInstalled = \"action::packageInstalled\";\r\n    export type EventTypesRegistry = \"event::typesRegistry\";\r\n    export type EventBeginInstallTypes = \"event::beginInstallTypes\";\r\n    export type EventEndInstallTypes = \"event::endInstallTypes\";\r\n    export type EventInitializationFailed = \"event::initializationFailed\";\r\n\r\n    export interface TypingInstallerResponse {\r\n        readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;\r\n    }\r\n    /* @internal */\r\n    export type TypingInstallerResponseUnion = SetTypings | InvalidateCachedTypings | TypesRegistryResponse | PackageInstalledResponse | InstallTypes | InitializationFailedResponse;\r\n\r\n    /* @internal */\r\n    export interface TypesRegistryResponse extends TypingInstallerResponse {\r\n        readonly kind: EventTypesRegistry;\r\n        readonly typesRegistry: MapLike<MapLike<string>>;\r\n    }\r\n\r\n    export interface PackageInstalledResponse extends ProjectResponse {\r\n        readonly kind: ActionPackageInstalled;\r\n        readonly success: boolean;\r\n        readonly message: string;\r\n    }\r\n\r\n    export interface InitializationFailedResponse extends TypingInstallerResponse {\r\n        readonly kind: EventInitializationFailed;\r\n        readonly message: string;\r\n    }\r\n\r\n    export interface ProjectResponse extends TypingInstallerResponse {\r\n        readonly projectName: string;\r\n    }\r\n\r\n    export interface SetTypings extends ProjectResponse {\r\n        readonly typeAcquisition: TypeAcquisition;\r\n        readonly compilerOptions: CompilerOptions;\r\n        readonly typings: string[];\r\n        readonly unresolvedImports: SortedReadonlyArray<string>;\r\n        readonly kind: ActionSet;\r\n    }\r\n\r\n    export interface InvalidateCachedTypings extends ProjectResponse {\r\n        readonly kind: ActionInvalidate;\r\n    }\r\n\r\n    export interface InstallTypes extends ProjectResponse {\r\n        readonly kind: EventBeginInstallTypes | EventEndInstallTypes;\r\n        readonly eventId: number;\r\n        readonly typingsInstallerVersion: string;\r\n        readonly packagesToInstall: ReadonlyArray<string>;\r\n    }\r\n\r\n    export interface BeginInstallTypes extends InstallTypes {\r\n        readonly kind: EventBeginInstallTypes;\r\n    }\r\n\r\n    export interface EndInstallTypes extends InstallTypes {\r\n        readonly kind: EventEndInstallTypes;\r\n        readonly installSuccess: boolean;\r\n    }\r\n\r\n    /* @internal */\r\n    export interface InstallTypingHost extends JsTyping.TypingResolutionHost {\r\n        useCaseSensitiveFileNames: boolean;\r\n        writeFile(path: string, content: string): void;\r\n        createDirectory(path: string): void;\r\n        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number): FileWatcher;\r\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean): FileWatcher;\r\n    }\r\n}\r\n"]}