import {
    __String,
    AccessExpression,
    AccessFlags,
    AccessorDeclaration,
    addRange,
    addRelatedInfo,
    addSyntheticLeadingComment,
    addSyntheticTrailingComment,
    AliasDeclarationNode,
    AllAccessorDeclarations,
    AmbientModuleDeclaration,
    and,
    AnonymousType,
    AnyImportOrJsDocImport,
    AnyImportOrReExport,
    append,
    appendIfUnique,
    ArrayBindingPattern,
    arrayFrom,
    arrayIsEqualTo,
    arrayIsHomogeneous,
    ArrayLiteralExpression,
    arrayOf,
    arrayToMultiMap,
    ArrayTypeNode,
    ArrowFunction,
    AsExpression,
    AssertionExpression,
    AssignmentDeclarationKind,
    AssignmentKind,
    AssignmentPattern,
    AwaitExpression,
    BaseType,
    BigIntLiteral,
    BigIntLiteralType,
    BinaryExpression,
    BinaryOperator,
    BinaryOperatorToken,
    binarySearch,
    BindableObjectDefinePropertyCall,
    BindableStaticNameExpression,
    BindingElement,
    BindingElementGrandparent,
    BindingName,
    BindingPattern,
    bindSourceFile,
    Block,
    BooleanLiteral,
    BreakOrContinueStatement,
    CallChain,
    CallExpression,
    CallLikeExpression,
    CallSignatureDeclaration,
    CancellationToken,
    canHaveDecorators,
    canHaveExportModifier,
    canHaveFlowNode,
    canHaveIllegalDecorators,
    canHaveIllegalModifiers,
    canHaveJSDoc,
    canHaveLocals,
    canHaveModifiers,
    canHaveModuleSpecifier,
    canHaveSymbol,
    canIncludeBindAndCheckDiagnostics,
    canUsePropertyAccess,
    cartesianProduct,
    CaseBlock,
    CaseClause,
    CaseOrDefaultClause,
    cast,
    chainDiagnosticMessages,
    CharacterCodes,
    CheckFlags,
    ClassDeclaration,
    ClassElement,
    classElementOrClassElementParameterIsDecorated,
    ClassExpression,
    ClassLikeDeclaration,
    classOrConstructorParameterIsDecorated,
    ClassStaticBlockDeclaration,
    clear,
    compareDiagnostics,
    comparePaths,
    compareValues,
    Comparison,
    CompilerOptions,
    ComputedPropertyName,
    concatenate,
    concatenateDiagnosticMessageChains,
    ConditionalExpression,
    ConditionalRoot,
    ConditionalType,
    ConditionalTypeNode,
    ConstructorDeclaration,
    ConstructorTypeNode,
    ConstructSignatureDeclaration,
    contains,
    containsParseError,
    ContextFlags,
    copyEntries,
    countWhere,
    createBinaryExpressionTrampoline,
    createCompilerDiagnostic,
    createDetachedDiagnostic,
    createDiagnosticCollection,
    createDiagnosticForFileFromMessageChain,
    createDiagnosticForNode,
    createDiagnosticForNodeArray,
    createDiagnosticForNodeArrayFromMessageChain,
    createDiagnosticForNodeFromMessageChain,
    createDiagnosticMessageChainFromDiagnostic,
    createEmptyExports,
    createEvaluator,
    createFileDiagnostic,
    createFlowNode,
    createGetSymbolWalker,
    createModeAwareCacheKey,
    createModeMismatchDetails,
    createModuleNotFoundChain,
    createMultiMap,
    createNameResolver,
    createPrinterWithDefaults,
    createPrinterWithRemoveComments,
    createPrinterWithRemoveCommentsNeverAsciiEscape,
    createPrinterWithRemoveCommentsOmitTrailingSemicolon,
    createPropertyNameNodeForIdentifierOrLiteral,
    createScanner,
    createSymbolTable,
    createSyntacticTypeNodeBuilder,
    createTextWriter,
    Debug,
    Declaration,
    DeclarationName,
    declarationNameToString,
    DeclarationStatement,
    DeclarationWithTypeParameterChildren,
    DeclarationWithTypeParameters,
    Decorator,
    deduplicate,
    DefaultClause,
    defaultMaximumTruncationLength,
    DeferredTypeReference,
    DeleteExpression,
    Diagnostic,
    DiagnosticAndArguments,
    DiagnosticArguments,
    DiagnosticCategory,
    DiagnosticMessage,
    DiagnosticMessageChain,
    DiagnosticRelatedInformation,
    Diagnostics,
    DiagnosticWithLocation,
    DoStatement,
    DynamicNamedDeclaration,
    ElementAccessChain,
    ElementAccessExpression,
    ElementFlags,
    ElementWithComputedPropertyName,
    EmitFlags,
    EmitHint,
    emitModuleKindIsNonNodeESM,
    EmitResolver,
    EmitTextWriter,
    emptyArray,
    EntityName,
    EntityNameExpression,
    EntityNameOrEntityNameExpression,
    entityNameToString,
    EnumDeclaration,
    EnumMember,
    EnumType,
    equateValues,
    ErrorOutputContainer,
    escapeLeadingUnderscores,
    escapeString,
    EvaluatorResult,
    evaluatorResult,
    every,
    EvolvingArrayType,
    ExclamationToken,
    ExportAssignment,
    exportAssignmentIsAlias,
    ExportDeclaration,
    ExportSpecifier,
    Expression,
    expressionResultIsUnused,
    ExpressionStatement,
    ExpressionWithTypeArguments,
    Extension,
    ExternalEmitHelpers,
    externalHelpersModuleNameText,
    factory,
    fileExtensionIs,
    fileExtensionIsOneOf,
    filter,
    find,
    findAncestor,
    findBestPatternMatch,
    findConstructorDeclaration,
    findIndex,
    findLast,
    findLastIndex,
    findUseStrictPrologue,
    first,
    firstDefined,
    firstIterator,
    firstOrUndefined,
    firstOrUndefinedIterator,
    flatMap,
    flatten,
    FlowArrayMutation,
    FlowAssignment,
    FlowCall,
    FlowCondition,
    FlowFlags,
    FlowLabel,
    FlowNode,
    FlowReduceLabel,
    FlowStart,
    FlowSwitchClause,
    FlowSwitchClauseData,
    FlowType,
    forEach,
    forEachChild,
    forEachChildRecursively,
    forEachEnclosingBlockScopeContainer,
    forEachEntry,
    forEachKey,
    forEachReturnStatement,
    forEachYieldExpression,
    ForInOrOfStatement,
    ForInStatement,
    formatMessage,
    ForOfStatement,
    ForStatement,
    FreshableIntrinsicType,
    FreshableType,
    FreshObjectLiteralType,
    FunctionDeclaration,
    FunctionExpression,
    FunctionFlags,
    FunctionLikeDeclaration,
    FunctionOrConstructorTypeNode,
    FunctionTypeNode,
    GenericType,
    GetAccessorDeclaration,
    getAliasDeclarationFromName,
    getAllJSDocTags,
    getAllowSyntheticDefaultImports,
    getAncestor,
    getAnyExtensionFromPath,
    getAssignedExpandoInitializer,
    getAssignmentDeclarationKind,
    getAssignmentDeclarationPropertyAccessKind,
    getAssignmentTargetKind,
    getCanonicalDiagnostic,
    getCheckFlags,
    getClassExtendsHeritageElement,
    getClassLikeDeclarationOfSymbol,
    getCombinedLocalAndExportSymbolFlags,
    getCombinedModifierFlags,
    getCombinedNodeFlags,
    getCommonSourceDirectoryOfConfig,
    getContainingClass,
    getContainingClassExcludingClassDecorators,
    getContainingClassStaticBlock,
    getContainingFunction,
    getContainingFunctionOrClassStaticBlock,
    getDeclarationFileExtension,
    getDeclarationModifierFlagsFromSymbol,
    getDeclarationOfKind,
    getDeclarationsOfKind,
    getDeclaredExpandoInitializer,
    getDecorators,
    getDirectoryPath,
    getEffectiveBaseTypeNode,
    getEffectiveConstraintOfTypeParameter,
    getEffectiveContainerForJSDocTemplateTag,
    getEffectiveImplementsTypeNodes,
    getEffectiveInitializer,
    getEffectiveJSDocHost,
    getEffectiveModifierFlags,
    getEffectiveReturnTypeNode,
    getEffectiveSetAccessorTypeAnnotationNode,
    getEffectiveTypeAnnotationNode,
    getEffectiveTypeParameterDeclarations,
    getElementOrPropertyAccessName,
    getEmitDeclarations,
    getEmitModuleKind,
    getEmitModuleResolutionKind,
    getEmitScriptTarget,
    getEmitStandardClassFields,
    getEnclosingBlockScopeContainer,
    getEnclosingContainer,
    getEntityNameFromTypeNode,
    getErrorSpanForNode,
    getEscapedTextOfIdentifierOrLiteral,
    getEscapedTextOfJsxAttributeName,
    getEscapedTextOfJsxNamespacedName,
    getESModuleInterop,
    getExpandoInitializer,
    getExportAssignmentExpression,
    getExternalModuleImportEqualsDeclarationExpression,
    getExternalModuleName,
    getExternalModuleRequireArgument,
    getFirstConstructorWithBody,
    getFirstIdentifier,
    getFunctionFlags,
    getHostSignatureFromJSDoc,
    getIdentifierGeneratedImportReference,
    getIdentifierTypeArguments,
    getImmediatelyInvokedFunctionExpression,
    getInitializerOfBinaryExpression,
    getInterfaceBaseTypeNodes,
    getInvokedExpression,
    getIsolatedModules,
    getJSDocClassTag,
    getJSDocDeprecatedTag,
    getJSDocEnumTag,
    getJSDocHost,
    getJSDocOverloadTags,
    getJSDocParameterTags,
    getJSDocRoot,
    getJSDocSatisfiesExpressionType,
    getJSDocTags,
    getJSDocThisTag,
    getJSDocType,
    getJSDocTypeAssertionType,
    getJSDocTypeParameterDeclarations,
    getJSDocTypeTag,
    getJSXImplicitImportBase,
    getJSXRuntimeImport,
    getJSXTransformEnabled,
    getLeftmostAccessExpression,
    getLineAndCharacterOfPosition,
    getMembersOfDeclaration,
    getModifiers,
    getModuleInstanceState,
    getNameFromImportAttribute,
    getNameFromIndexInfo,
    getNameOfDeclaration,
    getNameOfExpando,
    getNamespaceDeclarationNode,
    getNewTargetContainer,
    getNonAugmentationDeclaration,
    getNonModifierTokenPosOfNode,
    getNormalizedAbsolutePath,
    getObjectFlags,
    getOriginalNode,
    getOrUpdate,
    getParameterSymbolFromJSDoc,
    getParseTreeNode,
    getPropertyAssignmentAliasLikeExpression,
    getPropertyNameForPropertyNameNode,
    getPropertyNameFromType,
    getRelativePathFromDirectory,
    getRelativePathFromFile,
    getResolutionDiagnostic,
    getResolutionModeOverride,
    getResolveJsonModule,
    getRestParameterElementType,
    getRootDeclaration,
    getScriptTargetFeatures,
    getSelectedEffectiveModifierFlags,
    getSemanticJsxChildren,
    getSetAccessorValueParameter,
    getSingleVariableOfVariableStatement,
    getSourceFileOfModule,
    getSourceFileOfNode,
    getSpanOfTokenAtPosition,
    getSpellingSuggestion,
    getStrictOptionValue,
    getSuperContainer,
    getSymbolNameForPrivateIdentifier,
    getSynthesizedDeepClone,
    getTextOfIdentifierOrLiteral,
    getTextOfJSDocComment,
    getTextOfJsxAttributeName,
    getTextOfNode,
    getTextOfPropertyName,
    getThisContainer,
    getThisParameter,
    getTrailingSemicolonDeferringWriter,
    getTypeParameterFromJsDoc,
    getUseDefineForClassFields,
    group,
    hasAbstractModifier,
    hasAccessorModifier,
    hasAmbientModifier,
    hasContextSensitiveParameters,
    HasDecorators,
    hasDecorators,
    hasDynamicName,
    hasEffectiveModifier,
    hasEffectiveModifiers,
    hasEffectiveReadonlyModifier,
    HasExpressionInitializer,
    hasExtension,
    HasIllegalDecorators,
    HasIllegalModifiers,
    HasInferredType,
    hasInferredType,
    HasInitializer,
    hasInitializer,
    hasJSDocNodes,
    hasJSDocParameterTags,
    hasJsonModuleEmitEnabled,
    HasLocals,
    HasModifiers,
    hasOnlyExpressionInitializer,
    hasOverrideModifier,
    hasPossibleExternalModuleReference,
    hasQuestionToken,
    hasResolutionModeOverride,
    hasRestParameter,
    hasScopeMarker,
    hasStaticModifier,
    hasSyntacticModifier,
    hasSyntacticModifiers,
    hasType,
    HeritageClause,
    hostGetCanonicalFileName,
    Identifier,
    identifierToKeywordKind,
    IdentifierTypePredicate,
    idText,
    IfStatement,
    ImportAttribute,
    ImportAttributes,
    ImportCall,
    ImportClause,
    ImportDeclaration,
    ImportEqualsDeclaration,
    ImportOrExportSpecifier,
    ImportSpecifier,
    ImportTypeNode,
    IndexedAccessType,
    IndexedAccessTypeNode,
    IndexFlags,
    IndexInfo,
    IndexKind,
    indexOfNode,
    IndexSignatureDeclaration,
    IndexType,
    indicesOf,
    InferenceContext,
    InferenceFlags,
    InferenceInfo,
    InferencePriority,
    InferTypeNode,
    InstanceofExpression,
    InstantiableType,
    InstantiationExpressionType,
    InterfaceDeclaration,
    InterfaceType,
    InterfaceTypeWithDeclaredMembers,
    InternalNodeBuilderFlags,
    InternalSymbolName,
    IntersectionFlags,
    IntersectionType,
    IntersectionTypeNode,
    intrinsicTagNameToString,
    IntrinsicType,
    introducesArgumentsExoticObject,
    IntroducesNewScopeNode,
    isAccessExpression,
    isAccessor,
    isAliasableExpression,
    isAmbientModule,
    isArray,
    isArrayBindingPattern,
    isArrayLiteralExpression,
    isArrowFunction,
    isAssertionExpression,
    isAssignmentDeclaration,
    isAssignmentExpression,
    isAssignmentOperator,
    isAssignmentPattern,
    isAssignmentTarget,
    isAutoAccessorPropertyDeclaration,
    isAwaitExpression,
    isBigIntLiteral,
    isBinaryExpression,
    isBinaryLogicalOperator,
    isBindableObjectDefinePropertyCall,
    isBindableStaticElementAccessExpression,
    isBindableStaticNameExpression,
    isBindingElement,
    isBindingElementOfBareOrAccessedRequire,
    isBindingPattern,
    isBlock,
    isBlockOrCatchScoped,
    isBlockScopedContainerTopLevel,
    isBooleanLiteral,
    isCallChain,
    isCallExpression,
    isCallLikeExpression,
    isCallLikeOrFunctionLikeExpression,
    isCallOrNewExpression,
    isCallSignatureDeclaration,
    isCatchClause,
    isCatchClauseVariableDeclaration,
    isCatchClauseVariableDeclarationOrBindingElement,
    isCheckJsEnabledForFile,
    isClassDeclaration,
    isClassElement,
    isClassExpression,
    isClassInstanceProperty,
    isClassLike,
    isClassStaticBlockDeclaration,
    isCommaSequence,
    isCommonJsExportedExpression,
    isCommonJsExportPropertyAssignment,
    isCompoundAssignment,
    isComputedNonLiteralName,
    isComputedPropertyName,
    isConditionalExpression,
    isConditionalTypeNode,
    isConstAssertion,
    isConstructorDeclaration,
    isConstructorTypeNode,
    isConstructSignatureDeclaration,
    isConstTypeReference,
    isDeclaration,
    isDeclarationFileName,
    isDeclarationName,
    isDeclarationReadonly,
    isDecorator,
    isDefaultedExpandoInitializer,
    isDeleteTarget,
    isDottedName,
    isDynamicName,
    isEffectiveExternalModule,
    isElementAccessExpression,
    isEntityName,
    isEntityNameExpression,
    isEnumConst,
    isEnumDeclaration,
    isEnumMember,
    isExclusivelyTypeOnlyImportOrExport,
    isExpandoPropertyDeclaration,
    isExportAssignment,
    isExportDeclaration,
    isExportsIdentifier,
    isExportSpecifier,
    isExpression,
    isExpressionNode,
    isExpressionOfOptionalChainRoot,
    isExpressionStatement,
    isExpressionWithTypeArguments,
    isExpressionWithTypeArgumentsInClassExtendsClause,
    isExternalModule,
    isExternalModuleAugmentation,
    isExternalModuleImportEqualsDeclaration,
    isExternalModuleIndicator,
    isExternalModuleNameRelative,
    isExternalModuleReference,
    isExternalModuleSymbol,
    isExternalOrCommonJsModule,
    isForInOrOfStatement,
    isForInStatement,
    isForOfStatement,
    isForStatement,
    isFunctionDeclaration,
    isFunctionExpression,
    isFunctionExpressionOrArrowFunction,
    isFunctionLike,
    isFunctionLikeDeclaration,
    isFunctionLikeOrClassStaticBlockDeclaration,
    isFunctionOrModuleBlock,
    isFunctionTypeNode,
    isGeneratedIdentifier,
    isGetAccessor,
    isGetAccessorDeclaration,
    isGetOrSetAccessorDeclaration,
    isGlobalScopeAugmentation,
    isGlobalSourceFile,
    isHeritageClause,
    isIdentifier,
    isIdentifierText,
    isIdentifierTypePredicate,
    isIdentifierTypeReference,
    isIfStatement,
    isImportAttributes,
    isImportCall,
    isImportClause,
    isImportDeclaration,
    isImportEqualsDeclaration,
    isImportKeyword,
    isImportOrExportSpecifier,
    isImportSpecifier,
    isImportTypeNode,
    isInCompoundLikeAssignment,
    isIndexedAccessTypeNode,
    isIndexSignatureDeclaration,
    isInExpressionContext,
    isInfinityOrNaNString,
    isInitializedProperty,
    isInJSDoc,
    isInJSFile,
    isInJsonFile,
    isInstanceOfExpression,
    isInterfaceDeclaration,
    isInternalModuleImportEqualsDeclaration,
    isInTopLevelContext,
    isIntrinsicJsxName,
    isInTypeQuery,
    isIterationStatement,
    isJSDocAugmentsTag,
    isJSDocCallbackTag,
    isJSDocConstructSignature,
    isJSDocFunctionType,
    isJSDocImportTag,
    isJSDocIndexSignature,
    isJSDocLinkLike,
    isJSDocMemberName,
    isJSDocNameReference,
    isJSDocNode,
    isJSDocNonNullableType,
    isJSDocNullableType,
    isJSDocOptionalParameter,
    isJSDocOverloadTag,
    isJSDocParameterTag,
    isJSDocPropertyLikeTag,
    isJSDocPropertyTag,
    isJSDocSatisfiesExpression,
    isJSDocSatisfiesTag,
    isJSDocSignature,
    isJSDocTemplateTag,
    isJSDocThisTag,
    isJSDocTypeAlias,
    isJSDocTypeAssertion,
    isJSDocTypedefTag,
    isJSDocTypeExpression,
    isJSDocTypeLiteral,
    isJSDocVariadicType,
    isJsonSourceFile,
    isJsxAttribute,
    isJsxAttributeLike,
    isJsxAttributes,
    isJsxCallLike,
    isJsxElement,
    isJsxFragment,
    isJsxNamespacedName,
    isJsxOpeningElement,
    isJsxOpeningFragment,
    isJsxOpeningLikeElement,
    isJsxSelfClosingElement,
    isJsxSpreadAttribute,
    isJSXTagName,
    isKnownSymbol,
    isLateVisibilityPaintedStatement,
    isLeftHandSideExpression,
    isLineBreak,
    isLiteralComputedPropertyDeclarationName,
    isLiteralExpression,
    isLiteralExpressionOfObject,
    isLiteralImportTypeNode,
    isLiteralTypeNode,
    isLogicalOrCoalescingBinaryExpression,
    isLogicalOrCoalescingBinaryOperator,
    isMetaProperty,
    isMethodDeclaration,
    isMethodSignature,
    isModifier,
    isModuleBlock,
    isModuleDeclaration,
    isModuleExportsAccessExpression,
    isModuleIdentifier,
    isModuleOrEnumDeclaration,
    isModuleWithStringLiteralName,
    isNamedDeclaration,
    isNamedEvaluationSource,
    isNamedExports,
    isNamedTupleMember,
    isNamespaceExport,
    isNamespaceExportDeclaration,
    isNamespaceReexportDeclaration,
    isNewExpression,
    isNodeDescendantOf,
    isNonNullAccess,
    isNonNullExpression,
    isNumericLiteral,
    isNumericLiteralName,
    isObjectBindingPattern,
    isObjectLiteralElementLike,
    isObjectLiteralExpression,
    isObjectLiteralMethod,
    isObjectLiteralOrClassExpressionMethodOrAccessor,
    isOmittedExpression,
    isOptionalChain,
    isOptionalChainRoot,
    isOptionalDeclaration,
    isOptionalJSDocPropertyLikeTag,
    isOptionalTypeNode,
    isOutermostOptionalChain,
    isParameter,
    isParameterPropertyDeclaration,
    isParenthesizedExpression,
    isParenthesizedTypeNode,
    isPartOfParameterDeclaration,
    isPartOfTypeNode,
    isPartOfTypeOnlyImportOrExportDeclaration,
    isPartOfTypeQuery,
    isPlainJsFile,
    isPrefixUnaryExpression,
    isPrivateIdentifier,
    isPrivateIdentifierClassElementDeclaration,
    isPrivateIdentifierPropertyAccessExpression,
    isPropertyAccessEntityNameExpression,
    isPropertyAccessExpression,
    isPropertyAccessOrQualifiedName,
    isPropertyAccessOrQualifiedNameOrImportTypeNode,
    isPropertyAssignment,
    isPropertyDeclaration,
    isPropertyName,
    isPropertyNameLiteral,
    isPropertySignature,
    isPrototypeAccess,
    isPrototypePropertyAssignment,
    isPushOrUnshiftIdentifier,
    isQualifiedName,
    isRequireCall,
    isRestParameter,
    isRestTypeNode,
    isRightSideOfAccessExpression,
    isRightSideOfInstanceofExpression,
    isRightSideOfQualifiedNameOrPropertyAccess,
    isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName,
    isSameEntityName,
    isSetAccessor,
    isSetAccessorDeclaration,
    isShorthandAmbientModuleSymbol,
    isShorthandPropertyAssignment,
    isSideEffectImport,
    isSingleOrDoubleQuote,
    isSourceFile,
    isSourceFileJS,
    isSpreadAssignment,
    isSpreadElement,
    isStatement,
    isStatementWithLocals,
    isStatic,
    isString,
    isStringANonContextualKeyword,
    isStringLiteral,
    isStringLiteralLike,
    isStringOrNumericLiteralLike,
    isSuperCall,
    isSuperProperty,
    isTaggedTemplateExpression,
    isTemplateSpan,
    isThisContainerOrFunctionBlock,
    isThisIdentifier,
    isThisInitializedDeclaration,
    isThisInitializedObjectBindingExpression,
    isThisInTypeQuery,
    isThisProperty,
    isThisTypeParameter,
    isThisTypePredicate,
    isTransientSymbol,
    isTupleTypeNode,
    isTypeAlias,
    isTypeAliasDeclaration,
    isTypeDeclaration,
    isTypeLiteralNode,
    isTypeNode,
    isTypeNodeKind,
    isTypeOfExpression,
    isTypeOnlyImportDeclaration,
    isTypeOnlyImportOrExportDeclaration,
    isTypeOperatorNode,
    isTypeParameterDeclaration,
    isTypePredicateNode,
    isTypeQueryNode,
    isTypeReferenceNode,
    isTypeReferenceType,
    isTypeUsableAsPropertyName,
    isUMDExportSymbol,
    isValidBigIntString,
    isValidESSymbolDeclaration,
    isValidTypeOnlyAliasUseSite,
    isValueSignatureDeclaration,
    isVariableDeclaration,
    isVariableDeclarationInitializedToBareOrAccessedRequire,
    isVariableDeclarationInVariableStatement,
    isVariableDeclarationList,
    isVariableLike,
    isVariableStatement,
    isWriteAccess,
    isWriteOnlyAccess,
    IterableOrIteratorType,
    IterationTypes,
    JSDoc,
    JSDocAugmentsTag,
    JSDocCallbackTag,
    JSDocComment,
    JSDocFunctionType,
    JSDocImplementsTag,
    JSDocImportTag,
    JSDocLink,
    JSDocLinkCode,
    JSDocLinkPlain,
    JSDocMemberName,
    JSDocNullableType,
    JSDocOptionalType,
    JSDocOverloadTag,
    JSDocParameterTag,
    JSDocPrivateTag,
    JSDocPropertyLikeTag,
    JSDocPropertyTag,
    JSDocProtectedTag,
    JSDocPublicTag,
    JSDocSatisfiesTag,
    JSDocSignature,
    JSDocTemplateTag,
    JSDocThisTag,
    JSDocTypeAssertion,
    JSDocTypedefTag,
    JSDocTypeExpression,
    JSDocTypeLiteral,
    JSDocTypeReferencingNode,
    JSDocTypeTag,
    JSDocVariadicType,
    JsxAttribute,
    JsxAttributeLike,
    JsxAttributeName,
    JsxAttributes,
    JsxCallLike,
    JsxChild,
    JsxClosingElement,
    JsxElement,
    JsxEmit,
    JsxExpression,
    JsxFlags,
    JsxFragment,
    JsxNamespacedName,
    JsxOpeningElement,
    JsxOpeningFragment,
    JsxOpeningLikeElement,
    JsxReferenceKind,
    JsxSelfClosingElement,
    JsxSpreadAttribute,
    JsxTagNameExpression,
    KeywordTypeNode,
    LabeledStatement,
    LanguageFeatureMinimumTarget,
    last,
    lastOrUndefined,
    LateBoundBinaryExpressionDeclaration,
    LateBoundDeclaration,
    LateBoundName,
    LateVisibilityPaintedStatement,
    LazyNodeCheckFlags,
    length,
    LiteralExpression,
    LiteralType,
    LiteralTypeNode,
    map,
    mapDefined,
    MappedSymbol,
    MappedType,
    MappedTypeNode,
    MatchingKeys,
    maybeBind,
    MemberOverrideStatus,
    MetaProperty,
    MethodDeclaration,
    MethodSignature,
    minAndMax,
    MinusToken,
    Modifier,
    ModifierFlags,
    modifiersToFlags,
    modifierToFlag,
    ModuleBlock,
    ModuleDeclaration,
    ModuleExportName,
    moduleExportNameIsDefault,
    moduleExportNameTextEscaped,
    moduleExportNameTextUnescaped,
    ModuleInstanceState,
    ModuleKind,
    ModuleName,
    ModuleResolutionKind,
    ModuleSpecifierResolutionHost,
    moduleSupportsImportAttributes,
    Mutable,
    MutableNodeArray,
    NamedDeclaration,
    NamedExports,
    NamedImportsOrExports,
    NamedTupleMember,
    NamespaceDeclaration,
    NamespaceExport,
    NamespaceExportDeclaration,
    NamespaceImport,
    needsScopeMarker,
    NewExpression,
    Node,
    NodeArray,
    NodeBuilderFlags,
    nodeCanBeDecorated,
    NodeCheckFlags,
    NodeFlags,
    nodeHasName,
    nodeIsMissing,
    nodeIsPresent,
    nodeIsSynthesized,
    NodeLinks,
    nodeStartsNewLexicalEnvironment,
    NodeWithTypeArguments,
    NonNullChain,
    NonNullExpression,
    NoSubstitutionTemplateLiteral,
    not,
    noTruncationMaximumTruncationLength,
    NumberLiteralType,
    NumericLiteral,
    objectAllocator,
    ObjectBindingPattern,
    ObjectFlags,
    ObjectFlagsType,
    ObjectLiteralElementLike,
    ObjectLiteralExpression,
    ObjectType,
    OptionalChain,
    OptionalTypeNode,
    or,
    orderedRemoveItemAt,
    OuterExpressionKinds,
    ParameterDeclaration,
    parameterIsThisKeyword,
    ParameterPropertyDeclaration,
    ParenthesizedExpression,
    ParenthesizedTypeNode,
    parseIsolatedEntityName,
    parseNodeFactory,
    parsePseudoBigInt,
    parseValidBigInt,
    Path,
    pathIsRelative,
    PatternAmbientModule,
    PlusToken,
    PostfixUnaryExpression,
    PredicateSemantics,
    PrefixUnaryExpression,
    PrivateIdentifier,
    Program,
    PromiseOrAwaitableType,
    PropertyAccessChain,
    PropertyAccessEntityNameExpression,
    PropertyAccessExpression,
    PropertyAssignment,
    PropertyDeclaration,
    PropertyName,
    PropertySignature,
    PseudoBigInt,
    pseudoBigIntToString,
    PunctuationSyntaxKind,
    pushIfUnique,
    QualifiedName,
    QuestionToken,
    rangeEquals,
    rangeOfNode,
    rangeOfTypeParameters,
    ReadonlyKeyword,
    reduceLeft,
    RegularExpressionLiteral,
    RelationComparisonResult,
    relativeComplement,
    removeExtension,
    removePrefix,
    replaceElement,
    resolutionExtensionIsTSOrJson,
    ResolutionMode,
    ResolvedModuleFull,
    ResolvedType,
    resolvingEmptyArray,
    RestTypeNode,
    ReturnStatement,
    ReverseMappedSymbol,
    ReverseMappedType,
    sameMap,
    SatisfiesExpression,
    Scanner,
    scanTokenAtPosition,
    ScriptKind,
    ScriptTarget,
    SetAccessorDeclaration,
    setCommentRange as setCommentRangeWorker,
    setEmitFlags,
    setIdentifierTypeArguments,
    setNodeFlags,
    setOriginalNode,
    setParent,
    setSyntheticLeadingComments,
    setTextRange as setTextRangeWorker,
    setTextRangePosEnd,
    setValueDeclaration,
    ShorthandPropertyAssignment,
    shouldAllowImportingTsExtension,
    shouldPreserveConstEnums,
    shouldRewriteModuleSpecifier,
    Signature,
    SignatureDeclaration,
    SignatureFlags,
    SignatureKind,
    singleElementArray,
    skipOuterExpressions,
    skipParentheses,
    skipTrivia,
    skipTypeChecking,
    skipTypeParentheses,
    some,
    SourceFile,
    sourceFileMayBeEmitted,
    SpreadAssignment,
    SpreadElement,
    startsWith,
    Statement,
    StringLiteral,
    StringLiteralLike,
    StringLiteralType,
    StringMappingType,
    stripQuotes,
    StructuredType,
    SubstitutionType,
    SuperCall,
    SwitchStatement,
    Symbol,
    SymbolAccessibility,
    SymbolAccessibilityResult,
    SymbolFlags,
    SymbolFormatFlags,
    SymbolId,
    SymbolLinks,
    symbolName,
    SymbolTable,
    SymbolTracker,
    SymbolVisibilityResult,
    SyntacticTypeNodeBuilderContext,
    SyntacticTypeNodeBuilderResolver,
    SyntaxKind,
    SyntheticDefaultModuleType,
    SyntheticExpression,
    TaggedTemplateExpression,
    TemplateExpression,
    TemplateLiteralType,
    TemplateLiteralTypeNode,
    Ternary,
    textRangeContainsPositionInclusive,
    TextSpan,
    textSpanContainsPosition,
    textSpanEnd,
    ThisExpression,
    ThisTypeNode,
    ThrowStatement,
    TokenFlags,
    tokenToString,
    tracing,
    TracingNode,
    TrackedSymbol,
    TransientSymbol,
    TransientSymbolLinks,
    tryAddToSet,
    tryCast,
    tryExtractTSExtension,
    tryGetClassImplementingOrExtendingExpressionWithTypeArguments,
    tryGetExtensionFromPath,
    tryGetJSDocSatisfiesTypeNode,
    tryGetModuleSpecifierFromDeclaration,
    tryGetPropertyAccessOrIdentifierToString,
    TryStatement,
    TupleType,
    TupleTypeNode,
    TupleTypeReference,
    Type,
    TypeAliasDeclaration,
    TypeAssertion,
    TypeChecker,
    TypeCheckerHost,
    TypeComparer,
    TypeElement,
    TypeFlags,
    TypeFormatFlags,
    TypeId,
    TypeLiteralNode,
    TypeMapKind,
    TypeMapper,
    TypeNode,
    TypeNodeSyntaxKind,
    TypeOfExpression,
    TypeOnlyAliasDeclaration,
    TypeOnlyCompatibleAliasDeclaration,
    TypeOperatorNode,
    TypeParameter,
    TypeParameterDeclaration,
    TypePredicate,
    TypePredicateKind,
    TypePredicateNode,
    TypeQueryNode,
    TypeReference,
    TypeReferenceNode,
    TypeReferenceSerializationKind,
    TypeReferenceType,
    TypeVariable,
    unescapeLeadingUnderscores,
    UnionOrIntersectionType,
    UnionOrIntersectionTypeNode,
    UnionReduction,
    UnionType,
    UnionTypeNode,
    UniqueESSymbolType,
    usingSingleLineStringWriter,
    VariableDeclaration,
    VariableDeclarationList,
    VariableLikeDeclaration,
    VariableStatement,
    VarianceFlags,
    visitEachChild as visitEachChildWorker,
    visitNode,
    visitNodes,
    Visitor,
    VisitResult,
    VoidExpression,
    walkUpBindingElementsAndPatterns,
    walkUpOuterExpressions,
    walkUpParenthesizedExpressions,
    walkUpParenthesizedTypes,
    walkUpParenthesizedTypesAndGetParentAndChild,
    WhileStatement,
    WideningContext,
    WithStatement,
    WriterContextOut,
    YieldExpression,
} from "./_namespaces/ts.js";
import * as moduleSpecifiers from "./_namespaces/ts.moduleSpecifiers.js";
import * as performance from "./_namespaces/ts.performance.js";

const ambientModuleSymbolRegex = /^".+"$/;
const anon = "(anonymous)" as __String & string;

const enum ReferenceHint {
    Unspecified,
    Identifier,
    Property,
    ExportAssignment,
    Jsx,
    AsyncFunction,
    ExportImportEquals,
    ExportSpecifier,
    Decorator,
}

let nextSymbolId = 1;
let nextNodeId = 1;
let nextMergeId = 1;
let nextFlowId = 1;

const enum IterationUse {
    AllowsSyncIterablesFlag = 1 << 0,
    AllowsAsyncIterablesFlag = 1 << 1,
    AllowsStringInputFlag = 1 << 2,
    ForOfFlag = 1 << 3,
    YieldStarFlag = 1 << 4,
    SpreadFlag = 1 << 5,
    DestructuringFlag = 1 << 6,
    PossiblyOutOfBounds = 1 << 7,

    // Spread, Destructuring, Array element assignment
    Element = AllowsSyncIterablesFlag,
    Spread = AllowsSyncIterablesFlag | SpreadFlag,
    Destructuring = AllowsSyncIterablesFlag | DestructuringFlag,

    ForOf = AllowsSyncIterablesFlag | AllowsStringInputFlag | ForOfFlag,
    ForAwaitOf = AllowsSyncIterablesFlag | AllowsAsyncIterablesFlag | AllowsStringInputFlag | ForOfFlag,

    YieldStar = AllowsSyncIterablesFlag | YieldStarFlag,
    AsyncYieldStar = AllowsSyncIterablesFlag | AllowsAsyncIterablesFlag | YieldStarFlag,

    GeneratorReturnType = AllowsSyncIterablesFlag,
    AsyncGeneratorReturnType = AllowsAsyncIterablesFlag,
}

const enum IterationTypeKind {
    Yield,
    Return,
    Next,
}

interface IterationTypesResolver {
    iterableCacheKey: "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable";
    iteratorCacheKey: "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator";
    iteratorSymbolName: "asyncIterator" | "iterator";
    getGlobalIteratorType: (reportErrors: boolean) => GenericType;
    getGlobalIterableType: (reportErrors: boolean) => GenericType;
    getGlobalIterableIteratorType: (reportErrors: boolean) => GenericType;
    getGlobalIteratorObjectType: (reportErrors: boolean) => GenericType;
    getGlobalGeneratorType: (reportErrors: boolean) => GenericType;
    getGlobalBuiltinIteratorTypes: () => readonly GenericType[];
    resolveIterationType: (type: Type, errorNode: Node | undefined) => Type | undefined;
    mustHaveANextMethodDiagnostic: DiagnosticMessage;
    mustBeAMethodDiagnostic: DiagnosticMessage;
    mustHaveAValueDiagnostic: DiagnosticMessage;
}

const enum WideningKind {
    Normal,
    FunctionReturn,
    GeneratorNext,
    GeneratorYield,
}

// dprint-ignore
/** @internal */
export const enum TypeFacts {
    None = 0,
    TypeofEQString = 1 << 0,      // typeof x === "string"
    TypeofEQNumber = 1 << 1,      // typeof x === "number"
    TypeofEQBigInt = 1 << 2,      // typeof x === "bigint"
    TypeofEQBoolean = 1 << 3,     // typeof x === "boolean"
    TypeofEQSymbol = 1 << 4,      // typeof x === "symbol"
    TypeofEQObject = 1 << 5,      // typeof x === "object"
    TypeofEQFunction = 1 << 6,    // typeof x === "function"
    TypeofEQHostObject = 1 << 7,  // typeof x === "xxx"
    TypeofNEString = 1 << 8,      // typeof x !== "string"
    TypeofNENumber = 1 << 9,      // typeof x !== "number"
    TypeofNEBigInt = 1 << 10,     // typeof x !== "bigint"
    TypeofNEBoolean = 1 << 11,    // typeof x !== "boolean"
    TypeofNESymbol = 1 << 12,     // typeof x !== "symbol"
    TypeofNEObject = 1 << 13,     // typeof x !== "object"
    TypeofNEFunction = 1 << 14,   // typeof x !== "function"
    TypeofNEHostObject = 1 << 15, // typeof x !== "xxx"
    EQUndefined = 1 << 16,        // x === undefined
    EQNull = 1 << 17,             // x === null
    EQUndefinedOrNull = 1 << 18,  // x === undefined / x === null
    NEUndefined = 1 << 19,        // x !== undefined
    NENull = 1 << 20,             // x !== null
    NEUndefinedOrNull = 1 << 21,  // x != undefined / x != null
    Truthy = 1 << 22,             // x
    Falsy = 1 << 23,              // !x
    IsUndefined = 1 << 24,        // Contains undefined or intersection with undefined
    IsNull = 1 << 25,             // Contains null or intersection with null
    IsUndefinedOrNull = IsUndefined | IsNull,
    All = (1 << 27) - 1,
    // The following members encode facts about particular kinds of types for use in the getTypeFacts function.
    // The presence of a particular fact means that the given test is true for some (and possibly all) values
    // of that kind of type.
    BaseStringStrictFacts = TypeofEQString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseStringFacts = BaseStringStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    StringStrictFacts = BaseStringStrictFacts | Truthy | Falsy,
    StringFacts = BaseStringFacts | Truthy,
    EmptyStringStrictFacts = BaseStringStrictFacts | Falsy,
    EmptyStringFacts = BaseStringFacts,
    NonEmptyStringStrictFacts = BaseStringStrictFacts | Truthy,
    NonEmptyStringFacts = BaseStringFacts | Truthy,
    BaseNumberStrictFacts = TypeofEQNumber | TypeofNEString | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseNumberFacts = BaseNumberStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    NumberStrictFacts = BaseNumberStrictFacts | Truthy | Falsy,
    NumberFacts = BaseNumberFacts | Truthy,
    ZeroNumberStrictFacts = BaseNumberStrictFacts | Falsy,
    ZeroNumberFacts = BaseNumberFacts,
    NonZeroNumberStrictFacts = BaseNumberStrictFacts | Truthy,
    NonZeroNumberFacts = BaseNumberFacts | Truthy,
    BaseBigIntStrictFacts = TypeofEQBigInt | TypeofNEString | TypeofNENumber | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseBigIntFacts = BaseBigIntStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    BigIntStrictFacts = BaseBigIntStrictFacts | Truthy | Falsy,
    BigIntFacts = BaseBigIntFacts | Truthy,
    ZeroBigIntStrictFacts = BaseBigIntStrictFacts | Falsy,
    ZeroBigIntFacts = BaseBigIntFacts,
    NonZeroBigIntStrictFacts = BaseBigIntStrictFacts | Truthy,
    NonZeroBigIntFacts = BaseBigIntFacts | Truthy,
    BaseBooleanStrictFacts = TypeofEQBoolean | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseBooleanFacts = BaseBooleanStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    BooleanStrictFacts = BaseBooleanStrictFacts | Truthy | Falsy,
    BooleanFacts = BaseBooleanFacts | Truthy,
    FalseStrictFacts = BaseBooleanStrictFacts | Falsy,
    FalseFacts = BaseBooleanFacts,
    TrueStrictFacts = BaseBooleanStrictFacts | Truthy,
    TrueFacts = BaseBooleanFacts | Truthy,
    SymbolStrictFacts = TypeofEQSymbol | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull | Truthy,
    SymbolFacts = SymbolStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    ObjectStrictFacts = TypeofEQObject | TypeofEQHostObject | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEFunction | NEUndefined | NENull | NEUndefinedOrNull | Truthy,
    ObjectFacts = ObjectStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    FunctionStrictFacts = TypeofEQFunction | TypeofEQHostObject | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | NEUndefined | NENull | NEUndefinedOrNull | Truthy,
    FunctionFacts = FunctionStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    VoidFacts = TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | EQUndefined | EQUndefinedOrNull | NENull | Falsy,
    UndefinedFacts = TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | EQUndefined | EQUndefinedOrNull | NENull | Falsy | IsUndefined,
    NullFacts = TypeofEQObject | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEFunction | TypeofNEHostObject | EQNull | EQUndefinedOrNull | NEUndefined | Falsy | IsNull,
    EmptyObjectStrictFacts = All & ~(EQUndefined | EQNull | EQUndefinedOrNull | IsUndefinedOrNull),
    EmptyObjectFacts = All & ~IsUndefinedOrNull,
    UnknownFacts = All & ~IsUndefinedOrNull,
    AllTypeofNE = TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | NEUndefined,
    // Masks
    OrFactsMask = TypeofEQFunction | TypeofNEObject,
    AndFactsMask = All & ~OrFactsMask,
}

const typeofNEFacts: ReadonlyMap<string, TypeFacts> = new Map(Object.entries({
    string: TypeFacts.TypeofNEString,
    number: TypeFacts.TypeofNENumber,
    bigint: TypeFacts.TypeofNEBigInt,
    boolean: TypeFacts.TypeofNEBoolean,
    symbol: TypeFacts.TypeofNESymbol,
    undefined: TypeFacts.NEUndefined,
    object: TypeFacts.TypeofNEObject,
    function: TypeFacts.TypeofNEFunction,
}));

type TypeSystemEntity = Node | Symbol | Type | Signature;

const enum TypeSystemPropertyName {
    Type,
    ResolvedBaseConstructorType,
    DeclaredType,
    ResolvedReturnType,
    ImmediateBaseConstraint,
    ResolvedTypeArguments,
    ResolvedBaseTypes,
    WriteType,
    ParameterInitializerContainsUndefined,
}

// dprint-ignore
/** @internal */
export const enum CheckMode {
    Normal = 0,                                     // Normal type checking
    Contextual = 1 << 0,                            // Explicitly assigned contextual type, therefore not cacheable
    Inferential = 1 << 1,                           // Inferential typing
    SkipContextSensitive = 1 << 2,                  // Skip context sensitive function expressions
    SkipGenericFunctions = 1 << 3,                  // Skip single signature generic functions
    IsForSignatureHelp = 1 << 4,                    // Call resolution for purposes of signature help
    RestBindingElement = 1 << 5,                    // Checking a type that is going to be used to determine the type of a rest binding element
                                                    //   e.g. in `const { a, ...rest } = foo`, when checking the type of `foo` to determine the type of `rest`,
                                                    //   we need to preserve generic types instead of substituting them for constraints
    TypeOnly = 1 << 6,                              // Called from getTypeOfExpression, diagnostics may be omitted
}

/** @internal */
export const enum SignatureCheckMode {
    None = 0,
    BivariantCallback = 1 << 0,
    StrictCallback = 1 << 1,
    IgnoreReturnTypes = 1 << 2,
    StrictArity = 1 << 3,
    StrictTopSignature = 1 << 4,
    Callback = BivariantCallback | StrictCallback,
}

const enum IntersectionState {
    None = 0,
    Source = 1 << 0, // Source type is a constituent of an outer intersection
    Target = 1 << 1, // Target type is a constituent of an outer intersection
}

const enum RecursionFlags {
    None = 0,
    Source = 1 << 0,
    Target = 1 << 1,
    Both = Source | Target,
}

const enum MappedTypeModifiers {
    IncludeReadonly = 1 << 0,
    ExcludeReadonly = 1 << 1,
    IncludeOptional = 1 << 2,
    ExcludeOptional = 1 << 3,
}

const enum MappedTypeNameTypeKind {
    None,
    Filtering,
    Remapping,
}

const enum ExpandingFlags {
    None = 0,
    Source = 1,
    Target = 1 << 1,
    Both = Source | Target,
}

const enum MembersOrExportsResolutionKind {
    resolvedExports = "resolvedExports",
    resolvedMembers = "resolvedMembers",
}

const enum UnusedKind {
    Local,
    Parameter,
}

/** @param containingNode Node to check for parse error */
type AddUnusedDiagnostic = (containingNode: Node, type: UnusedKind, diagnostic: DiagnosticWithLocation) => void;

const isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor);

const enum DeclarationMeaning {
    GetAccessor = 1,
    SetAccessor = 2,
    PropertyAssignment = 4,
    Method = 8,
    PrivateStatic = 16,
    GetOrSetAccessor = GetAccessor | SetAccessor,
    PropertyAssignmentOrMethod = PropertyAssignment | Method,
}

const enum DeclarationSpaces {
    None = 0,
    ExportValue = 1 << 0,
    ExportType = 1 << 1,
    ExportNamespace = 1 << 2,
}

const enum MinArgumentCountFlags {
    None = 0,
    StrongArityForUntypedJS = 1 << 0,
    VoidIsNonOptional = 1 << 1,
}

const enum IntrinsicTypeKind {
    Uppercase,
    Lowercase,
    Capitalize,
    Uncapitalize,
    NoInfer,
}

const intrinsicTypeKinds: ReadonlyMap<string, IntrinsicTypeKind> = new Map(Object.entries({
    Uppercase: IntrinsicTypeKind.Uppercase,
    Lowercase: IntrinsicTypeKind.Lowercase,
    Capitalize: IntrinsicTypeKind.Capitalize,
    Uncapitalize: IntrinsicTypeKind.Uncapitalize,
    NoInfer: IntrinsicTypeKind.NoInfer,
}));

const SymbolLinks = class implements SymbolLinks {
    declare _symbolLinksBrand: any;
};

function NodeLinks(this: NodeLinks) {
    this.flags = NodeCheckFlags.None;
}

/** @internal */
export function getNodeId(node: Node): number {
    if (!node.id) {
        node.id = nextNodeId;
        nextNodeId++;
    }
    return node.id;
}

/** @internal */
export function getSymbolId(symbol: Symbol): SymbolId {
    if (!symbol.id) {
        symbol.id = nextSymbolId;
        nextSymbolId++;
    }

    return symbol.id;
}

/** @internal */
export function isInstantiatedModule(node: ModuleDeclaration, preserveConstEnums: boolean): boolean {
    const moduleState = getModuleInstanceState(node);
    return moduleState === ModuleInstanceState.Instantiated ||
        (preserveConstEnums && moduleState === ModuleInstanceState.ConstEnumOnly);
}

/** @internal */
export function createTypeChecker(host: TypeCheckerHost): TypeChecker {
    // Why var? It avoids TDZ checks in the runtime which can be costly.
    // See: https://github.com/microsoft/TypeScript/issues/52924
    /* eslint-disable no-var */
    var deferredDiagnosticsCallbacks: (() => void)[] = [];

    var addLazyDiagnostic = (arg: () => void) => {
        deferredDiagnosticsCallbacks.push(arg);
    };

    // Cancellation that controls whether or not we can cancel in the middle of type checking.
    // In general cancelling is *not* safe for the type checker.  We might be in the middle of
    // computing something, and we will leave our internals in an inconsistent state.  Callers
    // who set the cancellation token should catch if a cancellation exception occurs, and
    // should throw away and create a new TypeChecker.
    //
    // Currently we only support setting the cancellation token when getting diagnostics.  This
    // is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
    // they no longer need the information (for example, if the user started editing again).
    var cancellationToken: CancellationToken | undefined;

    var scanner: Scanner | undefined;

    var Symbol = objectAllocator.getSymbolConstructor();
    var Type = objectAllocator.getTypeConstructor();
    var Signature = objectAllocator.getSignatureConstructor();

    var typeCount = 0;
    var symbolCount = 0;
    var totalInstantiationCount = 0;
    var instantiationCount = 0;
    var instantiationDepth = 0;
    var inlineLevel = 0;
    var currentNode: Node | undefined;
    var varianceTypeParameter: TypeParameter | undefined;
    var isInferencePartiallyBlocked = false;

    var emptySymbols = createSymbolTable();
    var arrayVariances = [VarianceFlags.Covariant];

    var compilerOptions = host.getCompilerOptions();
    var languageVersion = getEmitScriptTarget(compilerOptions);
    var moduleKind = getEmitModuleKind(compilerOptions);
    var legacyDecorators = !!compilerOptions.experimentalDecorators;
    var useDefineForClassFields = getUseDefineForClassFields(compilerOptions);
    var emitStandardClassFields = getEmitStandardClassFields(compilerOptions);
    var allowSyntheticDefaultImports = getAllowSyntheticDefaultImports(compilerOptions);
    var strictNullChecks = getStrictOptionValue(compilerOptions, "strictNullChecks");
    var strictFunctionTypes = getStrictOptionValue(compilerOptions, "strictFunctionTypes");
    var strictBindCallApply = getStrictOptionValue(compilerOptions, "strictBindCallApply");
    var strictPropertyInitialization = getStrictOptionValue(compilerOptions, "strictPropertyInitialization");
    var strictBuiltinIteratorReturn = getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn");
    var noImplicitAny = getStrictOptionValue(compilerOptions, "noImplicitAny");
    var noImplicitThis = getStrictOptionValue(compilerOptions, "noImplicitThis");
    var useUnknownInCatchVariables = getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables");
    var exactOptionalPropertyTypes = compilerOptions.exactOptionalPropertyTypes;
    var noUncheckedSideEffectImports = !!compilerOptions.noUncheckedSideEffectImports;

    var checkBinaryExpression = createCheckBinaryExpression();
    var emitResolver = createResolver();
    var nodeBuilder = createNodeBuilder();
    var syntacticNodeBuilder = createSyntacticTypeNodeBuilder(compilerOptions, nodeBuilder.syntacticBuilderResolver);
    var evaluate = createEvaluator({
        evaluateElementAccessExpression,
        evaluateEntityNameExpression,
    });

    var globals = createSymbolTable();
    var undefinedSymbol = createSymbol(SymbolFlags.Property, "undefined" as __String);
    undefinedSymbol.declarations = [];

    var globalThisSymbol = createSymbol(SymbolFlags.Module, "globalThis" as __String, CheckFlags.Readonly);
    globalThisSymbol.exports = globals;
    globalThisSymbol.declarations = [];
    globals.set(globalThisSymbol.escapedName, globalThisSymbol);

    var argumentsSymbol = createSymbol(SymbolFlags.Property, "arguments" as __String);
    var requireSymbol = createSymbol(SymbolFlags.Property, "require" as __String);
    var isolatedModulesLikeFlagName = compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules";
    var canCollectSymbolAliasAccessabilityData = !compilerOptions.verbatimModuleSyntax;

    /** This will be set during calls to `getResolvedSignature` where services determines an apparent number of arguments greater than what is actually provided. */
    var apparentArgumentCount: number | undefined;

    var lastGetCombinedNodeFlagsNode: Node | undefined;
    var lastGetCombinedNodeFlagsResult = NodeFlags.None;
    var lastGetCombinedModifierFlagsNode: Declaration | undefined;
    var lastGetCombinedModifierFlagsResult = ModifierFlags.None;
    var resolveName = createNameResolver({
        compilerOptions,
        requireSymbol,
        argumentsSymbol,
        globals,
        getSymbolOfDeclaration,
        error,
        getRequiresScopeChangeCache,
        setRequiresScopeChangeCache,
        lookup: getSymbol,
        onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer,
        onFailedToResolveSymbol,
        onSuccessfullyResolvedSymbol,
    });

    var resolveNameForSymbolSuggestion = createNameResolver({
        compilerOptions,
        requireSymbol,
        argumentsSymbol,
        globals,
        getSymbolOfDeclaration,
        error,
        getRequiresScopeChangeCache,
        setRequiresScopeChangeCache,
        lookup: getSuggestionForSymbolNameLookup,
    });
    // for public members that accept a Node or one of its subtypes, we must guard against
    // synthetic nodes created during transformations by calling `getParseTreeNode`.
    // for most of these, we perform the guard only on `checker` to avoid any possible
    // extra cost of calling `getParseTreeNode` when calling these functions from inside the
    // checker.
    const checker: TypeChecker = {
        getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0),
        getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0),
        getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount),
        getTypeCount: () => typeCount,
        getInstantiationCount: () => totalInstantiationCount,
        getRelationCacheSizes: () => ({
            assignable: assignableRelation.size,
            identity: identityRelation.size,
            subtype: subtypeRelation.size,
            strictSubtype: strictSubtypeRelation.size,
        }),
        isUndefinedSymbol: symbol => symbol === undefinedSymbol,
        isArgumentsSymbol: symbol => symbol === argumentsSymbol,
        isUnknownSymbol: symbol => symbol === unknownSymbol,
        getMergedSymbol,
        symbolIsValue,
        getDiagnostics,
        getGlobalDiagnostics,
        getRecursionIdentity,
        getUnmatchedProperties,
        getTypeOfSymbolAtLocation: (symbol, locationIn) => {
            const location = getParseTreeNode(locationIn);
            return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
        },
        getTypeOfSymbol,
        getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {
            const parameter = getParseTreeNode(parameterIn, isParameter);
            if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");
            Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent));
            return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));
        },
        getDeclaredTypeOfSymbol,
        getPropertiesOfType,
        getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),
        getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {
            const node = getParseTreeNode(location);
            if (!node) {
                return undefined;
            }
            const propName = escapeLeadingUnderscores(name);
            const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);
            return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;
        },
        getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),
        getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType),
        getIndexInfosOfType,
        getIndexInfosOfIndexSymbol,
        getSignaturesOfType,
        getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),
        getIndexType: type => getIndexType(type),
        getBaseTypes,
        getBaseTypeOfLiteralType,
        getWidenedType,
        getWidenedLiteralType,
        fillMissingTypeArguments,
        getTypeFromTypeNode: nodeIn => {
            const node = getParseTreeNode(nodeIn, isTypeNode);
            return node ? getTypeFromTypeNode(node) : errorType;
        },
        getParameterType: getTypeAtPosition,
        getParameterIdentifierInfoAtPosition,
        getPromisedTypeOfPromise,
        getAwaitedType: type => getAwaitedType(type),
        getReturnTypeOfSignature,
        isNullableType,
        getNullableType,
        getNonNullableType,
        getNonOptionalType: removeOptionalTypeMarker,
        getTypeArguments,
        typeToTypeNode: nodeBuilder.typeToTypeNode,
        typePredicateToTypePredicateNode: nodeBuilder.typePredicateToTypePredicateNode,
        indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
        signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
        symbolToEntityName: nodeBuilder.symbolToEntityName,
        symbolToExpression: nodeBuilder.symbolToExpression,
        symbolToNode: nodeBuilder.symbolToNode,
        symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
        symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
        typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
        getSymbolsInScope: (locationIn, meaning) => {
            const location = getParseTreeNode(locationIn);
            return location ? getSymbolsInScope(location, meaning) : [];
        },
        getSymbolAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors
            return node ? getSymbolAtLocation(node, /*ignoreErrors*/ true) : undefined;
        },
        getIndexInfosAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return node ? getIndexInfosAtLocation(node) : undefined;
        },
        getShorthandAssignmentValueSymbol: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return node ? getShorthandAssignmentValueSymbol(node) : undefined;
        },
        getExportSpecifierLocalTargetSymbol: nodeIn => {
            const node = getParseTreeNode(nodeIn, isExportSpecifier);
            return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;
        },
        getExportSymbolOfSymbol(symbol) {
            return getMergedSymbol(symbol.exportSymbol || symbol);
        },
        getTypeAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return node ? getTypeOfNode(node) : errorType;
        },
        getTypeOfAssignmentPattern: nodeIn => {
            const node = getParseTreeNode(nodeIn, isAssignmentPattern);
            return node && getTypeOfAssignmentPattern(node) || errorType;
        },
        getPropertySymbolOfDestructuringAssignment: locationIn => {
            const location = getParseTreeNode(locationIn, isIdentifier);
            return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;
        },
        signatureToString: (signature, enclosingDeclaration, flags, kind) => {
            return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);
        },
        typeToString: (type, enclosingDeclaration, flags) => {
            return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);
        },
        symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {
            return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags);
        },
        typePredicateToString: (predicate, enclosingDeclaration, flags) => {
            return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);
        },
        writeSignature: (signature, enclosingDeclaration, flags, kind, writer, maximumLength, verbosityLevel, out) => {
            return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer, maximumLength, verbosityLevel, out);
        },
        writeType: (type, enclosingDeclaration, flags, writer, maximumLength, verbosityLevel, out) => {
            return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer, maximumLength, verbosityLevel, out);
        },
        writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {
            return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);
        },
        writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {
            return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);
        },
        getAugmentedPropertiesOfType,
        getRootSymbols,
        getSymbolOfExpando,
        getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {
            const node = getParseTreeNode(nodeIn, isExpression);
            if (!node) {
                return undefined;
            }
            if (contextFlags! & ContextFlags.Completions) {
                return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags));
            }
            return getContextualType(node, contextFlags);
        },
        getContextualTypeForObjectLiteralElement: nodeIn => {
            const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);
            return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags*/ undefined) : undefined;
        },
        getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {
            const node = getParseTreeNode(nodeIn, isCallLikeExpression);
            return node && getContextualTypeForArgumentAtIndex(node, argIndex);
        },
        getContextualTypeForJsxAttribute: nodeIn => {
            const node = getParseTreeNode(nodeIn, isJsxAttributeLike);
            return node && getContextualTypeForJsxAttribute(node, /*contextFlags*/ undefined);
        },
        isContextSensitive,
        getTypeOfPropertyOfContextualType,
        getFullyQualifiedName,
        getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),
        getCandidateSignaturesForStringLiteralCompletions,
        getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)),
        getExpandedParameters,
        hasEffectiveRestParameter,
        containsArgumentsReference,
        getConstantValue: nodeIn => {
            const node = getParseTreeNode(nodeIn, canHaveConstantValue);
            return node ? getConstantValue(node) : undefined;
        },
        isValidPropertyAccess: (nodeIn, propertyName) => {
            const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);
            return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));
        },
        isValidPropertyAccessForCompletions: (nodeIn, type, property) => {
            const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);
            return !!node && isValidPropertyAccessForCompletions(node, type, property);
        },
        getSignatureFromDeclaration: declarationIn => {
            const declaration = getParseTreeNode(declarationIn, isFunctionLike);
            return declaration ? getSignatureFromDeclaration(declaration) : undefined;
        },
        isImplementationOfOverload: nodeIn => {
            const node = getParseTreeNode(nodeIn, isFunctionLike);
            return node ? isImplementationOfOverload(node) : undefined;
        },
        getImmediateAliasedSymbol,
        getAliasedSymbol: resolveAlias,
        getEmitResolver,
        requiresAddingImplicitUndefined,
        getExportsOfModule: getExportsOfModuleAsArray,
        getExportsAndPropertiesOfModule,
        forEachExportAndPropertyOfModule,
        getSymbolWalker: createGetSymbolWalker(
            getRestTypeOfSignature,
            getTypePredicateOfSignature,
            getReturnTypeOfSignature,
            getBaseTypes,
            resolveStructuredTypeMembers,
            getTypeOfSymbol,
            getResolvedSymbol,
            getConstraintOfTypeParameter,
            getFirstIdentifier,
            getTypeArguments,
        ),
        getAmbientModules,
        getJsxIntrinsicTagNamesAt,
        isOptionalParameter: nodeIn => {
            const node = getParseTreeNode(nodeIn, isParameter);
            return node ? isOptionalParameter(node) : false;
        },
        tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),
        tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),
        tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations*/ true),
        getApparentType,
        getUnionType,
        isTypeAssignableTo,
        createAnonymousType,
        createSignature,
        createSymbol,
        createIndexInfo,
        getAnyType: () => anyType,
        getStringType: () => stringType,
        getStringLiteralType,
        getNumberType: () => numberType,
        getNumberLiteralType,
        getBigIntType: () => bigintType,
        getBigIntLiteralType,
        getUnknownType: () => unknownType,
        createPromiseType,
        createArrayType,
        getElementTypeOfArrayType,
        getBooleanType: () => booleanType,
        getFalseType: (fresh?) => fresh ? falseType : regularFalseType,
        getTrueType: (fresh?) => fresh ? trueType : regularTrueType,
        getVoidType: () => voidType,
        getUndefinedType: () => undefinedType,
        getNullType: () => nullType,
        getESSymbolType: () => esSymbolType,
        getNeverType: () => neverType,
        getNonPrimitiveType: () => nonPrimitiveType,
        getOptionalType: () => optionalType,
        getPromiseType: () => getGlobalPromiseType(/*reportErrors*/ false),
        getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors*/ false),
        getAnyAsyncIterableType: () => {
            const type = getGlobalAsyncIterableType(/*reportErrors*/ false);
            if (type === emptyGenericType) return undefined;
            return createTypeReference(type, [anyType, anyType, anyType]);
        },
        isSymbolAccessible,
        isArrayType,
        isTupleType,
        isArrayLikeType,
        isEmptyAnonymousObjectType,
        isTypeInvalidDueToUnionDiscriminant,
        getExactOptionalProperties,
        getAllPossiblePropertiesOfTypes,
        getSuggestedSymbolForNonexistentProperty,
        getSuggestedSymbolForNonexistentJSXAttribute,
        getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),
        getSuggestedSymbolForNonexistentModule,
        getSuggestedSymbolForNonexistentClassMember,
        getBaseConstraintOfType,
        getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,
        resolveName(name, location, meaning, excludeGlobals) {
            return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ false, excludeGlobals);
        },
        getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),
        getJsxFragmentFactory: n => {
            const jsxFragmentFactory = getJsxFragmentFactoryEntity(n);
            return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);
        },
        getAccessibleSymbolChain,
        getTypePredicateOfSignature,
        resolveExternalModuleName: moduleSpecifierIn => {
            const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);
            return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors*/ true);
        },
        resolveExternalModuleSymbol,
        tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {
            const node = getParseTreeNode(nodeIn);
            return node && tryGetThisTypeAt(node, includeGlobalThis, container);
        },
        getTypeArgumentConstraint: nodeIn => {
            const node = getParseTreeNode(nodeIn, isTypeNode);
            return node && getTypeArgumentConstraint(node);
        },
        getSuggestionDiagnostics: (fileIn, ct) => {
            const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");
            if (skipTypeChecking(file, compilerOptions, host)) {
                return emptyArray;
            }

            let diagnostics: DiagnosticWithLocation[] | undefined;
            try {
                // Record the cancellation token so it can be checked later on during checkSourceElement.
                // Do this in a finally block so we can ensure that it gets reset back to nothing after
                // this call is done.
                cancellationToken = ct;

                // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused
                checkSourceFileWithEagerDiagnostics(file);
                Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));

                diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));
                checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {
                    if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {
                        (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });
                    }
                });

                return diagnostics || emptyArray;
            }
            finally {
                cancellationToken = undefined;
            }
        },

        runWithCancellationToken: (token, callback) => {
            try {
                cancellationToken = token;
                return callback(checker);
            }
            finally {
                cancellationToken = undefined;
            }
        },

        getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
        isDeclarationVisible,
        isPropertyAccessible,
        getTypeOnlyAliasDeclaration,
        getMemberOverrideModifierStatus,
        isTypeParameterPossiblyReferenced,
        typeHasCallOrConstructSignatures,
        getSymbolFlags,
        getTypeArgumentsForResolvedSignature,
        isLibType,
    };

    function getTypeArgumentsForResolvedSignature(signature: Signature) {
        if (signature.mapper === undefined) return undefined;
        return instantiateTypes((signature.target || signature).typeParameters, signature.mapper);
    }

    function getCandidateSignaturesForStringLiteralCompletions(call: CallLikeExpression, editingArgument: Node) {
        const candidatesSet = new Set<Signature>();
        const candidates: Signature[] = [];

        // first, get candidates when inference is blocked from the source node.
        runWithInferenceBlockedFromSourceNode(editingArgument, () => getResolvedSignatureWorker(call, candidates, /*argumentCount*/ undefined, CheckMode.Normal));
        for (const candidate of candidates) {
            candidatesSet.add(candidate);
        }

        // reset candidates for second pass
        candidates.length = 0;

        // next, get candidates where the source node is considered for inference.
        runWithoutResolvedSignatureCaching(editingArgument, () => getResolvedSignatureWorker(call, candidates, /*argumentCount*/ undefined, CheckMode.Normal));
        for (const candidate of candidates) {
            candidatesSet.add(candidate);
        }

        return arrayFrom(candidatesSet);
    }

    function runWithoutResolvedSignatureCaching<T>(node: Node | undefined, fn: () => T): T {
        node = findAncestor(node, isCallLikeOrFunctionLikeExpression);
        if (node) {
            const cachedResolvedSignatures = [];
            const cachedTypes = [];
            while (node) {
                const nodeLinks = getNodeLinks(node);
                cachedResolvedSignatures.push([nodeLinks, nodeLinks.resolvedSignature] as const);
                nodeLinks.resolvedSignature = undefined;
                if (isFunctionExpressionOrArrowFunction(node)) {
                    const symbolLinks = getSymbolLinks(getSymbolOfDeclaration(node));
                    const type = symbolLinks.type;
                    cachedTypes.push([symbolLinks, type] as const);
                    symbolLinks.type = undefined;
                }
                node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression);
            }
            const result = fn();
            for (const [nodeLinks, resolvedSignature] of cachedResolvedSignatures) {
                nodeLinks.resolvedSignature = resolvedSignature;
            }
            for (const [symbolLinks, type] of cachedTypes) {
                symbolLinks.type = type;
            }
            return result;
        }
        return fn();
    }

    function runWithInferenceBlockedFromSourceNode<T>(node: Node | undefined, fn: () => T): T {
        const containingCall = findAncestor(node, isCallLikeExpression);
        if (containingCall) {
            let toMarkSkip = node!;
            do {
                getNodeLinks(toMarkSkip).skipDirectInference = true;
                toMarkSkip = toMarkSkip.parent;
            }
            while (toMarkSkip && toMarkSkip !== containingCall);
        }

        isInferencePartiallyBlocked = true;
        const result = runWithoutResolvedSignatureCaching(node, fn);
        isInferencePartiallyBlocked = false;

        if (containingCall) {
            let toMarkSkip = node!;
            do {
                getNodeLinks(toMarkSkip).skipDirectInference = undefined;
                toMarkSkip = toMarkSkip.parent;
            }
            while (toMarkSkip && toMarkSkip !== containingCall);
        }
        return result;
    }

    function getResolvedSignatureWorker(nodeIn: CallLikeExpression, candidatesOutArray: Signature[] | undefined, argumentCount: number | undefined, checkMode: CheckMode): Signature | undefined {
        const node = getParseTreeNode(nodeIn, isCallLikeExpression);
        apparentArgumentCount = argumentCount;
        const res = !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode);
        apparentArgumentCount = undefined;
        return res;
    }

    var tupleTypes = new Map<string, GenericType>();
    var unionTypes = new Map<string, UnionType>();
    var unionOfUnionTypes = new Map<string, Type>();
    var intersectionTypes = new Map<string, Type>();
    var stringLiteralTypes = new Map<string, StringLiteralType>();
    var numberLiteralTypes = new Map<number, NumberLiteralType>();
    var bigIntLiteralTypes = new Map<string, BigIntLiteralType>();
    var enumLiteralTypes = new Map<string, LiteralType>();
    var indexedAccessTypes = new Map<string, IndexedAccessType>();
    var templateLiteralTypes = new Map<string, TemplateLiteralType>();
    var stringMappingTypes = new Map<string, StringMappingType>();
    var substitutionTypes = new Map<string, SubstitutionType>();
    var subtypeReductionCache = new Map<string, Type[]>();
    var decoratorContextOverrideTypeCache = new Map<string, Type>();
    var cachedTypes = new Map<string, Type>();
    var evolvingArrayTypes: EvolvingArrayType[] = [];
    var undefinedProperties: SymbolTable = new Map();
    var markerTypes = new Set<number>();

    var unknownSymbol = createSymbol(SymbolFlags.Property, "unknown" as __String);
    var resolvingSymbol = createSymbol(0, InternalSymbolName.Resolving);
    var unresolvedSymbols = new Map<string, TransientSymbol>();
    var errorTypes = new Map<string, Type>();

    // We specifically create the `undefined` and `null` types before any other types that can occur in
    // unions such that they are given low type IDs and occur first in the sorted list of union constituents.
    // We can then just examine the first constituent(s) of a union to check for their presence.

    var seenIntrinsicNames = new Set<string>();

    var anyType = createIntrinsicType(TypeFlags.Any, "any");
    var autoType = createIntrinsicType(TypeFlags.Any, "any", ObjectFlags.NonInferrableType, "auto");
    var wildcardType = createIntrinsicType(TypeFlags.Any, "any", /*objectFlags*/ undefined, "wildcard");
    var blockedStringType = createIntrinsicType(TypeFlags.Any, "any", /*objectFlags*/ undefined, "blocked string");
    var errorType = createIntrinsicType(TypeFlags.Any, "error");
    var unresolvedType = createIntrinsicType(TypeFlags.Any, "unresolved");
    var nonInferrableAnyType = createIntrinsicType(TypeFlags.Any, "any", ObjectFlags.ContainsWideningType, "non-inferrable");
    var intrinsicMarkerType = createIntrinsicType(TypeFlags.Any, "intrinsic");
    var unknownType = createIntrinsicType(TypeFlags.Unknown, "unknown");
    var undefinedType = createIntrinsicType(TypeFlags.Undefined, "undefined");
    var undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening");
    var missingType = createIntrinsicType(TypeFlags.Undefined, "undefined", /*objectFlags*/ undefined, "missing");
    var undefinedOrMissingType = exactOptionalPropertyTypes ? missingType : undefinedType;
    var optionalType = createIntrinsicType(TypeFlags.Undefined, "undefined", /*objectFlags*/ undefined, "optional");
    var nullType = createIntrinsicType(TypeFlags.Null, "null");
    var nullWideningType = strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening");
    var stringType = createIntrinsicType(TypeFlags.String, "string");
    var numberType = createIntrinsicType(TypeFlags.Number, "number");
    var bigintType = createIntrinsicType(TypeFlags.BigInt, "bigint");
    var falseType = createIntrinsicType(TypeFlags.BooleanLiteral, "false", /*objectFlags*/ undefined, "fresh") as FreshableIntrinsicType;
    var regularFalseType = createIntrinsicType(TypeFlags.BooleanLiteral, "false") as FreshableIntrinsicType;
    var trueType = createIntrinsicType(TypeFlags.BooleanLiteral, "true", /*objectFlags*/ undefined, "fresh") as FreshableIntrinsicType;
    var regularTrueType = createIntrinsicType(TypeFlags.BooleanLiteral, "true") as FreshableIntrinsicType;
    trueType.regularType = regularTrueType;
    trueType.freshType = trueType;
    regularTrueType.regularType = regularTrueType;
    regularTrueType.freshType = trueType;
    falseType.regularType = regularFalseType;
    falseType.freshType = falseType;
    regularFalseType.regularType = regularFalseType;
    regularFalseType.freshType = falseType;
    var booleanType = getUnionType([regularFalseType, regularTrueType]);
    var esSymbolType = createIntrinsicType(TypeFlags.ESSymbol, "symbol");
    var voidType = createIntrinsicType(TypeFlags.Void, "void");
    var neverType = createIntrinsicType(TypeFlags.Never, "never");
    var silentNeverType = createIntrinsicType(TypeFlags.Never, "never", ObjectFlags.NonInferrableType, "silent");
    var implicitNeverType = createIntrinsicType(TypeFlags.Never, "never", /*objectFlags*/ undefined, "implicit");
    var unreachableNeverType = createIntrinsicType(TypeFlags.Never, "never", /*objectFlags*/ undefined, "unreachable");
    var nonPrimitiveType = createIntrinsicType(TypeFlags.NonPrimitive, "object");
    var stringOrNumberType = getUnionType([stringType, numberType]);
    var stringNumberSymbolType = getUnionType([stringType, numberType, esSymbolType]);
    var numberOrBigIntType = getUnionType([numberType, bigintType]);
    var templateConstraintType = getUnionType([stringType, numberType, booleanType, bigintType, nullType, undefinedType]) as UnionType;
    var numericStringType = getTemplateLiteralType(["", ""], [numberType]); // The `${number}` type

    var restrictiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t, () => "(restrictive mapper)");
    var permissiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags.TypeParameter ? wildcardType : t, () => "(permissive mapper)");
    var uniqueLiteralType = createIntrinsicType(TypeFlags.Never, "never", /*objectFlags*/ undefined, "unique literal"); // `uniqueLiteralType` is a special `never` flagged by union reduction to behave as a literal
    var uniqueLiteralMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags.TypeParameter ? uniqueLiteralType : t, () => "(unique literal mapper)"); // replace all type parameters with the unique literal type (disregarding constraints)
    var outofbandVarianceMarkerHandler: ((onlyUnreliable: boolean) => void) | undefined;
    var reportUnreliableMapper = makeFunctionTypeMapper(t => {
        if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {
            outofbandVarianceMarkerHandler(/*onlyUnreliable*/ true);
        }
        return t;
    }, () => "(unmeasurable reporter)");
    var reportUnmeasurableMapper = makeFunctionTypeMapper(t => {
        if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {
            outofbandVarianceMarkerHandler(/*onlyUnreliable*/ false);
        }
        return t;
    }, () => "(unreliable reporter)");

    var emptyObjectType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var emptyJsxObjectType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    emptyJsxObjectType.objectFlags |= ObjectFlags.JsxAttributes;
    var emptyFreshJsxObjectType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    emptyFreshJsxObjectType.objectFlags |= ObjectFlags.JsxAttributes | ObjectFlags.FreshLiteral | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;

    var emptyTypeLiteralSymbol = createSymbol(SymbolFlags.TypeLiteral, InternalSymbolName.Type);
    emptyTypeLiteralSymbol.members = createSymbolTable();
    var emptyTypeLiteralType = createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray);

    var unknownEmptyObjectType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var unknownUnionType = strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType;

    var emptyGenericType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray) as ObjectType as GenericType;
    emptyGenericType.instantiations = new Map<string, TypeReference>();

    var anyFunctionType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    // The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated
    // in getPropagatingFlagsOfTypes, and it is checked in inferFromTypes.
    anyFunctionType.objectFlags |= ObjectFlags.NonInferrableType;

    var noConstraintType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var circularConstraintType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var resolvingDefaultType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);

    var markerSuperType = createTypeParameter();
    var markerSubType = createTypeParameter();
    markerSubType.constraint = markerSuperType;
    var markerOtherType = createTypeParameter();

    var markerSuperTypeForCheck = createTypeParameter();
    var markerSubTypeForCheck = createTypeParameter();
    markerSubTypeForCheck.constraint = markerSuperTypeForCheck;

    var noTypePredicate = createTypePredicate(TypePredicateKind.Identifier, "<<unresolved>>", 0, anyType);

    var anySignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, anyType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
    var unknownSignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, errorType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
    var resolvingSignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, anyType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
    var silentNeverSignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, silentNeverType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);

    var enumNumberIndexInfo = createIndexInfo(numberType, stringType, /*isReadonly*/ true);
    var anyBaseTypeIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly*/ false);

    var iterationTypesCache = new Map<string, IterationTypes>(); // cache for common IterationTypes instances
    var noIterationTypes: IterationTypes = {
        get yieldType(): Type {
            return Debug.fail("Not supported");
        },
        get returnType(): Type {
            return Debug.fail("Not supported");
        },
        get nextType(): Type {
            return Debug.fail("Not supported");
        },
    };

    var anyIterationTypes = createIterationTypes(anyType, anyType, anyType);

    var asyncIterationTypesResolver: IterationTypesResolver = {
        iterableCacheKey: "iterationTypesOfAsyncIterable",
        iteratorCacheKey: "iterationTypesOfAsyncIterator",
        iteratorSymbolName: "asyncIterator",
        getGlobalIteratorType: getGlobalAsyncIteratorType,
        getGlobalIterableType: getGlobalAsyncIterableType,
        getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
        getGlobalIteratorObjectType: getGlobalAsyncIteratorObjectType,
        getGlobalGeneratorType: getGlobalAsyncGeneratorType,
        getGlobalBuiltinIteratorTypes: getGlobalBuiltinAsyncIteratorTypes,
        resolveIterationType: (type, errorNode) => getAwaitedType(type, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member),
        mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,
        mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
        mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
    };

    var syncIterationTypesResolver: IterationTypesResolver = {
        iterableCacheKey: "iterationTypesOfIterable",
        iteratorCacheKey: "iterationTypesOfIterator",
        iteratorSymbolName: "iterator",
        getGlobalIteratorType,
        getGlobalIterableType,
        getGlobalIterableIteratorType,
        getGlobalIteratorObjectType,
        getGlobalGeneratorType,
        getGlobalBuiltinIteratorTypes,
        resolveIterationType: (type, _errorNode) => type,
        mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,
        mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
        mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
    };

    interface DuplicateInfoForSymbol {
        readonly firstFileLocations: Declaration[];
        readonly secondFileLocations: Declaration[];
        readonly isBlockScoped: boolean;
    }
    interface DuplicateInfoForFiles {
        readonly firstFile: SourceFile;
        readonly secondFile: SourceFile;
        /** Key is symbol name. */
        readonly conflictingSymbols: Map<string, DuplicateInfoForSymbol>;
    }
    /** Key is "/path/to/a.ts|/path/to/b.ts". */
    var amalgamatedDuplicates: Map<string, DuplicateInfoForFiles> | undefined;
    var reverseMappedCache = new Map<string, Type | undefined>();
    var reverseHomomorphicMappedCache = new Map<string, Type | undefined>();
    var ambientModulesCache: Symbol[] | undefined;
    /**
     * List of every ambient module with a "*" wildcard.
     * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.
     * This is only used if there is no exact match.
     */
    var patternAmbientModules: PatternAmbientModule[];
    var patternAmbientModuleAugmentations: Map<string, Symbol> | undefined;

    var globalObjectType: ObjectType;
    var globalFunctionType: ObjectType;
    var globalCallableFunctionType: ObjectType;
    var globalNewableFunctionType: ObjectType;
    var globalArrayType: GenericType;
    var globalReadonlyArrayType: GenericType;
    var globalStringType: ObjectType;
    var globalNumberType: ObjectType;
    var globalBooleanType: ObjectType;
    var globalRegExpType: ObjectType;
    var globalThisType: GenericType;
    var anyArrayType: Type;
    var autoArrayType: Type;
    var anyReadonlyArrayType: Type;
    var deferredGlobalNonNullableTypeAlias: Symbol;

    // The library files are only loaded when the feature is used.
    // This allows users to just specify library files they want to used through --lib
    // and they will not get an error from not having unrelated library files
    var deferredGlobalESSymbolConstructorSymbol: Symbol | undefined;
    var deferredGlobalESSymbolConstructorTypeSymbol: Symbol | undefined;
    var deferredGlobalESSymbolType: ObjectType | undefined;
    var deferredGlobalTypedPropertyDescriptorType: GenericType;
    var deferredGlobalPromiseType: GenericType | undefined;
    var deferredGlobalPromiseLikeType: GenericType | undefined;
    var deferredGlobalPromiseConstructorSymbol: Symbol | undefined;
    var deferredGlobalPromiseConstructorLikeType: ObjectType | undefined;
    var deferredGlobalIterableType: GenericType | undefined;
    var deferredGlobalIteratorType: GenericType | undefined;
    var deferredGlobalIterableIteratorType: GenericType | undefined;
    var deferredGlobalIteratorObjectType: GenericType | undefined;
    var deferredGlobalGeneratorType: GenericType | undefined;
    var deferredGlobalIteratorYieldResultType: GenericType | undefined;
    var deferredGlobalIteratorReturnResultType: GenericType | undefined;
    var deferredGlobalAsyncIterableType: GenericType | undefined;
    var deferredGlobalAsyncIteratorType: GenericType | undefined;
    var deferredGlobalAsyncIterableIteratorType: GenericType | undefined;
    var deferredGlobalBuiltinIteratorTypes: readonly GenericType[] | undefined;
    var deferredGlobalBuiltinAsyncIteratorTypes: readonly GenericType[] | undefined;
    var deferredGlobalAsyncIteratorObjectType: GenericType | undefined;
    var deferredGlobalAsyncGeneratorType: GenericType | undefined;
    var deferredGlobalTemplateStringsArrayType: ObjectType | undefined;
    var deferredGlobalImportMetaType: ObjectType;
    var deferredGlobalImportMetaExpressionType: ObjectType;
    var deferredGlobalImportCallOptionsType: ObjectType | undefined;
    var deferredGlobalImportAttributesType: ObjectType | undefined;
    var deferredGlobalDisposableType: ObjectType | undefined;
    var deferredGlobalAsyncDisposableType: ObjectType | undefined;
    var deferredGlobalExtractSymbol: Symbol | undefined;
    var deferredGlobalOmitSymbol: Symbol | undefined;
    var deferredGlobalAwaitedSymbol: Symbol | undefined;
    var deferredGlobalBigIntType: ObjectType | undefined;
    var deferredGlobalNaNSymbol: Symbol | undefined;
    var deferredGlobalRecordSymbol: Symbol | undefined;
    var deferredGlobalClassDecoratorContextType: GenericType | undefined;
    var deferredGlobalClassMethodDecoratorContextType: GenericType | undefined;
    var deferredGlobalClassGetterDecoratorContextType: GenericType | undefined;
    var deferredGlobalClassSetterDecoratorContextType: GenericType | undefined;
    var deferredGlobalClassAccessorDecoratorContextType: GenericType | undefined;
    var deferredGlobalClassAccessorDecoratorTargetType: GenericType | undefined;
    var deferredGlobalClassAccessorDecoratorResultType: GenericType | undefined;
    var deferredGlobalClassFieldDecoratorContextType: GenericType | undefined;

    var allPotentiallyUnusedIdentifiers = new Map<Path, PotentiallyUnusedIdentifier[]>(); // key is file name

    var flowLoopStart = 0;
    var flowLoopCount = 0;
    var sharedFlowCount = 0;
    var flowAnalysisDisabled = false;
    var flowInvocationCount = 0;
    var lastFlowNode: FlowNode | undefined;
    var lastFlowNodeReachable: boolean;
    var flowTypeCache: Type[] | undefined;

    var contextualTypeNodes: Node[] = [];
    var contextualTypes: (Type | undefined)[] = [];
    var contextualIsCache: boolean[] = [];
    var contextualTypeCount = 0;
    var contextualBindingPatterns: BindingPattern[] = [];

    var inferenceContextNodes: Node[] = [];
    var inferenceContexts: (InferenceContext | undefined)[] = [];
    var inferenceContextCount = 0;

    var activeTypeMappers: TypeMapper[] = [];
    var activeTypeMappersCaches: Map<string, Type>[] = [];
    var activeTypeMappersCount = 0;

    var emptyStringType = getStringLiteralType("");
    var zeroType = getNumberLiteralType(0);
    var zeroBigIntType = getBigIntLiteralType({ negative: false, base10Value: "0" });

    var resolutionTargets: TypeSystemEntity[] = [];
    var resolutionResults: boolean[] = [];
    var resolutionPropertyNames: TypeSystemPropertyName[] = [];
    var resolutionStart = 0;
    var inVarianceComputation = false;

    var suggestionCount = 0;
    var maximumSuggestionCount = 10;
    var mergedSymbols: Symbol[] = [];
    var symbolLinks: SymbolLinks[] = [];
    var nodeLinks: NodeLinks[] = [];
    var flowLoopCaches: Map<string, Type>[] = [];
    var flowLoopNodes: FlowNode[] = [];
    var flowLoopKeys: string[] = [];
    var flowLoopTypes: Type[][] = [];
    var sharedFlowNodes: FlowNode[] = [];
    var sharedFlowTypes: FlowType[] = [];
    var flowNodeReachable: (boolean | undefined)[] = [];
    var flowNodePostSuper: (boolean | undefined)[] = [];
    var potentialThisCollisions: Node[] = [];
    var potentialNewTargetCollisions: Node[] = [];
    var potentialWeakMapSetCollisions: Node[] = [];
    var potentialReflectCollisions: Node[] = [];
    var potentialUnusedRenamedBindingElementsInTypes: BindingElement[] = [];
    var awaitedTypeStack: number[] = [];
    var reverseMappedSourceStack: Type[] = [];
    var reverseMappedTargetStack: Type[] = [];
    var reverseExpandingFlags = ExpandingFlags.None;

    var diagnostics = createDiagnosticCollection();
    var suggestionDiagnostics = createDiagnosticCollection();

    var typeofType = createTypeofType();

    var _jsxNamespace: __String;
    var _jsxFactoryEntity: EntityName | undefined;

    var subtypeRelation = new Map<string, RelationComparisonResult>();
    var strictSubtypeRelation = new Map<string, RelationComparisonResult>();
    var assignableRelation = new Map<string, RelationComparisonResult>();
    var comparableRelation = new Map<string, RelationComparisonResult>();
    var identityRelation = new Map<string, RelationComparisonResult>();
    var enumRelation = new Map<string, RelationComparisonResult>();

    // Extensions suggested for path imports when module resolution is node16 or higher.
    // The first element of each tuple is the extension a file has.
    // The second element of each tuple is the extension that should be used in a path import.
    // e.g. if we want to import file `foo.mts`, we should write `import {} from "./foo.mjs".
    var suggestedExtensions: [string, string][] = [
        [".mts", ".mjs"],
        [".ts", ".js"],
        [".cts", ".cjs"],
        [".mjs", ".mjs"],
        [".js", ".js"],
        [".cjs", ".cjs"],
        [".tsx", compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js"],
        [".jsx", ".jsx"],
        [".json", ".json"],
    ];

    /* eslint-enable no-var */

    initializeTypeChecker();

    return checker;

    function isDefinitelyReferenceToGlobalSymbolObject(node: Node): boolean {
        if (!isPropertyAccessExpression(node)) return false;
        if (!isIdentifier(node.name)) return false;
        if (!isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression)) return false;
        if (isIdentifier(node.expression)) {
            // Exactly `Symbol.something` and `Symbol` either does not resolve or definitely resolves to the global Symbol
            return idText(node.expression) === "Symbol" && getResolvedSymbol(node.expression) === (getGlobalSymbol("Symbol" as __String, SymbolFlags.Value | SymbolFlags.ExportValue, /*diagnostic*/ undefined) || unknownSymbol);
        }
        if (!isIdentifier(node.expression.expression)) return false;
        // Exactly `globalThis.Symbol.something` and `globalThis` resolves to the global `globalThis`
        return idText(node.expression.name) === "Symbol" && idText(node.expression.expression) === "globalThis" && getResolvedSymbol(node.expression.expression) === globalThisSymbol;
    }

    function getCachedType(key: string | undefined) {
        return key ? cachedTypes.get(key) : undefined;
    }

    function setCachedType(key: string | undefined, type: Type) {
        if (key) cachedTypes.set(key, type);
        return type;
    }

    function getJsxNamespace(location: Node | undefined): __String {
        if (location) {
            const file = getSourceFileOfNode(location);
            if (file) {
                if (isJsxOpeningFragment(location)) {
                    if (file.localJsxFragmentNamespace) {
                        return file.localJsxFragmentNamespace;
                    }
                    const jsxFragmentPragma = file.pragmas.get("jsxfrag");
                    if (jsxFragmentPragma) {
                        const chosenPragma = isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma;
                        file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
                        visitNode(file.localJsxFragmentFactory, markAsSynthetic, isEntityName);
                        if (file.localJsxFragmentFactory) {
                            return file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText;
                        }
                    }
                    const entity = getJsxFragmentFactoryEntity(location);
                    if (entity) {
                        file.localJsxFragmentFactory = entity;
                        return file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText;
                    }
                }
                else {
                    const localJsxNamespace = getLocalJsxNamespace(file);
                    if (localJsxNamespace) {
                        return file.localJsxNamespace = localJsxNamespace;
                    }
                }
            }
        }
        if (!_jsxNamespace) {
            _jsxNamespace = "React" as __String;
            if (compilerOptions.jsxFactory) {
                _jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion);
                visitNode(_jsxFactoryEntity, markAsSynthetic);
                if (_jsxFactoryEntity) {
                    _jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText;
                }
            }
            else if (compilerOptions.reactNamespace) {
                _jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace);
            }
        }
        if (!_jsxFactoryEntity) {
            _jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement");
        }
        return _jsxNamespace;
    }

    function getLocalJsxNamespace(file: SourceFile): __String | undefined {
        if (file.localJsxNamespace) {
            return file.localJsxNamespace;
        }
        const jsxPragma = file.pragmas.get("jsx");
        if (jsxPragma) {
            const chosenPragma = isArray(jsxPragma) ? jsxPragma[0] : jsxPragma;
            file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
            visitNode(file.localJsxFactory, markAsSynthetic, isEntityName);
            if (file.localJsxFactory) {
                return file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText;
            }
        }
    }

    function markAsSynthetic<T extends Node>(node: T): VisitResult<T> {
        setTextRangePosEnd(node, -1, -1);
        return visitEachChildWorker(node, markAsSynthetic, /*context*/ undefined);
    }

    function getEmitResolver(sourceFile: SourceFile, cancellationToken: CancellationToken, skipDiagnostics?: boolean) {
        // Ensure we have all the type information in place for this file so that all the
        // emitter questions of this resolver will return the right information.
        if (!skipDiagnostics) getDiagnostics(sourceFile, cancellationToken);
        return emitResolver;
    }

    function lookupOrIssueError(location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic {
        const diagnostic = location
            ? createDiagnosticForNode(location, message, ...args)
            : createCompilerDiagnostic(message, ...args);
        const existing = diagnostics.lookup(diagnostic);
        if (existing) {
            return existing;
        }
        else {
            diagnostics.add(diagnostic);
            return diagnostic;
        }
    }

    function errorSkippedOn(key: keyof CompilerOptions, location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic {
        const diagnostic = error(location, message, ...args);
        diagnostic.skippedOn = key;
        return diagnostic;
    }

    function createError(location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic {
        return location
            ? createDiagnosticForNode(location, message, ...args)
            : createCompilerDiagnostic(message, ...args);
    }

    function error(location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic {
        const diagnostic = createError(location, message, ...args);
        diagnostics.add(diagnostic);
        return diagnostic;
    }

    function addErrorOrSuggestion(isError: boolean, diagnostic: Diagnostic) {
        if (isError) {
            diagnostics.add(diagnostic);
        }
        else {
            suggestionDiagnostics.add({ ...diagnostic, category: DiagnosticCategory.Suggestion });
        }
    }
    function errorOrSuggestion(isError: boolean, location: Node, message: DiagnosticMessage | DiagnosticMessageChain, ...args: DiagnosticArguments): void {
        // Pseudo-synthesized input node
        if (location.pos < 0 || location.end < 0) {
            if (!isError) {
                return; // Drop suggestions (we have no span to suggest on)
            }
            // Issue errors globally
            const file = getSourceFileOfNode(location);
            addErrorOrSuggestion(isError, "message" in message ? createFileDiagnostic(file, 0, 0, message, ...args) : createDiagnosticForFileFromMessageChain(file, message)); // eslint-disable-line local/no-in-operator
            return;
        }
        addErrorOrSuggestion(isError, "message" in message ? createDiagnosticForNode(location, message, ...args) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message)); // eslint-disable-line local/no-in-operator
    }

    function errorAndMaybeSuggestAwait(
        location: Node,
        maybeMissingAwait: boolean,
        message: DiagnosticMessage,
        ...args: DiagnosticArguments
    ): Diagnostic {
        const diagnostic = error(location, message, ...args);
        if (maybeMissingAwait) {
            const related = createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await);
            addRelatedInfo(diagnostic, related);
        }
        return diagnostic;
    }

    function addDeprecatedSuggestionWorker(declarations: Node | Node[], diagnostic: DiagnosticWithLocation) {
        const deprecatedTag = Array.isArray(declarations) ? forEach(declarations, getJSDocDeprecatedTag) : getJSDocDeprecatedTag(declarations);
        if (deprecatedTag) {
            addRelatedInfo(
                diagnostic,
                createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here),
            );
        }
        // We call `addRelatedInfo()` before adding the diagnostic to prevent duplicates.
        suggestionDiagnostics.add(diagnostic);
        return diagnostic;
    }

    function isDeprecatedSymbol(symbol: Symbol) {
        const parentSymbol = getParentOfSymbol(symbol);
        if (parentSymbol && length(symbol.declarations) > 1) {
            return parentSymbol.flags & SymbolFlags.Interface ? some(symbol.declarations, isDeprecatedDeclaration) : every(symbol.declarations, isDeprecatedDeclaration);
        }
        return !!symbol.valueDeclaration && isDeprecatedDeclaration(symbol.valueDeclaration)
            || length(symbol.declarations) && every(symbol.declarations, isDeprecatedDeclaration);
    }

    function isDeprecatedDeclaration(declaration: Declaration) {
        return !!(getCombinedNodeFlagsCached(declaration) & NodeFlags.Deprecated);
    }

    function addDeprecatedSuggestion(location: Node, declarations: Node[], deprecatedEntity: string) {
        const diagnostic = createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity);
        return addDeprecatedSuggestionWorker(declarations, diagnostic);
    }

    function addDeprecatedSuggestionWithSignature(location: Node, declaration: Node, deprecatedEntity: string | undefined, signatureString: string) {
        const diagnostic = deprecatedEntity
            ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)
            : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString);
        return addDeprecatedSuggestionWorker(declaration, diagnostic);
    }

    function createSymbol(flags: SymbolFlags, name: __String, checkFlags?: CheckFlags) {
        symbolCount++;
        const symbol = new Symbol(flags | SymbolFlags.Transient, name) as TransientSymbol;
        symbol.links = new SymbolLinks() as TransientSymbolLinks;
        symbol.links.checkFlags = checkFlags || CheckFlags.None;
        return symbol;
    }

    function createParameter(name: __String, type: Type) {
        const symbol = createSymbol(SymbolFlags.FunctionScopedVariable, name);
        symbol.links.type = type;
        return symbol;
    }

    function createProperty(name: __String, type: Type) {
        const symbol = createSymbol(SymbolFlags.Property, name);
        symbol.links.type = type;
        return symbol;
    }

    function getExcludedSymbolFlags(flags: SymbolFlags): SymbolFlags {
        let result: SymbolFlags = 0;
        if (flags & SymbolFlags.BlockScopedVariable) result |= SymbolFlags.BlockScopedVariableExcludes;
        if (flags & SymbolFlags.FunctionScopedVariable) result |= SymbolFlags.FunctionScopedVariableExcludes;
        if (flags & SymbolFlags.Property) result |= SymbolFlags.PropertyExcludes;
        if (flags & SymbolFlags.EnumMember) result |= SymbolFlags.EnumMemberExcludes;
        if (flags & SymbolFlags.Function) result |= SymbolFlags.FunctionExcludes;
        if (flags & SymbolFlags.Class) result |= SymbolFlags.ClassExcludes;
        if (flags & SymbolFlags.Interface) result |= SymbolFlags.InterfaceExcludes;
        if (flags & SymbolFlags.RegularEnum) result |= SymbolFlags.RegularEnumExcludes;
        if (flags & SymbolFlags.ConstEnum) result |= SymbolFlags.ConstEnumExcludes;
        if (flags & SymbolFlags.ValueModule) result |= SymbolFlags.ValueModuleExcludes;
        if (flags & SymbolFlags.Method) result |= SymbolFlags.MethodExcludes;
        if (flags & SymbolFlags.GetAccessor) result |= SymbolFlags.GetAccessorExcludes;
        if (flags & SymbolFlags.SetAccessor) result |= SymbolFlags.SetAccessorExcludes;
        if (flags & SymbolFlags.TypeParameter) result |= SymbolFlags.TypeParameterExcludes;
        if (flags & SymbolFlags.TypeAlias) result |= SymbolFlags.TypeAliasExcludes;
        if (flags & SymbolFlags.Alias) result |= SymbolFlags.AliasExcludes;
        return result;
    }

    function recordMergedSymbol(target: Symbol, source: Symbol) {
        if (!source.mergeId) {
            source.mergeId = nextMergeId;
            nextMergeId++;
        }
        mergedSymbols[source.mergeId] = target;
    }

    function cloneSymbol(symbol: Symbol): TransientSymbol {
        const result = createSymbol(symbol.flags, symbol.escapedName);
        result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
        result.parent = symbol.parent;
        if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
        if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
        if (symbol.members) result.members = new Map(symbol.members);
        if (symbol.exports) result.exports = new Map(symbol.exports);
        recordMergedSymbol(result, symbol);
        return result;
    }

    /**
     * Note: if target is transient, then it is mutable, and mergeSymbol with both mutate and return it.
     * If target is not transient, mergeSymbol will produce a transient clone, mutate that and return it.
     */
    function mergeSymbol(target: Symbol, source: Symbol, unidirectional = false): Symbol {
        if (
            !(target.flags & getExcludedSymbolFlags(source.flags)) ||
            (source.flags | target.flags) & SymbolFlags.Assignment
        ) {
            if (source === target) {
                // This can happen when an export assigned namespace exports something also erroneously exported at the top level
                // See `declarationFileNoCrashOnExtraExportModifier` for an example
                return target;
            }
            if (!(target.flags & SymbolFlags.Transient)) {
                const resolvedTarget = resolveSymbol(target);
                if (resolvedTarget === unknownSymbol) {
                    return source;
                }
                if (
                    !(resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) ||
                    (source.flags | resolvedTarget.flags) & SymbolFlags.Assignment
                ) {
                    target = cloneSymbol(resolvedTarget);
                }
                else {
                    reportMergeSymbolError(target, source);
                    return source;
                }
            }
            // Javascript static-property-assignment declarations always merge, even though they are also values
            if (source.flags & SymbolFlags.ValueModule && target.flags & SymbolFlags.ValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule) {
                // reset flag when merging instantiated module into value module that has only const enums
                target.constEnumOnlyModule = false;
            }
            target.flags |= source.flags;
            if (source.valueDeclaration) {
                setValueDeclaration(target, source.valueDeclaration);
            }
            addRange(target.declarations, source.declarations);
            if (source.members) {
                if (!target.members) target.members = createSymbolTable();
                mergeSymbolTable(target.members, source.members, unidirectional);
            }
            if (source.exports) {
                if (!target.exports) target.exports = createSymbolTable();
                mergeSymbolTable(target.exports, source.exports, unidirectional, target);
            }
            if (!unidirectional) {
                recordMergedSymbol(target, source);
            }
        }
        else if (target.flags & SymbolFlags.NamespaceModule) {
            // Do not report an error when merging `var globalThis` with the built-in `globalThis`,
            // as we will already report a "Declaration name conflicts..." error, and this error
            // won't make much sense.
            if (target !== globalThisSymbol) {
                error(
                    source.declarations && getNameOfDeclaration(source.declarations[0]),
                    Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity,
                    symbolToString(target),
                );
            }
        }
        else {
            reportMergeSymbolError(target, source);
        }
        return target;

        function reportMergeSymbolError(target: Symbol, source: Symbol) {
            const isEitherEnum = !!(target.flags & SymbolFlags.Enum || source.flags & SymbolFlags.Enum);
            const isEitherBlockScoped = !!(target.flags & SymbolFlags.BlockScopedVariable || source.flags & SymbolFlags.BlockScopedVariable);
            const message = isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
                : isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0
                : Diagnostics.Duplicate_identifier_0;
            const sourceSymbolFile = source.declarations && getSourceFileOfNode(source.declarations[0]);
            const targetSymbolFile = target.declarations && getSourceFileOfNode(target.declarations[0]);

            const isSourcePlainJs = isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs);
            const isTargetPlainJs = isPlainJsFile(targetSymbolFile, compilerOptions.checkJs);
            const symbolName = symbolToString(source);

            // Collect top-level duplicate identifier errors into one mapping, so we can then merge their diagnostics if there are a bunch
            if (sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile) {
                const firstFile = comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile;
                const secondFile = firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
                const filesDuplicates = getOrUpdate(amalgamatedDuplicates, `${firstFile.path}|${secondFile.path}`, (): DuplicateInfoForFiles => ({ firstFile, secondFile, conflictingSymbols: new Map() }));
                const conflictingSymbolInfo = getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, (): DuplicateInfoForSymbol => ({ isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] }));
                if (!isSourcePlainJs) addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source);
                if (!isTargetPlainJs) addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target);
            }
            else {
                if (!isSourcePlainJs) addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target);
                if (!isTargetPlainJs) addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source);
            }
        }

        function addDuplicateLocations(locs: Declaration[], symbol: Symbol): void {
            if (symbol.declarations) {
                for (const decl of symbol.declarations) {
                    pushIfUnique(locs, decl);
                }
            }
        }
    }

    function addDuplicateDeclarationErrorsForSymbols(target: Symbol, message: DiagnosticMessage, symbolName: string, source: Symbol) {
        forEach(target.declarations, node => {
            addDuplicateDeclarationError(node, message, symbolName, source.declarations);
        });
    }

    function addDuplicateDeclarationError(node: Declaration, message: DiagnosticMessage, symbolName: string, relatedNodes: readonly Declaration[] | undefined) {
        const errorNode = (getExpandoInitializer(node, /*isPrototypeAssignment*/ false) ? getNameOfExpando(node) : getNameOfDeclaration(node)) || node;
        const err = lookupOrIssueError(errorNode, message, symbolName);
        for (const relatedNode of relatedNodes || emptyArray) {
            const adjustedNode = (getExpandoInitializer(relatedNode, /*isPrototypeAssignment*/ false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode)) || relatedNode;
            if (adjustedNode === errorNode) continue;
            err.relatedInformation = err.relatedInformation || [];
            const leadingMessage = createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName);
            const followOnMessage = createDiagnosticForNode(adjustedNode, Diagnostics.and_here);
            if (length(err.relatedInformation) >= 5 || some(err.relatedInformation, r => compareDiagnostics(r, followOnMessage) === Comparison.EqualTo || compareDiagnostics(r, leadingMessage) === Comparison.EqualTo)) continue;
            addRelatedInfo(err, !length(err.relatedInformation) ? leadingMessage : followOnMessage);
        }
    }

    function combineSymbolTables(first: SymbolTable | undefined, second: SymbolTable | undefined): SymbolTable | undefined {
        if (!first?.size) return second;
        if (!second?.size) return first;
        const combined = createSymbolTable();
        mergeSymbolTable(combined, first);
        mergeSymbolTable(combined, second);
        return combined;
    }

    function mergeSymbolTable(target: SymbolTable, source: SymbolTable, unidirectional = false, mergedParent?: Symbol) {
        source.forEach((sourceSymbol, id) => {
            const targetSymbol = target.get(id);
            const merged = targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol);
            if (mergedParent && targetSymbol) {
                // If a merge was performed on the target symbol, set its parent to the merged parent that initiated the merge
                // of its exports. Otherwise, `merged` came only from `sourceSymbol` and can keep its parent:
                //
                // // a.ts
                // export interface A { x: number; }
                //
                // // b.ts
                // declare module "./a" {
                //   interface A { y: number; }
                //   interface B {}
                // }
                //
                // When merging the module augmentation into a.ts, the symbol for `A` will itself be merged, so its parent
                // should be the merged module symbol. But the symbol for `B` has only one declaration, so its parent should
                // be the module augmentation symbol, which contains its only declaration.
                merged.parent = mergedParent;
            }
            target.set(id, merged);
        });
    }

    function mergeModuleAugmentation(moduleName: StringLiteral | Identifier): void {
        const moduleAugmentation = moduleName.parent as ModuleDeclaration;
        if (moduleAugmentation.symbol.declarations?.[0] !== moduleAugmentation) {
            // this is a combined symbol for multiple augmentations within the same file.
            // its symbol already has accumulated information for all declarations
            // so we need to add it just once - do the work only for first declaration
            Debug.assert(moduleAugmentation.symbol.declarations!.length > 1);
            return;
        }

        if (isGlobalScopeAugmentation(moduleAugmentation)) {
            mergeSymbolTable(globals, moduleAugmentation.symbol.exports!);
        }
        else {
            // find a module that about to be augmented
            // do not validate names of augmentations that are defined in ambient context
            const moduleNotFoundError = !(moduleName.parent.parent.flags & NodeFlags.Ambient)
                ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found
                : undefined;
            let mainModule = resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, /*ignoreErrors*/ false, /*isForAugmentation*/ true);
            if (!mainModule) {
                return;
            }
            // obtain item referenced by 'export='
            mainModule = resolveExternalModuleSymbol(mainModule);
            if (mainModule.flags & SymbolFlags.Namespace) {
                // If we're merging an augmentation to a pattern ambient module, we want to
                // perform the merge unidirectionally from the augmentation ('a.foo') to
                // the pattern ('*.foo'), so that 'getMergedSymbol()' on a.foo gives you
                // all the exports both from the pattern and from the augmentation, but
                // 'getMergedSymbol()' on *.foo only gives you exports from *.foo.
                if (some(patternAmbientModules, module => mainModule === module.symbol)) {
                    const merged = mergeSymbol(moduleAugmentation.symbol, mainModule, /*unidirectional*/ true);
                    if (!patternAmbientModuleAugmentations) {
                        patternAmbientModuleAugmentations = new Map();
                    }
                    // moduleName will be a StringLiteral since this is not `declare global`.
                    patternAmbientModuleAugmentations.set((moduleName as StringLiteral).text, merged);
                }
                else {
                    if (mainModule.exports?.get(InternalSymbolName.ExportStar) && moduleAugmentation.symbol.exports?.size) {
                        // We may need to merge the module augmentation's exports into the target symbols of the resolved exports
                        const resolvedExports = getResolvedMembersOrExportsOfSymbol(mainModule, MembersOrExportsResolutionKind.resolvedExports);
                        for (const [key, value] of arrayFrom(moduleAugmentation.symbol.exports.entries())) {
                            if (resolvedExports.has(key) && !mainModule.exports.has(key)) {
                                mergeSymbol(resolvedExports.get(key)!, value);
                            }
                        }
                    }
                    mergeSymbol(mainModule, moduleAugmentation.symbol);
                }
            }
            else {
                // moduleName will be a StringLiteral since this is not `declare global`.
                error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName as StringLiteral).text);
            }
        }
    }

    function addUndefinedToGlobalsOrErrorOnRedeclaration() {
        const name = undefinedSymbol.escapedName;
        const targetSymbol = globals.get(name);
        if (targetSymbol) {
            forEach(targetSymbol.declarations, declaration => {
                // checkTypeNameIsReserved will have added better diagnostics for type declarations.
                if (!isTypeDeclaration(declaration)) {
                    diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)));
                }
            });
        }
        else {
            globals.set(name, undefinedSymbol);
        }
    }

    function getSymbolLinks(symbol: Symbol): SymbolLinks {
        if (symbol.flags & SymbolFlags.Transient) return (symbol as TransientSymbol).links;
        const id = getSymbolId(symbol);
        return symbolLinks[id] ??= new SymbolLinks();
    }

    function getNodeLinks(node: Node): NodeLinks {
        const nodeId = getNodeId(node);
        return nodeLinks[nodeId] || (nodeLinks[nodeId] = new (NodeLinks as any)());
    }

    function getSymbol(symbols: SymbolTable, name: __String, meaning: SymbolFlags): Symbol | undefined {
        if (meaning) {
            const symbol = getMergedSymbol(symbols.get(name));
            if (symbol) {
                if (symbol.flags & meaning) {
                    return symbol;
                }
                if (symbol.flags & SymbolFlags.Alias) {
                    const targetFlags = getSymbolFlags(symbol);
                    // `targetFlags` will be `SymbolFlags.All` if an error occurred in alias resolution; this avoids cascading errors
                    if (targetFlags & meaning) {
                        return symbol;
                    }
                }
            }
        }
        // return undefined if we can't find a symbol.
    }

    /**
     * Get symbols that represent parameter-property-declaration as parameter and as property declaration
     * @param parameter a parameterDeclaration node
     * @param parameterName a name of the parameter to get the symbols for.
     * @return a tuple of two symbols
     */
    function getSymbolsOfParameterPropertyDeclaration(parameter: ParameterPropertyDeclaration, parameterName: __String): [Symbol, Symbol] {
        const constructorDeclaration = parameter.parent;
        const classDeclaration = parameter.parent.parent;

        const parameterSymbol = getSymbol(constructorDeclaration.locals!, parameterName, SymbolFlags.Value);
        const propertySymbol = getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, SymbolFlags.Value);

        if (parameterSymbol && propertySymbol) {
            return [parameterSymbol, propertySymbol];
        }

        return Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration");
    }

    function isBlockScopedNameDeclaredBeforeUse(declaration: Declaration, usage: Node): boolean {
        const declarationFile = getSourceFileOfNode(declaration);
        const useFile = getSourceFileOfNode(usage);
        const declContainer = getEnclosingBlockScopeContainer(declaration);
        if (declarationFile !== useFile) {
            if (
                (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||
                (!compilerOptions.outFile) ||
                isInTypeQuery(usage) ||
                declaration.flags & NodeFlags.Ambient
            ) {
                // nodes are in different files and order cannot be determined
                return true;
            }
            // declaration is after usage
            // can be legal if usage is deferred (i.e. inside function or in initializer of instance property)
            if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                return true;
            }
            const sourceFiles = host.getSourceFiles();
            return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile);
        }

        // deferred usage in a type context is always OK regardless of the usage position:
        if (!!(usage.flags & NodeFlags.JSDoc) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage)) {
            return true;
        }

        if (declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken)) {
            // declaration is before usage
            if (declaration.kind === SyntaxKind.BindingElement) {
                // still might be illegal if declaration and usage are both binding elements (eg var [a = b, b = b] = [1, 2])
                const errorBindingElement = getAncestor(usage, SyntaxKind.BindingElement) as BindingElement;
                if (errorBindingElement) {
                    return findAncestor(errorBindingElement, isBindingElement) !== findAncestor(declaration, isBindingElement) ||
                        declaration.pos < errorBindingElement.pos;
                }
                // or it might be illegal if usage happens before parent variable is declared (eg var [a] = a)
                return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, SyntaxKind.VariableDeclaration) as Declaration, usage);
            }
            else if (declaration.kind === SyntaxKind.VariableDeclaration) {
                // still might be illegal if usage is in the initializer of the variable declaration (eg var a = a)
                return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration as VariableDeclaration, usage);
            }
            else if (isClassLike(declaration)) {
                // still might be illegal if the usage is within a computed property name in the class (eg class A { static p = "a"; [A.p]() {} })
                // or when used within a decorator in the class (e.g. `@dec(A.x) class A { static x = "x" }`),
                // except when used in a function that is not an IIFE (e.g., `@dec(() => A.x) class A { ... }`)
                const container = findAncestor(usage, n =>
                    n === declaration ? "quit" :
                        isComputedPropertyName(n) ? n.parent.parent === declaration :
                        !legacyDecorators && isDecorator(n) && (n.parent === declaration ||
                            isMethodDeclaration(n.parent) && n.parent.parent === declaration ||
                            isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent === declaration ||
                            isPropertyDeclaration(n.parent) && n.parent.parent === declaration ||
                            isParameter(n.parent) && n.parent.parent.parent === declaration));
                if (!container) {
                    return true;
                }
                if (!legacyDecorators && isDecorator(container)) {
                    return !!findAncestor(usage, n => n === container ? "quit" : isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n));
                }
                return false;
            }
            else if (isPropertyDeclaration(declaration)) {
                // still might be illegal if a self-referencing property initializer (eg private x = this.x)
                return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, /*stopAtAnyPropertyDeclaration*/ false);
            }
            else if (isParameterPropertyDeclaration(declaration, declaration.parent)) {
                // foo = this.bar is illegal in emitStandardClassFields when bar is a parameter property
                return !(emitStandardClassFields
                    && getContainingClass(declaration) === getContainingClass(usage)
                    && isUsedInFunctionOrInstanceProperty(usage, declaration));
            }
            return true;
        }

        // declaration is after usage, but it can still be legal if usage is deferred:
        // 1. inside an export specifier
        // 2. inside a function
        // 3. inside an instance property initializer, a reference to a non-instance property
        //    (except when emitStandardClassFields: true and the reference is to a parameter property)
        // 4. inside a static property initializer, a reference to a static method in the same class
        // 5. inside a TS export= declaration (since we will move the export statement during emit to avoid TDZ)
        if (usage.parent.kind === SyntaxKind.ExportSpecifier || (usage.parent.kind === SyntaxKind.ExportAssignment && (usage.parent as ExportAssignment).isExportEquals)) {
            // export specifiers do not use the variable, they only make it available for use
            return true;
        }
        // When resolving symbols for exports, the `usage` location passed in can be the export site directly
        if (usage.kind === SyntaxKind.ExportAssignment && (usage as ExportAssignment).isExportEquals) {
            return true;
        }

        if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
            if (
                emitStandardClassFields
                && getContainingClass(declaration)
                && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent))
            ) {
                return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, /*stopAtAnyPropertyDeclaration*/ true);
            }
            else {
                return true;
            }
        }
        return false;

        function isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration: VariableDeclaration, usage: Node): boolean {
            switch (declaration.parent.parent.kind) {
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForOfStatement:
                    // variable statement/for/for-of statement case,
                    // use site should not be inside variable declaration (initializer of declaration or binding element)
                    if (isSameScopeDescendentOf(usage, declaration, declContainer)) {
                        return true;
                    }
                    break;
            }

            // ForIn/ForOf case - use site should not be used in expression part
            const grandparent = declaration.parent.parent;
            return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer);
        }

        function isUsedInFunctionOrInstanceProperty(usage: Node, declaration: Node) {
            return isUsedInFunctionOrInstancePropertyWorker(usage, declaration);
        }

        function isUsedInFunctionOrInstancePropertyWorker(usage: Node, declaration: Node): boolean {
            return !!findAncestor(usage, current => {
                if (current === declContainer) {
                    return "quit";
                }
                if (isFunctionLike(current)) {
                    return !getImmediatelyInvokedFunctionExpression(current);
                }
                if (isClassStaticBlockDeclaration(current)) {
                    return declaration.pos < usage.pos;
                }

                const propertyDeclaration = tryCast(current.parent, isPropertyDeclaration);
                if (propertyDeclaration) {
                    const initializerOfProperty = propertyDeclaration.initializer === current;
                    if (initializerOfProperty) {
                        if (isStatic(current.parent)) {
                            if (declaration.kind === SyntaxKind.MethodDeclaration) {
                                return true;
                            }
                            if (isPropertyDeclaration(declaration) && getContainingClass(usage) === getContainingClass(declaration)) {
                                const propName = declaration.name;
                                if (isIdentifier(propName) || isPrivateIdentifier(propName)) {
                                    const type = getTypeOfSymbol(getSymbolOfDeclaration(declaration));
                                    const staticBlocks = filter(declaration.parent.members, isClassStaticBlockDeclaration);
                                    if (isPropertyInitializedInStaticBlocks(propName, type, staticBlocks, declaration.parent.pos, current.pos)) {
                                        return true;
                                    }
                                }
                            }
                        }
                        else {
                            const isDeclarationInstanceProperty = declaration.kind === SyntaxKind.PropertyDeclaration && !isStatic(declaration);
                            if (!isDeclarationInstanceProperty || getContainingClass(usage) !== getContainingClass(declaration)) {
                                return true;
                            }
                        }
                    }
                }

                const decorator = tryCast(current.parent, isDecorator);
                if (decorator && decorator.expression === current) {
                    if (isParameter(decorator.parent)) {
                        return isUsedInFunctionOrInstancePropertyWorker(decorator.parent.parent.parent, declaration) ? true : "quit";
                    }
                    if (isMethodDeclaration(decorator.parent)) {
                        return isUsedInFunctionOrInstancePropertyWorker(decorator.parent.parent, declaration) ? true : "quit";
                    }
                }

                return false;
            });
        }

        /** stopAtAnyPropertyDeclaration is used for detecting ES-standard class field use-before-def errors */
        function isPropertyImmediatelyReferencedWithinDeclaration(declaration: PropertyDeclaration | ParameterPropertyDeclaration, usage: Node, stopAtAnyPropertyDeclaration: boolean) {
            // always legal if usage is after declaration
            if (usage.end > declaration.end) {
                return false;
            }

            // still might be legal if usage is deferred (e.g. x: any = () => this.x)
            // otherwise illegal if immediately referenced within the declaration (e.g. x: any = this.x)
            const ancestorChangingReferenceScope = findAncestor(usage, (node: Node) => {
                if (node === declaration) {
                    return "quit";
                }

                switch (node.kind) {
                    case SyntaxKind.ArrowFunction:
                        return true;
                    case SyntaxKind.PropertyDeclaration:
                        // even when stopping at any property declaration, they need to come from the same class
                        return stopAtAnyPropertyDeclaration &&
                                (isPropertyDeclaration(declaration) && node.parent === declaration.parent
                                    || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)
                            ? "quit" : true;
                    case SyntaxKind.Block:
                        switch (node.parent.kind) {
                            case SyntaxKind.GetAccessor:
                            case SyntaxKind.MethodDeclaration:
                            case SyntaxKind.SetAccessor:
                                return true;
                            default:
                                return false;
                        }
                    default:
                        return false;
                }
            });

            return ancestorChangingReferenceScope === undefined;
        }
    }

    function getRequiresScopeChangeCache(node: FunctionLikeDeclaration) {
        return getNodeLinks(node).declarationRequiresScopeChange;
    }
    function setRequiresScopeChangeCache(node: FunctionLikeDeclaration, value: boolean) {
        getNodeLinks(node).declarationRequiresScopeChange = value;
    }
    // The invalid initializer error is needed in two situation:
    // 1. When result is undefined, after checking for a missing "this."
    // 2. When result is defined
    function checkAndReportErrorForInvalidInitializer(errorLocation: Node | undefined, name: __String, propertyWithInvalidInitializer: PropertyDeclaration, result: Symbol | undefined) {
        if (!emitStandardClassFields) {
            if (errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name)) {
                return true;
            }
            // We have a match, but the reference occurred within a property initializer and the identifier also binds
            // to a local variable in the constructor where the code will be emitted. Note that this is actually allowed
            // with emitStandardClassFields because the scope semantics are different.
            error(
                errorLocation,
                errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos)
                    ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor
                    : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor,
                declarationNameToString(propertyWithInvalidInitializer.name),
                diagnosticName(name),
            );
            return true;
        }
        return false;
    }
    function onFailedToResolveSymbol(
        errorLocation: Node | undefined,
        nameArg: __String | Identifier,
        meaning: SymbolFlags,
        nameNotFoundMessage: DiagnosticMessage,
    ) {
        const name = isString(nameArg) ? nameArg : (nameArg as Identifier).escapedText;
        addLazyDiagnostic(() => {
            if (
                !errorLocation ||
                errorLocation.parent.kind !== SyntaxKind.JSDocLink &&
                    !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) &&
                    !checkAndReportErrorForExtendingInterface(errorLocation) &&
                    !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&
                    !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) &&
                    !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) &&
                    !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&
                    !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)
            ) {
                let suggestion: Symbol | undefined;
                let suggestedLib: string | undefined;
                // Report missing lib first
                if (nameArg) {
                    suggestedLib = getSuggestedLibForNonExistentName(nameArg);
                    if (suggestedLib) {
                        error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib);
                    }
                }
                // then spelling suggestions
                if (!suggestedLib && suggestionCount < maximumSuggestionCount) {
                    suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning);
                    const isGlobalScopeAugmentationDeclaration = suggestion?.valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration);
                    if (isGlobalScopeAugmentationDeclaration) {
                        suggestion = undefined;
                    }
                    if (suggestion) {
                        const suggestionName = symbolToString(suggestion);
                        const isUncheckedJS = isUncheckedJSSuggestion(errorLocation, suggestion, /*excludeClasses*/ false);
                        const message = meaning === SymbolFlags.Namespace ||
                                nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ?
                            Diagnostics.Cannot_find_namespace_0_Did_you_mean_1
                            : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1
                            : Diagnostics.Cannot_find_name_0_Did_you_mean_1;
                        const diagnostic = createError(errorLocation, message, diagnosticName(nameArg), suggestionName);
                        diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg));
                        addErrorOrSuggestion(!isUncheckedJS, diagnostic);
                        if (suggestion.valueDeclaration) {
                            addRelatedInfo(
                                diagnostic,
                                createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName),
                            );
                        }
                    }
                }
                // And then fall back to unspecified "not found"
                if (!suggestion && !suggestedLib && nameArg) {
                    error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));
                }
                suggestionCount++;
            }
        });
    }

    function onSuccessfullyResolvedSymbol(
        errorLocation: Node | undefined,
        result: Symbol,
        meaning: SymbolFlags,
        lastLocation: Node | undefined,
        associatedDeclarationForContainingInitializerOrBindingName: ParameterDeclaration | BindingElement | undefined,
        withinDeferredContext: boolean,
    ) {
        addLazyDiagnostic(() => {
            const name = result.escapedName;
            const isInExternalModule = lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation);
            // Only check for block-scoped variable if we have an error location and are looking for the
            // name with variable meaning
            //      For example,
            //          declare module foo {
            //              interface bar {}
            //          }
            //      const foo/*1*/: foo/*2*/.bar;
            // The foo at /*1*/ and /*2*/ will share same symbol with two meanings:
            // block-scoped variable and namespace module. However, only when we
            // try to resolve name in /*1*/ which is used in variable position,
            // we want to check for block-scoped
            if (
                errorLocation &&
                (meaning & SymbolFlags.BlockScopedVariable ||
                    ((meaning & SymbolFlags.Class || meaning & SymbolFlags.Enum) && (meaning & SymbolFlags.Value) === SymbolFlags.Value))
            ) {
                const exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
                if (exportOrLocalSymbol.flags & SymbolFlags.BlockScopedVariable || exportOrLocalSymbol.flags & SymbolFlags.Class || exportOrLocalSymbol.flags & SymbolFlags.Enum) {
                    checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
                }
            }

            // If we're in an external module, we can't reference value symbols created from UMD export declarations
            if (isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value && !(errorLocation!.flags & NodeFlags.JSDoc)) {
                const merged = getMergedSymbol(result);
                if (length(merged.declarations) && every(merged.declarations, d => isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports)) {
                    errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation!, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name));
                }
            }

            // If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right
            if (associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {
                const candidate = getMergedSymbol(getLateBoundSymbol(result));
                const root = getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) as ParameterDeclaration;
                // A parameter initializer or binding pattern initializer within a parameter cannot refer to itself
                if (candidate === getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName)) {
                    error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));
                }
                // And it cannot refer to any declarations which come after it
                else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.escapedName, meaning) === candidate) {
                    error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation as Identifier));
                }
            }
            if (errorLocation && meaning & SymbolFlags.Value && result.flags & SymbolFlags.Alias && !(result.flags & SymbolFlags.Value) && !isValidTypeOnlyAliasUseSite(errorLocation)) {
                const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(result, SymbolFlags.Value);
                if (typeOnlyDeclaration) {
                    const message = typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport
                        ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type
                        : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;
                    const unescapedName = unescapeLeadingUnderscores(name);
                    addTypeOnlyDeclarationRelatedInfo(
                        error(errorLocation, message, unescapedName),
                        typeOnlyDeclaration,
                        unescapedName,
                    );
                }
            }

            // Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
            // here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
            if (compilerOptions.isolatedModules && result && isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {
                const isGlobal = getSymbol(globals, name, meaning) === result;
                const nonValueSymbol = isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlags.Value);
                if (nonValueSymbol) {
                    const importDecl = nonValueSymbol.declarations?.find(d => d.kind === SyntaxKind.ImportSpecifier || d.kind === SyntaxKind.ImportClause || d.kind === SyntaxKind.NamespaceImport || d.kind === SyntaxKind.ImportEqualsDeclaration);
                    if (importDecl && !isTypeOnlyImportDeclaration(importDecl)) {
                        error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name));
                    }
                }
            }
        });
    }

    function addTypeOnlyDeclarationRelatedInfo(diagnostic: Diagnostic, typeOnlyDeclaration: TypeOnlyCompatibleAliasDeclaration | undefined, unescapedName: string) {
        if (!typeOnlyDeclaration) return diagnostic;
        return addRelatedInfo(
            diagnostic,
            createDiagnosticForNode(
                typeOnlyDeclaration,
                typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport
                    ? Diagnostics._0_was_exported_here
                    : Diagnostics._0_was_imported_here,
                unescapedName,
            ),
        );
    }

    function diagnosticName(nameArg: __String | Identifier | PrivateIdentifier) {
        return isString(nameArg) ? unescapeLeadingUnderscores(nameArg as __String) : declarationNameToString(nameArg as Identifier);
    }

    function checkAndReportErrorForMissingPrefix(errorLocation: Node, name: __String, nameArg: __String | Identifier): boolean {
        if (!isIdentifier(errorLocation) || errorLocation.escapedText !== name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation)) {
            return false;
        }

        const container = getThisContainer(errorLocation, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
        let location: Node = container;
        while (location) {
            if (isClassLike(location.parent)) {
                const classSymbol = getSymbolOfDeclaration(location.parent);
                if (!classSymbol) {
                    break;
                }

                // Check to see if a static member exists.
                const constructorType = getTypeOfSymbol(classSymbol);
                if (getPropertyOfType(constructorType, name)) {
                    error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));
                    return true;
                }

                // No static member is present.
                // Check if we're in an instance method and look for a relevant instance member.
                if (location === container && !isStatic(location)) {
                    const instanceType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType!; // TODO: GH#18217
                    if (getPropertyOfType(instanceType, name)) {
                        error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));
                        return true;
                    }
                }
            }

            location = location.parent;
        }
        return false;
    }

    function checkAndReportErrorForExtendingInterface(errorLocation: Node): boolean {
        const expression = getEntityNameForExtendingInterface(errorLocation);
        if (expression && resolveEntityName(expression, SymbolFlags.Interface, /*ignoreErrors*/ true)) {
            error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression));
            return true;
        }
        return false;
    }
    /**
     * Climbs up parents to an ExpressionWithTypeArguments, and returns its expression,
     * but returns undefined if that expression is not an EntityNameExpression.
     */
    function getEntityNameForExtendingInterface(node: Node): EntityNameExpression | undefined {
        switch (node.kind) {
            case SyntaxKind.Identifier:
            case SyntaxKind.PropertyAccessExpression:
                return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;
            case SyntaxKind.ExpressionWithTypeArguments:
                if (isEntityNameExpression((node as ExpressionWithTypeArguments).expression)) {
                    return (node as ExpressionWithTypeArguments).expression as EntityNameExpression;
                }
                // falls through
            default:
                return undefined;
        }
    }

    function checkAndReportErrorForUsingTypeAsNamespace(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
        const namespaceMeaning = SymbolFlags.Namespace | (isInJSFile(errorLocation) ? SymbolFlags.Value : 0);
        if (meaning === namespaceMeaning) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.Type & ~namespaceMeaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ false));
            const parent = errorLocation.parent;
            if (symbol) {
                if (isQualifiedName(parent)) {
                    Debug.assert(parent.left === errorLocation, "Should only be resolving left side of qualified name as a namespace");
                    const propName = parent.right.escapedText;
                    const propType = getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName);
                    if (propType) {
                        error(
                            parent,
                            Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,
                            unescapeLeadingUnderscores(name),
                            unescapeLeadingUnderscores(propName),
                        );
                        return true;
                    }
                }
                error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name));
                return true;
            }
        }

        return false;
    }

    function checkAndReportErrorForUsingValueAsType(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
        if (meaning & (SymbolFlags.Type & ~SymbolFlags.Namespace)) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, ~SymbolFlags.Type & SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false));
            if (symbol && !(symbol.flags & SymbolFlags.Namespace)) {
                error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }

    function isPrimitiveTypeName(name: __String) {
        return name === "any" || name === "string" || name === "number" || name === "boolean" || name === "never" || name === "unknown";
    }

    function checkAndReportErrorForExportingPrimitiveType(errorLocation: Node, name: __String): boolean {
        if (isPrimitiveTypeName(name) && errorLocation.parent.kind === SyntaxKind.ExportSpecifier) {
            error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name as string);
            return true;
        }
        return false;
    }

    function checkAndReportErrorForUsingTypeAsValue(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
        if (meaning & SymbolFlags.Value) {
            if (isPrimitiveTypeName(name)) {
                const grandparent = errorLocation.parent.parent;
                if (grandparent && grandparent.parent && isHeritageClause(grandparent)) {
                    const heritageKind = grandparent.token;
                    const containerKind = grandparent.parent.kind;
                    if (containerKind === SyntaxKind.InterfaceDeclaration && heritageKind === SyntaxKind.ExtendsKeyword) {
                        error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name));
                    }
                    else if (isClassLike(grandparent.parent) && heritageKind === SyntaxKind.ExtendsKeyword) {
                        error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name));
                    }
                    else if (isClassLike(grandparent.parent) && heritageKind === SyntaxKind.ImplementsKeyword) {
                        error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name));
                    }
                }
                else {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name));
                }
                return true;
            }
            const symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.Type & ~SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false));
            const allFlags = symbol && getSymbolFlags(symbol);
            if (symbol && allFlags !== undefined && !(allFlags & SymbolFlags.Value)) {
                const rawName = unescapeLeadingUnderscores(name);
                if (isES2015OrLaterConstructorName(name)) {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName);
                }
                else if (maybeMappedType(errorLocation, symbol)) {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, rawName === "K" ? "P" : "K");
                }
                else {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName);
                }
                return true;
            }
        }
        return false;
    }

    function maybeMappedType(node: Node, symbol: Symbol) {
        const container = findAncestor(node.parent, n => isComputedPropertyName(n) || isPropertySignature(n) ? false : isTypeLiteralNode(n) || "quit") as TypeLiteralNode | undefined;
        if (container && container.members.length === 1) {
            const type = getDeclaredTypeOfSymbol(symbol);
            return !!(type.flags & TypeFlags.Union) && allTypesAssignableToKind(type, TypeFlags.StringOrNumberLiteral, /*strict*/ true);
        }
        return false;
    }

    function isES2015OrLaterConstructorName(n: __String) {
        switch (n) {
            case "Promise":
            case "Symbol":
            case "Map":
            case "WeakMap":
            case "Set":
            case "WeakSet":
                return true;
        }
        return false;
    }

    function checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
        if (meaning & (SymbolFlags.Value & ~SymbolFlags.Type)) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.NamespaceModule, /*nameNotFoundMessage*/ undefined, /*isUse*/ false));
            if (symbol) {
                error(
                    errorLocation,
                    Diagnostics.Cannot_use_namespace_0_as_a_value,
                    unescapeLeadingUnderscores(name),
                );
                return true;
            }
        }
        else if (meaning & (SymbolFlags.Type & ~SymbolFlags.Value)) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.Module, /*nameNotFoundMessage*/ undefined, /*isUse*/ false));
            if (symbol) {
                error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }

    function checkResolvedBlockScopedVariable(result: Symbol, errorLocation: Node): void {
        Debug.assert(!!(result.flags & SymbolFlags.BlockScopedVariable || result.flags & SymbolFlags.Class || result.flags & SymbolFlags.Enum));
        if (result.flags & (SymbolFlags.Function | SymbolFlags.FunctionScopedVariable | SymbolFlags.Assignment) && result.flags & SymbolFlags.Class) {
            // constructor functions aren't block scoped
            return;
        }
        // Block-scoped variables cannot be used before their definition
        const declaration = result.declarations?.find(
            d => isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind === SyntaxKind.EnumDeclaration),
        );

        if (declaration === undefined) return Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration");

        if (!(declaration.flags & NodeFlags.Ambient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation)) {
            let diagnosticMessage;
            const declarationName = declarationNameToString(getNameOfDeclaration(declaration));
            if (result.flags & SymbolFlags.BlockScopedVariable) {
                diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName);
            }
            else if (result.flags & SymbolFlags.Class) {
                diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName);
            }
            else if (result.flags & SymbolFlags.RegularEnum) {
                diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName);
            }
            else {
                Debug.assert(!!(result.flags & SymbolFlags.ConstEnum));
                if (getIsolatedModules(compilerOptions)) {
                    diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName);
                }
            }

            if (diagnosticMessage) {
                addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName));
            }
        }
    }

    /* Starting from 'initial' node walk up the parent chain until 'stopAt' node is reached.
     * If at any point current node is equal to 'parent' node - return true.
     * If current node is an IIFE, continue walking up.
     * Return false if 'stopAt' node is reached or isFunctionLike(current) === true.
     */
    function isSameScopeDescendentOf(initial: Node, parent: Node | undefined, stopAt: Node): boolean {
        return !!parent && !!findAncestor(initial, n =>
            n === parent
            || (n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n) & FunctionFlags.AsyncGenerator)) ? "quit" : false));
    }

    function getAnyImportSyntax(node: Node): AnyImportOrJsDocImport | undefined {
        switch (node.kind) {
            case SyntaxKind.ImportEqualsDeclaration:
                return node as ImportEqualsDeclaration;
            case SyntaxKind.ImportClause:
                return (node as ImportClause).parent;
            case SyntaxKind.NamespaceImport:
                return (node as NamespaceImport).parent.parent;
            case SyntaxKind.ImportSpecifier:
                return (node as ImportSpecifier).parent.parent.parent;
            default:
                return undefined;
        }
    }

    function getDeclarationOfAliasSymbol(symbol: Symbol): Declaration | undefined {
        return symbol.declarations && findLast<Declaration>(symbol.declarations, isAliasSymbolDeclaration);
    }

    /**
     * An alias symbol is created by one of the following declarations:
     * import <symbol> = ...
     * import <symbol> from ...
     * import * as <symbol> from ...
     * import { x as <symbol> } from ...
     * export { x as <symbol> } from ...
     * export * as ns <symbol> from ...
     * export = <EntityNameExpression>
     * export default <EntityNameExpression>
     * module.exports = <EntityNameExpression>
     * {<Identifier>}
     * {name: <EntityNameExpression>}
     * const { x } = require ...
     */
    function isAliasSymbolDeclaration(node: Node): boolean {
        return node.kind === SyntaxKind.ImportEqualsDeclaration
            || node.kind === SyntaxKind.NamespaceExportDeclaration
            || node.kind === SyntaxKind.ImportClause && !!(node as ImportClause).name
            || node.kind === SyntaxKind.NamespaceImport
            || node.kind === SyntaxKind.NamespaceExport
            || node.kind === SyntaxKind.ImportSpecifier
            || node.kind === SyntaxKind.ExportSpecifier
            || node.kind === SyntaxKind.ExportAssignment && exportAssignmentIsAlias(node as ExportAssignment)
            || isBinaryExpression(node) && getAssignmentDeclarationKind(node) === AssignmentDeclarationKind.ModuleExports && exportAssignmentIsAlias(node)
            || isAccessExpression(node)
                && isBinaryExpression(node.parent)
                && node.parent.left === node
                && node.parent.operatorToken.kind === SyntaxKind.EqualsToken
                && isAliasableOrJsExpression(node.parent.right)
            || node.kind === SyntaxKind.ShorthandPropertyAssignment
            || node.kind === SyntaxKind.PropertyAssignment && isAliasableOrJsExpression((node as PropertyAssignment).initializer)
            || node.kind === SyntaxKind.VariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node)
            || node.kind === SyntaxKind.BindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent);
    }

    function isAliasableOrJsExpression(e: Expression) {
        return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e);
    }

    function getTargetOfImportEqualsDeclaration(node: ImportEqualsDeclaration | VariableDeclaration, dontResolveAlias: boolean): Symbol | undefined {
        const commonJSPropertyAccess = getCommonJSPropertyAccess(node);
        if (commonJSPropertyAccess) {
            const name = (getLeftmostAccessExpression(commonJSPropertyAccess.expression) as CallExpression).arguments[0] as StringLiteral;
            return isIdentifier(commonJSPropertyAccess.name)
                ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))
                : undefined;
        }
        if (isVariableDeclaration(node) || node.moduleReference.kind === SyntaxKind.ExternalModuleReference) {
            const immediate = resolveExternalModuleName(
                node,
                getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node),
            );
            const resolved = resolveExternalModuleSymbol(immediate);
            if (resolved && ModuleKind.Node20 <= moduleKind && moduleKind <= ModuleKind.NodeNext) {
                const moduleExports = getExportOfModule(resolved, "module.exports" as __String, node, dontResolveAlias);
                if (moduleExports) {
                    return moduleExports;
                }
            }
            markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, /*overwriteEmpty*/ false);
            return resolved;
        }
        const resolved = getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias);
        checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved);
        return resolved;
    }

    function checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node: ImportEqualsDeclaration, resolved: Symbol | undefined) {
        if (markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget*/ undefined, resolved, /*overwriteEmpty*/ false) && !node.isTypeOnly) {
            const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node))!;
            const isExport = typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration;
            const message = isExport
                ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type
                : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type;
            const relatedMessage = isExport
                ? Diagnostics._0_was_exported_here
                : Diagnostics._0_was_imported_here;

            // TODO: how to get name for export *?
            const name = typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration ? "*" : moduleExportNameTextUnescaped(typeOnlyDeclaration.name);
            addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name));
        }
    }

    function resolveExportByName(moduleSymbol: Symbol, name: __String, sourceNode: TypeOnlyCompatibleAliasDeclaration | undefined, dontResolveAlias: boolean) {
        const exportValue = moduleSymbol.exports!.get(InternalSymbolName.ExportEquals);
        const exportSymbol = exportValue
            ? getPropertyOfType(getTypeOfSymbol(exportValue), name, /*skipObjectFunctionPropertyAugment*/ true)
            : moduleSymbol.exports!.get(name);
        const resolved = resolveSymbol(exportSymbol, dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, /*overwriteEmpty*/ false);
        return resolved;
    }

    function isSyntacticDefault(node: Node) {
        return ((isExportAssignment(node) && !node.isExportEquals)
            || hasSyntacticModifier(node, ModifierFlags.Default)
            || isExportSpecifier(node)
            || isNamespaceExport(node));
    }

    function getEmitSyntaxForModuleSpecifierExpression(usage: Expression) {
        return isStringLiteralLike(usage) ? host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage) : undefined;
    }

    function isESMFormatImportImportingCommonjsFormatFile(usageMode: ResolutionMode, targetMode: ResolutionMode) {
        return usageMode === ModuleKind.ESNext && targetMode === ModuleKind.CommonJS;
    }

    function isOnlyImportableAsDefault(usage: Expression, resolvedModule?: Symbol) {
        // In Node.js, JSON modules don't get named exports
        if (ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext) {
            const usageMode = getEmitSyntaxForModuleSpecifierExpression(usage);
            if (usageMode === ModuleKind.ESNext) {
                resolvedModule ??= resolveExternalModuleName(usage, usage, /*ignoreErrors*/ true);
                const targetFile = resolvedModule && getSourceFileOfModule(resolvedModule);
                return targetFile && (isJsonSourceFile(targetFile) || getDeclarationFileExtension(targetFile.fileName) === ".d.json.ts");
            }
        }
        return false;
    }

    function canHaveSyntheticDefault(file: SourceFile | undefined, moduleSymbol: Symbol, dontResolveAlias: boolean, usage: Expression) {
        const usageMode = file && getEmitSyntaxForModuleSpecifierExpression(usage);
        if (file && usageMode !== undefined) {
            const targetMode = host.getImpliedNodeFormatForEmit(file);
            if (usageMode === ModuleKind.ESNext && targetMode === ModuleKind.CommonJS && ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext) {
                // In Node.js, CommonJS modules always have a synthetic default when imported into ESM
                return true;
            }
            if (usageMode === ModuleKind.ESNext && targetMode === ModuleKind.ESNext) {
                // No matter what the `module` setting is, if we're confident that both files
                // are ESM, there cannot be a synthetic default.
                return false;
            }
        }
        if (!allowSyntheticDefaultImports) {
            return false;
        }
        // Declaration files (and ambient modules)
        if (!file || file.isDeclarationFile) {
            // Definitely cannot have a synthetic default if they have a syntactic default member specified
            const defaultExportSymbol = resolveExportByName(moduleSymbol, InternalSymbolName.Default, /*sourceNode*/ undefined, /*dontResolveAlias*/ true); // Dont resolve alias because we want the immediately exported symbol's declaration
            if (defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault)) {
                return false;
            }
            // It _might_ still be incorrect to assume there is no __esModule marker on the import at runtime, even if there is no `default` member
            // So we check a bit more,
            if (resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), /*sourceNode*/ undefined, dontResolveAlias)) {
                // If there is an `__esModule` specified in the declaration (meaning someone explicitly added it or wrote it in their code),
                // it definitely is a module and does not have a synthetic default
                return false;
            }
            // There are _many_ declaration files not written with esmodules in mind that still get compiled into a format with __esModule set
            // Meaning there may be no default at runtime - however to be on the permissive side, we allow access to a synthetic default member
            // as there is no marker to indicate if the accompanying JS has `__esModule` or not, or is even native esm
            return true;
        }
        // TypeScript files never have a synthetic default (as they are always emitted with an __esModule marker) _unless_ they contain an export= statement
        if (!isSourceFileJS(file)) {
            return hasExportAssignmentSymbol(moduleSymbol);
        }
        // JS files have a synthetic default if they do not contain ES2015+ module syntax (export = is not valid in js) _and_ do not have an __esModule marker
        return typeof file.externalModuleIndicator !== "object" && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), /*sourceNode*/ undefined, dontResolveAlias);
    }

    function getTargetOfImportClause(node: ImportClause, dontResolveAlias: boolean): Symbol | undefined {
        const moduleSymbol = resolveExternalModuleName(node, node.parent.moduleSpecifier);
        if (moduleSymbol) {
            return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias);
        }
    }

    function getTargetofModuleDefault(moduleSymbol: Symbol, node: ImportClause | ImportOrExportSpecifier, dontResolveAlias: boolean) {
        const file = moduleSymbol.declarations?.find(isSourceFile);
        const specifier = getModuleSpecifierForImportOrExport(node);
        let exportDefaultSymbol: Symbol | undefined;
        let exportModuleDotExportsSymbol: Symbol | undefined;
        if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
            exportDefaultSymbol = moduleSymbol;
        }
        else if (
            file && specifier &&
            ModuleKind.Node20 <= moduleKind && moduleKind <= ModuleKind.NodeNext &&
            getEmitSyntaxForModuleSpecifierExpression(specifier) === ModuleKind.CommonJS &&
            host.getImpliedNodeFormatForEmit(file) === ModuleKind.ESNext &&
            (exportModuleDotExportsSymbol = resolveExportByName(moduleSymbol, "module.exports" as __String, node, dontResolveAlias))
        ) {
            // We have a transpiled default import where the `require` resolves to an ES module with a `module.exports` named
            // export. If `esModuleInterop` is enabled, this will work:
            //
            // const dep_1 = __importDefault(require("./dep.mjs")); // wraps like { default: require("./dep.mjs") }
            // dep_1.default; // require("./dep.mjs") -> the `module.exports` export value
            //
            // But without `esModuleInterop`, it will be broken:
            //
            // const dep_1 = require("./dep.mjs"); // the `module.exports` export value (could be primitive)
            // dep_1.default; // `default` property access on the `module.exports` export value
            //
            // We could try to resolve the 'default' property in the latter case, but it's a mistake to run in this
            // environment without `esModuleInterop`, so just error.
            if (!getESModuleInterop(compilerOptions)) {
                error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), "esModuleInterop");
                return undefined;
            }
            markSymbolOfAliasDeclarationIfTypeOnly(node, exportModuleDotExportsSymbol, /*finalTarget*/ undefined, /*overwriteEmpty*/ false);
            return exportModuleDotExportsSymbol;
        }
        else {
            exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolName.Default, node, dontResolveAlias);
        }

        if (!specifier) {
            return exportDefaultSymbol;
        }
        const hasDefaultOnly = isOnlyImportableAsDefault(specifier, moduleSymbol);
        const hasSyntheticDefault = canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier);
        if (!exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly) {
            if (hasExportAssignmentSymbol(moduleSymbol) && !allowSyntheticDefaultImports) {
                const compilerOptionName = moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop";
                const exportEqualsSymbol = moduleSymbol.exports!.get(InternalSymbolName.ExportEquals);
                const exportAssignment = exportEqualsSymbol!.valueDeclaration;
                const err = error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName);

                if (exportAssignment) {
                    addRelatedInfo(
                        err,
                        createDiagnosticForNode(
                            exportAssignment,
                            Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag,
                            compilerOptionName,
                        ),
                    );
                }
            }
            else if (isImportClause(node)) {
                reportNonDefaultExport(moduleSymbol, node);
            }
            else {
                errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name);
            }
        }
        else if (hasSyntheticDefault || hasDefaultOnly) {
            // per emit behavior, a synthetic default overrides a "real" .default member if `__esModule` is not present
            const resolved = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, /*overwriteEmpty*/ false);
            return resolved;
        }
        markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, /*finalTarget*/ undefined, /*overwriteEmpty*/ false);
        return exportDefaultSymbol;
    }

    function getModuleSpecifierForImportOrExport(node: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier): Expression | undefined {
        switch (node.kind) {
            case SyntaxKind.ImportClause:
                return node.parent.moduleSpecifier;
            case SyntaxKind.ImportEqualsDeclaration:
                return isExternalModuleReference(node.moduleReference) ? node.moduleReference.expression : undefined;
            case SyntaxKind.NamespaceImport:
                return node.parent.parent.moduleSpecifier;
            case SyntaxKind.ImportSpecifier:
                return node.parent.parent.parent.moduleSpecifier;
            case SyntaxKind.ExportSpecifier:
                return node.parent.parent.moduleSpecifier;
            default:
                return Debug.assertNever(node);
        }
    }

    function reportNonDefaultExport(moduleSymbol: Symbol, node: ImportClause) {
        if (moduleSymbol.exports?.has(node.symbol.escapedName)) {
            error(
                node.name,
                Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead,
                symbolToString(moduleSymbol),
                symbolToString(node.symbol),
            );
        }
        else {
            const diagnostic = error(node.name, Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol));
            const exportStar = moduleSymbol.exports?.get(InternalSymbolName.ExportStar);
            if (exportStar) {
                const defaultExport = exportStar.declarations?.find(decl =>
                    !!(
                        isExportDeclaration(decl) && decl.moduleSpecifier &&
                        resolveExternalModuleName(decl, decl.moduleSpecifier)?.exports?.has(InternalSymbolName.Default)
                    )
                );
                if (defaultExport) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default));
                }
            }
        }
    }

    function getTargetOfNamespaceImport(node: NamespaceImport, dontResolveAlias: boolean): Symbol | undefined {
        const moduleSpecifier = node.parent.parent.moduleSpecifier;
        const immediate = resolveExternalModuleName(node, moduleSpecifier);
        const resolved = resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, /*suppressInteropError*/ false);
        markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, /*overwriteEmpty*/ false);
        return resolved;
    }

    function getTargetOfNamespaceExport(node: NamespaceExport, dontResolveAlias: boolean): Symbol | undefined {
        const moduleSpecifier = node.parent.moduleSpecifier;
        const immediate = moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier);
        const resolved = moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, /*suppressInteropError*/ false);
        markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, /*overwriteEmpty*/ false);
        return resolved;
    }

    // This function creates a synthetic symbol that combines the value side of one symbol with the
    // type/namespace side of another symbol. Consider this example:
    //
    //   declare module graphics {
    //       interface Point {
    //           x: number;
    //           y: number;
    //       }
    //   }
    //   declare var graphics: {
    //       Point: new (x: number, y: number) => graphics.Point;
    //   }
    //   declare module "graphics" {
    //       export = graphics;
    //   }
    //
    // An 'import { Point } from "graphics"' needs to create a symbol that combines the value side 'Point'
    // property with the type/namespace side interface 'Point'.
    function combineValueAndTypeSymbols(valueSymbol: Symbol, typeSymbol: Symbol): Symbol {
        if (valueSymbol === unknownSymbol && typeSymbol === unknownSymbol) {
            return unknownSymbol;
        }
        if (valueSymbol.flags & (SymbolFlags.Type | SymbolFlags.Namespace)) {
            return valueSymbol;
        }
        const result = createSymbol(valueSymbol.flags | typeSymbol.flags, valueSymbol.escapedName);
        Debug.assert(valueSymbol.declarations || typeSymbol.declarations);
        result.declarations = deduplicate(concatenate(valueSymbol.declarations!, typeSymbol.declarations), equateValues);
        result.parent = valueSymbol.parent || typeSymbol.parent;
        if (valueSymbol.valueDeclaration) result.valueDeclaration = valueSymbol.valueDeclaration;
        if (typeSymbol.members) result.members = new Map(typeSymbol.members);
        if (valueSymbol.exports) result.exports = new Map(valueSymbol.exports);
        return result;
    }

    function getExportOfModule(symbol: Symbol, nameText: __String, specifier: Declaration, dontResolveAlias: boolean): Symbol | undefined {
        if (symbol.flags & SymbolFlags.Module) {
            const exportSymbol = getExportsOfSymbol(symbol).get(nameText);
            const resolved = resolveSymbol(exportSymbol, dontResolveAlias);
            const exportStarDeclaration = getSymbolLinks(symbol).typeOnlyExportStarMap?.get(nameText);
            markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, /*overwriteEmpty*/ false, exportStarDeclaration, nameText);
            return resolved;
        }
    }

    function getPropertyOfVariable(symbol: Symbol, name: __String): Symbol | undefined {
        if (symbol.flags & SymbolFlags.Variable) {
            const typeAnnotation = (symbol.valueDeclaration as VariableDeclaration).type;
            if (typeAnnotation) {
                return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name));
            }
        }
    }

    function getExternalModuleMember(node: ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag, specifier: ImportOrExportSpecifier | BindingElement | PropertyAccessExpression, dontResolveAlias = false): Symbol | undefined {
        const moduleSpecifier = getExternalModuleRequireArgument(node) || (node as ImportDeclaration | ExportDeclaration | JSDocImportTag).moduleSpecifier!;
        const moduleSymbol = resolveExternalModuleName(node, moduleSpecifier)!; // TODO: GH#18217
        const name = !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name;
        if (!isIdentifier(name) && name.kind !== SyntaxKind.StringLiteral) {
            return undefined;
        }
        const nameText = moduleExportNameTextEscaped(name);
        const suppressInteropError = nameText === InternalSymbolName.Default && allowSyntheticDefaultImports;
        const targetSymbol = resolveESModuleSymbol(moduleSymbol, moduleSpecifier, /*dontResolveAlias*/ false, suppressInteropError);
        if (targetSymbol) {
            // Note: The empty string is a valid module export name:
            //
            //   import { "" as foo } from "./foo";
            //   export { foo as "" };
            //
            if (nameText || name.kind === SyntaxKind.StringLiteral) {
                if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
                    return moduleSymbol;
                }

                let symbolFromVariable: Symbol | undefined;
                // First check if module was specified with "export=". If so, get the member from the resolved type
                if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolName.ExportEquals)) {
                    symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), nameText, /*skipObjectFunctionPropertyAugment*/ true);
                }
                else {
                    symbolFromVariable = getPropertyOfVariable(targetSymbol, nameText);
                }
                // if symbolFromVariable is export - get its final target
                symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias);

                let symbolFromModule = getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias);
                if (symbolFromModule === undefined && nameText === InternalSymbolName.Default) {
                    const file = moduleSymbol.declarations?.find(isSourceFile);
                    if (isOnlyImportableAsDefault(moduleSpecifier, moduleSymbol) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier)) {
                        symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
                    }
                }

                const symbol = symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ?
                    combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :
                    symbolFromModule || symbolFromVariable;

                if (isImportOrExportSpecifier(specifier) && isOnlyImportableAsDefault(moduleSpecifier, moduleSymbol) && nameText !== InternalSymbolName.Default) {
                    error(name, Diagnostics.Named_imports_from_a_JSON_file_into_an_ECMAScript_module_are_not_allowed_when_module_is_set_to_0, ModuleKind[moduleKind]);
                }
                else if (!symbol) {
                    errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name);
                }
                return symbol;
            }
        }
    }

    function errorNoModuleMemberSymbol(moduleSymbol: Symbol, targetSymbol: Symbol, node: Node, name: ModuleExportName) {
        const moduleName = getFullyQualifiedName(moduleSymbol, node);
        const declarationName = declarationNameToString(name);
        const suggestion = isIdentifier(name) ? getSuggestedSymbolForNonexistentModule(name, targetSymbol) : undefined;
        if (suggestion !== undefined) {
            const suggestionName = symbolToString(suggestion);
            const diagnostic = error(name, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName);
            if (suggestion.valueDeclaration) {
                addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName));
            }
        }
        else {
            if (moduleSymbol.exports?.has(InternalSymbolName.Default)) {
                error(
                    name,
                    Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead,
                    moduleName,
                    declarationName,
                );
            }
            else {
                reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName);
            }
        }
    }

    function reportNonExportedMember(node: Node, name: ModuleExportName, declarationName: string, moduleSymbol: Symbol, moduleName: string): void {
        const localSymbol = tryCast(moduleSymbol.valueDeclaration, canHaveLocals)?.locals?.get(moduleExportNameTextEscaped(name));
        const exports = moduleSymbol.exports;
        if (localSymbol) {
            const exportedEqualsSymbol = exports?.get(InternalSymbolName.ExportEquals);
            if (exportedEqualsSymbol) {
                getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) :
                    error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
            }
            else {
                const exportedSymbol = exports ? find(symbolsToArray(exports), symbol => !!getSymbolIfSameReference(symbol, localSymbol)) : undefined;
                const diagnostic = exportedSymbol ? error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) :
                    error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName);
                if (localSymbol.declarations) {
                    addRelatedInfo(diagnostic, ...map(localSymbol.declarations, (decl, index) => createDiagnosticForNode(decl, index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here, declarationName)));
                }
            }
        }
        else {
            error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
        }
    }

    function reportInvalidImportEqualsExportMember(node: Node, name: ModuleExportName, declarationName: string, moduleName: string) {
        if (moduleKind >= ModuleKind.ES2015) {
            const message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import :
                Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
            error(name, message, declarationName);
        }
        else {
            if (isInJSFile(node)) {
                const message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import :
                    Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                error(name, message, declarationName);
            }
            else {
                const message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import :
                    Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                error(name, message, declarationName, declarationName, moduleName);
            }
        }
    }

    function getTargetOfImportSpecifier(node: ImportSpecifier | BindingElement, dontResolveAlias: boolean): Symbol | undefined {
        if (isImportSpecifier(node) && moduleExportNameIsDefault(node.propertyName || node.name)) {
            const specifier = getModuleSpecifierForImportOrExport(node);
            const moduleSymbol = specifier && resolveExternalModuleName(node, specifier);
            if (moduleSymbol) {
                return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias);
            }
        }
        const root = isBindingElement(node) ? getRootDeclaration(node) as VariableDeclaration : node.parent.parent.parent;
        const commonJSPropertyAccess = getCommonJSPropertyAccess(root);
        const resolved = getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias);
        const name = node.propertyName || node.name;
        if (commonJSPropertyAccess && resolved && isIdentifier(name)) {
            return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias);
        }
        markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget*/ undefined, resolved, /*overwriteEmpty*/ false);
        return resolved;
    }

    function getCommonJSPropertyAccess(node: Node) {
        if (isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer)) {
            return node.initializer;
        }
    }

    function getTargetOfNamespaceExportDeclaration(node: NamespaceExportDeclaration, dontResolveAlias: boolean): Symbol | undefined {
        if (canHaveSymbol(node.parent)) {
            const resolved = resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget*/ undefined, resolved, /*overwriteEmpty*/ false);
            return resolved;
        }
    }

    function getTargetOfExportSpecifier(node: ExportSpecifier, meaning: SymbolFlags, dontResolveAlias?: boolean) {
        const name = node.propertyName || node.name;
        if (moduleExportNameIsDefault(name)) {
            const specifier = getModuleSpecifierForImportOrExport(node);
            const moduleSymbol = specifier && resolveExternalModuleName(node, specifier);
            if (moduleSymbol) {
                return getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias);
            }
        }
        const resolved = node.parent.parent.moduleSpecifier ?
            getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :
            name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }
            resolveEntityName(name, meaning, /*ignoreErrors*/ false, dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget*/ undefined, resolved, /*overwriteEmpty*/ false);
        return resolved;
    }

    function getTargetOfExportAssignment(node: ExportAssignment | BinaryExpression, dontResolveAlias: boolean): Symbol | undefined {
        const expression = isExportAssignment(node) ? node.expression : node.right;
        const resolved = getTargetOfAliasLikeExpression(expression, dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget*/ undefined, resolved, /*overwriteEmpty*/ false);
        return resolved;
    }

    function getTargetOfAliasLikeExpression(expression: Expression, dontResolveAlias: boolean) {
        if (isClassExpression(expression)) {
            return checkExpressionCached(expression).symbol;
        }
        if (!isEntityName(expression) && !isEntityNameExpression(expression)) {
            return undefined;
        }
        const aliasLike = resolveEntityName(expression, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/ true, dontResolveAlias);
        if (aliasLike) {
            return aliasLike;
        }
        checkExpressionCached(expression);
        return getNodeLinks(expression).resolvedSymbol;
    }

    function getTargetOfAccessExpression(node: AccessExpression, dontRecursivelyResolve: boolean): Symbol | undefined {
        if (!(isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === SyntaxKind.EqualsToken)) {
            return undefined;
        }

        return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve);
    }

    function getTargetOfAliasDeclaration(node: Declaration, dontRecursivelyResolve = false): Symbol | undefined {
        switch (node.kind) {
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.VariableDeclaration:
                return getTargetOfImportEqualsDeclaration(node as ImportEqualsDeclaration | VariableDeclaration, dontRecursivelyResolve);
            case SyntaxKind.ImportClause:
                return getTargetOfImportClause(node as ImportClause, dontRecursivelyResolve);
            case SyntaxKind.NamespaceImport:
                return getTargetOfNamespaceImport(node as NamespaceImport, dontRecursivelyResolve);
            case SyntaxKind.NamespaceExport:
                return getTargetOfNamespaceExport(node as NamespaceExport, dontRecursivelyResolve);
            case SyntaxKind.ImportSpecifier:
            case SyntaxKind.BindingElement:
                return getTargetOfImportSpecifier(node as ImportSpecifier | BindingElement, dontRecursivelyResolve);
            case SyntaxKind.ExportSpecifier:
                return getTargetOfExportSpecifier(node as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, dontRecursivelyResolve);
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.BinaryExpression:
                return getTargetOfExportAssignment(node as ExportAssignment | BinaryExpression, dontRecursivelyResolve);
            case SyntaxKind.NamespaceExportDeclaration:
                return getTargetOfNamespaceExportDeclaration(node as NamespaceExportDeclaration, dontRecursivelyResolve);
            case SyntaxKind.ShorthandPropertyAssignment:
                return resolveEntityName((node as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/ true, dontRecursivelyResolve);
            case SyntaxKind.PropertyAssignment:
                return getTargetOfAliasLikeExpression((node as PropertyAssignment).initializer, dontRecursivelyResolve);
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.PropertyAccessExpression:
                return getTargetOfAccessExpression(node as AccessExpression, dontRecursivelyResolve);
            default:
                return Debug.fail();
        }
    }

    /**
     * Indicates that a symbol is an alias that does not merge with a local declaration.
     * OR Is a JSContainer which may merge an alias with a local declaration
     */
    function isNonLocalAlias(symbol: Symbol | undefined, excludes = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace): symbol is Symbol {
        if (!symbol) return false;
        return (symbol.flags & (SymbolFlags.Alias | excludes)) === SymbolFlags.Alias || !!(symbol.flags & SymbolFlags.Alias && symbol.flags & SymbolFlags.Assignment);
    }

    function resolveSymbol(symbol: Symbol, dontResolveAlias?: boolean): Symbol;
    function resolveSymbol(symbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined;
    function resolveSymbol(symbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined {
        return !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol;
    }

    function resolveAlias(symbol: Symbol): Symbol {
        Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here.");
        const links = getSymbolLinks(symbol);
        if (!links.aliasTarget) {
            links.aliasTarget = resolvingSymbol;
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            const target = getTargetOfAliasDeclaration(node);
            if (links.aliasTarget === resolvingSymbol) {
                links.aliasTarget = target || unknownSymbol;
            }
            else {
                error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
            }
        }
        else if (links.aliasTarget === resolvingSymbol) {
            links.aliasTarget = unknownSymbol;
        }
        return links.aliasTarget;
    }

    function tryResolveAlias(symbol: Symbol): Symbol | undefined {
        const links = getSymbolLinks(symbol);
        if (links.aliasTarget !== resolvingSymbol) {
            return resolveAlias(symbol);
        }

        return undefined;
    }

    /**
     * Gets combined flags of a `symbol` and all alias targets it resolves to. `resolveAlias`
     * is typically recursive over chains of aliases, but stops mid-chain if an alias is merged
     * with another exported symbol, e.g.
     * ```ts
     * // a.ts
     * export const a = 0;
     * // b.ts
     * export { a } from "./a";
     * export type a = number;
     * // c.ts
     * import { a } from "./b";
     * ```
     * Calling `resolveAlias` on the `a` in c.ts would stop at the merged symbol exported
     * from b.ts, even though there is still more alias to resolve. Consequently, if we were
     * trying to determine if the `a` in c.ts has a value meaning, looking at the flags on
     * the local symbol and on the symbol returned by `resolveAlias` is not enough.
     * @returns SymbolFlags.All if `symbol` is an alias that ultimately resolves to `unknown`;
     * combined flags of all alias targets otherwise.
     */
    function getSymbolFlags(symbol: Symbol, excludeTypeOnlyMeanings?: boolean, excludeLocalMeanings?: boolean): SymbolFlags {
        const typeOnlyDeclaration = excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol);
        const typeOnlyDeclarationIsExportStar = typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration);
        const typeOnlyResolution = typeOnlyDeclaration && (
            typeOnlyDeclarationIsExportStar
                ? resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier, /*ignoreErrors*/ true)
                : resolveAlias(typeOnlyDeclaration.symbol)
        );
        const typeOnlyExportStarTargets = typeOnlyDeclarationIsExportStar && typeOnlyResolution ? getExportsOfModule(typeOnlyResolution) : undefined;
        let flags = excludeLocalMeanings ? SymbolFlags.None : symbol.flags;
        let seenSymbols;
        while (symbol.flags & SymbolFlags.Alias) {
            const target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));
            if (
                !typeOnlyDeclarationIsExportStar && target === typeOnlyResolution ||
                typeOnlyExportStarTargets?.get(target.escapedName) === target
            ) {
                break;
            }
            if (target === unknownSymbol) {
                return SymbolFlags.All;
            }

            // Optimizations - try to avoid creating or adding to
            // `seenSymbols` if possible
            if (target === symbol || seenSymbols?.has(target)) {
                break;
            }
            if (target.flags & SymbolFlags.Alias) {
                if (seenSymbols) {
                    seenSymbols.add(target);
                }
                else {
                    seenSymbols = new Set([symbol, target]);
                }
            }
            flags |= target.flags;
            symbol = target;
        }
        return flags;
    }

    /**
     * Marks a symbol as type-only if its declaration is syntactically type-only.
     * If it is not itself marked type-only, but resolves to a type-only alias
     * somewhere in its resolution chain, save a reference to the type-only alias declaration
     * so the alias _not_ marked type-only can be identified as _transitively_ type-only.
     *
     * This function is called on each alias declaration that could be type-only or resolve to
     * another type-only alias during `resolveAlias`, so that later, when an alias is used in a
     * JS-emitting expression, we can quickly determine if that symbol is effectively type-only
     * and issue an error if so.
     *
     * @param aliasDeclaration The alias declaration not marked as type-only
     * @param immediateTarget The symbol to which the alias declaration immediately resolves
     * @param finalTarget The symbol to which the alias declaration ultimately resolves
     * @param overwriteEmpty Checks `resolvesToSymbol` for type-only declarations even if `aliasDeclaration`
     * has already been marked as not resolving to a type-only alias. Used when recursively resolving qualified
     * names of import aliases, e.g. `import C = a.b.C`. If namespace `a` is not found to be type-only, the
     * import declaration will initially be marked as not resolving to a type-only symbol. But, namespace `b`
     * must still be checked for a type-only marker, overwriting the previous negative result if found.
     */
    function markSymbolOfAliasDeclarationIfTypeOnly(
        aliasDeclaration: Declaration | undefined,
        immediateTarget: Symbol | undefined,
        finalTarget: Symbol | undefined,
        overwriteEmpty: boolean,
        exportStarDeclaration?: ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; },
        exportStarName?: __String,
    ): boolean {
        if (!aliasDeclaration || isPropertyAccessExpression(aliasDeclaration)) return false;

        // If the declaration itself is type-only, mark it and return.
        // No need to check what it resolves to.
        const sourceSymbol = getSymbolOfDeclaration(aliasDeclaration);
        if (isTypeOnlyImportOrExportDeclaration(aliasDeclaration)) {
            const links = getSymbolLinks(sourceSymbol);
            links.typeOnlyDeclaration = aliasDeclaration;
            return true;
        }
        if (exportStarDeclaration) {
            const links = getSymbolLinks(sourceSymbol);
            links.typeOnlyDeclaration = exportStarDeclaration;
            if (sourceSymbol.escapedName !== exportStarName) {
                links.typeOnlyExportStarName = exportStarName;
            }
            return true;
        }

        const links = getSymbolLinks(sourceSymbol);
        return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty)
            || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty);
    }

    function markSymbolOfAliasDeclarationIfTypeOnlyWorker(aliasDeclarationLinks: SymbolLinks, target: Symbol | undefined, overwriteEmpty: boolean): boolean {
        if (target && (aliasDeclarationLinks.typeOnlyDeclaration === undefined || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false)) {
            const exportSymbol = target.exports?.get(InternalSymbolName.ExportEquals) ?? target;
            const typeOnly = exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration);
            aliasDeclarationLinks.typeOnlyDeclaration = typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false;
        }
        return !!aliasDeclarationLinks.typeOnlyDeclaration;
    }

    /** Indicates that a symbol directly or indirectly resolves to a type-only import or export. */
    function getTypeOnlyAliasDeclaration(symbol: Symbol, include?: SymbolFlags): TypeOnlyAliasDeclaration | undefined {
        if (!(symbol.flags & SymbolFlags.Alias)) {
            return undefined;
        }
        const links = getSymbolLinks(symbol);
        if (links.typeOnlyDeclaration === undefined) {
            // We need to set a WIP value here to prevent reentrancy during `getImmediateAliasedSymbol` which, paradoxically, can depend on this
            links.typeOnlyDeclaration = false;
            const resolved = resolveSymbol(symbol); // do this before the `resolveImmediate` below, as it uses a different circularity cache and we might hide a circularity error if we blindly get the immediate alias first
            // While usually the alias will have been marked during the pass by the full typecheck, we may still need to calculate the alias declaration now
            markSymbolOfAliasDeclarationIfTypeOnly(symbol.declarations?.[0], getDeclarationOfAliasSymbol(symbol) && getImmediateAliasedSymbol(symbol), resolved, /*overwriteEmpty*/ true);
        }
        if (include === undefined) {
            return links.typeOnlyDeclaration || undefined;
        }
        if (links.typeOnlyDeclaration) {
            const resolved = links.typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration
                ? resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent!).get(links.typeOnlyExportStarName || symbol.escapedName))!
                : resolveAlias(links.typeOnlyDeclaration.symbol);
            return getSymbolFlags(resolved) & include ? links.typeOnlyDeclaration : undefined;
        }
        return undefined;
    }

    // This function is only for imports with entity names
    function getSymbolOfPartOfRightHandSideOfImportEquals(entityName: EntityName, dontResolveAlias?: boolean): Symbol | undefined {
        // There are three things we might try to look for. In the following examples,
        // the search term is enclosed in |...|:
        //
        //     import a = |b|; // Namespace
        //     import a = |b.c|; // Value, type, namespace
        //     import a = |b.c|.d; // Namespace
        if (entityName.kind === SyntaxKind.Identifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
            entityName = entityName.parent as QualifiedName;
        }
        // Check for case 1 and 3 in the above example
        if (entityName.kind === SyntaxKind.Identifier || entityName.parent.kind === SyntaxKind.QualifiedName) {
            return resolveEntityName(entityName, SymbolFlags.Namespace, /*ignoreErrors*/ false, dontResolveAlias);
        }
        else {
            // Case 2 in above example
            // entityName.kind could be a QualifiedName or a Missing identifier
            Debug.assert(entityName.parent.kind === SyntaxKind.ImportEqualsDeclaration);
            return resolveEntityName(entityName, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/ false, dontResolveAlias);
        }
    }

    function getFullyQualifiedName(symbol: Symbol, containingLocation?: Node): string {
        return symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, /*meaning*/ undefined, SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind);
    }

    function getContainingQualifiedNameNode(node: QualifiedName) {
        while (isQualifiedName(node.parent)) {
            node = node.parent;
        }
        return node;
    }

    function tryGetQualifiedNameAsValue(node: QualifiedName) {
        let left: Identifier | QualifiedName = getFirstIdentifier(node);
        let symbol = resolveName(left, left, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
        if (!symbol) {
            return undefined;
        }
        while (isQualifiedName(left.parent)) {
            const type = getTypeOfSymbol(symbol);
            symbol = getPropertyOfType(type, left.parent.right.escapedText);
            if (!symbol) {
                return undefined;
            }
            left = left.parent;
        }
        return symbol;
    }

    /**
     * Resolves a qualified name and any involved aliases.
     */
    function resolveEntityName(name: EntityNameOrEntityNameExpression, meaning: SymbolFlags, ignoreErrors?: boolean, dontResolveAlias?: boolean, location?: Node): Symbol | undefined {
        if (nodeIsMissing(name)) {
            return undefined;
        }

        const namespaceMeaning = SymbolFlags.Namespace | (isInJSFile(name) ? meaning & SymbolFlags.Value : 0);
        let symbol: Symbol | undefined;
        if (name.kind === SyntaxKind.Identifier) {
            const message = meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name));
            const symbolFromJSPrototype = isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined;
            symbol = getMergedSymbol(resolveName(location || name, name, meaning, ignoreErrors || symbolFromJSPrototype ? undefined : message, /*isUse*/ true, /*excludeGlobals*/ false));
            if (!symbol) {
                return getMergedSymbol(symbolFromJSPrototype);
            }
        }
        else if (name.kind === SyntaxKind.QualifiedName || name.kind === SyntaxKind.PropertyAccessExpression) {
            const left = name.kind === SyntaxKind.QualifiedName ? name.left : name.expression;
            const right = name.kind === SyntaxKind.QualifiedName ? name.right : name.name;
            let namespace = resolveEntityName(left, namespaceMeaning, ignoreErrors, /*dontResolveAlias*/ false, location);
            if (!namespace || nodeIsMissing(right)) {
                return undefined;
            }
            else if (namespace === unknownSymbol) {
                return namespace;
            }
            if (
                namespace.valueDeclaration &&
                isInJSFile(namespace.valueDeclaration) &&
                getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Bundler &&
                isVariableDeclaration(namespace.valueDeclaration) &&
                namespace.valueDeclaration.initializer &&
                isCommonJsRequire(namespace.valueDeclaration.initializer)
            ) {
                const moduleName = (namespace.valueDeclaration.initializer as CallExpression).arguments[0] as StringLiteral;
                const moduleSym = resolveExternalModuleName(moduleName, moduleName);
                if (moduleSym) {
                    const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                    if (resolvedModuleSymbol) {
                        namespace = resolvedModuleSymbol;
                    }
                }
            }
            symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning));
            if (!symbol && (namespace.flags & SymbolFlags.Alias)) {
                // `namespace` can be resolved further if there was a symbol merge with a re-export
                symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.escapedText, meaning));
            }
            if (!symbol) {
                if (!ignoreErrors) {
                    const namespaceName = getFullyQualifiedName(namespace);
                    const declarationName = declarationNameToString(right);
                    const suggestionForNonexistentModule = getSuggestedSymbolForNonexistentModule(right, namespace);
                    if (suggestionForNonexistentModule) {
                        error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule));
                        return undefined;
                    }

                    const containingQualifiedName = isQualifiedName(name) && getContainingQualifiedNameNode(name);
                    const canSuggestTypeof = globalObjectType // <-- can't pull on types if global types aren't initialized yet
                        && (meaning & SymbolFlags.Type)
                        && containingQualifiedName
                        && !isTypeOfExpression(containingQualifiedName.parent)
                        && tryGetQualifiedNameAsValue(containingQualifiedName);
                    if (canSuggestTypeof) {
                        error(
                            containingQualifiedName,
                            Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0,
                            entityNameToString(containingQualifiedName),
                        );
                        return undefined;
                    }

                    if (meaning & SymbolFlags.Namespace && isQualifiedName(name.parent)) {
                        const exportedTypeSymbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, SymbolFlags.Type));
                        if (exportedTypeSymbol) {
                            error(
                                name.parent.right,
                                Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,
                                symbolToString(exportedTypeSymbol),
                                unescapeLeadingUnderscores(name.parent.right.escapedText),
                            );
                            return undefined;
                        }
                    }

                    error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName);
                }
                return undefined;
            }
        }
        else {
            Debug.assertNever(name, "Unknown entity name kind.");
        }
        if (!nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags & SymbolFlags.Alias || name.parent.kind === SyntaxKind.ExportAssignment)) {
            markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, /*finalTarget*/ undefined, /*overwriteEmpty*/ true);
        }
        return (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol);
    }

    /**
     * 1. For prototype-property methods like `A.prototype.m = function () ...`, try to resolve names in the scope of `A` too.
     * Note that prototype-property assignment to locations outside the current file (eg globals) doesn't work, so
     * name resolution won't work either.
     * 2. For property assignments like `{ x: function f () { } }`, try to resolve names in the scope of `f` too.
     */
    function resolveEntityNameFromAssignmentDeclaration(name: Identifier, meaning: SymbolFlags) {
        if (isJSDocTypeReference(name.parent)) {
            const secondaryLocation = getAssignmentDeclarationLocation(name.parent);
            if (secondaryLocation) {
                return resolveName(secondaryLocation, name, meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
            }
        }
    }

    function getAssignmentDeclarationLocation(node: TypeReferenceNode): Node | undefined {
        const typeAlias = findAncestor(node, node => !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) ? "quit" : isJSDocTypeAlias(node));
        if (typeAlias) {
            return;
        }
        const host = getJSDocHost(node);
        if (host && isExpressionStatement(host) && isPrototypePropertyAssignment(host.expression)) {
            // /** @param {K} p */ X.prototype.m = function () { } <-- look for K on X's declaration
            const symbol = getSymbolOfDeclaration(host.expression.left);
            if (symbol) {
                return getDeclarationOfJSPrototypeContainer(symbol);
            }
        }
        if (host && isFunctionExpression(host) && isPrototypePropertyAssignment(host.parent) && isExpressionStatement(host.parent.parent)) {
            // X.prototype.m = /** @param {K} p */ function () { } <-- look for K on X's declaration
            const symbol = getSymbolOfDeclaration(host.parent.left);
            if (symbol) {
                return getDeclarationOfJSPrototypeContainer(symbol);
            }
        }
        if (
            host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) &&
            isBinaryExpression(host.parent.parent) &&
            getAssignmentDeclarationKind(host.parent.parent) === AssignmentDeclarationKind.Prototype
        ) {
            // X.prototype = { /** @param {K} p */m() { } } <-- look for K on X's declaration
            const symbol = getSymbolOfDeclaration(host.parent.parent.left as BindableStaticNameExpression);
            if (symbol) {
                return getDeclarationOfJSPrototypeContainer(symbol);
            }
        }
        const sig = getEffectiveJSDocHost(node);
        if (sig && isFunctionLike(sig)) {
            const symbol = getSymbolOfDeclaration(sig);
            return symbol && symbol.valueDeclaration;
        }
    }

    function getDeclarationOfJSPrototypeContainer(symbol: Symbol) {
        const decl = symbol.parent!.valueDeclaration;
        if (!decl) {
            return undefined;
        }
        const initializer = isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(decl) :
            hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(decl) :
            undefined;
        return initializer || decl;
    }

    /**
     * Get the real symbol of a declaration with an expando initializer.
     *
     * Normally, declarations have an associated symbol, but when a declaration has an expando
     * initializer, the expando's symbol is the one that has all the members merged into it.
     */
    function getExpandoSymbol(symbol: Symbol): Symbol | undefined {
        const decl = symbol.valueDeclaration;
        if (!decl || !isInJSFile(decl) || symbol.flags & SymbolFlags.TypeAlias || getExpandoInitializer(decl, /*isPrototypeAssignment*/ false)) {
            return undefined;
        }
        const init = isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(decl) : getAssignedExpandoInitializer(decl);
        if (init) {
            const initSymbol = getSymbolOfNode(init);
            if (initSymbol) {
                return mergeJSSymbols(initSymbol, symbol);
            }
        }
    }

    function resolveExternalModuleName(location: Node, moduleReferenceExpression: Expression, ignoreErrors?: boolean): Symbol | undefined {
        const isClassic = getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Classic;
        const errorMessage = isClassic ?
            Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option
            : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
        return resolveExternalModuleNameWorker(location, moduleReferenceExpression, ignoreErrors ? undefined : errorMessage, ignoreErrors);
    }

    function resolveExternalModuleNameWorker(location: Node, moduleReferenceExpression: Expression, moduleNotFoundError: DiagnosticMessage | undefined, ignoreErrors = false, isForAugmentation = false): Symbol | undefined {
        return isStringLiteralLike(moduleReferenceExpression)
            ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, !ignoreErrors ? moduleReferenceExpression : undefined, isForAugmentation)
            : undefined;
    }

    function resolveExternalModule(location: Node, moduleReference: string, moduleNotFoundError: DiagnosticMessage | undefined, errorNode: Node | undefined, isForAugmentation = false): Symbol | undefined {
        if (errorNode && startsWith(moduleReference, "@types/")) {
            const diag = Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
            const withoutAtTypePrefix = removePrefix(moduleReference, "@types/");
            error(errorNode, diag, withoutAtTypePrefix, moduleReference);
        }

        const ambientModule = tryFindAmbientModule(moduleReference, /*withAugmentations*/ true);
        if (ambientModule) {
            return ambientModule;
        }
        const currentSourceFile = getSourceFileOfNode(location);
        const contextSpecifier = isStringLiteralLike(location)
            ? location
            : (isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)?.name ||
                (isLiteralImportTypeNode(location) ? location : undefined)?.argument.literal ||
                (isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer, /*requireStringLiteralLikeArgument*/ true) ? location.initializer.arguments[0] : undefined) ||
                findAncestor(location, isImportCall)?.arguments[0] ||
                findAncestor(location, or(isImportDeclaration, isJSDocImportTag, isExportDeclaration))?.moduleSpecifier ||
                findAncestor(location, isExternalModuleImportEqualsDeclaration)?.moduleReference.expression;
        const mode = contextSpecifier && isStringLiteralLike(contextSpecifier)
            ? host.getModeForUsageLocation(currentSourceFile, contextSpecifier)
            : host.getDefaultResolutionModeForFile(currentSourceFile);
        const moduleResolutionKind = getEmitModuleResolutionKind(compilerOptions);
        const resolvedModule = host.getResolvedModule(currentSourceFile, moduleReference, mode)?.resolvedModule;
        const resolutionDiagnostic = errorNode && resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile);
        const sourceFile = resolvedModule
            && (!resolutionDiagnostic || resolutionDiagnostic === Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set)
            && host.getSourceFile(resolvedModule.resolvedFileName);
        if (sourceFile) {
            // If there's a resolutionDiagnostic we need to report it even if a sourceFile is found.
            if (resolutionDiagnostic) {
                error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
            }

            if (resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference)) {
                const importOrExport = findAncestor(location, isImportDeclaration)?.importClause ||
                    findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration));
                if (errorNode && importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall)) {
                    error(
                        errorNode,
                        Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead,
                        getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))),
                    );
                }
            }
            else if (resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(compilerOptions, currentSourceFile.fileName)) {
                const importOrExport = findAncestor(location, isImportDeclaration)?.importClause ||
                    findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration));
                if (errorNode && !(importOrExport?.isTypeOnly || findAncestor(location, isImportTypeNode))) {
                    const tsExtension = Debug.checkDefined(tryExtractTSExtension(moduleReference));
                    error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension);
                }
            }
            else if (
                compilerOptions.rewriteRelativeImportExtensions
                && !(location.flags & NodeFlags.Ambient)
                && !isDeclarationFileName(moduleReference)
                && !isLiteralImportTypeNode(location)
                && !isPartOfTypeOnlyImportOrExportDeclaration(location)
            ) {
                const shouldRewrite = shouldRewriteModuleSpecifier(moduleReference, compilerOptions);
                if (!resolvedModule.resolvedUsingTsExtension && shouldRewrite) {
                    error(
                        errorNode,
                        Diagnostics.This_relative_import_path_is_unsafe_to_rewrite_because_it_looks_like_a_file_name_but_actually_resolves_to_0,
                        getRelativePathFromFile(getNormalizedAbsolutePath(currentSourceFile.fileName, host.getCurrentDirectory()), resolvedModule.resolvedFileName, hostGetCanonicalFileName(host)),
                    );
                }
                else if (resolvedModule.resolvedUsingTsExtension && !shouldRewrite && sourceFileMayBeEmitted(sourceFile, host)) {
                    error(
                        errorNode,
                        Diagnostics.This_import_uses_a_0_extension_to_resolve_to_an_input_TypeScript_file_but_will_not_be_rewritten_during_emit_because_it_is_not_a_relative_path,
                        getAnyExtensionFromPath(moduleReference),
                    );
                }
                else if (resolvedModule.resolvedUsingTsExtension && shouldRewrite) {
                    const redirect = host.getRedirectFromSourceFile(sourceFile.path)?.resolvedRef;
                    if (redirect) {
                        const ignoreCase = !host.useCaseSensitiveFileNames();
                        const ownRootDir = host.getCommonSourceDirectory();
                        const otherRootDir = getCommonSourceDirectoryOfConfig(redirect.commandLine, ignoreCase);
                        const rootDirPath = getRelativePathFromDirectory(ownRootDir, otherRootDir, ignoreCase);
                        const outDirPath = getRelativePathFromDirectory(compilerOptions.outDir || ownRootDir, redirect.commandLine.options.outDir || otherRootDir, ignoreCase);
                        if (rootDirPath !== outDirPath) {
                            error(
                                errorNode,
                                Diagnostics.This_import_path_is_unsafe_to_rewrite_because_it_resolves_to_another_project_and_the_relative_path_between_the_projects_output_files_is_not_the_same_as_the_relative_path_between_its_input_files,
                            );
                        }
                    }
                }
            }

            if (sourceFile.symbol) {
                if (errorNode && resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension)) {
                    errorOnImplicitAnyModule(/*isError*/ false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference);
                }
                if (errorNode && (moduleKind === ModuleKind.Node16 || moduleKind === ModuleKind.Node18)) {
                    const isSyncImport = (currentSourceFile.impliedNodeFormat === ModuleKind.CommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration);
                    const overrideHost = findAncestor(location, l => isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l));
                    // An override clause will take effect for type-only imports and import types, and allows importing the types across formats, regardless of
                    // normal mode restrictions
                    if (isSyncImport && sourceFile.impliedNodeFormat === ModuleKind.ESNext && !hasResolutionModeOverride(overrideHost)) {
                        if (findAncestor(location, isImportEqualsDeclaration)) {
                            // ImportEquals in a ESM file resolving to another ESM file
                            error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference);
                        }
                        else {
                            // CJS file resolving to an ESM file
                            let diagnosticDetails;
                            const ext = tryGetExtensionFromPath(currentSourceFile.fileName);
                            if (ext === Extension.Ts || ext === Extension.Js || ext === Extension.Tsx || ext === Extension.Jsx) {
                                diagnosticDetails = createModeMismatchDetails(currentSourceFile);
                            }

                            const message = overrideHost?.kind === SyntaxKind.ImportDeclaration && overrideHost.importClause?.isTypeOnly ? Diagnostics.Type_only_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute :
                                overrideHost?.kind === SyntaxKind.ImportType ? Diagnostics.Type_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute :
                                Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead;
                            diagnostics.add(createDiagnosticForNodeFromMessageChain(
                                getSourceFileOfNode(errorNode),
                                errorNode,
                                chainDiagnosticMessages(diagnosticDetails, message, moduleReference),
                            ));
                        }
                    }
                }
                // merged symbol is module declaration symbol combined with all augmentations
                return getMergedSymbol(sourceFile.symbol);
            }
            if (errorNode && moduleNotFoundError && !isSideEffectImport(errorNode)) {
                // report errors only if it was requested
                error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName);
            }
            return undefined;
        }

        if (patternAmbientModules) {
            const pattern = findBestPatternMatch(patternAmbientModules, _ => _.pattern, moduleReference);
            if (pattern) {
                // If the module reference matched a pattern ambient module ('*.foo') but there's also a
                // module augmentation by the specific name requested ('a.foo'), we store the merged symbol
                // by the augmentation name ('a.foo'), because asking for *.foo should not give you exports
                // from a.foo.
                const augmentation = patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference);
                if (augmentation) {
                    return getMergedSymbol(augmentation);
                }
                return getMergedSymbol(pattern.symbol);
            }
        }

        if (!errorNode) {
            return undefined;
        }

        // May be an untyped module. If so, ignore resolutionDiagnostic.
        if (resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic === undefined || resolutionDiagnostic === Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type) {
            if (isForAugmentation) {
                const diag = Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented;
                error(errorNode, diag, moduleReference, resolvedModule!.resolvedFileName);
            }
            else {
                errorOnImplicitAnyModule(/*isError*/ noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode, resolvedModule!, moduleReference);
            }
            // Failed imports and untyped modules are both treated in an untyped manner; only difference is whether we give a diagnostic first.
            return undefined;
        }

        if (moduleNotFoundError) {
            // See if this was possibly a projectReference redirect
            if (resolvedModule) {
                const redirect = host.getRedirectFromSourceFile(resolvedModule.resolvedFileName);
                if (redirect?.outputDts) {
                    error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect.outputDts, resolvedModule.resolvedFileName);
                    return undefined;
                }
            }

            if (resolutionDiagnostic) {
                error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
            }
            else {
                const isExtensionlessRelativePathImport = pathIsRelative(moduleReference) && !hasExtension(moduleReference);
                const resolutionIsNode16OrNext = moduleResolutionKind === ModuleResolutionKind.Node16 ||
                    moduleResolutionKind === ModuleResolutionKind.NodeNext;
                if (
                    !getResolveJsonModule(compilerOptions) &&
                    fileExtensionIs(moduleReference, Extension.Json) &&
                    moduleResolutionKind !== ModuleResolutionKind.Classic &&
                    hasJsonModuleEmitEnabled(compilerOptions)
                ) {
                    error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference);
                }
                else if (mode === ModuleKind.ESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport) {
                    const absoluteRef = getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path));
                    const suggestedExt = suggestedExtensions.find(([actualExt, _importExt]) => host.fileExists(absoluteRef + actualExt))?.[1];
                    if (suggestedExt) {
                        error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference + suggestedExt);
                    }
                    else {
                        error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path);
                    }
                }
                else {
                    if (host.getResolvedModule(currentSourceFile, moduleReference, mode)?.alternateResult) {
                        const errorInfo = createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference);
                        errorOrSuggestion(/*isError*/ true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference));
                    }
                    else {
                        error(errorNode, moduleNotFoundError, moduleReference);
                    }
                }
            }
        }
        return undefined;

        function getSuggestedImportSource(tsExtension: string) {
            const importSourceWithoutExtension = removeExtension(moduleReference, tsExtension);
            /**
             * Direct users to import source with .js extension if outputting an ES module.
             * @see https://github.com/microsoft/TypeScript/issues/42151
             */
            if (emitModuleKindIsNonNodeESM(moduleKind) || mode === ModuleKind.ESNext) {
                const preferTs = isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions);
                const ext = tsExtension === Extension.Mts || tsExtension === Extension.Dmts ? preferTs ? ".mts" : ".mjs" :
                    tsExtension === Extension.Cts || tsExtension === Extension.Dmts ? preferTs ? ".cts" : ".cjs" :
                    preferTs ? ".ts" : ".js";
                return importSourceWithoutExtension + ext;
            }
            return importSourceWithoutExtension;
        }
    }

    function errorOnImplicitAnyModule(isError: boolean, errorNode: Node, sourceFile: SourceFile, mode: ResolutionMode, { packageId, resolvedFileName }: ResolvedModuleFull, moduleReference: string): void {
        if (isSideEffectImport(errorNode)) {
            return;
        }

        let errorInfo: DiagnosticMessageChain | undefined;
        if (!isExternalModuleNameRelative(moduleReference) && packageId) {
            errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name);
        }
        errorOrSuggestion(
            isError,
            errorNode,
            chainDiagnosticMessages(
                errorInfo,
                Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type,
                moduleReference,
                resolvedFileName,
            ),
        );
    }

    function resolveExternalModuleSymbol(moduleSymbol: Symbol, dontResolveAlias?: boolean): Symbol;
    function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined;
    function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined {
        if (moduleSymbol?.exports) {
            const exportEquals = resolveSymbol(moduleSymbol.exports.get(InternalSymbolName.ExportEquals), dontResolveAlias);
            const exported = getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol));
            return getMergedSymbol(exported) || moduleSymbol;
        }
        return undefined;
    }

    function getCommonJsExportEquals(exported: Symbol | undefined, moduleSymbol: Symbol): Symbol | undefined {
        if (!exported || exported === unknownSymbol || exported === moduleSymbol || moduleSymbol.exports!.size === 1 || exported.flags & SymbolFlags.Alias) {
            return exported;
        }
        const links = getSymbolLinks(exported);
        if (links.cjsExportMerged) {
            return links.cjsExportMerged;
        }
        const merged = exported.flags & SymbolFlags.Transient ? exported : cloneSymbol(exported);
        merged.flags = merged.flags | SymbolFlags.ValueModule;
        if (merged.exports === undefined) {
            merged.exports = createSymbolTable();
        }
        moduleSymbol.exports!.forEach((s, name) => {
            if (name === InternalSymbolName.ExportEquals) return;
            merged.exports!.set(name, merged.exports!.has(name) ? mergeSymbol(merged.exports!.get(name)!, s) : s);
        });
        if (merged === exported) {
            // We just mutated a symbol, reset any cached links we may have already set
            // (Notably required to make late bound members appear)
            getSymbolLinks(merged).resolvedExports = undefined;
            getSymbolLinks(merged).resolvedMembers = undefined;
        }
        getSymbolLinks(merged).cjsExportMerged = merged;
        return links.cjsExportMerged = merged;
    }

    // An external module with an 'export =' declaration may be referenced as an ES6 module provided the 'export ='
    // references a symbol that is at least declared as a module or a variable. The target of the 'export =' may
    // combine other declarations with the module or variable (e.g. a class/module, function/module, interface/variable).
    function resolveESModuleSymbol(moduleSymbol: Symbol | undefined, referencingLocation: Node, dontResolveAlias: boolean, suppressInteropError: boolean): Symbol | undefined {
        const symbol = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias);

        if (!dontResolveAlias && symbol) {
            if (!suppressInteropError && !(symbol.flags & (SymbolFlags.Module | SymbolFlags.Variable)) && !getDeclarationOfKind(symbol, SyntaxKind.SourceFile)) {
                const compilerOptionName = moduleKind >= ModuleKind.ES2015
                    ? "allowSyntheticDefaultImports"
                    : "esModuleInterop";

                error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName);

                return symbol;
            }

            const referenceParent = referencingLocation.parent;
            const namespaceImport = isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent);
            if (namespaceImport || isImportCall(referenceParent)) {
                const reference = isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier;
                const type = getTypeOfSymbol(symbol);
                const defaultOnlyType = getTypeWithSyntheticDefaultOnly(type, symbol, moduleSymbol!, reference);
                if (defaultOnlyType) {
                    return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent);
                }

                const targetFile = moduleSymbol?.declarations?.find(isSourceFile);
                const usageMode = getEmitSyntaxForModuleSpecifierExpression(reference);
                let exportModuleDotExportsSymbol: Symbol | undefined;
                if (
                    namespaceImport && targetFile &&
                    ModuleKind.Node20 <= moduleKind && moduleKind <= ModuleKind.NodeNext &&
                    usageMode === ModuleKind.CommonJS && host.getImpliedNodeFormatForEmit(targetFile) === ModuleKind.ESNext &&
                    (exportModuleDotExportsSymbol = resolveExportByName(symbol, "module.exports" as __String, namespaceImport, dontResolveAlias))
                ) {
                    if (!suppressInteropError && !(symbol.flags & (SymbolFlags.Module | SymbolFlags.Variable))) {
                        error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, "esModuleInterop");
                    }
                    if (getESModuleInterop(compilerOptions) && hasSignatures(type)) {
                        return cloneTypeAsModuleType(exportModuleDotExportsSymbol, type, referenceParent);
                    }
                    return exportModuleDotExportsSymbol;
                }

                const isEsmCjsRef = targetFile && isESMFormatImportImportingCommonjsFormatFile(usageMode, host.getImpliedNodeFormatForEmit(targetFile));
                if (getESModuleInterop(compilerOptions) || isEsmCjsRef) {
                    if (
                        hasSignatures(type) ||
                        getPropertyOfType(type, InternalSymbolName.Default, /*skipObjectFunctionPropertyAugment*/ true) ||
                        isEsmCjsRef
                    ) {
                        const moduleType = type.flags & TypeFlags.StructuredType
                            ? getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol!, reference)
                            : createDefaultPropertyWrapperForModule(symbol, symbol.parent);
                        return cloneTypeAsModuleType(symbol, moduleType, referenceParent);
                    }
                }
            }
        }
        return symbol;
    }

    function hasSignatures(type: Type): boolean {
        return some(getSignaturesOfStructuredType(type, SignatureKind.Call)) || some(getSignaturesOfStructuredType(type, SignatureKind.Construct));
    }

    /**
     * Create a new symbol which has the module's type less the call and construct signatures
     */
    function cloneTypeAsModuleType(symbol: Symbol, moduleType: Type, referenceParent: ImportDeclaration | ImportCall) {
        const result = createSymbol(symbol.flags, symbol.escapedName);
        result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
        result.parent = symbol.parent;
        result.links.target = symbol;
        result.links.originatingImport = referenceParent;
        if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
        if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
        if (symbol.members) result.members = new Map(symbol.members);
        if (symbol.exports) result.exports = new Map(symbol.exports);
        const resolvedModuleType = resolveStructuredTypeMembers(moduleType as StructuredType); // Should already be resolved from the signature checks above
        result.links.type = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos);
        return result;
    }

    function hasExportAssignmentSymbol(moduleSymbol: Symbol): boolean {
        return moduleSymbol.exports!.get(InternalSymbolName.ExportEquals) !== undefined;
    }

    function getExportsOfModuleAsArray(moduleSymbol: Symbol): Symbol[] {
        return symbolsToArray(getExportsOfModule(moduleSymbol));
    }

    function getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[] {
        const exports = getExportsOfModuleAsArray(moduleSymbol);
        const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol) {
            const type = getTypeOfSymbol(exportEquals);
            if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                addRange(exports, getPropertiesOfType(type));
            }
        }
        return exports;
    }

    function forEachExportAndPropertyOfModule(moduleSymbol: Symbol, cb: (symbol: Symbol, key: __String) => void): void {
        const exports = getExportsOfModule(moduleSymbol);
        exports.forEach((symbol, key) => {
            if (!isReservedMemberName(key)) {
                cb(symbol, key);
            }
        });
        const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol) {
            const type = getTypeOfSymbol(exportEquals);
            if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                forEachPropertyOfType(type, (symbol, escapedName) => {
                    cb(symbol, escapedName);
                });
            }
        }
    }

    function tryGetMemberInModuleExports(memberName: __String, moduleSymbol: Symbol): Symbol | undefined {
        const symbolTable = getExportsOfModule(moduleSymbol);
        if (symbolTable) {
            return symbolTable.get(memberName);
        }
    }

    function tryGetMemberInModuleExportsAndProperties(memberName: __String, moduleSymbol: Symbol): Symbol | undefined {
        const symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (symbol) {
            return symbol;
        }

        const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals === moduleSymbol) {
            return undefined;
        }

        const type = getTypeOfSymbol(exportEquals);
        return shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined;
    }

    function shouldTreatPropertiesOfExternalModuleAsExports(resolvedExternalModuleType: Type) {
        return !(resolvedExternalModuleType.flags & TypeFlags.Primitive ||
            getObjectFlags(resolvedExternalModuleType) & ObjectFlags.Class ||
            // `isArrayOrTupleLikeType` is too expensive to use in this auto-imports hot path
            isArrayType(resolvedExternalModuleType) ||
            isTupleType(resolvedExternalModuleType));
    }

    function getExportsOfSymbol(symbol: Symbol): SymbolTable {
        return symbol.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedExports) :
            symbol.flags & SymbolFlags.Module ? getExportsOfModule(symbol) :
            symbol.exports || emptySymbols;
    }

    function getExportsOfModule(moduleSymbol: Symbol): SymbolTable {
        const links = getSymbolLinks(moduleSymbol);
        if (!links.resolvedExports) {
            const { exports, typeOnlyExportStarMap } = getExportsOfModuleWorker(moduleSymbol);
            links.resolvedExports = exports;
            links.typeOnlyExportStarMap = typeOnlyExportStarMap;
        }
        return links.resolvedExports;
    }

    interface ExportCollisionTracker {
        specifierText: string;
        exportsWithDuplicate?: ExportDeclaration[];
    }

    type ExportCollisionTrackerTable = Map<__String, ExportCollisionTracker>;

    /**
     * Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument
     * Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables
     */
    function extendExportSymbols(target: SymbolTable, source: SymbolTable | undefined, lookupTable?: ExportCollisionTrackerTable, exportNode?: ExportDeclaration) {
        if (!source) return;
        source.forEach((sourceSymbol, id) => {
            if (id === InternalSymbolName.Default) return;

            const targetSymbol = target.get(id);
            if (!targetSymbol) {
                target.set(id, sourceSymbol);
                if (lookupTable && exportNode) {
                    lookupTable.set(id, {
                        specifierText: getTextOfNode(exportNode.moduleSpecifier!),
                    });
                }
            }
            else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {
                const collisionTracker = lookupTable.get(id)!;
                if (!collisionTracker.exportsWithDuplicate) {
                    collisionTracker.exportsWithDuplicate = [exportNode];
                }
                else {
                    collisionTracker.exportsWithDuplicate.push(exportNode);
                }
            }
        });
    }

    function getExportsOfModuleWorker(moduleSymbol: Symbol) {
        const visitedSymbols: Symbol[] = [];
        let typeOnlyExportStarMap: Map<__String, ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; }> | undefined;
        const nonTypeOnlyNames = new Set<__String>();

        // A module defined by an 'export=' consists of one export that needs to be resolved
        moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
        const exports = visit(moduleSymbol) || emptySymbols;

        if (typeOnlyExportStarMap) {
            nonTypeOnlyNames.forEach(name => typeOnlyExportStarMap!.delete(name));
        }

        return {
            exports,
            typeOnlyExportStarMap,
        };

        // The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
        // module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
        function visit(symbol: Symbol | undefined, exportStar?: ExportDeclaration, isTypeOnly?: boolean): SymbolTable | undefined {
            if (!isTypeOnly && symbol?.exports) {
                // Add non-type-only names before checking if we've visited this module,
                // because we might have visited it via an 'export type *', and visiting
                // again with 'export *' will override the type-onlyness of its exports.
                symbol.exports.forEach((_, name) => nonTypeOnlyNames.add(name));
            }
            if (!(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol))) {
                return;
            }
            const symbols = new Map(symbol.exports);

            // All export * declarations are collected in an __export symbol by the binder
            const exportStars = symbol.exports.get(InternalSymbolName.ExportStar);
            if (exportStars) {
                const nestedSymbols = createSymbolTable();
                const lookupTable: ExportCollisionTrackerTable = new Map();
                if (exportStars.declarations) {
                    for (const node of exportStars.declarations) {
                        const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!);
                        const exportedSymbols = visit(resolvedModule, node as ExportDeclaration, isTypeOnly || (node as ExportDeclaration).isTypeOnly);
                        extendExportSymbols(
                            nestedSymbols,
                            exportedSymbols,
                            lookupTable,
                            node as ExportDeclaration,
                        );
                    }
                }
                lookupTable.forEach(({ exportsWithDuplicate }, id) => {
                    // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
                    if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {
                        return;
                    }
                    for (const node of exportsWithDuplicate) {
                        diagnostics.add(createDiagnosticForNode(
                            node,
                            Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,
                            lookupTable.get(id)!.specifierText,
                            unescapeLeadingUnderscores(id),
                        ));
                    }
                });
                extendExportSymbols(symbols, nestedSymbols);
            }
            if (exportStar?.isTypeOnly) {
                typeOnlyExportStarMap ??= new Map();
                symbols.forEach((_, escapedName) =>
                    typeOnlyExportStarMap!.set(
                        escapedName,
                        exportStar as ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; },
                    )
                );
            }
            return symbols;
        }
    }

    function getMergedSymbol(symbol: Symbol): Symbol;
    function getMergedSymbol(symbol: Symbol | undefined): Symbol | undefined;
    function getMergedSymbol(symbol: Symbol | undefined): Symbol | undefined {
        let merged: Symbol;
        return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
    }

    function getSymbolOfDeclaration(node: Declaration): Symbol {
        return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol));
    }

    /**
     * Get the merged symbol for a node. If you know the node is a `Declaration`, it is faster and more type safe to
     * use use `getSymbolOfDeclaration` instead.
     */
    function getSymbolOfNode(node: Node): Symbol | undefined {
        return canHaveSymbol(node) ? getSymbolOfDeclaration(node) : undefined;
    }

    function getParentOfSymbol(symbol: Symbol): Symbol | undefined {
        return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent));
    }

    function getFunctionExpressionParentSymbolOrSymbol(symbol: Symbol) {
        return symbol.valueDeclaration?.kind === SyntaxKind.ArrowFunction || symbol.valueDeclaration?.kind === SyntaxKind.FunctionExpression
            ? getSymbolOfNode(symbol.valueDeclaration.parent) || symbol
            : symbol;
    }

    function getAlternativeContainingModules(symbol: Symbol, enclosingDeclaration: Node): Symbol[] {
        const containingFile = getSourceFileOfNode(enclosingDeclaration);
        const id = getNodeId(containingFile);
        const links = getSymbolLinks(symbol);
        let results: Symbol[] | undefined;
        if (links.extendedContainersByFile && (results = links.extendedContainersByFile.get(id))) {
            return results;
        }
        if (containingFile && containingFile.imports) {
            // Try to make an import using an import already in the enclosing file, if possible
            for (const importRef of containingFile.imports) {
                if (nodeIsSynthesized(importRef)) continue; // Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
                const resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, /*ignoreErrors*/ true);
                if (!resolvedModule) continue;
                const ref = getAliasForSymbolInContainer(resolvedModule, symbol);
                if (!ref) continue;
                results = append(results, resolvedModule);
            }
            if (length(results)) {
                (links.extendedContainersByFile || (links.extendedContainersByFile = new Map())).set(id, results!);
                return results!;
            }
        }
        if (links.extendedContainers) {
            return links.extendedContainers;
        }
        // No results from files already being imported by this file - expand search (expensive, but not location-specific, so cached)
        const otherFiles = host.getSourceFiles();
        for (const file of otherFiles) {
            if (!isExternalModule(file)) continue;
            const sym = getSymbolOfDeclaration(file);
            const ref = getAliasForSymbolInContainer(sym, symbol);
            if (!ref) continue;
            results = append(results, sym);
        }
        return links.extendedContainers = results || emptyArray;
    }

    /**
     * Attempts to find the symbol corresponding to the container a symbol is in - usually this
     * is just its' `.parent`, but for locals, this value is `undefined`
     */
    function getContainersOfSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): Symbol[] | undefined {
        const container = getParentOfSymbol(symbol);
        // Type parameters end up in the `members` lists but are not externally visible
        if (container && !(symbol.flags & SymbolFlags.TypeParameter)) {
            return getWithAlternativeContainers(container);
        }
        const candidates = mapDefined(symbol.declarations, d => {
            if (!isAmbientModule(d) && d.parent) {
                // direct children of a module
                if (hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) {
                    return getSymbolOfDeclaration(d.parent as Declaration);
                }
                // export ='d member of an ambient module
                if (isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) === symbol) {
                    return getSymbolOfDeclaration(d.parent.parent);
                }
            }
            if (isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind === SyntaxKind.EqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression)) {
                if (isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression)) {
                    return getSymbolOfDeclaration(getSourceFileOfNode(d));
                }
                checkExpressionCached(d.parent.left.expression);
                return getNodeLinks(d.parent.left.expression).resolvedSymbol;
            }
        });
        if (!length(candidates)) {
            return undefined;
        }
        const containers = mapDefined(candidates, candidate => getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined);

        let bestContainers: Symbol[] = [];
        let alternativeContainers: Symbol[] = [];

        for (const container of containers) {
            const [bestMatch, ...rest] = getWithAlternativeContainers(container);
            bestContainers = append(bestContainers, bestMatch);
            alternativeContainers = addRange(alternativeContainers, rest);
        }

        return concatenate(bestContainers, alternativeContainers);

        function getWithAlternativeContainers(container: Symbol) {
            const additionalContainers = mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer);
            const reexportContainers = enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration);
            const objectLiteralContainer = getVariableDeclarationOfObjectLiteral(container, meaning);
            if (
                enclosingDeclaration &&
                container.flags & getQualifiedLeftMeaning(meaning) &&
                getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlags.Namespace, /*useOnlyExternalAliasing*/ false)
            ) {
                return append(concatenate(concatenate([container], additionalContainers), reexportContainers), objectLiteralContainer); // This order expresses a preference for the real container if it is in scope
            }
            // we potentially have a symbol which is a member of the instance side of something - look for a variable in scope with the container's type
            // which may be acting like a namespace (eg, `Symbol` acts like a namespace when looking up `Symbol.toStringTag`)
            const firstVariableMatch = !(container.flags & getQualifiedLeftMeaning(meaning))
                    && container.flags & SymbolFlags.Type
                    && getDeclaredTypeOfSymbol(container).flags & TypeFlags.Object
                    && meaning === SymbolFlags.Value
                ? forEachSymbolTableInScope(enclosingDeclaration, t => {
                    return forEachEntry(t, s => {
                        if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {
                            return s;
                        }
                    });
                }) : undefined;
            let res = firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container];
            res = append(res, objectLiteralContainer);
            res = addRange(res, reexportContainers);
            return res;
        }

        function fileSymbolIfFileSymbolExportEqualsContainer(d: Declaration) {
            return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container);
        }
    }

    function getVariableDeclarationOfObjectLiteral(symbol: Symbol, meaning: SymbolFlags) {
        // If we're trying to reference some object literal in, eg `var a = { x: 1 }`, the symbol for the literal, `__object`, is distinct
        // from the symbol of the declaration it is being assigned to. Since we can use the declaration to refer to the literal, however,
        // we'd like to make that connection here - potentially causing us to paint the declaration's visibility, and therefore the literal.
        const firstDecl: Node | false = !!length(symbol.declarations) && first(symbol.declarations!);
        if (meaning & SymbolFlags.Value && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent)) {
            if (isObjectLiteralExpression(firstDecl) && firstDecl === firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl === firstDecl.parent.type) {
                return getSymbolOfDeclaration(firstDecl.parent);
            }
        }
    }

    function getFileSymbolIfFileSymbolExportEqualsContainer(d: Declaration, container: Symbol) {
        const fileSymbol = getExternalModuleContainer(d);
        const exported = fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolName.ExportEquals);
        return exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined;
    }

    function getAliasForSymbolInContainer(container: Symbol, symbol: Symbol) {
        if (container === getParentOfSymbol(symbol)) {
            // fast path, `symbol` is either already the alias or isn't aliased
            return symbol;
        }
        // Check if container is a thing with an `export=` which points directly at `symbol`, and if so, return
        // the container itself as the alias for the symbol
        const exportEquals = container.exports && container.exports.get(InternalSymbolName.ExportEquals);
        if (exportEquals && getSymbolIfSameReference(exportEquals, symbol)) {
            return container;
        }
        const exports = getExportsOfSymbol(container);
        const quick = exports.get(symbol.escapedName);
        if (quick && getSymbolIfSameReference(quick, symbol)) {
            return quick;
        }
        return forEachEntry(exports, exported => {
            if (getSymbolIfSameReference(exported, symbol)) {
                return exported;
            }
        });
    }

    /**
     * Checks if two symbols, through aliasing and/or merging, refer to the same thing
     */
    function getSymbolIfSameReference(s1: Symbol, s2: Symbol) {
        if (getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) === getMergedSymbol(resolveSymbol(getMergedSymbol(s2)))) {
            return s1;
        }
    }

    function getExportSymbolOfValueSymbolIfExported(symbol: Symbol): Symbol;
    function getExportSymbolOfValueSymbolIfExported(symbol: Symbol | undefined): Symbol | undefined;
    function getExportSymbolOfValueSymbolIfExported(symbol: Symbol | undefined): Symbol | undefined {
        return getMergedSymbol(symbol && (symbol.flags & SymbolFlags.ExportValue) !== 0 && symbol.exportSymbol || symbol);
    }

    function symbolIsValue(symbol: Symbol, includeTypeOnlyMembers?: boolean): boolean {
        return !!(
            symbol.flags & SymbolFlags.Value ||
            symbol.flags & SymbolFlags.Alias && getSymbolFlags(symbol, !includeTypeOnlyMembers) & SymbolFlags.Value
        );
    }

    function createType(flags: TypeFlags): Type {
        const result = new Type(checker, flags);
        typeCount++;
        result.id = typeCount;
        tracing?.recordType(result);
        return result;
    }

    function createTypeWithSymbol(flags: TypeFlags, symbol: Symbol): Type {
        const result = createType(flags);
        result.symbol = symbol;
        return result;
    }

    function createOriginType(flags: TypeFlags): Type {
        return new Type(checker, flags);
    }

    function createIntrinsicType(kind: TypeFlags, intrinsicName: string, objectFlags = ObjectFlags.None, debugIntrinsicName?: string): IntrinsicType {
        checkIntrinsicName(intrinsicName, debugIntrinsicName);
        const type = createType(kind) as IntrinsicType;
        type.intrinsicName = intrinsicName;
        type.debugIntrinsicName = debugIntrinsicName;
        type.objectFlags = objectFlags | ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.IsGenericTypeComputed | ObjectFlags.IsUnknownLikeUnionComputed | ObjectFlags.IsNeverIntersectionComputed;
        return type;
    }

    function checkIntrinsicName(name: string, debug: string | undefined) {
        const key = `${name},${debug ?? ""}`;
        if (seenIntrinsicNames.has(key)) {
            Debug.fail(`Duplicate intrinsic type name ${name}${debug ? ` (${debug})` : ""}; you may need to pass a name to createIntrinsicType.`);
        }
        seenIntrinsicNames.add(key);
    }

    function createObjectType(objectFlags: ObjectFlags, symbol?: Symbol): ObjectType {
        const type = createTypeWithSymbol(TypeFlags.Object, symbol!) as ObjectType;
        type.objectFlags = objectFlags;
        type.members = undefined;
        type.properties = undefined;
        type.callSignatures = undefined;
        type.constructSignatures = undefined;
        type.indexInfos = undefined;
        return type;
    }

    function createTypeofType() {
        return getUnionType(arrayFrom(typeofNEFacts.keys(), getStringLiteralType));
    }

    function createTypeParameter(symbol?: Symbol) {
        return createTypeWithSymbol(TypeFlags.TypeParameter, symbol!) as TypeParameter;
    }

    // A reserved member name starts with two underscores, but the third character cannot be an underscore,
    // @, or #. A third underscore indicates an escaped form of an identifier that started
    // with at least two underscores. The @ character indicates that the name is denoted by a well known ES
    // Symbol instance and the # character indicates that the name is a PrivateIdentifier.
    function isReservedMemberName(name: __String) {
        return (name as string).charCodeAt(0) === CharacterCodes._ &&
            (name as string).charCodeAt(1) === CharacterCodes._ &&
            (name as string).charCodeAt(2) !== CharacterCodes._ &&
            (name as string).charCodeAt(2) !== CharacterCodes.at &&
            (name as string).charCodeAt(2) !== CharacterCodes.hash;
    }

    function getNamedMembers(members: SymbolTable): Symbol[] {
        let result: Symbol[] | undefined;
        members.forEach((symbol, id) => {
            if (isNamedMember(symbol, id)) {
                (result || (result = [])).push(symbol);
            }
        });
        return result || emptyArray;
    }

    function isNamedMember(member: Symbol, escapedName: __String) {
        return !isReservedMemberName(escapedName) && symbolIsValue(member);
    }

    function getNamedOrIndexSignatureMembers(members: SymbolTable): Symbol[] {
        const result = getNamedMembers(members);
        const index = getIndexSymbolFromSymbolTable(members);
        return index ? concatenate(result, [index]) : result;
    }

    function setStructuredTypeMembers(type: StructuredType, members: SymbolTable, callSignatures: readonly Signature[], constructSignatures: readonly Signature[], indexInfos: readonly IndexInfo[]): ResolvedType {
        const resolved = type as ResolvedType;
        resolved.members = members;
        resolved.properties = emptyArray;
        resolved.callSignatures = callSignatures;
        resolved.constructSignatures = constructSignatures;
        resolved.indexInfos = indexInfos;
        // This can loop back to getPropertyOfType() which would crash if `callSignatures` & `constructSignatures` are not initialized.
        if (members !== emptySymbols) resolved.properties = getNamedMembers(members);
        return resolved;
    }

    function createAnonymousType(symbol: Symbol | undefined, members: SymbolTable, callSignatures: readonly Signature[], constructSignatures: readonly Signature[], indexInfos: readonly IndexInfo[]): ResolvedType {
        return setStructuredTypeMembers(createObjectType(ObjectFlags.Anonymous, symbol), members, callSignatures, constructSignatures, indexInfos);
    }

    function getResolvedTypeWithoutAbstractConstructSignatures(type: ResolvedType) {
        if (type.constructSignatures.length === 0) return type;
        if (type.objectTypeWithoutAbstractConstructSignatures) return type.objectTypeWithoutAbstractConstructSignatures;
        const constructSignatures = filter(type.constructSignatures, signature => !(signature.flags & SignatureFlags.Abstract));
        if (type.constructSignatures === constructSignatures) return type;
        const typeCopy = createAnonymousType(
            type.symbol,
            type.members,
            type.callSignatures,
            some(constructSignatures) ? constructSignatures : emptyArray,
            type.indexInfos,
        );
        type.objectTypeWithoutAbstractConstructSignatures = typeCopy;
        typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy;
        return typeCopy;
    }

    function forEachSymbolTableInScope<T>(enclosingDeclaration: Node | undefined, callback: (symbolTable: SymbolTable, ignoreQualification?: boolean, isLocalNameLookup?: boolean, scopeNode?: Node) => T): T {
        let result: T;
        for (let location = enclosingDeclaration; location; location = location.parent) {
            // Locals of a source file are not in scope (because they get merged into the global symbol table)
            if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {
                if (result = callback(location.locals, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ true, location)) {
                    return result;
                }
            }
            switch (location.kind) {
                case SyntaxKind.SourceFile:
                    if (!isExternalOrCommonJsModule(location as SourceFile)) {
                        break;
                    }
                    // falls through
                case SyntaxKind.ModuleDeclaration:
                    const sym = getSymbolOfDeclaration(location as ModuleDeclaration);
                    // `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten
                    // into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred
                    // to one another anyway)
                    if (result = callback(sym?.exports || emptySymbols, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ true, location)) {
                        return result;
                    }
                    break;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.InterfaceDeclaration:
                    // Type parameters are bound into `members` lists so they can merge across declarations
                    // This is troublesome, since in all other respects, they behave like locals :cries:
                    // TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol
                    // lookup logic in terms of `resolveName` would be nice
                    // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals
                    // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would
                    // trigger resolving late-bound names, which we may already be in the process of doing while we're here!
                    let table: Map<__String, Symbol> | undefined;
                    // TODO: Should this filtered table be cached in some way?
                    (getSymbolOfDeclaration(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols).forEach((memberSymbol, key) => {
                        if (memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)) {
                            (table || (table = createSymbolTable())).set(key, memberSymbol);
                        }
                    });
                    if (table && (result = callback(table, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ false, location))) {
                        return result;
                    }
                    break;
            }
        }

        return callback(globals, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ true);
    }

    function getQualifiedLeftMeaning(rightMeaning: SymbolFlags) {
        // If we are looking in value space, the parent meaning is value, other wise it is namespace
        return rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace;
    }

    function getAccessibleSymbolChain(symbol: Symbol | undefined, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, useOnlyExternalAliasing: boolean, visitedSymbolTablesMap = new Map<SymbolId, SymbolTable[]>()): Symbol[] | undefined {
        if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) {
            return undefined;
        }
        const links = getSymbolLinks(symbol);
        const cache = (links.accessibleChainCache ||= new Map());
        // Go from enclosingDeclaration to the first scope we check, so the cache is keyed off the scope and thus shared more
        const firstRelevantLocation = forEachSymbolTableInScope(enclosingDeclaration, (_, __, ___, node) => node);
        const key = `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation ? getNodeId(firstRelevantLocation) : 0}|${meaning}`;
        if (cache.has(key)) {
            return cache.get(key);
        }

        const id = getSymbolId(symbol);
        let visitedSymbolTables = visitedSymbolTablesMap.get(id);
        if (!visitedSymbolTables) {
            visitedSymbolTablesMap.set(id, visitedSymbolTables = []);
        }
        const result = forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
        cache.set(key, result);
        return result;

        /**
         * @param {ignoreQualification} boolean Set when a symbol is being looked for through the exports of another symbol (meaning we have a route to qualify it already)
         */
        function getAccessibleSymbolChainFromSymbolTable(symbols: SymbolTable, ignoreQualification?: boolean, isLocalNameLookup?: boolean): Symbol[] | undefined {
            if (!pushIfUnique(visitedSymbolTables!, symbols)) {
                return undefined;
            }

            const result = trySymbolTable(symbols, ignoreQualification, isLocalNameLookup);
            visitedSymbolTables!.pop();
            return result;
        }

        function canQualifySymbol(symbolFromSymbolTable: Symbol, meaning: SymbolFlags) {
            // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
            return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) ||
                // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap);
        }

        function isAccessible(symbolFromSymbolTable: Symbol, resolvedAliasSymbol?: Symbol, ignoreQualification?: boolean) {
            return (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) &&
                // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                // and if symbolFromSymbolTable or alias resolution matches the symbol,
                // check the symbol can be qualified, it is only then this symbol is accessible
                !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) &&
                (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning));
        }

        function trySymbolTable(symbols: SymbolTable, ignoreQualification: boolean | undefined, isLocalNameLookup: boolean | undefined): Symbol[] | undefined {
            // If symbol is directly available by its name in the symbol table
            if (isAccessible(symbols.get(symbol!.escapedName)!, /*resolvedAliasSymbol*/ undefined, ignoreQualification)) {
                return [symbol!];
            }

            // Check if symbol is any of the aliases in scope
            const result = forEachEntry(symbols, symbolFromSymbolTable => {
                if (
                    symbolFromSymbolTable.flags & SymbolFlags.Alias
                    && symbolFromSymbolTable.escapedName !== InternalSymbolName.ExportEquals
                    && symbolFromSymbolTable.escapedName !== InternalSymbolName.Default
                    && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration)))
                    // If `!useOnlyExternalAliasing`, we can use any type of alias to get the name
                    && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration))
                    // If we're looking up a local name to reference directly, omit namespace reexports, otherwise when we're trawling through an export list to make a dotted name, we can keep it
                    && (isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true)
                    // While exports are generally considered to be in scope, export-specifier declared symbols are _not_
                    // See similar comment in `resolveName` for details
                    && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier))
                ) {
                    const resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);
                    const candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);
                    if (candidate) {
                        return candidate;
                    }
                }
                if (symbolFromSymbolTable.escapedName === symbol!.escapedName && symbolFromSymbolTable.exportSymbol) {
                    if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), /*resolvedAliasSymbol*/ undefined, ignoreQualification)) {
                        return [symbol!];
                    }
                }
            });

            // If there's no result and we're looking at the global symbol table, treat `globalThis` like an alias and try to lookup thru that
            return result || (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined);
        }

        function getCandidateListForSymbol(symbolFromSymbolTable: Symbol, resolvedImportedSymbol: Symbol, ignoreQualification: boolean | undefined) {
            if (isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)) {
                return [symbolFromSymbolTable];
            }

            // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
            // but only if the symbolFromSymbolTable can be qualified
            const candidateTable = getExportsOfSymbol(resolvedImportedSymbol);
            const accessibleSymbolsFromExports = candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, /*ignoreQualification*/ true);
            if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
            }
        }
    }

    function needsQualification(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags) {
        let qualify = false;
        forEachSymbolTableInScope(enclosingDeclaration, symbolTable => {
            // If symbol of this name is not available in the symbol table we are ok
            let symbolFromSymbolTable = getMergedSymbol(symbolTable.get(symbol.escapedName));
            if (!symbolFromSymbolTable) {
                // Continue to the next symbol table
                return false;
            }
            // If the symbol with this name is present it should refer to the symbol
            if (symbolFromSymbolTable === symbol) {
                // No need to qualify
                return true;
            }

            // Qualify if the symbol from symbol table has same meaning as expected
            const shouldResolveAlias = symbolFromSymbolTable.flags & SymbolFlags.Alias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier);
            symbolFromSymbolTable = shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;
            const flags = shouldResolveAlias ? getSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags;
            if (flags & meaning) {
                qualify = true;
                return true;
            }

            // Continue to the next symbol table
            return false;
        });

        return qualify;
    }

    function isPropertyOrMethodDeclarationSymbol(symbol: Symbol) {
        if (symbol.declarations && symbol.declarations.length) {
            for (const declaration of symbol.declarations) {
                switch (declaration.kind) {
                    case SyntaxKind.PropertyDeclaration:
                    case SyntaxKind.MethodDeclaration:
                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                        continue;
                    default:
                        return false;
                }
            }
            return true;
        }
        return false;
    }

    function isTypeSymbolAccessible(typeSymbol: Symbol, enclosingDeclaration: Node | undefined): boolean {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlags.Type, /*shouldComputeAliasesToMakeVisible*/ false, /*allowModules*/ true);
        return access.accessibility === SymbolAccessibility.Accessible;
    }

    function isValueSymbolAccessible(typeSymbol: Symbol, enclosingDeclaration: Node | undefined): boolean {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlags.Value, /*shouldComputeAliasesToMakeVisible*/ false, /*allowModules*/ true);
        return access.accessibility === SymbolAccessibility.Accessible;
    }

    function isSymbolAccessibleByFlags(typeSymbol: Symbol, enclosingDeclaration: Node | undefined, flags: SymbolFlags): boolean {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, /*shouldComputeAliasesToMakeVisible*/ false, /*allowModules*/ false);
        return access.accessibility === SymbolAccessibility.Accessible;
    }

    function isAnySymbolAccessible(symbols: Symbol[] | undefined, enclosingDeclaration: Node | undefined, initialSymbol: Symbol, meaning: SymbolFlags, shouldComputeAliasesToMakeVisible: boolean, allowModules: boolean): SymbolAccessibilityResult | undefined {
        if (!length(symbols)) return;

        let hadAccessibleChain: Symbol | undefined;
        let earlyModuleBail = false;
        for (const symbol of symbols!) {
            // Symbol is accessible if it by itself is accessible
            const accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, /*useOnlyExternalAliasing*/ false);
            if (accessibleSymbolChain) {
                hadAccessibleChain = symbol;
                const hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);
                if (hasAccessibleDeclarations) {
                    return hasAccessibleDeclarations;
                }
            }
            if (allowModules) {
                if (some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                    if (shouldComputeAliasesToMakeVisible) {
                        earlyModuleBail = true;
                        // Generally speaking, we want to use the aliases that already exist to refer to a module, if present
                        // In order to do so, we need to find those aliases in order to retain them in declaration emit; so
                        // if we are in declaration emit, we cannot use the fast path for module visibility until we've exhausted
                        // all other visibility options (in order to capture the possible aliases used to reference the module)
                        continue;
                    }
                    // Any meaning of a module symbol is always accessible via an `import` type
                    return {
                        accessibility: SymbolAccessibility.Accessible,
                    };
                }
            }

            // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
            // It could be a qualified symbol and hence verify the path
            // e.g.:
            // module m {
            //     export class c {
            //     }
            // }
            // const x: typeof m.c
            // In the above example when we start with checking if typeof m.c symbol is accessible,
            // we are going to see if c can be accessed in scope directly.
            // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
            // It is accessible if the parent m is accessible because then m.c can be accessed through qualification

            const containers = getContainersOfSymbol(symbol, enclosingDeclaration, meaning);
            const parentResult = isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning, shouldComputeAliasesToMakeVisible, allowModules);
            if (parentResult) {
                return parentResult;
            }
        }

        if (earlyModuleBail) {
            return {
                accessibility: SymbolAccessibility.Accessible,
            };
        }

        if (hadAccessibleChain) {
            return {
                accessibility: SymbolAccessibility.NotAccessible,
                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlags.Namespace) : undefined,
            };
        }
    }

    /**
     * Check if the given symbol in given enclosing declaration is accessible and mark all associated alias to be visible if requested
     *
     * @param symbol a Symbol to check if accessible
     * @param enclosingDeclaration a Node containing reference to the symbol
     * @param meaning a SymbolFlags to check if such meaning of the symbol is accessible
     * @param shouldComputeAliasToMakeVisible a boolean value to indicate whether to return aliases to be mark visible in case the symbol is accessible
     */
    function isSymbolAccessible(symbol: Symbol | undefined, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasesToMakeVisible: boolean): SymbolAccessibilityResult {
        return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, /*allowModules*/ true);
    }

    function isSymbolAccessibleWorker(symbol: Symbol | undefined, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasesToMakeVisible: boolean, allowModules: boolean): SymbolAccessibilityResult {
        if (symbol && enclosingDeclaration) {
            const result = isAnySymbolAccessible([symbol], enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules);
            if (result) {
                return result;
            }

            // This could be a symbol that is not exported in the external module
            // or it could be a symbol from different external module that is not aliased and hence cannot be named
            const symbolExternalModule = forEach(symbol.declarations, getExternalModuleContainer);
            if (symbolExternalModule) {
                const enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                if (symbolExternalModule !== enclosingExternalModule) {
                    // name from different external module that is not visible
                    return {
                        accessibility: SymbolAccessibility.CannotBeNamed,
                        errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
                        errorModuleName: symbolToString(symbolExternalModule),
                        errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,
                    };
                }
            }

            // Just a local name that is not accessible
            return {
                accessibility: SymbolAccessibility.NotAccessible,
                errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
            };
        }

        return { accessibility: SymbolAccessibility.Accessible };
    }

    function getExternalModuleContainer(declaration: Node) {
        const node = findAncestor(declaration, hasExternalModuleSymbol);
        return node && getSymbolOfDeclaration(node as AmbientModuleDeclaration | SourceFile);
    }

    function hasExternalModuleSymbol(declaration: Node) {
        return isAmbientModule(declaration) || (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(declaration as SourceFile));
    }

    function hasNonGlobalAugmentationExternalModuleSymbol(declaration: Node) {
        return isModuleWithStringLiteralName(declaration) || (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(declaration as SourceFile));
    }

    function hasVisibleDeclarations(symbol: Symbol, shouldComputeAliasToMakeVisible: boolean): SymbolVisibilityResult | undefined {
        let aliasesToMakeVisible: LateVisibilityPaintedStatement[] | undefined;
        if (!every(filter(symbol.declarations, d => d.kind !== SyntaxKind.Identifier), getIsDeclarationVisible)) {
            return undefined;
        }
        return { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible };

        function getIsDeclarationVisible(declaration: Declaration) {
            if (!isDeclarationVisible(declaration)) {
                // Mark the unexported alias as visible if its parent is visible
                // because these kind of aliases can be used to name types in declaration file

                const anyImportSyntax = getAnyImportSyntax(declaration);
                if (
                    anyImportSyntax &&
                    !hasSyntacticModifier(anyImportSyntax, ModifierFlags.Export) && // import clause without export
                    isDeclarationVisible(anyImportSyntax.parent)
                ) {
                    return addVisibleAlias(declaration, anyImportSyntax);
                }
                else if (
                    isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) &&
                    !hasSyntacticModifier(declaration.parent.parent, ModifierFlags.Export) && // unexported variable statement
                    isDeclarationVisible(declaration.parent.parent.parent)
                ) {
                    return addVisibleAlias(declaration, declaration.parent.parent);
                }
                else if (
                    isLateVisibilityPaintedStatement(declaration) // unexported top-level statement
                    && !hasSyntacticModifier(declaration, ModifierFlags.Export)
                    && isDeclarationVisible(declaration.parent)
                ) {
                    return addVisibleAlias(declaration, declaration);
                }
                else if (isBindingElement(declaration)) {
                    if (
                        symbol.flags & SymbolFlags.Alias && isInJSFile(declaration) && declaration.parent?.parent // exported import-like top-level JS require statement
                        && isVariableDeclaration(declaration.parent.parent)
                        && declaration.parent.parent.parent?.parent && isVariableStatement(declaration.parent.parent.parent.parent)
                        && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlags.Export)
                        && declaration.parent.parent.parent.parent.parent // check if the thing containing the variable statement is visible (ie, the file)
                        && isDeclarationVisible(declaration.parent.parent.parent.parent.parent)
                    ) {
                        return addVisibleAlias(declaration, declaration.parent.parent.parent.parent);
                    }
                    else if (symbol.flags & SymbolFlags.BlockScopedVariable) {
                        const variableStatement = findAncestor(declaration, isVariableStatement)!;
                        if (hasSyntacticModifier(variableStatement, ModifierFlags.Export)) {
                            return true;
                        }
                        if (!isDeclarationVisible(variableStatement.parent)) {
                            return false;
                        }
                        return addVisibleAlias(declaration, variableStatement);
                    }
                }

                // Declaration is not visible
                return false;
            }

            return true;
        }

        function addVisibleAlias(declaration: Declaration, aliasingStatement: LateVisibilityPaintedStatement) {
            // In function "buildTypeDisplay" where we decide whether to write type-alias or serialize types,
            // we want to just check if type- alias is accessible or not but we don't care about emitting those alias at that time
            // since we will do the emitting later in trackSymbol.
            if (shouldComputeAliasToMakeVisible) {
                getNodeLinks(declaration).isVisible = true;
                aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement);
            }
            return true;
        }
    }

    function getMeaningOfEntityNameReference(entityName: EntityNameOrEntityNameExpression): SymbolFlags {
        // get symbol of the first identifier of the entityName
        let meaning: SymbolFlags;
        if (
            entityName.parent.kind === SyntaxKind.TypeQuery ||
            entityName.parent.kind === SyntaxKind.ExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) ||
            entityName.parent.kind === SyntaxKind.ComputedPropertyName ||
            entityName.parent.kind === SyntaxKind.TypePredicate && (entityName.parent as TypePredicateNode).parameterName === entityName
        ) {
            // Typeof value
            meaning = SymbolFlags.Value | SymbolFlags.ExportValue;
        }
        else if (
            entityName.kind === SyntaxKind.QualifiedName || entityName.kind === SyntaxKind.PropertyAccessExpression ||
            entityName.parent.kind === SyntaxKind.ImportEqualsDeclaration ||
            (entityName.parent.kind === SyntaxKind.QualifiedName && (entityName.parent as QualifiedName).left === entityName) ||
            (entityName.parent.kind === SyntaxKind.PropertyAccessExpression && (entityName.parent as PropertyAccessExpression).expression === entityName) ||
            (entityName.parent.kind === SyntaxKind.ElementAccessExpression && (entityName.parent as ElementAccessExpression).expression === entityName)
        ) {
            // Left identifier from type reference or TypeAlias
            // Entity name of the import declaration
            meaning = SymbolFlags.Namespace;
        }
        else {
            // Type Reference or TypeAlias entity = Identifier
            meaning = SymbolFlags.Type;
        }
        return meaning;
    }

    function isEntityNameVisible(entityName: EntityNameOrEntityNameExpression, enclosingDeclaration: Node, shouldComputeAliasToMakeVisible = true): SymbolVisibilityResult {
        const meaning = getMeaningOfEntityNameReference(entityName);
        const firstIdentifier = getFirstIdentifier(entityName);
        const symbol = resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
        if (symbol && symbol.flags & SymbolFlags.TypeParameter && meaning & SymbolFlags.Type) {
            return { accessibility: SymbolAccessibility.Accessible };
        }
        if (!symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false)), firstIdentifier, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility === SymbolAccessibility.Accessible) {
            return { accessibility: SymbolAccessibility.Accessible };
        }

        if (!symbol) {
            return {
                accessibility: SymbolAccessibility.NotResolved,
                errorSymbolName: getTextOfNode(firstIdentifier),
                errorNode: firstIdentifier,
            };
        }
        // Verify if the symbol is accessible
        return hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || {
            accessibility: SymbolAccessibility.NotAccessible,
            errorSymbolName: getTextOfNode(firstIdentifier),
            errorNode: firstIdentifier,
        };
    }

    function symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags: SymbolFormatFlags = SymbolFormatFlags.AllowAnyNodeKind, writer?: EmitTextWriter): string {
        let nodeFlags = NodeBuilderFlags.IgnoreErrors;
        let internalNodeFlags = InternalNodeBuilderFlags.None;
        if (flags & SymbolFormatFlags.UseOnlyExternalAliasing) {
            nodeFlags |= NodeBuilderFlags.UseOnlyExternalAliasing;
        }
        if (flags & SymbolFormatFlags.WriteTypeParametersOrArguments) {
            nodeFlags |= NodeBuilderFlags.WriteTypeParametersInQualifiedName;
        }
        if (flags & SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope) {
            nodeFlags |= NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope;
        }
        if (flags & SymbolFormatFlags.DoNotIncludeSymbolChain) {
            internalNodeFlags |= InternalNodeBuilderFlags.DoNotIncludeSymbolChain;
        }
        if (flags & SymbolFormatFlags.WriteComputedProps) {
            internalNodeFlags |= InternalNodeBuilderFlags.WriteComputedProps;
        }
        const builder = flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName;
        return writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(symbolToStringWorker);

        function symbolToStringWorker(writer: EmitTextWriter) {
            const entity = builder(symbol, meaning!, enclosingDeclaration, nodeFlags, internalNodeFlags)!; // TODO: GH#18217
            // add neverAsciiEscape for GH#39027
            const printer = enclosingDeclaration?.kind === SyntaxKind.SourceFile
                ? createPrinterWithRemoveCommentsNeverAsciiEscape()
                : createPrinterWithRemoveComments();
            const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(EmitHint.Unspecified, entity, /*sourceFile*/ sourceFile, writer);
            return writer;
        }
    }

    function signatureToString(
        signature: Signature,
        enclosingDeclaration?: Node,
        flags = TypeFormatFlags.None,
        kind?: SignatureKind,
        writer?: EmitTextWriter,
        maximumLength?: number,
        verbosityLevel?: number,
        out?: WriterContextOut,
    ): string {
        return writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker);

        function signatureToStringWorker(writer: EmitTextWriter) {
            let sigOutput: SyntaxKind;
            if (flags & TypeFormatFlags.WriteArrowStyleSignature) {
                sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructorType : SyntaxKind.FunctionType;
            }
            else {
                sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructSignature : SyntaxKind.CallSignature;
            }
            const sig = nodeBuilder.signatureToSignatureDeclaration(
                signature,
                sigOutput,
                enclosingDeclaration,
                toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName,
                /*internalFlags*/ undefined,
                /*tracker*/ undefined,
                maximumLength,
                verbosityLevel,
                out,
            );
            const printer = createPrinterWithRemoveCommentsOmitTrailingSemicolon();
            const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(EmitHint.Unspecified, sig!, /*sourceFile*/ sourceFile, getTrailingSemicolonDeferringWriter(writer)); // TODO: GH#18217
            return writer;
        }
    }

    function typeToString(
        type: Type,
        enclosingDeclaration?: Node,
        flags: TypeFormatFlags = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope,
        writer: EmitTextWriter = createTextWriter(""),
        maximumLength?: number,
        verbosityLevel?: number,
        out?: WriterContextOut,
    ): string {
        const noTruncation = compilerOptions.noErrorTruncation ||
            flags & TypeFormatFlags.NoTruncation;
        const typeNode = nodeBuilder.typeToTypeNode(
            type,
            enclosingDeclaration,
            toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | (noTruncation ? NodeBuilderFlags.NoTruncation : 0),
            /*internalFlags*/ undefined,
            /*tracker*/ undefined,
            maximumLength,
            verbosityLevel,
            out,
        );
        if (typeNode === undefined) return Debug.fail("should always get typenode");
        // The unresolved type gets a synthesized comment on `any` to hint to users that it's not a plain `any`.
        // Otherwise, we always strip comments out.
        const printer = type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults();
        const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
        printer.writeNode(EmitHint.Unspecified, typeNode, /*sourceFile*/ sourceFile, writer);
        const result = writer.getText();

        const maxLength = maximumLength || (noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2);
        if (maxLength && result && result.length >= maxLength) {
            return result.substr(0, maxLength - "...".length) + "...";
        }
        return result;
    }

    function getTypeNamesForErrorDisplay(left: Type, right: Type): [string, string] {
        let leftStr = symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left);
        let rightStr = symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right);
        if (leftStr === rightStr) {
            leftStr = getTypeNameForErrorDisplay(left);
            rightStr = getTypeNameForErrorDisplay(right);
        }
        return [leftStr, rightStr];
    }

    function getTypeNameForErrorDisplay(type: Type) {
        return typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.UseFullyQualifiedType);
    }

    function symbolValueDeclarationIsContextSensitive(symbol: Symbol): boolean {
        return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration);
    }

    function toNodeBuilderFlags(flags = TypeFormatFlags.None): NodeBuilderFlags {
        return flags & TypeFormatFlags.NodeBuilderFlagsMask;
    }

    function isClassInstanceSide(type: Type) {
        return !!type.symbol && !!(type.symbol.flags & SymbolFlags.Class) && (type === getDeclaredTypeOfClassOrInterface(type.symbol) || (!!(type.flags & TypeFlags.Object) && !!(getObjectFlags(type) & ObjectFlags.IsClassInstanceClone)));
    }
    /**
     * Same as getTypeFromTypeNode, but for use in createNodeBuilder
     * Inside createNodeBuilder we shadow getTypeFromTypeNode to make sure anyone using this function will call the local version that does type mapping if appropriate
     * This function is used to still be able to call the original getTypeFromTypeNode from the local scope version of getTypeFromTypeNode
     */
    function getTypeFromTypeNodeWithoutContext(node: TypeNode) {
        return getTypeFromTypeNode(node);
    }
    function createNodeBuilder() {
        const syntacticBuilderResolver: SyntacticTypeNodeBuilderResolver = {
            evaluateEntityNameExpression,
            isExpandoFunctionDeclaration,
            hasLateBindableName,
            shouldRemoveDeclaration(context: SyntacticTypeNodeBuilderContext, node: DynamicNamedDeclaration) {
                return !((context as NodeBuilderContext).internalFlags & InternalNodeBuilderFlags.AllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags & TypeFlags.Any);
            },
            createRecoveryBoundary(context) {
                return createRecoveryBoundary(context as NodeBuilderContext);
            },
            isDefinitelyReferenceToGlobalSymbolObject,
            getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration,
            requiresAddingImplicitUndefined(declaration: ParameterDeclaration | JSDocParameterTag | PropertyDeclaration | PropertySignature | JSDocPropertyTag, symbol: Symbol | undefined, enclosingDeclaration: Node | undefined): boolean {
                switch (declaration.kind) {
                    case SyntaxKind.PropertyDeclaration:
                    case SyntaxKind.PropertySignature:
                    case SyntaxKind.JSDocPropertyTag:
                        symbol ??= getSymbolOfDeclaration(declaration);
                        const type = getTypeOfSymbol(symbol);
                        return !!(symbol.flags & SymbolFlags.Property && symbol.flags & SymbolFlags.Optional && isOptionalDeclaration(declaration) && (symbol as MappedSymbol).links?.mappedType && containsNonMissingUndefinedType(type));
                    case SyntaxKind.Parameter:
                    case SyntaxKind.JSDocParameterTag:
                        return requiresAddingImplicitUndefined(declaration, enclosingDeclaration);
                    default:
                        Debug.assertNever(declaration);
                }
            },
            isOptionalParameter,
            isUndefinedIdentifierExpression(node: Identifier) {
                return getSymbolAtLocation(node) === undefinedSymbol;
            },
            isEntityNameVisible(context, entityName, shouldComputeAliasToMakeVisible) {
                return isEntityNameVisible(entityName, context.enclosingDeclaration!, shouldComputeAliasToMakeVisible);
            },
            serializeExistingTypeNode(context, typeNode, addUndefined) {
                return serializeExistingTypeNode(context as NodeBuilderContext, typeNode, !!addUndefined);
            },
            serializeReturnTypeForSignature(syntacticContext, signatureDeclaration, symbol) {
                const context = syntacticContext as NodeBuilderContext;
                const signature = getSignatureFromDeclaration(signatureDeclaration);
                symbol ??= getSymbolOfDeclaration(signatureDeclaration);
                const returnType = context.enclosingSymbolTypes.get(getSymbolId(symbol)) ?? instantiateType(getReturnTypeOfSignature(signature), context.mapper);
                return serializeInferredReturnTypeForSignature(context, signature, returnType);
            },
            serializeTypeOfExpression(syntacticContext, expr) {
                const context = syntacticContext as NodeBuilderContext;
                const type = instantiateType(getWidenedType(getRegularTypeOfExpression(expr)), context.mapper);
                return typeToTypeNodeHelper(type, context);
            },
            serializeTypeOfDeclaration(syntacticContext, declaration, symbol) {
                // Get type of the symbol if this is the valid symbol otherwise get type at location
                const context = syntacticContext as NodeBuilderContext;
                symbol ??= getSymbolOfDeclaration(declaration);
                let type = context.enclosingSymbolTypes?.get(getSymbolId(symbol));
                if (type === undefined) {
                    type = symbol.flags & SymbolFlags.Accessor && declaration.kind === SyntaxKind.SetAccessor ? instantiateType(getWriteTypeOfSymbol(symbol), context.mapper) :
                        symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature))
                        ? instantiateType(getWidenedLiteralType(getTypeOfSymbol(symbol)), context.mapper)
                        : errorType;
                }
                const addUndefinedForParameter = declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration);
                if (addUndefinedForParameter) {
                    type = getOptionalType(type);
                }
                return serializeInferredTypeForDeclaration(symbol, context, type);
            },
            serializeNameOfParameter(context, parameter) {
                return parameterToParameterDeclarationName(getSymbolOfDeclaration(parameter), parameter, context as NodeBuilderContext);
            },
            serializeEntityName(syntacticContext, node) {
                const context = syntacticContext as NodeBuilderContext;
                const symbol = getSymbolAtLocation(node, /*ignoreErrors*/ true);
                if (!symbol) return undefined;
                if (!isValueSymbolAccessible(symbol, context.enclosingDeclaration)) return undefined;
                return symbolToExpression(symbol, context, SymbolFlags.Value | SymbolFlags.ExportValue);
            },
            serializeTypeName(context, node, isTypeOf, typeArguments) {
                return serializeTypeName(context as NodeBuilderContext, node, isTypeOf, typeArguments);
            },
            getJsDocPropertyOverride(syntacticContext, jsDocTypeLiteral, jsDocProperty) {
                const context = syntacticContext as NodeBuilderContext;
                const name = isIdentifier(jsDocProperty.name) ? jsDocProperty.name : jsDocProperty.name.right;
                const typeViaParent = getTypeOfPropertyOfType(getTypeFromTypeNode(context, jsDocTypeLiteral), name.escapedText);
                const overrideTypeNode = typeViaParent && jsDocProperty.typeExpression && getTypeFromTypeNode(context, jsDocProperty.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined;
                return overrideTypeNode;
            },
            enterNewScope(context, node) {
                if (isFunctionLike(node) || isJSDocSignature(node)) {
                    const signature = getSignatureFromDeclaration(node);
                    return enterNewScope(context as NodeBuilderContext, node, signature.parameters, signature.typeParameters);
                }
                else {
                    const typeParameters = isConditionalTypeNode(node) ? getInferTypeParameters(node) :
                        [getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))];
                    return enterNewScope(context as NodeBuilderContext, node, /*expandedParams*/ undefined, typeParameters);
                }
            },
            markNodeReuse<T extends Node>(context: SyntacticTypeNodeBuilderContext, range: T, location: Node | undefined) {
                return setTextRange(context as NodeBuilderContext, range, location);
            },
            trackExistingEntityName<T extends EntityNameOrEntityNameExpression>(context: SyntacticTypeNodeBuilderContext, node: T) {
                return trackExistingEntityName(node, context as NodeBuilderContext);
            },
            trackComputedName(context: SyntacticTypeNodeBuilderContext, accessExpression: EntityNameOrEntityNameExpression) {
                trackComputedName(accessExpression, context.enclosingDeclaration, context as NodeBuilderContext);
            },
            getModuleSpecifierOverride(syntacticContext, parent, lit) {
                const context = syntacticContext as NodeBuilderContext;
                if (context.bundled || context.enclosingFile !== getSourceFileOfNode(lit)) {
                    let name = lit.text;
                    const originalName = name;
                    const nodeSymbol = getNodeLinks(parent).resolvedSymbol;
                    const meaning = parent.isTypeOf ? SymbolFlags.Value : SymbolFlags.Type;
                    const parentSymbol = nodeSymbol
                        && isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility === SymbolAccessibility.Accessible
                        && lookupSymbolChain(nodeSymbol, context, meaning, /*yieldModuleSymbol*/ true)[0];
                    if (parentSymbol && isExternalModuleSymbol(parentSymbol)) {
                        name = getSpecifierForModuleSymbol(parentSymbol, context);
                    }
                    else {
                        const targetFile = getExternalModuleFileFromDeclaration(parent);
                        if (targetFile) {
                            name = getSpecifierForModuleSymbol(targetFile.symbol, context);
                        }
                    }
                    if (name.includes("/node_modules/")) {
                        context.encounteredError = true;
                        if (context.tracker.reportLikelyUnsafeImportRequiredError) {
                            context.tracker.reportLikelyUnsafeImportRequiredError(name);
                        }
                    }
                    if (name !== originalName) {
                        return name;
                    }
                }
            },
            canReuseTypeNode(context, typeNode) {
                return canReuseTypeNode(context as NodeBuilderContext, typeNode);
            },
            canReuseTypeNodeAnnotation(syntacticContext: SyntacticTypeNodeBuilderContext, node: Declaration, existing: TypeNode, symbol: Symbol, requiresAddingUndefined?: boolean) {
                const context = syntacticContext as NodeBuilderContext;
                if (context.enclosingDeclaration === undefined) return false;

                symbol ??= getSymbolOfDeclaration(node);
                let type = context.enclosingSymbolTypes?.get(getSymbolId(symbol));
                if (type === undefined) {
                    if (symbol.flags & SymbolFlags.Accessor) {
                        type = node.kind === SyntaxKind.SetAccessor ? getWriteTypeOfSymbol(symbol) : getTypeOfAccessors(symbol);
                    }
                    else if (isValueSignatureDeclaration(node)) {
                        type = getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                    }
                    else {
                        type = getTypeOfSymbol(symbol);
                    }
                }
                let annotationType = getTypeFromTypeNodeWithoutContext(existing);
                if (isErrorType(annotationType)) {
                    // allow "reusing" type nodes that resolve to error types
                    // those can't truly be reused but it prevents cascading errors in isolatedDeclarations
                    // for source with errors there is no guarantee to emit correct code anyway
                    return true;
                }
                if (requiresAddingUndefined && annotationType) {
                    annotationType = addOptionality(annotationType, !isParameter(node));
                }
                return !!annotationType && typeNodeIsEquivalentToType(node, type, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type);
            },
        };
        return {
            syntacticBuilderResolver,
            typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker, maximumLength?: number, verbosityLevel?: number, out?: WriterContextOut) => withContext(enclosingDeclaration, flags, internalFlags, tracker, maximumLength, verbosityLevel, context => typeToTypeNodeHelper(type, context), out),
            typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => typePredicateToTypePredicateNodeHelper(typePredicate, context)),
            serializeTypeForDeclaration: (declaration: HasInferredType, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, symbol, context)),
            serializeReturnTypeForSignature: (signature: SignatureDeclaration, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => syntacticNodeBuilder.serializeReturnTypeForSignature(signature, getSymbolOfDeclaration(signature), context)),
            serializeTypeForExpression: (expr: Expression, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => syntacticNodeBuilder.serializeTypeOfExpression(expr, context)),
            indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, /*typeNode*/ undefined)),
            signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker, maximumLength?: number, verbosityLevel?: number, out?: WriterContextOut) => withContext(enclosingDeclaration, flags, internalFlags, tracker, maximumLength, verbosityLevel, context => signatureToSignatureDeclarationHelper(signature, kind, context), out),
            symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => symbolToName(symbol, context, meaning, /*expectsIdentifier*/ false)),
            symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => symbolToExpression(symbol, context, meaning)),
            symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => typeParametersToTypeParameterDeclarations(symbol, context)),
            symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => symbolToParameterDeclaration(symbol, context)),
            typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker, maximumLength?: number, verbosityLevel?: number, out?: WriterContextOut) => withContext(enclosingDeclaration, flags, internalFlags, tracker, maximumLength, verbosityLevel, context => typeParameterToDeclaration(parameter, context), out),
            symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => symbolTableToDeclarationStatements(symbolTable, context)),
            symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, /*maximumLength*/ undefined, /*verbosityLevel*/ undefined, context => symbolToNode(symbol, context, meaning)),
            symbolToDeclarations,
        };

        function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes?: false): Type;
        function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes: true): Type | undefined;
        function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes?: boolean): Type | undefined {
            const type = getTypeFromTypeNodeWithoutContext(node);
            if (!context.mapper) return type;

            const mappedType = instantiateType(type, context.mapper);
            return noMappedTypes && mappedType !== type ? undefined : mappedType;
        }

        /**
         * Unlike the utilities `setTextRange`, this checks if the `location` we're trying to set on `range` is within the
         * same file as the active context. If not, the range is not applied. This prevents us from copying ranges across files,
         * which will confuse the node printer (as it assumes all node ranges are within the current file).
         * Additionally, if `range` _isn't synthetic_, or isn't in the current file, it will _copy_ it to _remove_ its' position
         * information.
         *
         * It also calls `setOriginalNode` to setup a `.original` pointer, since you basically *always* want these in the node builder.
         */
        function setTextRange<T extends Node>(context: NodeBuilderContext, range: T, location: Node | undefined): T {
            if (!nodeIsSynthesized(range) || !(range.flags & NodeFlags.Synthesized) || !context.enclosingFile || context.enclosingFile !== getSourceFileOfNode(getOriginalNode(range))) {
                range = factory.cloneNode(range); // if `range` is synthesized or originates in another file, copy it so it definitely has synthetic positions
            }
            if (range === location) return range;
            if (!location) {
                return range;
            }
            // Don't overwrite the original node if `range` has an `original` node that points either directly or indirectly to `location`
            let original = range.original;
            while (original && original !== location) {
                original = original.original;
            }
            if (!original) {
                setOriginalNode(range, location);
            }
            // only set positions if range comes from the same file since copying text across files isn't supported by the emitter
            if (context.enclosingFile && context.enclosingFile === getSourceFileOfNode(getOriginalNode(location))) {
                return setTextRangeWorker(range, location);
            }
            return range;
        }

        function symbolToNode(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags) {
            if (context.internalFlags & InternalNodeBuilderFlags.WriteComputedProps) {
                if (symbol.valueDeclaration) {
                    const name = getNameOfDeclaration(symbol.valueDeclaration);
                    if (name && isComputedPropertyName(name)) return name;
                }
                const nameType = getSymbolLinks(symbol).nameType;
                if (nameType && nameType.flags & (TypeFlags.EnumLiteral | TypeFlags.UniqueESSymbol)) {
                    context.enclosingDeclaration = nameType.symbol.valueDeclaration;
                    return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning));
                }
            }
            return symbolToExpression(symbol, context, meaning);
        }

        function symbolToDeclarations(symbol: Symbol, meaning: SymbolFlags, flags: NodeBuilderFlags, maximumLength?: number, verbosityLevel?: number, out?: WriterContextOut): Declaration[] {
            const nodes = withContext(
                /*enclosingDeclaration*/ undefined,
                flags,
                /*internalFlags*/ undefined,
                /*tracker*/ undefined,
                maximumLength,
                verbosityLevel,
                context => symbolToDeclarationsWorker(symbol, context),
                out,
            );
            return mapDefined(nodes, node => {
                switch (node.kind) {
                    case SyntaxKind.ClassDeclaration:
                        return simplifyClassDeclaration(node as ClassDeclaration, symbol);
                    case SyntaxKind.EnumDeclaration:
                        return simplifyModifiers(node as EnumDeclaration, isEnumDeclaration, symbol);
                    case SyntaxKind.InterfaceDeclaration:
                        return simplifyInterfaceDeclaration(node as InterfaceDeclaration, symbol, meaning);
                    case SyntaxKind.ModuleDeclaration:
                        return simplifyModifiers(node as ModuleDeclaration, isModuleDeclaration, symbol);
                    default:
                        return undefined;
                }
            });
        }

        function simplifyClassDeclaration(classDecl: ClassDeclaration, symbol: Symbol): Declaration {
            const classDeclarations = filter(symbol.declarations, isClassLike);
            const originalClassDecl = classDeclarations && classDeclarations.length > 0 ? classDeclarations[0] : classDecl;
            const modifiers = getEffectiveModifierFlags(originalClassDecl) & ~(ModifierFlags.Export | ModifierFlags.Ambient);
            const isAnonymous = isClassExpression(originalClassDecl);
            if (isAnonymous) {
                classDecl = factory.updateClassDeclaration(
                    classDecl,
                    classDecl.modifiers,
                    /*name*/ undefined,
                    classDecl.typeParameters,
                    classDecl.heritageClauses,
                    classDecl.members,
                );
            }
            return factory.replaceModifiers(classDecl, modifiers);
        }

        function simplifyModifiers(newDecl: Declaration & HasModifiers, isDeclKind: (d: Declaration) => boolean, symbol: Symbol): Declaration & HasModifiers {
            const decls = filter(symbol.declarations, isDeclKind);
            const declWithModifiers = decls && decls.length > 0 ? decls[0] : newDecl;
            const modifiers = getEffectiveModifierFlags(declWithModifiers) & ~(ModifierFlags.Export | ModifierFlags.Ambient);
            return factory.replaceModifiers(newDecl, modifiers);
        }

        function simplifyInterfaceDeclaration(interfaceDecl: InterfaceDeclaration, symbol: Symbol, meaning: SymbolFlags): Declaration | undefined {
            if (!(meaning & SymbolFlags.Interface)) {
                return undefined;
            }
            return simplifyModifiers(interfaceDecl, isInterfaceDeclaration, symbol);
        }

        function symbolToDeclarationsWorker(symbol: Symbol, context: NodeBuilderContext): Statement[] {
            // We're already expanding the type: set it in the stack to avoid expanding it again.
            const type = getDeclaredTypeOfSymbol(symbol);
            context.typeStack.push(type.id);
            context.typeStack.push(-1);
            const table = createSymbolTable([symbol]);
            const statements = symbolTableToDeclarationStatements(table, context);
            context.typeStack.pop();
            context.typeStack.pop();
            return statements;
        }

        function withContext<T>(
            enclosingDeclaration: Node | undefined,
            flags: NodeBuilderFlags | undefined,
            internalFlags: InternalNodeBuilderFlags | undefined,
            tracker: SymbolTracker | undefined,
            maximumLength: number | undefined,
            verbosityLevel: number | undefined,
            cb: (context: NodeBuilderContext) => T,
            out?: WriterContextOut,
        ): T | undefined {
            const moduleResolverHost = tracker?.trackSymbol ? tracker.moduleResolverHost :
                (internalFlags || InternalNodeBuilderFlags.None) & InternalNodeBuilderFlags.DoNotIncludeSymbolChain ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) :
                undefined;
            flags = flags || NodeBuilderFlags.None;
            const maxTruncationLength = maximumLength ||
                (flags & NodeBuilderFlags.NoTruncation ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength);
            const context: NodeBuilderContext = {
                enclosingDeclaration,
                enclosingFile: enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),
                flags,
                internalFlags: internalFlags || InternalNodeBuilderFlags.None,
                tracker: undefined!,
                maxTruncationLength,
                maxExpansionDepth: verbosityLevel ?? -1,
                encounteredError: false,
                suppressReportInferenceFallback: false,
                reportedDiagnostic: false,
                visitedTypes: undefined,
                symbolDepth: undefined,
                inferTypeParameters: undefined,
                approximateLength: 0,
                trackedSymbols: undefined,
                bundled: !!compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)),
                truncating: false,
                usedSymbolNames: undefined,
                remappedSymbolNames: undefined,
                remappedSymbolReferences: undefined,
                reverseMappedStack: undefined,
                mustCreateTypeParameterSymbolList: true,
                typeParameterSymbolList: undefined,
                mustCreateTypeParametersNamesLookups: true,
                typeParameterNames: undefined,
                typeParameterNamesByText: undefined,
                typeParameterNamesByTextNextNameCount: undefined,
                enclosingSymbolTypes: new Map(),
                mapper: undefined,
                depth: 0,
                typeStack: [],
                out: {
                    canIncreaseExpansionDepth: false,
                    truncated: false,
                },
            };
            context.tracker = new SymbolTrackerImpl(context, tracker, moduleResolverHost);
            const resultingNode = cb(context);
            if (context.truncating && context.flags & NodeBuilderFlags.NoTruncation) {
                context.tracker.reportTruncationError();
            }
            if (out) {
                out.canIncreaseExpansionDepth = context.out.canIncreaseExpansionDepth;
                out.truncated = context.out.truncated;
            }
            return context.encounteredError ? undefined : resultingNode;
        }

        function addSymbolTypeToContext(context: NodeBuilderContext, symbol: Symbol, type: Type) {
            const id = getSymbolId(symbol);
            const oldType = context.enclosingSymbolTypes.get(id);
            context.enclosingSymbolTypes.set(id, type);
            return restore;
            function restore() {
                if (oldType) {
                    context.enclosingSymbolTypes.set(id, oldType);
                }
                else {
                    context.enclosingSymbolTypes.delete(id);
                }
            }
        }
        function saveRestoreFlags(context: NodeBuilderContext) {
            const flags = context.flags;
            const internalFlags = context.internalFlags;
            const depth = context.depth;

            return restore;

            function restore() {
                context.flags = flags;
                context.internalFlags = internalFlags;
                context.depth = depth;
            }
        }

        function checkTruncationLengthIfExpanding(context: NodeBuilderContext): boolean {
            return context.maxExpansionDepth >= 0 && checkTruncationLength(context);
        }

        function checkTruncationLength(context: NodeBuilderContext): boolean {
            if (context.truncating) return context.truncating;
            return context.truncating = context.approximateLength > context.maxTruncationLength;
        }

        /**
         * Returns true if it's possible the type or one of its components can be expanded.
         */
        function canPossiblyExpandType(type: Type, context: NodeBuilderContext): boolean {
            for (let i = 0; i < context.typeStack.length - 1; i++) {
                if (context.typeStack[i] === type.id) {
                    return false;
                }
            }
            return context.depth < context.maxExpansionDepth ||
                context.depth === context.maxExpansionDepth && !context.out.canIncreaseExpansionDepth;
        }

        /**
         * Determines if the input type should be expanded, based on how many layers of names we're allowed to expand.
         * @param isAlias - Whether we're expanding a type alias or not.
         */
        function shouldExpandType(type: Type, context: NodeBuilderContext, isAlias = false): boolean {
            if (!isAlias && isLibType(type)) {
                return false;
            }
            for (let i = 0; i < context.typeStack.length - 1; i++) {
                if (context.typeStack[i] === type.id) {
                    return false;
                }
            }
            const result = context.depth < context.maxExpansionDepth;
            if (!result) {
                // This type would have been expanded if `maxExpansionDepth` was increased.
                context.out.canIncreaseExpansionDepth = true;
            }
            return result;
        }

        function typeToTypeNodeHelper(type: Type, context: NodeBuilderContext): TypeNode {
            const restoreFlags = saveRestoreFlags(context);
            if (type) context.typeStack.push(type.id);
            const typeNode = typeToTypeNodeWorker(type, context);
            if (type) context.typeStack.pop();
            restoreFlags();
            return typeNode;
        }

        function typeToTypeNodeWorker(type: Type, context: NodeBuilderContext): TypeNode {
            if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                cancellationToken.throwIfCancellationRequested();
            }
            const inTypeAlias = context.flags & NodeBuilderFlags.InTypeAlias;
            context.flags &= ~NodeBuilderFlags.InTypeAlias;
            let expandingEnum = false;

            if (!type) {
                if (!(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection)) {
                    context.encounteredError = true;
                    return undefined!; // TODO: GH#18217
                }
                context.approximateLength += 3;
                return factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
            }

            if (!(context.flags & NodeBuilderFlags.NoTypeReduction)) {
                type = getReducedType(type);
            }

            if (type.flags & TypeFlags.Any) {
                if (type.aliasSymbol) {
                    return factory.createTypeReferenceNode(symbolToEntityNameNode(type.aliasSymbol), mapToTypeNodes(type.aliasTypeArguments, context));
                }
                if (type === unresolvedType) {
                    return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.AnyKeyword), SyntaxKind.MultiLineCommentTrivia, "unresolved");
                }
                context.approximateLength += 3;
                return factory.createKeywordTypeNode(type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword);
            }
            if (type.flags & TypeFlags.Unknown) {
                return factory.createKeywordTypeNode(SyntaxKind.UnknownKeyword);
            }
            if (type.flags & TypeFlags.String) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.StringKeyword);
            }
            if (type.flags & TypeFlags.Number) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.NumberKeyword);
            }
            if (type.flags & TypeFlags.BigInt) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.BigIntKeyword);
            }
            if (type.flags & TypeFlags.Boolean && !type.aliasSymbol) {
                context.approximateLength += 7;
                return factory.createKeywordTypeNode(SyntaxKind.BooleanKeyword);
            }
            if (type.flags & TypeFlags.EnumLike) {
                if (type.symbol.flags & SymbolFlags.EnumMember) {
                    const parentSymbol = getParentOfSymbol(type.symbol)!;
                    const parentName = symbolToTypeNode(parentSymbol, context, SymbolFlags.Type);
                    if (getDeclaredTypeOfSymbol(parentSymbol) === type) {
                        return parentName;
                    }
                    const memberName = symbolName(type.symbol);
                    if (isIdentifierText(memberName, ScriptTarget.ES5)) {
                        return appendReferenceToType(
                            parentName as TypeReferenceNode | ImportTypeNode,
                            factory.createTypeReferenceNode(memberName, /*typeArguments*/ undefined),
                        );
                    }
                    if (isImportTypeNode(parentName)) {
                        (parentName as any).isTypeOf = true; // mutably update, node is freshly manufactured anyhow
                        return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)));
                    }
                    else if (isTypeReferenceNode(parentName)) {
                        return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)));
                    }
                    else {
                        return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.");
                    }
                }
                if (!shouldExpandType(type, context)) {
                    return symbolToTypeNode(type.symbol, context, SymbolFlags.Type);
                }
                else {
                    expandingEnum = true;
                }
            }
            if (type.flags & TypeFlags.StringLiteral) {
                context.approximateLength += (type as StringLiteralType).value.length + 2;
                return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral((type as StringLiteralType).value, !!(context.flags & NodeBuilderFlags.UseSingleQuotesForStringLiteralType)), EmitFlags.NoAsciiEscaping));
            }
            if (type.flags & TypeFlags.NumberLiteral) {
                const value = (type as NumberLiteralType).value;
                context.approximateLength += ("" + value).length;
                return factory.createLiteralTypeNode(value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-value)) : factory.createNumericLiteral(value));
            }
            if (type.flags & TypeFlags.BigIntLiteral) {
                context.approximateLength += (pseudoBigIntToString((type as BigIntLiteralType).value).length) + 1;
                return factory.createLiteralTypeNode(factory.createBigIntLiteral((type as BigIntLiteralType).value));
            }
            if (type.flags & TypeFlags.BooleanLiteral) {
                context.approximateLength += (type as IntrinsicType).intrinsicName.length;
                return factory.createLiteralTypeNode((type as IntrinsicType).intrinsicName === "true" ? factory.createTrue() : factory.createFalse());
            }
            if (type.flags & TypeFlags.UniqueESSymbol) {
                if (!(context.flags & NodeBuilderFlags.AllowUniqueESSymbolType)) {
                    if (isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                        context.approximateLength += 6;
                        return symbolToTypeNode(type.symbol, context, SymbolFlags.Value);
                    }
                    if (context.tracker.reportInaccessibleUniqueSymbolError) {
                        context.tracker.reportInaccessibleUniqueSymbolError();
                    }
                }
                context.approximateLength += 13;
                return factory.createTypeOperatorNode(SyntaxKind.UniqueKeyword, factory.createKeywordTypeNode(SyntaxKind.SymbolKeyword));
            }
            if (type.flags & TypeFlags.Void) {
                context.approximateLength += 4;
                return factory.createKeywordTypeNode(SyntaxKind.VoidKeyword);
            }
            if (type.flags & TypeFlags.Undefined) {
                context.approximateLength += 9;
                return factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword);
            }
            if (type.flags & TypeFlags.Null) {
                context.approximateLength += 4;
                return factory.createLiteralTypeNode(factory.createNull());
            }
            if (type.flags & TypeFlags.Never) {
                context.approximateLength += 5;
                return factory.createKeywordTypeNode(SyntaxKind.NeverKeyword);
            }
            if (type.flags & TypeFlags.ESSymbol) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.SymbolKeyword);
            }
            if (type.flags & TypeFlags.NonPrimitive) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword);
            }
            if (isThisTypeParameter(type)) {
                if (context.flags & NodeBuilderFlags.InObjectTypeLiteral) {
                    if (!context.encounteredError && !(context.flags & NodeBuilderFlags.AllowThisInObjectLiteral)) {
                        context.encounteredError = true;
                    }
                    context.tracker.reportInaccessibleThisError?.();
                }
                context.approximateLength += 4;
                return factory.createThisTypeNode();
            }

            if (!inTypeAlias && type.aliasSymbol && (context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration))) {
                if (!shouldExpandType(type, context, /*isAlias*/ true)) {
                    const typeArgumentNodes = mapToTypeNodes(type.aliasTypeArguments, context);
                    if (isReservedMemberName(type.aliasSymbol.escapedName) && !(type.aliasSymbol.flags & SymbolFlags.Class)) return factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes);
                    if (length(typeArgumentNodes) === 1 && type.aliasSymbol === globalArrayType.symbol) {
                        return factory.createArrayTypeNode(typeArgumentNodes![0]);
                    }
                    return symbolToTypeNode(type.aliasSymbol, context, SymbolFlags.Type, typeArgumentNodes);
                }
                context.depth += 1;
            }

            const objectFlags = getObjectFlags(type);

            if (objectFlags & ObjectFlags.Reference) {
                Debug.assert(!!(type.flags & TypeFlags.Object));
                if (shouldExpandType(type, context)) {
                    context.depth += 1;
                    return createAnonymousTypeNode(type as TypeReference, /*forceClassExpansion*/ true, /*forceExpansion*/ true);
                }
                return (type as TypeReference).node ? visitAndTransformType(type as TypeReference, typeReferenceToTypeNode) : typeReferenceToTypeNode(type as TypeReference);
            }
            if (type.flags & TypeFlags.TypeParameter || objectFlags & ObjectFlags.ClassOrInterface) {
                if (type.flags & TypeFlags.TypeParameter && contains(context.inferTypeParameters, type)) {
                    context.approximateLength += symbolName(type.symbol).length + 6;
                    let constraintNode: TypeNode | undefined;
                    const constraint = getConstraintOfTypeParameter(type as TypeParameter);
                    if (constraint) {
                        // If the infer type has a constraint that is not the same as the constraint
                        // we would have normally inferred based on context, we emit the constraint
                        // using `infer T extends ?`. We omit inferred constraints from type references
                        // as they may be elided.
                        const inferredConstraint = getInferredTypeParameterConstraint(type as TypeParameter, /*omitTypeReferences*/ true);
                        if (!(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint))) {
                            context.approximateLength += 9;
                            constraintNode = constraint && typeToTypeNodeHelper(constraint, context);
                        }
                    }
                    return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type as TypeParameter, context, constraintNode));
                }
                if (
                    context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams &&
                    type.flags & TypeFlags.TypeParameter
                ) {
                    const name = typeParameterToName(type, context);
                    context.approximateLength += idText(name).length;
                    return factory.createTypeReferenceNode(factory.createIdentifier(idText(name)), /*typeArguments*/ undefined);
                }
                if (objectFlags & ObjectFlags.ClassOrInterface && shouldExpandType(type, context)) {
                    context.depth += 1;
                    return createAnonymousTypeNode(type as InterfaceType, /*forceClassExpansion*/ true, /*forceExpansion*/ true);
                }
                // Ignore constraint/default when creating a usage (as opposed to declaration) of a type parameter.
                if (type.symbol) {
                    return symbolToTypeNode(type.symbol, context, SymbolFlags.Type);
                }
                const name = (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ?
                    (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?";
                return factory.createTypeReferenceNode(factory.createIdentifier(name), /*typeArguments*/ undefined);
            }
            if (type.flags & TypeFlags.Union && (type as UnionType).origin) {
                type = (type as UnionType).origin!;
            }
            if (type.flags & (TypeFlags.Union | TypeFlags.Intersection)) {
                const types = type.flags & TypeFlags.Union ? formatUnionTypes((type as UnionType).types, expandingEnum) : (type as IntersectionType).types;
                if (length(types) === 1) {
                    return typeToTypeNodeHelper(types[0], context);
                }
                const typeNodes = mapToTypeNodes(types, context, /*isBareList*/ true);
                if (typeNodes && typeNodes.length > 0) {
                    return type.flags & TypeFlags.Union ? factory.createUnionTypeNode(typeNodes) : factory.createIntersectionTypeNode(typeNodes);
                }
                else {
                    if (!context.encounteredError && !(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection)) {
                        context.encounteredError = true;
                    }
                    return undefined!; // TODO: GH#18217
                }
            }
            if (objectFlags & (ObjectFlags.Anonymous | ObjectFlags.Mapped)) {
                Debug.assert(!!(type.flags & TypeFlags.Object));
                // The type is an object literal type.
                return createAnonymousTypeNode(type as ObjectType);
            }
            if (type.flags & TypeFlags.Index) {
                const indexedType = (type as IndexType).type;
                context.approximateLength += 6;
                const indexTypeNode = typeToTypeNodeHelper(indexedType, context);
                return factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, indexTypeNode);
            }
            if (type.flags & TypeFlags.TemplateLiteral) {
                const texts = (type as TemplateLiteralType).texts;
                const types = (type as TemplateLiteralType).types;
                const templateHead = factory.createTemplateHead(texts[0]);
                const templateSpans = factory.createNodeArray(
                    map(types, (t, i) =>
                        factory.createTemplateLiteralTypeSpan(
                            typeToTypeNodeHelper(t, context),
                            (i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail)(texts[i + 1]),
                        )),
                );
                context.approximateLength += 2;
                return factory.createTemplateLiteralType(templateHead, templateSpans);
            }
            if (type.flags & TypeFlags.StringMapping) {
                const typeNode = typeToTypeNodeHelper((type as StringMappingType).type, context);
                return symbolToTypeNode((type as StringMappingType).symbol, context, SymbolFlags.Type, [typeNode]);
            }
            if (type.flags & TypeFlags.IndexedAccess) {
                const objectTypeNode = typeToTypeNodeHelper((type as IndexedAccessType).objectType, context);
                const indexTypeNode = typeToTypeNodeHelper((type as IndexedAccessType).indexType, context);
                context.approximateLength += 2;
                return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode);
            }
            if (type.flags & TypeFlags.Conditional) {
                return visitAndTransformType(type, type => conditionalTypeToTypeNode(type as ConditionalType));
            }
            if (type.flags & TypeFlags.Substitution) {
                const typeNode = typeToTypeNodeHelper((type as SubstitutionType).baseType, context);
                const noInferSymbol = isNoInferType(type) && getGlobalTypeSymbol("NoInfer" as __String, /*reportErrors*/ false);
                return noInferSymbol ? symbolToTypeNode(noInferSymbol, context, SymbolFlags.Type, [typeNode]) : typeNode;
            }

            return Debug.fail("Should be unreachable.");

            function conditionalTypeToTypeNode(type: ConditionalType) {
                const checkTypeNode = typeToTypeNodeHelper(type.checkType, context);
                context.approximateLength += 15;
                if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && type.root.isDistributive && !(type.checkType.flags & TypeFlags.TypeParameter)) {
                    const newParam = createTypeParameter(createSymbol(SymbolFlags.TypeParameter, "T" as __String));
                    const name = typeParameterToName(newParam, context);
                    const newTypeVariable = factory.createTypeReferenceNode(name);
                    context.approximateLength += 37; // 15 each for two added conditionals, 7 for an added infer type
                    const newMapper = prependTypeMapping(type.root.checkType, newParam, type.mapper);
                    const saveInferTypeParameters = context.inferTypeParameters;
                    context.inferTypeParameters = type.root.inferTypeParameters;
                    const extendsTypeNode = typeToTypeNodeHelper(instantiateType(type.root.extendsType, newMapper), context);
                    context.inferTypeParameters = saveInferTypeParameters;
                    const trueTypeNode = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type.root.node.trueType), newMapper));
                    const falseTypeNode = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type.root.node.falseType), newMapper));

                    // outermost conditional makes `T` a type parameter, allowing the inner conditionals to be distributive
                    // second conditional makes `T` have `T & checkType` substitution, so it is correctly usable as the checkType
                    // inner conditional runs the check the user provided on the check type (distributively) and returns the result
                    // checkType extends infer T ? T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never : never;
                    // this is potentially simplifiable to
                    // checkType extends infer T ? T extends checkType & extendsType<T> ? trueType<T> : falseType<T> : never;
                    // but that may confuse users who read the output more.
                    // On the other hand,
                    // checkType extends infer T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never;
                    // may also work with `infer ... extends ...` in, but would produce declarations only compatible with the latest TS.
                    return factory.createConditionalTypeNode(
                        checkTypeNode,
                        factory.createInferTypeNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, factory.cloneNode(newTypeVariable.typeName) as Identifier)),
                        factory.createConditionalTypeNode(
                            factory.createTypeReferenceNode(factory.cloneNode(name)),
                            typeToTypeNodeHelper(type.checkType, context),
                            factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode),
                            factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
                        ),
                        factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
                    );
                }
                const saveInferTypeParameters = context.inferTypeParameters;
                context.inferTypeParameters = type.root.inferTypeParameters;
                const extendsTypeNode = typeToTypeNodeHelper(type.extendsType, context);
                context.inferTypeParameters = saveInferTypeParameters;
                const trueTypeNode = typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type));
                const falseTypeNode = typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type));
                return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode);
            }

            function typeToTypeNodeOrCircularityElision(type: Type) {
                if (type.flags & TypeFlags.Union) {
                    if (context.visitedTypes?.has(getTypeId(type))) {
                        if (!(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {
                            context.encounteredError = true;
                            context.tracker?.reportCyclicStructureError?.();
                        }
                        return createElidedInformationPlaceholder(context);
                    }
                    return visitAndTransformType(type, type => typeToTypeNodeHelper(type, context));
                }
                return typeToTypeNodeHelper(type, context);
            }

            function isMappedTypeHomomorphic(type: MappedType) {
                return !!getHomomorphicTypeVariable(type);
            }

            function isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type: MappedType) {
                return !!type.target && isMappedTypeHomomorphic(type.target as MappedType) && !isMappedTypeHomomorphic(type);
            }

            function createMappedTypeNodeFromType(type: MappedType) {
                Debug.assert(!!(type.flags & TypeFlags.Object));
                const readonlyToken = type.declaration.readonlyToken ? factory.createToken(type.declaration.readonlyToken.kind) as ReadonlyKeyword | PlusToken | MinusToken : undefined;
                const questionToken = type.declaration.questionToken ? factory.createToken(type.declaration.questionToken.kind) as QuestionToken | PlusToken | MinusToken : undefined;
                let appropriateConstraintTypeNode: TypeNode;
                let newTypeVariable: TypeReferenceNode | undefined;
                let templateType = getTemplateTypeFromMappedType(type);
                const typeParameter = getTypeParameterFromMappedType(type);
                // If the mapped type isn't `keyof` constraint-declared, _but_ still has modifiers preserved, and its naive instantiation won't preserve modifiers because its constraint isn't `keyof` constrained, we have work to do
                const needsModifierPreservingWrapper = !isMappedTypeWithKeyofConstraintDeclaration(type)
                    && !(getModifiersTypeFromMappedType(type).flags & TypeFlags.Unknown)
                    && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams
                    && !(getConstraintTypeFromMappedType(type).flags & TypeFlags.TypeParameter && getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type))?.flags! & TypeFlags.Index);
                if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                    // We have a { [P in keyof T]: X }
                    // We do this to ensure we retain the toplevel keyof-ness of the type which may be lost due to keyof distribution during `getConstraintTypeFromMappedType`
                    if (isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type) && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams) {
                        const newConstraintParam = createTypeParameter(createSymbol(SymbolFlags.TypeParameter, "T" as __String));
                        const name = typeParameterToName(newConstraintParam, context);
                        const target = type.target as MappedType;
                        newTypeVariable = factory.createTypeReferenceNode(name);
                        templateType = instantiateType(
                            getTemplateTypeFromMappedType(target),
                            makeArrayTypeMapper([getTypeParameterFromMappedType(target), getModifiersTypeFromMappedType(target)], [typeParameter, newConstraintParam]),
                        );
                    }
                    appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context));
                }
                else if (needsModifierPreservingWrapper) {
                    // So, step 1: new type variable
                    const newParam = createTypeParameter(createSymbol(SymbolFlags.TypeParameter, "T" as __String));
                    const name = typeParameterToName(newParam, context);
                    newTypeVariable = factory.createTypeReferenceNode(name);
                    // step 2: make that new type variable itself the constraint node, making the mapped type `{[K in T_1]: Template}`
                    appropriateConstraintTypeNode = newTypeVariable;
                }
                else {
                    appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context);
                }
                const typeParameterNode = typeParameterToDeclarationWithConstraint(typeParameter, context, appropriateConstraintTypeNode);

                // nameType and templateType nodes have to be in the new scope
                const cleanup = enterNewScope(context, type.declaration, /*expandedParams*/ undefined, [getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter))]);
                const nameTypeNode = type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type)!, context) : undefined;
                const templateTypeNode = typeToTypeNodeHelper(removeMissingType(templateType, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), context);
                cleanup();

                const mappedTypeNode = factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, /*members*/ undefined);
                context.approximateLength += 10;
                const result = setEmitFlags(mappedTypeNode, EmitFlags.SingleLine);
                if (isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type) && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams) {
                    // homomorphic mapped type with a non-homomorphic naive inlining
                    // wrap it with a conditional like `SomeModifiersType extends infer U ? {..the mapped type...} : never` to ensure the resulting
                    // type stays homomorphic
                    const originalConstraint = instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(context, (type.declaration.typeParameter.constraint! as TypeOperatorNode).type) as TypeParameter) || unknownType, type.mapper);
                    return factory.createConditionalTypeNode(
                        typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context),
                        factory.createInferTypeNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, factory.cloneNode(newTypeVariable!.typeName) as Identifier, originalConstraint.flags & TypeFlags.Unknown ? undefined : typeToTypeNodeHelper(originalConstraint, context))),
                        result,
                        factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
                    );
                }
                else if (needsModifierPreservingWrapper) {
                    // and step 3: once the mapped type is reconstructed, create a `ConstraintType extends infer T_1 extends keyof ModifiersType ? {[K in T_1]: Template} : never`
                    // subtly different from the `keyof` constraint case, by including the `keyof` constraint on the `infer` type parameter, it doesn't rely on the constraint type being itself
                    // constrained to a `keyof` type to preserve its modifier-preserving behavior. This is all basically because we preserve modifiers for a wider set of mapped types than
                    // just homomorphic ones.
                    return factory.createConditionalTypeNode(
                        typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context),
                        factory.createInferTypeNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, factory.cloneNode(newTypeVariable!.typeName) as Identifier, factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context)))),
                        result,
                        factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
                    );
                }
                return result;
            }

            function createAnonymousTypeNode(type: ObjectType, forceClassExpansion = false, forceExpansion = false): TypeNode {
                const typeId = type.id;
                const symbol = type.symbol;
                if (symbol) {
                    const isInstantiationExpressionType = !!(getObjectFlags(type) & ObjectFlags.InstantiationExpressionType);
                    if (isInstantiationExpressionType) {
                        const instantiationExpressionType = type as InstantiationExpressionType;
                        const existing = instantiationExpressionType.node;
                        //  instantiationExpressionType.node is unreliable for constituents of unions and intersections.
                        // declare const Err: typeof ErrImpl & (<T>() => T);
                        // type ErrAlias<U> = typeof Err<U>;
                        // declare const e: ErrAlias<number>;
                        // ErrAlias<number> = typeof Err<number> = typeof ErrImpl & (<number>() => number)
                        // The problem is each constituent of the intersection will be associated with typeof Err<number>
                        // And when extracting a type for typeof ErrImpl from typeof Err<number> does not make sense.
                        if (isTypeQueryNode(existing) && getTypeFromTypeNode(context, existing) === type) {
                            const typeNode = syntacticNodeBuilder.tryReuseExistingTypeNode(context, existing);
                            if (typeNode) {
                                return typeNode;
                            }
                        }
                        if (context.visitedTypes?.has(typeId)) {
                            return createElidedInformationPlaceholder(context);
                        }
                        return visitAndTransformType(type, createTypeNodeFromObjectType);
                    }
                    const isInstanceType = isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value;
                    if (isJSConstructor(symbol.valueDeclaration)) {
                        // Instance and static types share the same symbol; only add 'typeof' for the static side.
                        return symbolToTypeNode(symbol, context, isInstanceType);
                    }
                    // Always use 'typeof T' for type of class, enum, and module objects
                    else if (
                        !forceExpansion &&
                        (symbol.flags & SymbolFlags.Class
                                && !forceClassExpansion
                                && !getBaseTypeVariableOfClass(symbol)
                                && !(symbol.valueDeclaration
                                    && isClassLike(symbol.valueDeclaration)
                                    && context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral
                                    && (!isClassDeclaration(symbol.valueDeclaration)
                                        || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible))
                            || symbol.flags & (SymbolFlags.Enum | SymbolFlags.ValueModule)
                            || shouldWriteTypeOfFunctionSymbol())
                    ) {
                        if (shouldExpandType(type, context)) {
                            context.depth += 1;
                        }
                        else {
                            return symbolToTypeNode(symbol, context, isInstanceType);
                        }
                    }
                    if (context.visitedTypes?.has(typeId)) {
                        // If type is an anonymous type literal in a type alias declaration, use type alias name
                        const typeAlias = getTypeAliasForTypeLiteral(type);
                        if (typeAlias) {
                            // The specified symbol flags need to be reinterpreted as type flags
                            return symbolToTypeNode(typeAlias, context, SymbolFlags.Type);
                        }
                        else {
                            return createElidedInformationPlaceholder(context);
                        }
                    }
                    else {
                        return visitAndTransformType(type, createTypeNodeFromObjectType);
                    }
                }
                else {
                    // Anonymous types without a symbol are never circular.
                    return createTypeNodeFromObjectType(type);
                }
                function shouldWriteTypeOfFunctionSymbol() {
                    const isStaticMethodSymbol = !!(symbol.flags & SymbolFlags.Method) && // typeof static method
                        some(symbol.declarations, declaration => isStatic(declaration) && !isLateBindableIndexSignature(getNameOfDeclaration(declaration)!));
                    const isNonLocalFunctionSymbol = !!(symbol.flags & SymbolFlags.Function) &&
                        (symbol.parent || // is exported function symbol
                            forEach(symbol.declarations, declaration => declaration.parent.kind === SyntaxKind.SourceFile || declaration.parent.kind === SyntaxKind.ModuleBlock));
                    if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                        // typeof is allowed only for static/non local functions
                        return (!!(context.flags & NodeBuilderFlags.UseTypeOfFunction) || (context.visitedTypes?.has(typeId))) && // it is type of the symbol uses itself recursively
                            (!(context.flags & NodeBuilderFlags.UseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration)); // And the build is going to succeed without visibility error or there is no structural fallback allowed
                    }
                }
            }

            function visitAndTransformType<T extends Type>(type: T, transform: (type: T) => TypeNode) {
                const typeId = type.id;
                const isConstructorObject = getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & SymbolFlags.Class;
                const id = getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference & T).node ? "N" + getNodeId((type as TypeReference & T).node!) :
                    type.flags & TypeFlags.Conditional ? "N" + getNodeId((type as ConditionalType & T).root.node) :
                    type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :
                    undefined;
                // Since instantiations of the same anonymous type have the same symbol, tracking symbols instead
                // of types allows us to catch circular references to instantiations of the same anonymous type
                if (!context.visitedTypes) {
                    context.visitedTypes = new Set();
                }
                if (id && !context.symbolDepth) {
                    context.symbolDepth = new Map();
                }

                // Don't rely on type cache if we're expand a type, because we need to compute `canIncreaseExpansionDepth`.
                const links = context.maxExpansionDepth >= 0 ? undefined : context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration);
                const key = `${getTypeId(type)}|${context.flags}|${context.internalFlags}`;
                if (links) {
                    links.serializedTypes ||= new Map();
                }
                const cachedResult = links?.serializedTypes?.get(key);
                if (cachedResult) {
                    // TODO:: check if we instead store late painted statements associated with this?
                    cachedResult.trackedSymbols?.forEach(
                        ([symbol, enclosingDeclaration, meaning]) =>
                            context.tracker.trackSymbol(
                                symbol,
                                enclosingDeclaration,
                                meaning,
                            ),
                    );
                    if (cachedResult.truncating) {
                        context.truncating = true;
                    }
                    context.approximateLength += cachedResult.addedLength;
                    return deepCloneOrReuseNode(cachedResult.node);
                }

                let depth: number | undefined;
                if (id) {
                    depth = context.symbolDepth!.get(id) || 0;
                    if (depth > 10) {
                        return createElidedInformationPlaceholder(context);
                    }
                    context.symbolDepth!.set(id, depth + 1);
                }
                context.visitedTypes.add(typeId);
                const prevTrackedSymbols = context.trackedSymbols;
                context.trackedSymbols = undefined;
                const startLength = context.approximateLength;
                const result = transform(type);
                const addedLength = context.approximateLength - startLength;
                if (!context.reportedDiagnostic && !context.encounteredError) {
                    links?.serializedTypes?.set(key, {
                        node: result,
                        truncating: context.truncating,
                        addedLength,
                        trackedSymbols: context.trackedSymbols,
                    });
                }
                context.visitedTypes.delete(typeId);
                if (id) {
                    context.symbolDepth!.set(id, depth!);
                }
                context.trackedSymbols = prevTrackedSymbols;
                return result;

                function deepCloneOrReuseNode<T extends Node>(node: T): T {
                    if (!nodeIsSynthesized(node) && getParseTreeNode(node) === node) {
                        return node;
                    }
                    return setTextRange(context, factory.cloneNode(visitEachChildWorker(node, deepCloneOrReuseNode, /*context*/ undefined, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node);
                }

                function deepCloneOrReuseNodes(
                    nodes: NodeArray<Node> | undefined,
                    visitor: Visitor,
                    test?: (node: Node) => boolean,
                    start?: number,
                    count?: number,
                ): NodeArray<Node> | undefined {
                    if (nodes && nodes.length === 0) {
                        // Ensure we explicitly make a copy of an empty array; visitNodes will not do this unless the array has elements,
                        // which can lead to us reusing the same empty NodeArray more than once within the same AST during type noding.
                        return setTextRangeWorker(factory.createNodeArray(/*elements*/ undefined, nodes.hasTrailingComma), nodes);
                    }
                    return visitNodes(nodes, visitor, test, start, count);
                }
            }

            function createTypeNodeFromObjectType(type: ObjectType): TypeNode {
                if (isGenericMappedType(type) || (type as MappedType).containsError) {
                    return createMappedTypeNodeFromType(type as MappedType);
                }
                const resolved = resolveStructuredTypeMembers(type);
                if (!resolved.properties.length && !resolved.indexInfos.length) {
                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                        context.approximateLength += 2;
                        return setEmitFlags(factory.createTypeLiteralNode(/*members*/ undefined), EmitFlags.SingleLine);
                    }

                    if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                        const signature = resolved.callSignatures[0];
                        const signatureNode = signatureToSignatureDeclarationHelper(signature, SyntaxKind.FunctionType, context) as FunctionTypeNode;
                        return signatureNode;
                    }

                    if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                        const signature = resolved.constructSignatures[0];
                        const signatureNode = signatureToSignatureDeclarationHelper(signature, SyntaxKind.ConstructorType, context) as ConstructorTypeNode;
                        return signatureNode;
                    }
                }

                const abstractSignatures = filter(resolved.constructSignatures, signature => !!(signature.flags & SignatureFlags.Abstract));
                if (some(abstractSignatures)) {
                    const types = map(abstractSignatures, getOrCreateTypeFromSignature);
                    // count the number of type elements excluding abstract constructors
                    const typeElementCount = resolved.callSignatures.length +
                        (resolved.constructSignatures.length - abstractSignatures.length) +
                        resolved.indexInfos.length +
                        // exclude `prototype` when writing a class expression as a type literal, as per
                        // the logic in `createTypeNodesFromResolvedType`.
                        (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ?
                            countWhere(resolved.properties, p => !(p.flags & SymbolFlags.Prototype)) :
                            length(resolved.properties));
                    // don't include an empty object literal if there were no other static-side
                    // properties to write, i.e. `abstract class C { }` becomes `abstract new () => {}`
                    // and not `(abstract new () => {}) & {}`
                    if (typeElementCount) {
                        // create a copy of the object type without any abstract construct signatures.
                        types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved));
                    }
                    return typeToTypeNodeHelper(getIntersectionType(types), context);
                }

                const restoreFlags = saveRestoreFlags(context);
                context.flags |= NodeBuilderFlags.InObjectTypeLiteral;
                const members = createTypeNodesFromResolvedType(resolved);
                restoreFlags();
                const typeLiteralNode = factory.createTypeLiteralNode(members);
                context.approximateLength += 2;
                setEmitFlags(typeLiteralNode, (context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine);
                return typeLiteralNode;
            }

            function typeReferenceToTypeNode(type: TypeReference) {
                let typeArguments: readonly Type[] = getTypeArguments(type);
                if (type.target === globalArrayType || type.target === globalReadonlyArrayType) {
                    if (context.flags & NodeBuilderFlags.WriteArrayAsGenericType) {
                        const typeArgumentNode = typeToTypeNodeHelper(typeArguments[0], context);
                        return factory.createTypeReferenceNode(type.target === globalArrayType ? "Array" : "ReadonlyArray", [typeArgumentNode]);
                    }
                    const elementType = typeToTypeNodeHelper(typeArguments[0], context);
                    const arrayType = factory.createArrayTypeNode(elementType);
                    return type.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, arrayType);
                }
                else if (type.target.objectFlags & ObjectFlags.Tuple) {
                    typeArguments = sameMap(typeArguments, (t, i) => removeMissingType(t, !!((type.target as TupleType).elementFlags[i] & ElementFlags.Optional)));
                    if (typeArguments.length > 0) {
                        const arity = getTypeReferenceArity(type);
                        const tupleConstituentNodes = mapToTypeNodes(typeArguments.slice(0, arity), context);
                        if (tupleConstituentNodes) {
                            const { labeledElementDeclarations } = type.target as TupleType;
                            for (let i = 0; i < tupleConstituentNodes.length; i++) {
                                const flags = (type.target as TupleType).elementFlags[i];
                                const labeledElementDeclaration = labeledElementDeclarations?.[i];

                                if (labeledElementDeclaration) {
                                    tupleConstituentNodes[i] = factory.createNamedTupleMember(
                                        flags & ElementFlags.Variable ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined,
                                        factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))),
                                        flags & ElementFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                                        flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) :
                                            tupleConstituentNodes[i],
                                    );
                                }
                                else {
                                    tupleConstituentNodes[i] = flags & ElementFlags.Variable ? factory.createRestTypeNode(flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :
                                        flags & ElementFlags.Optional ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) :
                                        tupleConstituentNodes[i];
                                }
                            }
                            const tupleTypeNode = setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), EmitFlags.SingleLine);
                            return (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode;
                        }
                    }
                    if (context.encounteredError || (context.flags & NodeBuilderFlags.AllowEmptyTuple)) {
                        const tupleTypeNode = setEmitFlags(factory.createTupleTypeNode([]), EmitFlags.SingleLine);
                        return (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode;
                    }
                    context.encounteredError = true;
                    return undefined!; // TODO: GH#18217
                }
                else if (
                    context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral &&
                    type.symbol.valueDeclaration &&
                    isClassLike(type.symbol.valueDeclaration) &&
                    !isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)
                ) {
                    return createAnonymousTypeNode(type);
                }
                else {
                    const outerTypeParameters = type.target.outerTypeParameters;
                    let i = 0;
                    let resultType: TypeReferenceNode | ImportTypeNode | undefined;
                    if (outerTypeParameters) {
                        const length = outerTypeParameters.length;
                        while (i < length) {
                            // Find group of type arguments for type parameters with the same declaring container.
                            const start = i;
                            const parent = getParentSymbolOfTypeParameter(outerTypeParameters[i])!;
                            do {
                                i++;
                            }
                            while (i < length && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);
                            // When type parameters are their own type arguments for the whole group (i.e. we have
                            // the default outer type arguments), we don't show the group.
                            if (!rangeEquals(outerTypeParameters, typeArguments, start, i)) {
                                const typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);
                                const restoreFlags = saveRestoreFlags(context);
                                context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;
                                const ref = symbolToTypeNode(parent, context, SymbolFlags.Type, typeArgumentSlice) as TypeReferenceNode | ImportTypeNode;
                                restoreFlags();
                                resultType = !resultType ? ref : appendReferenceToType(resultType, ref as TypeReferenceNode);
                            }
                        }
                    }
                    let typeArgumentNodes: readonly TypeNode[] | undefined;
                    if (typeArguments.length > 0) {
                        let typeParameterCount = 0;
                        if (type.target.typeParameters) {
                            typeParameterCount = Math.min(type.target.typeParameters.length, typeArguments.length);

                            // Maybe we should do this for more types, but for now we only elide type arguments that are
                            // identical to their associated type parameters' defaults for `Iterable`, `IterableIterator`,
                            // `AsyncIterable`, and `AsyncIterableIterator` to provide backwards-compatible .d.ts emit due
                            // to each now having three type parameters instead of only one.
                            if (
                                isReferenceToType(type, getGlobalIterableType(/*reportErrors*/ false)) ||
                                isReferenceToType(type, getGlobalIterableIteratorType(/*reportErrors*/ false)) ||
                                isReferenceToType(type, getGlobalAsyncIterableType(/*reportErrors*/ false)) ||
                                isReferenceToType(type, getGlobalAsyncIterableIteratorType(/*reportErrors*/ false))
                            ) {
                                if (
                                    !type.node || !isTypeReferenceNode(type.node) || !type.node.typeArguments ||
                                    type.node.typeArguments.length < typeParameterCount
                                ) {
                                    while (typeParameterCount > 0) {
                                        const typeArgument = typeArguments[typeParameterCount - 1];
                                        const typeParameter = type.target.typeParameters[typeParameterCount - 1];
                                        const defaultType = getDefaultFromTypeParameter(typeParameter);
                                        if (!defaultType || !isTypeIdenticalTo(typeArgument, defaultType)) {
                                            break;
                                        }
                                        typeParameterCount--;
                                    }
                                }
                            }
                        }

                        typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context);
                    }
                    const restoreFlags = saveRestoreFlags(context);
                    context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;
                    const finalRef = symbolToTypeNode(type.symbol, context, SymbolFlags.Type, typeArgumentNodes);
                    restoreFlags();
                    return !resultType ? finalRef : appendReferenceToType(resultType, finalRef as TypeReferenceNode);
                }
            }

            function appendReferenceToType(root: TypeReferenceNode | ImportTypeNode, ref: TypeReferenceNode): TypeReferenceNode | ImportTypeNode {
                if (isImportTypeNode(root)) {
                    // first shift type arguments
                    let typeArguments = root.typeArguments;
                    let qualifier = root.qualifier;
                    if (qualifier) {
                        if (isIdentifier(qualifier)) {
                            if (typeArguments !== getIdentifierTypeArguments(qualifier)) {
                                qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments);
                            }
                        }
                        else {
                            if (typeArguments !== getIdentifierTypeArguments(qualifier.right)) {
                                qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments));
                            }
                        }
                    }
                    typeArguments = ref.typeArguments;
                    // then move qualifiers
                    const ids = getAccessStack(ref);
                    for (const id of ids) {
                        qualifier = qualifier ? factory.createQualifiedName(qualifier, id) : id;
                    }
                    return factory.updateImportTypeNode(
                        root,
                        root.argument,
                        root.attributes,
                        qualifier,
                        typeArguments,
                        root.isTypeOf,
                    );
                }
                else {
                    // first shift type arguments
                    let typeArguments = root.typeArguments;
                    let typeName = root.typeName;
                    if (isIdentifier(typeName)) {
                        if (typeArguments !== getIdentifierTypeArguments(typeName)) {
                            typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments);
                        }
                    }
                    else {
                        if (typeArguments !== getIdentifierTypeArguments(typeName.right)) {
                            typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments));
                        }
                    }
                    typeArguments = ref.typeArguments;
                    // then move qualifiers
                    const ids = getAccessStack(ref);
                    for (const id of ids) {
                        typeName = factory.createQualifiedName(typeName, id);
                    }
                    return factory.updateTypeReferenceNode(
                        root,
                        typeName,
                        typeArguments,
                    );
                }
            }

            function getAccessStack(ref: TypeReferenceNode): Identifier[] {
                let state = ref.typeName;
                const ids = [];
                while (!isIdentifier(state)) {
                    ids.unshift(state.right);
                    state = state.left;
                }
                ids.unshift(state);
                return ids;
            }

            function indexInfoToObjectComputedNamesOrSignatureDeclaration(indexInfo: IndexInfo, context: NodeBuilderContext, typeNode: TypeNode | undefined): [IndexSignatureDeclaration] | PropertySignature[] {
                if (indexInfo.components) {
                    // Index info is derived from object or class computed property names (plus explicit named members) - we can clone those instead of writing out the result computed index signature
                    const allComponentComputedNamesSerializable = every(indexInfo.components, e => {
                        return !!(e.name && isComputedPropertyName(e.name) && isEntityNameExpression(e.name.expression) && context.enclosingDeclaration && isEntityNameVisible(e.name.expression, context.enclosingDeclaration, /*shouldComputeAliasToMakeVisible*/ false)?.accessibility === SymbolAccessibility.Accessible);
                    });
                    if (allComponentComputedNamesSerializable) {
                        // Only use computed name serialization form if all components are visible and take the `a.b.c` form
                        const newComponents = filter(indexInfo.components, e => {
                            // skip late bound props that contribute to the index signature - they'll be created by property creation anyway
                            return !hasLateBindableName(e);
                        });
                        return map(newComponents, e => {
                            // Still need to track visibility even if we've already checked it to paint references as used
                            trackComputedName(e.name.expression as EntityNameExpression, context.enclosingDeclaration, context);
                            return setTextRange(
                                context,
                                factory.createPropertySignature(
                                    indexInfo.isReadonly ? [factory.createModifier(SyntaxKind.ReadonlyKeyword)] : undefined,
                                    e.name,
                                    (isPropertySignature(e) || isPropertyDeclaration(e) || isMethodSignature(e) || isMethodDeclaration(e) || isGetAccessor(e) || isSetAccessor(e)) && e.questionToken ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                                    typeNode || typeToTypeNodeHelper(getTypeOfSymbol(e.symbol), context),
                                ),
                                e,
                            );
                        });
                    }
                }
                return [indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, typeNode)];
            }

            function createTypeNodesFromResolvedType(resolvedType: ResolvedType): TypeElement[] | undefined {
                if (checkTruncationLength(context)) {
                    context.out.truncated = true;
                    if (context.flags & NodeBuilderFlags.NoTruncation) {
                        return [addSyntheticTrailingComment(factory.createNotEmittedTypeElement(), SyntaxKind.MultiLineCommentTrivia, "elided")];
                    }
                    return [factory.createPropertySignature(/*modifiers*/ undefined, "...", /*questionToken*/ undefined, /*type*/ undefined)];
                }
                context.typeStack.push(-1);
                const typeElements: TypeElement[] = [];
                for (const signature of resolvedType.callSignatures) {
                    typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKind.CallSignature, context) as CallSignatureDeclaration);
                }
                for (const signature of resolvedType.constructSignatures) {
                    if (signature.flags & SignatureFlags.Abstract) continue;
                    typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKind.ConstructSignature, context) as ConstructSignatureDeclaration);
                }
                for (const info of resolvedType.indexInfos) {
                    typeElements.push(...indexInfoToObjectComputedNamesOrSignatureDeclaration(info, context, resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(context) : undefined));
                }

                const properties = resolvedType.properties;
                if (!properties) {
                    context.typeStack.pop();
                    return typeElements;
                }

                let i = 0;
                for (const propertySymbol of properties) {
                    if (isExpanding(context) && propertySymbol.flags & SymbolFlags.Prototype) {
                        continue;
                    }
                    i++;
                    if (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral) {
                        if (propertySymbol.flags & SymbolFlags.Prototype) {
                            continue;
                        }
                        if (getDeclarationModifierFlagsFromSymbol(propertySymbol) & (ModifierFlags.Private | ModifierFlags.Protected) && context.tracker.reportPrivateInBaseOfClassExpression) {
                            context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName));
                        }
                    }
                    if (checkTruncationLength(context) && (i + 2 < properties.length - 1)) {
                        context.out.truncated = true;
                        if (context.flags & NodeBuilderFlags.NoTruncation) {
                            const typeElement = typeElements.pop()!;
                            typeElements.push(addSyntheticTrailingComment(typeElement, SyntaxKind.MultiLineCommentTrivia, `... ${properties.length - i} more elided ...`));
                        }
                        else {
                            typeElements.push(factory.createPropertySignature(/*modifiers*/ undefined, `... ${properties.length - i} more ...`, /*questionToken*/ undefined, /*type*/ undefined));
                        }
                        addPropertyToElementList(properties[properties.length - 1], context, typeElements);
                        break;
                    }
                    addPropertyToElementList(propertySymbol, context, typeElements);
                }
                context.typeStack.pop();
                return typeElements.length ? typeElements : undefined;
            }
        }

        function createElidedInformationPlaceholder(context: NodeBuilderContext) {
            context.approximateLength += 3;
            if (!(context.flags & NodeBuilderFlags.NoTruncation)) {
                return factory.createTypeReferenceNode(factory.createIdentifier("..."), /*typeArguments*/ undefined);
            }
            return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.AnyKeyword), SyntaxKind.MultiLineCommentTrivia, "elided");
        }

        function shouldUsePlaceholderForProperty(propertySymbol: Symbol, context: NodeBuilderContext) {
            // Use placeholders for reverse mapped types we've either
            // (1) already descended into, or
            // (2) are nested reverse mappings within a mapping over a non-anonymous type, or
            // (3) are deeply nested properties that originate from the same mapped type.
            // Condition (2) is a restriction mostly just to
            // reduce the blowup in printback size from doing, eg, a deep reverse mapping over `Window`.
            // Since anonymous types usually come from expressions, this allows us to preserve the output
            // for deep mappings which likely come from expressions, while truncating those parts which
            // come from mappings over library functions.
            // Condition (3) limits printing of possibly infinitely deep reverse mapped types.
            const depth = 3;
            return !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped)
                && (
                    contains(context.reverseMappedStack, propertySymbol as ReverseMappedSymbol)
                    || (
                        context.reverseMappedStack?.[0]
                        && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlags.Anonymous)
                    )
                    || isDeeplyNestedReverseMappedTypeProperty()
                );
            function isDeeplyNestedReverseMappedTypeProperty() {
                if ((context.reverseMappedStack?.length ?? 0) < depth) {
                    return false;
                }
                for (let i = 0; i < depth; i++) {
                    const prop = context.reverseMappedStack![context.reverseMappedStack!.length - 1 - i];
                    if (prop.links.mappedType.symbol !== (propertySymbol as ReverseMappedSymbol).links.mappedType.symbol) {
                        return false;
                    }
                }
                return true;
            }
        }

        function addPropertyToElementList(propertySymbol: Symbol, context: NodeBuilderContext, typeElements: TypeElement[]) {
            const propertyIsReverseMapped = !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped);
            const propertyType = shouldUsePlaceholderForProperty(propertySymbol, context) ?
                anyType : getNonMissingTypeOfSymbol(propertySymbol);
            const saveEnclosingDeclaration = context.enclosingDeclaration;
            context.enclosingDeclaration = undefined;
            if (context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.escapedName)) {
                if (propertySymbol.declarations) {
                    const decl = first(propertySymbol.declarations);
                    if (hasLateBindableName(decl)) {
                        if (isBinaryExpression(decl)) {
                            const name = getNameOfDeclaration(decl);
                            if (name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression)) {
                                trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context);
                            }
                        }
                        else {
                            trackComputedName(decl.name.expression, saveEnclosingDeclaration, context);
                        }
                    }
                }
                else {
                    context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol));
                }
            }
            context.enclosingDeclaration = propertySymbol.valueDeclaration || propertySymbol.declarations?.[0] || saveEnclosingDeclaration;
            const propertyName = getPropertyNameNodeForSymbol(propertySymbol, context);
            context.enclosingDeclaration = saveEnclosingDeclaration;
            context.approximateLength += symbolName(propertySymbol).length + 1;

            if (propertySymbol.flags & SymbolFlags.Accessor) {
                const writeType = getWriteTypeOfSymbol(propertySymbol);
                if (propertyType !== writeType && !isErrorType(propertyType) && !isErrorType(writeType)) {
                    const symbolMapper = getSymbolLinks(propertySymbol).mapper;
                    const getterDeclaration = getDeclarationOfKind<GetAccessorDeclaration>(propertySymbol, SyntaxKind.GetAccessor)!;
                    const getterSignature = getSignatureFromDeclaration(getterDeclaration);
                    typeElements.push(
                        setCommentRange(
                            context,
                            signatureToSignatureDeclarationHelper(symbolMapper ? instantiateSignature(getterSignature, symbolMapper) : getterSignature, SyntaxKind.GetAccessor, context, { name: propertyName }) as GetAccessorDeclaration,
                            getterDeclaration,
                        ),
                    );
                    const setterDeclaration = getDeclarationOfKind<SetAccessorDeclaration>(propertySymbol, SyntaxKind.SetAccessor)!;
                    const setterSignature = getSignatureFromDeclaration(setterDeclaration);
                    typeElements.push(
                        setCommentRange(
                            context,
                            signatureToSignatureDeclarationHelper(symbolMapper ? instantiateSignature(setterSignature, symbolMapper) : setterSignature, SyntaxKind.SetAccessor, context, { name: propertyName }) as SetAccessorDeclaration,
                            setterDeclaration,
                        ),
                    );
                    return;
                }
            }

            const optionalToken = propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined;
            if (propertySymbol.flags & (SymbolFlags.Function | SymbolFlags.Method) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol)) {
                const signatures = getSignaturesOfType(filterType(propertyType, t => !(t.flags & TypeFlags.Undefined)), SignatureKind.Call);
                for (const signature of signatures) {
                    const methodDeclaration = signatureToSignatureDeclarationHelper(signature, SyntaxKind.MethodSignature, context, { name: propertyName, questionToken: optionalToken }) as MethodSignature;
                    typeElements.push(preserveCommentsOn(methodDeclaration, signature.declaration || propertySymbol.valueDeclaration));
                }
                if (signatures.length || !optionalToken) {
                    return;
                }
            }
            let propertyTypeNode: TypeNode;
            if (shouldUsePlaceholderForProperty(propertySymbol, context)) {
                propertyTypeNode = createElidedInformationPlaceholder(context);
            }
            else {
                if (propertyIsReverseMapped) {
                    context.reverseMappedStack ||= [];
                    context.reverseMappedStack.push(propertySymbol as ReverseMappedSymbol);
                }
                propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, /*declaration*/ undefined, propertyType, propertySymbol) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
                if (propertyIsReverseMapped) {
                    context.reverseMappedStack!.pop();
                }
            }

            const modifiers = isReadonlySymbol(propertySymbol) ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined;
            if (modifiers) {
                context.approximateLength += 9;
            }
            const propertySignature = factory.createPropertySignature(
                modifiers,
                propertyName,
                optionalToken,
                propertyTypeNode,
            );

            typeElements.push(preserveCommentsOn(propertySignature, propertySymbol.valueDeclaration));

            function preserveCommentsOn<T extends Node>(node: T, range: Node | undefined) {
                const jsdocPropertyTag = propertySymbol.declarations?.find((d): d is JSDocPropertyTag => d.kind === SyntaxKind.JSDocPropertyTag);
                if (jsdocPropertyTag) {
                    const commentText = getTextOfJSDocComment(jsdocPropertyTag.comment);
                    if (commentText) {
                        setSyntheticLeadingComments(node, [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]);
                    }
                }
                else if (range) {
                    // Copy comments to node for declaration emit
                    setCommentRange(context, node, range);
                }
                return node;
            }
        }

        function setCommentRange<T extends Node>(context: NodeBuilderContext, node: T, range: Node): T {
            if (context.enclosingFile && context.enclosingFile === getSourceFileOfNode(range)) {
                // Copy comments to node for declaration emit
                return setCommentRangeWorker(node, range);
            }
            return node;
        }

        function mapToTypeNodes(types: readonly Type[] | undefined, context: NodeBuilderContext, isBareList?: boolean): TypeNode[] | undefined {
            if (some(types)) {
                if (checkTruncationLength(context)) {
                    context.out.truncated = true;
                    if (!isBareList) {
                        return [
                            context.flags & NodeBuilderFlags.NoTruncation
                                ? addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.AnyKeyword), SyntaxKind.MultiLineCommentTrivia, "elided")
                                : factory.createTypeReferenceNode("...", /*typeArguments*/ undefined),
                        ];
                    }
                    else if (types.length > 2) {
                        return [
                            typeToTypeNodeHelper(types[0], context),
                            context.flags & NodeBuilderFlags.NoTruncation
                                ? addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.AnyKeyword), SyntaxKind.MultiLineCommentTrivia, `... ${types.length - 2} more elided ...`)
                                : factory.createTypeReferenceNode(`... ${types.length - 2} more ...`, /*typeArguments*/ undefined),
                            typeToTypeNodeHelper(types[types.length - 1], context),
                        ];
                    }
                }
                const mayHaveNameCollisions = !(context.flags & NodeBuilderFlags.UseFullyQualifiedType);
                /** Map from type reference identifier text to [type, index in `result` where the type node is] */
                const seenNames = mayHaveNameCollisions ? createMultiMap<__String, [Type, number]>() : undefined;
                const result: TypeNode[] = [];
                let i = 0;
                for (const type of types) {
                    i++;
                    if (checkTruncationLength(context) && (i + 2 < types.length - 1)) {
                        context.out.truncated = true;
                        result.push(
                            context.flags & NodeBuilderFlags.NoTruncation
                                ? addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.AnyKeyword), SyntaxKind.MultiLineCommentTrivia, `... ${types.length - i} more elided ...`)
                                : factory.createTypeReferenceNode(`... ${types.length - i} more ...`, /*typeArguments*/ undefined),
                        );
                        const typeNode = typeToTypeNodeHelper(types[types.length - 1], context);
                        if (typeNode) {
                            result.push(typeNode);
                        }
                        break;
                    }
                    context.approximateLength += 2; // Account for whitespace + separator
                    const typeNode = typeToTypeNodeHelper(type, context);
                    if (typeNode) {
                        result.push(typeNode);
                        if (seenNames && isIdentifierTypeReference(typeNode)) {
                            seenNames.add(typeNode.typeName.escapedText, [type, result.length - 1]);
                        }
                    }
                }

                if (seenNames) {
                    // To avoid printing types like `[Foo, Foo]` or `Bar & Bar` where
                    // occurrences of the same name actually come from different
                    // namespaces, go through the single-identifier type reference nodes
                    // we just generated, and see if any names were generated more than
                    // once while referring to different types. If so, regenerate the
                    // type node for each entry by that name with the
                    // `UseFullyQualifiedType` flag enabled.
                    const restoreFlags = saveRestoreFlags(context);
                    context.flags |= NodeBuilderFlags.UseFullyQualifiedType;
                    seenNames.forEach(types => {
                        if (!arrayIsHomogeneous(types, ([a], [b]) => typesAreSameReference(a, b))) {
                            for (const [type, resultIndex] of types) {
                                result[resultIndex] = typeToTypeNodeHelper(type, context);
                            }
                        }
                    });
                    restoreFlags();
                }

                return result;
            }
        }

        function typesAreSameReference(a: Type, b: Type): boolean {
            return a === b
                || !!a.symbol && a.symbol === b.symbol
                || !!a.aliasSymbol && a.aliasSymbol === b.aliasSymbol;
        }

        function indexInfoToIndexSignatureDeclarationHelper(indexInfo: IndexInfo, context: NodeBuilderContext, typeNode: TypeNode | undefined): IndexSignatureDeclaration {
            const name = getNameFromIndexInfo(indexInfo) || "x";
            const indexerTypeNode = typeToTypeNodeHelper(indexInfo.keyType, context);

            const indexingParameter = factory.createParameterDeclaration(
                /*modifiers*/ undefined,
                /*dotDotDotToken*/ undefined,
                name,
                /*questionToken*/ undefined,
                indexerTypeNode,
                /*initializer*/ undefined,
            );
            if (!typeNode) {
                typeNode = typeToTypeNodeHelper(indexInfo.type || anyType, context);
            }
            if (!indexInfo.type && !(context.flags & NodeBuilderFlags.AllowEmptyIndexInfoType)) {
                context.encounteredError = true;
            }
            context.approximateLength += name.length + 4;
            return factory.createIndexSignature(
                indexInfo.isReadonly ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined,
                [indexingParameter],
                typeNode,
            );
        }

        interface SignatureToSignatureDeclarationOptions {
            modifiers?: readonly Modifier[];
            name?: PropertyName;
            questionToken?: QuestionToken;
        }

        function signatureToSignatureDeclarationHelper(signature: Signature, kind: SignatureDeclaration["kind"], context: NodeBuilderContext, options?: SignatureToSignatureDeclarationOptions): SignatureDeclaration {
            let typeParameters: TypeParameterDeclaration[] | undefined;
            let typeArguments: TypeNode[] | undefined;

            const expandedParams = getExpandedParameters(signature, /*skipUnionExpanding*/ true)[0];
            const cleanup = enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper);
            context.approximateLength += 3; // Usually a signature contributes a few more characters than this, but 3 is the minimum

            if (context.flags & NodeBuilderFlags.WriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters) {
                typeArguments = signature.target.typeParameters.map(parameter => typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context));
            }
            else {
                typeParameters = signature.typeParameters && signature.typeParameters.map(parameter => typeParameterToDeclaration(parameter, context));
            }

            const restoreFlags = saveRestoreFlags(context);
            context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; // SuppressAnyReturnType should only apply to the signature `return` position
            // If the expanded parameter list had a variadic in a non-trailing position, don't expand it
            const parameters = (some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams).map(parameter => symbolToParameterDeclaration(parameter, context, kind === SyntaxKind.Constructor));
            const thisParameter = context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context);
            if (thisParameter) {
                parameters.unshift(thisParameter);
            }
            restoreFlags();

            const returnTypeNode = serializeReturnTypeForSignature(context, signature);

            let modifiers = options?.modifiers;
            if ((kind === SyntaxKind.ConstructorType) && signature.flags & SignatureFlags.Abstract) {
                const flags = modifiersToFlags(modifiers);
                modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlags.Abstract);
            }

            const node = kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) :
                kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) :
                kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), options?.questionToken, typeParameters, parameters, returnTypeNode) :
                kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(modifiers, /*asteriskToken*/ undefined, options?.name ?? factory.createIdentifier(""), /*questionToken*/ undefined, typeParameters, parameters, returnTypeNode, /*body*/ undefined) :
                kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(modifiers, parameters, /*body*/ undefined) :
                kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, returnTypeNode, /*body*/ undefined) :
                kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, /*body*/ undefined) :
                kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) :
                kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(parameters, returnTypeNode) :
                kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :
                kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :
                kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, /*asteriskToken*/ undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, /*body*/ undefined) :
                kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, /*asteriskToken*/ undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) :
                kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken*/ undefined, factory.createBlock([])) :
                Debug.assertNever(kind);

            if (typeArguments) {
                node.typeArguments = factory.createNodeArray(typeArguments);
            }
            if (signature.declaration?.kind === SyntaxKind.JSDocSignature && signature.declaration.parent.kind === SyntaxKind.JSDocOverloadTag) {
                const comment = getTextOfNode(signature.declaration.parent.parent, /*includeTrivia*/ true).slice(2, -2).split(/\r\n|\n|\r/).map(line => line.replace(/^\s+/, " ")).join("\n");
                addSyntheticLeadingComment(node, SyntaxKind.MultiLineCommentTrivia, comment, /*hasTrailingNewLine*/ true);
            }

            cleanup?.();
            return node;
        }

        function createRecoveryBoundary(context: NodeBuilderContext) {
            if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                cancellationToken.throwIfCancellationRequested();
            }

            let trackedSymbols: TrackedSymbol[];
            let unreportedErrors: (() => void)[];
            let hadError = false;
            const oldTracker = context.tracker;
            const oldTrackedSymbols = context.trackedSymbols;
            context.trackedSymbols = undefined;
            const oldEncounteredError = context.encounteredError;
            context.tracker = new SymbolTrackerImpl(context, {
                ...oldTracker.inner,
                reportCyclicStructureError() {
                    markError(() => oldTracker.reportCyclicStructureError());
                },
                reportInaccessibleThisError() {
                    markError(() => oldTracker.reportInaccessibleThisError());
                },
                reportInaccessibleUniqueSymbolError() {
                    markError(() => oldTracker.reportInaccessibleUniqueSymbolError());
                },
                reportLikelyUnsafeImportRequiredError(specifier) {
                    markError(() => oldTracker.reportLikelyUnsafeImportRequiredError(specifier));
                },
                reportNonSerializableProperty(name) {
                    markError(() => oldTracker.reportNonSerializableProperty(name));
                },
                reportPrivateInBaseOfClassExpression(propertyName) {
                    markError(() => oldTracker.reportPrivateInBaseOfClassExpression(propertyName));
                },
                trackSymbol(sym, decl, meaning) {
                    (trackedSymbols ??= []).push([sym, decl, meaning]);
                    return false;
                },
                moduleResolverHost: context.tracker.moduleResolverHost,
            }, context.tracker.moduleResolverHost);

            return {
                startRecoveryScope,
                finalizeBoundary,
                markError,
                hadError: () => hadError,
            };
            function markError(unreportedError?: () => void) {
                hadError = true;
                if (unreportedError) {
                    (unreportedErrors ??= []).push(unreportedError);
                }
            }

            function startRecoveryScope() {
                const trackedSymbolsTop = trackedSymbols?.length ?? 0;
                const unreportedErrorsTop = unreportedErrors?.length ?? 0;
                return () => {
                    hadError = false;
                    // Reset the tracked symbols to before the error
                    if (trackedSymbols) {
                        trackedSymbols.length = trackedSymbolsTop;
                    }
                    if (unreportedErrors) {
                        unreportedErrors.length = unreportedErrorsTop;
                    }
                };
            }

            function finalizeBoundary() {
                context.tracker = oldTracker;
                context.trackedSymbols = oldTrackedSymbols;
                context.encounteredError = oldEncounteredError;

                unreportedErrors?.forEach(fn => fn());
                if (hadError) {
                    return false;
                }
                trackedSymbols?.forEach(
                    ([symbol, enclosingDeclaration, meaning]) =>
                        context.tracker.trackSymbol(
                            symbol,
                            enclosingDeclaration,
                            meaning,
                        ),
                );
                return true;
            }
        }

        function enterNewScope(
            context: NodeBuilderContext,
            declaration: IntroducesNewScopeNode | ConditionalTypeNode | undefined,
            expandedParams: readonly Symbol[] | undefined,
            typeParameters: readonly TypeParameter[] | undefined,
            originalParameters?: readonly Symbol[] | undefined,
            mapper?: TypeMapper,
        ) {
            const cleanupContext = cloneNodeBuilderContext(context);
            // For regular function/method declarations, the enclosing declaration will already be signature.declaration,
            // so this is a no-op, but for arrow functions and function expressions, the enclosing declaration will be
            // the declaration that the arrow function / function expression is assigned to.
            //
            // If the parameters or return type include "typeof globalThis.paramName", using the wrong scope will lead
            // us to believe that we can emit "typeof paramName" instead, even though that would refer to the parameter,
            // not the global. Make sure we are in the right scope by changing the enclosingDeclaration to the function.
            //
            // We can't use the declaration directly; it may be in another file and so we may lose access to symbols
            // accessible to the current enclosing declaration, or gain access to symbols not accessible to the current
            // enclosing declaration. To keep this chain accurate, insert a fake scope into the chain which makes the
            // function's parameters visible.
            let cleanupParams: (() => void) | undefined;
            let cleanupTypeParams: (() => void) | undefined;
            const oldEnclosingDecl = context.enclosingDeclaration;
            const oldMapper = context.mapper;
            if (mapper) {
                context.mapper = mapper;
            }
            if (context.enclosingDeclaration && declaration) {
                // As a performance optimization, reuse the same fake scope within this chain.
                // This is especially needed when we are working on an excessively deep type;
                // if we don't do this, then we spend all of our time adding more and more
                // scopes that need to be searched in isSymbolAccessible later. Since all we
                // really want to do is to mark certain names as unavailable, we can just keep
                // all of the names we're introducing in one large table and push/pop from it as
                // needed; isSymbolAccessible will walk upward and find the closest "fake" scope,
                // which will conveniently report on any and all faked scopes in the chain.
                //
                // It'd likely be better to store this somewhere else for isSymbolAccessible, but
                // since that API _only_ uses the enclosing declaration (and its parents), this is
                // seems like the best way to inject names into that search process.
                //
                // Note that we only check the most immediate enclosingDeclaration; the only place we
                // could potentially add another fake scope into the chain is right here, so we don't
                // traverse all ancestors.
                cleanupParams = !some(expandedParams) ? undefined : pushFakeScope(
                    "params",
                    add => {
                        if (!expandedParams) return;
                        for (let pIndex = 0; pIndex < expandedParams.length; pIndex++) {
                            const param = expandedParams[pIndex];
                            const originalParam = originalParameters?.[pIndex];
                            if (originalParameters && originalParam !== param) {
                                // Can't reference parameters that come from an expansion
                                add(param.escapedName, unknownSymbol);
                                // Can't reference the original expanded parameter either
                                if (originalParam) {
                                    add(originalParam.escapedName, unknownSymbol);
                                }
                            }
                            else if (
                                !forEach(param.declarations, d => {
                                    if (isParameter(d) && isBindingPattern(d.name)) {
                                        bindPattern(d.name);
                                        return true;
                                    }
                                    return undefined;
                                    function bindPattern(p: BindingPattern): void {
                                        forEach(p.elements, e => {
                                            switch (e.kind) {
                                                case SyntaxKind.OmittedExpression:
                                                    return;
                                                case SyntaxKind.BindingElement:
                                                    return bindElement(e);
                                                default:
                                                    return Debug.assertNever(e);
                                            }
                                        });
                                    }
                                    function bindElement(e: BindingElement): void {
                                        if (isBindingPattern(e.name)) {
                                            return bindPattern(e.name);
                                        }
                                        const symbol = getSymbolOfDeclaration(e);
                                        add(symbol.escapedName, symbol);
                                    }
                                })
                            ) {
                                add(param.escapedName, param);
                            }
                        }
                    },
                );

                if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && some(typeParameters)) {
                    cleanupTypeParams = pushFakeScope(
                        "typeParams",
                        add => {
                            for (const typeParam of typeParameters ?? emptyArray) {
                                const typeParamName = typeParameterToName(typeParam, context).escapedText;
                                add(typeParamName, typeParam.symbol);
                            }
                        },
                    );
                }

                function pushFakeScope(kind: "params" | "typeParams", addAll: (addSymbol: (name: __String, symbol: Symbol) => void) => void) {
                    // We only ever need to look two declarations upward.
                    Debug.assert(context.enclosingDeclaration);
                    let existingFakeScope: Node | undefined;
                    if (getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration === kind) {
                        existingFakeScope = context.enclosingDeclaration;
                    }
                    else if (context.enclosingDeclaration.parent && getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration === kind) {
                        existingFakeScope = context.enclosingDeclaration.parent;
                    }
                    Debug.assertOptionalNode(existingFakeScope, isBlock);

                    const locals = existingFakeScope?.locals ?? createSymbolTable();
                    let newLocals: __String[] | undefined;
                    let oldLocals: { name: __String; oldSymbol: Symbol; }[] | undefined;
                    addAll((name, symbol) => {
                        // Add cleanup information only if we don't own the fake scope
                        if (existingFakeScope) {
                            const oldSymbol = locals.get(name);
                            if (!oldSymbol) {
                                newLocals = append(newLocals, name);
                            }
                            else {
                                oldLocals = append(oldLocals, { name, oldSymbol });
                            }
                        }
                        locals.set(name, symbol);
                    });

                    if (!existingFakeScope) {
                        // Use a Block for this; the type of the node doesn't matter so long as it
                        // has locals, and this is cheaper/easier than using a function-ish Node.
                        const fakeScope = factory.createBlock(emptyArray);
                        getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind;
                        fakeScope.locals = locals;

                        setParent(fakeScope, context.enclosingDeclaration);
                        context.enclosingDeclaration = fakeScope;
                    }
                    else {
                        // We did not create the current scope, so we have to clean it up
                        return function undo() {
                            forEach(newLocals, s => locals.delete(s));
                            forEach(oldLocals, s => locals.set(s.name, s.oldSymbol));
                        };
                    }
                }
            }

            return () => {
                cleanupParams?.();
                cleanupTypeParams?.();
                cleanupContext();
                context.enclosingDeclaration = oldEnclosingDecl;
                context.mapper = oldMapper;
            };
        }

        function tryGetThisParameterDeclaration(signature: Signature, context: NodeBuilderContext) {
            if (signature.thisParameter) {
                return symbolToParameterDeclaration(signature.thisParameter, context);
            }
            if (signature.declaration && isInJSFile(signature.declaration)) {
                const thisTag = getJSDocThisTag(signature.declaration);
                if (thisTag && thisTag.typeExpression) {
                    return factory.createParameterDeclaration(
                        /*modifiers*/ undefined,
                        /*dotDotDotToken*/ undefined,
                        "this",
                        /*questionToken*/ undefined,
                        typeToTypeNodeHelper(getTypeFromTypeNode(context, thisTag.typeExpression), context),
                    );
                }
            }
        }

        function typeParameterToDeclarationWithConstraint(type: TypeParameter, context: NodeBuilderContext, constraintNode: TypeNode | undefined): TypeParameterDeclaration {
            const restoreFlags = saveRestoreFlags(context);
            context.flags &= ~NodeBuilderFlags.WriteTypeParametersInQualifiedName; // Avoids potential infinite loop when building for a claimspace with a generic
            const modifiers = factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type));
            const name = typeParameterToName(type, context);
            const defaultParameter = getDefaultFromTypeParameter(type);
            const defaultParameterNode = defaultParameter && typeToTypeNodeHelper(defaultParameter, context);
            restoreFlags();
            return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode);
        }

        function typeToTypeNodeHelperWithPossibleReusableTypeNode(type: Type, typeNode: TypeNode | undefined, context: NodeBuilderContext) {
            return !canPossiblyExpandType(type, context) && typeNode && getTypeFromTypeNode(context, typeNode) === type && syntacticNodeBuilder.tryReuseExistingTypeNode(context, typeNode)
                || typeToTypeNodeHelper(type, context);
        }

        function typeParameterToDeclaration(type: TypeParameter, context: NodeBuilderContext, constraint = getConstraintOfTypeParameter(type)): TypeParameterDeclaration {
            const constraintNode = constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type), context);
            return typeParameterToDeclarationWithConstraint(type, context, constraintNode);
        }

        function typePredicateToTypePredicateNodeHelper(typePredicate: TypePredicate, context: NodeBuilderContext): TypePredicateNode {
            const assertsModifier = typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?
                factory.createToken(SyntaxKind.AssertsKeyword) :
                undefined;
            const parameterName = typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?
                setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlags.NoAsciiEscaping) :
                factory.createThisTypeNode();
            const typeNode = typePredicate.type && typeToTypeNodeHelper(typePredicate.type, context);
            return factory.createTypePredicateNode(assertsModifier, parameterName, typeNode);
        }

        function getEffectiveParameterDeclaration(parameterSymbol: Symbol): ParameterDeclaration | JSDocParameterTag | undefined {
            const parameterDeclaration: ParameterDeclaration | JSDocParameterTag | undefined = getDeclarationOfKind<ParameterDeclaration>(parameterSymbol, SyntaxKind.Parameter);
            if (parameterDeclaration) {
                return parameterDeclaration;
            }
            if (!isTransientSymbol(parameterSymbol)) {
                return getDeclarationOfKind<JSDocParameterTag>(parameterSymbol, SyntaxKind.JSDocParameterTag);
            }
        }

        function symbolToParameterDeclaration(parameterSymbol: Symbol, context: NodeBuilderContext, preserveModifierFlags?: boolean): ParameterDeclaration {
            const parameterDeclaration = getEffectiveParameterDeclaration(parameterSymbol);

            const parameterType = getTypeOfSymbol(parameterSymbol);
            const parameterTypeNode = serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol);

            const modifiers = !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : undefined;
            const isRest = parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & CheckFlags.RestParameter;
            const dotDotDotToken = isRest ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined;
            const name = parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context);
            const isOptional = parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & CheckFlags.OptionalParameter;
            const questionToken = isOptional ? factory.createToken(SyntaxKind.QuestionToken) : undefined;
            const parameterNode = factory.createParameterDeclaration(
                modifiers,
                dotDotDotToken,
                name,
                questionToken,
                parameterTypeNode,
                /*initializer*/ undefined,
            );
            context.approximateLength += symbolName(parameterSymbol).length + 3;
            return parameterNode;
        }

        function parameterToParameterDeclarationName(parameterSymbol: Symbol, parameterDeclaration: ParameterDeclaration | JSDocParameterTag | undefined, context: NodeBuilderContext) {
            return parameterDeclaration ? parameterDeclaration.name ?
                parameterDeclaration.name.kind === SyntaxKind.Identifier ? setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlags.NoAsciiEscaping) :
                    parameterDeclaration.name.kind === SyntaxKind.QualifiedName ? setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlags.NoAsciiEscaping) :
                    cloneBindingName(parameterDeclaration.name) :
                symbolName(parameterSymbol) :
                symbolName(parameterSymbol);

            function cloneBindingName(node: BindingName): BindingName {
                return elideInitializerAndSetEmitFlags(node) as BindingName;
                function elideInitializerAndSetEmitFlags(node: Node): Node {
                    if (context.tracker.canTrackSymbol && isComputedPropertyName(node) && isLateBindableName(node)) {
                        trackComputedName(node.expression, context.enclosingDeclaration, context);
                    }
                    let visited = visitEachChildWorker(node, elideInitializerAndSetEmitFlags, /*context*/ undefined, /*nodesVisitor*/ undefined, elideInitializerAndSetEmitFlags);
                    if (isBindingElement(visited)) {
                        visited = factory.updateBindingElement(
                            visited,
                            visited.dotDotDotToken,
                            visited.propertyName,
                            visited.name,
                            /*initializer*/ undefined,
                        );
                    }
                    if (!nodeIsSynthesized(visited)) {
                        visited = factory.cloneNode(visited);
                    }
                    return setEmitFlags(visited, EmitFlags.SingleLine | EmitFlags.NoAsciiEscaping);
                }
            }
        }

        function trackComputedName(accessExpression: EntityNameOrEntityNameExpression, enclosingDeclaration: Node | undefined, context: NodeBuilderContext) {
            if (!context.tracker.canTrackSymbol) return;
            // get symbol of the first identifier of the entityName
            const firstIdentifier = getFirstIdentifier(accessExpression);
            const name = resolveName(enclosingDeclaration, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.ExportValue, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
            if (name) {
                context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlags.Value);
            }
            else {
                // Name does not resolve at target location, track symbol at dest location (should be inaccessible)
                const fallback = resolveName(firstIdentifier, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.ExportValue, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
                if (fallback) {
                    context.tracker.trackSymbol(fallback, enclosingDeclaration, SymbolFlags.Value);
                }
            }
        }

        function lookupSymbolChain(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, yieldModuleSymbol?: boolean) {
            context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning);
            return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol);
        }

        function lookupSymbolChainWorker(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, yieldModuleSymbol?: boolean) {
            // Try to get qualified name if the symbol is not a type parameter and there is an enclosing declaration.
            let chain: Symbol[];
            const isTypeParameter = symbol.flags & SymbolFlags.TypeParameter;
            if (!isTypeParameter && (context.enclosingDeclaration || context.flags & NodeBuilderFlags.UseFullyQualifiedType) && !(context.internalFlags & InternalNodeBuilderFlags.DoNotIncludeSymbolChain)) {
                chain = Debug.checkDefined(getSymbolChain(symbol, meaning, /*endOfChain*/ true));
                Debug.assert(chain && chain.length > 0);
            }
            else {
                chain = [symbol];
            }
            return chain;

            /** @param endOfChain Set to false for recursive calls; non-recursive calls should always output something. */
            function getSymbolChain(symbol: Symbol, meaning: SymbolFlags, endOfChain: boolean): Symbol[] | undefined {
                let accessibleSymbolChain = getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & NodeBuilderFlags.UseOnlyExternalAliasing));
                let parentSpecifiers: (string | undefined)[];
                if (
                    !accessibleSymbolChain ||
                    needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))
                ) {
                    // Go up and add our parent.
                    const parents = getContainersOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol, context.enclosingDeclaration, meaning);
                    if (length(parents)) {
                        parentSpecifiers = parents!.map(symbol =>
                            some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)
                                ? getSpecifierForModuleSymbol(symbol, context)
                                : undefined
                        );
                        const indices = parents!.map((_, i) => i);
                        indices.sort(sortByBestName);
                        const sortedParents = indices.map(i => parents![i]);
                        for (const parent of sortedParents) {
                            const parentChain = getSymbolChain(parent, getQualifiedLeftMeaning(meaning), /*endOfChain*/ false);
                            if (parentChain) {
                                if (
                                    parent.exports && parent.exports.get(InternalSymbolName.ExportEquals) &&
                                    getSymbolIfSameReference(parent.exports.get(InternalSymbolName.ExportEquals)!, symbol)
                                ) {
                                    // parentChain root _is_ symbol - symbol is a module export=, so it kinda looks like it's own parent
                                    // No need to lookup an alias for the symbol in itself
                                    accessibleSymbolChain = parentChain;
                                    break;
                                }
                                accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [getAliasForSymbolInContainer(parent, symbol) || symbol]);
                                break;
                            }
                        }
                    }
                }

                if (accessibleSymbolChain) {
                    return accessibleSymbolChain;
                }
                if (
                    // If this is the last part of outputting the symbol, always output. The cases apply only to parent symbols.
                    endOfChain ||
                    // If a parent symbol is an anonymous type, don't write it.
                    !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral))
                ) {
                    // If a parent symbol is an external module, don't write it. (We prefer just `x` vs `"foo/bar".x`.)
                    if (!endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                        return;
                    }
                    return [symbol];
                }

                function sortByBestName(a: number, b: number) {
                    const specifierA = parentSpecifiers[a];
                    const specifierB = parentSpecifiers[b];
                    if (specifierA && specifierB) {
                        const isBRelative = pathIsRelative(specifierB);
                        if (pathIsRelative(specifierA) === isBRelative) {
                            // Both relative or both non-relative, sort by number of parts
                            return moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB);
                        }
                        if (isBRelative) {
                            // A is non-relative, B is relative: prefer A
                            return -1;
                        }
                        // A is relative, B is non-relative: prefer B
                        return 1;
                    }
                    return 0;
                }
            }
        }

        function typeParametersToTypeParameterDeclarations(symbol: Symbol, context: NodeBuilderContext) {
            let typeParameterNodes: NodeArray<TypeParameterDeclaration> | undefined;
            const targetSymbol = getTargetSymbol(symbol);
            if (targetSymbol.flags & (SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.TypeAlias)) {
                typeParameterNodes = factory.createNodeArray(map(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), tp => typeParameterToDeclaration(tp, context)));
            }
            return typeParameterNodes;
        }

        function lookupTypeParameterNodes(chain: Symbol[], index: number, context: NodeBuilderContext) {
            Debug.assert(chain && 0 <= index && index < chain.length);
            const symbol = chain[index];
            const symbolId = getSymbolId(symbol);
            if (context.typeParameterSymbolList?.has(symbolId)) {
                return undefined;
            }
            if (context.mustCreateTypeParameterSymbolList) {
                context.mustCreateTypeParameterSymbolList = false;
                context.typeParameterSymbolList = new Set(context.typeParameterSymbolList);
            }
            context.typeParameterSymbolList!.add(symbolId);
            let typeParameterNodes: readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined;
            if (context.flags & NodeBuilderFlags.WriteTypeParametersInQualifiedName && index < (chain.length - 1)) {
                const parentSymbol = symbol;
                const nextSymbol = chain[index + 1];
                if (getCheckFlags(nextSymbol) & CheckFlags.Instantiated) {
                    const params = getTypeParametersOfClassOrInterface(
                        parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol,
                    );
                    // NOTE: cast to TransientSymbol should be safe because only TransientSymbol can have CheckFlags.Instantiated
                    typeParameterNodes = mapToTypeNodes(map(params, t => getMappedType(t, (nextSymbol as TransientSymbol).links.mapper!)), context);
                }
                else {
                    typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context);
                }
            }
            return typeParameterNodes;
        }

        /**
         * Given A[B][C][D], finds A[B]
         */
        function getTopmostIndexedAccessType(top: IndexedAccessTypeNode): IndexedAccessTypeNode {
            if (isIndexedAccessTypeNode(top.objectType)) {
                return getTopmostIndexedAccessType(top.objectType);
            }
            return top;
        }

        function getSpecifierForModuleSymbol(symbol: Symbol, context: NodeBuilderContext, overrideImportMode?: ResolutionMode) {
            let file = getDeclarationOfKind<SourceFile>(symbol, SyntaxKind.SourceFile);
            if (!file) {
                const equivalentFileSymbol = firstDefined(symbol.declarations, d => getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol));
                if (equivalentFileSymbol) {
                    file = getDeclarationOfKind<SourceFile>(equivalentFileSymbol, SyntaxKind.SourceFile);
                }
            }
            if (file && file.moduleName !== undefined) {
                // Use the amd name if it is available
                return file.moduleName;
            }
            if (!file) {
                if (ambientModuleSymbolRegex.test(symbol.escapedName as string)) {
                    return (symbol.escapedName as string).substring(1, (symbol.escapedName as string).length - 1);
                }
            }
            if (!context.enclosingFile || !context.tracker.moduleResolverHost) {
                // If there's no context declaration, we can't lookup a non-ambient specifier, so we just use the symbol name
                if (ambientModuleSymbolRegex.test(symbol.escapedName as string)) {
                    return (symbol.escapedName as string).substring(1, (symbol.escapedName as string).length - 1);
                }
                return getSourceFileOfNode(getNonAugmentationDeclaration(symbol)!).fileName; // A resolver may not be provided for baselines and errors - in those cases we use the fileName in full
            }
            const enclosingDeclaration = getOriginalNode(context.enclosingDeclaration);
            const originalModuleSpecifier = canHaveModuleSpecifier(enclosingDeclaration) ? tryGetModuleSpecifierFromDeclaration(enclosingDeclaration) : undefined;
            const contextFile = context.enclosingFile;
            const resolutionMode = overrideImportMode
                || originalModuleSpecifier && host.getModeForUsageLocation(contextFile, originalModuleSpecifier)
                || contextFile && host.getDefaultResolutionModeForFile(contextFile);
            const cacheKey = createModeAwareCacheKey(contextFile.path, resolutionMode);
            const links = getSymbolLinks(symbol);
            let specifier = links.specifierCache && links.specifierCache.get(cacheKey);
            if (!specifier) {
                const isBundle = !!compilerOptions.outFile;
                // For declaration bundles, we need to generate absolute paths relative to the common source dir for imports,
                // just like how the declaration emitter does for the ambient module declarations - we can easily accomplish this
                // using the `baseUrl` compiler option (which we would otherwise never use in declaration emit) and a non-relative
                // specifier preference
                const { moduleResolverHost } = context.tracker;
                const specifierCompilerOptions = isBundle ? { ...compilerOptions, baseUrl: moduleResolverHost.getCommonSourceDirectory() } : compilerOptions;
                specifier = first(moduleSpecifiers.getModuleSpecifiers(
                    symbol,
                    checker,
                    specifierCompilerOptions,
                    contextFile,
                    moduleResolverHost,
                    {
                        importModuleSpecifierPreference: isBundle ? "non-relative" : "project-relative",
                        importModuleSpecifierEnding: isBundle ? "minimal"
                            : resolutionMode === ModuleKind.ESNext ? "js"
                            : undefined,
                    },
                    { overrideImportMode },
                ));
                links.specifierCache ??= new Map();
                links.specifierCache.set(cacheKey, specifier);
            }
            return specifier;
        }

        function symbolToEntityNameNode(symbol: Symbol): EntityName {
            const identifier = factory.createIdentifier(unescapeLeadingUnderscores(symbol.escapedName));
            return symbol.parent ? factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier;
        }

        function symbolToTypeNode(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, overrideTypeArguments?: readonly TypeNode[]): TypeNode {
            const chain = lookupSymbolChain(symbol, context, meaning, !(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope)); // If we're using aliases outside the current scope, dont bother with the module

            const isTypeOf = meaning === SymbolFlags.Value;
            if (some(chain[0].declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                // module is root, must use `ImportTypeNode`
                const nonRootParts = chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined;
                const typeParameterNodes = overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context);
                const contextFile = getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration));
                const targetFile = getSourceFileOfModule(chain[0]);
                let specifier: string | undefined;
                let attributes: ImportAttributes | undefined;
                if (getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Node16 || getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.NodeNext) {
                    // An `import` type directed at an esm format file is only going to resolve in esm mode - set the esm mode assertion
                    if (targetFile?.impliedNodeFormat === ModuleKind.ESNext && targetFile.impliedNodeFormat !== contextFile?.impliedNodeFormat) {
                        specifier = getSpecifierForModuleSymbol(chain[0], context, ModuleKind.ESNext);
                        attributes = factory.createImportAttributes(
                            factory.createNodeArray([
                                factory.createImportAttribute(
                                    factory.createStringLiteral("resolution-mode"),
                                    factory.createStringLiteral("import"),
                                ),
                            ]),
                        );
                    }
                }
                if (!specifier) {
                    specifier = getSpecifierForModuleSymbol(chain[0], context);
                }
                if (!(context.flags & NodeBuilderFlags.AllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Classic && specifier.includes("/node_modules/")) {
                    const oldSpecifier = specifier;
                    if (getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Node16 || getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.NodeNext) {
                        // We might be able to write a portable import type using a mode override; try specifier generation again, but with a different mode set
                        const swappedMode = contextFile?.impliedNodeFormat === ModuleKind.ESNext ? ModuleKind.CommonJS : ModuleKind.ESNext;
                        specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode);

                        if (specifier.includes("/node_modules/")) {
                            // Still unreachable :(
                            specifier = oldSpecifier;
                        }
                        else {
                            attributes = factory.createImportAttributes(
                                factory.createNodeArray([
                                    factory.createImportAttribute(
                                        factory.createStringLiteral("resolution-mode"),
                                        factory.createStringLiteral(swappedMode === ModuleKind.ESNext ? "import" : "require"),
                                    ),
                                ]),
                            );
                        }
                    }

                    if (!attributes) {
                        // If ultimately we can only name the symbol with a reference that dives into a `node_modules` folder, we should error
                        // since declaration files with these kinds of references are liable to fail when published :(
                        context.encounteredError = true;
                        if (context.tracker.reportLikelyUnsafeImportRequiredError) {
                            context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier);
                        }
                    }
                }
                const lit = factory.createLiteralTypeNode(factory.createStringLiteral(specifier));
                context.approximateLength += specifier.length + 10; // specifier + import("")
                if (!nonRootParts || isEntityName(nonRootParts)) {
                    if (nonRootParts) {
                        const lastId = isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right;
                        setIdentifierTypeArguments(lastId, /*typeArguments*/ undefined);
                    }
                    return factory.createImportTypeNode(lit, attributes, nonRootParts as EntityName, typeParameterNodes as readonly TypeNode[], isTypeOf);
                }
                else {
                    const splitNode = getTopmostIndexedAccessType(nonRootParts);
                    const qualifier = (splitNode.objectType as TypeReferenceNode).typeName;
                    return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes as readonly TypeNode[], isTypeOf), splitNode.indexType);
                }
            }

            const entityName = createAccessFromSymbolChain(chain, chain.length - 1, 0);
            if (isIndexedAccessTypeNode(entityName)) {
                return entityName; // Indexed accesses can never be `typeof`
            }
            if (isTypeOf) {
                return factory.createTypeQueryNode(entityName);
            }
            else {
                const lastId = isIdentifier(entityName) ? entityName : entityName.right;
                const lastTypeArgs = getIdentifierTypeArguments(lastId);
                setIdentifierTypeArguments(lastId, /*typeArguments*/ undefined);
                return factory.createTypeReferenceNode(entityName, lastTypeArgs as NodeArray<TypeNode>);
            }

            function createAccessFromSymbolChain(chain: Symbol[], index: number, stopper: number): EntityName | IndexedAccessTypeNode {
                const typeParameterNodes = index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context);
                const symbol = chain[index];
                const parent = chain[index - 1];

                let symbolName: string | undefined;
                if (index === 0) {
                    context.flags |= NodeBuilderFlags.InInitialEntityName;
                    symbolName = getNameOfSymbolAsWritten(symbol, context);
                    context.approximateLength += (symbolName ? symbolName.length : 0) + 1;
                    context.flags ^= NodeBuilderFlags.InInitialEntityName;
                }
                else {
                    if (parent && getExportsOfSymbol(parent)) {
                        const exports = getExportsOfSymbol(parent);
                        forEachEntry(exports, (ex, name) => {
                            if (getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name !== InternalSymbolName.ExportEquals) {
                                symbolName = unescapeLeadingUnderscores(name);
                                return true;
                            }
                        });
                    }
                }

                if (symbolName === undefined) {
                    const name = firstDefined(symbol.declarations, getNameOfDeclaration);
                    if (name && isComputedPropertyName(name) && isEntityName(name.expression)) {
                        const LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                        if (isEntityName(LHS)) {
                            return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression));
                        }
                        return LHS;
                    }
                    symbolName = getNameOfSymbolAsWritten(symbol, context);
                }
                context.approximateLength += symbolName.length + 1;

                if (
                    !(context.flags & NodeBuilderFlags.ForbidIndexedAccessSymbolReferences) && parent &&
                    getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.escapedName) &&
                    getSymbolIfSameReference(getMembersOfSymbol(parent).get(symbol.escapedName)!, symbol)
                ) {
                    // Should use an indexed access
                    const LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                    if (isIndexedAccessTypeNode(LHS)) {
                        return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)));
                    }
                    else {
                        return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes as readonly TypeNode[]), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)));
                    }
                }

                const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                identifier.symbol = symbol;

                if (index > stopper) {
                    const LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                    if (!isEntityName(LHS)) {
                        return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable");
                    }
                    return factory.createQualifiedName(LHS, identifier);
                }
                return identifier;
            }
        }

        function typeParameterShadowsOtherTypeParameterInScope(escapedName: __String, context: NodeBuilderContext, type: TypeParameter) {
            const result = resolveName(context.enclosingDeclaration, escapedName, SymbolFlags.Type, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
            if (result && result.flags & SymbolFlags.TypeParameter) {
                return result !== type.symbol;
            }
            return false;
        }

        function typeParameterToName(type: TypeParameter, context: NodeBuilderContext) {
            if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && context.typeParameterNames) {
                const cached = context.typeParameterNames.get(getTypeId(type));
                if (cached) {
                    return cached;
                }
            }
            let result = symbolToName(type.symbol, context, SymbolFlags.Type, /*expectsIdentifier*/ true);
            if (!(result.kind & SyntaxKind.Identifier)) {
                return factory.createIdentifier("(Missing type parameter)");
            }
            const decl = type.symbol?.declarations?.[0];
            if (decl && isTypeParameterDeclaration(decl)) {
                result = setTextRange(context, result, decl.name);
            }
            if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams) {
                const rawtext = result.escapedText as string;
                let i = context.typeParameterNamesByTextNextNameCount?.get(rawtext) || 0;
                let text = rawtext;
                while (context.typeParameterNamesByText?.has(text) || typeParameterShadowsOtherTypeParameterInScope(text as __String, context, type)) {
                    i++;
                    text = `${rawtext}_${i}`;
                }
                if (text !== rawtext) {
                    const typeArguments = getIdentifierTypeArguments(result);
                    result = factory.createIdentifier(text);
                    setIdentifierTypeArguments(result, typeArguments);
                }
                if (context.mustCreateTypeParametersNamesLookups) {
                    context.mustCreateTypeParametersNamesLookups = false;
                    context.typeParameterNames = new Map(context.typeParameterNames);
                    context.typeParameterNamesByTextNextNameCount = new Map(context.typeParameterNamesByTextNextNameCount);
                    context.typeParameterNamesByText = new Set(context.typeParameterNamesByText);
                }
                // avoiding iterations of the above loop turns out to be worth it when `i` starts to get large, so we cache the max
                // `i` we've used thus far, to save work later
                context.typeParameterNamesByTextNextNameCount!.set(rawtext, i);
                context.typeParameterNames!.set(getTypeId(type), result);
                context.typeParameterNamesByText!.add(text);
            }
            return result;
        }

        function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: true): Identifier;
        function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: false): EntityName;
        function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: boolean): EntityName {
            const chain = lookupSymbolChain(symbol, context, meaning);

            if (
                expectsIdentifier && chain.length !== 1
                && !context.encounteredError
                && !(context.flags & NodeBuilderFlags.AllowQualifiedNameInPlaceOfIdentifier)
            ) {
                context.encounteredError = true;
            }
            return createEntityNameFromSymbolChain(chain, chain.length - 1);

            function createEntityNameFromSymbolChain(chain: Symbol[], index: number): EntityName {
                const typeParameterNodes = lookupTypeParameterNodes(chain, index, context);
                const symbol = chain[index];

                if (index === 0) {
                    context.flags |= NodeBuilderFlags.InInitialEntityName;
                }
                const symbolName = getNameOfSymbolAsWritten(symbol, context);
                if (index === 0) {
                    context.flags ^= NodeBuilderFlags.InInitialEntityName;
                }

                const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                identifier.symbol = symbol;

                return index > 0 ? factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier;
            }
        }

        function symbolToExpression(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags) {
            const chain = lookupSymbolChain(symbol, context, meaning);

            return createExpressionFromSymbolChain(chain, chain.length - 1);

            function createExpressionFromSymbolChain(chain: Symbol[], index: number): Expression {
                const typeParameterNodes = lookupTypeParameterNodes(chain, index, context);
                const symbol = chain[index];

                if (index === 0) {
                    context.flags |= NodeBuilderFlags.InInitialEntityName;
                }
                let symbolName = getNameOfSymbolAsWritten(symbol, context);
                if (index === 0) {
                    context.flags ^= NodeBuilderFlags.InInitialEntityName;
                }
                let firstChar = symbolName.charCodeAt(0);

                if (isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                    const specifier = getSpecifierForModuleSymbol(symbol, context);
                    context.approximateLength += 2 + specifier.length; // "specifier"
                    return factory.createStringLiteral(specifier);
                }
                if (index === 0 || canUsePropertyAccess(symbolName, languageVersion)) {
                    const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                    if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                    identifier.symbol = symbol;
                    context.approximateLength += 1 + symbolName.length; // .symbolName
                    return index > 0 ? factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index - 1), identifier) : identifier;
                }
                else {
                    if (firstChar === CharacterCodes.openBracket) {
                        symbolName = symbolName.substring(1, symbolName.length - 1);
                        firstChar = symbolName.charCodeAt(0);
                    }
                    let expression: Expression | undefined;
                    if (isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlags.EnumMember)) {
                        const literalText = stripQuotes(symbolName).replace(/\\./g, s => s.substring(1));
                        context.approximateLength += literalText.length + 2; // "literalText"
                        expression = factory.createStringLiteral(literalText, firstChar === CharacterCodes.singleQuote);
                    }
                    else if (("" + +symbolName) === symbolName) {
                        context.approximateLength += symbolName.length; // +symbolName
                        expression = factory.createNumericLiteral(+symbolName);
                    }
                    if (!expression) {
                        const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                        if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                        identifier.symbol = symbol;
                        context.approximateLength += symbolName.length; // symbolName
                        expression = identifier;
                    }
                    context.approximateLength += 2; // []
                    return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain, index - 1), expression);
                }
            }
        }

        function isStringNamed(d: Declaration) {
            const name = getNameOfDeclaration(d);
            if (!name) {
                return false;
            }
            if (isComputedPropertyName(name)) {
                const type = checkExpression(name.expression);
                return !!(type.flags & TypeFlags.StringLike);
            }
            if (isElementAccessExpression(name)) {
                const type = checkExpression(name.argumentExpression);
                return !!(type.flags & TypeFlags.StringLike);
            }
            return isStringLiteral(name);
        }

        function isSingleQuotedStringNamed(d: Declaration) {
            const name = getNameOfDeclaration(d);
            return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, /*includeTrivia*/ false), "'")));
        }

        function getPropertyNameNodeForSymbol(symbol: Symbol, context: NodeBuilderContext) {
            const hashPrivateName = getClonedHashPrivateName(symbol);
            if (hashPrivateName) {
                return hashPrivateName;
            }
            const stringNamed = !!length(symbol.declarations) && every(symbol.declarations, isStringNamed);
            const singleQuote = !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed);
            const isMethod = !!(symbol.flags & SymbolFlags.Method);
            const fromNameType = getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod);
            if (fromNameType) {
                return fromNameType;
            }
            const rawName = unescapeLeadingUnderscores(symbol.escapedName);
            return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod);
        }

        // See getNameForSymbolFromNameType for a stringy equivalent
        function getPropertyNameNodeForSymbolFromNameType(symbol: Symbol, context: NodeBuilderContext, singleQuote: boolean, stringNamed: boolean, isMethod: boolean) {
            const nameType = getSymbolLinks(symbol).nameType;
            if (nameType) {
                if (nameType.flags & TypeFlags.StringOrNumberLiteral) {
                    const name = "" + (nameType as StringLiteralType | NumberLiteralType).value;
                    if (!isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name))) {
                        return factory.createStringLiteral(name, !!singleQuote);
                    }
                    if (isNumericLiteralName(name) && startsWith(name, "-")) {
                        return factory.createComputedPropertyName(factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-name)));
                    }
                    return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod);
                }
                if (nameType.flags & TypeFlags.UniqueESSymbol) {
                    return factory.createComputedPropertyName(symbolToExpression((nameType as UniqueESSymbolType).symbol, context, SymbolFlags.Value));
                }
            }
        }

        function cloneNodeBuilderContext(context: NodeBuilderContext) {
            // Make type parameters created within this context not consume the name outside this context
            // The symbol serializer ends up creating many sibling scopes that all need "separate" contexts when
            // it comes to naming things - within a normal `typeToTypeNode` call, the node builder only ever descends
            // through the type tree, so the only cases where we could have used distinct sibling scopes was when there
            // were multiple generic overloads with similar generated type parameter names
            // The effect:
            // When we write out
            // export const x: <T>(x: T) => T
            // export const y: <T>(x: T) => T
            // we write it out like that, rather than as
            // export const x: <T>(x: T) => T
            // export const y: <T_1>(x: T_1) => T_1
            const oldMustCreateTypeParameterSymbolList = context.mustCreateTypeParameterSymbolList;
            const oldMustCreateTypeParametersNamesLookups = context.mustCreateTypeParametersNamesLookups;
            context.mustCreateTypeParameterSymbolList = true;
            context.mustCreateTypeParametersNamesLookups = true;
            const oldTypeParameterNames = context.typeParameterNames;
            const oldTypeParameterNamesByText = context.typeParameterNamesByText;
            const oldTypeParameterNamesByTextNextNameCount = context.typeParameterNamesByTextNextNameCount;
            const oldTypeParameterSymbolList = context.typeParameterSymbolList;
            return () => {
                context.typeParameterNames = oldTypeParameterNames;
                context.typeParameterNamesByText = oldTypeParameterNamesByText;
                context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount;
                context.typeParameterSymbolList = oldTypeParameterSymbolList;
                context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList;
                context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups;
            };
        }

        function getDeclarationWithTypeAnnotation(symbol: Symbol, enclosingDeclaration?: Node | undefined) {
            return symbol.declarations && find(symbol.declarations, s => !!getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, n => n === enclosingDeclaration)));
        }

        function existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing: TypeNode, type: Type) {
            // In JS, you can say something like `Foo` and get a `Foo<any>` implicitly - we don't want to preserve that original `Foo` in these cases, though.
            if (!(getObjectFlags(type) & ObjectFlags.Reference)) return true;
            if (!isTypeReferenceNode(existing)) return true;
            // `type` is a reference type, and `existing` is a type reference node, but we still need to make sure they refer to the _same_ target type
            // before we go comparing their type argument counts.
            void getTypeFromTypeReference(existing); // call to ensure symbol is resolved
            const symbol = getNodeLinks(existing).resolvedSymbol;
            const existingTarget = symbol && getDeclaredTypeOfSymbol(symbol);
            if (!existingTarget || existingTarget !== (type as TypeReference).target) return true;
            return length(existing.typeArguments) >= getMinTypeArgumentCount((type as TypeReference).target.typeParameters);
        }

        function getEnclosingDeclarationIgnoringFakeScope(enclosingDeclaration: Node) {
            while (getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration) {
                enclosingDeclaration = enclosingDeclaration.parent;
            }
            return enclosingDeclaration;
        }
        /**
         * Serialize the checker type for the declaration without trying to go though the syntactic printer
         * Unlike `typeToTypeNodeHelper`, this handles setting up the `AllowUniqueESSymbolType` flag
         * so a `unique symbol` is returned when appropriate for the input symbol, rather than `typeof sym`
         */
        function serializeInferredTypeForDeclaration(symbol: Symbol, context: NodeBuilderContext, type: Type) {
            if (
                type.flags & TypeFlags.UniqueESSymbol &&
                type.symbol === symbol && (!context.enclosingDeclaration || some(symbol.declarations, d => getSourceFileOfNode(d) === context.enclosingFile))
            ) {
                context.flags |= NodeBuilderFlags.AllowUniqueESSymbolType;
            }

            const result = typeToTypeNodeHelper(type, context);
            return result;
        }
        /**
         * Serializes the type of the declaration by first trying to use the syntactic printer if possible and falling back to the checker type if not.
         * @param context - The node builder context. Any reused nodes are checked to be pulled from within the scope of the context's enclosingDeclaration.
         * @param declaration - The preferred declaration to pull existing type nodes from (the symbol will be used as a fallback to find any annotated declaration)
         * @param type - The type to write; an existing annotation must match this type if it's used, otherwise this is the type serialized as a new type node
         * @param symbol - The symbol is used both to find an existing annotation if declaration is not provided, and to determine if `unique symbol` should be printed
         */
        function serializeTypeForDeclaration(context: NodeBuilderContext, declaration: Declaration | undefined, type: Type, symbol: Symbol) {
            let result;
            const addUndefinedForParameter = declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration);
            const decl = declaration ?? symbol.valueDeclaration ?? getDeclarationWithTypeAnnotation(symbol) ?? symbol.declarations?.[0];
            if (!canPossiblyExpandType(type, context) && decl) {
                const restore = addSymbolTypeToContext(context, symbol, type);
                if (isAccessor(decl)) {
                    result = syntacticNodeBuilder.serializeTypeOfAccessor(decl, symbol, context);
                }
                else if (
                    hasInferredType(decl)
                    && !nodeIsSynthesized(decl)
                    && !(getObjectFlags(type) & ObjectFlags.RequiresWidening)
                ) {
                    result = syntacticNodeBuilder.serializeTypeOfDeclaration(decl, symbol, context);
                }
                restore();
            }
            if (!result) {
                if (addUndefinedForParameter) {
                    type = getOptionalType(type);
                }
                result = serializeInferredTypeForDeclaration(symbol, context, type);
            }
            return result ?? factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
        }

        function typeNodeIsEquivalentToType(annotatedDeclaration: Node | undefined, type: Type, typeFromTypeNode: Type) {
            if (typeFromTypeNode === type) {
                return true;
            }
            if (!annotatedDeclaration) {
                return false;
            }
            if ((isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken) {
                return getTypeWithFacts(type, TypeFacts.NEUndefined) === typeFromTypeNode;
            }
            if (isParameter(annotatedDeclaration) && hasEffectiveQuestionToken(annotatedDeclaration)) {
                return getTypeWithFacts(type, TypeFacts.NEUndefined) === typeFromTypeNode;
            }
            return false;
        }

        /**
         * Serializes the return type of the signature by first trying to use the syntactic printer if possible and falling back to the checker type if not.
         */
        function serializeReturnTypeForSignature(context: NodeBuilderContext, signature: Signature) {
            const suppressAny = context.flags & NodeBuilderFlags.SuppressAnyReturnType;
            const restoreFlags = saveRestoreFlags(context);
            if (suppressAny) context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; // suppress only toplevel `any`s
            let returnTypeNode: TypeNode | undefined;

            const returnType = getReturnTypeOfSignature(signature);
            if (!(suppressAny && isTypeAny(returnType))) {
                if (signature.declaration && !nodeIsSynthesized(signature.declaration) && !canPossiblyExpandType(returnType, context)) {
                    const declarationSymbol = getSymbolOfDeclaration(signature.declaration);
                    const restore = addSymbolTypeToContext(context, declarationSymbol, returnType);
                    returnTypeNode = syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, declarationSymbol, context);
                    restore();
                }
                if (!returnTypeNode) {
                    returnTypeNode = serializeInferredReturnTypeForSignature(context, signature, returnType);
                }
            }

            if (!returnTypeNode && !suppressAny) {
                returnTypeNode = factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
            }
            restoreFlags();
            return returnTypeNode;
        }

        /**
         * Serializes the checker type of the signature (does not use the syntactic printer)
         */
        function serializeInferredReturnTypeForSignature(context: NodeBuilderContext, signature: Signature, returnType: Type) {
            const oldSuppressReportInferenceFallback = context.suppressReportInferenceFallback;
            context.suppressReportInferenceFallback = true;
            const typePredicate = getTypePredicateOfSignature(signature);
            const returnTypeNode = typePredicate ?
                typePredicateToTypePredicateNodeHelper(context.mapper ? instantiateTypePredicate(typePredicate, context.mapper) : typePredicate, context) :
                typeToTypeNodeHelper(returnType, context);
            context.suppressReportInferenceFallback = oldSuppressReportInferenceFallback;
            return returnTypeNode;
        }

        function trackExistingEntityName<T extends EntityNameOrEntityNameExpression>(node: T, context: NodeBuilderContext, enclosingDeclaration = context.enclosingDeclaration) {
            let introducesError = false;
            const leftmost = getFirstIdentifier(node);
            if (isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right)))) {
                introducesError = true;
                return { introducesError, node };
            }
            const meaning = getMeaningOfEntityNameReference(node);
            let sym: Symbol | undefined;
            if (isThisIdentifier(leftmost)) {
                // `this` isn't a bindable identifier - skip resolution, find a relevant `this` symbol directly and avoid exhaustive scope traversal
                sym = getSymbolOfDeclaration(getThisContainer(leftmost, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false));
                if (isSymbolAccessible(sym, leftmost, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible) {
                    introducesError = true;
                    context.tracker.reportInaccessibleThisError();
                }
                return { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T };
            }
            sym = resolveEntityName(leftmost, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true);
            if (
                context.enclosingDeclaration &&
                !(sym && sym.flags & SymbolFlags.TypeParameter)
            ) {
                sym = getExportSymbolOfValueSymbolIfExported(sym);
                // Some declarations may be transplanted to a new location.
                // When this happens we need to make sure that the name has the same meaning at both locations
                // We also check for the unknownSymbol because when we create a fake scope some parameters may actually not be usable
                // either because they are the expanded rest parameter,
                // or because they are the newly added parameters from the tuple, which might have different meanings in the original context
                const symAtLocation = resolveEntityName(leftmost, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, context.enclosingDeclaration);
                if (
                    // Check for unusable parameters symbols
                    symAtLocation === unknownSymbol ||
                    // If the symbol is not found, but was not found in the original scope either we probably have an error, don't reuse the node
                    (symAtLocation === undefined && sym !== undefined) ||
                    // If the symbol is found both in declaration scope and in current scope then it should point to the same reference
                    (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym))
                ) {
                    // In isolated declaration we will not do rest parameter expansion so there is no need to report on these.
                    if (symAtLocation !== unknownSymbol) {
                        context.tracker.reportInferenceFallback(node);
                    }
                    introducesError = true;
                    return { introducesError, node, sym };
                }
                else {
                    sym = symAtLocation;
                }
            }

            if (sym) {
                // If a parameter is resolvable in the current context it is also visible, so no need to go to symbol accesibility
                if (
                    sym.flags & SymbolFlags.FunctionScopedVariable
                    && sym.valueDeclaration
                ) {
                    if (isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration)) {
                        return { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T };
                    }
                }
                if (
                    !(sym.flags & SymbolFlags.TypeParameter) && // Type parameters are visible in the current context if they are are resolvable
                    !isDeclarationName(node) &&
                    isSymbolAccessible(sym, enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible
                ) {
                    context.tracker.reportInferenceFallback(node);
                    introducesError = true;
                }
                else {
                    context.tracker.trackSymbol(sym, enclosingDeclaration, meaning);
                }
                return { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T };
            }

            return { introducesError, node };

            /**
             * Attaches a `.symbol` member to an identifier, cloning it to do so, so symbol information
             * is smuggled out for symbol display information.
             */
            function attachSymbolToLeftmostIdentifier(node: Node): Node {
                if (node === leftmost) {
                    const type = getDeclaredTypeOfSymbol(sym!);
                    const name = sym!.flags & SymbolFlags.TypeParameter ? typeParameterToName(type, context) : factory.cloneNode(node as Identifier);
                    name.symbol = sym!; // for quickinfo, which uses identifier symbol information
                    return setTextRange(context, setEmitFlags(name, EmitFlags.NoAsciiEscaping), node);
                }
                const updated = visitEachChildWorker(node, c => attachSymbolToLeftmostIdentifier(c), /*context*/ undefined);
                return setTextRange(context, updated, node);
            }
        }

        function serializeTypeName(context: NodeBuilderContext, node: EntityName, isTypeOf?: boolean, typeArguments?: readonly TypeNode[]) {
            const meaning = isTypeOf ? SymbolFlags.Value : SymbolFlags.Type;
            const symbol = resolveEntityName(node, meaning, /*ignoreErrors*/ true);
            if (!symbol) return undefined;
            const resolvedSymbol = symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol;
            if (isSymbolAccessible(symbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible) return undefined;
            return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments);
        }

        function canReuseTypeNode(context: NodeBuilderContext, existing: TypeNode) {
            const type = getTypeFromTypeNode(context, existing, /*noMappedTypes*/ true);
            if (!type) {
                return false;
            }
            if (isInJSFile(existing)) {
                if (isLiteralImportTypeNode(existing)) {
                    // Ensure resolvedSymbol is present
                    void getTypeFromImportTypeNode(existing);
                    const nodeSymbol = getNodeLinks(existing).resolvedSymbol;
                    return (
                        !nodeSymbol ||
                        !(
                            // The import type resolved using jsdoc fallback logic
                            (!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) ||
                            // The import type had type arguments autofilled by js fallback logic
                            !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))
                        )
                    );
                }
            }
            if (isTypeReferenceNode(existing)) {
                if (isConstTypeReference(existing)) return false;
                const symbol = getNodeLinks(existing).resolvedSymbol;
                if (!symbol) return false;
                if (symbol.flags & SymbolFlags.TypeParameter) {
                    const declaredType = getDeclaredTypeOfSymbol(symbol);
                    return !(context.mapper && getMappedType(declaredType, context.mapper) !== declaredType);
                }
                if (isInJSDoc(existing)) {
                    return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type)
                        && !getIntendedTypeFromJSDocTypeReference(existing) // We should probably allow the reuse of JSDoc reference types such as String Number etc
                        && !!(symbol.flags & SymbolFlags.Type); // JSDoc type annotations can reference values (meaning typeof value) as well as types. We only reuse type nodes
                }
            }
            if (
                isTypeOperatorNode(existing) &&
                existing.operator === SyntaxKind.UniqueKeyword &&
                existing.type.kind === SyntaxKind.SymbolKeyword
            ) {
                const effectiveEnclosingContext = context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration);
                return !!findAncestor(existing, n => n === effectiveEnclosingContext);
            }
            return true;
        }

        function serializeExistingTypeNode(context: NodeBuilderContext, typeNode: TypeNode, addUndefined: boolean) {
            const type = getTypeFromTypeNode(context, typeNode);
            if (
                addUndefined &&
                !someType(type, t => !!(t.flags & TypeFlags.Undefined)) &&
                canReuseTypeNode(context, typeNode)
            ) {
                const clone = syntacticNodeBuilder.tryReuseExistingTypeNode(context, typeNode);
                if (clone) {
                    return factory.createUnionTypeNode([clone, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)]);
                }
            }
            return typeToTypeNodeHelper(type, context);
        }

        function symbolTableToDeclarationStatements(symbolTable: SymbolTable, context: NodeBuilderContext): Statement[] {
            const serializePropertySymbolForClass = makeSerializePropertySymbol<ClassElement>(factory.createPropertyDeclaration, SyntaxKind.MethodDeclaration, /*useAccessors*/ true);
            const serializePropertySymbolForInterfaceWorker = makeSerializePropertySymbol<TypeElement>((mods, name, question, type) => factory.createPropertySignature(mods, name, question, type), SyntaxKind.MethodSignature, /*useAccessors*/ false);

            // TODO: Use `setOriginalNode` on original declaration names where possible so these declarations see some kind of
            // declaration mapping

            // We save the enclosing declaration off here so it's not adjusted by well-meaning declaration
            // emit codepaths which want to apply more specific contexts (so we can still refer to the root real declaration
            // we're trying to emit from later on)
            const enclosingDeclaration = context.enclosingDeclaration!;
            let results: Statement[] = [];
            const visitedSymbols = new Set<number>();
            const deferredPrivatesStack: Map<SymbolId, Symbol>[] = [];
            const oldcontext = context;
            context = {
                ...oldcontext,
                usedSymbolNames: new Set(oldcontext.usedSymbolNames),
                remappedSymbolNames: new Map(),
                remappedSymbolReferences: new Map(oldcontext.remappedSymbolReferences?.entries()),
                tracker: undefined!,
            };
            const tracker: SymbolTracker = {
                ...oldcontext.tracker.inner,
                trackSymbol: (sym, decl, meaning) => {
                    if (context.remappedSymbolNames?.has(getSymbolId(sym))) return false; // If the context has a remapped name for the symbol, it *should* mean it's been made visible
                    const accessibleResult = isSymbolAccessible(sym, decl, meaning, /*shouldComputeAliasesToMakeVisible*/ false);
                    if (accessibleResult.accessibility === SymbolAccessibility.Accessible) {
                        // Lookup the root symbol of the chain of refs we'll use to access it and serialize it
                        const chain = lookupSymbolChainWorker(sym, context, meaning);
                        if (!(sym.flags & SymbolFlags.Property)) {
                            // Only include referenced privates in the same file. Weird JS aliases may expose privates
                            // from other files - assume JS transforms will make those available via expected means
                            const root = chain[0];
                            const contextFile = getSourceFileOfNode(oldcontext.enclosingDeclaration);
                            if (some(root.declarations, d => getSourceFileOfNode(d) === contextFile)) {
                                includePrivateSymbol(root);
                            }
                        }
                    }
                    else if (oldcontext.tracker.inner?.trackSymbol) {
                        return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning);
                    }
                    return false;
                },
            };
            context.tracker = new SymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost);
            forEachEntry(symbolTable, (symbol, name) => {
                const baseName = unescapeLeadingUnderscores(name);
                void getInternalSymbolName(symbol, baseName); // Called to cache values into `usedSymbolNames` and `remappedSymbolNames`
            });
            let addingDeclare = !context.bundled;
            const exportEquals = symbolTable.get(InternalSymbolName.ExportEquals);
            if (exportEquals && symbolTable.size > 1 && exportEquals.flags & (SymbolFlags.Alias | SymbolFlags.Module)) {
                symbolTable = createSymbolTable();
                // Remove extraneous elements from root symbol table (they'll be mixed back in when the target of the `export=` is looked up)
                symbolTable.set(InternalSymbolName.ExportEquals, exportEquals);
            }

            visitSymbolTable(symbolTable);
            return mergeRedundantStatements(results);

            function isIdentifierAndNotUndefined(node: Node | undefined): node is Identifier {
                return !!node && node.kind === SyntaxKind.Identifier;
            }

            function getNamesOfDeclaration(statement: Statement): Identifier[] {
                if (isVariableStatement(statement)) {
                    return filter(map(statement.declarationList.declarations, getNameOfDeclaration), isIdentifierAndNotUndefined);
                }
                return filter([getNameOfDeclaration(statement as DeclarationStatement)], isIdentifierAndNotUndefined);
            }

            function flattenExportAssignedNamespace(statements: Statement[]) {
                const exportAssignment = find(statements, isExportAssignment);
                const nsIndex = findIndex(statements, isModuleDeclaration);
                let ns = nsIndex !== -1 ? statements[nsIndex] as ModuleDeclaration : undefined;
                if (
                    ns && exportAssignment && exportAssignment.isExportEquals &&
                    isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) === idText(exportAssignment.expression) &&
                    ns.body && isModuleBlock(ns.body)
                ) {
                    // Pass 0: Correct situations where a module has both an `export = ns` and multiple top-level exports by stripping the export modifiers from
                    //  the top-level exports and exporting them in the targeted ns, as can occur when a js file has both typedefs and `module.export` assignments
                    const excessExports = filter(statements, s => !!(getEffectiveModifierFlags(s) & ModifierFlags.Export));
                    const name = ns.name;
                    let body = ns.body;
                    if (length(excessExports)) {
                        ns = factory.updateModuleDeclaration(
                            ns,
                            ns.modifiers,
                            ns.name,
                            body = factory.updateModuleBlock(
                                body,
                                factory.createNodeArray([
                                    ...ns.body.statements,
                                    factory.createExportDeclaration(
                                        /*modifiers*/ undefined,
                                        /*isTypeOnly*/ false,
                                        factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly*/ false, /*propertyName*/ undefined, id))),
                                        /*moduleSpecifier*/ undefined,
                                    ),
                                ]),
                            ),
                        );
                        statements = [...statements.slice(0, nsIndex), ns, ...statements.slice(nsIndex + 1)];
                    }

                    // Pass 1: Flatten `export namespace _exports {} export = _exports;` so long as the `export=` only points at a single namespace declaration
                    if (!find(statements, s => s !== ns && nodeHasName(s, name))) {
                        results = [];
                        // If the namespace contains no export assignments or declarations, and no declarations flagged with `export`, then _everything_ is exported -
                        // to respect this as the top level, we need to add an `export` modifier to everything
                        const mixinExportFlag = !some(body.statements, s => hasSyntacticModifier(s, ModifierFlags.Export) || isExportAssignment(s) || isExportDeclaration(s));
                        forEach(body.statements, s => {
                            addResult(s, mixinExportFlag ? ModifierFlags.Export : ModifierFlags.None); // Recalculates the ambient (and export, if applicable from above) flag
                        });
                        statements = [...filter(statements, s => s !== ns && s !== exportAssignment), ...results];
                    }
                }
                return statements;
            }

            function mergeExportDeclarations(statements: Statement[]) {
                // Pass 2: Combine all `export {}` declarations
                const exports = filter(statements, d => isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)) as ExportDeclaration[];
                if (length(exports) > 1) {
                    const nonExports = filter(statements, d => !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause);
                    statements = [
                        ...nonExports,
                        factory.createExportDeclaration(
                            /*modifiers*/ undefined,
                            /*isTypeOnly*/ false,
                            factory.createNamedExports(flatMap(exports, e => cast(e.exportClause, isNamedExports).elements)),
                            /*moduleSpecifier*/ undefined,
                        ),
                    ];
                }
                // Pass 2b: Also combine all `export {} from "..."` declarations as needed
                const reexports = filter(statements, d => isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)) as ExportDeclaration[];
                if (length(reexports) > 1) {
                    const groups = group(reexports, decl => isStringLiteral(decl.moduleSpecifier!) ? ">" + decl.moduleSpecifier.text : ">");
                    if (groups.length !== reexports.length) {
                        for (const group of groups) {
                            if (group.length > 1) {
                                // remove group members from statements and then merge group members and add back to statements
                                statements = [
                                    ...filter(statements, s => !group.includes(s as ExportDeclaration)),
                                    factory.createExportDeclaration(
                                        /*modifiers*/ undefined,
                                        /*isTypeOnly*/ false,
                                        factory.createNamedExports(flatMap(group, e => cast(e.exportClause, isNamedExports).elements)),
                                        group[0].moduleSpecifier,
                                    ),
                                ];
                            }
                        }
                    }
                }
                return statements;
            }

            function inlineExportModifiers(statements: Statement[]) {
                // Pass 3: Move all `export {}`'s to `export` modifiers where possible
                const index = findIndex(statements, d => isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause && isNamedExports(d.exportClause));
                if (index >= 0) {
                    const exportDecl = statements[index] as ExportDeclaration & { readonly exportClause: NamedExports; };
                    const replacements = mapDefined(exportDecl.exportClause.elements, e => {
                        if (!e.propertyName && e.name.kind !== SyntaxKind.StringLiteral) {
                            // export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it
                            const name = e.name;
                            const indices = indicesOf(statements);
                            const associatedIndices = filter(indices, i => nodeHasName(statements[i], name));
                            if (length(associatedIndices) && every(associatedIndices, i => canHaveExportModifier(statements[i]))) {
                                for (const index of associatedIndices) {
                                    statements[index] = addExportModifier(statements[index] as Extract<HasModifiers, Statement>);
                                }
                                return undefined;
                            }
                        }
                        return e;
                    });
                    if (!length(replacements)) {
                        // all clauses removed, remove the export declaration
                        orderedRemoveItemAt(statements, index);
                    }
                    else {
                        // some items filtered, others not - update the export declaration
                        statements[index] = factory.updateExportDeclaration(
                            exportDecl,
                            exportDecl.modifiers,
                            exportDecl.isTypeOnly,
                            factory.updateNamedExports(
                                exportDecl.exportClause,
                                replacements,
                            ),
                            exportDecl.moduleSpecifier,
                            exportDecl.attributes,
                        );
                    }
                }
                return statements;
            }

            function mergeRedundantStatements(statements: Statement[]) {
                statements = flattenExportAssignedNamespace(statements);
                statements = mergeExportDeclarations(statements);
                statements = inlineExportModifiers(statements);

                // Not a cleanup, but as a final step: If there is a mix of `export` and non-`export` declarations, but no `export =` or `export {}` add a `export {};` so
                // declaration privacy is respected.
                if (
                    enclosingDeclaration &&
                    ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) &&
                    (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker)))
                ) {
                    statements.push(createEmptyExports(factory));
                }
                return statements;
            }

            function addExportModifier(node: Extract<HasModifiers, Statement>) {
                const flags = (getEffectiveModifierFlags(node) | ModifierFlags.Export) & ~ModifierFlags.Ambient;
                return factory.replaceModifiers(node, flags);
            }

            function removeExportModifier(node: Extract<HasModifiers, Statement>) {
                const flags = getEffectiveModifierFlags(node) & ~ModifierFlags.Export;
                return factory.replaceModifiers(node, flags);
            }

            function visitSymbolTable(symbolTable: SymbolTable, suppressNewPrivateContext?: boolean, propertyAsAlias?: boolean) {
                if (!suppressNewPrivateContext) {
                    deferredPrivatesStack.push(new Map());
                }
                let i = 0;
                const symbols = Array.from(symbolTable.values());
                for (const symbol of symbols) {
                    i++;
                    if (checkTruncationLengthIfExpanding(context) && (i + 2 < symbolTable.size - 1)) {
                        context.out.truncated = true;
                        results.push(createTruncationStatement(`... (${symbolTable.size - i} more ...)`));
                        serializeSymbol(symbols[symbols.length - 1], /*isPrivate*/ false, !!propertyAsAlias);
                        break;
                    }
                    serializeSymbol(symbol, /*isPrivate*/ false, !!propertyAsAlias);
                }
                if (!suppressNewPrivateContext) {
                    // deferredPrivates will be filled up by visiting the symbol table
                    // And will continue to iterate as elements are added while visited `deferredPrivates`
                    // (As that's how a map iterator is defined to work)
                    deferredPrivatesStack[deferredPrivatesStack.length - 1].forEach((symbol: Symbol) => {
                        serializeSymbol(symbol, /*isPrivate*/ true, !!propertyAsAlias);
                    });
                    deferredPrivatesStack.pop();
                }
            }

            function serializeSymbol(symbol: Symbol, isPrivate: boolean, propertyAsAlias: boolean): void {
                void getPropertiesOfType(getTypeOfSymbol(symbol)); // resolve symbol's type and properties, which should trigger any required merges
                // cache visited list based on merged symbol, since we want to use the unmerged top-level symbol, but
                // still skip reserializing it if we encounter the merged product later on
                const visitedSym = getMergedSymbol(symbol);
                if (visitedSymbols.has(getSymbolId(visitedSym))) {
                    return; // Already printed
                }
                visitedSymbols.add(getSymbolId(visitedSym));
                // Only actually serialize symbols within the correct enclosing declaration, otherwise do nothing with the out-of-context symbol
                const skipMembershipCheck = !isPrivate; // We only call this on exported symbols when we know they're in the correct scope
                if (skipMembershipCheck || (!!length(symbol.declarations) && some(symbol.declarations, d => !!findAncestor(d, n => n === enclosingDeclaration)))) {
                    const scopeCleanup = cloneNodeBuilderContext(context);
                    context.tracker.pushErrorFallbackNode(find(symbol.declarations, d => getSourceFileOfNode(d) === context.enclosingFile));
                    serializeSymbolWorker(symbol, isPrivate, propertyAsAlias);
                    context.tracker.popErrorFallbackNode();
                    scopeCleanup();
                }
            }

            // Synthesize declarations for a symbol - might be an Interface, a Class, a Namespace, a Type, a Variable (const, let, or var), an Alias
            // or a merge of some number of those.
            // An interesting challenge is ensuring that when classes merge with namespaces and interfaces, is keeping
            // each symbol in only one of the representations
            // Also, synthesizing a default export of some kind
            // If it's an alias: emit `export default ref`
            // If it's a property: emit `export default _default` with a `_default` prop
            // If it's a class/interface/function: emit a class/interface/function with a `default` modifier
            // These forms can merge, eg (`export default 12; export default interface A {}`)
            function serializeSymbolWorker(symbol: Symbol, isPrivate: boolean, propertyAsAlias: boolean, escapedSymbolName = symbol.escapedName): void {
                const symbolName = unescapeLeadingUnderscores(escapedSymbolName);
                const isDefault = escapedSymbolName === InternalSymbolName.Default;
                if (isPrivate && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier) && isStringANonContextualKeyword(symbolName) && !isDefault) {
                    // Oh no. We cannot use this symbol's name as it's name... It's likely some jsdoc had an invalid name like `export` or `default` :(
                    context.encounteredError = true;
                    // TODO: Issue error via symbol tracker?
                    return; // If we need to emit a private with a keyword name, we're done for, since something else will try to refer to it by that name
                }
                let needsPostExportDefault = isDefault && !!(
                    symbol.flags & SymbolFlags.ExportDoesNotSupportDefaultModifier
                    || (symbol.flags & SymbolFlags.Function && length(getPropertiesOfType(getTypeOfSymbol(symbol))))
                ) && !(symbol.flags & SymbolFlags.Alias); // An alias symbol should preclude needing to make an alias ourselves
                let needsExportDeclaration = !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault;
                // `serializeVariableOrProperty` will handle adding the export declaration if it is run (since `getInternalSymbolName` will create the name mapping), so we need to ensuer we unset `needsExportDeclaration` if it is
                if (needsPostExportDefault || needsExportDeclaration) {
                    isPrivate = true;
                }
                const modifierFlags = (!isPrivate ? ModifierFlags.Export : 0) | (isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0);
                const isConstMergedWithNS = symbol.flags & SymbolFlags.Module &&
                    symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property) &&
                    escapedSymbolName !== InternalSymbolName.ExportEquals;
                const isConstMergedWithNSPrintableAsSignatureMerge = isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol);
                if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) || isConstMergedWithNSPrintableAsSignatureMerge) {
                    serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                }
                if (symbol.flags & SymbolFlags.TypeAlias) {
                    serializeTypeAlias(symbol, symbolName, modifierFlags);
                }
                // Need to skip over export= symbols below - json source files get a single `Property` flagged
                // symbol of name `export=` which needs to be handled like an alias. It's not great, but it is what it is.
                if (
                    symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property | SymbolFlags.Accessor)
                    && escapedSymbolName !== InternalSymbolName.ExportEquals
                    && !(symbol.flags & SymbolFlags.Prototype)
                    && !(symbol.flags & SymbolFlags.Class)
                    && !(symbol.flags & SymbolFlags.Method)
                    && !isConstMergedWithNSPrintableAsSignatureMerge
                ) {
                    if (propertyAsAlias) {
                        const createdExport = serializeMaybeAliasAssignment(symbol);
                        if (createdExport) {
                            needsExportDeclaration = false;
                            needsPostExportDefault = false;
                        }
                    }
                    else {
                        const type = getTypeOfSymbol(symbol);
                        const localName = getInternalSymbolName(symbol, symbolName);
                        if (type.symbol && type.symbol !== symbol && type.symbol.flags & SymbolFlags.Function && some(type.symbol.declarations, isFunctionExpressionOrArrowFunction) && (type.symbol.members?.size || type.symbol.exports?.size)) {
                            // assignment of a anonymous expando/class-like function, the func/ns/merge branch below won't trigger,
                            // and the assignment form has to reference the unreachable anonymous type so will error.
                            // Instead, serialize the type's symbol, but with the current symbol's name, rather than the anonymous one.
                            if (!context.remappedSymbolReferences) {
                                context.remappedSymbolReferences = new Map();
                            }
                            context.remappedSymbolReferences.set(getSymbolId(type.symbol), symbol); // save name remapping as local name for target symbol
                            serializeSymbolWorker(type.symbol, isPrivate, propertyAsAlias, escapedSymbolName);
                            context.remappedSymbolReferences.delete(getSymbolId(type.symbol));
                        }
                        else if (!(symbol.flags & SymbolFlags.Function) && isTypeRepresentableAsFunctionNamespaceMerge(type, symbol)) {
                            // If the type looks like a function declaration + ns could represent it, and it's type is sourced locally, rewrite it into a function declaration + ns
                            serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags);
                        }
                        else {
                            // A Class + Property merge is made for a `module.exports.Member = class {}`, and it doesn't serialize well as either a class _or_ a property symbol - in fact, _it behaves like an alias!_
                            // `var` is `FunctionScopedVariable`, `const` and `let` are `BlockScopedVariable`, and `module.exports.thing =` is `Property`
                            const flags = !(symbol.flags & SymbolFlags.BlockScopedVariable)
                                ? symbol.parent?.valueDeclaration && isSourceFile(symbol.parent?.valueDeclaration)
                                    ? NodeFlags.Const // exports are immutable in es6, which is what we emulate and check; so it's safe to mark all exports as `const` (there's no difference to consumers, but it allows unique symbol type declarations)
                                    : undefined
                                : isConstantVariable(symbol)
                                ? NodeFlags.Const
                                : NodeFlags.Let;
                            const name = (needsPostExportDefault || !(symbol.flags & SymbolFlags.Property)) ? localName : getUnusedName(localName, symbol);
                            let textRange: Node | undefined = symbol.declarations && find(symbol.declarations, d => isVariableDeclaration(d));
                            if (textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length === 1) {
                                textRange = textRange.parent.parent;
                            }
                            const propertyAccessRequire = symbol.declarations?.find(isPropertyAccessExpression);
                            if (
                                propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right)
                                && type.symbol?.valueDeclaration && isSourceFile(type.symbol.valueDeclaration)
                            ) {
                                const alias = localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right;
                                context.approximateLength += 12 + ((alias?.escapedText as string | undefined)?.length ?? 0); // `export { alias };`
                                addResult(
                                    factory.createExportDeclaration(
                                        /*modifiers*/ undefined,
                                        /*isTypeOnly*/ false,
                                        factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly*/ false, alias, localName)]),
                                    ),
                                    ModifierFlags.None,
                                );
                                context.tracker.trackSymbol(type.symbol, context.enclosingDeclaration, SymbolFlags.Value);
                            }
                            else {
                                const statement = setTextRange(
                                    context,
                                    factory.createVariableStatement(
                                        /*modifiers*/ undefined,
                                        factory.createVariableDeclarationList([
                                            factory.createVariableDeclaration(name, /*exclamationToken*/ undefined, serializeTypeForDeclaration(context, /*declaration*/ undefined, type, symbol)),
                                        ], flags),
                                    ),
                                    textRange,
                                );
                                context.approximateLength += 7 + name.length; // `var name: ;`
                                addResult(statement, name !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags);
                                if (name !== localName && !isPrivate) {
                                    // We rename the variable declaration we generate for Property symbols since they may have a name which
                                    // conflicts with a local declaration. For example, given input:
                                    // ```
                                    // function g() {}
                                    // module.exports.g = g
                                    // ```
                                    // In such a situation, we have a local variable named `g`, and a separate exported variable named `g`.
                                    // Naively, we would emit
                                    // ```
                                    // function g() {}
                                    // export const g: typeof g;
                                    // ```
                                    // That's obviously incorrect - the `g` in the type annotation needs to refer to the local `g`, but
                                    // the export declaration shadows it.
                                    // To work around that, we instead write
                                    // ```
                                    // function g() {}
                                    // const g_1: typeof g;
                                    // export { g_1 as g };
                                    // ```
                                    // To create an export named `g` that does _not_ shadow the local `g`
                                    context.approximateLength += 16 + name.length + localName.length; // `export { name as localName };`
                                    addResult(
                                        factory.createExportDeclaration(
                                            /*modifiers*/ undefined,
                                            /*isTypeOnly*/ false,
                                            factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly*/ false, name, localName)]),
                                        ),
                                        ModifierFlags.None,
                                    );
                                    needsExportDeclaration = false;
                                    needsPostExportDefault = false;
                                }
                            }
                        }
                    }
                }
                if (symbol.flags & SymbolFlags.Enum) {
                    serializeEnum(symbol, symbolName, modifierFlags);
                }
                if (symbol.flags & SymbolFlags.Class) {
                    if (
                        symbol.flags & SymbolFlags.Property
                        && symbol.valueDeclaration
                        && isBinaryExpression(symbol.valueDeclaration.parent)
                        && isClassExpression(symbol.valueDeclaration.parent.right)
                    ) {
                        // Looks like a `module.exports.Sub = class {}` - if we serialize `symbol` as a class, the result will have no members,
                        // since the classiness is actually from the target of the effective alias the symbol is. yes. A BlockScopedVariable|Class|Property
                        // _really_ acts like an Alias, and none of a BlockScopedVariable, Class, or Property. This is the travesty of JS binding today.
                        serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                    }
                    else {
                        serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                    }
                }
                if ((symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge) {
                    serializeModule(symbol, symbolName, modifierFlags);
                }
                // The class meaning serialization should handle serializing all interface members
                if (symbol.flags & SymbolFlags.Interface && !(symbol.flags & SymbolFlags.Class)) {
                    serializeInterface(symbol, symbolName, modifierFlags);
                }
                if (symbol.flags & SymbolFlags.Alias) {
                    serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                }
                if (symbol.flags & SymbolFlags.Property && symbol.escapedName === InternalSymbolName.ExportEquals) {
                    serializeMaybeAliasAssignment(symbol);
                }
                if (symbol.flags & SymbolFlags.ExportStar) {
                    // synthesize export * from "moduleReference"
                    // Straightforward - only one thing to do - make an export declaration
                    if (symbol.declarations) {
                        for (const node of symbol.declarations) {
                            const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!);
                            if (!resolvedModule) continue;
                            const isTypeOnly = (node as ExportDeclaration).isTypeOnly;
                            const specifier = getSpecifierForModuleSymbol(resolvedModule, context);
                            context.approximateLength += 17 + specifier.length; // `export * from "specifier";`
                            addResult(factory.createExportDeclaration(/*modifiers*/ undefined, isTypeOnly, /*exportClause*/ undefined, factory.createStringLiteral(specifier)), ModifierFlags.None);
                        }
                    }
                }
                if (needsPostExportDefault) {
                    const internalSymbolName = getInternalSymbolName(symbol, symbolName);
                    context.approximateLength += 16 + internalSymbolName.length; // `export default internalName;`
                    addResult(factory.createExportAssignment(/*modifiers*/ undefined, /*isExportEquals*/ false, factory.createIdentifier(internalSymbolName)), ModifierFlags.None);
                }
                else if (needsExportDeclaration) {
                    const internalSymbolName = getInternalSymbolName(symbol, symbolName);
                    context.approximateLength += 22 + symbolName.length + internalSymbolName.length; // `export { internalName as symbolName };`
                    addResult(
                        factory.createExportDeclaration(
                            /*modifiers*/ undefined,
                            /*isTypeOnly*/ false,
                            factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly*/ false, internalSymbolName, symbolName)]),
                        ),
                        ModifierFlags.None,
                    );
                }
            }

            function includePrivateSymbol(symbol: Symbol) {
                if (some(symbol.declarations, isPartOfParameterDeclaration)) return;
                Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length - 1]);
                getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol); // Call to cache unique name for symbol
                // Blanket moving (import) aliases into the root private context should work, since imports are not valid within namespaces
                // (so they must have been in the root to begin with if they were real imports) cjs `require` aliases (an upcoming feature)
                // will throw a wrench in this, since those may have been nested, but we'll need to synthesize them in the outer scope
                // anyway, as that's the only place the import they translate to is valid. In such a case, we might need to use a unique name
                // for the moved import; which hopefully the above `getUnusedName` call should produce.
                const isExternalImportAlias = !!(symbol.flags & SymbolFlags.Alias) && !some(symbol.declarations, d =>
                    !!findAncestor(d, isExportDeclaration) ||
                    isNamespaceExport(d) ||
                    (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference)));
                deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)].set(getSymbolId(symbol), symbol);
            }

            function isExportingScope(enclosingDeclaration: Node) {
                return ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) ||
                    (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration)));
            }

            // Prepends a `declare` and/or `export` modifier if the context requires it, and then adds `node` to `result` and returns `node`
            function addResult(node: Statement, additionalModifierFlags: ModifierFlags) {
                if (canHaveModifiers(node)) {
                    const oldModifierFlags = getEffectiveModifierFlags(node);
                    let newModifierFlags: ModifierFlags = ModifierFlags.None;
                    const enclosingDeclaration = context.enclosingDeclaration &&
                        (isJSDocTypeAlias(context.enclosingDeclaration) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration);
                    if (
                        additionalModifierFlags & ModifierFlags.Export &&
                        enclosingDeclaration && (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) &&
                        canHaveExportModifier(node)
                    ) {
                        // Classes, namespaces, variables, functions, interfaces, and types should all be `export`ed in a module context if not private
                        newModifierFlags |= ModifierFlags.Export;
                    }
                    if (
                        addingDeclare && !(newModifierFlags & ModifierFlags.Export) &&
                        (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlags.Ambient)) &&
                        (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node))
                    ) {
                        // Classes, namespaces, variables, enums, and functions all need `declare` modifiers to be valid in a declaration file top-level scope
                        newModifierFlags |= ModifierFlags.Ambient;
                    }
                    if ((additionalModifierFlags & ModifierFlags.Default) && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node))) {
                        newModifierFlags |= ModifierFlags.Default;
                    }
                    if (newModifierFlags) {
                        node = factory.replaceModifiers(node, newModifierFlags | oldModifierFlags);
                    }
                    context.approximateLength += modifiersLength(newModifierFlags | oldModifierFlags);
                }
                results.push(node);
            }

            function serializeTypeAlias(symbol: Symbol, symbolName: string, modifierFlags: ModifierFlags) {
                const aliasType = getDeclaredTypeOfTypeAlias(symbol);
                const typeParams = getSymbolLinks(symbol).typeParameters;
                const typeParamDecls = map(typeParams, p => typeParameterToDeclaration(p, context));
                const jsdocAliasDecl = symbol.declarations?.find(isJSDocTypeAlias);
                const commentText = getTextOfJSDocComment(jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined);
                const restoreFlags = saveRestoreFlags(context);
                context.flags |= NodeBuilderFlags.InTypeAlias;
                const oldEnclosingDecl = context.enclosingDeclaration;
                context.enclosingDeclaration = jsdocAliasDecl;
                const typeNode = jsdocAliasDecl && jsdocAliasDecl.typeExpression
                        && isJSDocTypeExpression(jsdocAliasDecl.typeExpression)
                        && syntacticNodeBuilder.tryReuseExistingTypeNode(context, jsdocAliasDecl.typeExpression.type)
                    || typeToTypeNodeHelper(aliasType, context);
                const internalSymbolName = getInternalSymbolName(symbol, symbolName);
                context.approximateLength += 8 + (commentText?.length ?? 0) + internalSymbolName.length; // `/* comment */ type name = ...`
                addResult(
                    setSyntheticLeadingComments(
                        factory.createTypeAliasDeclaration(/*modifiers*/ undefined, internalSymbolName, typeParamDecls, typeNode),
                        !commentText ? [] : [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }],
                    ),
                    modifierFlags,
                );
                restoreFlags();
                context.enclosingDeclaration = oldEnclosingDecl;
            }

            function serializeInterface(symbol: Symbol, symbolName: string, modifierFlags: ModifierFlags) {
                const internalSymbolName = getInternalSymbolName(symbol, symbolName);
                context.approximateLength += 14 + internalSymbolName.length; // `interface name { }`
                const interfaceType = getDeclaredTypeOfClassOrInterface(symbol);
                const localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                const typeParamDecls = map(localParams, p => typeParameterToDeclaration(p, context));
                const baseTypes = getBaseTypes(interfaceType);
                const baseType = length(baseTypes) ? getIntersectionType(baseTypes) : undefined;
                const members = serializePropertySymbolsForClassOrInterface(getPropertiesOfType(interfaceType), /*isClass*/ false, baseType);
                const callSignatures = serializeSignatures(SignatureKind.Call, interfaceType, baseType, SyntaxKind.CallSignature) as CallSignatureDeclaration[];
                const constructSignatures = serializeSignatures(SignatureKind.Construct, interfaceType, baseType, SyntaxKind.ConstructSignature) as ConstructSignatureDeclaration[];
                const indexSignatures = serializeIndexSignatures(interfaceType, baseType);

                const heritageClauses = !length(baseTypes) ? undefined : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, mapDefined(baseTypes, b => trySerializeAsTypeReference(b, SymbolFlags.Value)))];
                addResult(
                    factory.createInterfaceDeclaration(
                        /*modifiers*/ undefined,
                        internalSymbolName,
                        typeParamDecls,
                        heritageClauses,
                        [...indexSignatures, ...constructSignatures, ...callSignatures, ...members],
                    ),
                    modifierFlags,
                );
            }

            function serializePropertySymbolsForClassOrInterface(props: readonly Symbol[], isClass: false, baseType: Type | undefined): TypeElement[];
            function serializePropertySymbolsForClassOrInterface(props: readonly Symbol[], isClass: true, baseType: Type | undefined, isStatic: boolean): ClassElement[];
            function serializePropertySymbolsForClassOrInterface(props: readonly Symbol[], isClass: boolean, baseType: Type | undefined, isStatic?: boolean): (ClassElement | TypeElement)[] {
                const elements: (ClassElement | TypeElement)[] = [];
                let i = 0;
                for (const prop of props) {
                    i++;
                    if (checkTruncationLengthIfExpanding(context) && (i + 2 < props.length - 1)) {
                        context.out.truncated = true;
                        const placeholder = createTruncationProperty(`... ${props.length - i} more ... `, isClass);
                        elements.push(placeholder);
                        const result = isClass ?
                            serializePropertySymbolForClass(props[props.length - 1], isStatic!, baseType) :
                            serializePropertySymbolForInterface(props[props.length - 1], baseType);
                        if (isArray(result)) {
                            elements.push(...result);
                        }
                        else {
                            elements.push(result);
                        }
                        break;
                    }

                    context.approximateLength += 1; // separator
                    const result = isClass ?
                        serializePropertySymbolForClass(prop, isStatic!, baseType) :
                        serializePropertySymbolForInterface(prop, baseType);
                    if (isArray(result)) {
                        elements.push(...result);
                    }
                    else {
                        elements.push(result);
                    }
                }
                return elements;
            }

            function createTruncationProperty(dotDotDotText: string, isClass: boolean): TypeElement | ClassElement {
                if (context.flags & NodeBuilderFlags.NoTruncation) {
                    return addSyntheticLeadingComment(factory.createNotEmittedTypeElement(), SyntaxKind.MultiLineCommentTrivia, dotDotDotText);
                }
                return isClass ?
                    factory.createPropertyDeclaration(
                        /*modifiers*/ undefined,
                        dotDotDotText,
                        /*questionOrExclamationToken*/ undefined,
                        /*type*/ undefined,
                        /*initializer*/ undefined,
                    ) :
                    factory.createPropertySignature(
                        /*modifiers*/ undefined,
                        dotDotDotText,
                        /*questionToken*/ undefined,
                        /*type*/ undefined,
                    );
            }

            function getNamespaceMembersForSerialization(symbol: Symbol) {
                let exports = arrayFrom(getExportsOfSymbol(symbol).values());
                const merged = getMergedSymbol(symbol);
                if (merged !== symbol) {
                    const membersSet = new Set(exports);
                    for (const exported of getExportsOfSymbol(merged).values()) {
                        if (!(getSymbolFlags(resolveSymbol(exported)) & SymbolFlags.Value)) {
                            membersSet.add(exported);
                        }
                    }
                    exports = arrayFrom(membersSet);
                }
                return filter(exports, m => isNamespaceMember(m) && isIdentifierText(m.escapedName as string, ScriptTarget.ESNext));
            }

            function isTypeOnlyNamespace(symbol: Symbol) {
                return every(getNamespaceMembersForSerialization(symbol), m => !(getSymbolFlags(resolveSymbol(m)) & SymbolFlags.Value));
            }

            function serializeModule(symbol: Symbol, symbolName: string, modifierFlags: ModifierFlags) {
                const members = getNamespaceMembersForSerialization(symbol);
                const expanding = isExpanding(context);
                // Split NS members up by declaration - members whose parent symbol is the ns symbol vs those whose is not (but were added in later via merging)
                const locationMap = arrayToMultiMap(members, m => m.parent && m.parent === symbol || expanding ? "real" : "merged");
                const realMembers = locationMap.get("real") || emptyArray;
                const mergedMembers = locationMap.get("merged") || emptyArray;
                // TODO: `suppressNewPrivateContext` is questionable -we need to simply be emitting privates in whatever scope they were declared in, rather
                // than whatever scope we traverse to them in. That's a bit of a complex rewrite, since we're not _actually_ tracking privates at all in advance,
                // so we don't even have placeholders to fill in.
                if (length(realMembers) || expanding) {
                    let localName: ModuleName;
                    if (expanding) {
                        // Use the same name as symbol display.
                        const oldFlags = context.flags;
                        context.flags |= NodeBuilderFlags.WriteTypeParametersInQualifiedName | SymbolFormatFlags.UseOnlyExternalAliasing;
                        localName = symbolToNode(symbol, context, /*meaning*/ SymbolFlags.All) as ModuleName;
                        context.flags = oldFlags;
                    }
                    else {
                        const localText = getInternalSymbolName(symbol, symbolName);
                        localName = factory.createIdentifier(localText);
                        context.approximateLength += localText.length;
                    }
                    serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (SymbolFlags.Function | SymbolFlags.Assignment)));
                }
                if (length(mergedMembers)) {
                    const containingFile = getSourceFileOfNode(context.enclosingDeclaration);
                    const localName = getInternalSymbolName(symbol, symbolName);
                    const nsBody = factory.createModuleBlock([factory.createExportDeclaration(
                        /*modifiers*/ undefined,
                        /*isTypeOnly*/ false,
                        factory.createNamedExports(mapDefined(filter(mergedMembers, n => n.escapedName !== InternalSymbolName.ExportEquals), s => {
                            const name = unescapeLeadingUnderscores(s.escapedName);
                            const localName = getInternalSymbolName(s, name);
                            const aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);
                            if (containingFile && (aliasDecl ? containingFile !== getSourceFileOfNode(aliasDecl) : !some(s.declarations, d => getSourceFileOfNode(d) === containingFile))) {
                                context.tracker?.reportNonlocalAugmentation?.(containingFile, symbol, s);
                                return undefined;
                            }
                            const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve*/ true);
                            includePrivateSymbol(target || s);
                            const targetName = target ? getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName)) : localName;
                            return factory.createExportSpecifier(/*isTypeOnly*/ false, name === targetName ? undefined : targetName, name);
                        })),
                    )]);
                    addResult(
                        factory.createModuleDeclaration(
                            /*modifiers*/ undefined,
                            factory.createIdentifier(localName),
                            nsBody,
                            NodeFlags.Namespace,
                        ),
                        ModifierFlags.None,
                    );
                }
            }

            function serializeEnum(symbol: Symbol, symbolName: string, modifierFlags: ModifierFlags) {
                const internalSymbolName = getInternalSymbolName(symbol, symbolName);
                context.approximateLength += 9 + internalSymbolName.length; // `enum internalName { }`
                const members: EnumMember[] = [];
                const memberProps = filter(getPropertiesOfType(getTypeOfSymbol(symbol)), p => !!(p.flags & SymbolFlags.EnumMember));
                let i = 0;
                for (const p of memberProps) {
                    i++;
                    if (checkTruncationLengthIfExpanding(context) && (i + 2 < memberProps.length - 1)) {
                        context.out.truncated = true;
                        members.push(factory.createEnumMember(` ... ${memberProps.length - i} more ... `));
                        const last = memberProps[memberProps.length - 1];
                        const initializedValue = last.declarations && last.declarations[0] && isEnumMember(last.declarations[0]) ? getConstantValue(last.declarations[0]) : undefined;
                        const initializer = initializedValue === undefined ? undefined :
                            typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) :
                            factory.createNumericLiteral(initializedValue);
                        const memberName = unescapeLeadingUnderscores(last.escapedName);
                        const member = factory.createEnumMember(
                            memberName,
                            initializer,
                        );
                        members.push(member);
                        break;
                    }
                    // TODO: Handle computed names
                    // I hate that to get the initialized value we need to walk back to the declarations here; but there's no
                    // other way to get the possible const value of an enum member that I'm aware of, as the value is cached
                    // _on the declaration_, not on the declaration's symbol...
                    const memberDecl = p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) ?
                        p.declarations[0] :
                        undefined;
                    let initializer: Expression | undefined;
                    let initializerLength: number;
                    if (isExpanding(context) && memberDecl && memberDecl.initializer) {
                        initializer = getSynthesizedDeepClone(memberDecl.initializer);
                        initializerLength = memberDecl.initializer.end - memberDecl.initializer.pos;
                    }
                    else {
                        const initializedValue = memberDecl && getConstantValue(memberDecl);
                        initializer = initializedValue === undefined ? undefined :
                            typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) :
                            factory.createNumericLiteral(initializedValue);
                        initializerLength = (initializer as StringLiteral | NumericLiteral | undefined)?.text.length ?? 0;
                    }
                    const memberName = unescapeLeadingUnderscores(p.escapedName);
                    context.approximateLength += 4 + memberName.length + initializerLength; // `member = initializer,`
                    const member = factory.createEnumMember(
                        memberName,
                        initializer,
                    );
                    members.push(member);
                }
                addResult(
                    factory.createEnumDeclaration(
                        factory.createModifiersFromModifierFlags(isConstEnumSymbol(symbol) ? ModifierFlags.Const : 0),
                        internalSymbolName,
                        members,
                    ),
                    modifierFlags,
                );
            }

            function serializeAsFunctionNamespaceMerge(type: Type, symbol: Symbol, localName: string, modifierFlags: ModifierFlags) {
                const signatures = getSignaturesOfType(type, SignatureKind.Call);
                for (const sig of signatures) {
                    context.approximateLength += 1; // ;
                    // Each overload becomes a separate function declaration, in order
                    const decl = signatureToSignatureDeclarationHelper(sig, SyntaxKind.FunctionDeclaration, context, { name: factory.createIdentifier(localName) }) as FunctionDeclaration;
                    addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags);
                }
                // Module symbol emit will take care of module-y members, provided it has exports
                if (!(symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && !!symbol.exports && !!symbol.exports.size)) {
                    const props = filter(getPropertiesOfType(type), isNamespaceMember);
                    context.approximateLength += localName.length;
                    serializeAsNamespaceDeclaration(props, factory.createIdentifier(localName), modifierFlags, /*suppressNewPrivateContext*/ true);
                }
            }

            function createTruncationStatement(dotDotDotText: string): Statement {
                if (context.flags & NodeBuilderFlags.NoTruncation) {
                    return addSyntheticLeadingComment(factory.createEmptyStatement(), SyntaxKind.MultiLineCommentTrivia, dotDotDotText);
                }
                return factory.createExpressionStatement(factory.createIdentifier(dotDotDotText));
            }

            function getSignatureTextRangeLocation(signature: Signature) {
                if (signature.declaration && signature.declaration.parent) {
                    if (isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) === AssignmentDeclarationKind.Property) {
                        return signature.declaration.parent;
                    }
                    // for expressions assigned to `var`s, use the `var` as the text range
                    if (isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent) {
                        return signature.declaration.parent.parent;
                    }
                }
                return signature.declaration;
            }

            function serializeAsNamespaceDeclaration(props: readonly Symbol[], localName: ModuleName, modifierFlags: ModifierFlags, suppressNewPrivateContext: boolean) {
                const nodeFlags = isIdentifier(localName) ? NodeFlags.Namespace : NodeFlags.None;
                const expanding = isExpanding(context);
                if (length(props)) {
                    context.approximateLength += 14; // "namespace { }"
                    const localVsRemoteMap = arrayToMultiMap(props, p => !length(p.declarations) || some(p.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!)) || expanding ? "local" : "remote");
                    const localProps = localVsRemoteMap.get("local") || emptyArray;
                    // handle remote props first - we need to make an `import` declaration that points at the module containing each remote
                    // prop in the outermost scope (TODO: a namespace within a namespace would need to be appropriately handled by this)
                    // Example:
                    // import Foo_1 = require("./exporter");
                    // export namespace ns {
                    //     import Foo = Foo_1.Foo;
                    //     export { Foo };
                    //     export const c: number;
                    // }
                    // This is needed because in JS, statements like `const x = require("./f")` support both type and value lookup, even if they're
                    // normally just value lookup (so it functions kinda like an alias even when it's not an alias)
                    // _Usually_, we'll simply print the top-level as an alias instead of a `var` in such situations, however is is theoretically
                    // possible to encounter a situation where a type has members from both the current file and other files - in those situations,
                    // emit akin to the above would be needed.

                    // Add a namespace
                    // Create namespace as non-synthetic so it is usable as an enclosing declaration
                    let fakespace = parseNodeFactory.createModuleDeclaration(/*modifiers*/ undefined, localName, factory.createModuleBlock([]), nodeFlags);
                    setParent(fakespace, enclosingDeclaration as SourceFile | NamespaceDeclaration);
                    fakespace.locals = createSymbolTable(props);
                    fakespace.symbol = props[0].parent!;

                    const oldResults = results;
                    results = [];
                    const oldAddingDeclare = addingDeclare;
                    addingDeclare = false;
                    const subcontext = { ...context, enclosingDeclaration: fakespace };
                    const oldContext = context;
                    context = subcontext;
                    // TODO: implement handling for the localVsRemoteMap.get("remote") - should be difficult to trigger (see comment above), as only interesting cross-file js merges should make this possible
                    visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext, /*propertyAsAlias*/ true);
                    context = oldContext;
                    addingDeclare = oldAddingDeclare;
                    const declarations = results;
                    results = oldResults;
                    // replace namespace with synthetic version
                    const defaultReplaced = map(declarations, d =>
                        isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) ? factory.createExportDeclaration(
                            /*modifiers*/ undefined,
                            /*isTypeOnly*/ false,
                            factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly*/ false, d.expression, factory.createIdentifier(InternalSymbolName.Default))]),
                        ) : d);
                    const exportModifierStripped = every(defaultReplaced, d => hasSyntacticModifier(d, ModifierFlags.Export)) ? map(defaultReplaced as Extract<HasModifiers, Statement>[], removeExportModifier) : defaultReplaced;
                    fakespace = factory.updateModuleDeclaration(
                        fakespace,
                        fakespace.modifiers,
                        fakespace.name,
                        factory.createModuleBlock(exportModifierStripped),
                    );
                    addResult(fakespace, modifierFlags); // namespaces can never be default exported
                }
                else if (expanding) {
                    context.approximateLength += 14; // "namespace { }"
                    addResult(
                        factory.createModuleDeclaration(
                            /*modifiers*/ undefined,
                            localName,
                            factory.createModuleBlock([]),
                            nodeFlags,
                        ),
                        modifierFlags,
                    );
                }
            }

            function isNamespaceMember(p: Symbol) {
                return !!(p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias)) ||
                    !(p.flags & SymbolFlags.Prototype || p.escapedName === "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent));
            }

            function sanitizeJSDocImplements(clauses: readonly ExpressionWithTypeArguments[]): ExpressionWithTypeArguments[] | undefined {
                const result = mapDefined(clauses, e => {
                    const oldEnclosing = context.enclosingDeclaration;
                    context.enclosingDeclaration = e;
                    let expr = e.expression;
                    if (isEntityNameExpression(expr)) {
                        if (isIdentifier(expr) && idText(expr) === "") {
                            return cleanup(/*result*/ undefined); // Empty heritage clause, should be an error, but prefer emitting no heritage clauses to reemitting the empty one
                        }
                        let introducesError: boolean;
                        ({ introducesError, node: expr } = trackExistingEntityName(expr, context));
                        if (introducesError) {
                            return cleanup(/*result*/ undefined);
                        }
                    }
                    return cleanup(factory.createExpressionWithTypeArguments(
                        expr,
                        map(e.typeArguments, a =>
                            syntacticNodeBuilder.tryReuseExistingTypeNode(context, a)
                            || typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context)),
                    ));

                    function cleanup<T>(result: T): T {
                        context.enclosingDeclaration = oldEnclosing;
                        return result;
                    }
                });
                if (result.length === clauses.length) {
                    return result;
                }
                return undefined;
            }

            function serializeAsClass(symbol: Symbol, localName: string, modifierFlags: ModifierFlags) {
                context.approximateLength += 9 + localName.length; // `class localName { }`
                const originalDecl = symbol.declarations?.find(isClassLike);
                const oldEnclosing = context.enclosingDeclaration;
                context.enclosingDeclaration = originalDecl || oldEnclosing;
                const localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                const typeParamDecls = map(localParams, p => typeParameterToDeclaration(p, context));
                forEach(localParams, p => context.approximateLength += symbolName(p.symbol).length);
                const classType = getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol)) as InterfaceType;
                const baseTypes = getBaseTypes(classType);
                const originalImplements = originalDecl && getEffectiveImplementsTypeNodes(originalDecl);
                const implementsExpressions = originalImplements && sanitizeJSDocImplements(originalImplements)
                    || mapDefined(getImplementsTypes(classType), serializeImplementedType);
                const staticType = getTypeOfSymbol(symbol);
                const isClass = !!staticType.symbol?.valueDeclaration && isClassLike(staticType.symbol.valueDeclaration);
                const staticBaseType = isClass
                    ? getBaseConstructorTypeOfClass(staticType as InterfaceType)
                    : anyType;
                context.approximateLength += (length(baseTypes) ? 8 : 0) + (length(implementsExpressions) ? 11 : 0); // `extends ` and `implements `
                const heritageClauses = [
                    ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))],
                    ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)],
                ];
                const symbolProps = getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType));
                const publicSymbolProps = filter(symbolProps, s => !isHashPrivate(s));
                const hasPrivateIdentifier = some(symbolProps, isHashPrivate);
                // Boil down all private properties into a single one.
                const privateProperties = hasPrivateIdentifier ?
                    isExpanding(context) ?
                        serializePropertySymbolsForClassOrInterface(filter(symbolProps, isHashPrivate), /*isClass*/ true, baseTypes[0], /*isStatic*/ false) :
                        [factory.createPropertyDeclaration(
                            /*modifiers*/ undefined,
                            factory.createPrivateIdentifier("#private"),
                            /*questionOrExclamationToken*/ undefined,
                            /*type*/ undefined,
                            /*initializer*/ undefined,
                        )] :
                    emptyArray;
                if (hasPrivateIdentifier && !isExpanding(context)) {
                    context.approximateLength += 9; // `#private;`
                }
                const publicProperties = serializePropertySymbolsForClassOrInterface(publicSymbolProps, /*isClass*/ true, baseTypes[0], /*isStatic*/ false);
                // Consider static members empty if symbol also has function or module meaning - function namespacey emit will handle statics
                const staticMembers = serializePropertySymbolsForClassOrInterface(
                    filter(getPropertiesOfType(staticType), p => !(p.flags & SymbolFlags.Prototype) && p.escapedName !== "prototype" && !isNamespaceMember(p)),
                    /*isClass*/ true,
                    staticBaseType,
                    /*isStatic*/ true,
                );
                // When we encounter an `X.prototype.y` assignment in a JS file, we bind `X` as a class regardless as to whether
                // the value is ever initialized with a class or function-like value. For cases where `X` could never be
                // created via `new`, we will inject a `private constructor()` declaration to indicate it is not createable.
                const isNonConstructableClassLikeInJsFile = !isClass &&
                    !!symbol.valueDeclaration &&
                    isInJSFile(symbol.valueDeclaration) &&
                    !some(getSignaturesOfType(staticType, SignatureKind.Construct));
                if (isNonConstructableClassLikeInJsFile) context.approximateLength += 21; // `private constructor()`
                const constructors = isNonConstructableClassLikeInJsFile ?
                    [factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlags.Private), [], /*body*/ undefined)] :
                    serializeSignatures(SignatureKind.Construct, staticType, staticBaseType, SyntaxKind.Constructor) as ConstructorDeclaration[];
                const indexSignatures = serializeIndexSignatures(classType, baseTypes[0]);
                context.enclosingDeclaration = oldEnclosing;
                addResult(
                    setTextRange(
                        context,
                        factory.createClassDeclaration(
                            /*modifiers*/ undefined,
                            localName,
                            typeParamDecls,
                            heritageClauses,
                            [...indexSignatures, ...staticMembers, ...constructors, ...publicProperties, ...privateProperties],
                        ),
                        symbol.declarations && filter(symbol.declarations, d => isClassDeclaration(d) || isClassExpression(d))[0],
                    ),
                    modifierFlags,
                );
            }

            function getSomeTargetNameFromDeclarations(declarations: Declaration[] | undefined) {
                return firstDefined(declarations, d => {
                    if (isImportSpecifier(d) || isExportSpecifier(d)) {
                        return moduleExportNameTextUnescaped(d.propertyName || d.name);
                    }
                    if (isBinaryExpression(d) || isExportAssignment(d)) {
                        const expression = isExportAssignment(d) ? d.expression : d.right;
                        if (isPropertyAccessExpression(expression)) {
                            return idText(expression.name);
                        }
                    }
                    if (isAliasSymbolDeclaration(d)) {
                        // This is... heuristic, at best. But it's probably better than always printing the name of the shorthand ambient module.
                        const name = getNameOfDeclaration(d);
                        if (name && isIdentifier(name)) {
                            return idText(name);
                        }
                    }
                    return undefined;
                });
            }

            function serializeAsAlias(symbol: Symbol, localName: string, modifierFlags: ModifierFlags) {
                // synthesize an alias, eg `export { symbolName as Name }`
                // need to mark the alias `symbol` points at
                // as something we need to serialize as a private declaration as well
                const node = getDeclarationOfAliasSymbol(symbol);
                if (!node) return Debug.fail();
                const target = getMergedSymbol(getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve*/ true));
                if (!target) {
                    return;
                }
                // If `target` refers to a shorthand module symbol, the name we're trying to pull out isn;t recoverable from the target symbol
                // In such a scenario, we must fall back to looking for an alias declaration on `symbol` and pulling the target name from that
                let verbatimTargetName = isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName);
                if (verbatimTargetName === InternalSymbolName.ExportEquals && allowSyntheticDefaultImports) {
                    // target refers to an `export=` symbol that was hoisted into a synthetic default - rename here to match
                    verbatimTargetName = InternalSymbolName.Default;
                }
                const targetName = getInternalSymbolName(target, verbatimTargetName);
                includePrivateSymbol(target); // the target may be within the same scope - attempt to serialize it first
                switch (node.kind) {
                    case SyntaxKind.BindingElement:
                        if (node.parent?.parent?.kind === SyntaxKind.VariableDeclaration) {
                            // const { SomeClass } = require('./lib');
                            const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // './lib'
                            const { propertyName } = node as BindingElement;
                            const propertyNameText = propertyName && isIdentifier(propertyName) ? idText(propertyName) : undefined;
                            context.approximateLength += 24 + localName.length + specifier.length + (propertyNameText?.length ?? 0); // `import { propertyName as name } from "specifier";`
                            addResult(
                                factory.createImportDeclaration(
                                    /*modifiers*/ undefined,
                                    factory.createImportClause(
                                        /*phaseModifier*/ undefined,
                                        /*name*/ undefined,
                                        factory.createNamedImports([factory.createImportSpecifier(
                                            /*isTypeOnly*/ false,
                                            propertyNameText ? factory.createIdentifier(propertyNameText) : undefined,
                                            factory.createIdentifier(localName),
                                        )]),
                                    ),
                                    factory.createStringLiteral(specifier),
                                    /*attributes*/ undefined,
                                ),
                                ModifierFlags.None,
                            );
                            break;
                        }
                        // We don't know how to serialize this (nested?) binding element
                        Debug.failBadSyntaxKind(node.parent?.parent || node, "Unhandled binding element grandparent kind in declaration serialization");
                        break;
                    case SyntaxKind.ShorthandPropertyAssignment:
                        if (node.parent?.parent?.kind === SyntaxKind.BinaryExpression) {
                            // module.exports = { SomeClass }
                            serializeExportSpecifier(
                                unescapeLeadingUnderscores(symbol.escapedName),
                                targetName,
                            );
                        }
                        break;
                    case SyntaxKind.VariableDeclaration:
                        // commonjs require: const x = require('y')
                        if (isPropertyAccessExpression((node as VariableDeclaration).initializer!)) {
                            // const x = require('y').z
                            const initializer = (node as VariableDeclaration).initializer! as PropertyAccessExpression; // require('y').z
                            const uniqueName = factory.createUniqueName(localName); // _x
                            const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // 'y'
                            // import _x = require('y');
                            context.approximateLength += 22 + specifier.length + idText(uniqueName).length; // `import uniqueName = require("specifier");`
                            addResult(
                                factory.createImportEqualsDeclaration(
                                    /*modifiers*/ undefined,
                                    /*isTypeOnly*/ false,
                                    uniqueName,
                                    factory.createExternalModuleReference(factory.createStringLiteral(specifier)),
                                ),
                                ModifierFlags.None,
                            );
                            // import x = _x.z
                            context.approximateLength += 12 + localName.length + idText(uniqueName).length + idText(initializer.name).length; // `import localName = uniqueName.initializerName;`
                            addResult(
                                factory.createImportEqualsDeclaration(
                                    /*modifiers*/ undefined,
                                    /*isTypeOnly*/ false,
                                    factory.createIdentifier(localName),
                                    factory.createQualifiedName(uniqueName, initializer.name as Identifier),
                                ),
                                modifierFlags,
                            );
                            break;
                        }
                        // else fall through and treat commonjs require just like import=
                    case SyntaxKind.ImportEqualsDeclaration:
                        // This _specifically_ only exists to handle json declarations - where we make aliases, but since
                        // we emit no declarations for the json document, must not refer to it in the declarations
                        if (target.escapedName === InternalSymbolName.ExportEquals && some(target.declarations, d => isSourceFile(d) && isJsonSourceFile(d))) {
                            serializeMaybeAliasAssignment(symbol);
                            break;
                        }
                        // Could be a local `import localName = ns.member` or
                        // an external `import localName = require("whatever")`
                        const isLocalImport = !(target.flags & SymbolFlags.ValueModule) && !isVariableDeclaration(node);
                        context.approximateLength += 11 + localName.length + unescapeLeadingUnderscores(target.escapedName).length; // `import localName = target;`
                        addResult(
                            factory.createImportEqualsDeclaration(
                                /*modifiers*/ undefined,
                                /*isTypeOnly*/ false,
                                factory.createIdentifier(localName),
                                isLocalImport
                                    ? symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier*/ false)
                                    : factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))),
                            ),
                            isLocalImport ? modifierFlags : ModifierFlags.None,
                        );
                        break;
                    case SyntaxKind.NamespaceExportDeclaration:
                        // export as namespace foo
                        // TODO: Not part of a file's local or export symbol tables
                        // Is bound into file.symbol.globalExports instead, which we don't currently traverse
                        addResult(factory.createNamespaceExportDeclaration(idText((node as NamespaceExportDeclaration).name)), ModifierFlags.None);
                        break;
                    case SyntaxKind.ImportClause: {
                        const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
                        const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportClause).parent.moduleSpecifier;
                        const attributes = isImportDeclaration(node.parent) ? node.parent.attributes : undefined;
                        const isTypeOnly = isJSDocImportTag((node as ImportClause).parent);
                        context.approximateLength += 14 + localName.length + 3 + (isTypeOnly ? 4 : 0); // `import localName from specifier;`, approximate specifier
                        addResult(
                            factory.createImportDeclaration(
                                /*modifiers*/ undefined,
                                factory.createImportClause(
                                    /* phaseModifier */ isTypeOnly ? SyntaxKind.TypeKeyword : undefined,
                                    factory.createIdentifier(localName),
                                    /*namedBindings*/ undefined,
                                ),
                                specifier,
                                attributes,
                            ),
                            ModifierFlags.None,
                        );
                        break;
                    }
                    case SyntaxKind.NamespaceImport: {
                        const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
                        const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as NamespaceImport).parent.parent.moduleSpecifier;
                        const isTypeOnly = isJSDocImportTag((node as NamespaceImport).parent.parent);
                        context.approximateLength += 19 + localName.length + 3 + (isTypeOnly ? 4 : 0); // `import * as localName from specifier;`, approximate specifier
                        addResult(
                            factory.createImportDeclaration(
                                /*modifiers*/ undefined,
                                factory.createImportClause(
                                    /* phaseModifier */ isTypeOnly ? SyntaxKind.TypeKeyword : undefined,
                                    /*name*/ undefined,
                                    factory.createNamespaceImport(factory.createIdentifier(localName)),
                                ),
                                specifier,
                                (node as ImportClause).parent.attributes,
                            ),
                            ModifierFlags.None,
                        );
                        break;
                    }
                    case SyntaxKind.NamespaceExport:
                        context.approximateLength += 19 + localName.length + 3; // `export * as localName from specifier;`, approximate specifier
                        addResult(
                            factory.createExportDeclaration(
                                /*modifiers*/ undefined,
                                /*isTypeOnly*/ false,
                                factory.createNamespaceExport(factory.createIdentifier(localName)),
                                factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)),
                            ),
                            ModifierFlags.None,
                        );
                        break;
                    case SyntaxKind.ImportSpecifier: {
                        const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
                        const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportSpecifier).parent.parent.parent.moduleSpecifier;
                        const isTypeOnly = isJSDocImportTag((node as ImportSpecifier).parent.parent.parent);
                        context.approximateLength += 19 + localName.length + 3 + (isTypeOnly ? 4 : 0); // `import { localName } from specifier;`, approximate specifier
                        addResult(
                            factory.createImportDeclaration(
                                /*modifiers*/ undefined,
                                factory.createImportClause(
                                    /* phaseModifier */ isTypeOnly ? SyntaxKind.TypeKeyword : undefined,
                                    /*name*/ undefined,
                                    factory.createNamedImports([
                                        factory.createImportSpecifier(
                                            /*isTypeOnly*/ false,
                                            localName !== verbatimTargetName ? factory.createIdentifier(verbatimTargetName) : undefined,
                                            factory.createIdentifier(localName),
                                        ),
                                    ]),
                                ),
                                specifier,
                                (node as ImportSpecifier).parent.parent.parent.attributes,
                            ),
                            ModifierFlags.None,
                        );
                        break;
                    }
                    case SyntaxKind.ExportSpecifier:
                        // does not use localName because the symbol name in this case refers to the name in the exports table,
                        // which we must exactly preserve
                        const specifier = (node.parent.parent as ExportDeclaration).moduleSpecifier;
                        if (specifier) {
                            const propertyName = (node as ExportSpecifier).propertyName;
                            if (propertyName && moduleExportNameIsDefault(propertyName)) {
                                verbatimTargetName = InternalSymbolName.Default;
                            }
                        }
                        // targetName is only used when the target is local, as otherwise the target is an alias that points at
                        // another file
                        serializeExportSpecifier(
                            unescapeLeadingUnderscores(symbol.escapedName),
                            specifier ? verbatimTargetName : targetName,
                            specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(specifier.text) : undefined,
                        );
                        break;
                    case SyntaxKind.ExportAssignment:
                        serializeMaybeAliasAssignment(symbol);
                        break;
                    case SyntaxKind.BinaryExpression:
                    case SyntaxKind.PropertyAccessExpression:
                    case SyntaxKind.ElementAccessExpression:
                        // Could be best encoded as though an export specifier or as though an export assignment
                        // If name is default or export=, do an export assignment
                        // Otherwise do an export specifier
                        if (symbol.escapedName === InternalSymbolName.Default || symbol.escapedName === InternalSymbolName.ExportEquals) {
                            serializeMaybeAliasAssignment(symbol);
                        }
                        else {
                            serializeExportSpecifier(localName, targetName);
                        }
                        break;
                    default:
                        return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!");
                }
            }

            function serializeExportSpecifier(localName: string, targetName: string, specifier?: Expression) {
                context.approximateLength += 16 + localName.length + (localName !== targetName ? targetName.length : 0); // `export { targetName as localName };`
                addResult(
                    factory.createExportDeclaration(
                        /*modifiers*/ undefined,
                        /*isTypeOnly*/ false,
                        factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly*/ false, localName !== targetName ? targetName : undefined, localName)]),
                        specifier,
                    ),
                    ModifierFlags.None,
                );
            }

            /**
             * Returns `true` if an export assignment or declaration was produced for the symbol
             */
            function serializeMaybeAliasAssignment(symbol: Symbol): boolean {
                if (symbol.flags & SymbolFlags.Prototype) {
                    return false;
                }
                const name = unescapeLeadingUnderscores(symbol.escapedName);
                const isExportEquals = name === InternalSymbolName.ExportEquals;
                const isDefault = name === InternalSymbolName.Default;
                const isExportAssignmentCompatibleSymbolName = isExportEquals || isDefault;
                // synthesize export = ref
                // ref should refer to either be a locally scoped symbol which we need to emit, or
                // a reference to another namespace/module which we may need to emit an `import` statement for
                const aliasDecl = symbol.declarations && getDeclarationOfAliasSymbol(symbol);
                // serialize what the alias points to, preserve the declaration's initializer
                const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve*/ true);
                // If the target resolves and resolves to a thing defined in this file, emit as an alias, otherwise emit as a const
                if (target && length(target.declarations) && some(target.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(enclosingDeclaration))) {
                    // In case `target` refers to a namespace member, look at the declaration and serialize the leftmost symbol in it
                    // eg, `namespace A { export class B {} }; exports = A.B;`
                    // Technically, this is all that's required in the case where the assignment is an entity name expression
                    const expr = aliasDecl && ((isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression));
                    const first = expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined;
                    const referenced = first && resolveEntityName(first, SymbolFlags.All, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, enclosingDeclaration);
                    if (referenced || target) {
                        includePrivateSymbol(referenced || target);
                    }

                    // We disable the context's symbol tracker for the duration of this name serialization
                    // as, by virtue of being here, the name is required to print something, and we don't want to
                    // issue a visibility error on it. Only anonymous classes that an alias points at _would_ issue
                    // a visibility error here (as they're not visible within any scope), but we want to hoist them
                    // into the containing scope anyway, so we want to skip the visibility checks.
                    const prevDisableTrackSymbol = context.tracker.disableTrackSymbol;
                    context.tracker.disableTrackSymbol = true;
                    if (isExportAssignmentCompatibleSymbolName) {
                        context.approximateLength += 10; // `export = ;`
                        results.push(factory.createExportAssignment(
                            /*modifiers*/ undefined,
                            isExportEquals,
                            symbolToExpression(target, context, SymbolFlags.All),
                        ));
                    }
                    else {
                        if (first === expr && first) {
                            // serialize as `export {target as name}`
                            serializeExportSpecifier(name, idText(first));
                        }
                        else if (expr && isClassExpression(expr)) {
                            serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)));
                        }
                        else {
                            // serialize as `import _Ref = t.arg.et; export { _Ref as name }`
                            const varName = getUnusedName(name, symbol);
                            context.approximateLength += varName.length + 10; // `import name = ;`
                            addResult(
                                factory.createImportEqualsDeclaration(
                                    /*modifiers*/ undefined,
                                    /*isTypeOnly*/ false,
                                    factory.createIdentifier(varName),
                                    symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier*/ false),
                                ),
                                ModifierFlags.None,
                            );
                            serializeExportSpecifier(name, varName);
                        }
                    }
                    context.tracker.disableTrackSymbol = prevDisableTrackSymbol;
                    return true;
                }
                else {
                    // serialize as an anonymous property declaration
                    const varName = getUnusedName(name, symbol);
                    // We have to use `getWidenedType` here since the object within a json file is unwidened within the file
                    // (Unwidened types can only exist in expression contexts and should never be serialized)
                    const typeToSerialize = getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)));
                    if (isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol)) {
                        // If there are no index signatures and `typeToSerialize` is an object type, emit as a namespace instead of a const
                        serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, isExportAssignmentCompatibleSymbolName ? ModifierFlags.None : ModifierFlags.Export);
                    }
                    else {
                        const flags = context.enclosingDeclaration?.kind === SyntaxKind.ModuleDeclaration && (!(symbol.flags & SymbolFlags.Accessor) || symbol.flags & SymbolFlags.SetAccessor) ? NodeFlags.Let : NodeFlags.Const;
                        context.approximateLength += varName.length + 5; // `var name: ;`
                        const statement = factory.createVariableStatement(
                            /*modifiers*/ undefined,
                            factory.createVariableDeclarationList([
                                factory.createVariableDeclaration(varName, /*exclamationToken*/ undefined, serializeTypeForDeclaration(context, /*declaration*/ undefined, typeToSerialize, symbol)),
                            ], flags),
                        );
                        // Inlined JSON types exported with [module.]exports= will already emit an export=, so should use `declare`.
                        // Otherwise, the type itself should be exported.
                        addResult(
                            statement,
                            target && target.flags & SymbolFlags.Property && target.escapedName === InternalSymbolName.ExportEquals ? ModifierFlags.Ambient
                                : name === varName ? ModifierFlags.Export
                                : ModifierFlags.None,
                        );
                    }
                    if (isExportAssignmentCompatibleSymbolName) {
                        context.approximateLength += varName.length + 10; // `export = name;`
                        results.push(factory.createExportAssignment(
                            /*modifiers*/ undefined,
                            isExportEquals,
                            factory.createIdentifier(varName),
                        ));
                        return true;
                    }
                    else if (name !== varName) {
                        serializeExportSpecifier(name, varName);
                        return true;
                    }
                    return false;
                }
            }

            function isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize: Type, hostSymbol: Symbol) {
                // Only object types which are not constructable, or indexable, whose members all come from the
                // context source file, and whose property names are all valid identifiers and not late-bound, _and_
                // whose input is not type annotated (if the input symbol has an annotation we can reuse, we should prefer it)
                const ctxSrc = getSourceFileOfNode(context.enclosingDeclaration);
                return getObjectFlags(typeToSerialize) & (ObjectFlags.Anonymous | ObjectFlags.Mapped) &&
                    !some(typeToSerialize.symbol?.declarations, isTypeNode) && // If the type comes straight from a type node, we shouldn't try to break it up
                    !length(getIndexInfosOfType(typeToSerialize)) &&
                    !isClassInstanceSide(typeToSerialize) && // While a class instance is potentially representable as a NS, prefer printing a reference to the instance type and serializing the class
                    !!(length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, SignatureKind.Call))) &&
                    !length(getSignaturesOfType(typeToSerialize, SignatureKind.Construct)) && // TODO: could probably serialize as function + ns + class, now that that's OK
                    !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) &&
                    !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, d => getSourceFileOfNode(d) !== ctxSrc)) &&
                    !some(getPropertiesOfType(typeToSerialize), p => isLateBoundName(p.escapedName)) &&
                    !some(getPropertiesOfType(typeToSerialize), p => some(p.declarations, d => getSourceFileOfNode(d) !== ctxSrc)) &&
                    every(getPropertiesOfType(typeToSerialize), p => {
                        if (!isIdentifierText(symbolName(p), languageVersion)) {
                            return false;
                        }
                        if (!(p.flags & SymbolFlags.Accessor)) {
                            return true;
                        }
                        return getNonMissingTypeOfSymbol(p) === getWriteTypeOfSymbol(p);
                    });
            }

            function makeSerializePropertySymbol<T extends Node>(
                createProperty: (
                    modifiers: readonly Modifier[] | undefined,
                    name: string | PropertyName,
                    questionOrExclamationToken: QuestionToken | undefined,
                    type: TypeNode | undefined,
                    initializer: Expression | undefined,
                ) => T,
                methodKind: SignatureDeclaration["kind"],
                useAccessors: true,
            ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | AccessorDeclaration | (T | AccessorDeclaration)[];
            function makeSerializePropertySymbol<T extends Node>(
                createProperty: (
                    modifiers: readonly Modifier[] | undefined,
                    name: string | PropertyName,
                    questionOrExclamationToken: QuestionToken | undefined,
                    type: TypeNode | undefined,
                    initializer: Expression | undefined,
                ) => T,
                methodKind: SignatureDeclaration["kind"],
                useAccessors: false,
            ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | T[];
            function makeSerializePropertySymbol<T extends Node>(
                createProperty: (
                    modifiers: readonly Modifier[] | undefined,
                    name: string | PropertyName,
                    questionOrExclamationToken: QuestionToken | undefined,
                    type: TypeNode | undefined,
                    initializer: Expression | undefined,
                ) => T,
                methodKind: SignatureDeclaration["kind"],
                useAccessors: boolean,
            ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | AccessorDeclaration | (T | AccessorDeclaration)[] {
                return function serializePropertySymbol(p: Symbol, isStatic: boolean, baseType: Type | undefined): T | AccessorDeclaration | (T | AccessorDeclaration)[] {
                    const modifierFlags = getDeclarationModifierFlagsFromSymbol(p);
                    const omitType = !!(modifierFlags & ModifierFlags.Private) && !isExpanding(context);
                    if (isStatic && (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias))) {
                        // Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols
                        // need to be merged namespace members
                        return [];
                    }
                    if (
                        p.flags & SymbolFlags.Prototype || p.escapedName === "constructor" ||
                        (baseType && getPropertyOfType(baseType, p.escapedName)
                            && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)!) === isReadonlySymbol(p)
                            && (p.flags & SymbolFlags.Optional) === (getPropertyOfType(baseType, p.escapedName)!.flags & SymbolFlags.Optional)
                            && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)!))
                    ) {
                        return [];
                    }
                    const flag = (modifierFlags & ~ModifierFlags.Async) | (isStatic ? ModifierFlags.Static : 0);
                    const name = getPropertyNameNodeForSymbol(p, context);
                    const firstPropertyLikeDecl = p.declarations?.find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression));
                    if (p.flags & SymbolFlags.Accessor && useAccessors) {
                        const result: AccessorDeclaration[] = [];
                        if (p.flags & SymbolFlags.SetAccessor) {
                            const setter = p.declarations && forEach(p.declarations, d => {
                                if (d.kind === SyntaxKind.SetAccessor) {
                                    return d as SetAccessorDeclaration;
                                }
                                if (isCallExpression(d) && isBindableObjectDefinePropertyCall(d)) {
                                    return forEach(d.arguments[2].properties, propDecl => {
                                        const id = getNameOfDeclaration(propDecl);
                                        if (!!id && isIdentifier(id) && idText(id) === "set") {
                                            return propDecl;
                                        }
                                    });
                                }
                            });

                            Debug.assert(!!setter);
                            const paramSymbol = isFunctionLikeDeclaration(setter) ? getSignatureFromDeclaration(setter).parameters[0] : undefined;
                            const setterDeclaration = p.declarations?.find(isSetAccessor);
                            context.approximateLength += modifiersLength(flag) + 7 + (paramSymbol ? symbolName(paramSymbol).length : 5) + (omitType ? 0 : 2); // `modifiers set name(param);`, approximate name
                            result.push(setTextRange(
                                context,
                                factory.createSetAccessorDeclaration(
                                    factory.createModifiersFromModifierFlags(flag),
                                    name,
                                    [factory.createParameterDeclaration(
                                        /*modifiers*/ undefined,
                                        /*dotDotDotToken*/ undefined,
                                        paramSymbol ? parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context) : "value",
                                        /*questionToken*/ undefined,
                                        omitType ? undefined : serializeTypeForDeclaration(context, setterDeclaration, getWriteTypeOfSymbol(p), p),
                                    )],
                                    /*body*/ undefined,
                                ),
                                setterDeclaration ?? firstPropertyLikeDecl,
                            ));
                        }
                        if (p.flags & SymbolFlags.GetAccessor) {
                            const getterDeclaration = p.declarations?.find(isGetAccessor);
                            context.approximateLength += modifiersLength(flag) + 8 + (omitType ? 0 : 2); // `modifiers get name(): ;`, approximate name
                            result.push(setTextRange(
                                context,
                                factory.createGetAccessorDeclaration(
                                    factory.createModifiersFromModifierFlags(flag),
                                    name,
                                    [],
                                    omitType ? undefined : serializeTypeForDeclaration(context, getterDeclaration, getTypeOfSymbol(p), p),
                                    /*body*/ undefined,
                                ),
                                getterDeclaration ?? firstPropertyLikeDecl,
                            ));
                        }
                        return result;
                    }
                    // This is an else/if as accessors and properties can't merge in TS, but might in JS
                    // If this happens, we assume the accessor takes priority, as it imposes more constraints
                    else if (p.flags & (SymbolFlags.Property | SymbolFlags.Variable | SymbolFlags.Accessor)) {
                        const modifierFlags = (isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag;
                        context.approximateLength += 2 + (omitType ? 0 : 2) + modifiersLength(modifierFlags); // `modifiers name: ;`, approximate name
                        return setTextRange(
                            context,
                            createProperty(
                                factory.createModifiersFromModifierFlags(modifierFlags),
                                name,
                                p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                                omitType ? undefined : serializeTypeForDeclaration(context, p.declarations?.find(isSetAccessorDeclaration), getWriteTypeOfSymbol(p), p),
                                // TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357
                                // interface members can't have initializers, however class members _can_
                                /*initializer*/ undefined,
                            ),
                            p.declarations?.find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl,
                        );
                    }
                    if (p.flags & (SymbolFlags.Method | SymbolFlags.Function)) {
                        const type = getTypeOfSymbol(p);
                        const signatures = getSignaturesOfType(type, SignatureKind.Call);
                        if (omitType) {
                            const modifierFlags = (isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag;
                            context.approximateLength += 1 + modifiersLength(modifierFlags); // `modifiers name;`, approximate name
                            return setTextRange(
                                context,
                                createProperty(
                                    factory.createModifiersFromModifierFlags(modifierFlags),
                                    name,
                                    p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                                    /*type*/ undefined,
                                    /*initializer*/ undefined,
                                ),
                                p.declarations?.find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0],
                            );
                        }

                        const results = [];
                        for (const sig of signatures) {
                            context.approximateLength += 1; // ;
                            // Each overload becomes a separate method declaration, in order
                            const decl = signatureToSignatureDeclarationHelper(
                                sig,
                                methodKind,
                                context,
                                {
                                    name,
                                    questionToken: p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                                    modifiers: flag ? factory.createModifiersFromModifierFlags(flag) : undefined,
                                },
                            );
                            const location = sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;
                            results.push(setTextRange(context, decl, location));
                        }
                        return results as unknown as T[];
                    }
                    // The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static
                    return Debug.fail(`Unhandled class member kind! ${(p as any).__debugFlags || p.flags}`);
                };
            }

            function modifiersLength(flags: ModifierFlags): number {
                let result = 0;
                // Include the trailing space after the modifier keyword.
                if (flags & ModifierFlags.Export) result += 7;
                if (flags & ModifierFlags.Ambient) result += 8;
                if (flags & ModifierFlags.Default) result += 8;
                if (flags & ModifierFlags.Const) result += 6;
                if (flags & ModifierFlags.Public) result += 7;
                if (flags & ModifierFlags.Private) result += 8;
                if (flags & ModifierFlags.Protected) result += 10;
                if (flags & ModifierFlags.Abstract) result += 9;
                if (flags & ModifierFlags.Static) result += 7;
                if (flags & ModifierFlags.Override) result += 9;
                if (flags & ModifierFlags.Readonly) result += 9;
                if (flags & ModifierFlags.Accessor) result += 9;
                if (flags & ModifierFlags.Async) result += 6;
                if (flags & ModifierFlags.In) result += 3;
                if (flags & ModifierFlags.Out) result += 4;
                return result;
            }

            function serializePropertySymbolForInterface(p: Symbol, baseType: Type | undefined) {
                return serializePropertySymbolForInterfaceWorker(p, /*isStatic*/ false, baseType);
            }

            function serializeSignatures(kind: SignatureKind, input: Type, baseType: Type | undefined, outputKind: SignatureDeclaration["kind"]) {
                const signatures = getSignaturesOfType(input, kind);
                if (kind === SignatureKind.Construct) {
                    if (!baseType && every(signatures, s => length(s.parameters) === 0)) {
                        return []; // No base type, every constructor is empty - elide the extraneous `constructor()`
                    }
                    if (baseType) {
                        // If there is a base type, if every signature in the class is identical to a signature in the baseType, elide all the declarations
                        const baseSigs = getSignaturesOfType(baseType, SignatureKind.Construct);
                        if (!length(baseSigs) && every(signatures, s => length(s.parameters) === 0)) {
                            return []; // Base had no explicit signatures, if all our signatures are also implicit, return an empty list
                        }
                        if (baseSigs.length === signatures.length) {
                            let failed = false;
                            for (let i = 0; i < baseSigs.length; i++) {
                                if (!compareSignaturesIdentical(signatures[i], baseSigs[i], /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true, compareTypesIdentical)) {
                                    failed = true;
                                    break;
                                }
                            }
                            if (!failed) {
                                return []; // Every signature was identical - elide constructor list as it is inherited
                            }
                        }
                    }
                    let privateProtected: ModifierFlags = 0;
                    for (const s of signatures) {
                        if (s.declaration) {
                            privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlags.Private | ModifierFlags.Protected);
                        }
                    }
                    if (privateProtected) {
                        return [setTextRange(
                            context,
                            factory.createConstructorDeclaration(
                                factory.createModifiersFromModifierFlags(privateProtected),
                                /*parameters*/ [],
                                /*body*/ undefined,
                            ),
                            signatures[0].declaration,
                        )];
                    }
                }

                const results = [];
                for (const sig of signatures) {
                    context.approximateLength += 1; // ;
                    // Each overload becomes a separate constructor declaration, in order
                    const decl = signatureToSignatureDeclarationHelper(sig, outputKind, context);
                    results.push(setTextRange(context, decl, sig.declaration));
                }
                return results;
            }

            function serializeIndexSignatures(input: Type, baseType: Type | undefined) {
                const results: IndexSignatureDeclaration[] = [];
                for (const info of getIndexInfosOfType(input)) {
                    if (baseType) {
                        const baseInfo = getIndexInfoOfType(baseType, info.keyType);
                        if (baseInfo) {
                            if (isTypeIdenticalTo(info.type, baseInfo.type)) {
                                continue; // elide identical index signatures
                            }
                        }
                    }
                    results.push(indexInfoToIndexSignatureDeclarationHelper(info, context, /*typeNode*/ undefined));
                }
                return results;
            }

            function serializeBaseType(t: Type, staticType: Type, rootName: string) {
                const ref = trySerializeAsTypeReference(t, SymbolFlags.Value);
                if (ref) {
                    return ref;
                }
                const tempName = getUnusedName(`${rootName}_base`);
                const statement = factory.createVariableStatement(
                    /*modifiers*/ undefined,
                    factory.createVariableDeclarationList([
                        factory.createVariableDeclaration(tempName, /*exclamationToken*/ undefined, typeToTypeNodeHelper(staticType, context)),
                    ], NodeFlags.Const),
                );
                addResult(statement, ModifierFlags.None);
                return factory.createExpressionWithTypeArguments(factory.createIdentifier(tempName), /*typeArguments*/ undefined);
            }

            function trySerializeAsTypeReference(t: Type, flags: SymbolFlags) {
                let typeArgs: TypeNode[] | undefined;
                let reference: Expression | undefined;

                // We don't use `isValueSymbolAccessible` below. since that considers alternative containers (like modules)
                // which we can't write out in a syntactically valid way as an expression
                if ((t as TypeReference).target && isSymbolAccessibleByFlags((t as TypeReference).target.symbol, enclosingDeclaration, flags)) {
                    typeArgs = map(getTypeArguments(t as TypeReference), t => typeToTypeNodeHelper(t, context));
                    reference = symbolToExpression((t as TypeReference).target.symbol, context, SymbolFlags.Type);
                }
                else if (t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags)) {
                    reference = symbolToExpression(t.symbol, context, SymbolFlags.Type);
                }
                if (reference) {
                    return factory.createExpressionWithTypeArguments(reference, typeArgs);
                }
            }

            function serializeImplementedType(t: Type) {
                const ref = trySerializeAsTypeReference(t, SymbolFlags.Type);
                if (ref) {
                    return ref;
                }
                if (t.symbol) {
                    return factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, SymbolFlags.Type), /*typeArguments*/ undefined);
                }
            }

            function getUnusedName(input: string, symbol?: Symbol): string {
                const id = symbol ? getSymbolId(symbol) : undefined;
                if (id) {
                    if (context.remappedSymbolNames!.has(id)) {
                        return context.remappedSymbolNames!.get(id)!;
                    }
                }
                if (symbol) {
                    input = getNameCandidateWorker(symbol, input);
                }
                let i = 0;
                const original = input;
                while (context.usedSymbolNames?.has(input)) {
                    i++;
                    input = `${original}_${i}`;
                }
                context.usedSymbolNames?.add(input);
                if (id) {
                    context.remappedSymbolNames!.set(id, input);
                }
                return input;
            }

            function getNameCandidateWorker(symbol: Symbol, localName: string) {
                if (localName === InternalSymbolName.Default || localName === InternalSymbolName.Class || localName === InternalSymbolName.Function) {
                    const restoreFlags = saveRestoreFlags(context);
                    context.flags |= NodeBuilderFlags.InInitialEntityName;
                    const nameCandidate = getNameOfSymbolAsWritten(symbol, context);
                    restoreFlags();
                    localName = nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? stripQuotes(nameCandidate) : nameCandidate;
                }
                if (localName === InternalSymbolName.Default) {
                    localName = "_default";
                }
                else if (localName === InternalSymbolName.ExportEquals) {
                    localName = "_exports";
                }
                localName = isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-z0-9]/gi, "_");
                return localName;
            }

            function getInternalSymbolName(symbol: Symbol, localName: string) {
                const id = getSymbolId(symbol);
                if (context.remappedSymbolNames!.has(id)) {
                    return context.remappedSymbolNames!.get(id)!;
                }
                localName = getNameCandidateWorker(symbol, localName);
                // The result of this is going to be used as the symbol's name - lock it in, so `getUnusedName` will also pick it up
                context.remappedSymbolNames!.set(id, localName);
                return localName;
            }
        }

        function isExpanding(context: NodeBuilderContext) {
            return context.maxExpansionDepth !== -1;
        }

        function isHashPrivate(s: Symbol): boolean {
            // `valueDeclaration` could be undefined if inherited from
            // a union/intersection base type, but inherited properties
            // don't matter here.
            return !!s.valueDeclaration && isNamedDeclaration(s.valueDeclaration) && isPrivateIdentifier(s.valueDeclaration.name);
        }

        function getClonedHashPrivateName(s: Symbol): PrivateIdentifier | undefined {
            if (s.valueDeclaration && isNamedDeclaration(s.valueDeclaration) && isPrivateIdentifier(s.valueDeclaration.name)) {
                return factory.cloneNode(s.valueDeclaration.name);
            }
            return undefined;
        }
    }

    /** Returns true if a type is declared in a lib file. */
    // Don't expand types like `Array` or `Promise`, instead treating them as opaque.
    function isLibType(type: Type): boolean {
        const symbol = (getObjectFlags(type) & ObjectFlags.Reference) !== 0 ? (type as TypeReference).target.symbol : type.symbol;
        return isTupleType(type) || !!(symbol?.declarations?.some(decl => host.isSourceFileDefaultLibrary(getSourceFileOfNode(decl))));
    }

    function typePredicateToString(typePredicate: TypePredicate, enclosingDeclaration?: Node, flags: TypeFormatFlags = TypeFormatFlags.UseAliasDefinedOutsideCurrentScope, writer?: EmitTextWriter): string {
        return writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(typePredicateToStringWorker);

        function typePredicateToStringWorker(writer: EmitTextWriter) {
            const nodeBuilderFlags = toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName;
            const predicate = nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)!; // TODO: GH#18217
            const printer = createPrinterWithRemoveComments();
            const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(EmitHint.Unspecified, predicate, /*sourceFile*/ sourceFile, writer);
            return writer;
        }
    }

    function formatUnionTypes(types: readonly Type[], expandingEnum: boolean): Type[] {
        const result: Type[] = [];
        let flags = 0 as TypeFlags;
        for (let i = 0; i < types.length; i++) {
            const t = types[i];
            flags |= t.flags;
            if (!(t.flags & TypeFlags.Nullable)) {
                if (t.flags & (TypeFlags.BooleanLiteral) || !expandingEnum && (t.flags | TypeFlags.EnumLike)) {
                    const baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLikeType(t as LiteralType);
                    if (baseType.flags & TypeFlags.Union) {
                        const count = (baseType as UnionType).types.length;
                        if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType((baseType as UnionType).types[count - 1])) {
                            result.push(baseType);
                            i += count - 1;
                            continue;
                        }
                    }
                }
                result.push(t);
            }
        }
        if (flags & TypeFlags.Null) result.push(nullType);
        if (flags & TypeFlags.Undefined) result.push(undefinedType);
        return result || types;
    }

    function visibilityToString(flags: ModifierFlags): string {
        if (flags === ModifierFlags.Private) {
            return "private";
        }
        if (flags === ModifierFlags.Protected) {
            return "protected";
        }
        return "public";
    }

    function getTypeAliasForTypeLiteral(type: Type): Symbol | undefined {
        if (type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && type.symbol.declarations) {
            const node = walkUpParenthesizedTypes(type.symbol.declarations[0].parent);
            if (isTypeAliasDeclaration(node)) {
                return getSymbolOfDeclaration(node);
            }
        }
        return undefined;
    }

    function isTopLevelInExternalModuleAugmentation(node: Node): boolean {
        return node && node.parent &&
            node.parent.kind === SyntaxKind.ModuleBlock &&
            isExternalModuleAugmentation(node.parent.parent);
    }

    function isDefaultBindingContext(location: Node) {
        return location.kind === SyntaxKind.SourceFile || isAmbientModule(location);
    }

    function getNameOfSymbolFromNameType(symbol: Symbol, context?: NodeBuilderContext) {
        const nameType = getSymbolLinks(symbol).nameType;
        if (nameType) {
            if (nameType.flags & TypeFlags.StringOrNumberLiteral) {
                const name = "" + (nameType as StringLiteralType | NumberLiteralType).value;
                if (!isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name)) {
                    return `"${escapeString(name, CharacterCodes.doubleQuote)}"`;
                }
                if (isNumericLiteralName(name) && startsWith(name, "-")) {
                    return `[${name}]`;
                }
                return name;
            }
            if (nameType.flags & TypeFlags.UniqueESSymbol) {
                return `[${getNameOfSymbolAsWritten((nameType as UniqueESSymbolType).symbol, context)}]`;
            }
        }
    }

    /**
     * Gets a human-readable name for a symbol.
     * Should *not* be used for the right-hand side of a `.` -- use `symbolName(symbol)` for that instead.
     *
     * Unlike `symbolName(symbol)`, this will include quotes if the name is from a string literal.
     * It will also use a representation of a number as written instead of a decimal form, e.g. `0o11` instead of `9`.
     */
    function getNameOfSymbolAsWritten(symbol: Symbol, context?: NodeBuilderContext): string {
        if (context?.remappedSymbolReferences?.has(getSymbolId(symbol))) {
            symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))!;
        }
        if (
            context && symbol.escapedName === InternalSymbolName.Default && !(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) &&
            // If it's not the first part of an entity name, it must print as `default`
            (!(context.flags & NodeBuilderFlags.InInitialEntityName) ||
                // if the symbol is synthesized, it will only be referenced externally it must print as `default`
                !symbol.declarations ||
                // if not in the same binding context (source file, module declaration), it must print as `default`
                (context.enclosingDeclaration && findAncestor(symbol.declarations[0], isDefaultBindingContext) !== findAncestor(context.enclosingDeclaration, isDefaultBindingContext)))
        ) {
            return "default";
        }
        if (symbol.declarations && symbol.declarations.length) {
            let declaration = firstDefined(symbol.declarations, d => getNameOfDeclaration(d) ? d : undefined); // Try using a declaration with a name, first
            const name = declaration && getNameOfDeclaration(declaration);
            if (declaration && name) {
                if (isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration)) {
                    return symbolName(symbol);
                }
                if (isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlags.Late)) {
                    const nameType = getSymbolLinks(symbol).nameType;
                    if (nameType && nameType.flags & TypeFlags.StringOrNumberLiteral) {
                        // Computed property name isn't late bound, but has a well-known name type - use name type to generate a symbol name
                        const result = getNameOfSymbolFromNameType(symbol, context);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                }
                return declarationNameToString(name);
            }
            if (!declaration) {
                declaration = symbol.declarations[0]; // Declaration may be nameless, but we'll try anyway
            }
            if (declaration.parent && declaration.parent.kind === SyntaxKind.VariableDeclaration) {
                return declarationNameToString((declaration.parent as VariableDeclaration).name);
            }
            switch (declaration.kind) {
                case SyntaxKind.ClassExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.ArrowFunction:
                    if (context && !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {
                        context.encounteredError = true;
                    }
                    return declaration.kind === SyntaxKind.ClassExpression ? "(Anonymous class)" : "(Anonymous function)";
            }
        }
        const name = getNameOfSymbolFromNameType(symbol, context);
        return name !== undefined ? name : symbolName(symbol);
    }

    function isDeclarationVisible(node: Node): boolean {
        if (node) {
            const links = getNodeLinks(node);
            if (links.isVisible === undefined) {
                links.isVisible = !!determineIfDeclarationIsVisible();
            }
            return links.isVisible;
        }

        return false;

        function determineIfDeclarationIsVisible() {
            switch (node.kind) {
                case SyntaxKind.JSDocCallbackTag:
                case SyntaxKind.JSDocTypedefTag:
                case SyntaxKind.JSDocEnumTag:
                    // Top-level jsdoc type aliases are considered exported
                    // First parent is comment node, second is hosting declaration or token; we only care about those tokens or declarations whose parent is a source file
                    return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent));
                case SyntaxKind.BindingElement:
                    return isDeclarationVisible(node.parent.parent);
                case SyntaxKind.VariableDeclaration:
                    if (
                        isBindingPattern((node as VariableDeclaration).name) &&
                        !((node as VariableDeclaration).name as BindingPattern).elements.length
                    ) {
                        // If the binding pattern is empty, this variable declaration is not visible
                        return false;
                    }
                    // falls through
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.ImportEqualsDeclaration:
                    // external module augmentation is always visible
                    if (isExternalModuleAugmentation(node)) {
                        return true;
                    }
                    const parent = getDeclarationContainer(node);
                    // If the node is not exported or it is not ambient module element (except import declaration)
                    if (
                        !(getCombinedModifierFlagsCached(node as Declaration) & ModifierFlags.Export) &&
                        !(node.kind !== SyntaxKind.ImportEqualsDeclaration && parent.kind !== SyntaxKind.SourceFile && parent.flags & NodeFlags.Ambient)
                    ) {
                        return isGlobalSourceFile(parent);
                    }
                    // Exported members/ambient module elements (exception import declaration) are visible if parent is visible
                    return isDeclarationVisible(parent);

                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                    if (hasEffectiveModifier(node, ModifierFlags.Private | ModifierFlags.Protected)) {
                        // Private/protected properties/methods are not visible
                        return false;
                    }
                    // Public properties/methods are visible if its parents are visible, so:
                    // falls through

                case SyntaxKind.Constructor:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.CallSignature:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.Parameter:
                case SyntaxKind.ModuleBlock:
                case SyntaxKind.FunctionType:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.TypeLiteral:
                case SyntaxKind.TypeReference:
                case SyntaxKind.ArrayType:
                case SyntaxKind.TupleType:
                case SyntaxKind.UnionType:
                case SyntaxKind.IntersectionType:
                case SyntaxKind.ParenthesizedType:
                case SyntaxKind.NamedTupleMember:
                    return isDeclarationVisible(node.parent);

                // Default binding, import specifier and namespace import is visible
                // only on demand so by default it is not visible
                case SyntaxKind.ImportClause:
                case SyntaxKind.NamespaceImport:
                case SyntaxKind.ImportSpecifier:
                    return false;

                // Type parameters are always visible
                case SyntaxKind.TypeParameter:

                // Source file and namespace export are always visible
                // falls through
                case SyntaxKind.SourceFile:
                case SyntaxKind.NamespaceExportDeclaration:
                    return true;

                // Export assignments do not create name bindings outside the module
                case SyntaxKind.ExportAssignment:
                    return false;

                default:
                    return false;
            }
        }
    }

    function collectLinkedAliases(node: ModuleExportName, setVisibility?: boolean): Node[] | undefined {
        let exportSymbol: Symbol | undefined;
        if (node.kind !== SyntaxKind.StringLiteral && node.parent && node.parent.kind === SyntaxKind.ExportAssignment) {
            exportSymbol = resolveName(node, node, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
        }
        else if (node.parent.kind === SyntaxKind.ExportSpecifier) {
            exportSymbol = getTargetOfExportSpecifier(node.parent as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
        }
        let result: Node[] | undefined;
        let visited: Set<number> | undefined;
        if (exportSymbol) {
            visited = new Set();
            visited.add(getSymbolId(exportSymbol));
            buildVisibleNodeList(exportSymbol.declarations);
        }
        return result;

        function buildVisibleNodeList(declarations: Declaration[] | undefined) {
            forEach(declarations, declaration => {
                const resultNode = getAnyImportSyntax(declaration) || declaration;
                if (setVisibility) {
                    getNodeLinks(declaration).isVisible = true;
                }
                else {
                    result = result || [];
                    pushIfUnique(result, resultNode);
                }

                if (isInternalModuleImportEqualsDeclaration(declaration)) {
                    // Add the referenced top container visible
                    const internalModuleReference = declaration.moduleReference as Identifier | QualifiedName;
                    const firstIdentifier = getFirstIdentifier(internalModuleReference);
                    const importSymbol = resolveName(declaration, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
                    if (importSymbol && visited) {
                        if (tryAddToSet(visited, getSymbolId(importSymbol))) {
                            buildVisibleNodeList(importSymbol.declarations);
                        }
                    }
                }
            });
        }
    }

    /**
     * Push an entry on the type resolution stack. If an entry with the given target and the given property name
     * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
     * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
     * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
     * In order to see if the same query has already been done before, the target object and the propertyName both
     * must match the one passed in.
     *
     * @param target The symbol, type, or signature whose type is being queried
     * @param propertyName The property name that should be used to query the target for its type
     */
    function pushTypeResolution(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): boolean {
        const resolutionCycleStartIndex = findResolutionCycleStartIndex(target, propertyName);
        if (resolutionCycleStartIndex >= 0) {
            // A cycle was found
            const { length } = resolutionTargets;
            for (let i = resolutionCycleStartIndex; i < length; i++) {
                resolutionResults[i] = false;
            }
            return false;
        }
        resolutionTargets.push(target);
        resolutionResults.push(/*items*/ true);
        resolutionPropertyNames.push(propertyName);
        return true;
    }

    function findResolutionCycleStartIndex(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): number {
        for (let i = resolutionTargets.length - 1; i >= resolutionStart; i--) {
            if (resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i])) {
                return -1;
            }
            if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {
                return i;
            }
        }
        return -1;
    }

    function resolutionTargetHasProperty(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): boolean {
        switch (propertyName) {
            case TypeSystemPropertyName.Type:
                return !!getSymbolLinks(target as Symbol).type;
            case TypeSystemPropertyName.DeclaredType:
                return !!getSymbolLinks(target as Symbol).declaredType;
            case TypeSystemPropertyName.ResolvedBaseConstructorType:
                return !!(target as InterfaceType).resolvedBaseConstructorType;
            case TypeSystemPropertyName.ResolvedReturnType:
                return !!(target as Signature).resolvedReturnType;
            case TypeSystemPropertyName.ImmediateBaseConstraint:
                return !!(target as Type).immediateBaseConstraint;
            case TypeSystemPropertyName.ResolvedTypeArguments:
                return !!(target as TypeReference).resolvedTypeArguments;
            case TypeSystemPropertyName.ResolvedBaseTypes:
                return !!(target as InterfaceType).baseTypesResolved;
            case TypeSystemPropertyName.WriteType:
                return !!getSymbolLinks(target as Symbol).writeType;
            case TypeSystemPropertyName.ParameterInitializerContainsUndefined:
                return getNodeLinks(target as ParameterDeclaration).parameterInitializerContainsUndefined !== undefined;
        }
        return Debug.assertNever(propertyName);
    }

    /**
     * Pop an entry from the type resolution stack and return its associated result value. The result value will
     * be true if no circularities were detected, or false if a circularity was found.
     */
    function popTypeResolution(): boolean {
        resolutionTargets.pop();
        resolutionPropertyNames.pop();
        return resolutionResults.pop()!;
    }

    function getDeclarationContainer(node: Node): Node {
        return findAncestor(getRootDeclaration(node), node => {
            switch (node.kind) {
                case SyntaxKind.VariableDeclaration:
                case SyntaxKind.VariableDeclarationList:
                case SyntaxKind.ImportSpecifier:
                case SyntaxKind.NamedImports:
                case SyntaxKind.NamespaceImport:
                case SyntaxKind.ImportClause:
                    return false;
                default:
                    return true;
            }
        })!.parent;
    }

    function getTypeOfPrototypeProperty(prototype: Symbol): Type {
        // TypeScript 1.0 spec (April 2014): 8.4
        // Every class automatically contains a static property member named 'prototype',
        // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
        // It is an error to explicitly declare a static property member with the name 'prototype'.
        const classType = getDeclaredTypeOfSymbol(getParentOfSymbol(prototype)!) as InterfaceType;
        return classType.typeParameters ? createTypeReference(classType as GenericType, map(classType.typeParameters, _ => anyType)) : classType;
    }

    // Return the type of the given property in the given type, or undefined if no such property exists
    function getTypeOfPropertyOfType(type: Type, name: __String): Type | undefined {
        const prop = getPropertyOfType(type, name);
        return prop ? getTypeOfSymbol(prop) : undefined;
    }

    /**
     * Return the type of the matching property or index signature in the given type, or undefined
     * if no matching property or index signature exists. Add optionality to index signature types.
     */
    function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {
        let propType;
        return getTypeOfPropertyOfType(type, name) ||
            (propType = getApplicableIndexInfoForName(type, name)?.type) &&
                addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);
    }

    function isTypeAny(type: Type | undefined) {
        return type && (type.flags & TypeFlags.Any) !== 0;
    }

    function isErrorType(type: Type) {
        // The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
        // a reference to an unresolved symbol. We want those to behave like the errorType.
        return type === errorType || !!(type.flags & TypeFlags.Any && type.aliasSymbol);
    }

    // Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
    // assigned by contextual typing.
    function getTypeForBindingElementParent(node: BindingElementGrandparent, checkMode: CheckMode) {
        if (checkMode !== CheckMode.Normal) {
            return getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ false, checkMode);
        }
        const symbol = getSymbolOfDeclaration(node);
        return symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ false, checkMode);
    }

    function getRestType(source: Type, properties: PropertyName[], symbol: Symbol | undefined): Type {
        source = filterType(source, t => !(t.flags & TypeFlags.Nullable));
        if (source.flags & TypeFlags.Never) {
            return emptyObjectType;
        }
        if (source.flags & TypeFlags.Union) {
            return mapType(source, t => getRestType(t, properties, symbol));
        }

        let omitKeyType = getUnionType(map(properties, getLiteralTypeFromPropertyName));

        const spreadableProperties: Symbol[] = [];
        const unspreadableToRestKeys: Type[] = [];

        for (const prop of getPropertiesOfType(source)) {
            const literalTypeFromProperty = getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique);
            if (
                !isTypeAssignableTo(literalTypeFromProperty, omitKeyType)
                && !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected))
                && isSpreadableProperty(prop)
            ) {
                spreadableProperties.push(prop);
            }
            else {
                unspreadableToRestKeys.push(literalTypeFromProperty);
            }
        }

        if (isGenericObjectType(source) || isGenericIndexType(omitKeyType)) {
            if (unspreadableToRestKeys.length) {
                // If the type we're spreading from has properties that cannot
                // be spread into the rest type (e.g. getters, methods), ensure
                // they are explicitly omitted, as they would in the non-generic case.
                omitKeyType = getUnionType([omitKeyType, ...unspreadableToRestKeys]);
            }

            if (omitKeyType.flags & TypeFlags.Never) {
                return source;
            }

            const omitTypeAlias = getGlobalOmitSymbol();
            if (!omitTypeAlias) {
                return errorType;
            }
            return getTypeAliasInstantiation(omitTypeAlias, [source, omitKeyType]);
        }
        const members = createSymbolTable();
        for (const prop of spreadableProperties) {
            members.set(prop.escapedName, getSpreadSymbol(prop, /*readonly*/ false));
        }
        const result = createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source));
        result.objectFlags |= ObjectFlags.ObjectRestType;
        return result;
    }

    function isGenericTypeWithUndefinedConstraint(type: Type) {
        return !!(type.flags & TypeFlags.Instantiable) && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, TypeFlags.Undefined);
    }

    function getNonUndefinedType(type: Type) {
        const typeOrConstraint = someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t) : type;
        return getTypeWithFacts(typeOrConstraint, TypeFacts.NEUndefined);
    }

    // Determine the control flow type associated with a destructuring declaration or assignment. The following
    // forms of destructuring are possible:
    //   let { x } = obj;  // BindingElement
    //   let [ x ] = obj;  // BindingElement
    //   { x } = obj;      // ShorthandPropertyAssignment
    //   { x: v } = obj;   // PropertyAssignment
    //   [ x ] = obj;      // Expression
    // We construct a synthetic element access expression corresponding to 'obj.x' such that the control
    // flow analyzer doesn't have to handle all the different syntactic forms.
    function getFlowTypeOfDestructuring(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression, declaredType: Type) {
        const reference = getSyntheticElementAccess(node);
        return reference ? getFlowTypeOfReference(reference, declaredType) : declaredType;
    }

    function getSyntheticElementAccess(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression): ElementAccessExpression | undefined {
        const parentAccess = getParentElementAccess(node);
        if (parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode) {
            const propName = getDestructuringPropertyName(node);
            if (propName) {
                const literal = setTextRangeWorker(parseNodeFactory.createStringLiteral(propName), node);
                const lhsExpr = isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess);
                const result = setTextRangeWorker(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node);
                setParent(literal, result);
                setParent(result, node);
                if (lhsExpr !== parentAccess) {
                    setParent(lhsExpr, result);
                }
                result.flowNode = parentAccess.flowNode;
                return result;
            }
        }
    }

    function getParentElementAccess(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression) {
        const ancestor = node.parent.parent;
        switch (ancestor.kind) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyAssignment:
                return getSyntheticElementAccess(ancestor as BindingElement | PropertyAssignment);
            case SyntaxKind.ArrayLiteralExpression:
                return getSyntheticElementAccess(node.parent as Expression);
            case SyntaxKind.VariableDeclaration:
                return (ancestor as VariableDeclaration).initializer;
            case SyntaxKind.BinaryExpression:
                return (ancestor as BinaryExpression).right;
        }
    }

    function getDestructuringPropertyName(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression) {
        const parent = node.parent;
        if (node.kind === SyntaxKind.BindingElement && parent.kind === SyntaxKind.ObjectBindingPattern) {
            return getLiteralPropertyNameText((node as BindingElement).propertyName || (node as BindingElement).name as Identifier);
        }
        if (node.kind === SyntaxKind.PropertyAssignment || node.kind === SyntaxKind.ShorthandPropertyAssignment) {
            return getLiteralPropertyNameText((node as PropertyAssignment | ShorthandPropertyAssignment).name);
        }
        return "" + ((parent as BindingPattern | ArrayLiteralExpression).elements as NodeArray<Node>).indexOf(node);
    }

    function getLiteralPropertyNameText(name: PropertyName) {
        const type = getLiteralTypeFromPropertyName(name);
        return type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) ? "" + (type as StringLiteralType | NumberLiteralType).value : undefined;
    }

    /** Return the inferred type for a binding element */
    function getTypeForBindingElement(declaration: BindingElement): Type | undefined {
        const checkMode = declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal;
        const parentType = getTypeForBindingElementParent(declaration.parent.parent, checkMode);
        return parentType && getBindingElementTypeFromParentType(declaration, parentType, /*noTupleBoundsCheck*/ false);
    }

    function getBindingElementTypeFromParentType(declaration: BindingElement, parentType: Type, noTupleBoundsCheck: boolean): Type {
        // If an any type was inferred for parent, infer that for the binding element
        if (isTypeAny(parentType)) {
            return parentType;
        }
        const pattern = declaration.parent;
        // Relax null check on ambient destructuring parameters, since the parameters have no implementation and are just documentation
        if (strictNullChecks && declaration.flags & NodeFlags.Ambient && isPartOfParameterDeclaration(declaration)) {
            parentType = getNonNullableType(parentType);
        }
        // Filter `undefined` from the type we check against if the parent has an initializer and that initializer is not possibly `undefined`
        else if (strictNullChecks && pattern.parent.initializer && !(hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFacts.EQUndefined))) {
            parentType = getTypeWithFacts(parentType, TypeFacts.NEUndefined);
        }

        const accessFlags = AccessFlags.ExpressionPosition | (noTupleBoundsCheck || hasDefaultValue(declaration) ? AccessFlags.AllowMissing : 0);
        let type: Type | undefined;
        if (pattern.kind === SyntaxKind.ObjectBindingPattern) {
            if (declaration.dotDotDotToken) {
                parentType = getReducedType(parentType);
                if (parentType.flags & TypeFlags.Unknown || !isValidSpreadType(parentType)) {
                    error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types);
                    return errorType;
                }
                const literalMembers: PropertyName[] = [];
                for (const element of pattern.elements) {
                    if (!element.dotDotDotToken) {
                        literalMembers.push(element.propertyName || element.name as Identifier);
                    }
                }
                type = getRestType(parentType, literalMembers, declaration.symbol);
            }
            else {
                // Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)
                const name = declaration.propertyName || declaration.name as Identifier;
                const indexType = getLiteralTypeFromPropertyName(name);
                const declaredType = getIndexedAccessType(parentType, indexType, accessFlags, name);
                type = getFlowTypeOfDestructuring(declaration, declaredType);
            }
        }
        else {
            // This elementType will be used if the specific property corresponding to this index is not
            // present (aka the tuple element property). This call also checks that the parentType is in
            // fact an iterable or array (depending on target language).
            const elementType = checkIteratedTypeOrElementType(IterationUse.Destructuring | (declaration.dotDotDotToken ? 0 : IterationUse.PossiblyOutOfBounds), parentType, undefinedType, pattern);
            const index = pattern.elements.indexOf(declaration);
            if (declaration.dotDotDotToken) {
                // If the parent is a tuple type, the rest element has a tuple type of the
                // remaining tuple element types. Otherwise, the rest element has an array type with same
                // element type as the parent type.
                const baseConstraint = mapType(parentType, t => t.flags & TypeFlags.InstantiableNonPrimitive ? getBaseConstraintOrType(t) : t);
                type = everyType(baseConstraint, isTupleType) ?
                    mapType(baseConstraint, t => sliceTupleType(t as TupleTypeReference, index)) :
                    createArrayType(elementType);
            }
            else if (isArrayLikeType(parentType)) {
                const indexType = getNumberLiteralType(index);
                const declaredType = getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType;
                type = getFlowTypeOfDestructuring(declaration, declaredType);
            }
            else {
                type = elementType;
            }
        }
        if (!declaration.initializer) {
            return type;
        }
        if (getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration))) {
            // In strict null checking mode, if a default value of a non-undefined type is specified, remove
            // undefined from the final type.
            return strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) ? getNonUndefinedType(type) : type;
        }
        return widenTypeInferredFromInitializer(declaration, getUnionType([getNonUndefinedType(type), checkDeclarationInitializer(declaration, CheckMode.Normal)], UnionReduction.Subtype));
    }

    function getTypeForDeclarationFromJSDocComment(declaration: Node) {
        const jsdocType = getJSDocType(declaration);
        if (jsdocType) {
            return getTypeFromTypeNode(jsdocType);
        }
        return undefined;
    }

    function isNullOrUndefined(node: Expression) {
        const expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        return expr.kind === SyntaxKind.NullKeyword || expr.kind === SyntaxKind.Identifier && getResolvedSymbol(expr as Identifier) === undefinedSymbol;
    }

    function isEmptyArrayLiteral(node: Expression) {
        const expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        return expr.kind === SyntaxKind.ArrayLiteralExpression && (expr as ArrayLiteralExpression).elements.length === 0;
    }

    function addOptionality(type: Type, isProperty = false, isOptional = true): Type {
        return strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type;
    }

    // Return the inferred type for a variable, parameter, or property declaration
    function getTypeForVariableLikeDeclaration(
        declaration: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag,
        includeOptionality: boolean,
        checkMode: CheckMode,
    ): Type | undefined {
        // A variable declared in a for..in statement is of type string, or of type keyof T when the
        // right hand expression is of a type parameter type.
        if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForInStatement) {
            const indexType = getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, /*checkMode*/ checkMode)));
            return indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(indexType) : stringType;
        }

        if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForOfStatement) {
            // checkRightHandSideOfForOf will return undefined if the for-of expression type was
            // missing properties/signatures required to get its iteratedType (like
            // [Symbol.iterator] or next). This may be because we accessed properties from anyType,
            // or it may have led to an error inside getElementTypeOfIterable.
            const forOfStatement = declaration.parent.parent;
            return checkRightHandSideOfForOf(forOfStatement) || anyType;
        }

        if (isBindingPattern(declaration.parent)) {
            return getTypeForBindingElement(declaration as BindingElement);
        }

        const isProperty = (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration);
        const isOptional = includeOptionality && isOptionalDeclaration(declaration);

        // Use type from type annotation if one is present
        const declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
        if (isCatchClauseVariableDeclarationOrBindingElement(declaration)) {
            if (declaredType) {
                // If the catch clause is explicitly annotated with any or unknown, accept it, otherwise error.
                return isTypeAny(declaredType) || declaredType === unknownType ? declaredType : errorType;
            }
            // If the catch clause is not explicitly annotated, treat it as though it were explicitly
            // annotated with unknown or any, depending on useUnknownInCatchVariables.
            return useUnknownInCatchVariables ? unknownType : anyType;
        }
        if (declaredType) {
            return addOptionality(declaredType, isProperty, isOptional);
        }

        if (
            (noImplicitAny || isInJSFile(declaration)) &&
            isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) &&
            !(getCombinedModifierFlagsCached(declaration) & ModifierFlags.Export) && !(declaration.flags & NodeFlags.Ambient)
        ) {
            // If --noImplicitAny is on or the declaration is in a Javascript file,
            // use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
            // initializer or a 'null' or 'undefined' initializer.
            if (!(getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant) && (!declaration.initializer || isNullOrUndefined(declaration.initializer))) {
                return autoType;
            }
            // Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
            // literal initializer.
            if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) {
                return autoArrayType;
            }
        }

        if (isParameter(declaration)) {
            if (!declaration.symbol) {
                // parameters of function types defined in JSDoc in TS files don't have symbols
                return;
            }
            const func = declaration.parent as FunctionLikeDeclaration;
            // For a parameter of a set accessor, use the type of the get accessor if one is present
            if (func.kind === SyntaxKind.SetAccessor && hasBindableName(func)) {
                const getter = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(declaration.parent), SyntaxKind.GetAccessor);
                if (getter) {
                    const getterSignature = getSignatureFromDeclaration(getter);
                    const thisParameter = getAccessorThisParameter(func as AccessorDeclaration);
                    if (thisParameter && declaration === thisParameter) {
                        // Use the type from the *getter*
                        Debug.assert(!thisParameter.type);
                        return getTypeOfSymbol(getterSignature.thisParameter!);
                    }
                    return getReturnTypeOfSignature(getterSignature);
                }
            }
            const parameterTypeOfTypeTag = getParameterTypeOfTypeTag(func, declaration);
            if (parameterTypeOfTypeTag) return parameterTypeOfTypeTag;
            // Use contextual parameter type if one is available
            const type = declaration.symbol.escapedName === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration);
            if (type) {
                return addOptionality(type, /*isProperty*/ false, isOptional);
            }
        }

        // Use the type of the initializer expression if one is present and the declaration is
        // not a parameter of a contextually typed function
        if (hasOnlyExpressionInitializer(declaration) && !!declaration.initializer) {
            if (isInJSFile(declaration) && !isParameter(declaration)) {
                const containerObjectType = getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration));
                if (containerObjectType) {
                    return containerObjectType;
                }
            }
            const type = widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode));
            return addOptionality(type, isProperty, isOptional);
        }

        if (isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration))) {
            // We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
            // Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
            if (!hasStaticModifier(declaration)) {
                const constructor = findConstructorDeclaration(declaration.parent);
                const type = constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :
                    getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                    undefined;
                return type && addOptionality(type, /*isProperty*/ true, isOptional);
            }
            else {
                const staticBlocks = filter(declaration.parent.members, isClassStaticBlockDeclaration);
                const type = staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :
                    getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                    undefined;
                return type && addOptionality(type, /*isProperty*/ true, isOptional);
            }
        }

        if (isJsxAttribute(declaration)) {
            // if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
            // I.e <Elem attr /> is sugar for <Elem attr={true} />
            return trueType;
        }

        // If the declaration specifies a binding pattern and is not a parameter of a contextually
        // typed function, use the type implied by the binding pattern
        if (isBindingPattern(declaration.name)) {
            return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ false, /*reportErrors*/ true);
        }

        // No type specified and nothing can be inferred
        return undefined;
    }

    function isConstructorDeclaredProperty(symbol: Symbol) {
        // A property is considered a constructor declared property when all declaration sites are this.xxx assignments,
        // when no declaration sites have JSDoc type annotations, and when at least one declaration site is in the body of
        // a class constructor.
        if (symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration)) {
            const links = getSymbolLinks(symbol);
            if (links.isConstructorDeclaredProperty === undefined) {
                links.isConstructorDeclaredProperty = false;
                links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, declaration =>
                    isBinaryExpression(declaration) &&
                    isPossiblyAliasedThisProperty(declaration) &&
                    (declaration.left.kind !== SyntaxKind.ElementAccessExpression || isStringOrNumericLiteralLike((declaration.left as ElementAccessExpression).argumentExpression)) &&
                    !getAnnotatedTypeForAssignmentDeclaration(/*declaredType*/ undefined, declaration, symbol, declaration));
            }
            return links.isConstructorDeclaredProperty;
        }
        return false;
    }

    function isAutoTypedProperty(symbol: Symbol) {
        // A property is auto-typed when its declaration has no type annotation or initializer and we're in
        // noImplicitAny mode or a .js file.
        const declaration = symbol.valueDeclaration;
        return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) &&
            !declaration.initializer && (noImplicitAny || isInJSFile(declaration));
    }

    function getDeclaringConstructor(symbol: Symbol) {
        if (!symbol.declarations) {
            return;
        }
        for (const declaration of symbol.declarations) {
            const container = getThisContainer(declaration, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
            if (container && (container.kind === SyntaxKind.Constructor || isJSConstructor(container))) {
                return container as ConstructorDeclaration;
            }
        }
    }

    /** Create a synthetic property access flow node after the last statement of the file */
    function getFlowTypeFromCommonJSExport(symbol: Symbol) {
        const file = getSourceFileOfNode(symbol.declarations![0]);
        const accessName = unescapeLeadingUnderscores(symbol.escapedName);
        const areAllModuleExports = symbol.declarations!.every(d => isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression));
        const reference = areAllModuleExports
            ? factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName)
            : factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName);
        if (areAllModuleExports) {
            setParent((reference.expression as PropertyAccessExpression).expression, reference.expression);
        }
        setParent(reference.expression, reference);
        setParent(reference, file);
        reference.flowNode = file.endFlowNode;
        return getFlowTypeOfReference(reference, autoType, undefinedType);
    }

    function getFlowTypeInStaticBlocks(symbol: Symbol, staticBlocks: readonly ClassStaticBlockDeclaration[]) {
        const accessName = startsWith(symbol.escapedName as string, "__#")
            ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])
            : unescapeLeadingUnderscores(symbol.escapedName);
        for (const staticBlock of staticBlocks) {
            const reference = factory.createPropertyAccessExpression(factory.createThis(), accessName);
            setParent(reference.expression, reference);
            setParent(reference, staticBlock);
            reference.flowNode = staticBlock.returnFlowNode;
            const flowType = getFlowTypeOfProperty(reference, symbol);
            if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
                error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
            }
            // We don't infer a type if assignments are only null or undefined.
            if (everyType(flowType, isNullableType)) {
                continue;
            }
            return convertAutoToAny(flowType);
        }
    }

    function getFlowTypeInConstructor(symbol: Symbol, constructor: ConstructorDeclaration) {
        const accessName = startsWith(symbol.escapedName as string, "__#")
            ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])
            : unescapeLeadingUnderscores(symbol.escapedName);
        const reference = factory.createPropertyAccessExpression(factory.createThis(), accessName);
        setParent(reference.expression, reference);
        setParent(reference, constructor);
        reference.flowNode = constructor.returnFlowNode;
        const flowType = getFlowTypeOfProperty(reference, symbol);
        if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
            error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
        }
        // We don't infer a type if assignments are only null or undefined.
        return everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType);
    }

    function getFlowTypeOfProperty(reference: Node, prop: Symbol | undefined) {
        const initialType = prop?.valueDeclaration
                && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration) & ModifierFlags.Ambient)
                && getTypeOfPropertyInBaseClass(prop)
            || undefinedType;
        return getFlowTypeOfReference(reference, autoType, initialType);
    }

    function getWidenedTypeForAssignmentDeclaration(symbol: Symbol, resolvedSymbol?: Symbol) {
        // function/class/{} initializers are themselves containers, so they won't merge in the same way as other initializers
        const container = getAssignedExpandoInitializer(symbol.valueDeclaration);
        if (container) {
            const tag = isInJSFile(container) ? getJSDocTypeTag(container) : undefined;
            if (tag && tag.typeExpression) {
                return getTypeFromTypeNode(tag.typeExpression);
            }
            const containerObjectType = symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container);
            return containerObjectType || getWidenedLiteralType(checkExpressionCached(container));
        }
        let type;
        let definedInConstructor = false;
        let definedInMethod = false;
        // We use control flow analysis to determine the type of the property if the property qualifies as a constructor
        // declared property and the resulting control flow type isn't just undefined or null.
        if (isConstructorDeclaredProperty(symbol)) {
            type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol)!);
        }
        if (!type) {
            let types: Type[] | undefined;
            if (symbol.declarations) {
                let jsdocType: Type | undefined;
                for (const declaration of symbol.declarations) {
                    const expression = (isBinaryExpression(declaration) || isCallExpression(declaration)) ? declaration :
                        isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration :
                        undefined;
                    if (!expression) {
                        continue; // Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere
                    }

                    const kind = isAccessExpression(expression)
                        ? getAssignmentDeclarationPropertyAccessKind(expression)
                        : getAssignmentDeclarationKind(expression);
                    if (kind === AssignmentDeclarationKind.ThisProperty || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind)) {
                        if (isDeclarationInConstructor(expression)) {
                            definedInConstructor = true;
                        }
                        else {
                            definedInMethod = true;
                        }
                    }
                    if (!isCallExpression(expression)) {
                        jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration);
                    }
                    if (!jsdocType) {
                        (types || (types = [])).push((isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType);
                    }
                }
                type = jsdocType;
            }
            if (!type) {
                if (!length(types)) {
                    return errorType; // No types from any declarations :(
                }
                let constructorTypes = definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined;
                // use only the constructor types unless they were only assigned null | undefined (including widening variants)
                if (definedInMethod) {
                    const propType = getTypeOfPropertyInBaseClass(symbol);
                    if (propType) {
                        (constructorTypes || (constructorTypes = [])).push(propType);
                        definedInConstructor = true;
                    }
                }
                const sourceTypes = some(constructorTypes, t => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types; // TODO: GH#18217
                type = getUnionType(sourceTypes!);
            }
        }
        const widened = getWidenedType(addOptionality(type, /*isProperty*/ false, definedInMethod && !definedInConstructor));
        if (symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && filterType(widened, t => !!(t.flags & ~TypeFlags.Nullable)) === neverType) {
            reportImplicitAny(symbol.valueDeclaration, anyType);
            return anyType;
        }
        return widened;
    }

    function getJSContainerObjectType(decl: Node, symbol: Symbol, init: Expression | undefined): Type | undefined {
        if (!isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length) {
            return undefined;
        }
        const exports = createSymbolTable();
        while (isBinaryExpression(decl) || isPropertyAccessExpression(decl)) {
            const s = getSymbolOfNode(decl);
            if (s?.exports?.size) {
                mergeSymbolTable(exports, s.exports);
            }
            decl = isBinaryExpression(decl) ? decl.parent : decl.parent.parent;
        }
        const s = getSymbolOfNode(decl);
        if (s?.exports?.size) {
            mergeSymbolTable(exports, s.exports);
        }
        const type = createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray);
        type.objectFlags |= ObjectFlags.JSLiteral;
        return type;
    }

    function getAnnotatedTypeForAssignmentDeclaration(declaredType: Type | undefined, expression: Expression, symbol: Symbol, declaration: Declaration) {
        const typeNode = getEffectiveTypeAnnotationNode(expression.parent);
        if (typeNode) {
            const type = getWidenedType(getTypeFromTypeNode(typeNode));
            if (!declaredType) {
                return type;
            }
            else if (!isErrorType(declaredType) && !isErrorType(type) && !isTypeIdenticalTo(declaredType, type)) {
                errorNextVariableOrPropertyDeclarationMustHaveSameType(/*firstDeclaration*/ undefined, declaredType, declaration, type);
            }
        }
        if (symbol.parent?.valueDeclaration) {
            const possiblyAnnotatedSymbol = getFunctionExpressionParentSymbolOrSymbol(symbol.parent);
            if (possiblyAnnotatedSymbol.valueDeclaration) {
                const typeNode = getEffectiveTypeAnnotationNode(possiblyAnnotatedSymbol.valueDeclaration);
                if (typeNode) {
                    const annotationSymbol = getPropertyOfType(getTypeFromTypeNode(typeNode), symbol.escapedName);
                    if (annotationSymbol) {
                        return getNonMissingTypeOfSymbol(annotationSymbol);
                    }
                }
            }
        }

        return declaredType;
    }

    /** If we don't have an explicit JSDoc type, get the type from the initializer. */
    function getInitializerTypeFromAssignmentDeclaration(symbol: Symbol, resolvedSymbol: Symbol | undefined, expression: BinaryExpression | CallExpression, kind: AssignmentDeclarationKind) {
        if (isCallExpression(expression)) {
            if (resolvedSymbol) {
                return getTypeOfSymbol(resolvedSymbol); // This shouldn't happen except under some hopefully forbidden merges of export assignments and object define assignments
            }
            const objectLitType = checkExpressionCached((expression as BindableObjectDefinePropertyCall).arguments[2]);
            const valueType = getTypeOfPropertyOfType(objectLitType, "value" as __String);
            if (valueType) {
                return valueType;
            }
            const getFunc = getTypeOfPropertyOfType(objectLitType, "get" as __String);
            if (getFunc) {
                const getSig = getSingleCallSignature(getFunc);
                if (getSig) {
                    return getReturnTypeOfSignature(getSig);
                }
            }
            const setFunc = getTypeOfPropertyOfType(objectLitType, "set" as __String);
            if (setFunc) {
                const setSig = getSingleCallSignature(setFunc);
                if (setSig) {
                    return getTypeOfFirstParameterOfSignature(setSig);
                }
            }
            return anyType;
        }
        if (containsSameNamedThisProperty(expression.left, expression.right)) {
            return anyType;
        }
        const isDirectExport = kind === AssignmentDeclarationKind.ExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression)));
        const type = resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)
            : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))
            : getWidenedLiteralType(checkExpressionCached(expression.right));
        if (
            type.flags & TypeFlags.Object &&
            kind === AssignmentDeclarationKind.ModuleExports &&
            symbol.escapedName === InternalSymbolName.ExportEquals
        ) {
            const exportedType = resolveStructuredTypeMembers(type as ObjectType);
            const members = createSymbolTable();
            copyEntries(exportedType.members, members);
            const initialSize = members.size;
            if (resolvedSymbol && !resolvedSymbol.exports) {
                resolvedSymbol.exports = createSymbolTable();
            }
            (resolvedSymbol || symbol).exports!.forEach((s, name) => {
                const exportedMember = members.get(name)!;
                if (exportedMember && exportedMember !== s && !(s.flags & SymbolFlags.Alias)) {
                    if (s.flags & SymbolFlags.Value && exportedMember.flags & SymbolFlags.Value) {
                        // If the member has an additional value-like declaration, union the types from the two declarations,
                        // but issue an error if they occurred in two different files. The purpose is to support a JS file with
                        // a pattern like:
                        //
                        // module.exports = { a: true };
                        // module.exports.a = 3;
                        //
                        // but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation
                        // declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because
                        // it's unclear what that's supposed to mean, so it's probably a mistake.
                        if (s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) !== getSourceFileOfNode(exportedMember.valueDeclaration)) {
                            const unescapedName = unescapeLeadingUnderscores(s.escapedName);
                            const exportedMemberName = tryCast(exportedMember.valueDeclaration, isNamedDeclaration)?.name || exportedMember.valueDeclaration;
                            addRelatedInfo(
                                error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName),
                                createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName),
                            );
                            addRelatedInfo(
                                error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName),
                                createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName),
                            );
                        }
                        const union = createSymbol(s.flags | exportedMember.flags, name);
                        union.links.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);
                        union.valueDeclaration = exportedMember.valueDeclaration;
                        union.declarations = concatenate(exportedMember.declarations, s.declarations);
                        members.set(name, union);
                    }
                    else {
                        members.set(name, mergeSymbol(s, exportedMember));
                    }
                }
                else {
                    members.set(name, s);
                }
            });
            const result = createAnonymousType(
                initialSize !== members.size ? undefined : exportedType.symbol, // Only set the type's symbol if it looks to be the same as the original type
                members,
                exportedType.callSignatures,
                exportedType.constructSignatures,
                exportedType.indexInfos,
            );
            if (initialSize === members.size) {
                if (type.aliasSymbol) {
                    result.aliasSymbol = type.aliasSymbol;
                    result.aliasTypeArguments = type.aliasTypeArguments;
                }
                if (getObjectFlags(type) & ObjectFlags.Reference) {
                    result.aliasSymbol = (type as TypeReference).symbol;
                    const args = getTypeArguments(type as TypeReference);
                    result.aliasTypeArguments = length(args) ? args : undefined;
                }
            }
            result.objectFlags |= getPropagatingFlagsOfTypes([type]) | getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.ArrayLiteral | ObjectFlags.ObjectLiteral);
            if (result.symbol && result.symbol.flags & SymbolFlags.Class && type === getDeclaredTypeOfClassOrInterface(result.symbol)) {
                result.objectFlags |= ObjectFlags.IsClassInstanceClone; // Propagate the knowledge that this type is equivalent to the symbol's class instance type
            }
            return result;
        }
        if (isEmptyArrayLiteralType(type)) {
            reportImplicitAny(expression, anyArrayType);
            return anyArrayType;
        }
        return type;
    }

    function containsSameNamedThisProperty(thisProperty: Expression, expression: Expression) {
        return isPropertyAccessExpression(thisProperty)
            && thisProperty.expression.kind === SyntaxKind.ThisKeyword
            && forEachChildRecursively(expression, n => isMatchingReference(thisProperty, n));
    }

    function isDeclarationInConstructor(expression: Expression) {
        const thisContainer = getThisContainer(expression, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
        // Properties defined in a constructor (or base constructor, or javascript constructor function) don't get undefined added.
        // Function expressions that are assigned to the prototype count as methods.
        return thisContainer.kind === SyntaxKind.Constructor ||
            thisContainer.kind === SyntaxKind.FunctionDeclaration ||
            (thisContainer.kind === SyntaxKind.FunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent));
    }

    function getConstructorDefinedThisAssignmentTypes(types: Type[], declarations: Declaration[]): Type[] | undefined {
        Debug.assert(types.length === declarations.length);
        return types.filter((_, i) => {
            const declaration = declarations[i];
            const expression = isBinaryExpression(declaration) ? declaration :
                isBinaryExpression(declaration.parent) ? declaration.parent : undefined;
            return expression && isDeclarationInConstructor(expression);
        });
    }

    // Return the type implied by a binding pattern element. This is the type of the initializer of the element if
    // one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
    // pattern. Otherwise, it is the type any.
    function getTypeFromBindingElement(element: BindingElement, includePatternInType?: boolean, reportErrors?: boolean): Type {
        if (element.initializer) {
            // The type implied by a binding pattern is independent of context, so we check the initializer with no
            // contextual type or, if the element itself is a binding pattern, with the type implied by that binding
            // pattern.
            const contextualType = isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType*/ true, /*reportErrors*/ false) : unknownType;
            return addOptionality(getWidenedLiteralTypeForInitializer(element, checkDeclarationInitializer(element, CheckMode.Normal, contextualType)));
        }
        if (isBindingPattern(element.name)) {
            return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors);
        }
        if (reportErrors && !declarationBelongsToPrivateAmbientMember(element)) {
            reportImplicitAny(element, anyType);
        }
        // When we're including the pattern in the type (an indication we're obtaining a contextual type), we
        // use a non-inferrable any type. Inference will never directly infer this type, but it is possible
        // to infer a type that contains it, e.g. for a binding pattern like [foo] or { foo }. In such cases,
        // widening of the binding pattern type substitutes a regular any for the non-inferrable any.
        return includePatternInType ? nonInferrableAnyType : anyType;
    }

    // Return the type implied by an object binding pattern
    function getTypeFromObjectBindingPattern(pattern: ObjectBindingPattern, includePatternInType: boolean, reportErrors: boolean): Type {
        const members = createSymbolTable();
        let stringIndexInfo: IndexInfo | undefined;
        let objectFlags = ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
        forEach(pattern.elements, e => {
            const name = e.propertyName || e.name as Identifier;
            if (e.dotDotDotToken) {
                stringIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly*/ false);
                return;
            }

            const exprType = getLiteralTypeFromPropertyName(name);
            if (!isTypeUsableAsPropertyName(exprType)) {
                // do not include computed properties in the implied type
                objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;
                return;
            }
            const text = getPropertyNameFromType(exprType);
            const flags = SymbolFlags.Property | (e.initializer ? SymbolFlags.Optional : 0);
            const symbol = createSymbol(flags, text);
            symbol.links.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);
            members.set(symbol.escapedName, symbol);
        });
        const result = createAnonymousType(/*symbol*/ undefined, members, emptyArray, emptyArray, stringIndexInfo ? [stringIndexInfo] : emptyArray);
        result.objectFlags |= objectFlags;
        if (includePatternInType) {
            result.pattern = pattern;
            result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral;
        }
        return result;
    }

    // Return the type implied by an array binding pattern
    function getTypeFromArrayBindingPattern(pattern: BindingPattern, includePatternInType: boolean, reportErrors: boolean): Type {
        const elements = pattern.elements;
        const lastElement = lastOrUndefined(elements);
        const restElement = lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined;
        if (elements.length === 0 || elements.length === 1 && restElement) {
            return languageVersion >= ScriptTarget.ES2015 ? createIterableType(anyType) : anyArrayType;
        }
        const elementTypes = map(elements, e => isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors));
        const minLength = findLastIndex(elements, e => !(e === restElement || isOmittedExpression(e) || hasDefaultValue(e)), elements.length - 1) + 1;
        const elementFlags = map(elements, (e, i) => e === restElement ? ElementFlags.Rest : i >= minLength ? ElementFlags.Optional : ElementFlags.Required);
        let result = createTupleType(elementTypes, elementFlags) as TypeReference;
        if (includePatternInType) {
            result = cloneTypeReference(result);
            result.pattern = pattern;
            result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral;
        }
        return result;
    }

    // Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
    // and without regard to its context (i.e. without regard any type annotation or initializer associated with the
    // declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
    // and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
    // used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
    // parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
    // the parameter.
    function getTypeFromBindingPattern(pattern: BindingPattern, includePatternInType = false, reportErrors = false): Type {
        if (includePatternInType) contextualBindingPatterns.push(pattern);
        const result = pattern.kind === SyntaxKind.ObjectBindingPattern
            ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
            : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors);
        if (includePatternInType) contextualBindingPatterns.pop();
        return result;
    }

    // Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
    // specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
    // is a bit more involved. For example:
    //
    //   var [x, s = ""] = [1, "one"];
    //
    // Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
    // binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
    // tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
    function getWidenedTypeForVariableLikeDeclaration(declaration: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag, reportErrors?: boolean): Type {
        return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true, CheckMode.Normal), declaration, reportErrors);
    }

    function getTypeFromImportAttributes(node: ImportAttributes): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const symbol = createSymbol(SymbolFlags.ObjectLiteral, InternalSymbolName.ImportAttributes);
            const members = createSymbolTable();
            forEach(node.elements, attr => {
                const member = createSymbol(SymbolFlags.Property, getNameFromImportAttribute(attr));
                member.parent = symbol;
                member.links.type = checkImportAttribute(attr);
                member.links.target = member;
                members.set(member.escapedName, member);
            });
            const type = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
            type.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.NonInferrableType;
            links.resolvedType = type;
        }
        return links.resolvedType;
    }

    function isGlobalSymbolConstructor(node: Node) {
        const symbol = getSymbolOfNode(node);
        const globalSymbol = getGlobalESSymbolConstructorTypeSymbol(/*reportErrors*/ false);
        return globalSymbol && symbol && symbol === globalSymbol;
    }

    function widenTypeForVariableLikeDeclaration(type: Type | undefined, declaration: any, reportErrors?: boolean) {
        if (type) {
            // TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
            if (type.flags & TypeFlags.ESSymbol && isGlobalSymbolConstructor(declaration.parent)) {
                type = getESSymbolLikeTypeForNode(declaration);
            }
            if (reportErrors) {
                reportErrorsFromWidening(declaration, type);
            }

            // always widen a 'unique symbol' type if the type was created for a different declaration.
            if (type.flags & TypeFlags.UniqueESSymbol && (isBindingElement(declaration) || !tryGetTypeFromEffectiveTypeNode(declaration)) && type.symbol !== getSymbolOfDeclaration(declaration)) {
                type = esSymbolType;
            }

            return getWidenedType(type);
        }

        // Rest parameters default to type any[], other parameters default to type any
        type = isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType;

        // Report implicit any errors unless this is a private property within an ambient declaration
        if (reportErrors) {
            if (!declarationBelongsToPrivateAmbientMember(declaration)) {
                reportImplicitAny(declaration, type);
            }
        }
        return type;
    }

    function declarationBelongsToPrivateAmbientMember(declaration: VariableLikeDeclaration) {
        const root = getRootDeclaration(declaration);
        const memberDeclaration = root.kind === SyntaxKind.Parameter ? root.parent : root;
        return isPrivateWithinAmbient(memberDeclaration);
    }

    function tryGetTypeFromEffectiveTypeNode(node: Node) {
        const typeNode = getEffectiveTypeAnnotationNode(node);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
    }

    function isParameterOfContextSensitiveSignature(symbol: Symbol) {
        let decl = symbol.valueDeclaration;
        if (!decl) {
            return false;
        }
        if (isBindingElement(decl)) {
            decl = walkUpBindingElementsAndPatterns(decl);
        }
        if (isParameter(decl)) {
            return isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent);
        }
        return false;
    }

    function getTypeOfVariableOrParameterOrProperty(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            const type = getTypeOfVariableOrParameterOrPropertyWorker(symbol);
            // For a contextually typed parameter it is possible that a type has already
            // been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
            // to preserve this type. In fact, we need to _prefer_ that type, but it won't
            // be assigned until contextual typing is complete, so we need to defer in
            // cases where contextual typing may take place.
            if (!links.type && !isParameterOfContextSensitiveSignature(symbol)) {
                links.type = type;
            }
            return type;
        }
        return links.type;
    }

    function getTypeOfVariableOrParameterOrPropertyWorker(symbol: Symbol): Type {
        // Handle prototype property
        if (symbol.flags & SymbolFlags.Prototype) {
            return getTypeOfPrototypeProperty(symbol);
        }
        // CommonsJS require and module both have type any.
        if (symbol === requireSymbol) {
            return anyType;
        }
        if (symbol.flags & SymbolFlags.ModuleExports && symbol.valueDeclaration) {
            const fileSymbol = getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration));
            const result = createSymbol(fileSymbol.flags, "exports" as __String);
            result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : [];
            result.parent = symbol;
            result.links.target = fileSymbol;
            if (fileSymbol.valueDeclaration) result.valueDeclaration = fileSymbol.valueDeclaration;
            if (fileSymbol.members) result.members = new Map(fileSymbol.members);
            if (fileSymbol.exports) result.exports = new Map(fileSymbol.exports);
            const members = createSymbolTable();
            members.set("exports" as __String, result);
            return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
        }
        Debug.assertIsDefined(symbol.valueDeclaration);
        const declaration = symbol.valueDeclaration;
        // Handle export default expressions
        if (isSourceFile(declaration) && isJsonSourceFile(declaration)) {
            if (!declaration.statements.length) {
                return emptyObjectType;
            }
            return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)));
        }
        if (isAccessor(declaration)) {
            // Binding of certain patterns in JS code will occasionally mark symbols as both properties
            // and accessors. Here we dispatch to accessor resolution if needed.
            return getTypeOfAccessors(symbol);
        }

        // Handle variable, parameter or property
        if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            if (symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            return reportCircularityError(symbol);
        }
        let type: Type;
        if (declaration.kind === SyntaxKind.ExportAssignment) {
            type = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration as ExportAssignment).expression), declaration);
        }
        else if (
            isBinaryExpression(declaration) ||
            (isInJSFile(declaration) &&
                (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent)))
        ) {
            type = getWidenedTypeForAssignmentDeclaration(symbol);
        }
        else if (
            isPropertyAccessExpression(declaration)
            || isElementAccessExpression(declaration)
            || isIdentifier(declaration)
            || isStringLiteralLike(declaration)
            || isNumericLiteral(declaration)
            || isClassDeclaration(declaration)
            || isFunctionDeclaration(declaration)
            || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration))
            || isMethodSignature(declaration)
            || isSourceFile(declaration)
        ) {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            type = isBinaryExpression(declaration.parent) ?
                getWidenedTypeForAssignmentDeclaration(symbol) :
                tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
        }
        else if (isPropertyAssignment(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration);
        }
        else if (isJsxAttribute(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration);
        }
        else if (isShorthandPropertyAssignment(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckMode.Normal);
        }
        else if (isObjectLiteralMethod(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckMode.Normal);
        }
        else if (
            isParameter(declaration)
            || isPropertyDeclaration(declaration)
            || isPropertySignature(declaration)
            || isVariableDeclaration(declaration)
            || isBindingElement(declaration)
            || isJSDocPropertyLikeTag(declaration)
        ) {
            type = getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors*/ true);
        }
        // getTypeOfSymbol dispatches some JS merges incorrectly because their symbol flags are not mutually exclusive.
        // Re-dispatch based on valueDeclaration.kind instead.
        else if (isEnumDeclaration(declaration)) {
            type = getTypeOfFuncClassEnumModule(symbol);
        }
        else if (isEnumMember(declaration)) {
            type = getTypeOfEnumMember(symbol);
        }
        else {
            return Debug.fail("Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol));
        }

        if (!popTypeResolution()) {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            if (symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            return reportCircularityError(symbol);
        }
        return type;
    }

    function getAnnotatedAccessorTypeNode(accessor: AccessorDeclaration | PropertyDeclaration | undefined): TypeNode | undefined {
        if (accessor) {
            switch (accessor.kind) {
                case SyntaxKind.GetAccessor:
                    const getterTypeAnnotation = getEffectiveReturnTypeNode(accessor);
                    return getterTypeAnnotation;
                case SyntaxKind.SetAccessor:
                    const setterTypeAnnotation = getEffectiveSetAccessorTypeAnnotationNode(accessor);
                    return setterTypeAnnotation;
                case SyntaxKind.PropertyDeclaration:
                    Debug.assert(hasAccessorModifier(accessor));
                    const accessorTypeAnnotation = getEffectiveTypeAnnotationNode(accessor);
                    return accessorTypeAnnotation;
            }
        }
        return undefined;
    }

    function getAnnotatedAccessorType(accessor: AccessorDeclaration | PropertyDeclaration | undefined): Type | undefined {
        const node = getAnnotatedAccessorTypeNode(accessor);
        return node && getTypeFromTypeNode(node);
    }

    function getAnnotatedAccessorThisParameter(accessor: AccessorDeclaration): Symbol | undefined {
        const parameter = getAccessorThisParameter(accessor);
        return parameter && parameter.symbol;
    }

    function getThisTypeOfDeclaration(declaration: SignatureDeclaration): Type | undefined {
        return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
    }

    function getTypeOfAccessors(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
                return errorType;
            }
            const getter = getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.GetAccessor);
            const setter = getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor);
            const accessor = tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration);

            // We try to resolve a getter type annotation, a setter type annotation, or a getter function
            // body return type inference, in that order.
            let type = getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) ||
                getAnnotatedAccessorType(getter) ||
                getAnnotatedAccessorType(setter) ||
                getAnnotatedAccessorType(accessor) ||
                getter && getter.body && getReturnTypeFromBody(getter) ||
                accessor && getWidenedTypeForVariableLikeDeclaration(accessor, /*reportErrors*/ true);
            if (!type) {
                if (setter && !isPrivateWithinAmbient(setter)) {
                    errorOrSuggestion(noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol));
                }
                else if (getter && !isPrivateWithinAmbient(getter)) {
                    errorOrSuggestion(noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol));
                }
                else if (accessor && !isPrivateWithinAmbient(accessor)) {
                    errorOrSuggestion(noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any");
                }
                type = anyType;
            }
            if (!popTypeResolution()) {
                if (getAnnotatedAccessorTypeNode(getter)) {
                    error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                }
                else if (getAnnotatedAccessorTypeNode(setter)) {
                    error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                }
                else if (getAnnotatedAccessorTypeNode(accessor)) {
                    error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                }
                else if (getter && noImplicitAny) {
                    error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));
                }
                type = anyType;
            }
            links.type ??= type;
        }
        return links.type;
    }

    function getWriteTypeOfAccessors(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.writeType) {
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.WriteType)) {
                return errorType;
            }

            const setter = getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor)
                ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration);
            let writeType = getAnnotatedAccessorType(setter);
            if (!popTypeResolution()) {
                if (getAnnotatedAccessorTypeNode(setter)) {
                    error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                }
                writeType = anyType;
            }
            // Absent an explicit setter type annotation we use the read type of the accessor.
            links.writeType ??= writeType || getTypeOfAccessors(symbol);
        }
        return links.writeType;
    }

    function getBaseTypeVariableOfClass(symbol: Symbol) {
        const baseConstructorType = getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol));
        return baseConstructorType.flags & TypeFlags.TypeVariable ? baseConstructorType :
            baseConstructorType.flags & TypeFlags.Intersection ? find((baseConstructorType as IntersectionType).types, t => !!(t.flags & TypeFlags.TypeVariable)) :
            undefined;
    }

    function getTypeOfFuncClassEnumModule(symbol: Symbol): Type {
        let links = getSymbolLinks(symbol);
        const originalLinks = links;
        if (!links.type) {
            const expando = symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, /*allowDeclaration*/ false);
            if (expando) {
                const merged = mergeJSSymbols(symbol, expando);
                if (merged) {
                    // note:we overwrite links because we just cloned the symbol
                    symbol = merged;
                    links = merged.links;
                }
            }
            originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(symbol);
        }
        return links.type;
    }

    function getTypeOfFuncClassEnumModuleWorker(symbol: Symbol): Type {
        const declaration = symbol.valueDeclaration;
        if (symbol.flags & SymbolFlags.Module && isShorthandAmbientModuleSymbol(symbol)) {
            return anyType;
        }
        else if (
            declaration && (declaration.kind === SyntaxKind.BinaryExpression ||
                isAccessExpression(declaration) &&
                    declaration.parent.kind === SyntaxKind.BinaryExpression)
        ) {
            return getWidenedTypeForAssignmentDeclaration(symbol);
        }
        else if (symbol.flags & SymbolFlags.ValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator) {
            const resolvedModule = resolveExternalModuleSymbol(symbol);
            if (resolvedModule !== symbol) {
                if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
                    return errorType;
                }
                const exportEquals = getMergedSymbol(symbol.exports!.get(InternalSymbolName.ExportEquals)!);
                const type = getWidenedTypeForAssignmentDeclaration(exportEquals, exportEquals === resolvedModule ? undefined : resolvedModule);
                if (!popTypeResolution()) {
                    return reportCircularityError(symbol);
                }
                return type;
            }
        }
        const type = createObjectType(ObjectFlags.Anonymous, symbol);
        if (symbol.flags & SymbolFlags.Class) {
            const baseTypeVariable = getBaseTypeVariableOfClass(symbol);
            return baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
        }
        else {
            return strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(type, /*isProperty*/ true) : type;
        }
    }

    function getTypeOfEnumMember(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        return links.type || (links.type = getDeclaredTypeOfEnumMember(symbol));
    }

    function getTypeOfAlias(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
                return errorType;
            }
            const targetSymbol = resolveAlias(symbol);
            const exportSymbol = symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol)!, /*dontRecursivelyResolve*/ true);
            const declaredType = firstDefined(exportSymbol?.declarations, d => isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined);

            // It only makes sense to get the type of a value symbol. If the result of resolving
            // the alias is not a value, then it has no type. To get the type associated with a
            // type symbol, call getDeclaredTypeOfSymbol.
            // This check is important because without it, a call to getTypeOfSymbol could end
            // up recursively calling getTypeOfAlias, causing a stack overflow.
            links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol)
                : isDuplicatedCommonJSExport(symbol.declarations) ? autoType
                : declaredType ? declaredType
                : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol)
                : errorType;

            if (!popTypeResolution()) {
                reportCircularityError(exportSymbol ?? symbol);
                return links.type ??= errorType;
            }
        }
        return links.type;
    }

    function getTypeOfInstantiatedSymbol(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        return links.type || (links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper));
    }

    function getWriteTypeOfInstantiatedSymbol(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        return links.writeType || (links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper));
    }

    function reportCircularityError(symbol: Symbol) {
        const declaration = symbol.valueDeclaration;
        // Check if variable has type annotation that circularly references the variable itself
        if (declaration) {
            if (getEffectiveTypeAnnotationNode(declaration)) {
                error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                return errorType;
            }
            // Check if variable has initializer that circularly references the variable itself
            if (noImplicitAny && (declaration.kind !== SyntaxKind.Parameter || (declaration as HasInitializer).initializer)) {
                error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol));
            }
        }
        else if (symbol.flags & SymbolFlags.Alias) {
            const node = getDeclarationOfAliasSymbol(symbol);
            if (node) {
                error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
            }
        }
        // Circularities could also result from parameters in function expressions that end up
        // having themselves as contextual types following type argument inference. In those cases
        // we have already reported an implicit any error so we don't report anything here.
        return anyType;
    }

    function getTypeOfSymbolWithDeferredType(symbol: Symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            Debug.assertIsDefined(links.deferralParent);
            Debug.assertIsDefined(links.deferralConstituents);
            links.type = links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents);
        }
        return links.type;
    }

    function getWriteTypeOfSymbolWithDeferredType(symbol: Symbol): Type | undefined {
        const links = getSymbolLinks(symbol);
        if (!links.writeType && links.deferralWriteConstituents) {
            Debug.assertIsDefined(links.deferralParent);
            Debug.assertIsDefined(links.deferralConstituents);
            links.writeType = links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents);
        }
        return links.writeType;
    }

    /**
     * Distinct write types come only from set accessors, but synthetic union and intersection
     * properties deriving from set accessors will either pre-compute or defer the union or
     * intersection of the writeTypes of their constituents.
     */
    function getWriteTypeOfSymbol(symbol: Symbol): Type {
        const checkFlags = getCheckFlags(symbol);
        if (symbol.flags & SymbolFlags.Property) {
            return checkFlags & CheckFlags.SyntheticProperty ?
                checkFlags & CheckFlags.DeferredType ?
                    getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :
                    // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty
                    (symbol as TransientSymbol).links.writeType || (symbol as TransientSymbol).links.type! :
                removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional));
        }
        if (symbol.flags & SymbolFlags.Accessor) {
            return checkFlags & CheckFlags.Instantiated ?
                getWriteTypeOfInstantiatedSymbol(symbol) :
                getWriteTypeOfAccessors(symbol);
        }
        return getTypeOfSymbol(symbol);
    }

    function getTypeOfSymbol(symbol: Symbol): Type {
        const checkFlags = getCheckFlags(symbol);
        if (checkFlags & CheckFlags.DeferredType) {
            return getTypeOfSymbolWithDeferredType(symbol);
        }
        if (checkFlags & CheckFlags.Instantiated) {
            return getTypeOfInstantiatedSymbol(symbol);
        }
        if (checkFlags & CheckFlags.Mapped) {
            return getTypeOfMappedSymbol(symbol as MappedSymbol);
        }
        if (checkFlags & CheckFlags.ReverseMapped) {
            return getTypeOfReverseMappedSymbol(symbol as ReverseMappedSymbol);
        }
        if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {
            return getTypeOfVariableOrParameterOrProperty(symbol);
        }
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) {
            return getTypeOfFuncClassEnumModule(symbol);
        }
        if (symbol.flags & SymbolFlags.EnumMember) {
            return getTypeOfEnumMember(symbol);
        }
        if (symbol.flags & SymbolFlags.Accessor) {
            return getTypeOfAccessors(symbol);
        }
        if (symbol.flags & SymbolFlags.Alias) {
            return getTypeOfAlias(symbol);
        }
        return errorType;
    }

    function getNonMissingTypeOfSymbol(symbol: Symbol) {
        return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional));
    }

    function isReferenceToSomeType(type: Type, targets: readonly Type[]) {
        if (type === undefined || (getObjectFlags(type) & ObjectFlags.Reference) === 0) {
            return false;
        }
        for (const target of targets) {
            if ((type as TypeReference).target === target) {
                return true;
            }
        }
        return false;
    }

    function isReferenceToType(type: Type, target: Type) {
        return type !== undefined
            && target !== undefined
            && (getObjectFlags(type) & ObjectFlags.Reference) !== 0
            && (type as TypeReference).target === target;
    }

    function getTargetType(type: Type): Type {
        return getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target : type;
    }

    // TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
    function hasBaseType(type: Type, checkBase: Type | undefined) {
        return check(type);
        function check(type: Type): boolean {
            if (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference)) {
                const target = getTargetType(type) as InterfaceType;
                return target === checkBase || some(getBaseTypes(target), check);
            }
            else if (type.flags & TypeFlags.Intersection) {
                return some((type as IntersectionType).types, check);
            }
            return false;
        }
    }

    // Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
    // The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
    // in-place and returns the same array.
    function appendTypeParameters(typeParameters: TypeParameter[] | undefined, declarations: readonly TypeParameterDeclaration[]): TypeParameter[] | undefined {
        for (const declaration of declarations) {
            typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)));
        }
        return typeParameters;
    }

    // Return the outer type parameters of a node or undefined if the node has no outer type parameters.
    function getOuterTypeParameters(node: Node, includeThisTypes?: boolean): TypeParameter[] | undefined {
        while (true) {
            node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead
            if (node && isBinaryExpression(node)) {
                // prototype assignments get the outer type parameters of their constructor function
                const assignmentKind = getAssignmentDeclarationKind(node);
                if (assignmentKind === AssignmentDeclarationKind.Prototype || assignmentKind === AssignmentDeclarationKind.PrototypeProperty) {
                    const symbol = getSymbolOfDeclaration(node.left as BindableStaticNameExpression | PropertyAssignment);
                    if (symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, d => node === d)) {
                        node = symbol.parent.valueDeclaration!;
                    }
                }
            }
            if (!node) {
                return undefined;
            }
            const kind = node.kind;
            switch (kind) {
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.CallSignature:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.FunctionType:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.JSDocFunctionType:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.ArrowFunction:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.JSDocTemplateTag:
                case SyntaxKind.JSDocTypedefTag:
                case SyntaxKind.JSDocEnumTag:
                case SyntaxKind.JSDocCallbackTag:
                case SyntaxKind.MappedType:
                case SyntaxKind.ConditionalType: {
                    const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                    if ((kind === SyntaxKind.FunctionExpression || kind === SyntaxKind.ArrowFunction || isObjectLiteralMethod(node)) && isContextSensitive(node as Expression | MethodDeclaration)) {
                        const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node as FunctionLikeDeclaration)), SignatureKind.Call));
                        if (signature && signature.typeParameters) {
                            return [...(outerTypeParameters || emptyArray), ...signature.typeParameters];
                        }
                    }
                    if (kind === SyntaxKind.MappedType) {
                        return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node as MappedTypeNode).typeParameter)));
                    }
                    else if (kind === SyntaxKind.ConditionalType) {
                        return concatenate(outerTypeParameters, getInferTypeParameters(node as ConditionalTypeNode));
                    }
                    const outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node as DeclarationWithTypeParameters));
                    const thisType = includeThisTypes &&
                        (kind === SyntaxKind.ClassDeclaration || kind === SyntaxKind.ClassExpression || kind === SyntaxKind.InterfaceDeclaration || isJSConstructor(node)) &&
                        getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node as ClassLikeDeclaration | InterfaceDeclaration)).thisType;
                    return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
                }
                case SyntaxKind.JSDocParameterTag:
                    const paramSymbol = getParameterSymbolFromJSDoc(node as JSDocParameterTag);
                    if (paramSymbol) {
                        node = paramSymbol.valueDeclaration!;
                    }
                    break;
                case SyntaxKind.JSDoc: {
                    const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                    return (node as JSDoc).tags
                        ? appendTypeParameters(outerTypeParameters, flatMap((node as JSDoc).tags, t => isJSDocTemplateTag(t) ? t.typeParameters : undefined))
                        : outerTypeParameters;
                }
            }
        }
    }

    // The outer type parameters are those defined by enclosing generic classes, methods, or functions.
    function getOuterTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] | undefined {
        const declaration = (symbol.flags & SymbolFlags.Class || symbol.flags & SymbolFlags.Function)
            ? symbol.valueDeclaration
            : symbol.declarations?.find(decl => {
                if (decl.kind === SyntaxKind.InterfaceDeclaration) {
                    return true;
                }
                if (decl.kind !== SyntaxKind.VariableDeclaration) {
                    return false;
                }
                const initializer = (decl as VariableDeclaration).initializer;
                return !!initializer && (initializer.kind === SyntaxKind.FunctionExpression || initializer.kind === SyntaxKind.ArrowFunction);
            })!;
        Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations");
        return getOuterTypeParameters(declaration);
    }

    // The local type parameters are the combined set of type parameters from all declarations of the class,
    // interface, or type alias.
    function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol: Symbol): TypeParameter[] | undefined {
        if (!symbol.declarations) {
            return;
        }
        let result: TypeParameter[] | undefined;
        for (const node of symbol.declarations) {
            if (
                node.kind === SyntaxKind.InterfaceDeclaration ||
                node.kind === SyntaxKind.ClassDeclaration ||
                node.kind === SyntaxKind.ClassExpression ||
                isJSConstructor(node) ||
                isTypeAlias(node)
            ) {
                const declaration = node as InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag;
                result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration));
            }
        }
        return result;
    }

    // The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
    // its locally declared type parameters.
    function getTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] | undefined {
        return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol));
    }

    // A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
    // rest parameter of type any[].
    function isMixinConstructorType(type: Type) {
        const signatures = getSignaturesOfType(type, SignatureKind.Construct);
        if (signatures.length === 1) {
            const s = signatures[0];
            if (!s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(s)) {
                const paramType = getTypeOfParameter(s.parameters[0]);
                return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) === anyType;
            }
        }
        return false;
    }

    function isConstructorType(type: Type): boolean {
        if (getSignaturesOfType(type, SignatureKind.Construct).length > 0) {
            return true;
        }
        if (type.flags & TypeFlags.TypeVariable) {
            const constraint = getBaseConstraintOfType(type);
            return !!constraint && isMixinConstructorType(constraint);
        }
        return false;
    }

    function getBaseTypeNodeOfClass(type: InterfaceType): ExpressionWithTypeArguments | undefined {
        const decl = getClassLikeDeclarationOfSymbol(type.symbol);
        return decl && getEffectiveBaseTypeNode(decl);
    }

    function getConstructorsForTypeArguments(type: Type, typeArgumentNodes: readonly TypeNode[] | undefined, location: Node): readonly Signature[] {
        const typeArgCount = length(typeArgumentNodes);
        const isJavascript = isInJSFile(location);
        return filter(getSignaturesOfType(type, SignatureKind.Construct), sig => (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters));
    }

    function getInstantiatedConstructorsForTypeArguments(type: Type, typeArgumentNodes: readonly TypeNode[] | undefined, location: Node): readonly Signature[] {
        const signatures = getConstructorsForTypeArguments(type, typeArgumentNodes, location);
        const typeArguments = map(typeArgumentNodes, getTypeFromTypeNode);
        return sameMap<Signature>(signatures, sig => some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) : sig);
    }

    /**
     * The base constructor of a class can resolve to
     * * undefinedType if the class has no extends clause,
     * * errorType if an error occurred during resolution of the extends expression,
     * * nullType if the extends expression is the null value,
     * * anyType if the extends expression has type any, or
     * * an object type with at least one construct signature.
     */
    function getBaseConstructorTypeOfClass(type: InterfaceType): Type {
        if (!type.resolvedBaseConstructorType) {
            const decl = getClassLikeDeclarationOfSymbol(type.symbol);
            const extended = decl && getEffectiveBaseTypeNode(decl);
            const baseTypeNode = getBaseTypeNodeOfClass(type);
            if (!baseTypeNode) {
                return type.resolvedBaseConstructorType = undefinedType;
            }
            if (!pushTypeResolution(type, TypeSystemPropertyName.ResolvedBaseConstructorType)) {
                return errorType;
            }
            const baseConstructorType = checkExpression(baseTypeNode.expression);
            if (extended && baseTypeNode !== extended) {
                Debug.assert(!extended.typeArguments); // Because this is in a JS file, and baseTypeNode is in an @extends tag
                checkExpression(extended.expression);
            }
            if (baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection)) {
                // Resolving the members of a class requires us to resolve the base class of that class.
                // We force resolution here such that we catch circularities now.
                resolveStructuredTypeMembers(baseConstructorType as ObjectType);
            }
            if (!popTypeResolution()) {
                error(type.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));
                return type.resolvedBaseConstructorType ??= errorType;
            }
            if (!(baseConstructorType.flags & TypeFlags.Any) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType)) {
                const err = error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
                if (baseConstructorType.flags & TypeFlags.TypeParameter) {
                    const constraint = getConstraintFromTypeParameter(baseConstructorType);
                    let ctorReturn: Type = unknownType;
                    if (constraint) {
                        const ctorSig = getSignaturesOfType(constraint, SignatureKind.Construct);
                        if (ctorSig[0]) {
                            ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
                        }
                    }
                    if (baseConstructorType.symbol.declarations) {
                        addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)));
                    }
                }
                return type.resolvedBaseConstructorType ??= errorType;
            }
            type.resolvedBaseConstructorType ??= baseConstructorType;
        }
        return type.resolvedBaseConstructorType;
    }

    function getImplementsTypes(type: InterfaceType): BaseType[] {
        let resolvedImplementsTypes: BaseType[] = emptyArray;
        if (type.symbol.declarations) {
            for (const declaration of type.symbol.declarations) {
                const implementsTypeNodes = getEffectiveImplementsTypeNodes(declaration as ClassLikeDeclaration);
                if (!implementsTypeNodes) continue;
                for (const node of implementsTypeNodes) {
                    const implementsType = getTypeFromTypeNode(node);
                    if (!isErrorType(implementsType)) {
                        if (resolvedImplementsTypes === emptyArray) {
                            resolvedImplementsTypes = [implementsType as ObjectType];
                        }
                        else {
                            resolvedImplementsTypes.push(implementsType);
                        }
                    }
                }
            }
        }
        return resolvedImplementsTypes;
    }

    function reportCircularBaseType(node: Node, type: Type) {
        error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType));
    }

    function getBaseTypes(type: InterfaceType): BaseType[] {
        if (!type.baseTypesResolved) {
            if (pushTypeResolution(type, TypeSystemPropertyName.ResolvedBaseTypes)) {
                if (type.objectFlags & ObjectFlags.Tuple) {
                    type.resolvedBaseTypes = [getTupleBaseType(type as TupleType)];
                }
                else if (type.symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
                    if (type.symbol.flags & SymbolFlags.Class) {
                        resolveBaseTypesOfClass(type);
                    }
                    if (type.symbol.flags & SymbolFlags.Interface) {
                        resolveBaseTypesOfInterface(type);
                    }
                }
                else {
                    Debug.fail("type must be class or interface");
                }
                if (!popTypeResolution() && type.symbol.declarations) {
                    for (const declaration of type.symbol.declarations) {
                        if (declaration.kind === SyntaxKind.ClassDeclaration || declaration.kind === SyntaxKind.InterfaceDeclaration) {
                            reportCircularBaseType(declaration, type);
                        }
                    }
                }
            }
            type.baseTypesResolved = true;
        }
        return type.resolvedBaseTypes;
    }

    function getTupleBaseType(type: TupleType) {
        const elementTypes = sameMap(type.typeParameters, (t, i) => type.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t);
        return createArrayType(getUnionType(elementTypes || emptyArray), type.readonly);
    }

    function resolveBaseTypesOfClass(type: InterfaceType) {
        type.resolvedBaseTypes = resolvingEmptyArray;
        const baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
        if (!(baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Any))) {
            return type.resolvedBaseTypes = emptyArray;
        }
        const baseTypeNode = getBaseTypeNodeOfClass(type)!;
        let baseType: Type;
        const originalBaseType = baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined;
        if (
            baseConstructorType.symbol && baseConstructorType.symbol.flags & SymbolFlags.Class &&
            areAllOuterTypeParametersApplied(originalBaseType!)
        ) {
            // When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
            // class and all return the instance type of the class. There is no need for further checks and we can apply the
            // type arguments in the same manner as a type reference to get the same error reporting experience.
            baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol);
        }
        else if (baseConstructorType.flags & TypeFlags.Any) {
            baseType = baseConstructorType;
        }
        else {
            // The class derives from a "class-like" constructor function, check that we have at least one construct signature
            // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
            // we check that all instantiated signatures return the same type.
            const constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
            if (!constructors.length) {
                error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
                return type.resolvedBaseTypes = emptyArray;
            }
            baseType = getReturnTypeOfSignature(constructors[0]);
        }

        if (isErrorType(baseType)) {
            return type.resolvedBaseTypes = emptyArray;
        }
        const reducedBaseType = getReducedType(baseType);
        if (!isValidBaseType(reducedBaseType)) {
            const elaboration = elaborateNeverIntersection(/*errorInfo*/ undefined, baseType);
            const diagnostic = chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType));
            diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic));
            return type.resolvedBaseTypes = emptyArray;
        }
        if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
            error(type.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType));
            return type.resolvedBaseTypes = emptyArray;
        }
        if (type.resolvedBaseTypes === resolvingEmptyArray) {
            // Circular reference, likely through instantiation of default parameters
            // (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
            // as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
            // partial instantiation of the members without the base types fully resolved
            type.members = undefined;
        }
        return type.resolvedBaseTypes = [reducedBaseType];
    }

    function areAllOuterTypeParametersApplied(type: Type): boolean { // TODO: GH#18217 Shouldn't this take an InterfaceType?
        // An unapplied type parameter has its symbol still the same as the matching argument symbol.
        // Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
        const outerTypeParameters = (type as InterfaceType).outerTypeParameters;
        if (outerTypeParameters) {
            const last = outerTypeParameters.length - 1;
            const typeArguments = getTypeArguments(type as TypeReference);
            return outerTypeParameters[last].symbol !== typeArguments[last].symbol;
        }
        return true;
    }

    // A valid base type is `any`, an object type or intersection of object types.
    function isValidBaseType(type: Type): type is BaseType {
        if (type.flags & TypeFlags.TypeParameter) {
            const constraint = getBaseConstraintOfType(type);
            if (constraint) {
                return isValidBaseType(constraint);
            }
        }
        // TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
        // There's no reason a `T` should be allowed while a `Readonly<T>` should not.
        return !!(type.flags & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.Any) && !isGenericMappedType(type) ||
            type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isValidBaseType));
    }

    function resolveBaseTypesOfInterface(type: InterfaceType): void {
        type.resolvedBaseTypes = type.resolvedBaseTypes || emptyArray;
        if (type.symbol.declarations) {
            for (const declaration of type.symbol.declarations) {
                if (declaration.kind === SyntaxKind.InterfaceDeclaration && getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration)) {
                    for (const node of getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration)!) {
                        const baseType = getReducedType(getTypeFromTypeNode(node));
                        if (!isErrorType(baseType)) {
                            if (isValidBaseType(baseType)) {
                                if (type !== baseType && !hasBaseType(baseType, type)) {
                                    if (type.resolvedBaseTypes === emptyArray) {
                                        type.resolvedBaseTypes = [baseType as ObjectType];
                                    }
                                    else {
                                        type.resolvedBaseTypes.push(baseType);
                                    }
                                }
                                else {
                                    reportCircularBaseType(declaration, type);
                                }
                            }
                            else {
                                error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns true if the interface given by the symbol is free of "this" references.
     *
     * Specifically, the result is true if the interface itself contains no references
     * to "this" in its body, if all base types are interfaces,
     * and if none of the base interfaces have a "this" type.
     */
    function isThislessInterface(symbol: Symbol): boolean {
        if (!symbol.declarations) {
            return true;
        }
        for (const declaration of symbol.declarations) {
            if (declaration.kind === SyntaxKind.InterfaceDeclaration) {
                if (declaration.flags & NodeFlags.ContainsThis) {
                    return false;
                }
                const baseTypeNodes = getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration);
                if (baseTypeNodes) {
                    for (const node of baseTypeNodes) {
                        if (isEntityNameExpression(node.expression)) {
                            const baseSymbol = resolveEntityName(node.expression, SymbolFlags.Type, /*ignoreErrors*/ true);
                            if (!baseSymbol || !(baseSymbol.flags & SymbolFlags.Interface) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    function getDeclaredTypeOfClassOrInterface(symbol: Symbol): InterfaceType {
        let links = getSymbolLinks(symbol);
        const originalLinks = links;
        if (!links.declaredType) {
            const kind = symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface;
            const merged = mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration));
            if (merged) {
                // note:we overwrite links because we just cloned the symbol
                symbol = merged;
                links = merged.links;
            }

            const type = originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType;
            const outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
            const localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
            // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
            // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
            // property types inferred from initializers and method return types inferred from return statements are very hard
            // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
            // "this" references.
            if (outerTypeParameters || localTypeParameters || kind === ObjectFlags.Class || !isThislessInterface(symbol)) {
                type.objectFlags |= ObjectFlags.Reference;
                type.typeParameters = concatenate(outerTypeParameters, localTypeParameters);
                type.outerTypeParameters = outerTypeParameters;
                type.localTypeParameters = localTypeParameters;
                (type as GenericType).instantiations = new Map<string, TypeReference>();
                (type as GenericType).instantiations.set(getTypeListId(type.typeParameters), type as GenericType);
                (type as GenericType).target = type as GenericType;
                (type as GenericType).resolvedTypeArguments = type.typeParameters;
                type.thisType = createTypeParameter(symbol);
                type.thisType.isThisType = true;
                type.thisType.constraint = type;
            }
        }
        return links.declaredType as InterfaceType;
    }

    function getDeclaredTypeOfTypeAlias(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            // Note that we use the links object as the target here because the symbol object is used as the unique
            // identity for resolution of the 'type' property in SymbolLinks.
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.DeclaredType)) {
                return errorType;
            }

            const declaration = Debug.checkDefined(symbol.declarations?.find(isTypeAlias), "Type alias symbol with no valid declaration found");
            const typeNode = isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type;
            // If typeNode is missing, we will error in checkJSDocTypedefTag.
            let type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;
            if (popTypeResolution()) {
                const typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                if (typeParameters) {
                    // Initialize the instantiation cache for generic type aliases. The declared type corresponds to
                    // an instantiation of the type alias with the type parameters supplied as type arguments.
                    links.typeParameters = typeParameters;
                    links.instantiations = new Map<string, Type>();
                    links.instantiations.set(getTypeListId(typeParameters), type);
                }
                if (type === intrinsicMarkerType && symbol.escapedName === "BuiltinIteratorReturn") {
                    type = getBuiltinIteratorReturnType();
                }
            }
            else {
                type = errorType;
                if (declaration.kind === SyntaxKind.JSDocEnumTag) {
                    error(declaration.typeExpression.type, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                }
                else {
                    error(isNamedDeclaration(declaration) ? declaration.name || declaration : declaration, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                }
            }
            links.declaredType ??= type;
        }
        return links.declaredType;
    }

    function getBaseTypeOfEnumLikeType(type: Type) {
        return type.flags & TypeFlags.EnumLike && type.symbol.flags & SymbolFlags.EnumMember ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)!) : type;
    }

    function getDeclaredTypeOfEnum(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            const memberTypeList: Type[] = [];
            if (symbol.declarations) {
                for (const declaration of symbol.declarations) {
                    if (declaration.kind === SyntaxKind.EnumDeclaration) {
                        for (const member of (declaration as EnumDeclaration).members) {
                            if (hasBindableName(member)) {
                                const memberSymbol = getSymbolOfDeclaration(member);
                                const value = getEnumMemberValue(member).value;
                                const memberType = getFreshTypeOfLiteralType(
                                    value !== undefined ?
                                        getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) :
                                        createComputedEnumType(memberSymbol),
                                );
                                getSymbolLinks(memberSymbol).declaredType = memberType;
                                memberTypeList.push(getRegularTypeOfLiteralType(memberType));
                            }
                        }
                    }
                }
            }
            const enumType = memberTypeList.length ?
                getUnionType(memberTypeList, UnionReduction.Literal, symbol, /*aliasTypeArguments*/ undefined) :
                createComputedEnumType(symbol);
            if (enumType.flags & TypeFlags.Union) {
                enumType.flags |= TypeFlags.EnumLiteral;
                enumType.symbol = symbol;
            }
            links.declaredType = enumType;
        }
        return links.declaredType;
    }

    function createComputedEnumType(symbol: Symbol) {
        const regularType = createTypeWithSymbol(TypeFlags.Enum, symbol) as EnumType;
        const freshType = createTypeWithSymbol(TypeFlags.Enum, symbol) as EnumType;
        regularType.regularType = regularType;
        regularType.freshType = freshType;
        freshType.regularType = regularType;
        freshType.freshType = freshType;
        return regularType;
    }

    function getDeclaredTypeOfEnumMember(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            const enumType = getDeclaredTypeOfEnum(getParentOfSymbol(symbol)!);
            if (!links.declaredType) {
                links.declaredType = enumType;
            }
        }
        return links.declaredType;
    }

    function getDeclaredTypeOfTypeParameter(symbol: Symbol): TypeParameter {
        const links = getSymbolLinks(symbol);
        return links.declaredType || (links.declaredType = createTypeParameter(symbol));
    }

    function getDeclaredTypeOfAlias(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        return links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)));
    }

    function getDeclaredTypeOfSymbol(symbol: Symbol): Type {
        return tryGetDeclaredTypeOfSymbol(symbol) || errorType;
    }

    function tryGetDeclaredTypeOfSymbol(symbol: Symbol): Type | undefined {
        if (symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
            return getDeclaredTypeOfClassOrInterface(symbol);
        }
        if (symbol.flags & SymbolFlags.TypeAlias) {
            return getDeclaredTypeOfTypeAlias(symbol);
        }
        if (symbol.flags & SymbolFlags.TypeParameter) {
            return getDeclaredTypeOfTypeParameter(symbol);
        }
        if (symbol.flags & SymbolFlags.Enum) {
            return getDeclaredTypeOfEnum(symbol);
        }
        if (symbol.flags & SymbolFlags.EnumMember) {
            return getDeclaredTypeOfEnumMember(symbol);
        }
        if (symbol.flags & SymbolFlags.Alias) {
            return getDeclaredTypeOfAlias(symbol);
        }
        return undefined;
    }

    /**
     * A type is free of this references if it's the any, string, number, boolean, symbol, or void keyword, a string
     * literal type, an array with an element type that is free of this references, or a type reference that is
     * free of this references.
     */
    function isThislessType(node: TypeNode): boolean {
        switch (node.kind) {
            case SyntaxKind.AnyKeyword:
            case SyntaxKind.UnknownKeyword:
            case SyntaxKind.StringKeyword:
            case SyntaxKind.NumberKeyword:
            case SyntaxKind.BigIntKeyword:
            case SyntaxKind.BooleanKeyword:
            case SyntaxKind.SymbolKeyword:
            case SyntaxKind.ObjectKeyword:
            case SyntaxKind.VoidKeyword:
            case SyntaxKind.UndefinedKeyword:
            case SyntaxKind.NeverKeyword:
            case SyntaxKind.LiteralType:
                return true;
            case SyntaxKind.ArrayType:
                return isThislessType((node as ArrayTypeNode).elementType);
            case SyntaxKind.TypeReference:
                return !(node as TypeReferenceNode).typeArguments || (node as TypeReferenceNode).typeArguments!.every(isThislessType);
        }
        return false;
    }

    /** A type parameter is thisless if its constraint is thisless, or if it has no constraint. */
    function isThislessTypeParameter(node: TypeParameterDeclaration) {
        const constraint = getEffectiveConstraintOfTypeParameter(node);
        return !constraint || isThislessType(constraint);
    }

    /**
     * A variable-like declaration is free of this references if it has a type annotation
     * that is thisless, or if it has no type annotation and no initializer (and is thus of type any).
     */
    function isThislessVariableLikeDeclaration(node: VariableLikeDeclaration): boolean {
        const typeNode = getEffectiveTypeAnnotationNode(node);
        return typeNode ? isThislessType(typeNode) : !hasInitializer(node);
    }

    /**
     * A function-like declaration is considered free of `this` references if it has a return type
     * annotation that is free of this references and if each parameter is thisless and if
     * each type parameter (if present) is thisless.
     */
    function isThislessFunctionLikeDeclaration(node: FunctionLikeDeclaration): boolean {
        const returnType = getEffectiveReturnTypeNode(node);
        const typeParameters = getEffectiveTypeParameterDeclarations(node);
        return (node.kind === SyntaxKind.Constructor || (!!returnType && isThislessType(returnType))) &&
            node.parameters.every(isThislessVariableLikeDeclaration) &&
            typeParameters.every(isThislessTypeParameter);
    }

    /**
     * Returns true if the class or interface member given by the symbol is free of "this" references. The
     * function may return false for symbols that are actually free of "this" references because it is not
     * feasible to perform a complete analysis in all cases. In particular, property members with types
     * inferred from their initializers and function members with inferred return types are conservatively
     * assumed not to be free of "this" references.
     */
    function isThisless(symbol: Symbol): boolean {
        if (symbol.declarations && symbol.declarations.length === 1) {
            const declaration = symbol.declarations[0];
            if (declaration) {
                switch (declaration.kind) {
                    case SyntaxKind.PropertyDeclaration:
                    case SyntaxKind.PropertySignature:
                        return isThislessVariableLikeDeclaration(declaration as VariableLikeDeclaration);
                    case SyntaxKind.MethodDeclaration:
                    case SyntaxKind.MethodSignature:
                    case SyntaxKind.Constructor:
                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                        return isThislessFunctionLikeDeclaration(declaration as FunctionLikeDeclaration | AccessorDeclaration);
                }
            }
        }
        return false;
    }

    // The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
    // we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
    function createInstantiatedSymbolTable(symbols: Symbol[], mapper: TypeMapper, mappingThisOnly: boolean): SymbolTable {
        const result = createSymbolTable();
        for (const symbol of symbols) {
            result.set(symbol.escapedName, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));
        }
        return result;
    }

    function addInheritedMembers(symbols: SymbolTable, baseSymbols: Symbol[]) {
        for (const base of baseSymbols) {
            if (isStaticPrivateIdentifierProperty(base)) {
                continue;
            }
            const derived = symbols.get(base.escapedName);
            if (
                !derived
                // non-constructor/static-block assignment declarations are ignored here; they're not treated as overrides
                || derived.valueDeclaration
                    && isBinaryExpression(derived.valueDeclaration)
                    && !isConstructorDeclaredProperty(derived)
                    && !getContainingClassStaticBlock(derived.valueDeclaration)
            ) {
                symbols.set(base.escapedName, base);
                symbols.set(base.escapedName, base);
            }
        }
    }

    function isStaticPrivateIdentifierProperty(s: Symbol): boolean {
        return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration);
    }

    function resolveDeclaredMembers(type: InterfaceType): InterfaceTypeWithDeclaredMembers {
        if (!(type as InterfaceTypeWithDeclaredMembers).declaredProperties) {
            const symbol = type.symbol;
            const members = getMembersOfSymbol(symbol);
            (type as InterfaceTypeWithDeclaredMembers).declaredProperties = getNamedMembers(members);
            // Start with signatures at empty array in case of recursive types
            (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = emptyArray;
            (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = emptyArray;
            (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = emptyArray;

            (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call));
            (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New));
            (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = getIndexInfosOfSymbol(symbol);
        }
        return type as InterfaceTypeWithDeclaredMembers;
    }

    /**
     * Indicates whether a declaration name is definitely late-bindable.
     * A declaration name is only late-bindable if:
     * - It is a `ComputedPropertyName`.
     * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
     * `ElementAccessExpression` consisting only of these same three types of nodes.
     * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
     */
    function isLateBindableName(node: DeclarationName): node is LateBoundName {
        return isLateBindableAST(node)
            && isTypeUsableAsPropertyName(isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached((node as ElementAccessExpression).argumentExpression));
    }

    function isLateBindableIndexSignature(node: DeclarationName): node is LateBoundName {
        return isLateBindableAST(node)
            && isTypeUsableAsIndexSignature(isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached((node as ElementAccessExpression).argumentExpression));
    }

    function isLateBindableAST(node: DeclarationName) {
        if (!isComputedPropertyName(node) && !isElementAccessExpression(node)) {
            return false;
        }
        const expr = isComputedPropertyName(node) ? node.expression : node.argumentExpression;
        return isEntityNameExpression(expr);
    }

    function isTypeUsableAsIndexSignature(type: Type): boolean {
        return isTypeAssignableTo(type, stringNumberSymbolType);
    }

    function isLateBoundName(name: __String): boolean {
        return (name as string).charCodeAt(0) === CharacterCodes._ &&
            (name as string).charCodeAt(1) === CharacterCodes._ &&
            (name as string).charCodeAt(2) === CharacterCodes.at;
    }

    /**
     * Indicates whether a declaration has a late-bindable dynamic name.
     */
    function hasLateBindableName(node: Declaration): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration {
        const name = getNameOfDeclaration(node);
        return !!name && isLateBindableName(name);
    }

    function hasLateBindableIndexSignature(node: Declaration) {
        const name = getNameOfDeclaration(node);
        return !!name && isLateBindableIndexSignature(name);
    }

    /**
     * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
     */
    function hasBindableName(node: Declaration) {
        return !hasDynamicName(node) || hasLateBindableName(node);
    }

    /**
     * Indicates whether a declaration name is a dynamic name that cannot be late-bound.
     */
    function isNonBindableDynamicName(node: DeclarationName) {
        return isDynamicName(node) && !isLateBindableName(node);
    }

    /**
     * Adds a declaration to a late-bound dynamic member. This performs the same function for
     * late-bound members that `addDeclarationToSymbol` in binder.ts performs for early-bound
     * members.
     */
    function addDeclarationToLateBoundSymbol(symbol: Symbol, member: LateBoundDeclaration | BinaryExpression, symbolFlags: SymbolFlags) {
        Debug.assert(!!(getCheckFlags(symbol) & CheckFlags.Late), "Expected a late-bound symbol.");
        symbol.flags |= symbolFlags;
        getSymbolLinks(member.symbol).lateSymbol = symbol;
        if (!symbol.declarations) {
            symbol.declarations = [member];
        }
        else if (!member.symbol.isReplaceableByMethod) {
            symbol.declarations.push(member);
        }
        if (symbolFlags & SymbolFlags.Value) {
            setValueDeclaration(symbol, member);
        }
    }

    /**
     * Performs late-binding of a dynamic member. This performs the same function for
     * late-bound members that `declareSymbol` in binder.ts performs for early-bound
     * members.
     *
     * If a symbol is a dynamic name from a computed property, we perform an additional "late"
     * binding phase to attempt to resolve the name for the symbol from the type of the computed
     * property's expression. If the type of the expression is a string-literal, numeric-literal,
     * or unique symbol type, we can use that type as the name of the symbol.
     *
     * For example, given:
     *
     *   const x = Symbol();
     *
     *   interface I {
     *     [x]: number;
     *   }
     *
     * The binder gives the property `[x]: number` a special symbol with the name "__computed".
     * In the late-binding phase we can type-check the expression `x` and see that it has a
     * unique symbol type which we can then use as the name of the member. This allows users
     * to define custom symbols that can be used in the members of an object type.
     *
     * @param parent The containing symbol for the member.
     * @param earlySymbols The early-bound symbols of the parent.
     * @param lateSymbols The late-bound symbols of the parent.
     * @param decl The member to bind.
     */
    function lateBindMember(parent: Symbol, earlySymbols: SymbolTable | undefined, lateSymbols: Map<__String, TransientSymbol>, decl: LateBoundDeclaration | LateBoundBinaryExpressionDeclaration) {
        Debug.assert(!!decl.symbol, "The member is expected to have a symbol.");
        const links = getNodeLinks(decl);
        if (!links.resolvedSymbol) {
            // In the event we attempt to resolve the late-bound name of this member recursively,
            // fall back to the early-bound name of this member.
            links.resolvedSymbol = decl.symbol;
            const declName = isBinaryExpression(decl) ? decl.left : decl.name;
            const type = isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
            if (isTypeUsableAsPropertyName(type)) {
                const memberName = getPropertyNameFromType(type);
                const symbolFlags = decl.symbol.flags;

                // Get or add a late-bound symbol for the member. This allows us to merge late-bound accessor declarations.
                let lateSymbol = lateSymbols.get(memberName);
                if (!lateSymbol) lateSymbols.set(memberName, lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late));

                // Report an error if there's a symbol declaration with the same name and conflicting flags.
                const earlySymbol = earlySymbols && earlySymbols.get(memberName);
                // Duplicate property declarations of classes are checked in checkClassForDuplicateDeclarations.
                if (!(parent.flags & SymbolFlags.Class) && lateSymbol.flags & getExcludedSymbolFlags(symbolFlags)) {
                    // If we have an existing early-bound member, combine its declarations so that we can
                    // report an error at each declaration.
                    const declarations = earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations;
                    const name = !(type.flags & TypeFlags.UniqueESSymbol) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName);
                    forEach(declarations, declaration => error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name));
                    error(declName || decl, Diagnostics.Duplicate_property_0, name);
                    lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late);
                }
                lateSymbol.links.nameType = type;
                addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
                if (lateSymbol.parent) {
                    Debug.assert(lateSymbol.parent === parent, "Existing symbol parent should match new one");
                }
                else {
                    lateSymbol.parent = parent;
                }
                return links.resolvedSymbol = lateSymbol;
            }
        }
        return links.resolvedSymbol;
    }

    function lateBindIndexSignature(parent: Symbol, earlySymbols: SymbolTable | undefined, lateSymbols: Map<__String, TransientSymbol>, decl: LateBoundDeclaration | LateBoundBinaryExpressionDeclaration) {
        // First, late bind the index symbol itself, if needed
        let indexSymbol = lateSymbols.get(InternalSymbolName.Index);
        if (!indexSymbol) {
            const early = earlySymbols?.get(InternalSymbolName.Index);
            if (!early) {
                indexSymbol = createSymbol(SymbolFlags.None, InternalSymbolName.Index, CheckFlags.Late);
            }
            else {
                indexSymbol = cloneSymbol(early);
                indexSymbol.links.checkFlags |= CheckFlags.Late;
            }
            lateSymbols.set(InternalSymbolName.Index, indexSymbol);
        }
        // Then just add the computed name as a late bound declaration
        // (note: unlike `addDeclarationToLateBoundSymbol` we do not set up a `.lateSymbol` on `decl`'s links,
        // since that would point at an index symbol and not a single property symbol, like most consumers would expect)
        if (!indexSymbol.declarations) {
            indexSymbol.declarations = [decl];
        }
        else if (!decl.symbol.isReplaceableByMethod) {
            indexSymbol.declarations.push(decl);
        }
    }

    function getResolvedMembersOrExportsOfSymbol(symbol: Symbol, resolutionKind: MembersOrExportsResolutionKind): Map<__String, Symbol> {
        const links = getSymbolLinks(symbol);
        if (!links[resolutionKind]) {
            const isStatic = resolutionKind === MembersOrExportsResolutionKind.resolvedExports;
            const earlySymbols = !isStatic ? symbol.members :
                symbol.flags & SymbolFlags.Module ? getExportsOfModuleWorker(symbol).exports :
                symbol.exports;

            // In the event we recursively resolve the members/exports of the symbol, we
            // set the initial value of resolvedMembers/resolvedExports to the early-bound
            // members/exports of the symbol.
            links[resolutionKind] = earlySymbols || emptySymbols;

            // fill in any as-yet-unresolved late-bound members.
            const lateSymbols = createSymbolTable() as Map<__String, TransientSymbol>;
            for (const decl of symbol.declarations || emptyArray) {
                const members = getMembersOfDeclaration(decl);
                if (members) {
                    for (const member of members) {
                        if (isStatic === hasStaticModifier(member)) {
                            if (hasLateBindableName(member)) {
                                lateBindMember(symbol, earlySymbols, lateSymbols, member);
                            }
                            else if (hasLateBindableIndexSignature(member)) {
                                lateBindIndexSignature(symbol, earlySymbols, lateSymbols, member as Node as LateBoundDeclaration | LateBoundBinaryExpressionDeclaration);
                            }
                        }
                    }
                }
            }
            const assignments = getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers;

            if (assignments) {
                const decls = arrayFrom(assignments.values());
                for (const member of decls) {
                    const assignmentKind = getAssignmentDeclarationKind(member as BinaryExpression | CallExpression);
                    const isInstanceMember = assignmentKind === AssignmentDeclarationKind.PrototypeProperty
                        || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind)
                        || assignmentKind === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
                        || assignmentKind === AssignmentDeclarationKind.Prototype; // A straight `Prototype` assignment probably can never have a computed name
                    if (isStatic === !isInstanceMember) {
                        if (hasLateBindableName(member)) {
                            lateBindMember(symbol, earlySymbols, lateSymbols, member);
                        }
                    }
                }
            }

            let resolved = combineSymbolTables(earlySymbols, lateSymbols);
            if (symbol.flags & SymbolFlags.Transient && links.cjsExportMerged && symbol.declarations) {
                for (const decl of symbol.declarations) {
                    const original = getSymbolLinks(decl.symbol)[resolutionKind];
                    if (!resolved) {
                        resolved = original;
                        continue;
                    }
                    if (!original) continue;
                    original.forEach((s, name) => {
                        const existing = resolved!.get(name);
                        if (!existing) resolved!.set(name, s);
                        else if (existing === s) return;
                        else resolved!.set(name, mergeSymbol(existing, s));
                    });
                }
            }
            links[resolutionKind] = resolved || emptySymbols;
        }

        return links[resolutionKind];
    }

    /**
     * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
     *
     * For a description of late-binding, see `lateBindMember`.
     */
    function getMembersOfSymbol(symbol: Symbol) {
        return symbol.flags & SymbolFlags.LateBindingContainer
            ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedMembers)
            : symbol.members || emptySymbols;
    }

    /**
     * If a symbol is the dynamic name of the member of an object type, get the late-bound
     * symbol of the member.
     *
     * For a description of late-binding, see `lateBindMember`.
     */
    function getLateBoundSymbol(symbol: Symbol): Symbol {
        if (symbol.flags & SymbolFlags.ClassMember && symbol.escapedName === InternalSymbolName.Computed) {
            const links = getSymbolLinks(symbol);
            if (!links.lateSymbol && some(symbol.declarations, hasLateBindableName)) {
                // force late binding of members/exports. This will set the late-bound symbol
                const parent = getMergedSymbol(symbol.parent)!;
                if (some(symbol.declarations, hasStaticModifier)) {
                    getExportsOfSymbol(parent);
                }
                else {
                    getMembersOfSymbol(parent);
                }
            }
            return links.lateSymbol || (links.lateSymbol = symbol);
        }
        return symbol;
    }

    function getTypeWithThisArgument(type: Type, thisArgument?: Type, needApparentType?: boolean): Type {
        if (getObjectFlags(type) & ObjectFlags.Reference) {
            const target = (type as TypeReference).target;
            const typeArguments = getTypeArguments(type as TypeReference);
            return length(target.typeParameters) === length(typeArguments) ? createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType!])) : type;
        }
        else if (type.flags & TypeFlags.Intersection) {
            const types = sameMap((type as IntersectionType).types, t => getTypeWithThisArgument(t, thisArgument, needApparentType));
            return types !== (type as IntersectionType).types ? getIntersectionType(types) : type;
        }
        return needApparentType ? getApparentType(type) : type;
    }

    function resolveObjectTypeMembers(type: ObjectType, source: InterfaceTypeWithDeclaredMembers, typeParameters: readonly TypeParameter[], typeArguments: readonly Type[]) {
        let mapper: TypeMapper | undefined;
        let members: SymbolTable;
        let callSignatures: readonly Signature[];
        let constructSignatures: readonly Signature[];
        let indexInfos: readonly IndexInfo[];
        if (rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
            members = source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties);
            callSignatures = source.declaredCallSignatures;
            constructSignatures = source.declaredConstructSignatures;
            indexInfos = source.declaredIndexInfos;
        }
        else {
            mapper = createTypeMapper(typeParameters, typeArguments);
            members = createInstantiatedSymbolTable(source.declaredProperties, mapper, /*mappingThisOnly*/ typeParameters.length === 1);
            callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
            constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
            indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper);
        }
        const baseTypes = getBaseTypes(source);
        if (baseTypes.length) {
            if (source.symbol && members === getMembersOfSymbol(source.symbol)) {
                const symbolTable = createSymbolTable(source.declaredProperties);
                // copy index signature symbol as well (for quickinfo)
                const sourceIndex = getIndexSymbol(source.symbol);
                if (sourceIndex) {
                    symbolTable.set(InternalSymbolName.Index, sourceIndex);
                }
                members = symbolTable;
            }
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            const thisArgument = lastOrUndefined(typeArguments);
            for (const baseType of baseTypes) {
                const instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;
                addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Call));
                constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Construct));
                const inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [anyBaseTypeIndexInfo];
                indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, info => !findIndexInfo(indexInfos, info.keyType)));
            }
        }
        setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
    }

    function resolveClassOrInterfaceMembers(type: InterfaceType): void {
        resolveObjectTypeMembers(type, resolveDeclaredMembers(type), emptyArray, emptyArray);
    }

    function resolveTypeReferenceMembers(type: TypeReference): void {
        const source = resolveDeclaredMembers(type.target);
        const typeParameters = concatenate(source.typeParameters!, [source.thisType!]);
        const typeArguments = getTypeArguments(type);
        const paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]);
        resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments);
    }

    function createSignature(
        declaration: SignatureDeclaration | JSDocSignature | undefined,
        typeParameters: readonly TypeParameter[] | undefined,
        thisParameter: Symbol | undefined,
        parameters: readonly Symbol[],
        resolvedReturnType: Type | undefined,
        resolvedTypePredicate: TypePredicate | undefined,
        minArgumentCount: number,
        flags: SignatureFlags,
    ): Signature {
        const sig = new Signature(checker, flags);
        sig.declaration = declaration;
        sig.typeParameters = typeParameters;
        sig.parameters = parameters;
        sig.thisParameter = thisParameter;
        sig.resolvedReturnType = resolvedReturnType;
        sig.resolvedTypePredicate = resolvedTypePredicate;
        sig.minArgumentCount = minArgumentCount;
        sig.resolvedMinArgumentCount = undefined;
        sig.target = undefined;
        sig.mapper = undefined;
        sig.compositeSignatures = undefined;
        sig.compositeKind = undefined;
        return sig;
    }

    function cloneSignature(sig: Signature): Signature {
        const result = createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags);
        result.target = sig.target;
        result.mapper = sig.mapper;
        result.compositeSignatures = sig.compositeSignatures;
        result.compositeKind = sig.compositeKind;
        return result;
    }

    function createUnionSignature(signature: Signature, unionSignatures: Signature[]) {
        const result = cloneSignature(signature);
        result.compositeSignatures = unionSignatures;
        result.compositeKind = TypeFlags.Union;
        result.target = undefined;
        result.mapper = undefined;
        return result;
    }

    function getOptionalCallSignature(signature: Signature, callChainFlags: SignatureFlags): Signature {
        if ((signature.flags & SignatureFlags.CallChainFlags) === callChainFlags) {
            return signature;
        }
        if (!signature.optionalCallSignatureCache) {
            signature.optionalCallSignatureCache = {};
        }
        const key = callChainFlags === SignatureFlags.IsInnerCallChain ? "inner" : "outer";
        return signature.optionalCallSignatureCache[key]
            || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags));
    }

    function createOptionalCallSignature(signature: Signature, callChainFlags: SignatureFlags) {
        Debug.assert(callChainFlags === SignatureFlags.IsInnerCallChain || callChainFlags === SignatureFlags.IsOuterCallChain, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.");
        const result = cloneSignature(signature);
        result.flags |= callChainFlags;
        return result;
    }

    function getExpandedParameters(sig: Signature, skipUnionExpanding?: boolean): readonly (readonly Symbol[])[] {
        if (signatureHasRestParameter(sig)) {
            const restIndex = sig.parameters.length - 1;
            const restSymbol = sig.parameters[restIndex];
            const restType = getTypeOfSymbol(restSymbol);
            if (isTupleType(restType)) {
                return [expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)];
            }
            else if (!skipUnionExpanding && restType.flags & TypeFlags.Union && every((restType as UnionType).types, isTupleType)) {
                return map((restType as UnionType).types, t => expandSignatureParametersWithTupleMembers(t as TupleTypeReference, restIndex, restSymbol));
            }
        }
        return [sig.parameters];

        function expandSignatureParametersWithTupleMembers(restType: TupleTypeReference, restIndex: number, restSymbol: Symbol) {
            const elementTypes = getTypeArguments(restType);
            const associatedNames = getUniqAssociatedNamesFromTupleType(restType, restSymbol);
            const restParams = map(elementTypes, (t, i) => {
                // Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name
                const name = associatedNames && associatedNames[i] ? associatedNames[i] :
                    getParameterNameAtPosition(sig, restIndex + i, restType);
                const flags = restType.target.elementFlags[i];
                const checkFlags = flags & ElementFlags.Variable ? CheckFlags.RestParameter :
                    flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0;
                const symbol = createSymbol(SymbolFlags.FunctionScopedVariable, name, checkFlags);
                symbol.links.type = flags & ElementFlags.Rest ? createArrayType(t) : t;
                return symbol;
            });
            return concatenate(sig.parameters.slice(0, restIndex), restParams);
        }

        function getUniqAssociatedNamesFromTupleType(type: TupleTypeReference, restSymbol: Symbol) {
            const names = map(type.target.labeledElementDeclarations, (labeledElement, i) => getTupleElementLabel(labeledElement, i, type.target.elementFlags[i], restSymbol));
            if (names) {
                const duplicates: number[] = [];
                const uniqueNames = new Set<__String>();
                for (let i = 0; i < names.length; i++) {
                    const name = names[i];
                    if (!tryAddToSet(uniqueNames, name)) {
                        duplicates.push(i);
                    }
                }
                const counters = new Map<__String, number>();
                for (const i of duplicates) {
                    let counter = counters.get(names[i]) ?? 1;
                    let name: __String;
                    while (!tryAddToSet(uniqueNames, name = `${names[i]}_${counter}` as __String)) {
                        counter++;
                    }
                    names[i] = name;
                    counters.set(names[i], counter + 1);
                }
            }
            return names;
        }
    }

    function getDefaultConstructSignatures(classType: InterfaceType): Signature[] {
        const baseConstructorType = getBaseConstructorTypeOfClass(classType);
        const baseSignatures = getSignaturesOfType(baseConstructorType, SignatureKind.Construct);
        const declaration = getClassLikeDeclarationOfSymbol(classType.symbol);
        const isAbstract = !!declaration && hasSyntacticModifier(declaration, ModifierFlags.Abstract);
        if (baseSignatures.length === 0) {
            return [createSignature(/*declaration*/ undefined, classType.localTypeParameters, /*thisParameter*/ undefined, emptyArray, classType, /*resolvedTypePredicate*/ undefined, 0, isAbstract ? SignatureFlags.Abstract : SignatureFlags.None)];
        }
        const baseTypeNode = getBaseTypeNodeOfClass(classType)!;
        const isJavaScript = isInJSFile(baseTypeNode);
        const typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
        const typeArgCount = length(typeArguments);
        const result: Signature[] = [];
        for (const baseSig of baseSignatures) {
            const minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);
            const typeParamCount = length(baseSig.typeParameters);
            if (isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount) {
                const sig = typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig);
                sig.typeParameters = classType.localTypeParameters;
                sig.resolvedReturnType = classType;
                sig.flags = isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract;
                result.push(sig);
            }
        }
        return result;
    }

    function findMatchingSignature(signatureList: readonly Signature[], signature: Signature, partialMatch: boolean, ignoreThisTypes: boolean, ignoreReturnTypes: boolean): Signature | undefined {
        for (const s of signatureList) {
            if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, partialMatch ? compareTypesSubtypeOf : compareTypesIdentical)) {
                return s;
            }
        }
    }

    function findMatchingSignatures(signatureLists: readonly (readonly Signature[])[], signature: Signature, listIndex: number): Signature[] | undefined {
        if (signature.typeParameters) {
            // We require an exact match for generic signatures, so we only return signatures from the first
            // signature list and only if they have exact matches in the other signature lists.
            if (listIndex > 0) {
                return undefined;
            }
            for (let i = 1; i < signatureLists.length; i++) {
                if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false)) {
                    return undefined;
                }
            }
            return [signature];
        }
        let result: Signature[] | undefined;
        for (let i = 0; i < signatureLists.length; i++) {
            // Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.
            // Prefer matching this types if possible.
            const match = i === listIndex
                ? signature
                : findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true)
                    || findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ true, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true);
            if (!match) {
                return undefined;
            }
            result = appendIfUnique(result, match);
        }
        return result;
    }

    // The signatures of a union type are those signatures that are present in each of the constituent types.
    // Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
    // parameters and may differ in return types. When signatures differ in return types, the resulting return
    // type is the union of the constituent return types.
    function getUnionSignatures(signatureLists: readonly (readonly Signature[])[]): Signature[] {
        let result: Signature[] | undefined;
        let indexWithLengthOverOne: number | undefined;
        for (let i = 0; i < signatureLists.length; i++) {
            if (signatureLists[i].length === 0) return emptyArray;
            if (signatureLists[i].length > 1) {
                indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets
            }
            for (const signature of signatureLists[i]) {
                // Only process signatures with parameter lists that aren't already in the result list
                if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true)) {
                    const unionSignatures = findMatchingSignatures(signatureLists, signature, i);
                    if (unionSignatures) {
                        let s = signature;
                        // Union the result types when more than one signature matches
                        if (unionSignatures.length > 1) {
                            let thisParameter = signature.thisParameter;
                            const firstThisParameterOfUnionSignatures = forEach(unionSignatures, sig => sig.thisParameter);
                            if (firstThisParameterOfUnionSignatures) {
                                const thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));
                                thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);
                            }
                            s = createUnionSignature(signature, unionSignatures);
                            s.thisParameter = thisParameter;
                        }
                        (result || (result = [])).push(s);
                    }
                }
            }
        }
        if (!length(result) && indexWithLengthOverOne !== -1) {
            // No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
            // signature that handles all over them. We only do this when there are overloads in only one constituent.
            // (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
            // signatures from the type, whose ordering would be non-obvious)
            const masterList = signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0];
            let results: Signature[] | undefined = masterList.slice();
            for (const signatures of signatureLists) {
                if (signatures !== masterList) {
                    const signature = signatures[0];
                    Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass");
                    results = !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature));
                    if (!results) {
                        break;
                    }
                }
            }
            result = results;
        }
        return result || emptyArray;
    }

    function compareTypeParametersIdentical(sourceParams: readonly TypeParameter[] | undefined, targetParams: readonly TypeParameter[] | undefined): boolean {
        if (length(sourceParams) !== length(targetParams)) {
            return false;
        }
        if (!sourceParams || !targetParams) {
            return true;
        }

        const mapper = createTypeMapper(targetParams, sourceParams);
        for (let i = 0; i < sourceParams.length; i++) {
            const source = sourceParams[i];
            const target = targetParams[i];
            if (source === target) continue;
            // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
            if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper))) return false;
            // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
            // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
            // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
            // and, since it's just an inference _default_, just picking one arbitrarily works OK.
        }

        return true;
    }

    function combineUnionThisParam(left: Symbol | undefined, right: Symbol | undefined, mapper: TypeMapper | undefined): Symbol | undefined {
        if (!left || !right) {
            return left || right;
        }
        // A signature `this` type might be a read or a write position... It's very possible that it should be invariant
        // and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
        // permissive when calling, for now, we'll intersect the `this` types just like we do for param types in union signatures.
        const thisType = getIntersectionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
        return createSymbolWithType(left, thisType);
    }

    function combineUnionParameters(left: Signature, right: Signature, mapper: TypeMapper | undefined) {
        const leftCount = getParameterCount(left);
        const rightCount = getParameterCount(right);
        const longest = leftCount >= rightCount ? left : right;
        const shorter = longest === left ? right : left;
        const longestCount = longest === left ? leftCount : rightCount;
        const eitherHasEffectiveRest = hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right);
        const needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
        const params = new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0));
        for (let i = 0; i < longestCount; i++) {
            let longestParamType = tryGetTypeAtPosition(longest, i)!;
            if (longest === right) {
                longestParamType = instantiateType(longestParamType, mapper);
            }
            let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
            if (shorter === right) {
                shorterParamType = instantiateType(shorterParamType, mapper);
            }
            const unionParamType = getIntersectionType([longestParamType, shorterParamType]);
            const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
            const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
            const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
            const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);

            const paramName = leftName === rightName ? leftName :
                !leftName ? rightName :
                !rightName ? leftName :
                undefined;
            const paramSymbol = createSymbol(
                SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),
                paramName || `arg${i}` as __String,
                isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0,
            );
            paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
            params[i] = paramSymbol;
        }
        if (needsExtraRestElement) {
            const restParamSymbol = createSymbol(SymbolFlags.FunctionScopedVariable, "args" as __String, CheckFlags.RestParameter);
            restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount));
            if (shorter === right) {
                restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper);
            }
            params[longestCount] = restParamSymbol;
        }
        return params;
    }

    function combineSignaturesOfUnionMembers(left: Signature, right: Signature): Signature {
        const typeParams = left.typeParameters || right.typeParameters;
        let paramMapper: TypeMapper | undefined;
        if (left.typeParameters && right.typeParameters) {
            paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
            // We just use the type parameter defaults from the first signature
        }
        let flags = (left.flags | right.flags) & (SignatureFlags.PropagatingFlags & ~SignatureFlags.HasRestParameter);
        const declaration = left.declaration;
        const params = combineUnionParameters(left, right, paramMapper);
        const lastParam = lastOrUndefined(params);
        if (lastParam && getCheckFlags(lastParam) & CheckFlags.RestParameter) {
            flags |= SignatureFlags.HasRestParameter;
        }
        const thisParam = combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper);
        const minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
        const result = createSignature(
            declaration,
            typeParams,
            thisParam,
            params,
            /*resolvedReturnType*/ undefined,
            /*resolvedTypePredicate*/ undefined,
            minArgCount,
            flags,
        );
        result.compositeKind = TypeFlags.Union;
        result.compositeSignatures = concatenate(left.compositeKind !== TypeFlags.Intersection && left.compositeSignatures || [left], [right]);
        if (paramMapper) {
            result.mapper = left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
        }
        else if (left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures) {
            result.mapper = left.mapper;
        }
        return result;
    }

    function getUnionIndexInfos(types: readonly Type[]): IndexInfo[] {
        const sourceInfos = getIndexInfosOfType(types[0]);
        if (sourceInfos) {
            const result = [];
            for (const info of sourceInfos) {
                const indexType = info.keyType;
                if (every(types, t => !!getIndexInfoOfType(t, indexType))) {
                    result.push(createIndexInfo(indexType, getUnionType(map(types, t => getIndexTypeOfType(t, indexType)!)), some(types, t => getIndexInfoOfType(t, indexType)!.isReadonly)));
                }
            }
            return result;
        }
        return emptyArray;
    }

    function resolveUnionTypeMembers(type: UnionType) {
        // The members and properties collections are empty for union types. To get all properties of a union
        // type use getPropertiesOfType (only the language service uses this).
        const callSignatures = getUnionSignatures(map(type.types, t => t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, SignatureKind.Call)));
        const constructSignatures = getUnionSignatures(map(type.types, t => getSignaturesOfType(t, SignatureKind.Construct)));
        const indexInfos = getUnionIndexInfos(type.types);
        setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos);
    }

    function intersectTypes(type1: Type, type2: Type): Type;
    function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined;
    function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined {
        return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
    }

    function findMixins(types: readonly Type[]): readonly boolean[] {
        const constructorTypeCount = countWhere(types, t => getSignaturesOfType(t, SignatureKind.Construct).length > 0);
        const mixinFlags = map(types, isMixinConstructorType);
        if (constructorTypeCount > 0 && constructorTypeCount === countWhere(mixinFlags, b => b)) {
            const firstMixinIndex = mixinFlags.indexOf(/*searchElement*/ true);
            mixinFlags[firstMixinIndex] = false;
        }
        return mixinFlags;
    }

    function includeMixinType(type: Type, types: readonly Type[], mixinFlags: readonly boolean[], index: number): Type {
        const mixedTypes: Type[] = [];
        for (let i = 0; i < types.length; i++) {
            if (i === index) {
                mixedTypes.push(type);
            }
            else if (mixinFlags[i]) {
                mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKind.Construct)[0]));
            }
        }
        return getIntersectionType(mixedTypes);
    }

    function resolveIntersectionTypeMembers(type: IntersectionType) {
        // The members and properties collections are empty for intersection types. To get all properties of an
        // intersection type use getPropertiesOfType (only the language service uses this).
        let callSignatures: Signature[] | undefined;
        let constructSignatures: Signature[] | undefined;
        let indexInfos: IndexInfo[] | undefined;
        const types = type.types;
        const mixinFlags = findMixins(types);
        const mixinCount = countWhere(mixinFlags, b => b);
        for (let i = 0; i < types.length; i++) {
            const t = type.types[i];
            // When an intersection type contains mixin constructor types, the construct signatures from
            // those types are discarded and their return types are mixed into the return types of all
            // other construct signatures in the intersection type. For example, the intersection type
            // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
            // 'new(s: string) => A & B'.
            if (!mixinFlags[i]) {
                let signatures = getSignaturesOfType(t, SignatureKind.Construct);
                if (signatures.length && mixinCount > 0) {
                    signatures = map(signatures, s => {
                        const clone = cloneSignature(s);
                        clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
                        return clone;
                    });
                }
                constructSignatures = appendSignatures(constructSignatures, signatures);
            }
            callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKind.Call));
            indexInfos = reduceLeft(getIndexInfosOfType(t), (infos, newInfo) => appendIndexInfo(infos, newInfo, /*union*/ false), indexInfos);
        }
        setStructuredTypeMembers(type, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray);
    }

    function appendSignatures(signatures: Signature[] | undefined, newSignatures: readonly Signature[]) {
        for (const sig of newSignatures) {
            if (!signatures || every(signatures, s => !compareSignaturesIdentical(s, sig, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, compareTypesIdentical))) {
                signatures = append(signatures, sig);
            }
        }
        return signatures;
    }

    function appendIndexInfo(indexInfos: IndexInfo[] | undefined, newInfo: IndexInfo, union: boolean) {
        if (indexInfos) {
            for (let i = 0; i < indexInfos.length; i++) {
                const info = indexInfos[i];
                if (info.keyType === newInfo.keyType) {
                    indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);
                    return indexInfos;
                }
            }
        }
        return append(indexInfos, newInfo);
    }

    /**
     * Converts an AnonymousType to a ResolvedType.
     */
    function resolveAnonymousTypeMembers(type: AnonymousType) {
        if (type.target) {
            setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
            const members = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper!, /*mappingThisOnly*/ false);
            const callSignatures = instantiateSignatures(getSignaturesOfType(type.target, SignatureKind.Call), type.mapper!);
            const constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, SignatureKind.Construct), type.mapper!);
            const indexInfos = instantiateIndexInfos(getIndexInfosOfType(type.target), type.mapper!);
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            return;
        }
        const symbol = getMergedSymbol(type.symbol);
        if (symbol.flags & SymbolFlags.TypeLiteral) {
            setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
            const members = getMembersOfSymbol(symbol);
            const callSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call));
            const constructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New));
            const indexInfos = getIndexInfosOfSymbol(symbol);
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            return;
        }
        // Combinations of function, class, enum and module
        let members = getExportsOfSymbol(symbol);
        let indexInfos: IndexInfo[] | undefined;
        if (symbol === globalThisSymbol) {
            const varsOnly = new Map<__String, Symbol>();
            members.forEach(p => {
                if (!(p.flags & SymbolFlags.BlockScoped) && !(p.flags & SymbolFlags.ValueModule && p.declarations?.length && every(p.declarations, isAmbientModule))) {
                    varsOnly.set(p.escapedName, p);
                }
            });
            members = varsOnly;
        }
        let baseConstructorIndexInfo: IndexInfo | undefined;
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, emptyArray);
        if (symbol.flags & SymbolFlags.Class) {
            const classType = getDeclaredTypeOfClassOrInterface(symbol);
            const baseConstructorType = getBaseConstructorTypeOfClass(classType);
            if (baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.TypeVariable)) {
                members = createSymbolTable(getNamedOrIndexSignatureMembers(members));
                addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
            }
            else if (baseConstructorType === anyType) {
                baseConstructorIndexInfo = anyBaseTypeIndexInfo;
            }
        }

        const indexSymbol = getIndexSymbolFromSymbolTable(members);
        if (indexSymbol) {
            indexInfos = getIndexInfosOfIndexSymbol(indexSymbol, arrayFrom(members.values()));
        }
        else {
            if (baseConstructorIndexInfo) {
                indexInfos = append(indexInfos, baseConstructorIndexInfo);
            }
            if (
                symbol.flags & SymbolFlags.Enum && (getDeclaredTypeOfSymbol(symbol).flags & TypeFlags.Enum ||
                    some(type.properties, prop => !!(getTypeOfSymbol(prop).flags & TypeFlags.NumberLike)))
            ) {
                indexInfos = append(indexInfos, enumNumberIndexInfo);
            }
        }
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos || emptyArray);
        // We resolve the members before computing the signatures because a signature may use
        // typeof with a qualified name expression that circularly references the type we are
        // in the process of resolving (see issue #6072). The temporarily empty signature list
        // will never be observed because a qualified name can't reference signatures.
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) {
            type.callSignatures = getSignaturesOfSymbol(symbol);
        }
        // And likewise for construct signatures for classes
        if (symbol.flags & SymbolFlags.Class) {
            const classType = getDeclaredTypeOfClassOrInterface(symbol);
            let constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : emptyArray;
            if (symbol.flags & SymbolFlags.Function) {
                constructSignatures = addRange(
                    constructSignatures.slice(),
                    mapDefined(
                        type.callSignatures,
                        sig =>
                            isJSConstructor(sig.declaration) ?
                                createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) :
                                undefined,
                    ),
                );
            }
            if (!constructSignatures.length) {
                constructSignatures = getDefaultConstructSignatures(classType);
            }
            type.constructSignatures = constructSignatures;
        }
    }

    type ReplaceableIndexedAccessType = IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; };
    function replaceIndexedAccess(instantiable: Type, type: ReplaceableIndexedAccessType, replacement: Type) {
        // map type.indexType to 0
        // map type.objectType to `[TReplacement]`
        // thus making the indexed access `[TReplacement][0]` or `TReplacement`
        return instantiateType(instantiable, createTypeMapper([type.indexType, type.objectType], [getNumberLiteralType(0), createTupleType([replacement])]));
    }

    // If the original mapped type had an intersection constraint we extract its components,
    // and we make an attempt to do so even if the intersection has been reduced to a union.
    // This entire process allows us to possibly retrieve the filtering type literals.
    // e.g. { [K in keyof U & ("a" | "b") ] } -> "a" | "b"
    function getLimitedConstraint(type: ReverseMappedType) {
        const constraint = getConstraintTypeFromMappedType(type.mappedType);
        if (!(constraint.flags & TypeFlags.Union || constraint.flags & TypeFlags.Intersection)) {
            return;
        }
        const origin = (constraint.flags & TypeFlags.Union) ? (constraint as UnionType).origin : (constraint as IntersectionType);
        if (!origin || !(origin.flags & TypeFlags.Intersection)) {
            return;
        }
        const limitedConstraint = getIntersectionType((origin as IntersectionType).types.filter(t => t !== type.constraintType));
        return limitedConstraint !== neverType ? limitedConstraint : undefined;
    }

    function resolveReverseMappedTypeMembers(type: ReverseMappedType) {
        const indexInfo = getIndexInfoOfType(type.source, stringType);
        const modifiers = getMappedTypeModifiers(type.mappedType);
        const readonlyMask = modifiers & MappedTypeModifiers.IncludeReadonly ? false : true;
        const optionalMask = modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional;
        const indexInfos = indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)] : emptyArray;
        const members = createSymbolTable();
        const limitedConstraint = getLimitedConstraint(type);
        for (const prop of getPropertiesOfType(type.source)) {
            // In case of a reverse mapped type with an intersection constraint, if we were able to
            // extract the filtering type literals we skip those properties that are not assignable to them,
            // because the extra properties wouldn't get through the application of the mapped type anyway
            if (limitedConstraint) {
                const propertyNameType = getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique);
                if (!isTypeAssignableTo(propertyNameType, limitedConstraint)) {
                    continue;
                }
            }
            const checkFlags = CheckFlags.ReverseMapped | (readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0);
            const inferredProp = createSymbol(SymbolFlags.Property | prop.flags & optionalMask, prop.escapedName, checkFlags) as ReverseMappedSymbol;
            inferredProp.declarations = prop.declarations;
            inferredProp.links.nameType = getSymbolLinks(prop).nameType;
            inferredProp.links.propertyType = getTypeOfSymbol(prop);
            if (
                type.constraintType.type.flags & TypeFlags.IndexedAccess
                && (type.constraintType.type as IndexedAccessType).objectType.flags & TypeFlags.TypeParameter
                && (type.constraintType.type as IndexedAccessType).indexType.flags & TypeFlags.TypeParameter
            ) {
                // A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
                // inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
                // type identities produced, we simplify such indexed access occurences
                const newTypeParam = (type.constraintType.type as IndexedAccessType).objectType;
                const newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type as ReplaceableIndexedAccessType, newTypeParam);
                inferredProp.links.mappedType = newMappedType as MappedType;
                inferredProp.links.constraintType = getIndexType(newTypeParam) as IndexType;
            }
            else {
                inferredProp.links.mappedType = type.mappedType;
                inferredProp.links.constraintType = type.constraintType;
            }
            members.set(prop.escapedName, inferredProp);
        }
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos);
    }

    // Return the lower bound of the key type in a mapped type. Intuitively, the lower
    // bound includes those keys that are known to always be present, for example because
    // because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
    function getLowerBoundOfKeyType(type: Type): Type {
        if (type.flags & TypeFlags.Index) {
            const t = getApparentType((type as IndexType).type);
            return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t);
        }
        if (type.flags & TypeFlags.Conditional) {
            if ((type as ConditionalType).root.isDistributive) {
                const checkType = (type as ConditionalType).checkType;
                const constraint = getLowerBoundOfKeyType(checkType);
                if (constraint !== checkType) {
                    return getConditionalTypeInstantiation(type as ConditionalType, prependTypeMapping((type as ConditionalType).root.checkType, constraint, (type as ConditionalType).mapper), /*forConstraint*/ false);
                }
            }
            return type;
        }
        if (type.flags & TypeFlags.Union) {
            return mapType(type as UnionType, getLowerBoundOfKeyType, /*noReductions*/ true);
        }
        if (type.flags & TypeFlags.Intersection) {
            // Similarly to getTypeFromIntersectionTypeNode, we preserve the special string & {}, number & {},
            // and bigint & {} intersections that are used to prevent subtype reduction in union types.
            const types = (type as IntersectionType).types;
            if (types.length === 2 && !!(types[0].flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt)) && types[1] === emptyTypeLiteralType) {
                return type;
            }
            return getIntersectionType(sameMap((type as UnionType).types, getLowerBoundOfKeyType));
        }
        return type;
    }

    function getIsLateCheckFlag(s: Symbol): CheckFlags {
        return getCheckFlags(s) & CheckFlags.Late;
    }

    function forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(type: Type, include: TypeFlags, stringsOnly: boolean, cb: (keyType: Type) => void) {
        for (const prop of getPropertiesOfType(type)) {
            cb(getLiteralTypeFromProperty(prop, include));
        }
        if (type.flags & TypeFlags.Any) {
            cb(stringType);
        }
        else {
            for (const info of getIndexInfosOfType(type)) {
                if (!stringsOnly || info.keyType.flags & (TypeFlags.String | TypeFlags.TemplateLiteral)) {
                    cb(info.keyType);
                }
            }
        }
    }

    /** Resolve the members of a mapped type { [P in K]: T } */
    function resolveMappedTypeMembers(type: MappedType) {
        const members: SymbolTable = createSymbolTable();
        let indexInfos: IndexInfo[] | undefined;
        // Resolve upfront such that recursive references see an empty object type.
        setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
        // In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
        // and T as the template type.
        const typeParameter = getTypeParameterFromMappedType(type);
        const constraintType = getConstraintTypeFromMappedType(type);
        const mappedType = (type.target as MappedType) || type;
        const nameType = getNameTypeFromMappedType(mappedType);
        const shouldLinkPropDeclarations = getMappedTypeNameTypeKind(mappedType) !== MappedTypeNameTypeKind.Remapping;
        const templateType = getTemplateTypeFromMappedType(mappedType);
        const modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
        const templateModifiers = getMappedTypeModifiers(type);
        const include = TypeFlags.StringOrNumberLiteralOrUnique;
        if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
            // We have a { [P in keyof T]: X }
            forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, /*stringsOnly*/ false, addMemberForKeyType);
        }
        else {
            forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
        }
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos || emptyArray);

        function addMemberForKeyType(keyType: Type) {
            const propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
            forEachType(propNameType, t => addMemberForKeyTypeWorker(keyType, t));
        }

        function addMemberForKeyTypeWorker(keyType: Type, propNameType: Type) {
            // If the current iteration type constituent is a string literal type, create a property.
            // Otherwise, for type string create a string index signature.
            if (isTypeUsableAsPropertyName(propNameType)) {
                const propName = getPropertyNameFromType(propNameType);
                // String enum members from separate enums with identical values
                // are distinct types with the same property name. Make the resulting
                // property symbol's name type be the union of those enum member types.
                const existingProp = members.get(propName) as MappedSymbol | undefined;
                if (existingProp) {
                    existingProp.links.nameType = getUnionType([existingProp.links.nameType!, propNameType]);
                    existingProp.links.keyType = getUnionType([existingProp.links.keyType, keyType]);
                }
                else {
                    const modifiersProp = isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined;
                    const isOptional = !!(templateModifiers & MappedTypeModifiers.IncludeOptional ||
                        !(templateModifiers & MappedTypeModifiers.ExcludeOptional) && modifiersProp && modifiersProp.flags & SymbolFlags.Optional);
                    const isReadonly = !!(templateModifiers & MappedTypeModifiers.IncludeReadonly ||
                        !(templateModifiers & MappedTypeModifiers.ExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp));
                    const stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & SymbolFlags.Optional;
                    const lateFlag: CheckFlags = modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0;
                    const prop = createSymbol(SymbolFlags.Property | (isOptional ? SymbolFlags.Optional : 0), propName, lateFlag | CheckFlags.Mapped | (isReadonly ? CheckFlags.Readonly : 0) | (stripOptional ? CheckFlags.StripOptional : 0)) as MappedSymbol;
                    prop.links.mappedType = type;
                    prop.links.nameType = propNameType;
                    prop.links.keyType = keyType;
                    if (modifiersProp) {
                        prop.links.syntheticOrigin = modifiersProp;
                        prop.declarations = shouldLinkPropDeclarations ? modifiersProp.declarations : undefined;
                    }
                    members.set(propName, prop);
                }
            }
            else if (isValidIndexKeyType(propNameType) || propNameType.flags & (TypeFlags.Any | TypeFlags.Enum)) {
                const indexKeyType = propNameType.flags & (TypeFlags.Any | TypeFlags.String) ? stringType :
                    propNameType.flags & (TypeFlags.Number | TypeFlags.Enum) ? numberType :
                    propNameType;
                const propType = instantiateType(templateType, appendTypeMapping(type.mapper, typeParameter, keyType));
                const modifiersIndexInfo = getApplicableIndexInfo(modifiersType, propNameType);
                const isReadonly = !!(templateModifiers & MappedTypeModifiers.IncludeReadonly ||
                    !(templateModifiers & MappedTypeModifiers.ExcludeReadonly) && modifiersIndexInfo?.isReadonly);
                const indexInfo = createIndexInfo(indexKeyType, propType, isReadonly);
                indexInfos = appendIndexInfo(indexInfos, indexInfo, /*union*/ true);
            }
        }
    }

    function getTypeOfMappedSymbol(symbol: MappedSymbol) {
        if (!symbol.links.type) {
            const mappedType = symbol.links.mappedType;
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
                mappedType.containsError = true;
                return errorType;
            }
            const templateType = getTemplateTypeFromMappedType(mappedType.target as MappedType || mappedType);
            const mapper = appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.links.keyType);
            const propType = instantiateType(templateType, mapper);
            // When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
            // type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
            // mode, if the underlying property is optional we remove 'undefined' from the type.
            let type = strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty*/ true) :
                symbol.links.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(propType) :
                propType;
            if (!popTypeResolution()) {
                error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType));
                type = errorType;
            }
            symbol.links.type ??= type;
        }
        return symbol.links.type;
    }

    function getTypeParameterFromMappedType(type: MappedType) {
        return type.typeParameter ||
            (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)));
    }

    function getConstraintTypeFromMappedType(type: MappedType) {
        return type.constraintType ||
            (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
    }

    function getNameTypeFromMappedType(type: MappedType) {
        return type.declaration.nameType ?
            type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :
            undefined;
    }

    function getTemplateTypeFromMappedType(type: MappedType) {
        return type.templateType ||
            (type.templateType = type.declaration.type ?
                instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty*/ true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) :
                errorType);
    }

    function getConstraintDeclarationForMappedType(type: MappedType) {
        return getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
    }

    function isMappedTypeWithKeyofConstraintDeclaration(type: MappedType) {
        const constraintDeclaration = getConstraintDeclarationForMappedType(type)!; // TODO: GH#18217
        return constraintDeclaration.kind === SyntaxKind.TypeOperator &&
            (constraintDeclaration as TypeOperatorNode).operator === SyntaxKind.KeyOfKeyword;
    }

    function getModifiersTypeFromMappedType(type: MappedType) {
        if (!type.modifiersType) {
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                // If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
                // AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
                // 'keyof T' to a literal union type and we can't recover T from that type.
                type.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type) as TypeOperatorNode).type), type.mapper);
            }
            else {
                // Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
                // get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
                // the modifiers type is T. Otherwise, the modifiers type is unknown.
                const declaredType = getTypeFromMappedTypeNode(type.declaration) as MappedType;
                const constraint = getConstraintTypeFromMappedType(declaredType);
                const extendedConstraint = constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(constraint as TypeParameter) : constraint;
                type.modifiersType = extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((extendedConstraint as IndexType).type, type.mapper) : unknownType;
            }
        }
        return type.modifiersType;
    }

    function getMappedTypeModifiers(type: MappedType): MappedTypeModifiers {
        const declaration = type.declaration;
        return (declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly : 0) |
            (declaration.questionToken ? declaration.questionToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeOptional : MappedTypeModifiers.IncludeOptional : 0);
    }

    // Return -1, 0, or 1, where -1 means optionality is stripped (i.e. -?), 0 means optionality is unchanged, and 1 means
    // optionality is added (i.e. +?).
    function getMappedTypeOptionality(type: MappedType): number {
        const modifiers = getMappedTypeModifiers(type);
        return modifiers & MappedTypeModifiers.ExcludeOptional ? -1 : modifiers & MappedTypeModifiers.IncludeOptional ? 1 : 0;
    }

    // Return -1, 0, or 1, for stripped, unchanged, or added optionality respectively. When a homomorphic mapped type doesn't
    // modify optionality, recursively consult the optionality of the type being mapped over to see if it strips or adds optionality.
    // For intersections, return -1 or 1 when all constituents strip or add optionality, otherwise return 0.
    function getCombinedMappedTypeOptionality(type: Type): number {
        if (getObjectFlags(type) & ObjectFlags.Mapped) {
            return getMappedTypeOptionality(type as MappedType) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type as MappedType));
        }
        if (type.flags & TypeFlags.Intersection) {
            const optionality = getCombinedMappedTypeOptionality((type as IntersectionType).types[0]);
            return every((type as IntersectionType).types, (t, i) => i === 0 || getCombinedMappedTypeOptionality(t) === optionality) ? optionality : 0;
        }
        return 0;
    }

    function isPartialMappedType(type: Type) {
        return !!(getObjectFlags(type) & ObjectFlags.Mapped && getMappedTypeModifiers(type as MappedType) & MappedTypeModifiers.IncludeOptional);
    }

    function isGenericMappedType(type: Type): type is MappedType {
        if (getObjectFlags(type) & ObjectFlags.Mapped) {
            const constraint = getConstraintTypeFromMappedType(type as MappedType);
            if (isGenericIndexType(constraint)) {
                return true;
            }
            // A mapped type is generic if the 'as' clause references generic types other than the iteration type.
            // To determine this, we substitute the constraint type (that we now know isn't generic) for the iteration
            // type and check whether the resulting type is generic.
            const nameType = getNameTypeFromMappedType(type as MappedType);
            if (nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type as MappedType), constraint)))) {
                return true;
            }
        }
        return false;
    }

    function getMappedTypeNameTypeKind(type: MappedType): MappedTypeNameTypeKind {
        const nameType = getNameTypeFromMappedType(type);
        if (!nameType) {
            return MappedTypeNameTypeKind.None;
        }
        return isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type)) ? MappedTypeNameTypeKind.Filtering : MappedTypeNameTypeKind.Remapping;
    }

    function resolveStructuredTypeMembers(type: StructuredType): ResolvedType {
        if (!(type as ResolvedType).members) {
            if (type.flags & TypeFlags.Object) {
                if ((type as ObjectType).objectFlags & ObjectFlags.Reference) {
                    resolveTypeReferenceMembers(type as TypeReference);
                }
                else if ((type as ObjectType).objectFlags & ObjectFlags.ClassOrInterface) {
                    resolveClassOrInterfaceMembers(type as InterfaceType);
                }
                else if ((type as ReverseMappedType).objectFlags & ObjectFlags.ReverseMapped) {
                    resolveReverseMappedTypeMembers(type as ReverseMappedType);
                }
                else if ((type as ObjectType).objectFlags & ObjectFlags.Anonymous) {
                    resolveAnonymousTypeMembers(type as AnonymousType);
                }
                else if ((type as MappedType).objectFlags & ObjectFlags.Mapped) {
                    resolveMappedTypeMembers(type as MappedType);
                }
                else {
                    Debug.fail("Unhandled object type " + Debug.formatObjectFlags(type.objectFlags));
                }
            }
            else if (type.flags & TypeFlags.Union) {
                resolveUnionTypeMembers(type as UnionType);
            }
            else if (type.flags & TypeFlags.Intersection) {
                resolveIntersectionTypeMembers(type as IntersectionType);
            }
            else {
                Debug.fail("Unhandled type " + Debug.formatTypeFlags(type.flags));
            }
        }
        return type as ResolvedType;
    }

    /** Return properties of an object type or an empty array for other types */
    function getPropertiesOfObjectType(type: Type): Symbol[] {
        if (type.flags & TypeFlags.Object) {
            return resolveStructuredTypeMembers(type as ObjectType).properties;
        }
        return emptyArray;
    }

    /** If the given type is an object type and that type has a property by the given name,
     * return the symbol for that property. Otherwise return undefined.
     */
    function getPropertyOfObjectType(type: Type, name: __String): Symbol | undefined {
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            const symbol = resolved.members.get(name);
            if (symbol && symbolIsValue(symbol)) {
                return symbol;
            }
        }
    }

    function getPropertiesOfUnionOrIntersectionType(type: UnionOrIntersectionType): Symbol[] {
        if (!type.resolvedProperties) {
            const members = createSymbolTable();
            for (const current of type.types) {
                for (const prop of getPropertiesOfType(current)) {
                    if (!members.has(prop.escapedName)) {
                        const combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName, /*skipObjectFunctionPropertyAugment*/ !!(type.flags & TypeFlags.Intersection));
                        if (combinedProp) {
                            members.set(prop.escapedName, combinedProp);
                        }
                    }
                }
                // The properties of a union type are those that are present in all constituent types, so
                // we only need to check the properties of the first type without index signature
                if (type.flags & TypeFlags.Union && getIndexInfosOfType(current).length === 0) {
                    break;
                }
            }
            type.resolvedProperties = getNamedMembers(members);
        }
        return type.resolvedProperties;
    }

    function getPropertiesOfType(type: Type): Symbol[] {
        type = getReducedApparentType(type);
        return type.flags & TypeFlags.UnionOrIntersection ?
            getPropertiesOfUnionOrIntersectionType(type as UnionType) :
            getPropertiesOfObjectType(type);
    }

    function forEachPropertyOfType(type: Type, action: (symbol: Symbol, escapedName: __String) => void): void {
        type = getReducedApparentType(type);
        if (type.flags & TypeFlags.StructuredType) {
            resolveStructuredTypeMembers(type as StructuredType).members.forEach((symbol, escapedName) => {
                if (isNamedMember(symbol, escapedName)) {
                    action(symbol, escapedName);
                }
            });
        }
    }

    function isTypeInvalidDueToUnionDiscriminant(contextualType: Type, obj: ObjectLiteralExpression | JsxAttributes): boolean {
        const list = obj.properties as NodeArray<ObjectLiteralElementLike | JsxAttributeLike>;
        return list.some(property => {
            const nameType = property.name && (isJsxNamespacedName(property.name) ? getStringLiteralType(getTextOfJsxAttributeName(property.name)) : getLiteralTypeFromPropertyName(property.name));
            const name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
            const expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);
            return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
        });
    }

    function getAllPossiblePropertiesOfTypes(types: readonly Type[]): Symbol[] {
        const unionType = getUnionType(types);
        if (!(unionType.flags & TypeFlags.Union)) {
            return getAugmentedPropertiesOfType(unionType);
        }

        const props = createSymbolTable();
        for (const memberType of types) {
            for (const { escapedName } of getAugmentedPropertiesOfType(memberType)) {
                if (!props.has(escapedName)) {
                    const prop = createUnionOrIntersectionProperty(unionType as UnionType, escapedName);
                    // May be undefined if the property is private
                    if (prop) props.set(escapedName, prop);
                }
            }
        }
        return arrayFrom(props.values());
    }

    function getConstraintOfType(type: InstantiableType | UnionOrIntersectionType): Type | undefined {
        return type.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(type as TypeParameter) :
            type.flags & TypeFlags.IndexedAccess ? getConstraintOfIndexedAccess(type as IndexedAccessType) :
            type.flags & TypeFlags.Conditional ? getConstraintOfConditionalType(type as ConditionalType) :
            getBaseConstraintOfType(type);
    }

    function getConstraintOfTypeParameter(typeParameter: TypeParameter): Type | undefined {
        return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
    }

    function isConstMappedType(type: MappedType, depth: number): boolean {
        const typeVariable = getHomomorphicTypeVariable(type);
        return !!typeVariable && isConstTypeVariable(typeVariable, depth);
    }

    function isConstTypeVariable(type: Type | undefined, depth = 0): boolean {
        return depth < 5 && !!(type && (
            type.flags & TypeFlags.TypeParameter && some((type as TypeParameter).symbol?.declarations, d => hasSyntacticModifier(d, ModifierFlags.Const)) ||
            type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, t => isConstTypeVariable(t, depth)) ||
            type.flags & TypeFlags.IndexedAccess && isConstTypeVariable((type as IndexedAccessType).objectType, depth + 1) ||
            type.flags & TypeFlags.Conditional && isConstTypeVariable(getConstraintOfConditionalType(type as ConditionalType), depth + 1) ||
            type.flags & TypeFlags.Substitution && isConstTypeVariable((type as SubstitutionType).baseType, depth) ||
            getObjectFlags(type) & ObjectFlags.Mapped && isConstMappedType(type as MappedType, depth) ||
            isGenericTupleType(type) && findIndex(getElementTypes(type), (t, i) => !!(type.target.elementFlags[i] & ElementFlags.Variadic) && isConstTypeVariable(t, depth)) >= 0
        ));
    }

    function getConstraintOfIndexedAccess(type: IndexedAccessType) {
        return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined;
    }

    function getSimplifiedTypeOrConstraint(type: Type) {
        const simplified = getSimplifiedType(type, /*writing*/ false);
        return simplified !== type ? simplified : getConstraintOfType(type);
    }

    function getConstraintFromIndexedAccess(type: IndexedAccessType) {
        if (isMappedTypeGenericIndexedAccess(type)) {
            // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
            // we substitute an instantiation of E where P is replaced with X.
            return substituteIndexedMappedType(type.objectType as MappedType, type.indexType);
        }
        const indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
        if (indexConstraint && indexConstraint !== type.indexType) {
            const indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint, type.accessFlags);
            if (indexedAccess) {
                return indexedAccess;
            }
        }
        const objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
        if (objectConstraint && objectConstraint !== type.objectType) {
            return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType, type.accessFlags);
        }
        return undefined;
    }

    function getDefaultConstraintOfConditionalType(type: ConditionalType) {
        if (!type.resolvedDefaultConstraint) {
            // An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
            // a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
            // just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
            // in effect treating `any` like `never` rather than `unknown` in this location.
            const trueConstraint = getInferredTrueTypeFromConditionalType(type);
            const falseConstraint = getFalseTypeFromConditionalType(type);
            type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
        }
        return type.resolvedDefaultConstraint;
    }

    function getConstraintOfDistributiveConditionalType(type: ConditionalType): Type | undefined {
        if (type.resolvedConstraintOfDistributive !== undefined) {
            return type.resolvedConstraintOfDistributive || undefined;
        }

        // Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
        // type parameter. If so, create an instantiation of the conditional type where T is replaced
        // with its constraint. We do this because if the constraint is a union type it will be distributed
        // over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
        // removes 'undefined' from T.
        // We skip returning a distributive constraint for a restrictive instantiation of a conditional type
        // as the constraint for all type params (check type included) have been replace with `unknown`, which
        // is going to produce even more false positive/negative results than the distribute constraint already does.
        // Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
        // a union - once negated types exist and are applied to the conditional false branch, this "constraint"
        // likely doesn't need to exist.
        if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
            const simplified = getSimplifiedType(type.checkType, /*writing*/ false);
            const constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
            if (constraint && constraint !== type.checkType) {
                const instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper), /*forConstraint*/ true);
                if (!(instantiated.flags & TypeFlags.Never)) {
                    type.resolvedConstraintOfDistributive = instantiated;
                    return instantiated;
                }
            }
        }
        type.resolvedConstraintOfDistributive = false;
        return undefined;
    }

    function getConstraintFromConditionalType(type: ConditionalType) {
        return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
    }

    function getConstraintOfConditionalType(type: ConditionalType) {
        return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined;
    }

    function getEffectiveConstraintOfIntersection(types: readonly Type[], targetIsUnion: boolean) {
        let constraints: Type[] | undefined;
        let hasDisjointDomainType = false;
        for (const t of types) {
            if (t.flags & TypeFlags.Instantiable) {
                // We keep following constraints as long as we have an instantiable type that is known
                // not to be circular or infinite (hence we stop on index access types).
                let constraint = getConstraintOfType(t);
                while (constraint && constraint.flags & (TypeFlags.TypeParameter | TypeFlags.Index | TypeFlags.Conditional)) {
                    constraint = getConstraintOfType(constraint);
                }
                if (constraint) {
                    constraints = append(constraints, constraint);
                    if (targetIsUnion) {
                        constraints = append(constraints, t);
                    }
                }
            }
            else if (t.flags & TypeFlags.DisjointDomains || isEmptyAnonymousObjectType(t)) {
                hasDisjointDomainType = true;
            }
        }
        // If the target is a union type or if we are intersecting with types belonging to one of the
        // disjoint domains, we may end up producing a constraint that hasn't been examined before.
        if (constraints && (targetIsUnion || hasDisjointDomainType)) {
            if (hasDisjointDomainType) {
                // We add any types belong to one of the disjoint domains because they might cause the final
                // intersection operation to reduce the union constraints.
                for (const t of types) {
                    if (t.flags & TypeFlags.DisjointDomains || isEmptyAnonymousObjectType(t)) {
                        constraints = append(constraints, t);
                    }
                }
            }
            // The source types were normalized; ensure the result is normalized too.
            return getNormalizedType(getIntersectionType(constraints, IntersectionFlags.NoConstraintReduction), /*writing*/ false);
        }
        return undefined;
    }

    function getBaseConstraintOfType(type: Type): Type | undefined {
        if (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) || isGenericTupleType(type)) {
            const constraint = getResolvedBaseConstraint(type as InstantiableType | UnionOrIntersectionType);
            return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;
        }
        return type.flags & TypeFlags.Index ? stringNumberSymbolType : undefined;
    }

    /**
     * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
     * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
     */
    function getBaseConstraintOrType(type: Type) {
        return getBaseConstraintOfType(type) || type;
    }

    function hasNonCircularBaseConstraint(type: InstantiableType): boolean {
        return getResolvedBaseConstraint(type) !== circularConstraintType;
    }

    /**
     * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
     * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
     * circularly references the type variable.
     */
    function getResolvedBaseConstraint(type: InstantiableType | UnionOrIntersectionType): Type {
        if (type.resolvedBaseConstraint) {
            return type.resolvedBaseConstraint;
        }
        const stack: object[] = [];
        return type.resolvedBaseConstraint = getImmediateBaseConstraint(type);

        function getImmediateBaseConstraint(t: Type): Type {
            if (!t.immediateBaseConstraint) {
                if (!pushTypeResolution(t, TypeSystemPropertyName.ImmediateBaseConstraint)) {
                    return circularConstraintType;
                }
                let result;
                // We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
                // up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
                // (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
                // levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
                // yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
                // nesting, so it is effectively just a safety stop.
                const identity = getRecursionIdentity(t);
                if (stack.length < 10 || stack.length < 50 && !contains(stack, identity)) {
                    stack.push(identity);
                    result = computeBaseConstraint(getSimplifiedType(t, /*writing*/ false));
                    stack.pop();
                }
                if (!popTypeResolution()) {
                    if (t.flags & TypeFlags.TypeParameter) {
                        const errorNode = getConstraintDeclaration(t as TypeParameter);
                        if (errorNode) {
                            const diagnostic = error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                            if (currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode)) {
                                addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location));
                            }
                        }
                    }
                    result = circularConstraintType;
                }
                t.immediateBaseConstraint ??= result || noConstraintType;
            }
            return t.immediateBaseConstraint;
        }

        function getBaseConstraint(t: Type): Type | undefined {
            const c = getImmediateBaseConstraint(t);
            return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
        }

        function computeBaseConstraint(t: Type): Type | undefined {
            if (t.flags & TypeFlags.TypeParameter) {
                const constraint = getConstraintFromTypeParameter(t as TypeParameter);
                return (t as TypeParameter).isThisType || !constraint ?
                    constraint :
                    getBaseConstraint(constraint);
            }
            if (t.flags & TypeFlags.UnionOrIntersection) {
                const types = (t as UnionOrIntersectionType).types;
                const baseTypes: Type[] = [];
                let different = false;
                for (const type of types) {
                    const baseType = getBaseConstraint(type);
                    if (baseType) {
                        if (baseType !== type) {
                            different = true;
                        }
                        baseTypes.push(baseType);
                    }
                    else {
                        different = true;
                    }
                }
                if (!different) {
                    return t;
                }
                return t.flags & TypeFlags.Union && baseTypes.length === types.length ? getUnionType(baseTypes) :
                    t.flags & TypeFlags.Intersection && baseTypes.length ? getIntersectionType(baseTypes) :
                    undefined;
            }
            if (t.flags & TypeFlags.Index) {
                return stringNumberSymbolType;
            }
            if (t.flags & TypeFlags.TemplateLiteral) {
                const types = (t as TemplateLiteralType).types;
                const constraints = mapDefined(types, getBaseConstraint);
                return constraints.length === types.length ? getTemplateLiteralType((t as TemplateLiteralType).texts, constraints) : stringType;
            }
            if (t.flags & TypeFlags.StringMapping) {
                const constraint = getBaseConstraint((t as StringMappingType).type);
                return constraint && constraint !== (t as StringMappingType).type ? getStringMappingType((t as StringMappingType).symbol, constraint) : stringType;
            }
            if (t.flags & TypeFlags.IndexedAccess) {
                if (isMappedTypeGenericIndexedAccess(t)) {
                    // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
                    // we substitute an instantiation of E where P is replaced with X.
                    return getBaseConstraint(substituteIndexedMappedType((t as IndexedAccessType).objectType as MappedType, (t as IndexedAccessType).indexType));
                }
                const baseObjectType = getBaseConstraint((t as IndexedAccessType).objectType);
                const baseIndexType = getBaseConstraint((t as IndexedAccessType).indexType);
                const baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t as IndexedAccessType).accessFlags);
                return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
            }
            if (t.flags & TypeFlags.Conditional) {
                const constraint = getConstraintFromConditionalType(t as ConditionalType);
                return constraint && getBaseConstraint(constraint);
            }
            if (t.flags & TypeFlags.Substitution) {
                return getBaseConstraint(getSubstitutionIntersection(t as SubstitutionType));
            }
            if (isGenericTupleType(t)) {
                // We substitute constraints for variadic elements only when the constraints are array types or
                // non-variadic tuple types as we want to avoid further (possibly unbounded) recursion.
                const newElements = map(getElementTypes(t), (v, i) => {
                    const constraint = v.flags & TypeFlags.TypeParameter && t.target.elementFlags[i] & ElementFlags.Variadic && getBaseConstraint(v) || v;
                    return constraint !== v && everyType(constraint, c => isArrayOrTupleType(c) && !isGenericTupleType(c)) ? constraint : v;
                });
                return createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations);
            }
            return t;
        }
    }

    function getApparentTypeOfIntersectionType(type: IntersectionType, thisArgument: Type) {
        if (type === thisArgument) {
            return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType*/ true));
        }
        const key = `I${getTypeId(type)},${getTypeId(thisArgument)}`;
        return getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType*/ true));
    }

    function getResolvedTypeParameterDefault(typeParameter: TypeParameter): Type | undefined {
        if (!typeParameter.default) {
            if (typeParameter.target) {
                const targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
            }
            else {
                // To block recursion, set the initial value to the resolvingDefaultType.
                typeParameter.default = resolvingDefaultType;
                const defaultDeclaration = typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default);
                const defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                if (typeParameter.default === resolvingDefaultType) {
                    // If we have not been called recursively, set the correct default type.
                    typeParameter.default = defaultType;
                }
            }
        }
        else if (typeParameter.default === resolvingDefaultType) {
            // If we are called recursively for this type parameter, mark the default as circular.
            typeParameter.default = circularConstraintType;
        }
        return typeParameter.default;
    }

    /**
     * Gets the default type for a type parameter.
     *
     * If the type parameter is the result of an instantiation, this gets the instantiated
     * default type of its target. If the type parameter has no default type or the default is
     * circular, `undefined` is returned.
     */
    function getDefaultFromTypeParameter(typeParameter: TypeParameter): Type | undefined {
        const defaultType = getResolvedTypeParameterDefault(typeParameter);
        return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
    }

    function hasNonCircularTypeParameterDefault(typeParameter: TypeParameter) {
        return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
    }

    /**
     * Indicates whether the declaration of a typeParameter has a default type.
     */
    function hasTypeParameterDefault(typeParameter: TypeParameter): boolean {
        return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default));
    }

    function getApparentTypeOfMappedType(type: MappedType) {
        return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
    }

    function getResolvedApparentTypeOfMappedType(type: MappedType): Type {
        const target = (type.target ?? type) as MappedType;
        const typeVariable = getHomomorphicTypeVariable(target);
        if (typeVariable && !target.declaration.nameType) {
            // We have a homomorphic mapped type or an instantiation of a homomorphic mapped type, i.e. a type
            // of the form { [P in keyof T]: X }. Obtain the modifiers type (the T of the keyof T), and if it is
            // another generic mapped type, recursively obtain its apparent type. Otherwise, obtain its base
            // constraint. Then, if every constituent of the base constraint is an array or tuple type, apply
            // this mapped type to the base constraint. It is safe to recurse when the modifiers type is a
            // mapped type because we protect again circular constraints in getTypeFromMappedTypeNode.
            const modifiersType = getModifiersTypeFromMappedType(type);
            const baseConstraint = isGenericMappedType(modifiersType) ? getApparentTypeOfMappedType(modifiersType) : getBaseConstraintOfType(modifiersType);
            if (baseConstraint && everyType(baseConstraint, t => isArrayOrTupleType(t) || isArrayOrTupleOrIntersection(t))) {
                return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, type.mapper));
            }
        }
        return type;
    }

    function isArrayOrTupleOrIntersection(type: Type) {
        return !!(type.flags & TypeFlags.Intersection) && every((type as IntersectionType).types, isArrayOrTupleType);
    }

    function isMappedTypeGenericIndexedAccess(type: Type) {
        let objectType;
        return !!(type.flags & TypeFlags.IndexedAccess && getObjectFlags(objectType = (type as IndexedAccessType).objectType) & ObjectFlags.Mapped &&
            !isGenericMappedType(objectType) && isGenericIndexType((type as IndexedAccessType).indexType) &&
            !(getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.ExcludeOptional) && !(objectType as MappedType).declaration.nameType);
    }

    /**
     * For a type parameter, return the base constraint of the type parameter. For the string, number,
     * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
     * type itself.
     */
    function getApparentType(type: Type): Type {
        const t = type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type;
        const objectFlags = getObjectFlags(t);
        return objectFlags & ObjectFlags.Mapped ? getApparentTypeOfMappedType(t as MappedType) :
            objectFlags & ObjectFlags.Reference && t !== type ? getTypeWithThisArgument(t, type) :
            t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(t as IntersectionType, type) :
            t.flags & TypeFlags.StringLike ? globalStringType :
            t.flags & TypeFlags.NumberLike ? globalNumberType :
            t.flags & TypeFlags.BigIntLike ? getGlobalBigIntType() :
            t.flags & TypeFlags.BooleanLike ? globalBooleanType :
            t.flags & TypeFlags.ESSymbolLike ? getGlobalESSymbolType() :
            t.flags & TypeFlags.NonPrimitive ? emptyObjectType :
            t.flags & TypeFlags.Index ? stringNumberSymbolType :
            t.flags & TypeFlags.Unknown && !strictNullChecks ? emptyObjectType :
            t;
    }

    function getReducedApparentType(type: Type): Type {
        // Since getApparentType may return a non-reduced union or intersection type, we need to perform
        // type reduction both before and after obtaining the apparent type. For example, given a type parameter
        // 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
        // that type may need further reduction to remove empty intersections.
        return getReducedType(getApparentType(getReducedType(type)));
    }

    function createUnionOrIntersectionProperty(containingType: UnionOrIntersectionType, name: __String, skipObjectFunctionPropertyAugment?: boolean): Symbol | undefined {
        let singleProp: Symbol | undefined;
        let propSet: Map<SymbolId, Symbol> | undefined;
        let indexTypes: Type[] | undefined;
        const isUnion = containingType.flags & TypeFlags.Union;
        // Flags we want to propagate to the result if they exist in all source symbols
        let optionalFlag: SymbolFlags | undefined;
        let syntheticFlag = CheckFlags.SyntheticMethod;
        let checkFlags = isUnion ? 0 : CheckFlags.Readonly;
        let mergedInstantiations = false;
        for (const current of containingType.types) {
            const type = getApparentType(current);
            if (!(isErrorType(type) || type.flags & TypeFlags.Never)) {
                const prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
                const modifiers = prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0;
                if (prop) {
                    if (prop.flags & SymbolFlags.ClassMember) {
                        optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional;
                        if (isUnion) {
                            optionalFlag |= prop.flags & SymbolFlags.Optional;
                        }
                        else {
                            optionalFlag &= prop.flags;
                        }
                    }
                    if (!singleProp) {
                        singleProp = prop;
                    }
                    else if (prop !== singleProp) {
                        const isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
                        // If the symbols are instances of one another with identical types - consider the symbols
                        // equivalent and just use the first one, which thus allows us to avoid eliding private
                        // members when intersecting a (this-)instantiations of a class with its raw base or another instance
                        if (isInstantiation && compareProperties(singleProp, prop, (a, b) => a === b ? Ternary.True : Ternary.False) === Ternary.True) {
                            // If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
                            // to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
                            // back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
                            mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                        }
                        else {
                            if (!propSet) {
                                propSet = new Map<SymbolId, Symbol>();
                                propSet.set(getSymbolId(singleProp), singleProp);
                            }
                            const id = getSymbolId(prop);
                            if (!propSet.has(id)) {
                                propSet.set(id, prop);
                            }
                        }
                    }
                    if (isUnion && isReadonlySymbol(prop)) {
                        checkFlags |= CheckFlags.Readonly;
                    }
                    else if (!isUnion && !isReadonlySymbol(prop)) {
                        checkFlags &= ~CheckFlags.Readonly;
                    }
                    checkFlags |= (!(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0) |
                        (modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0) |
                        (modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0) |
                        (modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0);
                    if (!isPrototypeProperty(prop)) {
                        syntheticFlag = CheckFlags.SyntheticProperty;
                    }
                }
                else if (isUnion) {
                    const indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
                    if (indexInfo) {
                        checkFlags |= CheckFlags.WritePartial | (indexInfo.isReadonly ? CheckFlags.Readonly : 0);
                        indexTypes = append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
                    }
                    else if (isObjectLiteralType(type) && !(getObjectFlags(type) & ObjectFlags.ContainsSpread)) {
                        checkFlags |= CheckFlags.WritePartial;
                        indexTypes = append(indexTypes, undefinedType);
                    }
                    else {
                        checkFlags |= CheckFlags.ReadPartial;
                    }
                }
            }
        }
        if (
            !singleProp ||
            isUnion &&
                (propSet || checkFlags & CheckFlags.Partial) &&
                checkFlags & (CheckFlags.ContainsPrivate | CheckFlags.ContainsProtected) &&
                !(propSet && getCommonDeclarationsOfSymbols(propSet.values()))
        ) {
            // No property was found, or, in a union, a property has a private or protected declaration in one
            // constituent, but is missing or has a different declaration in another constituent.
            return undefined;
        }
        if (!propSet && !(checkFlags & CheckFlags.ReadPartial) && !indexTypes) {
            if (mergedInstantiations) {
                // No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
                // Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
                // They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
                const links = tryCast(singleProp, isTransientSymbol)?.links;
                const clone = createSymbolWithType(singleProp, links?.type);
                clone.parent = singleProp.valueDeclaration?.symbol?.parent;
                clone.links.containingType = containingType;
                clone.links.mapper = links?.mapper;
                clone.links.writeType = getWriteTypeOfSymbol(singleProp);
                return clone;
            }
            else {
                return singleProp;
            }
        }
        const props = propSet ? arrayFrom(propSet.values()) : [singleProp];
        let declarations: Declaration[] | undefined;
        let firstType: Type | undefined;
        let nameType: Type | undefined;
        const propTypes: Type[] = [];
        let writeTypes: Type[] | undefined;
        let firstValueDeclaration: Declaration | undefined;
        let hasNonUniformValueDeclaration = false;
        for (const prop of props) {
            if (!firstValueDeclaration) {
                firstValueDeclaration = prop.valueDeclaration;
            }
            else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
                hasNonUniformValueDeclaration = true;
            }
            declarations = addRange(declarations, prop.declarations);
            const type = getTypeOfSymbol(prop);
            if (!firstType) {
                firstType = type;
                nameType = getSymbolLinks(prop).nameType;
            }
            const writeType = getWriteTypeOfSymbol(prop);
            if (writeTypes || writeType !== type) {
                writeTypes = append(!writeTypes ? propTypes.slice() : writeTypes, writeType);
            }
            if (type !== firstType) {
                checkFlags |= CheckFlags.HasNonUniformType;
            }
            if (isLiteralType(type) || isPatternLiteralType(type)) {
                checkFlags |= CheckFlags.HasLiteralType;
            }
            if (type.flags & TypeFlags.Never && type !== uniqueLiteralType) {
                checkFlags |= CheckFlags.HasNeverType;
            }
            propTypes.push(type);
        }
        addRange(propTypes, indexTypes);
        const result = createSymbol(SymbolFlags.Property | (optionalFlag ?? 0), name, syntheticFlag | checkFlags);
        result.links.containingType = containingType;
        if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
            result.valueDeclaration = firstValueDeclaration;

            // Inherit information about parent type.
            if (firstValueDeclaration.symbol.parent) {
                result.parent = firstValueDeclaration.symbol.parent;
            }
        }

        result.declarations = declarations;
        result.links.nameType = nameType;
        if (propTypes.length > 2) {
            // When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
            result.links.checkFlags |= CheckFlags.DeferredType;
            result.links.deferralParent = containingType;
            result.links.deferralConstituents = propTypes;
            result.links.deferralWriteConstituents = writeTypes;
        }
        else {
            result.links.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
            if (writeTypes) {
                result.links.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes);
            }
        }
        return result;
    }

    // Return the symbol for a given property in a union or intersection type, or undefined if the property
    // does not exist in any constituent type. Note that the returned property may only be present in some
    // constituents, in which case the isPartial flag is set when the containing type is union type. We need
    // these partial properties when identifying discriminant properties, but otherwise they are filtered out
    // and do not appear to be present in the union type.
    function getUnionOrIntersectionProperty(type: UnionOrIntersectionType, name: __String, skipObjectFunctionPropertyAugment?: boolean): Symbol | undefined {
        let property = skipObjectFunctionPropertyAugment ?
            type.propertyCacheWithoutObjectFunctionPropertyAugment?.get(name) :
            type.propertyCache?.get(name);
        if (!property) {
            property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
            if (property) {
                const properties = skipObjectFunctionPropertyAugment ?
                    type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() :
                    type.propertyCache ||= createSymbolTable();
                properties.set(name, property);
                // Propagate an entry from the non-augmented cache to the augmented cache unless the property is partial.
                if (skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlags.Partial) && !type.propertyCache?.get(name)) {
                    const properties = type.propertyCache ||= createSymbolTable();
                    properties.set(name, property);
                }
            }
        }
        return property;
    }

    function getCommonDeclarationsOfSymbols(symbols: Iterable<Symbol>) {
        let commonDeclarations: Set<Node> | undefined;
        for (const symbol of symbols) {
            if (!symbol.declarations) {
                return undefined;
            }
            if (!commonDeclarations) {
                commonDeclarations = new Set(symbol.declarations);
                continue;
            }
            commonDeclarations.forEach(declaration => {
                if (!contains(symbol.declarations, declaration)) {
                    commonDeclarations!.delete(declaration);
                }
            });
            if (commonDeclarations.size === 0) {
                return undefined;
            }
        }
        return commonDeclarations;
    }

    function getPropertyOfUnionOrIntersectionType(type: UnionOrIntersectionType, name: __String, skipObjectFunctionPropertyAugment?: boolean): Symbol | undefined {
        const property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
        // We need to filter out partial properties in union types
        return property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined;
    }

    /**
     * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
     * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
     * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
     * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
     */
    function getReducedType(type: Type): Type {
        if (type.flags & TypeFlags.Union && (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections) {
            return (type as UnionType).resolvedReducedType || ((type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType));
        }
        else if (type.flags & TypeFlags.Intersection) {
            if (!((type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersectionComputed)) {
                (type as IntersectionType).objectFlags |= ObjectFlags.IsNeverIntersectionComputed |
                    (some(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0);
            }
            return (type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type;
        }
        return type;
    }

    function getReducedUnionType(unionType: UnionType) {
        const reducedTypes = sameMap(unionType.types, getReducedType);
        if (reducedTypes === unionType.types) {
            return unionType;
        }
        const reduced = getUnionType(reducedTypes);
        if (reduced.flags & TypeFlags.Union) {
            (reduced as UnionType).resolvedReducedType = reduced;
        }
        return reduced;
    }

    function isNeverReducedProperty(prop: Symbol) {
        return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
    }

    function isDiscriminantWithNeverType(prop: Symbol) {
        // Return true for a synthetic non-optional property with non-uniform types, where at least one is
        // a literal type and none is never, that reduces to never.
        return !(prop.flags & SymbolFlags.Optional) &&
            (getCheckFlags(prop) & (CheckFlags.Discriminant | CheckFlags.HasNeverType)) === CheckFlags.Discriminant &&
            !!(getTypeOfSymbol(prop).flags & TypeFlags.Never);
    }

    function isConflictingPrivateProperty(prop: Symbol) {
        // Return true for a synthetic property with multiple declarations, at least one of which is private.
        return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlags.ContainsPrivate);
    }

    /**
     * A union type which is reducible upon instantiation (meaning some members are removed under certain instantiations)
     * must be kept generic, as that instantiation information needs to flow through the type system. By replacing all
     * type parameters in the union with a special never type that is treated as a literal in `getReducedType`, we can cause
     * the `getReducedType` logic to reduce the resulting type if possible (since only intersections with conflicting
     * literal-typed properties are reducible).
     */
    function isGenericReducibleType(type: Type): boolean {
        return !!(type.flags & TypeFlags.Union && (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections && some((type as UnionType).types, isGenericReducibleType) ||
            type.flags & TypeFlags.Intersection && isReducibleIntersection(type as IntersectionType));
    }

    function isReducibleIntersection(type: IntersectionType) {
        const uniqueFilled = type.uniqueLiteralFilledInstantiation || (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper));
        return getReducedType(uniqueFilled) !== uniqueFilled;
    }

    function elaborateNeverIntersection(errorInfo: DiagnosticMessageChain | undefined, type: Type) {
        if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsNeverIntersection) {
            const neverProp = find(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isDiscriminantWithNeverType);
            if (neverProp) {
                return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.NoTypeReduction), symbolToString(neverProp));
            }
            const privateProp = find(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isConflictingPrivateProperty);
            if (privateProp) {
                return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.NoTypeReduction), symbolToString(privateProp));
            }
        }
        return errorInfo;
    }

    /**
     * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
     * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
     * Object and Function as appropriate.
     *
     * @param type a type to look up property from
     * @param name a name of property to look up in a given type
     */
    function getPropertyOfType(type: Type, name: __String, skipObjectFunctionPropertyAugment?: boolean, includeTypeOnlyMembers?: boolean): Symbol | undefined {
        type = getReducedApparentType(type);
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            const symbol = resolved.members.get(name);
            if (symbol && !includeTypeOnlyMembers && type.symbol?.flags & SymbolFlags.ValueModule && getSymbolLinks(type.symbol).typeOnlyExportStarMap?.has(name)) {
                // If this is the type of a module, `resolved.members.get(name)` might have effectively skipped over
                // an `export type * from './foo'`, leaving `symbolIsValue` unable to see that the symbol is being
                // viewed through a type-only export.
                return undefined;
            }
            if (symbol && symbolIsValue(symbol, includeTypeOnlyMembers)) {
                return symbol;
            }
            if (skipObjectFunctionPropertyAugment) return undefined;
            const functionType = resolved === anyFunctionType ? globalFunctionType :
                resolved.callSignatures.length ? globalCallableFunctionType :
                resolved.constructSignatures.length ? globalNewableFunctionType :
                undefined;
            if (functionType) {
                const symbol = getPropertyOfObjectType(functionType, name);
                if (symbol) {
                    return symbol;
                }
            }
            return getPropertyOfObjectType(globalObjectType, name);
        }
        if (type.flags & TypeFlags.Intersection) {
            const prop = getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name, /*skipObjectFunctionPropertyAugment*/ true);
            if (prop) {
                return prop;
            }
            if (!skipObjectFunctionPropertyAugment) {
                return getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name, skipObjectFunctionPropertyAugment);
            }
            return undefined;
        }
        if (type.flags & TypeFlags.Union) {
            return getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name, skipObjectFunctionPropertyAugment);
        }
        return undefined;
    }

    function getSignaturesOfStructuredType(type: Type, kind: SignatureKind): readonly Signature[] {
        if (type.flags & TypeFlags.StructuredType) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            return kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures;
        }
        return emptyArray;
    }

    /**
     * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
     * maps primitive types and type parameters are to their apparent types.
     */
    function getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[] {
        const result = getSignaturesOfStructuredType(getReducedApparentType(type), kind);
        if (kind === SignatureKind.Call && !length(result) && type.flags & TypeFlags.Union) {
            if ((type as UnionType).arrayFallbackSignatures) {
                return (type as UnionType).arrayFallbackSignatures!;
            }
            // If the union is all different instantiations of a member of the global array type...
            let memberName: __String;
            if (everyType(type, t => !!t.symbol?.parent && isArrayOrTupleSymbol(t.symbol.parent) && (!memberName ? (memberName = t.symbol.escapedName, true) : memberName === t.symbol.escapedName))) {
                // Transform the type from `(A[] | B[])["member"]` to `(A | B)[]["member"]` (since we pretend array is covariant anyway)
                const arrayArg = mapType(type, t => getMappedType((isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType).typeParameters![0], (t as AnonymousType).mapper!));
                const arrayType = createArrayType(arrayArg, someType(type, t => isReadonlyArraySymbol(t.symbol.parent)));
                return (type as UnionType).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName!)!, kind);
            }
            (type as UnionType).arrayFallbackSignatures = result;
        }
        return result;
    }

    function isArrayOrTupleSymbol(symbol: Symbol | undefined) {
        if (!symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol) {
            return false;
        }
        return !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol);
    }

    function isReadonlyArraySymbol(symbol: Symbol | undefined) {
        if (!symbol || !globalReadonlyArrayType.symbol) {
            return false;
        }
        return !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol);
    }

    function findIndexInfo(indexInfos: readonly IndexInfo[], keyType: Type) {
        return find(indexInfos, info => info.keyType === keyType);
    }

    function findApplicableIndexInfo(indexInfos: readonly IndexInfo[], keyType: Type) {
        // Index signatures for type 'string' are considered only when no other index signatures apply.
        let stringIndexInfo: IndexInfo | undefined;
        let applicableInfo: IndexInfo | undefined;
        let applicableInfos: IndexInfo[] | undefined;
        for (const info of indexInfos) {
            if (info.keyType === stringType) {
                stringIndexInfo = info;
            }
            else if (isApplicableIndexType(keyType, info.keyType)) {
                if (!applicableInfo) {
                    applicableInfo = info;
                }
                else {
                    (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
                }
            }
        }
        // When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
        // the intersected key type, we just use unknownType for the key type as nothing actually depends on the
        // keyType property of the returned IndexInfo.
        return applicableInfos ? createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, info => info.type)), reduceLeft(applicableInfos, (isReadonly, info) => isReadonly && info.isReadonly, /*initial*/ true)) :
            applicableInfo ? applicableInfo :
            stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :
            undefined;
    }

    function isApplicableIndexType(source: Type, target: Type): boolean {
        // A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
        // signature applies to types assignable to 'number', `${number}` and numeric string literal types.
        return isTypeAssignableTo(source, target) ||
            target === stringType && isTypeAssignableTo(source, numberType) ||
            target === numberType && (source === numericStringType || !!(source.flags & TypeFlags.StringLiteral) && isNumericLiteralName((source as StringLiteralType).value));
    }

    function getIndexInfosOfStructuredType(type: Type): readonly IndexInfo[] {
        if (type.flags & TypeFlags.StructuredType) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            return resolved.indexInfos;
        }
        return emptyArray;
    }

    function getIndexInfosOfType(type: Type): readonly IndexInfo[] {
        return getIndexInfosOfStructuredType(getReducedApparentType(type));
    }

    // Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    function getIndexInfoOfType(type: Type, keyType: Type): IndexInfo | undefined {
        return findIndexInfo(getIndexInfosOfType(type), keyType);
    }

    // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    function getIndexTypeOfType(type: Type, keyType: Type): Type | undefined {
        return getIndexInfoOfType(type, keyType)?.type;
    }

    function getApplicableIndexInfos(type: Type, keyType: Type): IndexInfo[] {
        return getIndexInfosOfType(type).filter(info => isApplicableIndexType(keyType, info.keyType));
    }

    function getApplicableIndexInfo(type: Type, keyType: Type): IndexInfo | undefined {
        return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
    }

    function getApplicableIndexInfoForName(type: Type, name: __String): IndexInfo | undefined {
        return getApplicableIndexInfo(type, isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)));
    }

    // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
    // type checking functions).
    function getTypeParametersFromDeclaration(declaration: DeclarationWithTypeParameters): readonly TypeParameter[] | undefined {
        let result: TypeParameter[] | undefined;
        for (const node of getEffectiveTypeParameterDeclarations(declaration)) {
            result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
        }
        return result?.length ? result
            : isFunctionDeclaration(declaration) ? getSignatureOfTypeTag(declaration)?.typeParameters
            : undefined;
    }

    function symbolsToArray(symbols: SymbolTable): Symbol[] {
        const result: Symbol[] = [];
        symbols.forEach((symbol, id) => {
            if (!isReservedMemberName(id)) {
                result.push(symbol);
            }
        });
        return result;
    }

    function tryFindAmbientModule(moduleName: string, withAugmentations: boolean) {
        if (isExternalModuleNameRelative(moduleName)) {
            return undefined;
        }
        const symbol = getSymbol(globals, '"' + moduleName + '"' as __String, SymbolFlags.ValueModule);
        // merged symbol is module declaration symbol combined with all augmentations
        return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
    }

    function hasEffectiveQuestionToken(node: ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag) {
        return hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node);
    }

    function isOptionalParameter(node: ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag) {
        if (hasEffectiveQuestionToken(node)) {
            return true;
        }
        if (!isParameter(node)) {
            return false;
        }
        if (node.initializer) {
            const signature = getSignatureFromDeclaration(node.parent);
            const parameterIndex = node.parent.parameters.indexOf(node);
            Debug.assert(parameterIndex >= 0);
            // Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
            // in grammar checks and checking for `void` too early results in parameter types widening too early
            // and causes some noImplicitAny errors to be lost.
            return parameterIndex >= getMinArgumentCount(signature, MinArgumentCountFlags.StrongArityForUntypedJS | MinArgumentCountFlags.VoidIsNonOptional);
        }
        const iife = getImmediatelyInvokedFunctionExpression(node.parent);
        if (iife) {
            return !node.type &&
                !node.dotDotDotToken &&
                node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length;
        }

        return false;
    }

    function isOptionalPropertyDeclaration(node: Declaration) {
        return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken;
    }

    function createTypePredicate(kind: TypePredicateKind, parameterName: string | undefined, parameterIndex: number | undefined, type: Type | undefined): TypePredicate {
        return { kind, parameterName, parameterIndex, type } as TypePredicate;
    }

    /**
     * Gets the minimum number of type arguments needed to satisfy all non-optional type
     * parameters.
     */
    function getMinTypeArgumentCount(typeParameters: readonly TypeParameter[] | undefined): number {
        let minTypeArgumentCount = 0;
        if (typeParameters) {
            for (let i = 0; i < typeParameters.length; i++) {
                if (!hasTypeParameterDefault(typeParameters[i])) {
                    minTypeArgumentCount = i + 1;
                }
            }
        }
        return minTypeArgumentCount;
    }

    /**
     * Fill in default types for unsupplied type arguments. If `typeArguments` is undefined
     * when a default type is supplied, a new array will be created and returned.
     *
     * @param typeArguments The supplied type arguments.
     * @param typeParameters The requested type parameters.
     * @param minTypeArgumentCount The minimum number of required type arguments.
     */
    function fillMissingTypeArguments(typeArguments: readonly Type[], typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[];
    function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[] | undefined;
    function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean) {
        const numTypeParameters = length(typeParameters);
        if (!numTypeParameters) {
            return [];
        }
        const numTypeArguments = length(typeArguments);
        if (isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)) {
            const result = typeArguments ? typeArguments.slice() : [];
            // Map invalid forward references in default types to the error type
            for (let i = numTypeArguments; i < numTypeParameters; i++) {
                result[i] = errorType;
            }
            const baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
            for (let i = numTypeArguments; i < numTypeParameters; i++) {
                let defaultType = getDefaultFromTypeParameter(typeParameters![i]);
                if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
                    defaultType = anyType;
                }
                result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType;
            }
            result.length = typeParameters!.length;
            return result;
        }
        return typeArguments && typeArguments.slice();
    }

    function getSignatureFromDeclaration(declaration: SignatureDeclaration | JSDocSignature): Signature {
        const links = getNodeLinks(declaration);
        if (!links.resolvedSignature) {
            const parameters: Symbol[] = [];
            let flags = SignatureFlags.None;
            let minArgumentCount = 0;
            let thisParameter: Symbol | undefined;
            let thisTag: JSDocThisTag | undefined = isInJSFile(declaration) ? getJSDocThisTag(declaration) : undefined;
            let hasThisParameter = false;
            const iife = getImmediatelyInvokedFunctionExpression(declaration);
            const isJSConstructSignature = isJSDocConstructSignature(declaration);
            const isUntypedSignatureInJSFile = !iife &&
                isInJSFile(declaration) &&
                isValueSignatureDeclaration(declaration) &&
                !hasJSDocParameterTags(declaration) &&
                !some(declaration.parameters, p => !!getJSDocType(p)) &&
                !getJSDocType(declaration) &&
                !getContextualSignatureForFunctionLikeDeclaration(declaration);
            if (isUntypedSignatureInJSFile) {
                flags |= SignatureFlags.IsUntypedSignatureInJSFile;
            }

            // If this is a JSDoc construct signature, then skip the first parameter in the
            // parameter list.  The first parameter represents the return type of the construct
            // signature.
            for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
                const param = declaration.parameters[i];
                if (isInJSFile(param) && isJSDocThisTag(param)) {
                    thisTag = param;
                    continue;
                }

                let paramSymbol = param.symbol;
                const type = isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;
                // Include parameter symbol instead of property symbol in the signature
                if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !isBindingPattern(param.name)) {
                    const resolvedSymbol = resolveName(param, paramSymbol.escapedName, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
                    paramSymbol = resolvedSymbol!;
                }
                if (i === 0 && paramSymbol.escapedName === InternalSymbolName.This) {
                    hasThisParameter = true;
                    thisParameter = param.symbol;
                }
                else {
                    parameters.push(paramSymbol);
                }

                if (type && type.kind === SyntaxKind.LiteralType) {
                    flags |= SignatureFlags.HasLiteralTypes;
                }

                // Record a new minimum argument count if this is not an optional parameter
                const isOptionalParameter = hasEffectiveQuestionToken(param) ||
                    isParameter(param) && param.initializer || isRestParameter(param) ||
                    iife && parameters.length > iife.arguments.length && !type;
                if (!isOptionalParameter) {
                    minArgumentCount = parameters.length;
                }
            }

            // If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
            if (
                (declaration.kind === SyntaxKind.GetAccessor || declaration.kind === SyntaxKind.SetAccessor) &&
                hasBindableName(declaration) &&
                (!hasThisParameter || !thisParameter)
            ) {
                const otherKind = declaration.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;
                const other = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(declaration), otherKind);
                if (other) {
                    thisParameter = getAnnotatedAccessorThisParameter(other);
                }
            }

            if (thisTag && thisTag.typeExpression) {
                thisParameter = createSymbolWithType(createSymbol(SymbolFlags.FunctionScopedVariable, InternalSymbolName.This), getTypeFromTypeNode(thisTag.typeExpression));
            }

            const hostDeclaration = isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration;
            const classType = hostDeclaration && isConstructorDeclaration(hostDeclaration) ?
                getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent as ClassDeclaration).symbol))
                : undefined;
            const typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
            if (hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
                flags |= SignatureFlags.HasRestParameter;
            }
            if (
                isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlags.Abstract) ||
                isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlags.Abstract)
            ) {
                flags |= SignatureFlags.Abstract;
            }
            links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, minArgumentCount, flags);
        }
        return links.resolvedSignature;
    }

    /**
     * A JS function gets a synthetic rest parameter if it references `arguments` AND:
     * 1. It has no parameters but at least one `@param` with a type that starts with `...`
     * OR
     * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
     */
    function maybeAddJsSyntheticRestParameter(declaration: SignatureDeclaration | JSDocSignature, parameters: Symbol[]): boolean {
        if (isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
            return false;
        }
        const lastParam = lastOrUndefined(declaration.parameters);
        const lastParamTags = lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag);
        const lastParamVariadicType = firstDefined(lastParamTags, p => p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined);

        const syntheticArgsSymbol = createSymbol(SymbolFlags.Variable, "args" as __String, CheckFlags.RestParameter);
        if (lastParamVariadicType) {
            // Parameter has effective annotation, lock in type
            syntheticArgsSymbol.links.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type));
        }
        else {
            // Parameter has no annotation
            // By using a `DeferredType` symbol, we allow the type of this rest arg to be overriden by contextual type assignment so long as its type hasn't been
            // cached by `getTypeOfSymbol` yet.
            syntheticArgsSymbol.links.checkFlags |= CheckFlags.DeferredType;
            syntheticArgsSymbol.links.deferralParent = neverType;
            syntheticArgsSymbol.links.deferralConstituents = [anyArrayType];
            syntheticArgsSymbol.links.deferralWriteConstituents = [anyArrayType];
        }
        if (lastParamVariadicType) {
            // Replace the last parameter with a rest parameter.
            parameters.pop();
        }
        parameters.push(syntheticArgsSymbol);
        return true;
    }

    function getSignatureOfTypeTag(node: SignatureDeclaration | JSDocSignature) {
        // should be attached to a function declaration or expression
        if (!(isInJSFile(node) && isFunctionLikeDeclaration(node))) return undefined;
        const typeTag = getJSDocTypeTag(node);
        return typeTag?.typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
    }

    function getParameterTypeOfTypeTag(func: FunctionLikeDeclaration, parameter: ParameterDeclaration) {
        const signature = getSignatureOfTypeTag(func);
        if (!signature) return undefined;
        const pos = func.parameters.indexOf(parameter);
        return parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos);
    }

    function getReturnTypeOfTypeTag(node: SignatureDeclaration | JSDocSignature) {
        const signature = getSignatureOfTypeTag(node);
        return signature && getReturnTypeOfSignature(signature);
    }

    function containsArgumentsReference(declaration: SignatureDeclaration): boolean {
        const links = getNodeLinks(declaration);
        if (links.containsArgumentsReference === undefined) {
            if (links.flags & NodeCheckFlags.CaptureArguments) {
                links.containsArgumentsReference = true;
            }
            else {
                links.containsArgumentsReference = traverse((declaration as FunctionLikeDeclaration).body!);
            }
        }
        return links.containsArgumentsReference;

        function traverse(node: Node): boolean {
            if (!node) return false;
            switch (node.kind) {
                case SyntaxKind.Identifier:
                    return (node as Identifier).escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node as Identifier) === argumentsSymbol;

                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    return (node as NamedDeclaration).name!.kind === SyntaxKind.ComputedPropertyName
                        && traverse((node as NamedDeclaration).name!);

                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                    return traverse((node as PropertyAccessExpression | ElementAccessExpression).expression);

                case SyntaxKind.PropertyAssignment:
                    return traverse((node as PropertyAssignment).initializer);

                default:
                    return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse);
            }
        }
    }

    function getSignaturesOfSymbol(symbol: Symbol | undefined): Signature[] {
        if (!symbol || !symbol.declarations) return emptyArray;
        const result: Signature[] = [];
        for (let i = 0; i < symbol.declarations.length; i++) {
            const decl = symbol.declarations[i];
            if (!isFunctionLike(decl)) continue;
            // Don't include signature if node is the implementation of an overloaded function. A node is considered
            // an implementation node if it has a body and the previous node is of the same kind and immediately
            // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
            if (i > 0 && (decl as FunctionLikeDeclaration).body) {
                const previous = symbol.declarations[i - 1];
                if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
                    continue;
                }
            }
            if (isInJSFile(decl) && decl.jsDoc) {
                const tags = getJSDocOverloadTags(decl);
                if (length(tags)) {
                    for (const tag of tags) {
                        const jsDocSignature = tag.typeExpression;
                        if (jsDocSignature.type === undefined && !isConstructorDeclaration(decl)) {
                            reportImplicitAny(jsDocSignature, anyType);
                        }
                        result.push(getSignatureFromDeclaration(jsDocSignature));
                    }
                    continue;
                }
            }
            // If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.
            // Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.
            result.push(
                (!isFunctionExpressionOrArrowFunction(decl) &&
                    !isObjectLiteralMethod(decl) &&
                    getSignatureOfTypeTag(decl)) ||
                    getSignatureFromDeclaration(decl),
            );
        }
        return result;
    }

    function resolveExternalModuleTypeByLiteral(name: StringLiteral) {
        const moduleSym = resolveExternalModuleName(name, name);
        if (moduleSym) {
            const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
            if (resolvedModuleSymbol) {
                return getTypeOfSymbol(resolvedModuleSymbol);
            }
        }

        return anyType;
    }

    function getThisTypeOfSignature(signature: Signature): Type | undefined {
        if (signature.thisParameter) {
            return getTypeOfSymbol(signature.thisParameter);
        }
    }

    function getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined {
        if (!signature.resolvedTypePredicate) {
            if (signature.target) {
                const targetTypePredicate = getTypePredicateOfSignature(signature.target);
                signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate;
            }
            else if (signature.compositeSignatures) {
                signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
            }
            else {
                const type = signature.declaration && getEffectiveReturnTypeNode(signature.declaration);
                let jsdocPredicate: TypePredicate | undefined;
                if (!type) {
                    const jsdocSignature = getSignatureOfTypeTag(signature.declaration!);
                    if (jsdocSignature && signature !== jsdocSignature) {
                        jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                    }
                }
                if (type || jsdocPredicate) {
                    signature.resolvedTypePredicate = type && isTypePredicateNode(type) ?
                        createTypePredicateFromTypePredicateNode(type, signature) :
                        jsdocPredicate || noTypePredicate;
                }
                else if (signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags & TypeFlags.Boolean) && getParameterCount(signature) > 0) {
                    const { declaration } = signature;
                    signature.resolvedTypePredicate = noTypePredicate; // avoid infinite loop
                    signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate;
                }
                else {
                    signature.resolvedTypePredicate = noTypePredicate;
                }
            }
            Debug.assert(!!signature.resolvedTypePredicate);
        }
        return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
    }

    function createTypePredicateFromTypePredicateNode(node: TypePredicateNode, signature: Signature): TypePredicate {
        const parameterName = node.parameterName;
        const type = node.type && getTypeFromTypeNode(node.type);
        return parameterName.kind === SyntaxKind.ThisType ?
            createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This, /*parameterName*/ undefined, /*parameterIndex*/ undefined, type) :
            createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier, parameterName.escapedText as string, findIndex(signature.parameters, p => p.escapedName === parameterName.escapedText), type);
    }

    function getUnionOrIntersectionType(types: Type[], kind: TypeFlags | undefined, unionReduction?: UnionReduction) {
        return kind !== TypeFlags.Intersection ? getUnionType(types, unionReduction) : getIntersectionType(types);
    }

    function getReturnTypeOfSignature(signature: Signature): Type {
        if (!signature.resolvedReturnType) {
            if (!pushTypeResolution(signature, TypeSystemPropertyName.ResolvedReturnType)) {
                return errorType;
            }
            let type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :
                signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReduction.Subtype), signature.mapper) :
                getReturnTypeFromAnnotation(signature.declaration!) ||
                (nodeIsMissing((signature.declaration as FunctionLikeDeclaration).body) ? anyType : getReturnTypeFromBody(signature.declaration as FunctionLikeDeclaration));
            if (signature.flags & SignatureFlags.IsInnerCallChain) {
                type = addOptionalTypeMarker(type);
            }
            else if (signature.flags & SignatureFlags.IsOuterCallChain) {
                type = getOptionalType(type);
            }
            if (!popTypeResolution()) {
                if (signature.declaration) {
                    const typeNode = getEffectiveReturnTypeNode(signature.declaration);
                    if (typeNode) {
                        error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself);
                    }
                    else if (noImplicitAny) {
                        const declaration = signature.declaration as Declaration;
                        const name = getNameOfDeclaration(declaration);
                        if (name) {
                            error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name));
                        }
                        else {
                            error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                        }
                    }
                }
                type = anyType;
            }
            signature.resolvedReturnType ??= type;
        }
        return signature.resolvedReturnType;
    }

    function getReturnTypeFromAnnotation(declaration: SignatureDeclaration | JSDocSignature) {
        if (declaration.kind === SyntaxKind.Constructor) {
            return getDeclaredTypeOfClassOrInterface(getMergedSymbol((declaration.parent as ClassDeclaration).symbol));
        }
        const typeNode = getEffectiveReturnTypeNode(declaration);
        if (isJSDocSignature(declaration)) {
            const root = getJSDocRoot(declaration);
            if (root && isConstructorDeclaration(root.parent) && !typeNode) {
                return getDeclaredTypeOfClassOrInterface(getMergedSymbol((root.parent.parent as ClassDeclaration).symbol));
            }
        }
        if (isJSDocConstructSignature(declaration)) {
            return getTypeFromTypeNode((declaration.parameters[0] as ParameterDeclaration).type!); // TODO: GH#18217
        }
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
        if (declaration.kind === SyntaxKind.GetAccessor && hasBindableName(declaration)) {
            const jsDocType = isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
            if (jsDocType) {
                return jsDocType;
            }
            const setter = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(declaration), SyntaxKind.SetAccessor);
            const setterType = getAnnotatedAccessorType(setter);
            if (setterType) {
                return setterType;
            }
        }
        return getReturnTypeOfTypeTag(declaration);
    }

    function isResolvingReturnTypeOfSignature(signature: Signature): boolean {
        return signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) ||
            !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyName.ResolvedReturnType) >= 0;
    }

    function getRestTypeOfSignature(signature: Signature): Type {
        return tryGetRestTypeOfSignature(signature) || anyType;
    }

    function tryGetRestTypeOfSignature(signature: Signature): Type | undefined {
        if (signatureHasRestParameter(signature)) {
            const sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            const restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
            return restType && getIndexTypeOfType(restType, numberType);
        }
        return undefined;
    }

    function getSignatureInstantiation(signature: Signature, typeArguments: Type[] | undefined, isJavascript: boolean, inferredTypeParameters?: readonly TypeParameter[]): Signature {
        const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
        if (inferredTypeParameters) {
            const returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
            if (returnSignature) {
                const newReturnSignature = cloneSignature(returnSignature);
                newReturnSignature.typeParameters = inferredTypeParameters;
                const newReturnType = getOrCreateTypeFromSignature(newReturnSignature) as AnonymousType;
                newReturnType.mapper = instantiatedSignature.mapper;
                const newInstantiatedSignature = cloneSignature(instantiatedSignature);
                newInstantiatedSignature.resolvedReturnType = newReturnType;
                return newInstantiatedSignature;
            }
        }
        return instantiatedSignature;
    }

    function getSignatureInstantiationWithoutFillingInTypeArguments(signature: Signature, typeArguments: readonly Type[] | undefined): Signature {
        const instantiations = signature.instantiations || (signature.instantiations = new Map<string, Signature>());
        const id = getTypeListId(typeArguments);
        let instantiation = instantiations.get(id);
        if (!instantiation) {
            instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
        }
        return instantiation;
    }

    function createSignatureInstantiation(signature: Signature, typeArguments: readonly Type[] | undefined): Signature {
        return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), /*eraseTypeParameters*/ true);
    }

    function getTypeParametersForMapper(signature: Signature) {
        return sameMap(signature.typeParameters, tp => tp.mapper ? instantiateType(tp, tp.mapper) : tp);
    }

    function createSignatureTypeMapper(signature: Signature, typeArguments: readonly Type[] | undefined): TypeMapper {
        return createTypeMapper(getTypeParametersForMapper(signature)!, typeArguments);
    }

    function getErasedSignature(signature: Signature): Signature {
        return signature.typeParameters ?
            signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :
            signature;
    }

    function createErasedSignature(signature: Signature) {
        // Create an instantiation of the signature where all type arguments are the any type.
        return instantiateSignature(signature, createTypeEraser(signature.typeParameters!), /*eraseTypeParameters*/ true);
    }

    function getCanonicalSignature(signature: Signature): Signature {
        return signature.typeParameters ?
            signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :
            signature;
    }

    function createCanonicalSignature(signature: Signature) {
        // Create an instantiation of the signature where each unconstrained type parameter is replaced with
        // its original. When a generic class or interface is instantiated, each generic method in the class or
        // interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
        // where different generations of the same type parameter are in scope). This leads to a lot of new type
        // identities, and potentially a lot of work comparing those identities, so here we create an instantiation
        // that uses the original type identities for all unconstrained type parameters.
        return getSignatureInstantiation(
            signature,
            map(signature.typeParameters, tp => tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp),
            isInJSFile(signature.declaration),
        );
    }

    function getBaseSignature(signature: Signature) {
        const typeParameters = signature.typeParameters;
        if (typeParameters) {
            if (signature.baseSignatureCache) {
                return signature.baseSignatureCache;
            }
            const typeEraser = createTypeEraser(typeParameters);
            const baseConstraintMapper = createTypeMapper(typeParameters, map(typeParameters, tp => getConstraintOfTypeParameter(tp) || unknownType));
            let baseConstraints: readonly Type[] = map(typeParameters, tp => instantiateType(tp, baseConstraintMapper) || unknownType);
            // Run N type params thru the immediate constraint mapper up to N times
            // This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
            for (let i = 0; i < typeParameters.length - 1; i++) {
                baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);
            }
            // and then apply a type eraser to remove any remaining circularly dependent type parameters
            baseConstraints = instantiateTypes(baseConstraints, typeEraser);
            return signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters*/ true);
        }
        return signature;
    }

    function getOrCreateTypeFromSignature(signature: Signature): ObjectType {
        // There are two ways to declare a construct signature, one is by declaring a class constructor
        // using the constructor keyword, and the other is declaring a bare construct signature in an
        // object type literal or interface (using the new keyword). Each way of declaring a constructor
        // will result in a different declaration kind.
        if (!signature.isolatedSignatureType) {
            const kind = signature.declaration?.kind;

            // If declaration is undefined, it is likely to be the signature of the default constructor.
            const isConstructor = kind === undefined || kind === SyntaxKind.Constructor || kind === SyntaxKind.ConstructSignature || kind === SyntaxKind.ConstructorType;

            const type = createObjectType(ObjectFlags.Anonymous | ObjectFlags.SingleSignatureType, signature.declaration?.symbol);
            type.members = emptySymbols;
            type.properties = emptyArray;
            type.callSignatures = !isConstructor ? [signature] : emptyArray;
            type.constructSignatures = isConstructor ? [signature] : emptyArray;
            type.indexInfos = emptyArray;
            signature.isolatedSignatureType = type;
        }

        return signature.isolatedSignatureType;
    }

    function getIndexSymbol(symbol: Symbol): Symbol | undefined {
        return symbol.members ? getIndexSymbolFromSymbolTable(getMembersOfSymbol(symbol)) : undefined;
    }

    function getIndexSymbolFromSymbolTable(symbolTable: SymbolTable): Symbol | undefined {
        return symbolTable.get(InternalSymbolName.Index);
    }

    function createIndexInfo(keyType: Type, type: Type, isReadonly: boolean, declaration?: IndexSignatureDeclaration, components?: ElementWithComputedPropertyName[]): IndexInfo {
        return { keyType, type, isReadonly, declaration, components };
    }

    function getIndexInfosOfSymbol(symbol: Symbol): IndexInfo[] {
        const indexSymbol = getIndexSymbol(symbol);
        return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol, arrayFrom(getMembersOfSymbol(symbol).values())) : emptyArray;
    }

    // note intentional similarities to index signature building in `checkObjectLiteral` for parity
    function getIndexInfosOfIndexSymbol(indexSymbol: Symbol, siblingSymbols: Symbol[] | undefined = indexSymbol.parent ? arrayFrom(getMembersOfSymbol(indexSymbol.parent).values()) : undefined): IndexInfo[] {
        if (indexSymbol.declarations) {
            const indexInfos: IndexInfo[] = [];
            let hasComputedNumberProperty = false;
            let readonlyComputedNumberProperty = true;
            let hasComputedSymbolProperty = false;
            let readonlyComputedSymbolProperty = true;
            let hasComputedStringProperty = false;
            let readonlyComputedStringProperty = true;
            const computedPropertySymbols: Symbol[] = [];
            for (const declaration of indexSymbol.declarations) {
                if (isIndexSignatureDeclaration(declaration)) {
                    if (declaration.parameters.length === 1) {
                        const parameter = declaration.parameters[0];
                        if (parameter.type) {
                            forEachType(getTypeFromTypeNode(parameter.type), keyType => {
                                if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType)) {
                                    indexInfos.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, hasEffectiveModifier(declaration, ModifierFlags.Readonly), declaration));
                                }
                            });
                        }
                    }
                }
                else if (hasLateBindableIndexSignature(declaration)) {
                    const declName = isBinaryExpression(declaration) ? declaration.left as ElementAccessExpression : (declaration as LateBoundDeclaration).name;
                    const keyType = isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
                    if (findIndexInfo(indexInfos, keyType)) {
                        continue; // Explicit index for key type takes priority
                    }
                    if (isTypeAssignableTo(keyType, stringNumberSymbolType)) {
                        if (isTypeAssignableTo(keyType, numberType)) {
                            hasComputedNumberProperty = true;
                            if (!hasEffectiveReadonlyModifier(declaration)) {
                                readonlyComputedNumberProperty = false;
                            }
                        }
                        else if (isTypeAssignableTo(keyType, esSymbolType)) {
                            hasComputedSymbolProperty = true;
                            if (!hasEffectiveReadonlyModifier(declaration)) {
                                readonlyComputedSymbolProperty = false;
                            }
                        }
                        else {
                            hasComputedStringProperty = true;
                            if (!hasEffectiveReadonlyModifier(declaration)) {
                                readonlyComputedStringProperty = false;
                            }
                        }
                        computedPropertySymbols.push(declaration.symbol);
                    }
                }
            }
            const allPropertySymbols = concatenate(computedPropertySymbols, filter(siblingSymbols, s => s !== indexSymbol));
            // aggregate similar index infos implied to be the same key to the same combined index info
            if (hasComputedStringProperty && !findIndexInfo(indexInfos, stringType)) indexInfos.push(getObjectLiteralIndexInfo(readonlyComputedStringProperty, 0, allPropertySymbols, stringType));
            if (hasComputedNumberProperty && !findIndexInfo(indexInfos, numberType)) indexInfos.push(getObjectLiteralIndexInfo(readonlyComputedNumberProperty, 0, allPropertySymbols, numberType));
            if (hasComputedSymbolProperty && !findIndexInfo(indexInfos, esSymbolType)) indexInfos.push(getObjectLiteralIndexInfo(readonlyComputedSymbolProperty, 0, allPropertySymbols, esSymbolType));
            return indexInfos;
        }
        return emptyArray;
    }

    function isValidIndexKeyType(type: Type): boolean {
        return !!(type.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.ESSymbol)) || isPatternLiteralType(type) ||
            !!(type.flags & TypeFlags.Intersection) && !isGenericType(type) && some((type as IntersectionType).types, isValidIndexKeyType);
    }

    function getConstraintDeclaration(type: TypeParameter): TypeNode | undefined {
        return mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0];
    }

    function getInferredTypeParameterConstraint(typeParameter: TypeParameter, omitTypeReferences?: boolean) {
        let inferences: Type[] | undefined;
        if (typeParameter.symbol?.declarations) {
            for (const declaration of typeParameter.symbol.declarations) {
                if (declaration.parent.kind === SyntaxKind.InferType) {
                    // When an 'infer T' declaration is immediately contained in a type reference node
                    // (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
                    // corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
                    // present, we form an intersection of the inferred constraint types.
                    const [childTypeParameter = declaration.parent, grandParent] = walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent);
                    if (grandParent.kind === SyntaxKind.TypeReference && !omitTypeReferences) {
                        const typeReference = grandParent as TypeReferenceNode;
                        const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReference);
                        if (typeParameters) {
                            const index = typeReference.typeArguments!.indexOf(childTypeParameter as TypeNode);
                            if (index < typeParameters.length) {
                                const declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                                if (declaredConstraint) {
                                    // Type parameter constraints can reference other type parameters so
                                    // constraints need to be instantiated. If instantiation produces the
                                    // type parameter itself, we discard that inference. For example, in
                                    //   type Foo<T extends string, U extends T> = [T, U];
                                    //   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
                                    // the instantiated constraint for U is X, so we discard that inference.
                                    const mapper = makeDeferredTypeMapper(
                                        typeParameters,
                                        typeParameters.map((_, index) => () => {
                                            return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index);
                                        }),
                                    );
                                    const constraint = instantiateType(declaredConstraint, mapper);
                                    if (constraint !== typeParameter) {
                                        inferences = append(inferences, constraint);
                                    }
                                }
                            }
                        }
                    }
                    // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type
                    // or a named rest tuple element, we infer an 'unknown[]' constraint.
                    else if (
                        grandParent.kind === SyntaxKind.Parameter && (grandParent as ParameterDeclaration).dotDotDotToken ||
                        grandParent.kind === SyntaxKind.RestType ||
                        grandParent.kind === SyntaxKind.NamedTupleMember && (grandParent as NamedTupleMember).dotDotDotToken
                    ) {
                        inferences = append(inferences, createArrayType(unknownType));
                    }
                    // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'
                    // constraint.
                    else if (grandParent.kind === SyntaxKind.TemplateLiteralTypeSpan) {
                        inferences = append(inferences, stringType);
                    }
                    // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'
                    // constraint.
                    else if (grandParent.kind === SyntaxKind.TypeParameter && grandParent.parent.kind === SyntaxKind.MappedType) {
                        inferences = append(inferences, stringNumberSymbolType);
                    }
                    // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends
                    // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template
                    // of the check type's mapped type
                    else if (
                        grandParent.kind === SyntaxKind.MappedType && (grandParent as MappedTypeNode).type &&
                        skipParentheses((grandParent as MappedTypeNode).type!) === declaration.parent && grandParent.parent.kind === SyntaxKind.ConditionalType &&
                        (grandParent.parent as ConditionalTypeNode).extendsType === grandParent && (grandParent.parent as ConditionalTypeNode).checkType.kind === SyntaxKind.MappedType &&
                        ((grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode).type
                    ) {
                        const checkMappedType = (grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode;
                        const nodeType = getTypeFromTypeNode(checkMappedType.type!);
                        inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)), checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : stringNumberSymbolType)));
                    }
                }
            }
        }
        return inferences && getIntersectionType(inferences);
    }

    /** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
    function getConstraintFromTypeParameter(typeParameter: TypeParameter): Type | undefined {
        if (!typeParameter.constraint) {
            if (typeParameter.target) {
                const targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
            }
            else {
                const constraintDeclaration = getConstraintDeclaration(typeParameter);
                if (!constraintDeclaration) {
                    typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
                }
                else {
                    let type = getTypeFromTypeNode(constraintDeclaration);
                    if (type.flags & TypeFlags.Any && !isErrorType(type)) { // Allow errorType to propegate to keep downstream errors suppressed
                        // use stringNumberSymbolType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
                        // use unknown otherwise
                        type = constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? stringNumberSymbolType : unknownType;
                    }
                    typeParameter.constraint = type;
                }
            }
        }
        return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
    }

    function getParentSymbolOfTypeParameter(typeParameter: TypeParameter): Symbol | undefined {
        const tp = getDeclarationOfKind<TypeParameterDeclaration>(typeParameter.symbol, SyntaxKind.TypeParameter)!;
        const host = isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent;
        return host && getSymbolOfNode(host);
    }

    function getTypeListId(types: readonly Type[] | undefined) {
        let result = "";
        if (types) {
            const length = types.length;
            let i = 0;
            while (i < length) {
                const startId = types[i].id;
                let count = 1;
                while (i + count < length && types[i + count].id === startId + count) {
                    count++;
                }
                if (result.length) {
                    result += ",";
                }
                result += startId;
                if (count > 1) {
                    result += ":" + count;
                }
                i += count;
            }
        }
        return result;
    }

    function getAliasId(aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined) {
        return aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "";
    }

    // This function is used to propagate certain flags when creating new object type references and union types.
    // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
    // of an object literal or a non-inferrable type. This is because there are operations in the type checker
    // that care about the presence of such types at arbitrary depth in a containing type.
    function getPropagatingFlagsOfTypes(types: readonly Type[], excludeKinds?: TypeFlags): ObjectFlags {
        let result: ObjectFlags = 0;
        for (const type of types) {
            if (excludeKinds === undefined || !(type.flags & excludeKinds)) {
                result |= getObjectFlags(type);
            }
        }
        return result & ObjectFlags.PropagatingFlags;
    }

    function tryCreateTypeReference(target: GenericType, typeArguments: readonly Type[] | undefined): Type {
        if (some(typeArguments) && target === emptyGenericType) {
            return unknownType;
        }

        return createTypeReference(target, typeArguments);
    }

    function createTypeReference(target: GenericType, typeArguments: readonly Type[] | undefined): TypeReference {
        const id = getTypeListId(typeArguments);
        let type = target.instantiations.get(id);
        if (!type) {
            type = createObjectType(ObjectFlags.Reference, target.symbol) as TypeReference;
            target.instantiations.set(id, type);
            type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0;
            type.target = target;
            type.resolvedTypeArguments = typeArguments;
        }
        return type;
    }

    function cloneTypeReference(source: TypeReference): TypeReference {
        const type = createTypeWithSymbol(source.flags, source.symbol) as TypeReference;
        type.objectFlags = source.objectFlags;
        type.target = source.target;
        type.resolvedTypeArguments = source.resolvedTypeArguments;
        return type;
    }

    function createDeferredTypeReference(target: GenericType, node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode, mapper?: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): DeferredTypeReference {
        if (!aliasSymbol) {
            aliasSymbol = getAliasSymbolForTypeNode(node);
            const localAliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
            aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments;
        }
        const type = createObjectType(ObjectFlags.Reference, target.symbol) as DeferredTypeReference;
        type.target = target;
        type.node = node;
        type.mapper = mapper;
        type.aliasSymbol = aliasSymbol;
        type.aliasTypeArguments = aliasTypeArguments;
        return type;
    }

    function getTypeArguments(type: TypeReference): readonly Type[] {
        if (!type.resolvedTypeArguments) {
            if (!pushTypeResolution(type, TypeSystemPropertyName.ResolvedTypeArguments)) {
                return concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType)) || emptyArray;
            }
            const node = type.node;
            const typeArguments = !node ? emptyArray :
                node.kind === SyntaxKind.TypeReference ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!)) :
                node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] :
                map(node.elements, getTypeFromTypeNode);
            if (popTypeResolution()) {
                type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
            }
            else {
                type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray);
                error(
                    type.node || currentNode,
                    type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves,
                    type.target.symbol && symbolToString(type.target.symbol),
                );
            }
        }
        return type.resolvedTypeArguments;
    }

    function getTypeReferenceArity(type: TypeReference): number {
        return length(type.target.typeParameters);
    }

    /**
     * Get type from type-reference that reference to class or interface
     */
    function getTypeFromClassOrInterfaceReference(node: NodeWithTypeArguments, symbol: Symbol): Type {
        const type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol)) as InterfaceType;
        const typeParameters = type.localTypeParameters;
        if (typeParameters) {
            const numTypeArguments = length(node.typeArguments);
            const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            const isJs = isInJSFile(node);
            const isJsImplicitAny = !noImplicitAny && isJs;
            if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
                const missingAugmentsTag = isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent);
                const diag = minTypeArgumentCount === typeParameters.length ?
                    missingAugmentsTag ?
                        Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :
                        Diagnostics.Generic_type_0_requires_1_type_argument_s :
                    missingAugmentsTag ?
                    Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :
                    Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;

                const typeStr = typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType);
                error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
                if (!isJs) {
                    // TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
                    return errorType;
                }
            }
            if (node.kind === SyntaxKind.TypeReference && isDeferredTypeReferenceNode(node as TypeReferenceNode, length(node.typeArguments) !== typeParameters.length)) {
                return createDeferredTypeReference(type as GenericType, node as TypeReferenceNode, /*mapper*/ undefined);
            }
            // In a type reference, the outer type parameters of the referenced class or interface are automatically
            // supplied as type arguments and the type reference only specifies arguments for the local type parameters
            // of the class or interface.
            const typeArguments = concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
            return createTypeReference(type as GenericType, typeArguments);
        }
        return checkNoTypeArguments(node, symbol) ? type : errorType;
    }

    function getTypeAliasInstantiation(symbol: Symbol, typeArguments: readonly Type[] | undefined, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        const type = getDeclaredTypeOfSymbol(symbol);
        if (type === intrinsicMarkerType) {
            const typeKind = intrinsicTypeKinds.get(symbol.escapedName as string);
            if (typeKind !== undefined && typeArguments && typeArguments.length === 1) {
                return typeKind === IntrinsicTypeKind.NoInfer ? getNoInferType(typeArguments[0]) : getStringMappingType(symbol, typeArguments[0]);
            }
        }
        const links = getSymbolLinks(symbol);
        const typeParameters = links.typeParameters!;
        const id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
        let instantiation = links.instantiations!.get(id);
        if (!instantiation) {
            links.instantiations!.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments));
        }
        return instantiation;
    }

    /**
     * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
     * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
     * declared type. Instantiations are cached using the type identities of the type arguments as the key.
     */
    function getTypeFromTypeAliasReference(node: NodeWithTypeArguments, symbol: Symbol): Type {
        if (getCheckFlags(symbol) & CheckFlags.Unresolved) {
            const typeArguments = typeArgumentsFromTypeReferenceNode(node);
            const id = getAliasId(symbol, typeArguments);
            let errorType = errorTypes.get(id);
            if (!errorType) {
                errorType = createIntrinsicType(TypeFlags.Any, "error", /*objectFlags*/ undefined, `alias ${id}`);
                errorType.aliasSymbol = symbol;
                errorType.aliasTypeArguments = typeArguments;
                errorTypes.set(id, errorType);
            }
            return errorType;
        }
        const type = getDeclaredTypeOfSymbol(symbol);
        const typeParameters = getSymbolLinks(symbol).typeParameters;
        if (typeParameters) {
            const numTypeArguments = length(node.typeArguments);
            const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                error(
                    node,
                    minTypeArgumentCount === typeParameters.length ?
                        Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments,
                    symbolToString(symbol),
                    minTypeArgumentCount,
                    typeParameters.length,
                );
                return errorType;
            }
            // We refrain from associating a local type alias with an instantiation of a top-level type alias
            // because the local alias may end up being referenced in an inferred return type where it is not
            // accessible--which in turn may lead to a large structural expansion of the type when generating
            // a .d.ts file. See #43622 for an example.
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            let newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined;
            let aliasTypeArguments: Type[] | undefined;
            if (newAliasSymbol) {
                aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol);
            }
            else if (isTypeReferenceType(node)) {
                const aliasSymbol = resolveTypeReferenceName(node, SymbolFlags.Alias, /*ignoreErrors*/ true);
                // refers to an alias import/export/reexport - by making sure we use the target as an aliasSymbol,
                // we ensure the exported symbol is used to refer to the type when it's reserialized later
                if (aliasSymbol && aliasSymbol !== unknownSymbol) {
                    const resolved = resolveAlias(aliasSymbol);
                    if (resolved && resolved.flags & SymbolFlags.TypeAlias) {
                        newAliasSymbol = resolved;
                        aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || (typeParameters ? [] : undefined);
                    }
                }
            }
            return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments);
        }
        return checkNoTypeArguments(node, symbol) ? type : errorType;
    }

    function isLocalTypeAlias(symbol: Symbol) {
        const declaration = symbol.declarations?.find(isTypeAlias);
        return !!(declaration && getContainingFunction(declaration));
    }

    function getTypeReferenceName(node: TypeReferenceType): EntityNameOrEntityNameExpression | undefined {
        switch (node.kind) {
            case SyntaxKind.TypeReference:
                return node.typeName;
            case SyntaxKind.ExpressionWithTypeArguments:
                // We only support expressions that are simple qualified names. For other
                // expressions this produces undefined.
                const expr = node.expression;
                if (isEntityNameExpression(expr)) {
                    return expr;
                }
                // fall through;
        }

        return undefined;
    }

    function getSymbolPath(symbol: Symbol): string {
        return symbol.parent ? `${getSymbolPath(symbol.parent)}.${symbol.escapedName}` : symbol.escapedName as string;
    }

    function getUnresolvedSymbolForEntityName(name: EntityNameOrEntityNameExpression) {
        const identifier = name.kind === SyntaxKind.QualifiedName ? name.right :
            name.kind === SyntaxKind.PropertyAccessExpression ? name.name :
            name;
        const text = identifier.escapedText;
        if (text) {
            const parentSymbol = name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) :
                name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) :
                undefined;
            const path = parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string;
            let result = unresolvedSymbols.get(path);
            if (!result) {
                unresolvedSymbols.set(path, result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved));
                result.parent = parentSymbol;
                result.links.declaredType = unresolvedType;
            }
            return result;
        }
        return unknownSymbol;
    }

    function resolveTypeReferenceName(typeReference: TypeReferenceType, meaning: SymbolFlags, ignoreErrors?: boolean) {
        const name = getTypeReferenceName(typeReference);
        if (!name) {
            return unknownSymbol;
        }
        const symbol = resolveEntityName(name, meaning, ignoreErrors);
        return symbol && symbol !== unknownSymbol ? symbol :
            ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name);
    }

    function getTypeReferenceType(node: NodeWithTypeArguments, symbol: Symbol): Type {
        if (symbol === unknownSymbol) {
            return errorType;
        }
        symbol = getExpandoSymbol(symbol) || symbol;
        if (symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
            return getTypeFromClassOrInterfaceReference(node, symbol);
        }
        if (symbol.flags & SymbolFlags.TypeAlias) {
            return getTypeFromTypeAliasReference(node, symbol);
        }
        // Get type from reference to named type that cannot be generic (enum or type parameter)
        const res = tryGetDeclaredTypeOfSymbol(symbol);
        if (res) {
            return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
        }
        if (symbol.flags & SymbolFlags.Value && isJSDocTypeReference(node)) {
            const jsdocType = getTypeFromJSDocValueReference(node, symbol);
            if (jsdocType) {
                return jsdocType;
            }
            else {
                // Resolve the type reference as a Type for the purpose of reporting errors.
                resolveTypeReferenceName(node, SymbolFlags.Type);
                return getTypeOfSymbol(symbol);
            }
        }
        return errorType;
    }

    /**
     * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
     * Example: import('./b').ConstructorFunction
     */
    function getTypeFromJSDocValueReference(node: NodeWithTypeArguments, symbol: Symbol): Type | undefined {
        const links = getNodeLinks(node);
        if (!links.resolvedJSDocType) {
            const valueType = getTypeOfSymbol(symbol);
            let typeType = valueType;
            if (symbol.valueDeclaration) {
                const isImportTypeWithQualifier = node.kind === SyntaxKind.ImportType && (node as ImportTypeNode).qualifier;
                // valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
                if (valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier) {
                    typeType = getTypeReferenceType(node, valueType.symbol);
                }
            }
            links.resolvedJSDocType = typeType;
        }
        return links.resolvedJSDocType;
    }

    function getNoInferType(type: Type) {
        return isNoInferTargetType(type) ? getOrCreateSubstitutionType(type, unknownType) : type;
    }

    function isNoInferTargetType(type: Type): boolean {
        // This is effectively a more conservative and predictable form of couldContainTypeVariables. We want to
        // preserve NoInfer<T> only for types that could contain type variables, but we don't want to exhaustively
        // examine all object type members.
        return !!(type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, isNoInferTargetType) ||
            type.flags & TypeFlags.Substitution && !isNoInferType(type) && isNoInferTargetType((type as SubstitutionType).baseType) ||
            type.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(type) ||
            type.flags & (TypeFlags.Instantiable & ~TypeFlags.Substitution) && !isPatternLiteralType(type));
    }

    function isNoInferType(type: Type) {
        // A NoInfer<T> type is represented as a substitution type with a TypeFlags.Unknown constraint.
        return !!(type.flags & TypeFlags.Substitution && (type as SubstitutionType).constraint.flags & TypeFlags.Unknown);
    }

    function getSubstitutionType(baseType: Type, constraint: Type) {
        return constraint.flags & TypeFlags.AnyOrUnknown || constraint === baseType || baseType.flags & TypeFlags.Any ?
            baseType :
            getOrCreateSubstitutionType(baseType, constraint);
    }

    function getOrCreateSubstitutionType(baseType: Type, constraint: Type) {
        const id = `${getTypeId(baseType)}>${getTypeId(constraint)}`;
        const cached = substitutionTypes.get(id);
        if (cached) {
            return cached;
        }
        const result = createType(TypeFlags.Substitution) as SubstitutionType;
        result.baseType = baseType;
        result.constraint = constraint;
        substitutionTypes.set(id, result);
        return result;
    }

    function getSubstitutionIntersection(substitutionType: SubstitutionType) {
        return isNoInferType(substitutionType) ? substitutionType.baseType : getIntersectionType([substitutionType.constraint, substitutionType.baseType]);
    }

    function isUnaryTupleTypeNode(node: TypeNode) {
        return node.kind === SyntaxKind.TupleType && (node as TupleTypeNode).elements.length === 1;
    }

    function getImpliedConstraint(type: Type, checkNode: TypeNode, extendsNode: TypeNode): Type | undefined {
        return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, (checkNode as TupleTypeNode).elements[0], (extendsNode as TupleTypeNode).elements[0]) :
            getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :
            undefined;
    }

    function getConditionalFlowTypeOfType(type: Type, node: Node) {
        let constraints: Type[] | undefined;
        let covariant = true;
        while (node && !isStatement(node) && node.kind !== SyntaxKind.JSDoc) {
            const parent = node.parent;
            // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
            // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
            if (parent.kind === SyntaxKind.Parameter) {
                covariant = !covariant;
            }
            // Always substitute on type parameters, regardless of variance, since even
            // in contravariant positions, they may rely on substituted constraints to be valid
            if ((covariant || type.flags & TypeFlags.TypeVariable) && parent.kind === SyntaxKind.ConditionalType && node === (parent as ConditionalTypeNode).trueType) {
                const constraint = getImpliedConstraint(type, (parent as ConditionalTypeNode).checkType, (parent as ConditionalTypeNode).extendsType);
                if (constraint) {
                    constraints = append(constraints, constraint);
                }
            }
            // Given a homomorphic mapped type { [K in keyof T]: XXX }, where T is constrained to an array or tuple type, in the
            // template type XXX, K has an added constraint of number | `${number}`.
            else if (type.flags & TypeFlags.TypeParameter && parent.kind === SyntaxKind.MappedType && !(parent as MappedTypeNode).nameType && node === (parent as MappedTypeNode).type) {
                const mappedType = getTypeFromTypeNode(parent as TypeNode) as MappedType;
                if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {
                    const typeParameter = getHomomorphicTypeVariable(mappedType);
                    if (typeParameter) {
                        const constraint = getConstraintOfTypeParameter(typeParameter);
                        if (constraint && everyType(constraint, isArrayOrTupleType)) {
                            constraints = append(constraints, getUnionType([numberType, numericStringType]));
                        }
                    }
                }
            }
            node = parent;
        }
        return constraints ? getSubstitutionType(type, getIntersectionType(constraints)) : type;
    }

    function isJSDocTypeReference(node: Node): node is TypeReferenceNode {
        return !!(node.flags & NodeFlags.JSDoc) && (node.kind === SyntaxKind.TypeReference || node.kind === SyntaxKind.ImportType);
    }

    function checkNoTypeArguments(node: NodeWithTypeArguments, symbol?: Symbol) {
        if (node.typeArguments) {
            error(node, Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon);
            return false;
        }
        return true;
    }

    function getIntendedTypeFromJSDocTypeReference(node: TypeReferenceNode): Type | undefined {
        if (isIdentifier(node.typeName)) {
            const typeArgs = node.typeArguments;
            switch (node.typeName.escapedText) {
                case "String":
                    checkNoTypeArguments(node);
                    return stringType;
                case "Number":
                    checkNoTypeArguments(node);
                    return numberType;
                case "BigInt":
                    checkNoTypeArguments(node);
                    return bigintType;
                case "Boolean":
                    checkNoTypeArguments(node);
                    return booleanType;
                case "Void":
                    checkNoTypeArguments(node);
                    return voidType;
                case "Undefined":
                    checkNoTypeArguments(node);
                    return undefinedType;
                case "Null":
                    checkNoTypeArguments(node);
                    return nullType;
                case "Function":
                case "function":
                    checkNoTypeArguments(node);
                    return globalFunctionType;
                case "array":
                    return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
                case "promise":
                    return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;
                case "Object":
                    if (typeArgs && typeArgs.length === 2) {
                        if (isJSDocIndexSignature(node)) {
                            const indexed = getTypeFromTypeNode(typeArgs[0]);
                            const target = getTypeFromTypeNode(typeArgs[1]);
                            const indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly*/ false)] : emptyArray;
                            return createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, indexInfo);
                        }
                        return anyType;
                    }
                    checkNoTypeArguments(node);
                    return !noImplicitAny ? anyType : undefined;
            }
        }
    }

    function getTypeFromJSDocNullableTypeNode(node: JSDocNullableType) {
        const type = getTypeFromTypeNode(node.type);
        return strictNullChecks ? getNullableType(type, TypeFlags.Null) : type;
    }

    function getTypeFromTypeReference(node: TypeReferenceType): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            // handle LS queries on the `const` in `x as const` by resolving to the type of `x`
            if (isConstTypeReference(node) && isAssertionExpression(node.parent)) {
                links.resolvedSymbol = unknownSymbol;
                return links.resolvedType = checkExpressionCached(node.parent.expression);
            }
            let symbol: Symbol | undefined;
            let type: Type | undefined;
            const meaning = SymbolFlags.Type;
            if (isJSDocTypeReference(node)) {
                type = getIntendedTypeFromJSDocTypeReference(node);
                if (!type) {
                    symbol = resolveTypeReferenceName(node, meaning, /*ignoreErrors*/ true);
                    if (symbol === unknownSymbol) {
                        symbol = resolveTypeReferenceName(node, meaning | SymbolFlags.Value);
                    }
                    else {
                        resolveTypeReferenceName(node, meaning); // Resolve again to mark errors, if any
                    }
                    type = getTypeReferenceType(node, symbol);
                }
            }
            if (!type) {
                symbol = resolveTypeReferenceName(node, meaning);
                type = getTypeReferenceType(node, symbol);
            }
            // Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
            // type reference in checkTypeReferenceNode.
            links.resolvedSymbol = symbol;
            links.resolvedType = type;
        }
        return links.resolvedType;
    }

    function typeArgumentsFromTypeReferenceNode(node: NodeWithTypeArguments): Type[] | undefined {
        return map(node.typeArguments, getTypeFromTypeNode);
    }

    function getTypeFromTypeQueryNode(node: TypeQueryNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            // TypeScript 1.0 spec (April 2014): 3.6.3
            // The expression is processed as an identifier expression (section 4.3)
            // or property access expression(section 4.10),
            // the widened type(section 3.9) of which becomes the result.
            const type = checkExpressionWithTypeArguments(node);
            links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type));
        }
        return links.resolvedType;
    }

    function getTypeOfGlobalSymbol(symbol: Symbol | undefined, arity: number): ObjectType {
        function getTypeDeclaration(symbol: Symbol): Declaration | undefined {
            const declarations = symbol.declarations;
            if (declarations) {
                for (const declaration of declarations) {
                    switch (declaration.kind) {
                        case SyntaxKind.ClassDeclaration:
                        case SyntaxKind.InterfaceDeclaration:
                        case SyntaxKind.EnumDeclaration:
                            return declaration;
                    }
                }
            }
        }

        if (!symbol) {
            return arity ? emptyGenericType : emptyObjectType;
        }
        const type = getDeclaredTypeOfSymbol(symbol);
        if (!(type.flags & TypeFlags.Object)) {
            error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol));
            return arity ? emptyGenericType : emptyObjectType;
        }
        if (length((type as InterfaceType).typeParameters) !== arity) {
            error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity);
            return arity ? emptyGenericType : emptyObjectType;
        }
        return type as ObjectType;
    }

    function getGlobalValueSymbol(name: __String, reportErrors: boolean): Symbol | undefined {
        return getGlobalSymbol(name, SymbolFlags.Value, reportErrors ? Diagnostics.Cannot_find_global_value_0 : undefined);
    }

    function getGlobalTypeSymbol(name: __String, reportErrors: boolean): Symbol | undefined {
        return getGlobalSymbol(name, SymbolFlags.Type, reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined);
    }

    function getGlobalTypeAliasSymbol(name: __String, arity: number, reportErrors: boolean): Symbol | undefined {
        const symbol = getGlobalSymbol(name, SymbolFlags.Type, reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined);
        if (symbol) {
            // Resolve the declared type of the symbol. This resolves type parameters for the type
            // alias so that we can check arity.
            getDeclaredTypeOfSymbol(symbol);
            if (length(getSymbolLinks(symbol).typeParameters) !== arity) {
                const decl = symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration);
                error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity);
                return undefined;
            }
        }
        return symbol;
    }

    function getGlobalSymbol(name: __String, meaning: SymbolFlags, diagnostic: DiagnosticMessage | undefined): Symbol | undefined {
        // Don't track references for global symbols anyway, so value if `isReference` is arbitrary
        return resolveName(/*location*/ undefined, name, meaning, diagnostic, /*isUse*/ false, /*excludeGlobals*/ false);
    }

    function getGlobalType(name: __String, arity: 0, reportErrors: true): ObjectType;
    function getGlobalType(name: __String, arity: 0, reportErrors: boolean): ObjectType | undefined;
    function getGlobalType(name: __String, arity: number, reportErrors: true): GenericType;
    function getGlobalType(name: __String, arity: number, reportErrors: boolean): GenericType | undefined;
    function getGlobalType(name: __String, arity: number, reportErrors: boolean): ObjectType | undefined {
        const symbol = getGlobalTypeSymbol(name, reportErrors);
        return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
    }

    function getGlobalBuiltinTypes(typeNames: readonly string[], arity: 0): ObjectType[];
    function getGlobalBuiltinTypes(typeNames: readonly string[], arity: number): GenericType[];
    function getGlobalBuiltinTypes(typeNames: readonly string[], arity: number) {
        let types: Type[] | undefined;
        for (const typeName of typeNames) {
            types = append(types, getGlobalType(typeName as __String, arity, /*reportErrors*/ false));
        }
        return types ?? emptyArray;
    }

    function getGlobalTypedPropertyDescriptorType() {
        // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
        return deferredGlobalTypedPropertyDescriptorType ||= getGlobalType("TypedPropertyDescriptor" as __String, /*arity*/ 1, /*reportErrors*/ true) || emptyGenericType;
    }

    function getGlobalTemplateStringsArrayType() {
        // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
        return deferredGlobalTemplateStringsArrayType ||= getGlobalType("TemplateStringsArray" as __String, /*arity*/ 0, /*reportErrors*/ true) || emptyObjectType;
    }

    function getGlobalImportMetaType() {
        // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
        return deferredGlobalImportMetaType ||= getGlobalType("ImportMeta" as __String, /*arity*/ 0, /*reportErrors*/ true) || emptyObjectType;
    }

    function getGlobalImportMetaExpressionType() {
        if (!deferredGlobalImportMetaExpressionType) {
            // Create a synthetic type `ImportMetaExpression { meta: MetaProperty }`
            const symbol = createSymbol(SymbolFlags.None, "ImportMetaExpression" as __String);
            const importMetaType = getGlobalImportMetaType();

            const metaPropertySymbol = createSymbol(SymbolFlags.Property, "meta" as __String, CheckFlags.Readonly);
            metaPropertySymbol.parent = symbol;
            metaPropertySymbol.links.type = importMetaType;

            const members = createSymbolTable([metaPropertySymbol]);
            symbol.members = members;

            deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
        }
        return deferredGlobalImportMetaExpressionType;
    }

    function getGlobalImportCallOptionsType(reportErrors: boolean) {
        return (deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity*/ 0, reportErrors)) || emptyObjectType;
    }

    function getGlobalImportAttributesType(reportErrors: boolean) {
        return (deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity*/ 0, reportErrors)) || emptyObjectType;
    }

    function getGlobalESSymbolConstructorSymbol(reportErrors: boolean): Symbol | undefined {
        return deferredGlobalESSymbolConstructorSymbol ||= getGlobalValueSymbol("Symbol" as __String, reportErrors);
    }

    function getGlobalESSymbolConstructorTypeSymbol(reportErrors: boolean): Symbol | undefined {
        return deferredGlobalESSymbolConstructorTypeSymbol ||= getGlobalTypeSymbol("SymbolConstructor" as __String, reportErrors);
    }

    function getGlobalESSymbolType() {
        return (deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity*/ 0, /*reportErrors*/ false)) || emptyObjectType;
    }

    function getGlobalPromiseType(reportErrors: boolean) {
        return (deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity*/ 1, reportErrors)) || emptyGenericType;
    }

    function getGlobalPromiseLikeType(reportErrors: boolean) {
        return (deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity*/ 1, reportErrors)) || emptyGenericType;
    }

    function getGlobalPromiseConstructorSymbol(reportErrors: boolean): Symbol | undefined {
        return deferredGlobalPromiseConstructorSymbol ||= getGlobalValueSymbol("Promise" as __String, reportErrors);
    }

    function getGlobalPromiseConstructorLikeType(reportErrors: boolean) {
        return (deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity*/ 0, reportErrors)) || emptyObjectType;
    }

    function getGlobalAsyncIterableType(reportErrors: boolean) {
        return (deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalAsyncIteratorType(reportErrors: boolean) {
        return (deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalAsyncIterableIteratorType(reportErrors: boolean) {
        return (deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalBuiltinAsyncIteratorTypes() {
        // NOTE: This list does not include all built-in async iterator types, only those that are likely to be encountered frequently.
        return deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1);
    }

    function getGlobalAsyncIteratorObjectType(reportErrors: boolean) {
        return (deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalAsyncGeneratorType(reportErrors: boolean) {
        return (deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalIterableType(reportErrors: boolean) {
        return (deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalIteratorType(reportErrors: boolean) {
        return (deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalIterableIteratorType(reportErrors: boolean) {
        return (deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getBuiltinIteratorReturnType() {
        return strictBuiltinIteratorReturn ? undefinedType : anyType;
    }

    function getGlobalBuiltinIteratorTypes() {
        // NOTE: This list does not include all built-in iterator types, only those that are likely to be encountered frequently.
        return deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1);
    }

    function getGlobalIteratorObjectType(reportErrors: boolean) {
        return (deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalGeneratorType(reportErrors: boolean) {
        return (deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity*/ 3, reportErrors)) || emptyGenericType;
    }

    function getGlobalIteratorYieldResultType(reportErrors: boolean) {
        return (deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity*/ 1, reportErrors)) || emptyGenericType;
    }

    function getGlobalIteratorReturnResultType(reportErrors: boolean) {
        return (deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity*/ 1, reportErrors)) || emptyGenericType;
    }

    function getGlobalDisposableType(reportErrors: boolean) {
        return (deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity*/ 0, reportErrors)) || emptyObjectType;
    }

    function getGlobalAsyncDisposableType(reportErrors: boolean) {
        return (deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity*/ 0, reportErrors)) || emptyObjectType;
    }

    function getGlobalTypeOrUndefined(name: __String, arity = 0): ObjectType | undefined {
        const symbol = getGlobalSymbol(name, SymbolFlags.Type, /*diagnostic*/ undefined);
        return symbol && getTypeOfGlobalSymbol(symbol, arity) as GenericType;
    }

    function getGlobalExtractSymbol(): Symbol | undefined {
        // We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
        deferredGlobalExtractSymbol ||= getGlobalTypeAliasSymbol("Extract" as __String, /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol;
        return deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol;
    }

    function getGlobalOmitSymbol(): Symbol | undefined {
        // We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
        deferredGlobalOmitSymbol ||= getGlobalTypeAliasSymbol("Omit" as __String, /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol;
        return deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol;
    }

    function getGlobalAwaitedSymbol(reportErrors: boolean): Symbol | undefined {
        // Only cache `unknownSymbol` if we are reporting errors so that we don't report the error more than once.
        deferredGlobalAwaitedSymbol ||= getGlobalTypeAliasSymbol("Awaited" as __String, /*arity*/ 1, reportErrors) || (reportErrors ? unknownSymbol : undefined);
        return deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol;
    }

    function getGlobalBigIntType() {
        return (deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity*/ 0, /*reportErrors*/ false)) || emptyObjectType;
    }

    function getGlobalClassDecoratorContextType(reportErrors: boolean) {
        return (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity*/ 1, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalClassMethodDecoratorContextType(reportErrors: boolean) {
        return (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity*/ 2, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalClassGetterDecoratorContextType(reportErrors: boolean) {
        return (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity*/ 2, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalClassSetterDecoratorContextType(reportErrors: boolean) {
        return (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity*/ 2, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalClassAccessorDecoratorContextType(reportErrors: boolean) {
        return (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity*/ 2, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalClassAccessorDecoratorTargetType(reportErrors: boolean) {
        return (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity*/ 2, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalClassAccessorDecoratorResultType(reportErrors: boolean) {
        return (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity*/ 2, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalClassFieldDecoratorContextType(reportErrors: boolean) {
        return (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity*/ 2, reportErrors)) ?? emptyGenericType;
    }

    function getGlobalNaNSymbol(): Symbol | undefined {
        return (deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors*/ false));
    }

    function getGlobalRecordSymbol(): Symbol | undefined {
        deferredGlobalRecordSymbol ||= getGlobalTypeAliasSymbol("Record" as __String, /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol;
        return deferredGlobalRecordSymbol === unknownSymbol ? undefined : deferredGlobalRecordSymbol;
    }

    /**
     * Instantiates a global type that is generic with some element type, and returns that instantiation.
     */
    function createTypeFromGenericGlobalType(genericGlobalType: GenericType, typeArguments: readonly Type[]): ObjectType {
        return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
    }

    function createTypedPropertyDescriptorType(propertyType: Type): Type {
        return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
    }

    function createIterableType(iteratedType: Type): Type {
        return createTypeFromGenericGlobalType(getGlobalIterableType(/*reportErrors*/ true), [iteratedType, voidType, undefinedType]);
    }

    function createArrayType(elementType: Type, readonly?: boolean): ObjectType {
        return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
    }

    function getTupleElementFlags(node: TypeNode) {
        switch (node.kind) {
            case SyntaxKind.OptionalType:
                return ElementFlags.Optional;
            case SyntaxKind.RestType:
                return getRestTypeElementFlags(node as RestTypeNode);
            case SyntaxKind.NamedTupleMember:
                return (node as NamedTupleMember).questionToken ? ElementFlags.Optional :
                    (node as NamedTupleMember).dotDotDotToken ? getRestTypeElementFlags(node as NamedTupleMember) :
                    ElementFlags.Required;
            default:
                return ElementFlags.Required;
        }
    }

    function getRestTypeElementFlags(node: RestTypeNode | NamedTupleMember) {
        return getArrayElementTypeNode(node.type) ? ElementFlags.Rest : ElementFlags.Variadic;
    }

    function getArrayOrTupleTargetType(node: ArrayTypeNode | TupleTypeNode): GenericType {
        const readonly = isReadonlyTypeOperator(node.parent);
        const elementType = getArrayElementTypeNode(node);
        if (elementType) {
            return readonly ? globalReadonlyArrayType : globalArrayType;
        }
        const elementFlags = map((node as TupleTypeNode).elements, getTupleElementFlags);
        return getTupleTargetType(elementFlags, readonly, map((node as TupleTypeNode).elements, memberIfLabeledElementDeclaration));
    }

    function memberIfLabeledElementDeclaration(member: Node): NamedTupleMember | ParameterDeclaration | undefined {
        return isNamedTupleMember(member) || isParameter(member) ? member : undefined;
    }

    // Return true if the given type reference node is directly aliased or if it needs to be deferred
    // because it is possibly contained in a circular chain of eagerly resolved types.
    function isDeferredTypeReferenceNode(node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode, hasDefaultTypeArguments?: boolean) {
        return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (
                    node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(node.elementType) :
                        node.kind === SyntaxKind.TupleType ? some(node.elements, mayResolveTypeAlias) :
                        hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias)
                );
    }

    // Return true when the given node is transitively contained in type constructs that eagerly
    // resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
    // of type aliases are eagerly resolved.
    function isResolvedByTypeAlias(node: Node): boolean {
        const parent = node.parent;
        switch (parent.kind) {
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.NamedTupleMember:
            case SyntaxKind.TypeReference:
            case SyntaxKind.UnionType:
            case SyntaxKind.IntersectionType:
            case SyntaxKind.IndexedAccessType:
            case SyntaxKind.ConditionalType:
            case SyntaxKind.TypeOperator:
            case SyntaxKind.ArrayType:
            case SyntaxKind.TupleType:
                return isResolvedByTypeAlias(parent);
            case SyntaxKind.TypeAliasDeclaration:
                return true;
        }
        return false;
    }

    // Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
    // of a type alias.
    function mayResolveTypeAlias(node: Node): boolean {
        switch (node.kind) {
            case SyntaxKind.TypeReference:
                return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node as TypeReferenceNode, SymbolFlags.Type).flags & SymbolFlags.TypeAlias);
            case SyntaxKind.TypeQuery:
                return true;
            case SyntaxKind.TypeOperator:
                return (node as TypeOperatorNode).operator !== SyntaxKind.UniqueKeyword && mayResolveTypeAlias((node as TypeOperatorNode).type);
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.OptionalType:
            case SyntaxKind.NamedTupleMember:
            case SyntaxKind.JSDocOptionalType:
            case SyntaxKind.JSDocNullableType:
            case SyntaxKind.JSDocNonNullableType:
            case SyntaxKind.JSDocTypeExpression:
                return mayResolveTypeAlias((node as ParenthesizedTypeNode | OptionalTypeNode | JSDocTypeReferencingNode | NamedTupleMember).type);
            case SyntaxKind.RestType:
                return (node as RestTypeNode).type.kind !== SyntaxKind.ArrayType || mayResolveTypeAlias(((node as RestTypeNode).type as ArrayTypeNode).elementType);
            case SyntaxKind.UnionType:
            case SyntaxKind.IntersectionType:
                return some((node as UnionOrIntersectionTypeNode).types, mayResolveTypeAlias);
            case SyntaxKind.IndexedAccessType:
                return mayResolveTypeAlias((node as IndexedAccessTypeNode).objectType) || mayResolveTypeAlias((node as IndexedAccessTypeNode).indexType);
            case SyntaxKind.ConditionalType:
                return mayResolveTypeAlias((node as ConditionalTypeNode).checkType) || mayResolveTypeAlias((node as ConditionalTypeNode).extendsType) ||
                    mayResolveTypeAlias((node as ConditionalTypeNode).trueType) || mayResolveTypeAlias((node as ConditionalTypeNode).falseType);
        }
        return false;
    }

    function getTypeFromArrayOrTupleTypeNode(node: ArrayTypeNode | TupleTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const target = getArrayOrTupleTargetType(node);
            if (target === emptyGenericType) {
                links.resolvedType = emptyObjectType;
            }
            else if (!(node.kind === SyntaxKind.TupleType && some(node.elements, e => !!(getTupleElementFlags(e) & ElementFlags.Variadic))) && isDeferredTypeReferenceNode(node)) {
                links.resolvedType = node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target :
                    createDeferredTypeReference(target, node, /*mapper*/ undefined);
            }
            else {
                const elementTypes = node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode);
                links.resolvedType = createNormalizedTypeReference(target, elementTypes);
            }
        }
        return links.resolvedType;
    }

    function isReadonlyTypeOperator(node: Node) {
        return isTypeOperatorNode(node) && node.operator === SyntaxKind.ReadonlyKeyword;
    }

    function createTupleType(elementTypes: readonly Type[], elementFlags?: readonly ElementFlags[], readonly = false, namedMemberDeclarations: readonly (NamedTupleMember | ParameterDeclaration | undefined)[] = []) {
        const tupleTarget = getTupleTargetType(elementFlags || map(elementTypes, _ => ElementFlags.Required), readonly, namedMemberDeclarations);
        return tupleTarget === emptyGenericType ? emptyObjectType :
            elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :
            tupleTarget;
    }

    function getTupleTargetType(elementFlags: readonly ElementFlags[], readonly: boolean, namedMemberDeclarations: readonly (NamedTupleMember | ParameterDeclaration | undefined)[]): GenericType {
        if (elementFlags.length === 1 && elementFlags[0] & ElementFlags.Rest) {
            // [...X[]] is equivalent to just X[]
            return readonly ? globalReadonlyArrayType : globalArrayType;
        }
        const key = map(elementFlags, f => f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*").join() +
            (readonly ? "R" : "") +
            (some(namedMemberDeclarations, node => !!node) ? "," + map(namedMemberDeclarations, node => node ? getNodeId(node) : "_").join(",") : "");
        let type = tupleTypes.get(key);
        if (!type) {
            tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations));
        }
        return type;
    }

    // We represent tuple types as type references to synthesized generic interface types created by
    // this function. The types are of the form:
    //
    //   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
    //
    // Note that the generic type created by this function has no symbol associated with it. The same
    // is true for each of the synthesized type parameters.
    function createTupleTargetType(elementFlags: readonly ElementFlags[], readonly: boolean, namedMemberDeclarations: readonly (NamedTupleMember | ParameterDeclaration | undefined)[]): TupleType {
        const arity = elementFlags.length;
        const minLength = countWhere(elementFlags, f => !!(f & (ElementFlags.Required | ElementFlags.Variadic)));
        let typeParameters: TypeParameter[] | undefined;
        const properties: Symbol[] = [];
        let combinedFlags = 0 as ElementFlags;
        if (arity) {
            typeParameters = new Array(arity);
            for (let i = 0; i < arity; i++) {
                const typeParameter = typeParameters[i] = createTypeParameter();
                const flags = elementFlags[i];
                combinedFlags |= flags;
                if (!(combinedFlags & ElementFlags.Variable)) {
                    const property = createSymbol(SymbolFlags.Property | (flags & ElementFlags.Optional ? SymbolFlags.Optional : 0), "" + i as __String, readonly ? CheckFlags.Readonly : 0);
                    property.links.tupleLabelDeclaration = namedMemberDeclarations?.[i];
                    property.links.type = typeParameter;
                    properties.push(property);
                }
            }
        }
        const fixedLength = properties.length;
        const lengthSymbol = createSymbol(SymbolFlags.Property, "length" as __String, readonly ? CheckFlags.Readonly : 0);
        if (combinedFlags & ElementFlags.Variable) {
            lengthSymbol.links.type = numberType;
        }
        else {
            const literalTypes = [];
            for (let i = minLength; i <= arity; i++) literalTypes.push(getNumberLiteralType(i));
            lengthSymbol.links.type = getUnionType(literalTypes);
        }
        properties.push(lengthSymbol);
        const type = createObjectType(ObjectFlags.Tuple | ObjectFlags.Reference) as TupleType & InterfaceTypeWithDeclaredMembers;
        type.typeParameters = typeParameters;
        type.outerTypeParameters = undefined;
        type.localTypeParameters = typeParameters;
        type.instantiations = new Map<string, TypeReference>();
        type.instantiations.set(getTypeListId(type.typeParameters), type as GenericType);
        type.target = type as GenericType;
        type.resolvedTypeArguments = type.typeParameters;
        type.thisType = createTypeParameter();
        type.thisType.isThisType = true;
        type.thisType.constraint = type;
        type.declaredProperties = properties;
        type.declaredCallSignatures = emptyArray;
        type.declaredConstructSignatures = emptyArray;
        type.declaredIndexInfos = emptyArray;
        type.elementFlags = elementFlags;
        type.minLength = minLength;
        type.fixedLength = fixedLength;
        type.hasRestElement = !!(combinedFlags & ElementFlags.Variable);
        type.combinedFlags = combinedFlags;
        type.readonly = readonly;
        type.labeledElementDeclarations = namedMemberDeclarations;
        return type;
    }

    function createNormalizedTypeReference(target: GenericType, typeArguments: readonly Type[] | undefined) {
        return target.objectFlags & ObjectFlags.Tuple ? createNormalizedTupleType(target as TupleType, typeArguments!) : createTypeReference(target, typeArguments);
    }

    function createNormalizedTupleType(target: TupleType, elementTypes: readonly Type[]): Type {
        if (!(target.combinedFlags & ElementFlags.NonRequired)) {
            // No need to normalize when we only have regular required elements
            return createTypeReference(target, elementTypes);
        }
        if (target.combinedFlags & ElementFlags.Variadic) {
            // Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
            const unionIndex = findIndex(elementTypes, (t, i) => !!(target.elementFlags[i] & ElementFlags.Variadic && t.flags & (TypeFlags.Never | TypeFlags.Union)));
            if (unionIndex >= 0) {
                return checkCrossProductUnion(map(elementTypes, (t, i) => target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType)) ?
                    mapType(elementTypes[unionIndex], t => createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))) :
                    errorType;
            }
        }
        // We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
        // elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
        // (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
        // (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
        // In either layout, zero or more generic variadic elements may be present at any location.
        const expandedTypes: Type[] = [];
        const expandedFlags: ElementFlags[] = [];
        const expandedDeclarations: (NamedTupleMember | ParameterDeclaration | undefined)[] = [];
        let lastRequiredIndex = -1;
        let firstRestIndex = -1;
        let lastOptionalOrRestIndex = -1;
        for (let i = 0; i < elementTypes.length; i++) {
            const type = elementTypes[i];
            const flags = target.elementFlags[i];
            if (flags & ElementFlags.Variadic) {
                if (type.flags & TypeFlags.Any) {
                    addElement(type, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);
                }
                else if (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type)) {
                    // Generic variadic elements stay as they are.
                    addElement(type, ElementFlags.Variadic, target.labeledElementDeclarations?.[i]);
                }
                else if (isTupleType(type)) {
                    const elements = getElementTypes(type);
                    if (elements.length + expandedTypes.length >= 10_000) {
                        error(
                            currentNode,
                            isPartOfTypeNode(currentNode!)
                                ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent
                                : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent,
                        );
                        return errorType;
                    }
                    // Spread variadic elements with tuple types into the resulting tuple.
                    forEach(elements, (t, n) => addElement(t, type.target.elementFlags[n], type.target.labeledElementDeclarations?.[n]));
                }
                else {
                    // Treat everything else as an array type and create a rest element.
                    addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);
                }
            }
            else {
                // Copy other element kinds with no change.
                addElement(type, flags, target.labeledElementDeclarations?.[i]);
            }
        }
        // Turn optional elements preceding the last required element into required elements
        for (let i = 0; i < lastRequiredIndex; i++) {
            if (expandedFlags[i] & ElementFlags.Optional) expandedFlags[i] = ElementFlags.Required;
        }
        if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
            // Turn elements between first rest and last optional/rest into a single rest element
            expandedTypes[firstRestIndex] = getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), (t, i) => expandedFlags[firstRestIndex + i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t));
            expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
        }
        const tupleTarget = getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations);
        return tupleTarget === emptyGenericType ? emptyObjectType :
            expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :
            tupleTarget;

        function addElement(type: Type, flags: ElementFlags, declaration: NamedTupleMember | ParameterDeclaration | undefined) {
            if (flags & ElementFlags.Required) {
                lastRequiredIndex = expandedFlags.length;
            }
            if (flags & ElementFlags.Rest && firstRestIndex < 0) {
                firstRestIndex = expandedFlags.length;
            }
            if (flags & (ElementFlags.Optional | ElementFlags.Rest)) {
                lastOptionalOrRestIndex = expandedFlags.length;
            }
            expandedTypes.push(flags & ElementFlags.Optional ? addOptionality(type, /*isProperty*/ true) : type);
            expandedFlags.push(flags);
            expandedDeclarations.push(declaration);
        }
    }

    function sliceTupleType(type: TupleTypeReference, index: number, endSkipCount = 0) {
        const target = type.target;
        const endIndex = getTypeReferenceArity(type) - endSkipCount;
        return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(emptyArray) :
            createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), /*readonly*/ false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex));
    }

    function getKnownKeysOfTupleType(type: TupleTypeReference) {
        return getUnionType(append(arrayOf(type.target.fixedLength, i => getStringLiteralType("" + i)), getIndexType(type.target.readonly ? globalReadonlyArrayType : globalArrayType)));
    }

    // Return count of starting consecutive tuple elements of the given kind(s)
    function getStartElementCount(type: TupleType, flags: ElementFlags) {
        const index = findIndex(type.elementFlags, f => !(f & flags));
        return index >= 0 ? index : type.elementFlags.length;
    }

    // Return count of ending consecutive tuple elements of the given kind(s)
    function getEndElementCount(type: TupleType, flags: ElementFlags) {
        return type.elementFlags.length - findLastIndex(type.elementFlags, f => !(f & flags)) - 1;
    }

    function getTotalFixedElementCount(type: TupleType) {
        return type.fixedLength + getEndElementCount(type, ElementFlags.Fixed);
    }

    function getElementTypes(type: TupleTypeReference): readonly Type[] {
        const typeArguments = getTypeArguments(type);
        const arity = getTypeReferenceArity(type);
        return typeArguments.length === arity ? typeArguments : typeArguments.slice(0, arity);
    }

    function getTypeFromOptionalTypeNode(node: OptionalTypeNode): Type {
        return addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true);
    }

    function getTypeId(type: Type): TypeId {
        return type.id;
    }

    function containsType(types: readonly Type[], type: Type): boolean {
        return binarySearch(types, type, getTypeId, compareValues) >= 0;
    }

    function insertType(types: Type[], type: Type): boolean {
        const index = binarySearch(types, type, getTypeId, compareValues);
        if (index < 0) {
            types.splice(~index, 0, type);
            return true;
        }
        return false;
    }

    function addTypeToUnion(typeSet: Type[], includes: TypeFlags, type: Type) {
        const flags = type.flags;
        // We ignore 'never' types in unions
        if (!(flags & TypeFlags.Never)) {
            includes |= flags & TypeFlags.IncludesMask;
            if (flags & TypeFlags.Instantiable) includes |= TypeFlags.IncludesInstantiable;
            if (flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) includes |= TypeFlags.IncludesConstrainedTypeVariable;
            if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
            if (isErrorType(type)) includes |= TypeFlags.IncludesError;
            if (!strictNullChecks && flags & TypeFlags.Nullable) {
                if (!(getObjectFlags(type) & ObjectFlags.ContainsWideningType)) includes |= TypeFlags.IncludesNonWideningType;
            }
            else {
                const len = typeSet.length;
                const index = len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues);
                if (index < 0) {
                    typeSet.splice(~index, 0, type);
                }
            }
        }
        return includes;
    }

    // Add the given types to the given type set. Order is preserved, duplicates are removed,
    // and nested types of the given kind are flattened into the set.
    function addTypesToUnion(typeSet: Type[], includes: TypeFlags, types: readonly Type[]): TypeFlags {
        let lastType: Type | undefined;
        for (const type of types) {
            // We skip the type if it is the same as the last type we processed. This simple test particularly
            // saves a lot of work for large lists of the same union type, such as when resolving `Record<A, B>[A]`,
            // where A and B are large union types.
            if (type !== lastType) {
                includes = type.flags & TypeFlags.Union ?
                    addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? TypeFlags.Union : 0), (type as UnionType).types) :
                    addTypeToUnion(typeSet, includes, type);
                lastType = type;
            }
        }
        return includes;
    }

    function removeSubtypes(types: Type[], hasObjectTypes: boolean): Type[] | undefined {
        // [] and [T] immediately reduce to [] and [T] respectively
        if (types.length < 2) {
            return types;
        }

        const id = getTypeListId(types);
        const match = subtypeReductionCache.get(id);
        if (match) {
            return match;
        }

        // We assume that redundant primitive types have already been removed from the types array and that there
        // are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
        // object types, and if none of those are present we can exclude primitive types from the subtype check.
        const hasEmptyObject = hasObjectTypes && some(types, t => !!(t.flags & TypeFlags.Object) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t as ObjectType)));
        const len = types.length;
        let i = len;
        let count = 0;
        while (i > 0) {
            i--;
            const source = types[i];
            if (hasEmptyObject || source.flags & TypeFlags.StructuredOrInstantiable) {
                // A type parameter with a union constraint may be a subtype of some union, but not a subtype of the
                // individual constituents of that union. For example, `T extends A | B` is a subtype of `A | B`, but not
                // a subtype of just `A` or just `B`. When we encounter such a type parameter, we therefore check if the
                // type parameter is a subtype of a union of all the other types.
                if (source.flags & TypeFlags.TypeParameter && getBaseConstraintOrType(source).flags & TypeFlags.Union) {
                    if (isTypeRelatedTo(source, getUnionType(map(types, t => t === source ? neverType : t)), strictSubtypeRelation)) {
                        orderedRemoveItemAt(types, i);
                    }
                    continue;
                }
                // Find the first property with a unit type, if any. When constituents have a property by the same name
                // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
                // reduction of large discriminated union types.
                const keyProperty = source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ?
                    find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) :
                    undefined;
                const keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                for (const target of types) {
                    if (source !== target) {
                        if (count === 100000) {
                            // After 100000 subtype checks we estimate the remaining amount of work by assuming the
                            // same ratio of checks per element. If the estimated number of remaining type checks is
                            // greater than 1M we deem the union type too complex to represent. This for example
                            // caps union types at 1000 unique object types.
                            const estimatedCount = (count / (len - i)) * len;
                            if (estimatedCount > 1000000) {
                                tracing?.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", { typeIds: types.map(t => t.id) });
                                error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                                return undefined;
                            }
                        }
                        count++;
                        if (keyProperty && target.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {
                            const t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
                            if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                                continue;
                            }
                        }
                        if (
                            isTypeRelatedTo(source, target, strictSubtypeRelation) && (
                                !(getObjectFlags(getTargetType(source)) & ObjectFlags.Class) ||
                                !(getObjectFlags(getTargetType(target)) & ObjectFlags.Class) ||
                                isTypeDerivedFrom(source, target)
                            )
                        ) {
                            orderedRemoveItemAt(types, i);
                            break;
                        }
                    }
                }
            }
        }
        subtypeReductionCache.set(id, types);
        return types;
    }

    function removeRedundantLiteralTypes(types: Type[], includes: TypeFlags, reduceVoidUndefined: boolean) {
        let i = types.length;
        while (i > 0) {
            i--;
            const t = types[i];
            const flags = t.flags;
            const remove = flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.String ||
                flags & TypeFlags.NumberLiteral && includes & TypeFlags.Number ||
                flags & TypeFlags.BigIntLiteral && includes & TypeFlags.BigInt ||
                flags & TypeFlags.UniqueESSymbol && includes & TypeFlags.ESSymbol ||
                reduceVoidUndefined && flags & TypeFlags.Undefined && includes & TypeFlags.Void ||
                isFreshLiteralType(t) && containsType(types, (t as LiteralType).regularType);
            if (remove) {
                orderedRemoveItemAt(types, i);
            }
        }
    }

    function removeStringLiteralsMatchedByTemplateLiterals(types: Type[]) {
        const templates = filter(types, isPatternLiteralType) as (TemplateLiteralType | StringMappingType)[];
        if (templates.length) {
            let i = types.length;
            while (i > 0) {
                i--;
                const t = types[i];
                if (t.flags & TypeFlags.StringLiteral && some(templates, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {
                    orderedRemoveItemAt(types, i);
                }
            }
        }
    }

    function isTypeMatchedByTemplateLiteralOrStringMapping(type: Type, template: TemplateLiteralType | StringMappingType) {
        return template.flags & TypeFlags.TemplateLiteral ?
            isTypeMatchedByTemplateLiteralType(type, template as TemplateLiteralType) :
            isMemberOfStringMapping(type, template);
    }

    function removeConstrainedTypeVariables(types: Type[]) {
        const typeVariables: TypeVariable[] = [];
        // First collect a list of the type variables occurring in constraining intersections.
        for (const type of types) {
            if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {
                const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;
                pushIfUnique(typeVariables, (type as IntersectionType).types[index]);
            }
        }
        // For each type variable, check if the constraining intersections for that type variable fully
        // cover the constraint of the type variable; if so, remove the constraining intersections and
        // substitute the type variable.
        for (const typeVariable of typeVariables) {
            const primitives: Type[] = [];
            // First collect the primitive types from the constraining intersections.
            for (const type of types) {
                if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {
                    const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;
                    if ((type as IntersectionType).types[index] === typeVariable) {
                        insertType(primitives, (type as IntersectionType).types[1 - index]);
                    }
                }
            }
            // If every constituent in the type variable's constraint is covered by an intersection of the type
            // variable and that constituent, remove those intersections and substitute the type variable.
            const constraint = getBaseConstraintOfType(typeVariable)!;
            if (everyType(constraint, t => containsType(primitives, t))) {
                let i = types.length;
                while (i > 0) {
                    i--;
                    const type = types[i];
                    if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {
                        const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;
                        if ((type as IntersectionType).types[index] === typeVariable && containsType(primitives, (type as IntersectionType).types[1 - index])) {
                            orderedRemoveItemAt(types, i);
                        }
                    }
                }
                insertType(types, typeVariable);
            }
        }
    }

    function isNamedUnionType(type: Type) {
        return !!(type.flags & TypeFlags.Union && (type.aliasSymbol || (type as UnionType).origin));
    }

    function addNamedUnions(namedUnions: Type[], types: readonly Type[]) {
        for (const t of types) {
            if (t.flags & TypeFlags.Union) {
                const origin = (t as UnionType).origin;
                if (t.aliasSymbol || origin && !(origin.flags & TypeFlags.Union)) {
                    pushIfUnique(namedUnions, t);
                }
                else if (origin && origin.flags & TypeFlags.Union) {
                    addNamedUnions(namedUnions, (origin as UnionType).types);
                }
            }
        }
    }

    function createOriginUnionOrIntersectionType(flags: TypeFlags, types: Type[]) {
        const result = createOriginType(flags) as UnionOrIntersectionType;
        result.types = types;
        return result;
    }

    // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
    // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
    // of other types. Subtype reduction is expensive for large union types and is possible only when union
    // types are known not to circularly reference themselves (as is the case with union types created by
    // expression constructs such as array literals and the || and ?: operators). Named types can
    // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
    // For example, "type Item = string | (() => Item)" is a named type that circularly references itself.
    function getUnionType(types: readonly Type[], unionReduction: UnionReduction = UnionReduction.Literal, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[], origin?: Type): Type {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        // We optimize for the common case of unioning a union type with some other type (such as `undefined`).
        if (types.length === 2 && !origin && (types[0].flags & TypeFlags.Union || types[1].flags & TypeFlags.Union)) {
            const infix = unionReduction === UnionReduction.None ? "N" : unionReduction === UnionReduction.Subtype ? "S" : "L";
            const index = types[0].id < types[1].id ? 0 : 1;
            const id = types[index].id + infix + types[1 - index].id + getAliasId(aliasSymbol, aliasTypeArguments);
            let type = unionOfUnionTypes.get(id);
            if (!type) {
                type = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, /*origin*/ undefined);
                unionOfUnionTypes.set(id, type);
            }
            return type;
        }
        return getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin);
    }

    function getUnionTypeWorker(types: readonly Type[], unionReduction: UnionReduction, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined, origin: Type | undefined): Type {
        let typeSet: Type[] | undefined = [];
        const includes = addTypesToUnion(typeSet, 0 as TypeFlags, types);
        if (unionReduction !== UnionReduction.None) {
            if (includes & TypeFlags.AnyOrUnknown) {
                return includes & TypeFlags.Any ?
                    includes & TypeFlags.IncludesWildcard ? wildcardType :
                        includes & TypeFlags.IncludesError ? errorType : anyType :
                    unknownType;
            }
            if (includes & TypeFlags.Undefined) {
                // If type set contains both undefinedType and missingType, remove missingType
                if (typeSet.length >= 2 && typeSet[0] === undefinedType && typeSet[1] === missingType) {
                    orderedRemoveItemAt(typeSet, 1);
                }
            }
            if (includes & (TypeFlags.Enum | TypeFlags.Literal | TypeFlags.UniqueESSymbol | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) || includes & TypeFlags.Void && includes & TypeFlags.Undefined) {
                removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReduction.Subtype));
            }
            if (includes & TypeFlags.StringLiteral && includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping)) {
                removeStringLiteralsMatchedByTemplateLiterals(typeSet);
            }
            if (includes & TypeFlags.IncludesConstrainedTypeVariable) {
                removeConstrainedTypeVariables(typeSet);
            }
            if (unionReduction === UnionReduction.Subtype) {
                typeSet = removeSubtypes(typeSet, !!(includes & TypeFlags.Object));
                if (!typeSet) {
                    return errorType;
                }
            }
            if (typeSet.length === 0) {
                return includes & TypeFlags.Null ? includes & TypeFlags.IncludesNonWideningType ? nullType : nullWideningType :
                    includes & TypeFlags.Undefined ? includes & TypeFlags.IncludesNonWideningType ? undefinedType : undefinedWideningType :
                    neverType;
            }
        }
        if (!origin && includes & TypeFlags.Union) {
            const namedUnions: Type[] = [];
            addNamedUnions(namedUnions, types);
            const reducedTypes: Type[] = [];
            for (const t of typeSet) {
                if (!some(namedUnions, union => containsType((union as UnionType).types, t))) {
                    reducedTypes.push(t);
                }
            }
            if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
                return namedUnions[0];
            }
            // We create a denormalized origin type only when the union was created from one or more named unions
            // (unions with alias symbols or origins) and when there is no overlap between those named unions.
            const namedTypesCount = reduceLeft(namedUnions, (sum, union) => sum + (union as UnionType).types.length, 0);
            if (namedTypesCount + reducedTypes.length === typeSet.length) {
                for (const t of namedUnions) {
                    insertType(reducedTypes, t);
                }
                origin = createOriginUnionOrIntersectionType(TypeFlags.Union, reducedTypes);
            }
        }
        const objectFlags = (includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion) |
            (includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0);
        return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin);
    }

    function getUnionOrIntersectionTypePredicate(signatures: readonly Signature[], kind: TypeFlags | undefined): TypePredicate | undefined {
        let last: TypePredicate | undefined;
        const types: Type[] = [];
        for (const sig of signatures) {
            const pred = getTypePredicateOfSignature(sig);
            if (pred) {
                // Constituent type predicates must all have matching kinds. We don't create composite type predicates for assertions.
                if (pred.kind !== TypePredicateKind.This && pred.kind !== TypePredicateKind.Identifier || last && !typePredicateKindsMatch(last, pred)) {
                    return undefined;
                }
                last = pred;
                types.push(pred.type);
            }
            else {
                // In composite union signatures we permit and ignore signatures with a return type `false`.
                const returnType = kind !== TypeFlags.Intersection ? getReturnTypeOfSignature(sig) : undefined;
                if (returnType !== falseType && returnType !== regularFalseType) {
                    return undefined;
                }
            }
        }
        if (!last) {
            return undefined;
        }
        const compositeType = getUnionOrIntersectionType(types, kind);
        return createTypePredicate(last.kind, last.parameterName, last.parameterIndex, compositeType);
    }

    function typePredicateKindsMatch(a: TypePredicate, b: TypePredicate): boolean {
        return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
    }

    // This function assumes the constituent type list is sorted and deduplicated.
    function getUnionTypeFromSortedList(types: Type[], precomputedObjectFlags: ObjectFlags, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[], origin?: Type): Type {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        const typeKey = !origin ? getTypeListId(types) :
            origin.flags & TypeFlags.Union ? `|${getTypeListId((origin as UnionType).types)}` :
            origin.flags & TypeFlags.Intersection ? `&${getTypeListId((origin as IntersectionType).types)}` :
            `#${(origin as IndexType).type.id}|${getTypeListId(types)}`; // origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
        const id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
        let type = unionTypes.get(id);
        if (!type) {
            type = createType(TypeFlags.Union) as UnionType;
            type.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds*/ TypeFlags.Nullable);
            type.types = types;
            type.origin = origin;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            if (types.length === 2 && types[0].flags & TypeFlags.BooleanLiteral && types[1].flags & TypeFlags.BooleanLiteral) {
                type.flags |= TypeFlags.Boolean;
                (type as UnionType & IntrinsicType).intrinsicName = "boolean";
            }
            unionTypes.set(id, type);
        }
        return type;
    }

    function getTypeFromUnionTypeNode(node: UnionTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            links.resolvedType = getUnionType(map(node.types, getTypeFromTypeNode), UnionReduction.Literal, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
        }
        return links.resolvedType;
    }

    function addTypeToIntersection(typeSet: Map<string, Type>, includes: TypeFlags, type: Type) {
        const flags = type.flags;
        if (flags & TypeFlags.Intersection) {
            return addTypesToIntersection(typeSet, includes, (type as IntersectionType).types);
        }
        if (isEmptyAnonymousObjectType(type)) {
            if (!(includes & TypeFlags.IncludesEmptyObject)) {
                includes |= TypeFlags.IncludesEmptyObject;
                typeSet.set(type.id.toString(), type);
            }
        }
        else {
            if (flags & TypeFlags.AnyOrUnknown) {
                if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
                if (isErrorType(type)) includes |= TypeFlags.IncludesError;
            }
            else if (strictNullChecks || !(flags & TypeFlags.Nullable)) {
                if (type === missingType) {
                    includes |= TypeFlags.IncludesMissingType;
                    type = undefinedType;
                }
                if (!typeSet.has(type.id.toString())) {
                    if (type.flags & TypeFlags.Unit && includes & TypeFlags.Unit) {
                        // We have seen two distinct unit types which means we should reduce to an
                        // empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
                        includes |= TypeFlags.NonPrimitive;
                    }
                    typeSet.set(type.id.toString(), type);
                }
            }
            includes |= flags & TypeFlags.IncludesMask;
        }
        return includes;
    }

    // Add the given types to the given type set. Order is preserved, freshness is removed from literal
    // types, duplicates are removed, and nested types of the given kind are flattened into the set.
    function addTypesToIntersection(typeSet: Map<string, Type>, includes: TypeFlags, types: readonly Type[]) {
        for (const type of types) {
            includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
        }
        return includes;
    }

    function removeRedundantSupertypes(types: Type[], includes: TypeFlags) {
        let i = types.length;
        while (i > 0) {
            i--;
            const t = types[i];
            const remove = t.flags & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||
                t.flags & TypeFlags.Number && includes & TypeFlags.NumberLiteral ||
                t.flags & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral ||
                t.flags & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol ||
                t.flags & TypeFlags.Void && includes & TypeFlags.Undefined ||
                isEmptyAnonymousObjectType(t) && includes & TypeFlags.DefinitelyNonNullable;
            if (remove) {
                orderedRemoveItemAt(types, i);
            }
        }
    }

    // Check that the given type has a match in every union. A given type is matched by
    // an identical type, and a literal type is additionally matched by its corresponding
    // primitive type, and missingType is matched by undefinedType (and vice versa).
    function eachUnionContains(unionTypes: UnionType[], type: Type) {
        for (const u of unionTypes) {
            if (!containsType(u.types, type)) {
                if (type === missingType) {
                    return containsType(u.types, undefinedType);
                }
                if (type === undefinedType) {
                    return containsType(u.types, missingType);
                }
                const primitive = type.flags & TypeFlags.StringLiteral ? stringType :
                    type.flags & (TypeFlags.Enum | TypeFlags.NumberLiteral) ? numberType :
                    type.flags & TypeFlags.BigIntLiteral ? bigintType :
                    type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :
                    undefined;
                if (!primitive || !containsType(u.types, primitive)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Returns true if the intersection of the template literals and string literals is the empty set,
     * for example `get${string}` & "setX", and should reduce to never.
     */
    function extractRedundantTemplateLiterals(types: Type[]): boolean {
        let i = types.length;
        const literals = filter(types, t => !!(t.flags & TypeFlags.StringLiteral));
        while (i > 0) {
            i--;
            const t = types[i];
            if (!(t.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping))) continue;
            for (const t2 of literals) {
                if (isTypeSubtypeOf(t2, t)) {
                    // For example, `get${T}` & "getX" is just "getX", and Lowercase<string> & "foo" is just "foo"
                    orderedRemoveItemAt(types, i);
                    break;
                }
                else if (isPatternLiteralType(t)) {
                    return true;
                }
            }
        }
        return false;
    }

    function removeFromEach(types: Type[], flag: TypeFlags) {
        for (let i = 0; i < types.length; i++) {
            types[i] = filterType(types[i], t => !(t.flags & flag));
        }
    }

    // If the given list of types contains more than one union of primitive types, replace the
    // first with a union containing an intersection of those primitive types, then remove the
    // other unions and return true. Otherwise, do nothing and return false.
    function intersectUnionsOfPrimitiveTypes(types: Type[]) {
        let unionTypes: UnionType[] | undefined;
        const index = findIndex(types, t => !!(getObjectFlags(t) & ObjectFlags.PrimitiveUnion));
        if (index < 0) {
            return false;
        }
        let i = index + 1;
        // Remove all but the first union of primitive types and collect them in
        // the unionTypes array.
        while (i < types.length) {
            const t = types[i];
            if (getObjectFlags(t) & ObjectFlags.PrimitiveUnion) {
                (unionTypes || (unionTypes = [types[index] as UnionType])).push(t as UnionType);
                orderedRemoveItemAt(types, i);
            }
            else {
                i++;
            }
        }
        // Return false if there was only one union of primitive types
        if (!unionTypes) {
            return false;
        }
        // We have more than one union of primitive types, now intersect them. For each
        // type in each union we check if the type is matched in every union and if so
        // we include it in the result.
        const checked: Type[] = [];
        const result: Type[] = [];
        for (const u of unionTypes) {
            for (const t of u.types) {
                if (insertType(checked, t)) {
                    if (eachUnionContains(unionTypes, t)) {
                        // undefinedType/missingType should always come sorted first so we leverage that here
                        if (t === undefinedType && result.length && result[0] === missingType) {
                            continue;
                        }
                        if (t === missingType && result.length && result[0] === undefinedType) {
                            result[0] = missingType;
                            continue;
                        }
                        insertType(result, t);
                    }
                }
            }
        }
        // Finally replace the first union with the result
        types[index] = getUnionTypeFromSortedList(result, ObjectFlags.PrimitiveUnion);
        return true;
    }

    function createIntersectionType(types: Type[], objectFlags: ObjectFlags, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]) {
        const result = createType(TypeFlags.Intersection) as IntersectionType;
        result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds*/ TypeFlags.Nullable);
        result.types = types;
        result.aliasSymbol = aliasSymbol;
        result.aliasTypeArguments = aliasTypeArguments;
        return result;
    }

    // We normalize combinations of intersection and union types based on the distributive property of the '&'
    // operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
    // types with union type constituents into equivalent union types with intersection type constituents and
    // effectively ensure that union types are always at the top level in type representations.
    //
    // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
    // type operator and we can't reduce those because we want to support recursive intersection types. For example,
    // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
    // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
    // for intersections of types with signatures can be deterministic.
    function getIntersectionType(types: readonly Type[], flags = IntersectionFlags.None, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        const typeMembershipMap = new Map<string, Type>();
        const includes = addTypesToIntersection(typeMembershipMap, 0 as TypeFlags, types);
        const typeSet: Type[] = arrayFrom(typeMembershipMap.values());
        let objectFlags = ObjectFlags.None;
        // An intersection type is considered empty if it contains
        // the type never, or
        // more than one unit type or,
        // an object type and a nullable type (null or undefined), or
        // a string-like type and a type known to be non-string-like, or
        // a number-like type and a type known to be non-number-like, or
        // a symbol-like type and a type known to be non-symbol-like, or
        // a void-like type and a type known to be non-void-like, or
        // a non-primitive type and a type known to be primitive.
        if (includes & TypeFlags.Never) {
            return contains(typeSet, silentNeverType) ? silentNeverType : neverType;
        }
        if (
            strictNullChecks && includes & TypeFlags.Nullable && includes & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.IncludesEmptyObject) ||
            includes & TypeFlags.NonPrimitive && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NonPrimitive) ||
            includes & TypeFlags.StringLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.StringLike) ||
            includes & TypeFlags.NumberLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NumberLike) ||
            includes & TypeFlags.BigIntLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.BigIntLike) ||
            includes & TypeFlags.ESSymbolLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.ESSymbolLike) ||
            includes & TypeFlags.VoidLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.VoidLike)
        ) {
            return neverType;
        }
        if (includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.StringLiteral && extractRedundantTemplateLiterals(typeSet)) {
            return neverType;
        }
        if (includes & TypeFlags.Any) {
            return includes & TypeFlags.IncludesWildcard ? wildcardType : includes & TypeFlags.IncludesError ? errorType : anyType;
        }
        if (!strictNullChecks && includes & TypeFlags.Nullable) {
            return includes & TypeFlags.IncludesEmptyObject ? neverType : includes & TypeFlags.Undefined ? undefinedType : nullType;
        }
        if (
            includes & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||
            includes & TypeFlags.Number && includes & TypeFlags.NumberLiteral ||
            includes & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral ||
            includes & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol ||
            includes & TypeFlags.Void && includes & TypeFlags.Undefined ||
            includes & TypeFlags.IncludesEmptyObject && includes & TypeFlags.DefinitelyNonNullable
        ) {
            if (!(flags & IntersectionFlags.NoSupertypeReduction)) removeRedundantSupertypes(typeSet, includes);
        }
        if (includes & TypeFlags.IncludesMissingType) {
            typeSet[typeSet.indexOf(undefinedType)] = missingType;
        }
        if (typeSet.length === 0) {
            return unknownType;
        }
        if (typeSet.length === 1) {
            return typeSet[0];
        }
        if (typeSet.length === 2 && !(flags & IntersectionFlags.NoConstraintReduction)) {
            const typeVarIndex = typeSet[0].flags & TypeFlags.TypeVariable ? 0 : 1;
            const typeVariable = typeSet[typeVarIndex];
            const primitiveType = typeSet[1 - typeVarIndex];
            if (
                typeVariable.flags & TypeFlags.TypeVariable &&
                (primitiveType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) && !isGenericStringLikeType(primitiveType) || includes & TypeFlags.IncludesEmptyObject)
            ) {
                // We have an intersection T & P or P & T, where T is a type variable and P is a primitive type, the object type, or {}.
                const constraint = getBaseConstraintOfType(typeVariable);
                // Check that T's constraint is similarly composed of primitive types, the object type, or {}.
                if (constraint && everyType(constraint, t => !!(t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) || isEmptyAnonymousObjectType(t))) {
                    // If T's constraint is a subtype of P, simply return T. For example, given `T extends "a" | "b"`,
                    // the intersection `T & string` reduces to just T.
                    if (isTypeStrictSubtypeOf(constraint, primitiveType)) {
                        return typeVariable;
                    }
                    if (!(constraint.flags & TypeFlags.Union && someType(constraint, c => isTypeStrictSubtypeOf(c, primitiveType)))) {
                        // No constituent of T's constraint is a subtype of P. If P is also not a subtype of T's constraint,
                        // then the constraint and P are unrelated, and the intersection reduces to never. For example, given
                        // `T extends "a" | "b"`, the intersection `T & number` reduces to never.
                        if (!isTypeStrictSubtypeOf(primitiveType, constraint)) {
                            return neverType;
                        }
                    }
                    // Some constituent of T's constraint is a subtype of P, or P is a subtype of T's constraint. Thus,
                    // the intersection further constrains the type variable. For example, given `T extends string | number`,
                    // the intersection `T & "a"` is marked as a constrained type variable. Likewise, given `T extends "a" | 1`,
                    // the intersection `T & number` is marked as a constrained type variable.
                    objectFlags = ObjectFlags.IsConstrainedTypeVariable;
                }
            }
        }
        const id = getTypeListId(typeSet) + (flags & IntersectionFlags.NoConstraintReduction ? "*" : getAliasId(aliasSymbol, aliasTypeArguments));
        let result = intersectionTypes.get(id);
        if (!result) {
            if (includes & TypeFlags.Union) {
                if (intersectUnionsOfPrimitiveTypes(typeSet)) {
                    // When the intersection creates a reduced set (which might mean that *all* union types have
                    // disappeared), we restart the operation to get a new set of combined flags. Once we have
                    // reduced we'll never reduce again, so this occurs at most once.
                    result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments);
                }
                else if (every(typeSet, t => !!(t.flags & TypeFlags.Union && (t as UnionType).types[0].flags & TypeFlags.Undefined))) {
                    const containedUndefinedType = some(typeSet, containsMissingType) ? missingType : undefinedType;
                    removeFromEach(typeSet, TypeFlags.Undefined);
                    result = getUnionType([getIntersectionType(typeSet, flags), containedUndefinedType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
                }
                else if (every(typeSet, t => !!(t.flags & TypeFlags.Union && ((t as UnionType).types[0].flags & TypeFlags.Null || (t as UnionType).types[1].flags & TypeFlags.Null)))) {
                    removeFromEach(typeSet, TypeFlags.Null);
                    result = getUnionType([getIntersectionType(typeSet, flags), nullType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
                }
                else if (typeSet.length >= 3 && types.length > 2) {
                    // When we have three or more constituents, more than two inputs (to head off infinite reexpansion), some of which are unions, we employ a "divide and conquer" strategy
                    // where A & B & C & D is processed as (A & B) & (C & D). Since intersections of unions often produce far smaller
                    // unions of intersections than the full cartesian product (due to some intersections becoming `never`), this can
                    // dramatically reduce the overall work.
                    const middle = Math.floor(typeSet.length / 2);
                    result = getIntersectionType([getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)], flags, aliasSymbol, aliasTypeArguments);
                }
                else {
                    // We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
                    // the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
                    // exceeds 100000 constituents, report an error.
                    if (!checkCrossProductUnion(typeSet)) {
                        return errorType;
                    }
                    const constituents = getCrossProductIntersections(typeSet, flags);
                    // We attach a denormalized origin type when at least one constituent of the cross-product union is an
                    // intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions) and
                    // the denormalized origin has fewer constituents than the union itself.
                    const origin = some(constituents, t => !!(t.flags & TypeFlags.Intersection)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(TypeFlags.Intersection, typeSet) : undefined;
                    result = getUnionType(constituents, UnionReduction.Literal, aliasSymbol, aliasTypeArguments, origin);
                }
            }
            else {
                result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments);
            }
            intersectionTypes.set(id, result);
        }
        return result;
    }

    function getCrossProductUnionSize(types: readonly Type[]) {
        return reduceLeft(types, (n, t) => t.flags & TypeFlags.Union ? n * (t as UnionType).types.length : t.flags & TypeFlags.Never ? 0 : n, 1);
    }

    function checkCrossProductUnion(types: readonly Type[]) {
        const size = getCrossProductUnionSize(types);
        if (size >= 100000) {
            tracing?.instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit", { typeIds: types.map(t => t.id), size });
            error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
            return false;
        }
        return true;
    }

    function getCrossProductIntersections(types: readonly Type[], flags: IntersectionFlags) {
        const count = getCrossProductUnionSize(types);
        const intersections: Type[] = [];
        for (let i = 0; i < count; i++) {
            const constituents = types.slice();
            let n = i;
            for (let j = types.length - 1; j >= 0; j--) {
                if (types[j].flags & TypeFlags.Union) {
                    const sourceTypes = (types[j] as UnionType).types;
                    const length = sourceTypes.length;
                    constituents[j] = sourceTypes[n % length];
                    n = Math.floor(n / length);
                }
            }
            const t = getIntersectionType(constituents, flags);
            if (!(t.flags & TypeFlags.Never)) intersections.push(t);
        }
        return intersections;
    }

    function getConstituentCount(type: Type): number {
        return !(type.flags & TypeFlags.UnionOrIntersection) || type.aliasSymbol ? 1 :
            type.flags & TypeFlags.Union && (type as UnionType).origin ? getConstituentCount((type as UnionType).origin!) :
            getConstituentCountOfTypes((type as UnionOrIntersectionType).types);
    }

    function getConstituentCountOfTypes(types: Type[]): number {
        return reduceLeft(types, (n, t) => n + getConstituentCount(t), 0);
    }

    function getTypeFromIntersectionTypeNode(node: IntersectionTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            const types = map(node.types, getTypeFromTypeNode);
            // We perform no supertype reduction for X & {} or {} & X, where X is one of string, number, bigint,
            // or a pattern literal template type. This enables union types like "a" | "b" | string & {} or
            // "aa" | "ab" | `a${string}` which preserve the literal types for purposes of statement completion.
            const emptyIndex = types.length === 2 ? types.indexOf(emptyTypeLiteralType) : -1;
            const t = emptyIndex >= 0 ? types[1 - emptyIndex] : unknownType;
            const noSupertypeReduction = !!(t.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt) || t.flags & TypeFlags.TemplateLiteral && isPatternLiteralType(t));
            links.resolvedType = getIntersectionType(types, noSupertypeReduction ? IntersectionFlags.NoSupertypeReduction : 0, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
        }
        return links.resolvedType;
    }

    function createIndexType(type: InstantiableType | UnionOrIntersectionType, indexFlags: IndexFlags) {
        const result = createType(TypeFlags.Index) as IndexType;
        result.type = type;
        result.indexFlags = indexFlags;
        return result;
    }

    function createOriginIndexType(type: InstantiableType | UnionOrIntersectionType) {
        const result = createOriginType(TypeFlags.Index) as IndexType;
        result.type = type;
        return result;
    }

    function getIndexTypeForGenericType(type: InstantiableType | UnionOrIntersectionType, indexFlags: IndexFlags) {
        return indexFlags & IndexFlags.StringsOnly ?
            type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly)) :
            type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, IndexFlags.None));
    }

    /**
     * This roughly mirrors `resolveMappedTypeMembers` in the nongeneric case, except only reports a union of the keys calculated,
     * rather than manufacturing the properties. We can't just fetch the `constraintType` since that would ignore mappings
     * and mapping the `constraintType` directly ignores how mapped types map _properties_ and not keys (thus ignoring subtype
     * reduction in the constraintType) when possible.
     * @param noIndexSignatures Indicates if _string_ index signatures should be elided. (other index signatures are always reported)
     */
    function getIndexTypeForMappedType(type: MappedType, indexFlags: IndexFlags) {
        const typeParameter = getTypeParameterFromMappedType(type);
        const constraintType = getConstraintTypeFromMappedType(type);
        const nameType = getNameTypeFromMappedType(type.target as MappedType || type);
        if (!nameType && !(indexFlags & IndexFlags.NoIndexSignatures)) {
            // no mapping and no filtering required, just quickly bail to returning the constraint in the common case
            return constraintType;
        }
        const keyTypes: Type[] = [];
        // Calling getApparentType on the `T` of a `keyof T` in the constraint type of a generic mapped type can
        // trigger a circularity. For example, `T extends { [P in keyof T & string as Captitalize<P>]: any }` is
        // a circular definition. For this reason, we only eagerly manifest the keys if the constraint is non-generic.
        if (isGenericIndexType(constraintType)) {
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                // We have a generic index and a homomorphic mapping (but a distributive key remapping) - we need to defer
                // the whole `keyof whatever` for later since it's not safe to resolve the shape of modifier type.
                return getIndexTypeForGenericType(type, indexFlags);
            }
            // Include the generic component in the resulting type.
            forEachType(constraintType, addMemberForKeyType);
        }
        else if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
            const modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
            forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlags.StringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlags.StringsOnly), addMemberForKeyType);
        }
        else {
            forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
        }
        // We had to pick apart the constraintType to potentially map/filter it - compare the final resulting list with the
        // original constraintType, so we can return the union that preserves aliases/origin data if possible.
        const result = indexFlags & IndexFlags.NoIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (TypeFlags.Any | TypeFlags.String))) : getUnionType(keyTypes);
        if (result.flags & TypeFlags.Union && constraintType.flags & TypeFlags.Union && getTypeListId((result as UnionType).types) === getTypeListId((constraintType as UnionType).types)) {
            return constraintType;
        }
        return result;

        function addMemberForKeyType(keyType: Type) {
            const propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
            // `keyof` currently always returns `string | number` for concrete `string` index signatures - the below ternary keeps that behavior for mapped types
            // See `getLiteralTypeFromProperties` where there's a similar ternary to cause the same behavior.
            keyTypes.push(propNameType === stringType ? stringOrNumberType : propNameType);
        }
    }

    // Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
    // that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
    // want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
    // introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
    // they're the same type regardless of what's being distributed over.
    function hasDistributiveNameType(mappedType: MappedType) {
        const typeVariable = getTypeParameterFromMappedType(mappedType);
        return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable);
        function isDistributive(type: Type): boolean {
            return type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Primitive | TypeFlags.Never | TypeFlags.TypeParameter | TypeFlags.Object | TypeFlags.NonPrimitive) ? true :
                type.flags & TypeFlags.Conditional ? (type as ConditionalType).root.isDistributive && (type as ConditionalType).checkType === typeVariable :
                type.flags & (TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral) ? every((type as UnionOrIntersectionType | TemplateLiteralType).types, isDistributive) :
                type.flags & TypeFlags.IndexedAccess ? isDistributive((type as IndexedAccessType).objectType) && isDistributive((type as IndexedAccessType).indexType) :
                type.flags & TypeFlags.Substitution ? isDistributive((type as SubstitutionType).baseType) && isDistributive((type as SubstitutionType).constraint) :
                type.flags & TypeFlags.StringMapping ? isDistributive((type as StringMappingType).type) :
                false;
        }
    }

    function getLiteralTypeFromPropertyName(name: PropertyName | JsxAttributeName) {
        if (isPrivateIdentifier(name)) {
            return neverType;
        }
        if (isNumericLiteral(name)) {
            return getRegularTypeOfLiteralType(checkExpression(name));
        }
        if (isComputedPropertyName(name)) {
            return getRegularTypeOfLiteralType(checkComputedPropertyName(name));
        }
        const propertyName = getPropertyNameForPropertyNameNode(name);
        if (propertyName !== undefined) {
            return getStringLiteralType(unescapeLeadingUnderscores(propertyName));
        }
        if (isExpression(name)) {
            return getRegularTypeOfLiteralType(checkExpression(name));
        }
        return neverType;
    }

    function getLiteralTypeFromProperty(prop: Symbol, include: TypeFlags, includeNonPublic?: boolean) {
        if (includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier)) {
            let type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
            if (!type) {
                const name = getNameOfDeclaration(prop.valueDeclaration) as PropertyName | JsxAttributeName;
                type = prop.escapedName === InternalSymbolName.Default ? getStringLiteralType("default") :
                    name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined);
            }
            if (type && type.flags & include) {
                return type;
            }
        }
        return neverType;
    }

    function isKeyTypeIncluded(keyType: Type, include: TypeFlags): boolean {
        return !!(keyType.flags & include || keyType.flags & TypeFlags.Intersection && some((keyType as IntersectionType).types, t => isKeyTypeIncluded(t, include)));
    }

    function getLiteralTypeFromProperties(type: Type, include: TypeFlags, includeOrigin: boolean) {
        const origin = includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(type) : undefined;
        const propertyTypes = map(getPropertiesOfType(type), prop => getLiteralTypeFromProperty(prop, include));
        const indexKeyTypes = map(getIndexInfosOfType(type), info =>
            info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ?
                info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType : neverType);
        return getUnionType(concatenate(propertyTypes, indexKeyTypes), UnionReduction.Literal, /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, origin);
    }

    function shouldDeferIndexType(type: Type, indexFlags = IndexFlags.None) {
        return !!(type.flags & TypeFlags.InstantiableNonPrimitive ||
            isGenericTupleType(type) ||
            isGenericMappedType(type) && (!hasDistributiveNameType(type) || getMappedTypeNameTypeKind(type) === MappedTypeNameTypeKind.Remapping) ||
            type.flags & TypeFlags.Union && !(indexFlags & IndexFlags.NoReducibleCheck) && isGenericReducibleType(type) ||
            type.flags & TypeFlags.Intersection && maybeTypeOfKind(type, TypeFlags.Instantiable) && some((type as IntersectionType).types, isEmptyAnonymousObjectType));
    }

    function getIndexType(type: Type, indexFlags = IndexFlags.None): Type {
        type = getReducedType(type);
        return isNoInferType(type) ? getNoInferType(getIndexType((type as SubstitutionType).baseType, indexFlags)) :
            shouldDeferIndexType(type, indexFlags) ? getIndexTypeForGenericType(type as InstantiableType | UnionOrIntersectionType, indexFlags) :
            type.flags & TypeFlags.Union ? getIntersectionType(map((type as UnionType).types, t => getIndexType(t, indexFlags))) :
            type.flags & TypeFlags.Intersection ? getUnionType(map((type as IntersectionType).types, t => getIndexType(t, indexFlags))) :
            getObjectFlags(type) & ObjectFlags.Mapped ? getIndexTypeForMappedType(type as MappedType, indexFlags) :
            type === wildcardType ? wildcardType :
            type.flags & TypeFlags.Unknown ? neverType :
            type.flags & (TypeFlags.Any | TypeFlags.Never) ? stringNumberSymbolType :
            getLiteralTypeFromProperties(type, (indexFlags & IndexFlags.NoIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike) | (indexFlags & IndexFlags.StringsOnly ? 0 : TypeFlags.NumberLike | TypeFlags.ESSymbolLike), indexFlags === IndexFlags.None);
    }

    function getExtractStringType(type: Type) {
        const extractTypeAlias = getGlobalExtractSymbol();
        return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
    }

    function getIndexTypeOrString(type: Type): Type {
        const indexType = getExtractStringType(getIndexType(type));
        return indexType.flags & TypeFlags.Never ? stringType : indexType;
    }

    function getTypeFromTypeOperatorNode(node: TypeOperatorNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            switch (node.operator) {
                case SyntaxKind.KeyOfKeyword:
                    links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
                    break;
                case SyntaxKind.UniqueKeyword:
                    links.resolvedType = node.type.kind === SyntaxKind.SymbolKeyword
                        ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent))
                        : errorType;
                    break;
                case SyntaxKind.ReadonlyKeyword:
                    links.resolvedType = getTypeFromTypeNode(node.type);
                    break;
                default:
                    Debug.assertNever(node.operator);
            }
        }
        return links.resolvedType;
    }

    function getTypeFromTemplateTypeNode(node: TemplateLiteralTypeNode) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getTemplateLiteralType(
                [node.head.text, ...map(node.templateSpans, span => span.literal.text)],
                map(node.templateSpans, span => getTypeFromTypeNode(span.type)),
            );
        }
        return links.resolvedType;
    }

    function getTemplateLiteralType(texts: readonly string[], types: readonly Type[]): Type {
        const unionIndex = findIndex(types, t => !!(t.flags & (TypeFlags.Never | TypeFlags.Union)));
        if (unionIndex >= 0) {
            return checkCrossProductUnion(types) ?
                mapType(types[unionIndex], t => getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))) :
                errorType;
        }
        if (contains(types, wildcardType)) {
            return wildcardType;
        }
        const newTypes: Type[] = [];
        const newTexts: string[] = [];
        let text = texts[0];
        if (!addSpans(texts, types)) {
            return stringType;
        }
        if (newTypes.length === 0) {
            return getStringLiteralType(text);
        }
        newTexts.push(text);
        if (every(newTexts, t => t === "")) {
            if (every(newTypes, t => !!(t.flags & TypeFlags.String))) {
                return stringType;
            }
            // Normalize `${Mapping<xxx>}` into Mapping<xxx>
            if (newTypes.length === 1 && isPatternLiteralType(newTypes[0])) {
                return newTypes[0];
            }
        }
        const id = `${getTypeListId(newTypes)}|${map(newTexts, t => t.length).join(",")}|${newTexts.join("")}`;
        let type = templateLiteralTypes.get(id);
        if (!type) {
            templateLiteralTypes.set(id, type = createTemplateLiteralType(newTexts, newTypes));
        }
        return type;

        function addSpans(texts: readonly string[], types: readonly Type[]): boolean {
            for (let i = 0; i < types.length; i++) {
                const t = types[i];
                if (t.flags & (TypeFlags.Literal | TypeFlags.Null | TypeFlags.Undefined)) {
                    text += getTemplateStringForType(t) || "";
                    text += texts[i + 1];
                }
                else if (t.flags & TypeFlags.TemplateLiteral) {
                    text += (t as TemplateLiteralType).texts[0];
                    if (!addSpans((t as TemplateLiteralType).texts, (t as TemplateLiteralType).types)) return false;
                    text += texts[i + 1];
                }
                else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {
                    newTypes.push(t);
                    newTexts.push(text);
                    text = texts[i + 1];
                }
                else {
                    return false;
                }
            }
            return true;
        }
    }

    function getTemplateStringForType(type: Type) {
        return type.flags & TypeFlags.StringLiteral ? (type as StringLiteralType).value :
            type.flags & TypeFlags.NumberLiteral ? "" + (type as NumberLiteralType).value :
            type.flags & TypeFlags.BigIntLiteral ? pseudoBigIntToString((type as BigIntLiteralType).value) :
            type.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) ? (type as IntrinsicType).intrinsicName :
            undefined;
    }

    function createTemplateLiteralType(texts: readonly string[], types: readonly Type[]) {
        const type = createType(TypeFlags.TemplateLiteral) as TemplateLiteralType;
        type.texts = texts;
        type.types = types;
        return type;
    }

    function getStringMappingType(symbol: Symbol, type: Type): Type {
        return type.flags & (TypeFlags.Union | TypeFlags.Never) ? mapType(type, t => getStringMappingType(symbol, t)) :
            type.flags & TypeFlags.StringLiteral ? getStringLiteralType(applyStringMapping(symbol, (type as StringLiteralType).value)) :
            type.flags & TypeFlags.TemplateLiteral ? getTemplateLiteralType(...applyTemplateStringMapping(symbol, (type as TemplateLiteralType).texts, (type as TemplateLiteralType).types)) :
            // Mapping<Mapping<T>> === Mapping<T>
            type.flags & TypeFlags.StringMapping && symbol === type.symbol ? type :
            type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.StringMapping) || isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :
            // This handles Mapping<`${number}`> and Mapping<`${bigint}`>
            isPatternLiteralPlaceholderType(type) ? getStringMappingTypeForGenericType(symbol, getTemplateLiteralType(["", ""], [type])) :
            type;
    }

    function applyStringMapping(symbol: Symbol, str: string) {
        switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {
            case IntrinsicTypeKind.Uppercase:
                return str.toUpperCase();
            case IntrinsicTypeKind.Lowercase:
                return str.toLowerCase();
            case IntrinsicTypeKind.Capitalize:
                return str.charAt(0).toUpperCase() + str.slice(1);
            case IntrinsicTypeKind.Uncapitalize:
                return str.charAt(0).toLowerCase() + str.slice(1);
        }
        return str;
    }

    function applyTemplateStringMapping(symbol: Symbol, texts: readonly string[], types: readonly Type[]): [texts: readonly string[], types: readonly Type[]] {
        switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {
            case IntrinsicTypeKind.Uppercase:
                return [texts.map(t => t.toUpperCase()), types.map(t => getStringMappingType(symbol, t))];
            case IntrinsicTypeKind.Lowercase:
                return [texts.map(t => t.toLowerCase()), types.map(t => getStringMappingType(symbol, t))];
            case IntrinsicTypeKind.Capitalize:
                return [texts[0] === "" ? texts : [texts[0].charAt(0).toUpperCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];
            case IntrinsicTypeKind.Uncapitalize:
                return [texts[0] === "" ? texts : [texts[0].charAt(0).toLowerCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];
        }
        return [texts, types];
    }

    function getStringMappingTypeForGenericType(symbol: Symbol, type: Type): Type {
        const id = `${getSymbolId(symbol)},${getTypeId(type)}`;
        let result = stringMappingTypes.get(id);
        if (!result) {
            stringMappingTypes.set(id, result = createStringMappingType(symbol, type));
        }
        return result;
    }

    function createStringMappingType(symbol: Symbol, type: Type) {
        const result = createTypeWithSymbol(TypeFlags.StringMapping, symbol) as StringMappingType;
        result.type = type;
        return result;
    }

    function createIndexedAccessType(objectType: Type, indexType: Type, accessFlags: AccessFlags, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined) {
        const type = createType(TypeFlags.IndexedAccess) as IndexedAccessType;
        type.objectType = objectType;
        type.indexType = indexType;
        type.accessFlags = accessFlags;
        type.aliasSymbol = aliasSymbol;
        type.aliasTypeArguments = aliasTypeArguments;
        return type;
    }

    /**
     * Returns if a type is or consists of a JSLiteral object type
     * In addition to objects which are directly literals,
     * * unions where every element is a jsliteral
     * * intersections where at least one element is a jsliteral
     * * and instantiable types constrained to a jsliteral
     * Should all count as literals and not print errors on access or assignment of possibly existing properties.
     * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
     */
    function isJSLiteralType(type: Type): boolean {
        if (noImplicitAny) {
            return false; // Flag is meaningless under `noImplicitAny` mode
        }
        if (getObjectFlags(type) & ObjectFlags.JSLiteral) {
            return true;
        }
        if (type.flags & TypeFlags.Union) {
            return every((type as UnionType).types, isJSLiteralType);
        }
        if (type.flags & TypeFlags.Intersection) {
            return some((type as IntersectionType).types, isJSLiteralType);
        }
        if (type.flags & TypeFlags.Instantiable) {
            const constraint = getResolvedBaseConstraint(type);
            return constraint !== type && isJSLiteralType(constraint);
        }
        return false;
    }

    function getPropertyNameFromIndex(indexType: Type, accessNode: PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined) {
        return isTypeUsableAsPropertyName(indexType) ?
            getPropertyNameFromType(indexType) :
            accessNode && isPropertyName(accessNode) ?
            // late bound names are handled in the first branch, so here we only need to handle normal names
            getPropertyNameForPropertyNameNode(accessNode) :
            undefined;
    }

    function isUncalledFunctionReference(node: Node, symbol: Symbol) {
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) {
            const parent = findAncestor(node.parent, n => !isAccessExpression(n)) || node.parent;
            if (isCallLikeExpression(parent)) {
                return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node);
            }
            return every(symbol.declarations, d => !isFunctionLike(d) || isDeprecatedDeclaration(d));
        }
        return true;
    }

    function getPropertyTypeForIndexType(originalObjectType: Type, objectType: Type, indexType: Type, fullIndexType: Type, accessNode: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined, accessFlags: AccessFlags) {
        const accessExpression = accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined;
        const propName = accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode);

        if (propName !== undefined) {
            if (accessFlags & AccessFlags.Contextual) {
                return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
            }
            const prop = getPropertyOfType(objectType, propName);
            if (prop) {
                if (accessFlags & AccessFlags.ReportDeprecated && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop)) {
                    const deprecatedNode = accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode);
                    addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName as string);
                }
                if (accessExpression) {
                    markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                    if (isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression))) {
                        error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                        return undefined;
                    }
                    if (accessFlags & AccessFlags.CacheSymbol) {
                        getNodeLinks(accessNode!).resolvedSymbol = prop;
                    }
                    if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                        return autoType;
                    }
                }
                const propType = accessFlags & AccessFlags.Writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop);
                return accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(accessExpression, propType) :
                    accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) :
                    propType;
            }
            if (everyType(objectType, isTupleType) && isNumericLiteralName(propName)) {
                const index = +propName;
                if (accessNode && everyType(objectType, t => !((t as TupleTypeReference).target.combinedFlags & ElementFlags.Variable)) && !(accessFlags & AccessFlags.AllowMissing)) {
                    const indexNode = getIndexNodeForAccessExpression(accessNode);
                    if (isTupleType(objectType)) {
                        if (index < 0) {
                            error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value);
                            return undefinedType;
                        }
                        error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName));
                    }
                    else {
                        error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType));
                    }
                }
                if (index >= 0) {
                    errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                    return getTupleElementTypeOutOfStartCount(objectType, index, accessFlags & AccessFlags.IncludeUndefined ? missingType : undefined);
                }
            }
        }
        if (!(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike)) {
            if (objectType.flags & (TypeFlags.Any | TypeFlags.Never)) {
                return objectType;
            }
            // If no index signature is applicable, we default to the string index signature. In effect, this means the string
            // index signature applies even when accessing with a symbol-like type.
            const indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType);
            if (indexInfo) {
                if (accessFlags & AccessFlags.NoIndexSignatures && indexInfo.keyType !== numberType) {
                    if (accessExpression) {
                        if (accessFlags & AccessFlags.Writing) {
                            error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, typeToString(originalObjectType));
                        }
                        else {
                            error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                        }
                    }
                    return undefined;
                }
                if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number)) {
                    const indexNode = getIndexNodeForAccessExpression(accessNode);
                    error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                    return accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, missingType]) : indexInfo.type;
                }
                errorIfWritingToReadonlyIndex(indexInfo);
                // When accessing an enum object with its own type,
                // e.g. E[E.A] for enum E { A }, undefined shouldn't
                // be included in the result type
                if (
                    (accessFlags & AccessFlags.IncludeUndefined) &&
                    !(objectType.symbol &&
                        objectType.symbol.flags & (SymbolFlags.RegularEnum | SymbolFlags.ConstEnum) &&
                        (indexType.symbol &&
                            indexType.flags & TypeFlags.EnumLiteral &&
                            getParentOfSymbol(indexType.symbol) === objectType.symbol))
                ) {
                    return getUnionType([indexInfo.type, missingType]);
                }
                return indexInfo.type;
            }
            if (indexType.flags & TypeFlags.Never) {
                return neverType;
            }
            if (isJSLiteralType(objectType)) {
                return anyType;
            }
            if (accessExpression && !isConstEnumObjectType(objectType)) {
                if (isObjectLiteralType(objectType)) {
                    if (noImplicitAny && indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral)) {
                        diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType)));
                        return undefinedType;
                    }
                    else if (indexType.flags & (TypeFlags.Number | TypeFlags.String)) {
                        const types = map((objectType as ResolvedType).properties, property => {
                            return getTypeOfSymbol(property);
                        });
                        return getUnionType(append(types, undefinedType));
                    }
                }

                if (objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports!.has(propName) && (globalThisSymbol.exports!.get(propName)!.flags & SymbolFlags.BlockScoped)) {
                    error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType));
                }
                else if (noImplicitAny && !(accessFlags & AccessFlags.SuppressNoImplicitAnyError)) {
                    if (propName !== undefined && typeHasStaticProperty(propName, objectType)) {
                        const typeName = typeToString(objectType);
                        error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName as string, typeName, typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]");
                    }
                    else if (getIndexTypeOfType(objectType, numberType)) {
                        error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                    }
                    else {
                        let suggestion: string | undefined;
                        if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName as string, objectType))) {
                            if (suggestion !== undefined) {
                                error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName as string, typeToString(objectType), suggestion);
                            }
                        }
                        else {
                            const suggestion = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                            if (suggestion !== undefined) {
                                error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion);
                            }
                            else {
                                let errorInfo: DiagnosticMessageChain | undefined;
                                if (indexType.flags & TypeFlags.EnumLiteral) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                                }
                                else if (indexType.flags & TypeFlags.UniqueESSymbol) {
                                    const symbolName = getFullyQualifiedName((indexType as UniqueESSymbolType).symbol, accessExpression);
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName + "]", typeToString(objectType));
                                }
                                else if (indexType.flags & TypeFlags.StringLiteral) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType));
                                }
                                else if (indexType.flags & TypeFlags.NumberLiteral) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as NumberLiteralType).value, typeToString(objectType));
                                }
                                else if (indexType.flags & (TypeFlags.Number | TypeFlags.String)) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                                }

                                errorInfo = chainDiagnosticMessages(
                                    errorInfo,
                                    Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1,
                                    typeToString(fullIndexType),
                                    typeToString(objectType),
                                );
                                diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo));
                            }
                        }
                    }
                }
                return undefined;
            }
        }
        if (accessFlags & AccessFlags.AllowMissing && isObjectLiteralType(objectType)) {
            return undefinedType;
        }
        if (isJSLiteralType(objectType)) {
            return anyType;
        }
        if (accessNode) {
            const indexNode = getIndexNodeForAccessExpression(accessNode);
            if (indexNode.kind !== SyntaxKind.BigIntLiteral && indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral)) {
                error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, "" + (indexType as StringLiteralType | NumberLiteralType).value, typeToString(objectType));
            }
            else if (indexType.flags & (TypeFlags.String | TypeFlags.Number)) {
                error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
            }
            else {
                const typeString = indexNode.kind === SyntaxKind.BigIntLiteral ? "bigint" : typeToString(indexType);
                error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeString);
            }
        }
        if (isTypeAny(indexType)) {
            return indexType;
        }
        return undefined;

        function errorIfWritingToReadonlyIndex(indexInfo: IndexInfo | undefined): void {
            if (indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression))) {
                error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
            }
        }
    }

    function getIndexNodeForAccessExpression(accessNode: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression) {
        return accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode.argumentExpression :
            accessNode.kind === SyntaxKind.IndexedAccessType ? accessNode.indexType :
            accessNode.kind === SyntaxKind.ComputedPropertyName ? accessNode.expression :
            accessNode;
    }

    function isPatternLiteralPlaceholderType(type: Type): boolean {
        if (type.flags & TypeFlags.Intersection) {
            // Return true if the intersection consists of one or more placeholders and zero or
            // more object type tags.
            let seenPlaceholder = false;
            for (const t of (type as IntersectionType).types) {
                if (t.flags & (TypeFlags.Literal | TypeFlags.Nullable) || isPatternLiteralPlaceholderType(t)) {
                    seenPlaceholder = true;
                }
                else if (!(t.flags & TypeFlags.Object)) {
                    return false;
                }
            }
            return seenPlaceholder;
        }
        return !!(type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt)) || isPatternLiteralType(type);
    }

    function isPatternLiteralType(type: Type) {
        // A pattern literal type is a template literal or a string mapping type that contains only
        // non-generic pattern literal placeholders.
        return !!(type.flags & TypeFlags.TemplateLiteral) && every((type as TemplateLiteralType).types, isPatternLiteralPlaceholderType) ||
            !!(type.flags & TypeFlags.StringMapping) && isPatternLiteralPlaceholderType((type as StringMappingType).type);
    }

    function isGenericStringLikeType(type: Type) {
        return !!(type.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping)) && !isPatternLiteralType(type);
    }

    function isGenericType(type: Type): boolean {
        return !!getGenericObjectFlags(type);
    }

    function isGenericObjectType(type: Type): boolean {
        return !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericObjectType);
    }

    function isGenericIndexType(type: Type): boolean {
        return !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericIndexType);
    }

    function getGenericObjectFlags(type: Type): ObjectFlags {
        if (type.flags & (TypeFlags.UnionOrIntersection)) {
            if (!((type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericTypeComputed)) {
                (type as UnionOrIntersectionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |
                    reduceLeft((type as UnionOrIntersectionType).types, (flags, t) => flags | getGenericObjectFlags(t), 0);
            }
            return (type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericType;
        }
        if (type.flags & TypeFlags.Substitution) {
            if (!((type as SubstitutionType).objectFlags & ObjectFlags.IsGenericTypeComputed)) {
                (type as SubstitutionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |
                    getGenericObjectFlags((type as SubstitutionType).baseType) | getGenericObjectFlags((type as SubstitutionType).constraint);
            }
            return (type as SubstitutionType).objectFlags & ObjectFlags.IsGenericType;
        }
        return (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0) |
            (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index) || isGenericStringLikeType(type) ? ObjectFlags.IsGenericIndexType : 0);
    }

    function getSimplifiedType(type: Type, writing: boolean): Type {
        return type.flags & TypeFlags.IndexedAccess ? getSimplifiedIndexedAccessType(type as IndexedAccessType, writing) :
            type.flags & TypeFlags.Conditional ? getSimplifiedConditionalType(type as ConditionalType, writing) :
            type;
    }

    function distributeIndexOverObjectType(objectType: Type, indexType: Type, writing: boolean) {
        // (T | U)[K] -> T[K] | U[K] (reading)
        // (T | U)[K] -> T[K] & U[K] (writing)
        // (T & U)[K] -> T[K] & U[K]
        if (objectType.flags & TypeFlags.Union || objectType.flags & TypeFlags.Intersection && !shouldDeferIndexType(objectType)) {
            const types = map((objectType as UnionOrIntersectionType).types, t => getSimplifiedType(getIndexedAccessType(t, indexType), writing));
            return objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(types) : getUnionType(types);
        }
    }

    function distributeObjectOverIndexType(objectType: Type, indexType: Type, writing: boolean) {
        // T[A | B] -> T[A] | T[B] (reading)
        // T[A | B] -> T[A] & T[B] (writing)
        if (indexType.flags & TypeFlags.Union) {
            const types = map((indexType as UnionType).types, t => getSimplifiedType(getIndexedAccessType(objectType, t), writing));
            return writing ? getIntersectionType(types) : getUnionType(types);
        }
    }

    // Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
    // the type itself if no transformation is possible. The writing flag indicates that the type is
    // the target of an assignment.
    function getSimplifiedIndexedAccessType(type: IndexedAccessType, writing: boolean): Type {
        const cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
        if (type[cache]) {
            return type[cache] === circularConstraintType ? type : type[cache];
        }
        type[cache] = circularConstraintType;
        // We recursively simplify the object type as it may in turn be an indexed access type. For example, with
        // '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
        const objectType = getSimplifiedType(type.objectType, writing);
        const indexType = getSimplifiedType(type.indexType, writing);
        // T[A | B] -> T[A] | T[B] (reading)
        // T[A | B] -> T[A] & T[B] (writing)
        const distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
        if (distributedOverIndex) {
            return type[cache] = distributedOverIndex;
        }
        // Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
        if (!(indexType.flags & TypeFlags.Instantiable)) {
            // (T | U)[K] -> T[K] | U[K] (reading)
            // (T | U)[K] -> T[K] & U[K] (writing)
            // (T & U)[K] -> T[K] & U[K]
            const distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
            if (distributedOverObject) {
                return type[cache] = distributedOverObject;
            }
        }
        // So ultimately (reading):
        // ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]

        // A generic tuple type indexed by a number exists only when the index type doesn't select a
        // fixed element. We simplify to either the combined type of all elements (when the index type
        // the actual number type) or to the combined type of all non-fixed elements.
        if (isGenericTupleType(objectType) && indexType.flags & TypeFlags.NumberLike) {
            const elementType = getElementTypeOfSliceOfTupleType(objectType, indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength, /*endSkipCount*/ 0, writing);
            if (elementType) {
                return type[cache] = elementType;
            }
        }
        // If the object type is a mapped type { [P in K]: E }, where K is generic, or { [P in K as N]: E }, where
        // K is generic and N is assignable to P, instantiate E using a mapper that substitutes the index type for P.
        // For example, for an index access { [P in K]: Box<T[P]> }[X], we construct the type Box<T[X]>.
        if (isGenericMappedType(objectType)) {
            if (getMappedTypeNameTypeKind(objectType) !== MappedTypeNameTypeKind.Remapping) {
                return type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), t => getSimplifiedType(t, writing));
            }
        }
        return type[cache] = type;
    }

    function getSimplifiedConditionalType(type: ConditionalType, writing: boolean) {
        const checkType = type.checkType;
        const extendsType = type.extendsType;
        const trueType = getTrueTypeFromConditionalType(type);
        const falseType = getFalseTypeFromConditionalType(type);
        // Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
        if (falseType.flags & TypeFlags.Never && getActualTypeVariable(trueType) === getActualTypeVariable(checkType)) {
            if (checkType.flags & TypeFlags.Any || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                return getSimplifiedType(trueType, writing);
            }
            else if (isIntersectionEmpty(checkType, extendsType)) { // Always false
                return neverType;
            }
        }
        else if (trueType.flags & TypeFlags.Never && getActualTypeVariable(falseType) === getActualTypeVariable(checkType)) {
            if (!(checkType.flags & TypeFlags.Any) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                return neverType;
            }
            else if (checkType.flags & TypeFlags.Any || isIntersectionEmpty(checkType, extendsType)) { // Always false
                return getSimplifiedType(falseType, writing);
            }
        }
        return type;
    }

    /**
     * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
     */
    function isIntersectionEmpty(type1: Type, type2: Type) {
        return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & TypeFlags.Never);
    }

    // Given an indexed access on a mapped type of the form { [P in K]: E }[X], return an instantiation of E where P is
    // replaced with X. Since this simplification doesn't account for mapped type modifiers, add 'undefined' to the
    // resulting type if the mapped type includes a '?' modifier or if the modifiers type indicates that some properties
    // are optional. If the modifiers type is generic, conservatively estimate optionality by recursively looking for
    // mapped types that include '?' modifiers.
    function substituteIndexedMappedType(objectType: MappedType, index: Type) {
        const mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
        const templateMapper = combineTypeMappers(objectType.mapper, mapper);
        const instantiatedTemplateType = instantiateType(getTemplateTypeFromMappedType(objectType.target as MappedType || objectType), templateMapper);
        const isOptional = getMappedTypeOptionality(objectType) > 0 || (isGenericType(objectType) ?
            getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0 :
            couldAccessOptionalProperty(objectType, index));
        return addOptionality(instantiatedTemplateType, /*isProperty*/ true, isOptional);
    }

    // Return true if an indexed access with the given object and index types could access an optional property.
    function couldAccessOptionalProperty(objectType: Type, indexType: Type) {
        const indexConstraint = getBaseConstraintOfType(indexType);
        return !!indexConstraint && some(getPropertiesOfType(objectType), p =>
            !!(p.flags & SymbolFlags.Optional) &&
            isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlags.StringOrNumberLiteralOrUnique), indexConstraint));
    }

    function getIndexedAccessType(objectType: Type, indexType: Type, accessFlags = AccessFlags.None, accessNode?: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
    }

    function indexTypeLessThan(indexType: Type, limit: number) {
        return everyType(indexType, t => {
            if (t.flags & TypeFlags.StringOrNumberLiteral) {
                const propName = getPropertyNameFromType(t as StringLiteralType | NumberLiteralType);
                if (isNumericLiteralName(propName)) {
                    const index = +propName;
                    return index >= 0 && index < limit;
                }
            }
            return false;
        });
    }

    function getIndexedAccessTypeOrUndefined(objectType: Type, indexType: Type, accessFlags = AccessFlags.None, accessNode?: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type | undefined {
        if (objectType === wildcardType || indexType === wildcardType) {
            return wildcardType;
        }
        objectType = getReducedType(objectType);
        // If the object type has a string index signature and no other members we know that the result will
        // always be the type of that index signature and we can simplify accordingly.
        if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number)) {
            indexType = stringType;
        }
        // In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
        // an index signature have 'undefined' included in their type.
        if (compilerOptions.noUncheckedIndexedAccess && accessFlags & AccessFlags.ExpressionPosition) accessFlags |= AccessFlags.IncludeUndefined;
        // If the index type is generic, or if the object type is generic and doesn't originate in an expression and
        // the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
        // a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
        // for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
        // preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
        // eagerly using the constraint type of 'this' at the given location.
        if (
            isGenericIndexType(indexType) || (accessNode && accessNode.kind !== SyntaxKind.IndexedAccessType ?
                isGenericTupleType(objectType) && !indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target)) :
                isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target))) || isGenericReducibleType(objectType))
        ) {
            if (objectType.flags & TypeFlags.AnyOrUnknown) {
                return objectType;
            }
            // Defer the operation by creating an indexed access type.
            const persistentAccessFlags = accessFlags & AccessFlags.Persistent;
            const id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments);
            let type = indexedAccessTypes.get(id);
            if (!type) {
                indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments));
            }

            return type;
        }
        // In the following we resolve T[K] to the type of the property in T selected by K.
        // We treat boolean as different from other unions to improve errors;
        // skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
        const apparentObjectType = getReducedApparentType(objectType);
        if (indexType.flags & TypeFlags.Union && !(indexType.flags & TypeFlags.Boolean)) {
            const propTypes: Type[] = [];
            let wasMissingProp = false;
            for (const t of (indexType as UnionType).types) {
                const propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0));
                if (propType) {
                    propTypes.push(propType);
                }
                else if (!accessNode) {
                    // If there's no error node, we can immeditely stop, since error reporting is off
                    return undefined;
                }
                else {
                    // Otherwise we set a flag and return at the end of the loop so we still mark all errors
                    wasMissingProp = true;
                }
            }
            if (wasMissingProp) {
                return undefined;
            }
            return accessFlags & AccessFlags.Writing
                ? getIntersectionType(propTypes, IntersectionFlags.None, aliasSymbol, aliasTypeArguments)
                : getUnionType(propTypes, UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
        }
        return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags | AccessFlags.CacheSymbol | AccessFlags.ReportDeprecated);
    }

    function getTypeFromIndexedAccessTypeNode(node: IndexedAccessTypeNode) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const objectType = getTypeFromTypeNode(node.objectType);
            const indexType = getTypeFromTypeNode(node.indexType);
            const potentialAlias = getAliasSymbolForTypeNode(node);
            links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlags.None, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias));
        }
        return links.resolvedType;
    }

    function getTypeFromMappedTypeNode(node: MappedTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const type = createObjectType(ObjectFlags.Mapped, node.symbol) as MappedType;
            type.declaration = node;
            type.aliasSymbol = getAliasSymbolForTypeNode(node);
            type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
            links.resolvedType = type;
            // Eagerly resolve the constraint type which forces an error if the constraint type circularly
            // references itself through one or more type aliases.
            getConstraintTypeFromMappedType(type);
        }
        return links.resolvedType;
    }

    function getActualTypeVariable(type: Type): Type {
        if (type.flags & TypeFlags.Substitution) {
            return getActualTypeVariable((type as SubstitutionType).baseType);
        }
        if (
            type.flags & TypeFlags.IndexedAccess && (
                (type as IndexedAccessType).objectType.flags & TypeFlags.Substitution ||
                (type as IndexedAccessType).indexType.flags & TypeFlags.Substitution
            )
        ) {
            return getIndexedAccessType(getActualTypeVariable((type as IndexedAccessType).objectType), getActualTypeVariable((type as IndexedAccessType).indexType));
        }
        return type;
    }

    function isSimpleTupleType(node: TypeNode): boolean {
        return isTupleTypeNode(node) && length(node.elements) > 0 &&
            !some(node.elements, e => isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken));
    }

    function isDeferredType(type: Type, checkTuples: boolean) {
        return isGenericType(type) || checkTuples && isTupleType(type) && some(getElementTypes(type), isGenericType);
    }

    function getConditionalType(root: ConditionalRoot, mapper: TypeMapper | undefined, forConstraint: boolean, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        let result;
        let extraTypes: Type[] | undefined;
        let tailCount = 0;
        // We loop here for an immediately nested conditional type in the false position, effectively treating
        // types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
        // purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
        // another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
        // cases we increment the tail recursion counter and stop after 1000 iterations.
        while (true) {
            if (tailCount === 1000) {
                error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                return errorType;
            }
            const checkType = instantiateType(getActualTypeVariable(root.checkType), mapper);
            const extendsType = instantiateType(root.extendsType, mapper);
            if (checkType === errorType || extendsType === errorType) {
                return errorType;
            }
            if (checkType === wildcardType || extendsType === wildcardType) {
                return wildcardType;
            }
            const checkTypeNode = skipTypeParentheses(root.node.checkType);
            const extendsTypeNode = skipTypeParentheses(root.node.extendsType);
            // When the check and extends types are simple tuple types of the same arity, we defer resolution of the
            // conditional type when any tuple elements are generic. This is such that non-distributable conditional
            // types can be written `[X] extends [Y] ? ...` and be deferred similarly to `X extends Y ? ...`.
            const checkTuples = isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) &&
                length((checkTypeNode as TupleTypeNode).elements) === length((extendsTypeNode as TupleTypeNode).elements);
            const checkTypeDeferred = isDeferredType(checkType, checkTuples);
            let combinedMapper: TypeMapper | undefined;
            if (root.inferTypeParameters) {
                // When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be
                // instantiated with the context, so it doesn't need the mapper for the inference context - however the constraint
                // may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].
                // [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated
                // as `number`
                // Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`
                // [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`
                // which is in turn instantiated as `Q`, which is in turn instantiated as `number`.
                // So we need to:
                //    * combine `context.nonFixingMapper` with `mapper` so their constraints can be instantiated in the context of `mapper` (otherwise they'd only get inference context information)
                //    * incorporate all of the component mappers into the combined mapper for the true and false members
                // This means we have two mappers that need applying:
                //    * The original `mapper` used to create this conditional
                //    * The mapper that maps the infer type parameter to its inference result (`context.mapper`)
                const context = createInferenceContext(root.inferTypeParameters, /*signature*/ undefined, InferenceFlags.None);
                if (mapper) {
                    context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper);
                }
                if (!checkTypeDeferred) {
                    // We don't want inferences from constraints as they may cause us to eagerly resolve the
                    // conditional type instead of deferring resolution. Also, we always want strict function
                    // types rules (i.e. proper contravariance) for inferences.
                    inferTypes(context.inferences, checkType, extendsType, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);
                }
                // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
                // those type parameters are used in type references (see getInferredTypeParameterConstraint). For
                // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
                combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;
            }
            // Instantiate the extends type including inferences for 'infer T' type parameters
            const inferredExtendsType = combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType;
            // We attempt to resolve the conditional type only when the check and extends types are non-generic
            if (!checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples)) {
                // Return falseType for a definitely false extends check. We check an instantiations of the two
                // types with type parameters mapped to the wildcard type, the most permissive instantiations
                // possible (the wildcard type is assignable to and from all types). If those are not related,
                // then no instantiations will be and we can just return the false branch type.
                if (!(inferredExtendsType.flags & TypeFlags.AnyOrUnknown) && (checkType.flags & TypeFlags.Any || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                    // Return union of trueType and falseType for 'any' since it matches anything. Furthermore, for a
                    // distributive conditional type applied to the constraint of a type variable, include trueType if
                    // there are possible values of the check type that are also possible values of the extends type.
                    // We use a reverse assignability check as it is less expensive than the comparable relationship
                    // and avoids false positives of a non-empty intersection check.
                    if (checkType.flags & TypeFlags.Any || forConstraint && !(inferredExtendsType.flags & TypeFlags.Never) && someType(getPermissiveInstantiation(inferredExtendsType), t => isTypeAssignableTo(t, getPermissiveInstantiation(checkType)))) {
                        (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
                    }
                    // If falseType is an immediately nested conditional type that isn't distributive or has an
                    // identical checkType, switch to that type and loop.
                    const falseType = getTypeFromTypeNode(root.node.falseType);
                    if (falseType.flags & TypeFlags.Conditional) {
                        const newRoot = (falseType as ConditionalType).root;
                        if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {
                            root = newRoot;
                            continue;
                        }
                        if (canTailRecurse(falseType, mapper)) {
                            continue;
                        }
                    }
                    result = instantiateType(falseType, mapper);
                    break;
                }
                // Return trueType for a definitely true extends check. We check instantiations of the two
                // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
                // that has no constraint. This ensures that, for example, the type
                //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
                // doesn't immediately resolve to 'string' instead of being deferred.
                if (inferredExtendsType.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
                    const trueType = getTypeFromTypeNode(root.node.trueType);
                    const trueMapper = combinedMapper || mapper;
                    if (canTailRecurse(trueType, trueMapper)) {
                        continue;
                    }
                    result = instantiateType(trueType, trueMapper);
                    break;
                }
            }
            // Return a deferred type for a check that is neither definitely true nor definitely false
            result = createType(TypeFlags.Conditional) as ConditionalType;
            result.root = root;
            result.checkType = instantiateType(root.checkType, mapper);
            result.extendsType = instantiateType(root.extendsType, mapper);
            result.mapper = mapper;
            result.combinedMapper = combinedMapper;
            result.aliasSymbol = aliasSymbol || root.aliasSymbol;
            result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper!); // TODO: GH#18217
            break;
        }
        return extraTypes ? getUnionType(append(extraTypes, result)) : result;
        // We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
        // (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
        // type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
        // recursion counter for those.
        function canTailRecurse(newType: Type, newMapper: TypeMapper | undefined) {
            if (newType.flags & TypeFlags.Conditional && newMapper) {
                const newRoot = (newType as ConditionalType).root;
                if (newRoot.outerTypeParameters) {
                    const typeParamMapper = combineTypeMappers((newType as ConditionalType).mapper, newMapper);
                    const typeArguments = map(newRoot.outerTypeParameters, t => getMappedType(t, typeParamMapper));
                    const newRootMapper = createTypeMapper(newRoot.outerTypeParameters, typeArguments);
                    const newCheckType = newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined;
                    if (!newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (TypeFlags.Union | TypeFlags.Never))) {
                        root = newRoot;
                        mapper = newRootMapper;
                        aliasSymbol = undefined;
                        aliasTypeArguments = undefined;
                        if (newRoot.aliasSymbol) {
                            tailCount++;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
    }

    function getTrueTypeFromConditionalType(type: ConditionalType) {
        return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper));
    }

    function getFalseTypeFromConditionalType(type: ConditionalType) {
        return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper));
    }

    function getInferredTrueTypeFromConditionalType(type: ConditionalType) {
        return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type));
    }

    function getInferTypeParameters(node: ConditionalTypeNode): TypeParameter[] | undefined {
        let result: TypeParameter[] | undefined;
        if (node.locals) {
            node.locals.forEach(symbol => {
                if (symbol.flags & SymbolFlags.TypeParameter) {
                    result = append(result, getDeclaredTypeOfSymbol(symbol));
                }
            });
        }
        return result;
    }

    function isDistributionDependent(root: ConditionalRoot) {
        return root.isDistributive && (
            isTypeParameterPossiblyReferenced(root.checkType as TypeParameter, root.node.trueType) ||
            isTypeParameterPossiblyReferenced(root.checkType as TypeParameter, root.node.falseType)
        );
    }

    function getTypeFromConditionalTypeNode(node: ConditionalTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const checkType = getTypeFromTypeNode(node.checkType);
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            const aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
            const allOuterTypeParameters = getOuterTypeParameters(node, /*includeThisTypes*/ true);
            const outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node));
            const root: ConditionalRoot = {
                node,
                checkType,
                extendsType: getTypeFromTypeNode(node.extendsType),
                isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),
                inferTypeParameters: getInferTypeParameters(node),
                outerTypeParameters,
                instantiations: undefined,
                aliasSymbol,
                aliasTypeArguments,
            };
            links.resolvedType = getConditionalType(root, /*mapper*/ undefined, /*forConstraint*/ false);
            if (outerTypeParameters) {
                root.instantiations = new Map<string, Type>();
                root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
            }
        }
        return links.resolvedType;
    }

    function getTypeFromInferTypeNode(node: InferTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter));
        }
        return links.resolvedType;
    }

    function getIdentifierChain(node: EntityName): Identifier[] {
        if (isIdentifier(node)) {
            return [node];
        }
        else {
            return append(getIdentifierChain(node.left), node.right);
        }
    }

    function getTypeFromImportTypeNode(node: ImportTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            if (!isLiteralImportTypeNode(node)) {
                error(node.argument, Diagnostics.String_literal_expected);
                links.resolvedSymbol = unknownSymbol;
                return links.resolvedType = errorType;
            }
            const targetMeaning = node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type;
            // TODO: Future work: support unions/generics/whatever via a deferred import-type
            const innerModuleSymbol = resolveExternalModuleName(node, node.argument.literal);
            if (!innerModuleSymbol) {
                links.resolvedSymbol = unknownSymbol;
                return links.resolvedType = errorType;
            }
            const isExportEquals = !!innerModuleSymbol.exports?.get(InternalSymbolName.ExportEquals);
            const moduleSymbol = resolveExternalModuleSymbol(innerModuleSymbol, /*dontResolveAlias*/ false);
            if (!nodeIsMissing(node.qualifier)) {
                const nameStack: Identifier[] = getIdentifierChain(node.qualifier!);
                let currentNamespace = moduleSymbol;
                let current: Identifier | undefined;
                while (current = nameStack.shift()) {
                    const meaning = nameStack.length ? SymbolFlags.Namespace : targetMeaning;
                    // typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`
                    // That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from
                    // the `exports` lookup process that only looks up namespace members which is used for most type references
                    const mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));
                    const symbolFromVariable = node.isTypeOf || isInJSFile(node) && isExportEquals
                        ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, /*skipObjectFunctionPropertyAugment*/ false, /*includeTypeOnlyMembers*/ true)
                        : undefined;
                    const symbolFromModule = node.isTypeOf ? undefined : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);
                    const next = symbolFromModule ?? symbolFromVariable;
                    if (!next) {
                        error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current));
                        return links.resolvedType = errorType;
                    }
                    getNodeLinks(current).resolvedSymbol = next;
                    getNodeLinks(current.parent).resolvedSymbol = next;
                    currentNamespace = next;
                }
                links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning);
            }
            else {
                if (moduleSymbol.flags & targetMeaning) {
                    links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning);
                }
                else {
                    const errorMessage = targetMeaning === SymbolFlags.Value
                        ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here
                        : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0;

                    error(node, errorMessage, node.argument.literal.text);

                    links.resolvedSymbol = unknownSymbol;
                    links.resolvedType = errorType;
                }
            }
        }
        return links.resolvedType;
    }

    function resolveImportSymbolType(node: ImportTypeNode, links: NodeLinks, symbol: Symbol, meaning: SymbolFlags) {
        const resolvedSymbol = resolveSymbol(symbol);
        links.resolvedSymbol = resolvedSymbol;
        if (meaning === SymbolFlags.Value) {
            return getInstantiationExpressionType(getTypeOfSymbol(symbol), node); // intentionally doesn't use resolved symbol so type is cached as expected on the alias
        }
        else {
            return getTypeReferenceType(node, resolvedSymbol); // getTypeReferenceType doesn't handle aliases - it must get the resolved symbol
        }
    }

    function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node: TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            // Deferred resolution of members is handled by resolveObjectTypeMembers
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            if (!node.symbol || getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) {
                links.resolvedType = emptyTypeLiteralType;
            }
            else {
                let type = createObjectType(ObjectFlags.Anonymous, node.symbol);
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                if (isJSDocTypeLiteral(node) && node.isArrayType) {
                    type = createArrayType(type);
                }
                links.resolvedType = type;
            }
        }
        return links.resolvedType;
    }

    function getAliasSymbolForTypeNode(node: Node) {
        let host = node.parent;
        while (isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator === SyntaxKind.ReadonlyKeyword) {
            host = host.parent;
        }
        return isTypeAlias(host) ? getSymbolOfDeclaration(host) : undefined;
    }

    function getTypeArgumentsForAliasSymbol(symbol: Symbol | undefined) {
        return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined;
    }

    function isNonGenericObjectType(type: Type) {
        return !!(type.flags & TypeFlags.Object) && !isGenericMappedType(type);
    }

    function isEmptyObjectTypeOrSpreadsIntoEmptyObject(type: Type) {
        return isEmptyObjectType(type) || !!(type.flags & (TypeFlags.Null | TypeFlags.Undefined | TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index));
    }

    function tryMergeUnionOfObjectTypeAndEmptyObject(type: Type, readonly: boolean): Type {
        if (!(type.flags & TypeFlags.Union)) {
            return type;
        }
        if (every((type as UnionType).types, isEmptyObjectTypeOrSpreadsIntoEmptyObject)) {
            return find((type as UnionType).types, isEmptyObjectType) || emptyObjectType;
        }
        const firstType = find((type as UnionType).types, t => !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t));
        if (!firstType) {
            return type;
        }
        const secondType = find((type as UnionType).types, t => t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t));
        if (secondType) {
            return type;
        }
        return getAnonymousPartialType(firstType);

        function getAnonymousPartialType(type: Type) {
            // gets the type as if it had been spread, but where everything in the spread is made optional
            const members = createSymbolTable();
            for (const prop of getPropertiesOfType(type)) {
                if (getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected)) {
                    // do nothing, skip privates
                }
                else if (isSpreadableProperty(prop)) {
                    const isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
                    const flags = SymbolFlags.Property | SymbolFlags.Optional;
                    const result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0));
                    result.links.type = isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty*/ true);
                    result.declarations = prop.declarations;
                    result.links.nameType = getSymbolLinks(prop).nameType;
                    result.links.syntheticOrigin = prop;
                    members.set(prop.escapedName, result);
                }
            }
            const spread = createAnonymousType(type.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type));
            spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
            return spread;
        }
    }

    /**
     * Since the source of spread types are object literals, which are not binary,
     * this function should be called in a left folding style, with left = previous result of getSpreadType
     * and right = the new element to be spread.
     */
    function getSpreadType(left: Type, right: Type, symbol: Symbol | undefined, objectFlags: ObjectFlags, readonly: boolean): Type {
        if (left.flags & TypeFlags.Any || right.flags & TypeFlags.Any) {
            return anyType;
        }
        if (left.flags & TypeFlags.Unknown || right.flags & TypeFlags.Unknown) {
            return unknownType;
        }
        if (left.flags & TypeFlags.Never) {
            return right;
        }
        if (right.flags & TypeFlags.Never) {
            return left;
        }
        left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly);
        if (left.flags & TypeFlags.Union) {
            return checkCrossProductUnion([left, right])
                ? mapType(left, t => getSpreadType(t, right, symbol, objectFlags, readonly))
                : errorType;
        }
        right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly);
        if (right.flags & TypeFlags.Union) {
            return checkCrossProductUnion([left, right])
                ? mapType(right, t => getSpreadType(left, t, symbol, objectFlags, readonly))
                : errorType;
        }
        if (right.flags & (TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index)) {
            return left;
        }

        if (isGenericObjectType(left) || isGenericObjectType(right)) {
            if (isEmptyObjectType(left)) {
                return right;
            }
            // When the left type is an intersection, we may need to merge the last constituent of the
            // intersection with the right type. For example when the left type is 'T & { a: string }'
            // and the right type is '{ b: string }' we produce 'T & { a: string, b: string }'.
            if (left.flags & TypeFlags.Intersection) {
                const types = (left as IntersectionType).types;
                const lastLeft = types[types.length - 1];
                if (isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right)) {
                    return getIntersectionType(concatenate(types.slice(0, types.length - 1), [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)]));
                }
            }
            return getIntersectionType([left, right]);
        }

        const members = createSymbolTable();
        const skippedPrivateMembers = new Set<__String>();
        const indexInfos = left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]);

        for (const rightProp of getPropertiesOfType(right)) {
            if (getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlags.Private | ModifierFlags.Protected)) {
                skippedPrivateMembers.add(rightProp.escapedName);
            }
            else if (isSpreadableProperty(rightProp)) {
                members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly));
            }
        }

        for (const leftProp of getPropertiesOfType(left)) {
            if (skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp)) {
                continue;
            }
            if (members.has(leftProp.escapedName)) {
                const rightProp = members.get(leftProp.escapedName)!;
                const rightType = getTypeOfSymbol(rightProp);
                if (rightProp.flags & SymbolFlags.Optional) {
                    const declarations = concatenate(leftProp.declarations, rightProp.declarations);
                    const flags = SymbolFlags.Property | (leftProp.flags & SymbolFlags.Optional);
                    const result = createSymbol(flags, leftProp.escapedName);
                    // Optimization: avoid calculating the union type if spreading into the exact same type.
                    // This is common, e.g. spreading one options bag into another where the bags have the
                    // same type, or have properties which overlap. If the unions are large, it may turn out
                    // to be expensive to perform subtype reduction.
                    const leftType = getTypeOfSymbol(leftProp);
                    const leftTypeWithoutUndefined = removeMissingOrUndefinedType(leftType);
                    const rightTypeWithoutUndefined = removeMissingOrUndefinedType(rightType);
                    result.links.type = leftTypeWithoutUndefined === rightTypeWithoutUndefined ? leftType : getUnionType([leftType, rightTypeWithoutUndefined], UnionReduction.Subtype);
                    result.links.leftSpread = leftProp;
                    result.links.rightSpread = rightProp;
                    result.declarations = declarations;
                    result.links.nameType = getSymbolLinks(leftProp).nameType;
                    members.set(leftProp.escapedName, result);
                }
            }
            else {
                members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly));
            }
        }

        const spread = createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, info => getIndexInfoWithReadonly(info, readonly)));
        spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral | ObjectFlags.ContainsSpread | objectFlags;
        return spread;
    }

    /** We approximate own properties as non-methods plus methods that are inside the object literal */
    function isSpreadableProperty(prop: Symbol): boolean {
        return !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) &&
            (!(prop.flags & (SymbolFlags.Method | SymbolFlags.GetAccessor | SymbolFlags.SetAccessor)) ||
                !prop.declarations?.some(decl => isClassLike(decl.parent)));
    }

    function getSpreadSymbol(prop: Symbol, readonly: boolean) {
        const isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
        if (!isSetonlyAccessor && readonly === isReadonlySymbol(prop)) {
            return prop;
        }
        const flags = SymbolFlags.Property | (prop.flags & SymbolFlags.Optional);
        const result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0));
        result.links.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
        result.declarations = prop.declarations;
        result.links.nameType = getSymbolLinks(prop).nameType;
        result.links.syntheticOrigin = prop;
        return result;
    }

    function getIndexInfoWithReadonly(info: IndexInfo, readonly: boolean) {
        return info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration, info.components) : info;
    }

    function createLiteralType(flags: TypeFlags, value: string | number | PseudoBigInt, symbol?: Symbol, regularType?: LiteralType) {
        const type = createTypeWithSymbol(flags, symbol!) as LiteralType;
        type.value = value;
        type.regularType = regularType || type;
        return type;
    }

    function getFreshTypeOfLiteralType(type: Type): Type {
        if (type.flags & TypeFlags.Freshable) {
            if (!(type as FreshableType).freshType) {
                const freshType = createLiteralType(type.flags, (type as LiteralType).value, (type as LiteralType).symbol, type as LiteralType);
                freshType.freshType = freshType;
                (type as FreshableType).freshType = freshType;
            }
            return (type as FreshableType).freshType;
        }
        return type;
    }

    function getRegularTypeOfLiteralType(type: Type): Type {
        return type.flags & TypeFlags.Freshable ? (type as FreshableType).regularType :
            type.flags & TypeFlags.Union ? ((type as UnionType).regularType || ((type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType)) :
            type;
    }

    function isFreshLiteralType(type: Type) {
        return !!(type.flags & TypeFlags.Freshable) && (type as LiteralType).freshType === type;
    }

    function getStringLiteralType(value: string): StringLiteralType {
        let type;
        return stringLiteralTypes.get(value) ||
            (stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type);
    }

    function getNumberLiteralType(value: number): NumberLiteralType {
        let type;
        return numberLiteralTypes.get(value) ||
            (numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type);
    }

    function getBigIntLiteralType(value: PseudoBigInt): BigIntLiteralType {
        let type;
        const key = pseudoBigIntToString(value);
        return bigIntLiteralTypes.get(key) ||
            (bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type);
    }

    function getEnumLiteralType(value: string | number, enumId: number, symbol: Symbol): LiteralType {
        let type;
        const key = `${enumId}${typeof value === "string" ? "@" : "#"}${value}`;
        const flags = TypeFlags.EnumLiteral | (typeof value === "string" ? TypeFlags.StringLiteral : TypeFlags.NumberLiteral);
        return enumLiteralTypes.get(key) ||
            (enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type);
    }

    function getTypeFromLiteralTypeNode(node: LiteralTypeNode): Type {
        if (node.literal.kind === SyntaxKind.NullKeyword) {
            return nullType;
        }
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
        }
        return links.resolvedType;
    }

    function createUniqueESSymbolType(symbol: Symbol) {
        const type = createTypeWithSymbol(TypeFlags.UniqueESSymbol, symbol) as UniqueESSymbolType;
        type.escapedName = `__@${type.symbol.escapedName}@${getSymbolId(type.symbol)}` as __String;
        return type;
    }

    function getESSymbolLikeTypeForNode(node: Node) {
        if (isInJSFile(node) && isJSDocTypeExpression(node)) {
            const host = getJSDocHost(node);
            if (host) {
                node = getSingleVariableOfVariableStatement(host) || host;
            }
        }
        if (isValidESSymbolDeclaration(node)) {
            const symbol = isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode((node as BinaryExpression).left) : getSymbolOfNode(node);
            if (symbol) {
                const links = getSymbolLinks(symbol);
                return links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(symbol));
            }
        }
        return esSymbolType;
    }

    function getThisType(node: Node): Type {
        const container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
        const parent = container && container.parent;
        if (parent && (isClassLike(parent) || parent.kind === SyntaxKind.InterfaceDeclaration)) {
            if (
                !isStatic(container) &&
                (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body))
            ) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent as ClassLikeDeclaration | InterfaceDeclaration)).thisType!;
            }
        }

        // inside x.prototype = { ... }
        if (parent && isObjectLiteralExpression(parent) && isBinaryExpression(parent.parent) && getAssignmentDeclarationKind(parent.parent) === AssignmentDeclarationKind.Prototype) {
            return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left)!.parent!).thisType!;
        }
        // /** @return {this} */
        // x.prototype.m = function() { ... }
        const host = node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined;
        if (host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(host.parent) === AssignmentDeclarationKind.PrototypeProperty) {
            return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left)!.parent!).thisType!;
        }
        // inside constructor function C() { ... }
        if (isJSConstructor(container) && isNodeDescendantOf(node, container.body)) {
            return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType!;
        }
        error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);
        return errorType;
    }

    function getTypeFromThisTypeNode(node: ThisExpression | ThisTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getThisType(node);
        }
        return links.resolvedType;
    }

    function getTypeFromRestTypeNode(node: RestTypeNode | NamedTupleMember) {
        return getTypeFromTypeNode(getArrayElementTypeNode(node.type) || node.type);
    }

    function getArrayElementTypeNode(node: TypeNode): TypeNode | undefined {
        switch (node.kind) {
            case SyntaxKind.ParenthesizedType:
                return getArrayElementTypeNode((node as ParenthesizedTypeNode).type);
            case SyntaxKind.TupleType:
                if ((node as TupleTypeNode).elements.length === 1) {
                    node = (node as TupleTypeNode).elements[0];
                    if (node.kind === SyntaxKind.RestType || node.kind === SyntaxKind.NamedTupleMember && (node as NamedTupleMember).dotDotDotToken) {
                        return getArrayElementTypeNode((node as RestTypeNode | NamedTupleMember).type);
                    }
                }
                break;
            case SyntaxKind.ArrayType:
                return (node as ArrayTypeNode).elementType;
        }
        return undefined;
    }

    function getTypeFromNamedTupleTypeNode(node: NamedTupleMember): Type {
        const links = getNodeLinks(node);
        return links.resolvedType || (links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) :
            addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true, !!node.questionToken));
    }

    function getTypeFromTypeNode(node: TypeNode): Type {
        return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
    }

    function getTypeFromTypeNodeWorker(node: TypeNode): Type {
        switch (node.kind) {
            case SyntaxKind.AnyKeyword:
            case SyntaxKind.JSDocAllType:
            case SyntaxKind.JSDocUnknownType:
                return anyType;
            case SyntaxKind.UnknownKeyword:
                return unknownType;
            case SyntaxKind.StringKeyword:
                return stringType;
            case SyntaxKind.NumberKeyword:
                return numberType;
            case SyntaxKind.BigIntKeyword:
                return bigintType;
            case SyntaxKind.BooleanKeyword:
                return booleanType;
            case SyntaxKind.SymbolKeyword:
                return esSymbolType;
            case SyntaxKind.VoidKeyword:
                return voidType;
            case SyntaxKind.UndefinedKeyword:
                return undefinedType;
            case SyntaxKind.NullKeyword as TypeNodeSyntaxKind:
                // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.
                return nullType;
            case SyntaxKind.NeverKeyword:
                return neverType;
            case SyntaxKind.ObjectKeyword:
                return node.flags & NodeFlags.JavaScriptFile && !noImplicitAny ? anyType : nonPrimitiveType;
            case SyntaxKind.IntrinsicKeyword:
                return intrinsicMarkerType;
            case SyntaxKind.ThisType:
            case SyntaxKind.ThisKeyword as TypeNodeSyntaxKind:
                // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.
                return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode);
            case SyntaxKind.LiteralType:
                return getTypeFromLiteralTypeNode(node as LiteralTypeNode);
            case SyntaxKind.TypeReference:
                return getTypeFromTypeReference(node as TypeReferenceNode);
            case SyntaxKind.TypePredicate:
                return (node as TypePredicateNode).assertsModifier ? voidType : booleanType;
            case SyntaxKind.ExpressionWithTypeArguments:
                return getTypeFromTypeReference(node as ExpressionWithTypeArguments);
            case SyntaxKind.TypeQuery:
                return getTypeFromTypeQueryNode(node as TypeQueryNode);
            case SyntaxKind.ArrayType:
            case SyntaxKind.TupleType:
                return getTypeFromArrayOrTupleTypeNode(node as ArrayTypeNode | TupleTypeNode);
            case SyntaxKind.OptionalType:
                return getTypeFromOptionalTypeNode(node as OptionalTypeNode);
            case SyntaxKind.UnionType:
                return getTypeFromUnionTypeNode(node as UnionTypeNode);
            case SyntaxKind.IntersectionType:
                return getTypeFromIntersectionTypeNode(node as IntersectionTypeNode);
            case SyntaxKind.JSDocNullableType:
                return getTypeFromJSDocNullableTypeNode(node as JSDocNullableType);
            case SyntaxKind.JSDocOptionalType:
                return addOptionality(getTypeFromTypeNode((node as JSDocOptionalType).type));
            case SyntaxKind.NamedTupleMember:
                return getTypeFromNamedTupleTypeNode(node as NamedTupleMember);
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.JSDocNonNullableType:
            case SyntaxKind.JSDocTypeExpression:
                return getTypeFromTypeNode((node as ParenthesizedTypeNode | JSDocTypeReferencingNode | JSDocTypeExpression | NamedTupleMember).type);
            case SyntaxKind.RestType:
                return getTypeFromRestTypeNode(node as RestTypeNode);
            case SyntaxKind.JSDocVariadicType:
                return getTypeFromJSDocVariadicType(node as JSDocVariadicType);
            case SyntaxKind.FunctionType:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.TypeLiteral:
            case SyntaxKind.JSDocTypeLiteral:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
                return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node as TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature);
            case SyntaxKind.TypeOperator:
                return getTypeFromTypeOperatorNode(node as TypeOperatorNode);
            case SyntaxKind.IndexedAccessType:
                return getTypeFromIndexedAccessTypeNode(node as IndexedAccessTypeNode);
            case SyntaxKind.MappedType:
                return getTypeFromMappedTypeNode(node as MappedTypeNode);
            case SyntaxKind.ConditionalType:
                return getTypeFromConditionalTypeNode(node as ConditionalTypeNode);
            case SyntaxKind.InferType:
                return getTypeFromInferTypeNode(node as InferTypeNode);
            case SyntaxKind.TemplateLiteralType:
                return getTypeFromTemplateTypeNode(node as TemplateLiteralTypeNode);
            case SyntaxKind.ImportType:
                return getTypeFromImportTypeNode(node as ImportTypeNode);
            // This function assumes that an identifier, qualified name, or property access expression is a type expression
            // Callers should first ensure this by calling `isPartOfTypeNode`
            // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
            case SyntaxKind.Identifier as TypeNodeSyntaxKind:
            case SyntaxKind.QualifiedName as TypeNodeSyntaxKind:
            case SyntaxKind.PropertyAccessExpression as TypeNodeSyntaxKind:
                const symbol = getSymbolAtLocation(node);
                return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
            default:
                return errorType;
        }
    }

    function instantiateList<T>(items: readonly T[], mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[];
    function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined;
    function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined {
        if (items && items.length) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const mapped = instantiator(item, mapper);
                if (item !== mapped) {
                    const result = i === 0 ? [] : items.slice(0, i);
                    result.push(mapped);
                    for (i++; i < items.length; i++) {
                        result.push(instantiator(items[i], mapper));
                    }
                    return result;
                }
            }
        }
        return items;
    }

    function instantiateTypes(types: readonly Type[], mapper: TypeMapper): readonly Type[];
    function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined;
    function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined {
        return instantiateList<Type>(types, mapper, instantiateType);
    }

    function instantiateSignatures(signatures: readonly Signature[], mapper: TypeMapper): readonly Signature[] {
        return instantiateList<Signature>(signatures, mapper, instantiateSignature);
    }

    function instantiateIndexInfos(indexInfos: readonly IndexInfo[], mapper: TypeMapper): readonly IndexInfo[] {
        return instantiateList<IndexInfo>(indexInfos, mapper, instantiateIndexInfo);
    }

    function createTypeMapper(sources: readonly TypeParameter[], targets: readonly Type[] | undefined): TypeMapper {
        return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets);
    }

    function getMappedType(type: Type, mapper: TypeMapper): Type {
        switch (mapper.kind) {
            case TypeMapKind.Simple:
                return type === mapper.source ? mapper.target : type;
            case TypeMapKind.Array: {
                const sources = mapper.sources;
                const targets = mapper.targets;
                for (let i = 0; i < sources.length; i++) {
                    if (type === sources[i]) {
                        return targets ? targets[i] : anyType;
                    }
                }
                return type;
            }
            case TypeMapKind.Deferred: {
                const sources = mapper.sources;
                const targets = mapper.targets;
                for (let i = 0; i < sources.length; i++) {
                    if (type === sources[i]) {
                        return targets[i]();
                    }
                }
                return type;
            }
            case TypeMapKind.Function:
                return mapper.func(type);
            case TypeMapKind.Composite:
            case TypeMapKind.Merged:
                const t1 = getMappedType(type, mapper.mapper1);
                return t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);
        }
    }

    function makeUnaryTypeMapper(source: Type, target: Type): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Simple, source, target });
    }

    function makeArrayTypeMapper(sources: readonly TypeParameter[], targets: readonly Type[] | undefined): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Array, sources, targets });
    }

    function makeFunctionTypeMapper(func: (t: Type) => Type, debugInfo: () => string): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Function, func, debugInfo: Debug.isDebugging ? debugInfo : undefined });
    }

    function makeDeferredTypeMapper(sources: readonly TypeParameter[], targets: (() => Type)[]) {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Deferred, sources, targets });
    }

    function makeCompositeTypeMapper(kind: TypeMapKind.Composite | TypeMapKind.Merged, mapper1: TypeMapper, mapper2: TypeMapper): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind, mapper1, mapper2 });
    }

    function createTypeEraser(sources: readonly TypeParameter[]): TypeMapper {
        return createTypeMapper(sources, /*targets*/ undefined);
    }

    /**
     * Maps forward-references to later types parameters to the empty object type.
     * This is used during inference when instantiating type parameter defaults.
     */
    function createBackreferenceMapper(context: InferenceContext, index: number): TypeMapper {
        const forwardInferences = context.inferences.slice(index);
        return createTypeMapper(map(forwardInferences, i => i.typeParameter), map(forwardInferences, () => unknownType));
    }

    /**
     * Return a type mapper that combines the context's return mapper with a mapper that erases any additional type parameters
     * to their inferences at the time of creation.
     */
    function createOuterReturnMapper(context: InferenceContext) {
        return context.outerReturnMapper ??= mergeTypeMappers(context.returnMapper, cloneInferenceContext(context).mapper);
    }

    function combineTypeMappers(mapper1: TypeMapper | undefined, mapper2: TypeMapper): TypeMapper {
        return mapper1 ? makeCompositeTypeMapper(TypeMapKind.Composite, mapper1, mapper2) : mapper2;
    }

    function mergeTypeMappers(mapper1: TypeMapper | undefined, mapper2: TypeMapper): TypeMapper {
        return mapper1 ? makeCompositeTypeMapper(TypeMapKind.Merged, mapper1, mapper2) : mapper2;
    }

    function prependTypeMapping(source: Type, target: Type, mapper: TypeMapper | undefined) {
        return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, makeUnaryTypeMapper(source, target), mapper);
    }

    function appendTypeMapping(mapper: TypeMapper | undefined, source: Type, target: Type) {
        return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, mapper, makeUnaryTypeMapper(source, target));
    }

    function getRestrictiveTypeParameter(tp: TypeParameter) {
        return !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (
            tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation
        );
    }

    function cloneTypeParameter(typeParameter: TypeParameter): TypeParameter {
        const result = createTypeParameter(typeParameter.symbol);
        result.target = typeParameter;
        return result;
    }

    function instantiateTypePredicate(predicate: TypePredicate, mapper: TypeMapper): TypePredicate {
        return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type, mapper));
    }

    function instantiateSignature(signature: Signature, mapper: TypeMapper, eraseTypeParameters?: boolean): Signature {
        let freshTypeParameters: TypeParameter[] | undefined;
        if (signature.typeParameters && !eraseTypeParameters) {
            // First create a fresh set of type parameters, then include a mapping from the old to the
            // new type parameters in the mapper function. Finally store this mapper in the new type
            // parameters such that we can use it when instantiating constraints.
            freshTypeParameters = map(signature.typeParameters, cloneTypeParameter);
            mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
            for (const tp of freshTypeParameters) {
                tp.mapper = mapper;
            }
        }
        // Don't compute resolvedReturnType and resolvedTypePredicate now,
        // because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
        // See GH#17600.
        const result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, signature.minArgumentCount, signature.flags & SignatureFlags.PropagatingFlags);
        result.target = signature;
        result.mapper = mapper;
        return result;
    }

    function instantiateSymbol(symbol: Symbol, mapper: TypeMapper): Symbol {
        const links = getSymbolLinks(symbol);
        // If the type of the symbol is already resolved, and if that type could not possibly
        // be affected by instantiation, simply return the symbol itself.
        if (links.type && !couldContainTypeVariables(links.type)) {
            if (!(symbol.flags & SymbolFlags.SetAccessor)) {
                return symbol;
            }
            // If we're a setter, check writeType.
            if (links.writeType && !couldContainTypeVariables(links.writeType)) {
                return symbol;
            }
        }
        if (getCheckFlags(symbol) & CheckFlags.Instantiated) {
            // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
            // type mappers. This ensures that original type identities are properly preserved and that aliases
            // always reference a non-aliases.
            symbol = links.target!;
            mapper = combineTypeMappers(links.mapper, mapper);
        }
        // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
        // also transient so that we can just store data on it directly.
        const result = createSymbol(symbol.flags, symbol.escapedName, CheckFlags.Instantiated | getCheckFlags(symbol) & (CheckFlags.Readonly | CheckFlags.Late | CheckFlags.OptionalParameter | CheckFlags.RestParameter));
        result.declarations = symbol.declarations;
        result.parent = symbol.parent;
        result.links.target = symbol;
        result.links.mapper = mapper;
        if (symbol.valueDeclaration) {
            result.valueDeclaration = symbol.valueDeclaration;
        }
        if (links.nameType) {
            result.links.nameType = links.nameType;
        }
        return result;
    }

    function getObjectTypeInstantiation(type: AnonymousType | DeferredTypeReference, mapper: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]) {
        const declaration = type.objectFlags & ObjectFlags.Reference ? (type as TypeReference).node! :
            type.objectFlags & ObjectFlags.InstantiationExpressionType ? (type as InstantiationExpressionType).node :
            type.symbol.declarations![0];
        const links = getNodeLinks(declaration);
        const target = type.objectFlags & ObjectFlags.Reference ? links.resolvedType! as DeferredTypeReference :
            type.objectFlags & ObjectFlags.Instantiated ? type.target! : type;
        let typeParameters = links.outerTypeParameters;
        if (!typeParameters) {
            // The first time an anonymous type is instantiated we compute and store a list of the type
            // parameters that are in scope (and therefore potentially referenced). For type literals that
            // aren't the right hand side of a generic type alias declaration we optimize by reducing the
            // set of type parameters to those that are possibly referenced in the literal.
            let outerTypeParameters = getOuterTypeParameters(declaration, /*includeThisTypes*/ true);
            if (isJSConstructor(declaration)) {
                const templateTagParameters = getTypeParametersFromDeclaration(declaration as DeclarationWithTypeParameters);
                outerTypeParameters = addRange(outerTypeParameters, templateTagParameters);
            }
            typeParameters = outerTypeParameters || emptyArray;
            const allDeclarations = type.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) ? [declaration] : type.symbol.declarations!;
            typeParameters = (target.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ?
                filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) :
                typeParameters;
            links.outerTypeParameters = typeParameters;
        }
        if (typeParameters.length) {
            // We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
            // mapper to the type parameters to produce the effective list of type arguments, and compute the
            // instantiation cache key from the type IDs of the type arguments.
            const combinedMapper = combineTypeMappers(type.mapper, mapper);
            const typeArguments = map(typeParameters, t => getMappedType(t, combinedMapper));
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            const id = getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments);
            if (!target.instantiations) {
                target.instantiations = new Map<string, Type>();
                target.instantiations.set(getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments), target);
            }
            let result = target.instantiations.get(id);
            if (!result) {
                let newMapper = createTypeMapper(typeParameters, typeArguments);
                if (target.objectFlags & ObjectFlags.SingleSignatureType && mapper) {
                    newMapper = combineTypeMappers(newMapper, mapper);
                }
                result = target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference((type as DeferredTypeReference).target, (type as DeferredTypeReference).node, newMapper, newAliasSymbol, newAliasTypeArguments) :
                    target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(target as MappedType, newMapper, newAliasSymbol, newAliasTypeArguments) :
                    instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments);
                target.instantiations.set(id, result); // Set cached result early in case we recursively invoke instantiation while eagerly computing type variable visibility below
                const resultObjectFlags = getObjectFlags(result);
                if (result.flags & TypeFlags.ObjectFlagsType && !(resultObjectFlags & ObjectFlags.CouldContainTypeVariablesComputed)) {
                    const resultCouldContainTypeVariables = some(typeArguments, couldContainTypeVariables); // one of the input type arguments might be or contain the result
                    if (!(getObjectFlags(result) & ObjectFlags.CouldContainTypeVariablesComputed)) {
                        // if `result` is one of the object types we tried to make (it may not be, due to how `instantiateMappedType` works), we can carry forward the type variable containment check from the input type arguments
                        if (resultObjectFlags & (ObjectFlags.Mapped | ObjectFlags.Anonymous | ObjectFlags.Reference)) {
                            (result as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariables : 0);
                        }
                        // If none of the type arguments for the outer type parameters contain type variables, it follows
                        // that the instantiated type doesn't reference type variables.
                        // Intrinsics have `CouldContainTypeVariablesComputed` pre-set, so this should only cover unions and intersections resulting from `instantiateMappedType`
                        else {
                            (result as ObjectFlagsType).objectFlags |= !resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariablesComputed : 0;
                        }
                    }
                }
            }
            return result;
        }
        return type;
    }

    function maybeTypeParameterReference(node: Node) {
        return !(node.parent.kind === SyntaxKind.TypeReference && (node.parent as TypeReferenceNode).typeArguments && node === (node.parent as TypeReferenceNode).typeName ||
            node.parent.kind === SyntaxKind.ImportType && (node.parent as ImportTypeNode).typeArguments && node === (node.parent as ImportTypeNode).qualifier);
    }

    function isTypeParameterPossiblyReferenced(tp: TypeParameter, node: Node) {
        // If the type parameter doesn't have exactly one declaration, if there are intervening statement blocks
        // between the node and the type parameter declaration, if the node contains actual references to the
        // type parameter, or if the node contains type queries that we can't prove couldn't contain references to the type parameter,
        // we consider the type parameter possibly referenced.
        if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
            const container = tp.symbol.declarations[0].parent;
            for (let n = node; n !== container; n = n.parent) {
                if (!n || n.kind === SyntaxKind.Block || n.kind === SyntaxKind.ConditionalType && forEachChild((n as ConditionalTypeNode).extendsType, containsReference)) {
                    return true;
                }
            }
            return containsReference(node);
        }
        return true;
        function containsReference(node: Node): boolean {
            switch (node.kind) {
                case SyntaxKind.ThisType:
                    return !!tp.isThisType;
                case SyntaxKind.Identifier:
                    return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&
                        getTypeFromTypeNodeWorker(node as TypeNode) === tp; // use worker because we're looking for === equality
                case SyntaxKind.TypeQuery:
                    const entityName = (node as TypeQueryNode).exprName;
                    const firstIdentifier = getFirstIdentifier(entityName);
                    if (!isThisIdentifier(firstIdentifier)) { // Don't attempt to analyze typeof this.xxx
                        const firstIdentifierSymbol = getResolvedSymbol(firstIdentifier);
                        const tpDeclaration = tp.symbol.declarations![0]; // There is exactly one declaration, otherwise `containsReference` is not called
                        const tpScope = tpDeclaration.kind === SyntaxKind.TypeParameter ? tpDeclaration.parent : // Type parameter is a regular type parameter, e.g. foo<T>
                            tp.isThisType ? tpDeclaration : // Type parameter is the this type, and its declaration is the class declaration.
                            undefined; // Type parameter's declaration was unrecognized, e.g. comes from JSDoc annotation.
                        if (firstIdentifierSymbol.declarations && tpScope) {
                            return some(firstIdentifierSymbol.declarations, idDecl => isNodeDescendantOf(idDecl, tpScope)) ||
                                some((node as TypeQueryNode).typeArguments, containsReference);
                        }
                    }
                    return true;
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                    return !(node as FunctionLikeDeclaration).type && !!(node as FunctionLikeDeclaration).body ||
                        some((node as FunctionLikeDeclaration).typeParameters, containsReference) ||
                        some((node as FunctionLikeDeclaration).parameters, containsReference) ||
                        !!(node as FunctionLikeDeclaration).type && containsReference((node as FunctionLikeDeclaration).type!);
            }
            return !!forEachChild(node, containsReference);
        }
    }

    function getHomomorphicTypeVariable(type: MappedType) {
        const constraintType = getConstraintTypeFromMappedType(type);
        if (constraintType.flags & TypeFlags.Index) {
            const typeVariable = getActualTypeVariable((constraintType as IndexType).type);
            if (typeVariable.flags & TypeFlags.TypeParameter) {
                return typeVariable as TypeParameter;
            }
        }
        return undefined;
    }

    function instantiateMappedType(type: MappedType, mapper: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        // For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
        // operation depends on T as follows:
        // * If T is a primitive type no mapping is performed and the result is simply T.
        // * If T is a union type we distribute the mapped type over the union.
        // * If T is an array we map to an array where the element type has been transformed.
        // * If T is a tuple we map to a tuple where the element types have been transformed.
        // * If T is an intersection of array or tuple types we map to an intersection of transformed array or tuple types.
        // * Otherwise we map to an object type where the type of each property has been transformed.
        // For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
        // { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
        // { [P in keyof A]: X } | undefined.
        const typeVariable = getHomomorphicTypeVariable(type);
        if (typeVariable) {
            const mappedTypeVariable = instantiateType(typeVariable, mapper);
            if (typeVariable !== mappedTypeVariable) {
                return mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments);
            }
        }
        // If the constraint type of the instantiation is the wildcard type, return the wildcard type.
        return instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments);

        function instantiateConstituent(t: Type): Type {
            if (t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.InstantiableNonPrimitive | TypeFlags.Object | TypeFlags.Intersection) && t !== wildcardType && !isErrorType(t)) {
                if (!type.declaration.nameType) {
                    let constraint;
                    if (
                        isArrayType(t) || t.flags & TypeFlags.Any && findResolutionCycleStartIndex(typeVariable!, TypeSystemPropertyName.ImmediateBaseConstraint) < 0 &&
                            (constraint = getConstraintOfTypeParameter(typeVariable!)) && everyType(constraint, isArrayOrTupleType)
                    ) {
                        return instantiateMappedArrayType(t, type, prependTypeMapping(typeVariable!, t, mapper));
                    }
                    if (isTupleType(t)) {
                        return instantiateMappedTupleType(t, type, typeVariable!, mapper);
                    }
                    if (isArrayOrTupleOrIntersection(t)) {
                        return getIntersectionType(map((t as IntersectionType).types, instantiateConstituent));
                    }
                }
                return instantiateAnonymousType(type, prependTypeMapping(typeVariable!, t, mapper));
            }
            return t;
        }
    }

    function getModifiedReadonlyState(state: boolean, modifiers: MappedTypeModifiers) {
        return modifiers & MappedTypeModifiers.IncludeReadonly ? true : modifiers & MappedTypeModifiers.ExcludeReadonly ? false : state;
    }

    function instantiateMappedTupleType(tupleType: TupleTypeReference, mappedType: MappedType, typeVariable: TypeVariable, mapper: TypeMapper) {
        // We apply the mapped type's template type to each of the fixed part elements. For variadic elements, we
        // apply the mapped type itself to the variadic element type. For other elements in the variable part of the
        // tuple, we surround the element type with an array type and apply the mapped type to that. This ensures
        // that we get sequential property key types for the fixed part of the tuple, and property key type number
        // for the remaining elements. For example
        //
        //   type Keys<T> = { [K in keyof T]: K };
        //   type Foo<T extends any[]> = Keys<[string, string, ...T, string]>; // ["0", "1", ...Keys<T>, number]
        //
        const elementFlags = tupleType.target.elementFlags;
        const fixedLength = tupleType.target.fixedLength;
        const fixedMapper = fixedLength ? prependTypeMapping(typeVariable, tupleType, mapper) : mapper;
        const newElementTypes = map(getElementTypes(tupleType), (type, i) => {
            const flags = elementFlags[i];
            return i < fixedLength ? instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(flags & ElementFlags.Optional), fixedMapper) :
                flags & ElementFlags.Variadic ? instantiateType(mappedType, prependTypeMapping(typeVariable, type, mapper)) :
                getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType;
        });
        const modifiers = getMappedTypeModifiers(mappedType);
        const newElementFlags = modifiers & MappedTypeModifiers.IncludeOptional ? map(elementFlags, f => f & ElementFlags.Required ? ElementFlags.Optional : f) :
            modifiers & MappedTypeModifiers.ExcludeOptional ? map(elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :
            elementFlags;
        const newReadonly = getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType));
        return contains(newElementTypes, errorType) ? errorType :
            createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations);
    }

    function instantiateMappedArrayType(arrayType: Type, mappedType: MappedType, mapper: TypeMapper) {
        const elementType = instantiateMappedTypeTemplate(mappedType, numberType, /*isOptional*/ true, mapper);
        return isErrorType(elementType) ? errorType :
            createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)));
    }

    function instantiateMappedTypeTemplate(type: MappedType, key: Type, isOptional: boolean, mapper: TypeMapper) {
        const templateMapper = appendTypeMapping(mapper, getTypeParameterFromMappedType(type), key);
        const propType = instantiateType(getTemplateTypeFromMappedType(type.target as MappedType || type), templateMapper);
        const modifiers = getMappedTypeModifiers(type);
        return strictNullChecks && modifiers & MappedTypeModifiers.IncludeOptional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty*/ true) :
            strictNullChecks && modifiers & MappedTypeModifiers.ExcludeOptional && isOptional ? getTypeWithFacts(propType, TypeFacts.NEUndefined) :
            propType;
    }

    function instantiateAnonymousType(type: AnonymousType, mapper: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): AnonymousType {
        Debug.assert(type.symbol, "anonymous type must have symbol to be instantiated");
        const result = createObjectType(type.objectFlags & ~(ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.CouldContainTypeVariables) | ObjectFlags.Instantiated, type.symbol) as AnonymousType;
        if (type.objectFlags & ObjectFlags.Mapped) {
            (result as MappedType).declaration = (type as MappedType).declaration;
            // C.f. instantiateSignature
            const origTypeParameter = getTypeParameterFromMappedType(type as MappedType);
            const freshTypeParameter = cloneTypeParameter(origTypeParameter);
            (result as MappedType).typeParameter = freshTypeParameter;
            mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper);
            freshTypeParameter.mapper = mapper;
        }
        if (type.objectFlags & ObjectFlags.InstantiationExpressionType) {
            (result as InstantiationExpressionType).node = (type as InstantiationExpressionType).node;
        }
        result.target = type;
        result.mapper = mapper;
        result.aliasSymbol = aliasSymbol || type.aliasSymbol;
        result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
        result.objectFlags |= result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0;
        return result;
    }

    function getConditionalTypeInstantiation(type: ConditionalType, mapper: TypeMapper, forConstraint: boolean, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        const root = type.root;
        if (root.outerTypeParameters) {
            // We are instantiating a conditional type that has one or more type parameters in scope. Apply the
            // mapper to the type parameters to produce the effective list of type arguments, and compute the
            // instantiation cache key from the type IDs of the type arguments.
            const typeArguments = map(root.outerTypeParameters, t => getMappedType(t, mapper));
            const id = (forConstraint ? "C" : "") + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
            let result = root.instantiations!.get(id);
            if (!result) {
                const newMapper = createTypeMapper(root.outerTypeParameters, typeArguments);
                const checkType = root.checkType;
                const distributionType = root.isDistributive ? getReducedType(getMappedType(checkType, newMapper)) : undefined;
                // Distributive conditional types are distributed over union types. For example, when the
                // distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
                // result is (A extends U ? X : Y) | (B extends U ? X : Y).
                result = distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ?
                    mapTypeWithAlias(distributionType, t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint), aliasSymbol, aliasTypeArguments) :
                    getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments);
                root.instantiations!.set(id, result);
            }
            return result;
        }
        return type;
    }

    function instantiateType(type: Type, mapper: TypeMapper | undefined): Type;
    function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined;
    function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined {
        return type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined) : type;
    }

    function instantiateTypeWithAlias(type: Type, mapper: TypeMapper, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined): Type {
        if (!couldContainTypeVariables(type)) {
            return type;
        }
        if (instantiationDepth === 100 || instantiationCount >= 5000000) {
            // We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
            // or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
            // that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
            tracing?.instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit", { typeId: type.id, instantiationDepth, instantiationCount });
            error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
            return errorType;
        }
        const index = findActiveMapper(mapper);
        if (index === -1) {
            pushActiveMapper(mapper);
        }
        const key = type.id + getAliasId(aliasSymbol, aliasTypeArguments);
        const mapperCache = activeTypeMappersCaches[index !== -1 ? index : activeTypeMappersCount - 1];
        const cached = mapperCache.get(key);
        if (cached) {
            return cached;
        }
        totalInstantiationCount++;
        instantiationCount++;
        instantiationDepth++;
        const result = instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments);
        if (index === -1) {
            popActiveMapper();
        }
        else {
            mapperCache.set(key, result);
        }
        instantiationDepth--;
        return result;
    }

    function instantiateTypeWorker(type: Type, mapper: TypeMapper, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined): Type {
        const flags = type.flags;
        if (flags & TypeFlags.TypeParameter) {
            return getMappedType(type, mapper);
        }
        if (flags & TypeFlags.Object) {
            const objectFlags = (type as ObjectType).objectFlags;
            if (objectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped)) {
                if (objectFlags & ObjectFlags.Reference && !(type as TypeReference).node) {
                    const resolvedTypeArguments = (type as TypeReference).resolvedTypeArguments;
                    const newTypeArguments = instantiateTypes(resolvedTypeArguments, mapper);
                    return newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference((type as TypeReference).target, newTypeArguments) : type;
                }
                if (objectFlags & ObjectFlags.ReverseMapped) {
                    return instantiateReverseMappedType(type as ReverseMappedType, mapper);
                }
                return getObjectTypeInstantiation(type as TypeReference | AnonymousType | MappedType, mapper, aliasSymbol, aliasTypeArguments);
            }
            return type;
        }
        if (flags & TypeFlags.UnionOrIntersection) {
            const origin = type.flags & TypeFlags.Union ? (type as UnionType).origin : undefined;
            const types = origin && origin.flags & TypeFlags.UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (type as UnionOrIntersectionType).types;
            const newTypes = instantiateTypes(types, mapper);
            if (newTypes === types && aliasSymbol === type.aliasSymbol) {
                return type;
            }
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return flags & TypeFlags.Intersection || origin && origin.flags & TypeFlags.Intersection ?
                getIntersectionType(newTypes, IntersectionFlags.None, newAliasSymbol, newAliasTypeArguments) :
                getUnionType(newTypes, UnionReduction.Literal, newAliasSymbol, newAliasTypeArguments);
        }
        if (flags & TypeFlags.Index) {
            return getIndexType(instantiateType((type as IndexType).type, mapper));
        }
        if (flags & TypeFlags.TemplateLiteral) {
            return getTemplateLiteralType((type as TemplateLiteralType).texts, instantiateTypes((type as TemplateLiteralType).types, mapper));
        }
        if (flags & TypeFlags.StringMapping) {
            return getStringMappingType((type as StringMappingType).symbol, instantiateType((type as StringMappingType).type, mapper));
        }
        if (flags & TypeFlags.IndexedAccess) {
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return getIndexedAccessType(instantiateType((type as IndexedAccessType).objectType, mapper), instantiateType((type as IndexedAccessType).indexType, mapper), (type as IndexedAccessType).accessFlags, /*accessNode*/ undefined, newAliasSymbol, newAliasTypeArguments);
        }
        if (flags & TypeFlags.Conditional) {
            return getConditionalTypeInstantiation(
                type as ConditionalType,
                combineTypeMappers((type as ConditionalType).mapper, mapper),
                /*forConstraint*/ false,
                aliasSymbol,
                aliasTypeArguments,
            );
        }
        if (flags & TypeFlags.Substitution) {
            const newBaseType = instantiateType((type as SubstitutionType).baseType, mapper);
            if (isNoInferType(type)) {
                return getNoInferType(newBaseType);
            }
            const newConstraint = instantiateType((type as SubstitutionType).constraint, mapper);
            // A substitution type originates in the true branch of a conditional type and can be resolved
            // to just the base type in the same cases as the conditional type resolves to its true branch
            // (because the base type is then known to satisfy the constraint).
            if (newBaseType.flags & TypeFlags.TypeVariable && isGenericType(newConstraint)) {
                return getSubstitutionType(newBaseType, newConstraint);
            }
            if (newConstraint.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint))) {
                return newBaseType;
            }
            return newBaseType.flags & TypeFlags.TypeVariable ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]);
        }
        return type;
    }

    function instantiateReverseMappedType(type: ReverseMappedType, mapper: TypeMapper) {
        const innerMappedType = instantiateType(type.mappedType, mapper);
        if (!(getObjectFlags(innerMappedType) & ObjectFlags.Mapped)) {
            return type;
        }
        const innerIndexType = instantiateType(type.constraintType, mapper);
        if (!(innerIndexType.flags & TypeFlags.Index)) {
            return type;
        }
        const instantiated = inferTypeForHomomorphicMappedType(
            instantiateType(type.source, mapper),
            innerMappedType as MappedType,
            innerIndexType as IndexType,
        );
        if (instantiated) {
            return instantiated;
        }
        return type; // Nested invocation of `inferTypeForHomomorphicMappedType` or the `source` instantiated into something unmappable
    }

    function getPermissiveInstantiation(type: Type) {
        return type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) ? type :
            type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper));
    }

    function getRestrictiveInstantiation(type: Type) {
        if (type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never)) {
            return type;
        }
        if (type.restrictiveInstantiation) {
            return type.restrictiveInstantiation;
        }
        type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
        // We set the following so we don't attempt to set the restrictive instance of a restrictive instance
        // which is redundant - we'll produce new type identities, but all type params have already been mapped.
        // This also gives us a way to detect restrictive instances upon comparisons and _disable_ the "distributeive constraint"
        // assignability check for them, which is distinctly unsafe, as once you have a restrctive instance, all the type parameters
        // are constrained to `unknown` and produce tons of false positives/negatives!
        type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
        return type.restrictiveInstantiation;
    }

    function instantiateIndexInfo(info: IndexInfo, mapper: TypeMapper) {
        return createIndexInfo(info.keyType, instantiateType(info.type, mapper), info.isReadonly, info.declaration, info.components);
    }

    // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
    // that is subject to contextual typing.
    function isContextSensitive(node: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild): boolean {
        Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));
        switch (node.kind) {
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration: // Function declarations can have context when annotated with a jsdoc @type
                return isContextSensitiveFunctionLikeDeclaration(node as FunctionExpression | ArrowFunction | MethodDeclaration);
            case SyntaxKind.ObjectLiteralExpression:
                return some((node as ObjectLiteralExpression).properties, isContextSensitive);
            case SyntaxKind.ArrayLiteralExpression:
                return some((node as ArrayLiteralExpression).elements, isContextSensitive);
            case SyntaxKind.ConditionalExpression:
                return isContextSensitive((node as ConditionalExpression).whenTrue) ||
                    isContextSensitive((node as ConditionalExpression).whenFalse);
            case SyntaxKind.BinaryExpression:
                return ((node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken || (node as BinaryExpression).operatorToken.kind === SyntaxKind.QuestionQuestionToken) &&
                    (isContextSensitive((node as BinaryExpression).left) || isContextSensitive((node as BinaryExpression).right));
            case SyntaxKind.PropertyAssignment:
                return isContextSensitive((node as PropertyAssignment).initializer);
            case SyntaxKind.ParenthesizedExpression:
                return isContextSensitive((node as ParenthesizedExpression).expression);
            case SyntaxKind.JsxAttributes:
                return some((node as JsxAttributes).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive);
            case SyntaxKind.JsxAttribute: {
                // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
                const { initializer } = node as JsxAttribute;
                return !!initializer && isContextSensitive(initializer);
            }
            case SyntaxKind.JsxExpression: {
                // It is possible to that node.expression is undefined (e.g <div x={} />)
                const { expression } = node as JsxExpression;
                return !!expression && isContextSensitive(expression);
            }
        }

        return false;
    }

    function isContextSensitiveFunctionLikeDeclaration(node: FunctionLikeDeclaration): boolean {
        return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node);
    }

    function hasContextSensitiveReturnExpression(node: FunctionLikeDeclaration) {
        if (node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body) {
            return false;
        }
        if (node.body.kind !== SyntaxKind.Block) {
            return isContextSensitive(node.body);
        }
        return !!forEachReturnStatement(node.body as Block, statement => !!statement.expression && isContextSensitive(statement.expression));
    }

    function isContextSensitiveFunctionOrObjectLiteralMethod(func: Node): func is FunctionExpression | ArrowFunction | MethodDeclaration {
        return (isFunctionExpressionOrArrowFunction(func) || isObjectLiteralMethod(func)) &&
            isContextSensitiveFunctionLikeDeclaration(func);
    }

    function getTypeWithoutSignatures(type: Type): Type {
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            if (resolved.constructSignatures.length || resolved.callSignatures.length) {
                const result = createObjectType(ObjectFlags.Anonymous, type.symbol);
                result.members = resolved.members;
                result.properties = resolved.properties;
                result.callSignatures = emptyArray;
                result.constructSignatures = emptyArray;
                result.indexInfos = emptyArray;
                return result;
            }
        }
        else if (type.flags & TypeFlags.Intersection) {
            return getIntersectionType(map((type as IntersectionType).types, getTypeWithoutSignatures));
        }
        return type;
    }

    // TYPE CHECKING

    function isTypeIdenticalTo(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, identityRelation);
    }

    function compareTypesIdentical(source: Type, target: Type): Ternary {
        return isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False;
    }

    function compareTypesAssignable(source: Type, target: Type): Ternary {
        return isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False;
    }

    function compareTypesSubtypeOf(source: Type, target: Type): Ternary {
        return isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False;
    }

    function isTypeSubtypeOf(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, subtypeRelation);
    }

    function isTypeStrictSubtypeOf(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, strictSubtypeRelation);
    }

    function isTypeAssignableTo(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, assignableRelation);
    }

    // An object type S is considered to be derived from an object type T if
    // S is a union type and every constituent of S is derived from T,
    // T is a union type and S is derived from at least one constituent of T, or
    // S is an intersection type and some constituent of S is derived from T, or
    // S is a type variable with a base constraint that is derived from T, or
    // T is {} and S is an object-like type (ensuring {} is less derived than Object), or
    // T is one of the global types Object and Function and S is a subtype of T, or
    // T occurs directly or indirectly in an 'extends' clause of S.
    // Note that this check ignores type parameters and only considers the
    // inheritance hierarchy.
    function isTypeDerivedFrom(source: Type, target: Type): boolean {
        return source.flags & TypeFlags.Union ? every((source as UnionType).types, t => isTypeDerivedFrom(t, target)) :
            target.flags & TypeFlags.Union ? some((target as UnionType).types, t => isTypeDerivedFrom(source, t)) :
            source.flags & TypeFlags.Intersection ? some((source as IntersectionType).types, t => isTypeDerivedFrom(t, target)) :
            source.flags & TypeFlags.InstantiableNonPrimitive ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :
            isEmptyAnonymousObjectType(target) ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) :
            target === globalObjectType ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) && !isEmptyAnonymousObjectType(source) :
            target === globalFunctionType ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(source as ObjectType) :
            hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType));
    }

    /**
     * This is *not* a bi-directional relationship.
     * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
     *
     * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
     * It is used to check following cases:
     *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
     *   - the types of `case` clause expressions and their respective `switch` expressions.
     *   - the type of an expression in a type assertion with the type being asserted.
     */
    function isTypeComparableTo(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, comparableRelation);
    }

    function areTypesComparable(type1: Type, type2: Type): boolean {
        return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
    }

    function checkTypeAssignableTo(source: Type, target: Type, errorNode: Node | undefined, headMessage?: DiagnosticMessage, containingMessageChain?: () => DiagnosticMessageChain | undefined, errorOutputObject?: { errors?: Diagnostic[]; }): boolean {
        return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject);
    }

    /**
     * Like `checkTypeAssignableTo`, but if it would issue an error, instead performs structural comparisons of the types using the given expression node to
     * attempt to issue more specific errors on, for example, specific object literal properties or tuple members.
     */
    function checkTypeAssignableToAndOptionallyElaborate(source: Type, target: Type, errorNode: Node | undefined, expr: Expression | undefined, headMessage?: DiagnosticMessage, containingMessageChain?: () => DiagnosticMessageChain | undefined): boolean {
        return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, /*errorOutputContainer*/ undefined);
    }

    function checkTypeRelatedToAndOptionallyElaborate(
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        errorNode: Node | undefined,
        expr: Expression | undefined,
        headMessage: DiagnosticMessage | undefined,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ): boolean {
        if (isTypeRelatedTo(source, target, relation)) return true;
        if (!errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
            return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer);
        }
        return false;
    }

    function isOrHasGenericConditional(type: Type): boolean {
        return !!(type.flags & TypeFlags.Conditional || (type.flags & TypeFlags.Intersection && some((type as IntersectionType).types, isOrHasGenericConditional)));
    }

    function elaborateError(
        node: Expression | undefined,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        headMessage: DiagnosticMessage | undefined,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ): boolean {
        if (!node || isOrHasGenericConditional(target)) return false;
        if (
            !checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined)
            && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
        ) {
            return true;
        }
        switch (node.kind) {
            case SyntaxKind.AsExpression:
                if (!isConstAssertion(node)) {
                    break;
                }
                // fallthrough
            case SyntaxKind.JsxExpression:
            case SyntaxKind.ParenthesizedExpression:
                return elaborateError((node as AsExpression | ParenthesizedExpression | JsxExpression).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
            case SyntaxKind.BinaryExpression:
                switch ((node as BinaryExpression).operatorToken.kind) {
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.CommaToken:
                        return elaborateError((node as BinaryExpression).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                }
                break;
            case SyntaxKind.ObjectLiteralExpression:
                return elaborateObjectLiteral(node as ObjectLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);
            case SyntaxKind.ArrayLiteralExpression:
                return elaborateArrayLiteral(node as ArrayLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);
            case SyntaxKind.JsxAttributes:
                return elaborateJsxComponents(node as JsxAttributes, source, target, relation, containingMessageChain, errorOutputContainer);
            case SyntaxKind.ArrowFunction:
                return elaborateArrowFunction(node as ArrowFunction, source, target, relation, containingMessageChain, errorOutputContainer);
        }
        return false;
    }

    function elaborateDidYouMeanToCallOrConstruct(
        node: Expression,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        headMessage: DiagnosticMessage | undefined,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ): boolean {
        const callSignatures = getSignaturesOfType(source, SignatureKind.Call);
        const constructSignatures = getSignaturesOfType(source, SignatureKind.Construct);
        for (const signatures of [constructSignatures, callSignatures]) {
            if (
                some(signatures, s => {
                    const returnType = getReturnTypeOfSignature(s);
                    return !(returnType.flags & (TypeFlags.Any | TypeFlags.Never)) && checkTypeRelatedTo(returnType, target, relation, /*errorNode*/ undefined);
                })
            ) {
                const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};
                checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj);
                const diagnostic = resultObj.errors![resultObj.errors!.length - 1];
                addRelatedInfo(
                    diagnostic,
                    createDiagnosticForNode(
                        node,
                        signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression,
                    ),
                );
                return true;
            }
        }
        return false;
    }

    function elaborateArrowFunction(
        node: ArrowFunction,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ): boolean {
        // Don't elaborate blocks
        if (isBlock(node.body)) {
            return false;
        }
        // Or functions with annotated parameter types
        if (some(node.parameters, hasType)) {
            return false;
        }
        const sourceSig = getSingleCallSignature(source);
        if (!sourceSig) {
            return false;
        }
        const targetSignatures = getSignaturesOfType(target, SignatureKind.Call);
        if (!length(targetSignatures)) {
            return false;
        }
        const returnExpression = node.body;
        const sourceReturn = getReturnTypeOfSignature(sourceSig);
        const targetReturn = getUnionType(map(targetSignatures, getReturnTypeOfSignature));
        if (!checkTypeRelatedTo(sourceReturn, targetReturn, relation, /*errorNode*/ undefined)) {
            const elaborated = returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
            if (elaborated) {
                return elaborated;
            }
            const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};
            checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, /*headMessage*/ undefined, containingMessageChain, resultObj);
            if (resultObj.errors) {
                if (target.symbol && length(target.symbol.declarations)) {
                    addRelatedInfo(
                        resultObj.errors[resultObj.errors.length - 1],
                        createDiagnosticForNode(
                            target.symbol.declarations![0],
                            Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature,
                        ),
                    );
                }
                if (
                    (getFunctionFlags(node) & FunctionFlags.Async) === 0
                    // exclude cases where source itself is promisy - this way we don't make a suggestion when relating
                    // an IPromise and a Promise that are slightly different
                    && !getTypeOfPropertyOfType(sourceReturn, "then" as __String)
                    && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, /*errorNode*/ undefined)
                ) {
                    addRelatedInfo(
                        resultObj.errors[resultObj.errors.length - 1],
                        createDiagnosticForNode(
                            node,
                            Diagnostics.Did_you_mean_to_mark_this_function_as_async,
                        ),
                    );
                }
                return true;
            }
        }
        return false;
    }

    function getBestMatchIndexedAccessTypeOrUndefined(source: Type, target: Type, nameType: Type) {
        const idx = getIndexedAccessTypeOrUndefined(target, nameType);
        if (idx) {
            return idx;
        }
        if (target.flags & TypeFlags.Union) {
            const best = getBestMatchingType(source, target as UnionType);
            if (best) {
                return getIndexedAccessTypeOrUndefined(best, nameType);
            }
        }
    }

    function checkExpressionForMutableLocationWithContextualType(next: Expression, sourcePropType: Type) {
        pushContextualType(next, sourcePropType, /*isCache*/ false);
        const result = checkExpressionForMutableLocation(next, CheckMode.Contextual);
        popContextualType();
        return result;
    }

    type ElaborationIterator = IterableIterator<{ errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; }>;
    /**
     * For every element returned from the iterator, checks that element to issue an error on a property of that element's type
     * If that element would issue an error, we first attempt to dive into that element's inner expression and issue a more specific error by recuring into `elaborateError`
     * Otherwise, we issue an error on _every_ element which fail the assignability check
     */
    function elaborateElementwise(
        iterator: ElaborationIterator,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ) {
        // Assignability failure - check each prop individually, and if that fails, fall back on the bad error span
        let reportedError = false;
        for (const value of iterator) {
            const { errorNode: prop, innerExpression: next, nameType, errorMessage } = value;
            let targetPropType = getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType);
            if (!targetPropType || targetPropType.flags & TypeFlags.IndexedAccess) continue; // Don't elaborate on indexes on generic variables
            let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
            if (!sourcePropType) continue;
            const propName = getPropertyNameFromIndex(nameType, /*accessNode*/ undefined);
            if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode*/ undefined)) {
                const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
                reportedError = true;
                if (!elaborated) {
                    // Issue error on the prop itself, since the prop couldn't elaborate the error
                    const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};
                    // Use the expression type, if available
                    const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;
                    if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {
                        const diag = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));
                        diagnostics.add(diag);
                        resultObj.errors = [diag];
                    }
                    else {
                        const targetIsOptional = !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags & SymbolFlags.Optional);
                        const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional);
                        targetPropType = removeMissingType(targetPropType, targetIsOptional);
                        sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);
                        const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        if (result && specificSource !== sourcePropType) {
                            // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
                            checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        }
                    }
                    if (resultObj.errors) {
                        const reportedDiag = resultObj.errors[resultObj.errors.length - 1];
                        const propertyName = isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
                        const targetProp = propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined;

                        let issuedElaboration = false;
                        if (!targetProp) {
                            const indexInfo = getApplicableIndexInfo(target, nameType);
                            if (indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib) {
                                issuedElaboration = true;
                                addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature));
                            }
                        }

                        if (!issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations))) {
                            const targetNode = targetProp && length(targetProp.declarations) ? targetProp.declarations![0] : target.symbol.declarations![0];
                            if (!getSourceFileOfNode(targetNode).hasNoDefaultLib) {
                                addRelatedInfo(
                                    reportedDiag,
                                    createDiagnosticForNode(
                                        targetNode,
                                        Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1,
                                        propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? unescapeLeadingUnderscores(propertyName) : typeToString(nameType),
                                        typeToString(target),
                                    ),
                                );
                            }
                        }
                    }
                }
            }
        }
        return reportedError;
    }

    /**
     * Assumes `target` type is assignable to the `Iterable` type, if `Iterable` is defined,
     * or that it's an array or tuple-like type, if `Iterable` is not defined.
     */
    function elaborateIterableOrArrayLikeTargetElementwise(
        iterator: ElaborationIterator,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ) {
        const tupleOrArrayLikeTargetParts = filterType(target, isArrayOrTupleLikeType);
        const nonTupleOrArrayLikeTargetParts = filterType(target, t => !isArrayOrTupleLikeType(t));
        // If `nonTupleOrArrayLikeTargetParts` is not `never`, then that should mean `Iterable` is defined.
        const iterationType = nonTupleOrArrayLikeTargetParts !== neverType
            ? getIterationTypeOfIterable(IterationUse.ForOf, IterationTypeKind.Yield, nonTupleOrArrayLikeTargetParts, /*errorNode*/ undefined)
            : undefined;

        let reportedError = false;
        for (let status = iterator.next(); !status.done; status = iterator.next()) {
            const { errorNode: prop, innerExpression: next, nameType, errorMessage } = status.value;
            let targetPropType = iterationType;
            const targetIndexedPropType = tupleOrArrayLikeTargetParts !== neverType ? getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType) : undefined;
            if (targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlags.IndexedAccess)) { // Don't elaborate on indexes on generic variables
                targetPropType = iterationType ? getUnionType([iterationType, targetIndexedPropType]) : targetIndexedPropType;
            }
            if (!targetPropType) continue;
            let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
            if (!sourcePropType) continue;
            const propName = getPropertyNameFromIndex(nameType, /*accessNode*/ undefined);
            if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode*/ undefined)) {
                const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
                reportedError = true;
                if (!elaborated) {
                    // Issue error on the prop itself, since the prop couldn't elaborate the error
                    const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};
                    // Use the expression type, if available
                    const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;
                    if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {
                        const diag = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));
                        diagnostics.add(diag);
                        resultObj.errors = [diag];
                    }
                    else {
                        const targetIsOptional = !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags & SymbolFlags.Optional);
                        const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional);
                        targetPropType = removeMissingType(targetPropType, targetIsOptional);
                        sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);
                        const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        if (result && specificSource !== sourcePropType) {
                            // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
                            checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        }
                    }
                }
            }
        }
        return reportedError;
    }

    function* generateJsxAttributes(node: JsxAttributes): ElaborationIterator {
        if (!length(node.properties)) return;
        for (const prop of node.properties) {
            if (isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name))) continue;
            yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(getTextOfJsxAttributeName(prop.name)) };
        }
    }

    function* generateJsxChildren(node: JsxElement, getInvalidTextDiagnostic: () => DiagnosticMessage): ElaborationIterator {
        if (!length(node.children)) return;
        let memberOffset = 0;
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const nameType = getNumberLiteralType(i - memberOffset);
            const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);
            if (elem) {
                yield elem;
            }
            else {
                memberOffset++;
            }
        }
    }

    function getElaborationElementForJsxChild(child: JsxChild, nameType: LiteralType, getInvalidTextDiagnostic: () => DiagnosticMessage) {
        switch (child.kind) {
            case SyntaxKind.JsxExpression:
                // child is of the type of the expression
                return { errorNode: child, innerExpression: child.expression, nameType };
            case SyntaxKind.JsxText:
                if (child.containsOnlyTriviaWhiteSpaces) {
                    break; // Whitespace only jsx text isn't real jsx text
                }
                // child is a string
                return { errorNode: child, innerExpression: undefined, nameType, errorMessage: getInvalidTextDiagnostic() };
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.JsxFragment:
                // child is of type JSX.Element
                return { errorNode: child, innerExpression: child, nameType };
            default:
                return Debug.assertNever(child, "Found invalid jsx child");
        }
    }

    function elaborateJsxComponents(
        node: JsxAttributes,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ) {
        let result = elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer);
        let invalidTextDiagnostic: DiagnosticMessage | undefined;
        if (isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent)) {
            const containingElement = node.parent.parent;
            const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
            const childrenPropName = childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName);
            const childrenNameType = getStringLiteralType(childrenPropName);
            const childrenTargetType = getIndexedAccessType(target, childrenNameType);
            const validChildren = getSemanticJsxChildren(containingElement.children);
            if (!length(validChildren)) {
                return result;
            }
            const moreThanOneRealChildren = length(validChildren) > 1;
            let arrayLikeTargetParts: Type;
            let nonArrayLikeTargetParts: Type;
            const iterableType = getGlobalIterableType(/*reportErrors*/ false);
            if (iterableType !== emptyGenericType) {
                const anyIterable = createIterableType(anyType);
                arrayLikeTargetParts = filterType(childrenTargetType, t => isTypeAssignableTo(t, anyIterable));
                nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isTypeAssignableTo(t, anyIterable));
            }
            else {
                arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType);
                nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isArrayOrTupleLikeType(t));
            }
            if (moreThanOneRealChildren) {
                if (arrayLikeTargetParts !== neverType) {
                    const realSource = createTupleType(checkJsxChildren(containingElement, CheckMode.Normal));
                    const children = generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic);
                    result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result;
                }
                else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                    // arity mismatch
                    result = true;
                    const diag = error(
                        containingElement.openingElement.tagName,
                        Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided,
                        childrenPropName,
                        typeToString(childrenTargetType),
                    );
                    if (errorOutputContainer && errorOutputContainer.skipLogging) {
                        (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                    }
                }
            }
            else {
                if (nonArrayLikeTargetParts !== neverType) {
                    const child = validChildren[0];
                    const elem = getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic);
                    if (elem) {
                        result = elaborateElementwise(
                            (function* () {
                                yield elem;
                            })(),
                            source,
                            target,
                            relation,
                            containingMessageChain,
                            errorOutputContainer,
                        ) || result;
                    }
                }
                else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                    // arity mismatch
                    result = true;
                    const diag = error(
                        containingElement.openingElement.tagName,
                        Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided,
                        childrenPropName,
                        typeToString(childrenTargetType),
                    );
                    if (errorOutputContainer && errorOutputContainer.skipLogging) {
                        (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                    }
                }
            }
        }
        return result;

        function getInvalidTextualChildDiagnostic() {
            if (!invalidTextDiagnostic) {
                const tagNameText = getTextOfNode(node.parent.tagName);
                const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
                const childrenPropName = childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName);
                const childrenTargetType = getIndexedAccessType(target, getStringLiteralType(childrenPropName));
                const diagnostic = Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2;
                invalidTextDiagnostic = { ...diagnostic, key: "!!ALREADY FORMATTED!!", message: formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) };
            }
            return invalidTextDiagnostic;
        }
    }

    function* generateLimitedTupleElements(node: ArrayLiteralExpression, target: Type): ElaborationIterator {
        const len = length(node.elements);
        if (!len) return;
        for (let i = 0; i < len; i++) {
            // Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature
            if (isTupleLikeType(target) && !getPropertyOfType(target, ("" + i) as __String)) continue;
            const elem = node.elements[i];
            if (isOmittedExpression(elem)) continue;
            const nameType = getNumberLiteralType(i);
            const checkNode = getEffectiveCheckNode(elem);
            yield { errorNode: checkNode, innerExpression: checkNode, nameType };
        }
    }

    function elaborateArrayLiteral(
        node: ArrayLiteralExpression,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ) {
        if (target.flags & (TypeFlags.Primitive | TypeFlags.Never)) return false;
        if (isTupleLikeType(source)) {
            return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer);
        }
        // recreate a tuple from the elements, if possible
        // Since we're re-doing the expression type, we need to reapply the contextual type
        pushContextualType(node, target, /*isCache*/ false);
        const tupleizedType = checkArrayLiteral(node, CheckMode.Contextual, /*forceTuple*/ true);
        popContextualType();
        if (isTupleLikeType(tupleizedType)) {
            return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer);
        }
        return false;
    }

    function* generateObjectLiteralElements(node: ObjectLiteralExpression): ElaborationIterator {
        if (!length(node.properties)) return;
        for (const prop of node.properties) {
            if (isSpreadAssignment(prop)) continue;
            const type = getLiteralTypeFromProperty(getSymbolOfDeclaration(prop), TypeFlags.StringOrNumberLiteralOrUnique);
            if (!type || (type.flags & TypeFlags.Never)) {
                continue;
            }
            switch (prop.kind) {
                case SyntaxKind.SetAccessor:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.ShorthandPropertyAssignment:
                    yield { errorNode: prop.name, innerExpression: undefined, nameType: type };
                    break;
                case SyntaxKind.PropertyAssignment:
                    yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined };
                    break;
                default:
                    Debug.assertNever(prop);
            }
        }
    }

    function elaborateObjectLiteral(
        node: ObjectLiteralExpression,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer | undefined,
    ) {
        if (target.flags & (TypeFlags.Primitive | TypeFlags.Never)) return false;
        return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer);
    }

    /**
     * This is *not* a bi-directional relationship.
     * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
     */
    function checkTypeComparableTo(source: Type, target: Type, errorNode: Node, headMessage?: DiagnosticMessage, containingMessageChain?: () => DiagnosticMessageChain | undefined): boolean {
        return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
    }

    function isSignatureAssignableTo(source: Signature, target: Signature, ignoreReturnTypes: boolean): boolean {
        return compareSignaturesRelated(source, target, ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : SignatureCheckMode.None, /*reportErrors*/ false, /*errorReporter*/ undefined, /*incompatibleErrorReporter*/ undefined, compareTypesAssignable, /*reportUnreliableMarkers*/ undefined) !== Ternary.False;
    }

    type ErrorReporter = (message: DiagnosticMessage, ...args: DiagnosticArguments) => void;

    /**
     * Returns true if `s` is `(...args: A) => R` where `A` is `any`, `any[]`, `never`, or `never[]`, and `R` is `any` or `unknown`.
     */
    function isTopSignature(s: Signature) {
        if (!s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length === 1 && signatureHasRestParameter(s)) {
            const paramType = getTypeOfParameter(s.parameters[0]);
            const restType = isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType;
            return !!(restType.flags & (TypeFlags.Any | TypeFlags.Never) && getReturnTypeOfSignature(s).flags & TypeFlags.AnyOrUnknown);
        }
        return false;
    }

    /**
     * See signatureRelatedTo, compareSignaturesIdentical
     */
    function compareSignaturesRelated(source: Signature, target: Signature, checkMode: SignatureCheckMode, reportErrors: boolean, errorReporter: ErrorReporter | undefined, incompatibleErrorReporter: ((source: Type, target: Type) => void) | undefined, compareTypes: TypeComparer, reportUnreliableMarkers: TypeMapper | undefined): Ternary {
        // TODO (drosen): De-duplicate code between related functions.
        if (source === target) {
            return Ternary.True;
        }

        if (!(checkMode & SignatureCheckMode.StrictTopSignature && isTopSignature(source)) && isTopSignature(target)) {
            return Ternary.True;
        }
        if (checkMode & SignatureCheckMode.StrictTopSignature && isTopSignature(source) && !isTopSignature(target)) {
            return Ternary.False;
        }

        const targetCount = getParameterCount(target);
        const sourceHasMoreParameters = !hasEffectiveRestParameter(target) &&
            (checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount);
        if (sourceHasMoreParameters) {
            if (reportErrors && !(checkMode & SignatureCheckMode.StrictArity)) {
                // the second condition should be redundant, because there is no error reporting when comparing signatures by strict arity
                // since it is only done for subtype reduction
                errorReporter!(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, getMinArgumentCount(source), targetCount);
            }
            return Ternary.False;
        }

        if (source.typeParameters && source.typeParameters !== target.typeParameters) {
            target = getCanonicalSignature(target);
            source = instantiateSignatureInContextOf(source, target, /*inferenceContext*/ undefined, compareTypes);
        }

        const sourceCount = getParameterCount(source);
        const sourceRestType = getNonArrayRestType(source);
        const targetRestType = getNonArrayRestType(target);
        if (sourceRestType || targetRestType) {
            void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers);
        }

        const kind = target.declaration ? target.declaration.kind : SyntaxKind.Unknown;
        const strictVariance = !(checkMode & SignatureCheckMode.Callback) && strictFunctionTypes && kind !== SyntaxKind.MethodDeclaration &&
            kind !== SyntaxKind.MethodSignature && kind !== SyntaxKind.Constructor;
        let result = Ternary.True;

        const sourceThisType = getThisTypeOfSignature(source);
        if (sourceThisType && sourceThisType !== voidType) {
            const targetThisType = getThisTypeOfSignature(target);
            if (targetThisType) {
                // void sources are assignable to anything.
                const related = !strictVariance && compareTypes(sourceThisType, targetThisType, /*reportErrors*/ false)
                    || compareTypes(targetThisType, sourceThisType, reportErrors);
                if (!related) {
                    if (reportErrors) {
                        errorReporter!(Diagnostics.The_this_types_of_each_signature_are_incompatible);
                    }
                    return Ternary.False;
                }
                result &= related;
            }
        }

        const paramCount = sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount);
        const restIndex = sourceRestType || targetRestType ? paramCount - 1 : -1;

        for (let i = 0; i < paramCount; i++) {
            const sourceType = i === restIndex ? getRestOrAnyTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);
            const targetType = i === restIndex ? getRestOrAnyTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);
            if (sourceType && targetType && (sourceType !== targetType || checkMode & SignatureCheckMode.StrictArity)) {
                // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
                // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
                // they naturally relate only contra-variantly). However, if the source and target parameters both have
                // function types with a single call signature, we know we are relating two callback parameters. In
                // that case it is sufficient to only relate the parameters of the signatures co-variantly because,
                // similar to return values, callback parameters are output positions. This means that a Promise<T>,
                // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
                // with respect to T.
                const sourceSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(source, i) ? undefined : getSingleCallSignature(getNonNullableType(sourceType));
                const targetSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(target, i) ? undefined : getSingleCallSignature(getNonNullableType(targetType));
                const callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&
                    getTypeFacts(sourceType, TypeFacts.IsUndefinedOrNull) === getTypeFacts(targetType, TypeFacts.IsUndefinedOrNull);
                let related = callbacks ?
                    compareSignaturesRelated(targetSig, sourceSig, (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :
                    !(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors*/ false) || compareTypes(targetType, sourceType, reportErrors);
                // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void
                if (related && checkMode & SignatureCheckMode.StrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors*/ false)) {
                    related = Ternary.False;
                }
                if (!related) {
                    if (reportErrors) {
                        errorReporter!(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));
                    }
                    return Ternary.False;
                }
                result &= related;
            }
        }

        if (!(checkMode & SignatureCheckMode.IgnoreReturnTypes)) {
            // If a signature resolution is already in-flight, skip issuing a circularity error
            // here and just use the `any` type directly
            const targetReturnType = isResolvingReturnTypeOfSignature(target) ? anyType
                : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))
                : getReturnTypeOfSignature(target);
            if (targetReturnType === voidType || targetReturnType === anyType) {
                return result;
            }
            const sourceReturnType = isResolvingReturnTypeOfSignature(source) ? anyType
                : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))
                : getReturnTypeOfSignature(source);

            // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
            const targetTypePredicate = getTypePredicateOfSignature(target);
            if (targetTypePredicate) {
                const sourceTypePredicate = getTypePredicateOfSignature(source);
                if (sourceTypePredicate) {
                    result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes);
                }
                else if (isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate)) {
                    if (reportErrors) {
                        errorReporter!(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source));
                    }
                    return Ternary.False;
                }
            }
            else {
                // When relating callback signatures, we still need to relate return types bi-variantly as otherwise
                // the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
                // wouldn't be co-variant for T without this rule.
                result &= checkMode & SignatureCheckMode.BivariantCallback && compareTypes(targetReturnType, sourceReturnType, /*reportErrors*/ false) ||
                    compareTypes(sourceReturnType, targetReturnType, reportErrors);
                if (!result && reportErrors && incompatibleErrorReporter) {
                    incompatibleErrorReporter(sourceReturnType, targetReturnType);
                }
            }
        }

        return result;
    }

    function compareTypePredicateRelatedTo(
        source: TypePredicate,
        target: TypePredicate,
        reportErrors: boolean,
        errorReporter: ErrorReporter | undefined,
        compareTypes: (s: Type, t: Type, reportErrors?: boolean) => Ternary,
    ): Ternary {
        if (source.kind !== target.kind) {
            if (reportErrors) {
                errorReporter!(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
                errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
            }
            return Ternary.False;
        }

        if (source.kind === TypePredicateKind.Identifier || source.kind === TypePredicateKind.AssertsIdentifier) {
            if (source.parameterIndex !== (target as IdentifierTypePredicate).parameterIndex) {
                if (reportErrors) {
                    errorReporter!(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target as IdentifierTypePredicate).parameterName);
                    errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                }
                return Ternary.False;
            }
        }

        const related = source.type === target.type ? Ternary.True :
            source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :
            Ternary.False;
        if (related === Ternary.False && reportErrors) {
            errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
        }
        return related;
    }

    function isImplementationCompatibleWithOverload(implementation: Signature, overload: Signature): boolean {
        const erasedSource = getErasedSignature(implementation);
        const erasedTarget = getErasedSignature(overload);

        // First see if the return types are compatible in either direction.
        const sourceReturnType = getReturnTypeOfSignature(erasedSource);
        const targetReturnType = getReturnTypeOfSignature(erasedTarget);
        if (
            targetReturnType === voidType
            || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation)
            || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation)
        ) {
            return isSignatureAssignableTo(erasedSource, erasedTarget, /*ignoreReturnTypes*/ true);
        }

        return false;
    }

    function isEmptyResolvedType(t: ResolvedType) {
        return t !== anyFunctionType &&
            t.properties.length === 0 &&
            t.callSignatures.length === 0 &&
            t.constructSignatures.length === 0 &&
            t.indexInfos.length === 0;
    }

    function isEmptyObjectType(type: Type): boolean {
        return type.flags & TypeFlags.Object ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type as ObjectType)) :
            type.flags & TypeFlags.NonPrimitive ? true :
            type.flags & TypeFlags.Union ? some((type as UnionType).types, isEmptyObjectType) :
            type.flags & TypeFlags.Intersection ? every((type as UnionType).types, isEmptyObjectType) :
            false;
    }

    function isEmptyAnonymousObjectType(type: Type) {
        return !!(getObjectFlags(type) & ObjectFlags.Anonymous && (
            (type as ResolvedType).members && isEmptyResolvedType(type as ResolvedType) ||
            type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && getMembersOfSymbol(type.symbol).size === 0
        ));
    }

    function isUnknownLikeUnionType(type: Type) {
        if (strictNullChecks && type.flags & TypeFlags.Union) {
            if (!((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnionComputed)) {
                const types = (type as UnionType).types;
                (type as UnionType).objectFlags |= ObjectFlags.IsUnknownLikeUnionComputed | (types.length >= 3 && types[0].flags & TypeFlags.Undefined &&
                        types[1].flags & TypeFlags.Null && some(types, isEmptyAnonymousObjectType) ? ObjectFlags.IsUnknownLikeUnion : 0);
            }
            return !!((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnion);
        }
        return false;
    }

    function containsUndefinedType(type: Type) {
        return !!((type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type).flags & TypeFlags.Undefined);
    }

    function containsNonMissingUndefinedType(type: Type) {
        const candidate = type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type;
        return !!(candidate.flags & TypeFlags.Undefined) && candidate !== missingType;
    }

    function isStringIndexSignatureOnlyType(type: Type): boolean {
        return type.flags & TypeFlags.Object && !isGenericMappedType(type) && getPropertiesOfType(type).length === 0 && getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, stringType) ||
            type.flags & TypeFlags.UnionOrIntersection && every((type as UnionOrIntersectionType).types, isStringIndexSignatureOnlyType) ||
            false;
    }

    function isEnumTypeRelatedTo(source: Symbol, target: Symbol, errorReporter?: ErrorReporter) {
        const sourceSymbol = source.flags & SymbolFlags.EnumMember ? getParentOfSymbol(source)! : source;
        const targetSymbol = target.flags & SymbolFlags.EnumMember ? getParentOfSymbol(target)! : target;
        if (sourceSymbol === targetSymbol) {
            return true;
        }
        if (sourceSymbol.escapedName !== targetSymbol.escapedName || !(sourceSymbol.flags & SymbolFlags.RegularEnum) || !(targetSymbol.flags & SymbolFlags.RegularEnum)) {
            return false;
        }
        const id = getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol);
        const entry = enumRelation.get(id);
        if (entry !== undefined && !(entry & RelationComparisonResult.Failed && errorReporter)) {
            return !!(entry & RelationComparisonResult.Succeeded);
        }
        const targetEnumType = getTypeOfSymbol(targetSymbol);
        for (const sourceProperty of getPropertiesOfType(getTypeOfSymbol(sourceSymbol))) {
            if (sourceProperty.flags & SymbolFlags.EnumMember) {
                const targetProperty = getPropertyOfType(targetEnumType, sourceProperty.escapedName);
                if (!targetProperty || !(targetProperty.flags & SymbolFlags.EnumMember)) {
                    if (errorReporter) {
                        errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(sourceProperty), typeToString(getDeclaredTypeOfSymbol(targetSymbol), /*enclosingDeclaration*/ undefined, TypeFormatFlags.UseFullyQualifiedType));
                    }
                    enumRelation.set(id, RelationComparisonResult.Failed);
                    return false;
                }
                const sourceValue = getEnumMemberValue(getDeclarationOfKind(sourceProperty, SyntaxKind.EnumMember)!).value;
                const targetValue = getEnumMemberValue(getDeclarationOfKind(targetProperty, SyntaxKind.EnumMember)!).value;
                if (sourceValue !== targetValue) {
                    const sourceIsString = typeof sourceValue === "string";
                    const targetIsString = typeof targetValue === "string";

                    // If we have 2 enums with *known* values that differ, they are incompatible.
                    if (sourceValue !== undefined && targetValue !== undefined) {
                        if (errorReporter) {
                            const escapedSource = sourceIsString ? `"${escapeString(sourceValue)}"` : sourceValue;
                            const escapedTarget = targetIsString ? `"${escapeString(targetValue)}"` : targetValue;
                            errorReporter(Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource);
                        }
                        enumRelation.set(id, RelationComparisonResult.Failed);
                        return false;
                    }

                    // At this point we know that at least one of the values is 'undefined'.
                    // This may mean that we have an opaque member from an ambient enum declaration,
                    // or that we were not able to calculate it (which is basically an error).
                    //
                    // Either way, we can assume that it's numeric.
                    // If the other is a string, we have a mismatch in types.
                    if (sourceIsString || targetIsString) {
                        if (errorReporter) {
                            const knownStringValue = sourceValue ?? targetValue;
                            Debug.assert(typeof knownStringValue === "string");
                            const escapedValue = `"${escapeString(knownStringValue)}"`;
                            errorReporter(Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value, symbolName(targetSymbol), symbolName(targetProperty), escapedValue);
                        }
                        enumRelation.set(id, RelationComparisonResult.Failed);
                        return false;
                    }
                }
            }
        }
        enumRelation.set(id, RelationComparisonResult.Succeeded);
        return true;
    }

    function isSimpleTypeRelatedTo(source: Type, target: Type, relation: Map<string, RelationComparisonResult>, errorReporter?: ErrorReporter) {
        const s = source.flags;
        const t = target.flags;
        if (t & TypeFlags.Any || s & TypeFlags.Never || source === wildcardType) return true;
        if (t & TypeFlags.Unknown && !(relation === strictSubtypeRelation && s & TypeFlags.Any)) return true;
        if (t & TypeFlags.Never) return false;
        if (s & TypeFlags.StringLike && t & TypeFlags.String) return true;
        if (
            s & TypeFlags.StringLiteral && s & TypeFlags.EnumLiteral &&
            t & TypeFlags.StringLiteral && !(t & TypeFlags.EnumLiteral) &&
            (source as StringLiteralType).value === (target as StringLiteralType).value
        ) return true;
        if (s & TypeFlags.NumberLike && t & TypeFlags.Number) return true;
        if (
            s & TypeFlags.NumberLiteral && s & TypeFlags.EnumLiteral &&
            t & TypeFlags.NumberLiteral && !(t & TypeFlags.EnumLiteral) &&
            (source as NumberLiteralType).value === (target as NumberLiteralType).value
        ) return true;
        if (s & TypeFlags.BigIntLike && t & TypeFlags.BigInt) return true;
        if (s & TypeFlags.BooleanLike && t & TypeFlags.Boolean) return true;
        if (s & TypeFlags.ESSymbolLike && t & TypeFlags.ESSymbol) return true;
        if (
            s & TypeFlags.Enum && t & TypeFlags.Enum && source.symbol.escapedName === target.symbol.escapedName &&
            isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)
        ) return true;
        if (s & TypeFlags.EnumLiteral && t & TypeFlags.EnumLiteral) {
            if (s & TypeFlags.Union && t & TypeFlags.Union && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)) return true;
            if (
                s & TypeFlags.Literal && t & TypeFlags.Literal && (source as LiteralType).value === (target as LiteralType).value &&
                isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)
            ) return true;
        }
        // In non-strictNullChecks mode, `undefined` and `null` are assignable to anything except `never`.
        // Since unions and intersections may reduce to `never`, we exclude them here.
        if (s & TypeFlags.Undefined && (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & (TypeFlags.Undefined | TypeFlags.Void))) return true;
        if (s & TypeFlags.Null && (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & TypeFlags.Null)) return true;
        if (s & TypeFlags.Object && t & TypeFlags.NonPrimitive && !(relation === strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlags.FreshLiteral))) return true;
        if (relation === assignableRelation || relation === comparableRelation) {
            if (s & TypeFlags.Any) return true;
            // Type number is assignable to any computed numeric enum type or any numeric enum literal type, and
            // a numeric literal type is assignable any computed numeric enum type or any numeric enum literal type
            // with a matching value. These rules exist such that enums can be used for bit-flag purposes.
            if (s & TypeFlags.Number && (t & TypeFlags.Enum || t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral)) return true;
            if (
                s & TypeFlags.NumberLiteral && !(s & TypeFlags.EnumLiteral) && (t & TypeFlags.Enum ||
                    t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral &&
                        (source as NumberLiteralType).value === (target as NumberLiteralType).value)
            ) return true;
            // Anything is assignable to a union containing undefined, null, and {}
            if (isUnknownLikeUnionType(target)) return true;
        }
        return false;
    }

    function isTypeRelatedTo(source: Type, target: Type, relation: Map<string, RelationComparisonResult>) {
        if (isFreshLiteralType(source)) {
            source = (source as FreshableType).regularType;
        }
        if (isFreshLiteralType(target)) {
            target = (target as FreshableType).regularType;
        }
        if (source === target) {
            return true;
        }
        if (relation !== identityRelation) {
            if (relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation)) {
                return true;
            }
        }
        else if (!((source.flags | target.flags) & (TypeFlags.UnionOrIntersection | TypeFlags.IndexedAccess | TypeFlags.Conditional | TypeFlags.Substitution))) {
            // We have excluded types that may simplify to other forms, so types must have identical flags
            if (source.flags !== target.flags) return false;
            if (source.flags & TypeFlags.Singleton) return true;
        }
        if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
            const related = relation.get(getRelationKey(source, target, IntersectionState.None, relation, /*ignoreConstraints*/ false));
            if (related !== undefined) {
                return !!(related & RelationComparisonResult.Succeeded);
            }
        }
        if (source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable) {
            return checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined);
        }
        return false;
    }

    function isIgnoredJsxProperty(source: Type, sourceProp: Symbol) {
        return getObjectFlags(source) & ObjectFlags.JsxAttributes && isHyphenatedJsxName(sourceProp.escapedName);
    }

    function getNormalizedType(type: Type, writing: boolean): Type {
        while (true) {
            const t = isFreshLiteralType(type) ? (type as FreshableType).regularType :
                isGenericTupleType(type) ? getNormalizedTupleType(type, writing) :
                getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).node ? createTypeReference((type as TypeReference).target, getTypeArguments(type as TypeReference)) : getSingleBaseForNonAugmentingSubtype(type) || type :
                type.flags & TypeFlags.UnionOrIntersection ? getNormalizedUnionOrIntersectionType(type as UnionOrIntersectionType, writing) :
                type.flags & TypeFlags.Substitution ? writing ? (type as SubstitutionType).baseType : getSubstitutionIntersection(type as SubstitutionType) :
                type.flags & TypeFlags.Simplifiable ? getSimplifiedType(type, writing) :
                type;
            if (t === type) return t;
            type = t;
        }
    }

    function getNormalizedUnionOrIntersectionType(type: UnionOrIntersectionType, writing: boolean) {
        const reduced = getReducedType(type);
        if (reduced !== type) {
            return reduced;
        }
        if (type.flags & TypeFlags.Intersection && shouldNormalizeIntersection(type as IntersectionType)) {
            // Normalization handles cases like
            // Partial<T>[K] & ({} | null) ==>
            // Partial<T>[K] & {} | Partial<T>[K] & null ==>
            // (T[K] | undefined) & {} | (T[K] | undefined) & null ==>
            // T[K] & {} | undefined & {} | T[K] & null | undefined & null ==>
            // T[K] & {} | T[K] & null
            const normalizedTypes = sameMap(type.types, t => getNormalizedType(t, writing));
            if (normalizedTypes !== type.types) {
                return getIntersectionType(normalizedTypes);
            }
        }
        return type;
    }

    function shouldNormalizeIntersection(type: IntersectionType) {
        let hasInstantiable = false;
        let hasNullableOrEmpty = false;
        for (const t of type.types) {
            hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable);
            hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t);
            if (hasInstantiable && hasNullableOrEmpty) return true;
        }
        return false;
    }

    function getNormalizedTupleType(type: TupleTypeReference, writing: boolean): Type {
        const elements = getElementTypes(type);
        const normalizedElements = sameMap(elements, t => t.flags & TypeFlags.Simplifiable ? getSimplifiedType(t, writing) : t);
        return elements !== normalizedElements ? createNormalizedTupleType(type.target, normalizedElements) : type;
    }

    /**
     * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
     * @param source The left-hand-side of the relation.
     * @param target The right-hand-side of the relation.
     * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
     * Used as both to determine which checks are performed and as a cache of previously computed results.
     * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
     * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
     * @param containingMessageChain A chain of errors to prepend any new errors found.
     * @param errorOutputContainer Return the diagnostic. Do not log if 'skipLogging' is truthy.
     */
    function checkTypeRelatedTo(
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        errorNode: Node | undefined,
        headMessage?: DiagnosticMessage,
        containingMessageChain?: () => DiagnosticMessageChain | undefined,
        errorOutputContainer?: ErrorOutputContainer,
    ): boolean {
        let errorInfo: DiagnosticMessageChain | undefined;
        let relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined;
        let maybeKeys: string[];
        let maybeKeysSet: Set<string>;
        let sourceStack: Type[];
        let targetStack: Type[];
        let maybeCount = 0;
        let sourceDepth = 0;
        let targetDepth = 0;
        let expandingFlags = ExpandingFlags.None;
        let overflow = false;
        let overrideNextErrorInfo = 0; // How many `reportRelationError` calls should be skipped in the elaboration pyramid
        let skipParentCounter = 0; // How many errors should be skipped 'above' in the elaboration pyramid
        let lastSkippedInfo: [Type, Type] | undefined;
        let incompatibleStack: DiagnosticAndArguments[] | undefined;
        // In Node.js, the maximum number of elements in a map is 2^24. We limit the number of entries an invocation
        // of checkTypeRelatedTo can add to a relation to 1/8th of its remaining capacity.
        let relationCount = (16_000_000 - relation.size) >> 3;

        Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");

        const result = isRelatedTo(source, target, RecursionFlags.Both, /*reportErrors*/ !!errorNode, headMessage);
        if (incompatibleStack) {
            reportIncompatibleStack();
        }
        if (overflow) {
            // Record this relation as having failed such that we don't attempt the overflowing operation again.
            const id = getRelationKey(source, target, /*intersectionState*/ IntersectionState.None, relation, /*ignoreConstraints*/ false);
            relation.set(id, RelationComparisonResult.Failed | (relationCount <= 0 ? RelationComparisonResult.ComplexityOverflow : RelationComparisonResult.StackDepthOverflow));
            tracing?.instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit", { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth });
            const message = relationCount <= 0 ?
                Diagnostics.Excessive_complexity_comparing_types_0_and_1 :
                Diagnostics.Excessive_stack_depth_comparing_types_0_and_1;
            const diag = error(errorNode || currentNode, message, typeToString(source), typeToString(target));
            if (errorOutputContainer) {
                (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
            }
        }
        else if (errorInfo) {
            if (containingMessageChain) {
                const chain = containingMessageChain();
                if (chain) {
                    concatenateDiagnosticMessageChains(chain, errorInfo);
                    errorInfo = chain;
                }
            }

            let relatedInformation: DiagnosticRelatedInformation[] | undefined;
            // Check if we should issue an extra diagnostic to produce a quickfix for a slightly incorrect import statement
            if (headMessage && errorNode && !result && source.symbol) {
                const links = getSymbolLinks(source.symbol);
                if (links.originatingImport && !isImportCall(links.originatingImport)) {
                    const helpfulRetry = checkTypeRelatedTo(getTypeOfSymbol(links.target!), target, relation, /*errorNode*/ undefined);
                    if (helpfulRetry) {
                        // Likely an incorrect import. Issue a helpful diagnostic to produce a quickfix to change the import
                        const diag = createDiagnosticForNode(links.originatingImport, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead);
                        relatedInformation = append(relatedInformation, diag); // Cause the error to appear with the error that triggered it
                    }
                }
            }
            const diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode!), errorNode!, errorInfo, relatedInformation);
            if (relatedInfo) {
                addRelatedInfo(diag, ...relatedInfo);
            }
            if (errorOutputContainer) {
                (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
            }
            if (!errorOutputContainer || !errorOutputContainer.skipLogging) {
                diagnostics.add(diag);
            }
        }
        if (errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result === Ternary.False) {
            Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.");
        }

        return result !== Ternary.False;

        function resetErrorInfo(saved: ReturnType<typeof captureErrorCalculationState>) {
            errorInfo = saved.errorInfo;
            lastSkippedInfo = saved.lastSkippedInfo;
            incompatibleStack = saved.incompatibleStack;
            overrideNextErrorInfo = saved.overrideNextErrorInfo;
            skipParentCounter = saved.skipParentCounter;
            relatedInfo = saved.relatedInfo;
        }

        function captureErrorCalculationState() {
            return {
                errorInfo,
                lastSkippedInfo,
                incompatibleStack: incompatibleStack?.slice(),
                overrideNextErrorInfo,
                skipParentCounter,
                relatedInfo: relatedInfo?.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined,
            };
        }

        function reportIncompatibleError(message: DiagnosticMessage, ...args: DiagnosticArguments) {
            overrideNextErrorInfo++; // Suppress the next relation error
            lastSkippedInfo = undefined; // Reset skipped info cache
            (incompatibleStack ||= []).push([message, ...args]);
        }

        function reportIncompatibleStack() {
            const stack = incompatibleStack || [];
            incompatibleStack = undefined;
            const info = lastSkippedInfo;
            lastSkippedInfo = undefined;
            if (stack.length === 1) {
                reportError(...stack[0]);
                if (info) {
                    // Actually do the last relation error
                    reportRelationError(/*message*/ undefined, ...info);
                }
                return;
            }
            // The first error will be the innermost, while the last will be the outermost - so by popping off the end,
            // we can build from left to right
            let path = "";
            const secondaryRootErrors: DiagnosticAndArguments[] = [];
            while (stack.length) {
                const [msg, ...args] = stack.pop()!;
                switch (msg.code) {
                    case Diagnostics.Types_of_property_0_are_incompatible.code: {
                        // Parenthesize a `new` if there is one
                        if (path.indexOf("new ") === 0) {
                            path = `(${path})`;
                        }
                        const str = "" + args[0];
                        // If leading, just print back the arg (irrespective of if it's a valid identifier)
                        if (path.length === 0) {
                            path = `${str}`;
                        }
                        // Otherwise write a dotted name if possible
                        else if (isIdentifierText(str, getEmitScriptTarget(compilerOptions))) {
                            path = `${path}.${str}`;
                        }
                        // Failing that, check if the name is already a computed name
                        else if (str[0] === "[" && str[str.length - 1] === "]") {
                            path = `${path}${str}`;
                        }
                        // And finally write out a computed name as a last resort
                        else {
                            path = `${path}[${str}]`;
                        }
                        break;
                    }
                    case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
                    case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
                    case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
                    case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {
                        if (path.length === 0) {
                            // Don't flatten signature compatability errors at the start of a chain - instead prefer
                            // to unify (the with no arguments bit is excessive for printback) and print them back
                            let mappedMsg = msg;
                            if (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                                mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;
                            }
                            else if (msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                                mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;
                            }
                            secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);
                        }
                        else {
                            const prefix = (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||
                                    msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                                ? "new "
                                : "";
                            const params = (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||
                                    msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                                ? ""
                                : "...";
                            path = `${prefix}${path}(${params})`;
                        }
                        break;
                    }
                    case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code: {
                        secondaryRootErrors.unshift([Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]]);
                        break;
                    }
                    case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code: {
                        secondaryRootErrors.unshift([Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]]);
                        break;
                    }
                    default:
                        return Debug.fail(`Unhandled Diagnostic: ${msg.code}`);
                }
            }
            if (path) {
                reportError(
                    path[path.length - 1] === ")"
                        ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types
                        : Diagnostics.The_types_of_0_are_incompatible_between_these_types,
                    path,
                );
            }
            else {
                // Remove the innermost secondary error as it will duplicate the error already reported by `reportRelationError` on entry
                secondaryRootErrors.shift();
            }
            for (const [msg, ...args] of secondaryRootErrors) {
                const originalValue = msg.elidedInCompatabilityPyramid;
                msg.elidedInCompatabilityPyramid = false; // Temporarily override elision to ensure error is reported
                reportError(msg, ...args);
                msg.elidedInCompatabilityPyramid = originalValue;
            }
            if (info) {
                // Actually do the last relation error
                reportRelationError(/*message*/ undefined, ...info);
            }
        }

        function reportError(message: DiagnosticMessage, ...args: DiagnosticArguments): void {
            Debug.assert(!!errorNode);
            if (incompatibleStack) reportIncompatibleStack();
            if (message.elidedInCompatabilityPyramid) return;
            if (skipParentCounter === 0) {
                errorInfo = chainDiagnosticMessages(errorInfo, message, ...args);
            }
            else {
                skipParentCounter--;
            }
        }

        function reportParentSkippedError(message: DiagnosticMessage, ...args: DiagnosticArguments): void {
            reportError(message, ...args);
            skipParentCounter++;
        }

        function associateRelatedInfo(info: DiagnosticRelatedInformation) {
            Debug.assert(!!errorInfo);
            if (!relatedInfo) {
                relatedInfo = [info];
            }
            else {
                relatedInfo.push(info);
            }
        }

        function reportRelationError(message: DiagnosticMessage | undefined, source: Type, target: Type) {
            if (incompatibleStack) reportIncompatibleStack();
            const [sourceType, targetType] = getTypeNamesForErrorDisplay(source, target);
            let generalizedSource = source;
            let generalizedSourceType = sourceType;

            // Don't generalize on 'never' - we really want the original type
            // to be displayed for use-cases like 'assertNever'.
            if (!(target.flags & TypeFlags.Never) && isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target)) {
                generalizedSource = getBaseTypeOfLiteralType(source);
                Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable");
                generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource);
            }

            // If `target` is of indexed access type (And `source` it is not), we use the object type of `target` for better error reporting
            const targetFlags = target.flags & TypeFlags.IndexedAccess && !(source.flags & TypeFlags.IndexedAccess) ?
                (target as IndexedAccessType).objectType.flags :
                target.flags;

            if (targetFlags & TypeFlags.TypeParameter && target !== markerSuperTypeForCheck && target !== markerSubTypeForCheck) {
                const constraint = getBaseConstraintOfType(target);
                let needsOriginalSource;
                if (constraint && (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(source, constraint)))) {
                    reportError(
                        Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2,
                        needsOriginalSource ? sourceType : generalizedSourceType,
                        targetType,
                        typeToString(constraint),
                    );
                }
                else {
                    errorInfo = undefined;
                    reportError(
                        Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1,
                        targetType,
                        generalizedSourceType,
                    );
                }
            }

            if (!message) {
                if (relation === comparableRelation) {
                    message = Diagnostics.Type_0_is_not_comparable_to_type_1;
                }
                else if (sourceType === targetType) {
                    message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
                }
                else if (exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length) {
                    message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
                }
                else {
                    if (source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.Union) {
                        const suggestedType = getSuggestedTypeForNonexistentStringLiteralType(source as StringLiteralType, target as UnionType);
                        if (suggestedType) {
                            reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType));
                            return;
                        }
                    }
                    message = Diagnostics.Type_0_is_not_assignable_to_type_1;
                }
            }
            else if (
                message === Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
                && exactOptionalPropertyTypes
                && getExactOptionalUnassignableProperties(source, target).length
            ) {
                message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
            }

            reportError(message, generalizedSourceType, targetType);
        }

        function tryElaborateErrorsForPrimitivesAndObjects(source: Type, target: Type) {
            const sourceType = symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source);
            const targetType = symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target);

            if (
                (globalStringType === source && stringType === target) ||
                (globalNumberType === source && numberType === target) ||
                (globalBooleanType === source && booleanType === target) ||
                (getGlobalESSymbolType() === source && esSymbolType === target)
            ) {
                reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);
            }
        }

        /**
         * Try and elaborate array and tuple errors. Returns false
         * if we have found an elaboration, or we should ignore
         * any other elaborations when relating the `source` and
         * `target` types.
         */
        function tryElaborateArrayLikeErrors(source: Type, target: Type, reportErrors: boolean): boolean {
            /**
             * The spec for elaboration is:
             * - If the source is a readonly tuple and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
             * - If the source is a tuple then skip property elaborations if the target is an array or tuple.
             * - If the source is a readonly array and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
             * - If the source an array then skip property elaborations if the target is a tuple.
             */
            if (isTupleType(source)) {
                if (source.target.readonly && isMutableArrayOrTuple(target)) {
                    if (reportErrors) {
                        reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                    }
                    return false;
                }
                return isArrayOrTupleType(target);
            }
            if (isReadonlyArrayType(source) && isMutableArrayOrTuple(target)) {
                if (reportErrors) {
                    reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                }
                return false;
            }
            if (isTupleType(target)) {
                return isArrayType(source);
            }
            return true;
        }

        function isRelatedToWorker(source: Type, target: Type, reportErrors?: boolean) {
            return isRelatedTo(source, target, RecursionFlags.Both, reportErrors);
        }

        /**
         * Compare two types and return
         * * Ternary.True if they are related with no assumptions,
         * * Ternary.Maybe if they are related with assumptions of other relationships, or
         * * Ternary.False if they are not related.
         */
        function isRelatedTo(originalSource: Type, originalTarget: Type, recursionFlags: RecursionFlags = RecursionFlags.Both, reportErrors = false, headMessage?: DiagnosticMessage, intersectionState = IntersectionState.None): Ternary {
            if (originalSource === originalTarget) return Ternary.True;

            // Before normalization: if `source` is type an object type, and `target` is primitive,
            // skip all the checks we don't need and just return `isSimpleTypeRelatedTo` result
            if (originalSource.flags & TypeFlags.Object && originalTarget.flags & TypeFlags.Primitive) {
                if (
                    relation === comparableRelation && !(originalTarget.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) ||
                    isSimpleTypeRelatedTo(originalSource, originalTarget, relation, reportErrors ? reportError : undefined)
                ) {
                    return Ternary.True;
                }
                if (reportErrors) {
                    reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage);
                }
                return Ternary.False;
            }

            // Normalize the source and target types: Turn fresh literal types into regular literal types,
            // turn deferred type references into regular type references, simplify indexed access and
            // conditional types, and resolve substitution types to either the substitution (on the source
            // side) or the type variable (on the target side).
            const source = getNormalizedType(originalSource, /*writing*/ false);
            let target = getNormalizedType(originalTarget, /*writing*/ true);

            if (source === target) return Ternary.True;

            if (relation === identityRelation) {
                if (source.flags !== target.flags) return Ternary.False;
                if (source.flags & TypeFlags.Singleton) return Ternary.True;
                traceUnionsOrIntersectionsTooLarge(source, target);
                return recursiveTypeRelatedTo(source, target, /*reportErrors*/ false, IntersectionState.None, recursionFlags);
            }

            // We fastpath comparing a type parameter to exactly its constraint, as this is _super_ common,
            // and otherwise, for type parameters in large unions, causes us to need to compare the union to itself,
            // as we break down the _target_ union first, _then_ get the source constraint - so for every
            // member of the target, we attempt to find a match in the source. This avoids that in cases where
            // the target is exactly the constraint.
            if (source.flags & TypeFlags.TypeParameter && getConstraintOfType(source) === target) {
                return Ternary.True;
            }

            // See if we're relating a definitely non-nullable type to a union that includes null and/or undefined
            // plus a single non-nullable type. If so, remove null and/or undefined from the target type.
            if (source.flags & TypeFlags.DefinitelyNonNullable && target.flags & TypeFlags.Union) {
                const types = (target as UnionType).types;
                const candidate = types.length === 2 && types[0].flags & TypeFlags.Nullable ? types[1] :
                    types.length === 3 && types[0].flags & TypeFlags.Nullable && types[1].flags & TypeFlags.Nullable ? types[2] :
                    undefined;
                if (candidate && !(candidate.flags & TypeFlags.Nullable)) {
                    target = getNormalizedType(candidate, /*writing*/ true);
                    if (source === target) return Ternary.True;
                }
            }

            if (
                relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation) ||
                isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined)
            ) return Ternary.True;

            if (source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable) {
                const isPerformingExcessPropertyChecks = !(intersectionState & IntersectionState.Target) && (isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral);
                if (isPerformingExcessPropertyChecks) {
                    if (hasExcessProperties(source as FreshObjectLiteralType, target, reportErrors)) {
                        if (reportErrors) {
                            reportRelationError(headMessage, source, originalTarget.aliasSymbol ? originalTarget : target);
                        }
                        return Ternary.False;
                    }
                }

                const isPerformingCommonPropertyChecks = (relation !== comparableRelation || isUnitType(source)) &&
                    !(intersectionState & IntersectionState.Target) &&
                    source.flags & (TypeFlags.Primitive | TypeFlags.Object | TypeFlags.Intersection) && source !== globalObjectType &&
                    target.flags & (TypeFlags.Object | TypeFlags.Intersection) && isWeakType(target) &&
                    (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source));
                const isComparingJsxAttributes = !!(getObjectFlags(source) & ObjectFlags.JsxAttributes);
                if (isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes)) {
                    if (reportErrors) {
                        const sourceString = typeToString(originalSource.aliasSymbol ? originalSource : source);
                        const targetString = typeToString(originalTarget.aliasSymbol ? originalTarget : target);
                        const calls = getSignaturesOfType(source, SignatureKind.Call);
                        const constructs = getSignaturesOfType(source, SignatureKind.Construct);
                        if (
                            calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, RecursionFlags.Source, /*reportErrors*/ false) ||
                            constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, RecursionFlags.Source, /*reportErrors*/ false)
                        ) {
                            reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString);
                        }
                        else {
                            reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString);
                        }
                    }
                    return Ternary.False;
                }

                traceUnionsOrIntersectionsTooLarge(source, target);

                const skipCaching = source.flags & TypeFlags.Union && (source as UnionType).types.length < 4 && !(target.flags & TypeFlags.Union) ||
                    target.flags & TypeFlags.Union && (target as UnionType).types.length < 4 && !(source.flags & TypeFlags.StructuredOrInstantiable);
                const result = skipCaching ?
                    unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :
                    recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags);
                if (result) {
                    return result;
                }
            }

            if (reportErrors) {
                reportErrorResults(originalSource, originalTarget, source, target, headMessage);
            }
            return Ternary.False;
        }

        function reportErrorResults(originalSource: Type, originalTarget: Type, source: Type, target: Type, headMessage: DiagnosticMessage | undefined) {
            const sourceHasBase = !!getSingleBaseForNonAugmentingSubtype(originalSource);
            const targetHasBase = !!getSingleBaseForNonAugmentingSubtype(originalTarget);
            source = (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source;
            target = (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target;
            let maybeSuppress = overrideNextErrorInfo > 0;
            if (maybeSuppress) {
                overrideNextErrorInfo--;
            }
            if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
                const currentError = errorInfo;
                tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ true);
                if (errorInfo !== currentError) {
                    maybeSuppress = !!errorInfo;
                }
            }
            if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Primitive) {
                tryElaborateErrorsForPrimitivesAndObjects(source, target);
            }
            else if (source.symbol && source.flags & TypeFlags.Object && globalObjectType === source) {
                reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead);
            }
            else if (getObjectFlags(source) & ObjectFlags.JsxAttributes && target.flags & TypeFlags.Intersection) {
                const targetTypes = (target as IntersectionType).types;
                const intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes, errorNode);
                const intrinsicClassAttributes = getJsxType(JsxNames.IntrinsicClassAttributes, errorNode);
                if (
                    !isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) &&
                    (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes))
                ) {
                    // do not report top error
                    return;
                }
            }
            else {
                errorInfo = elaborateNeverIntersection(errorInfo, originalTarget);
            }
            // Used by, eg, missing property checking to replace the top-level message with a more informative one.
            if (!headMessage && maybeSuppress) {
                // We suppress a call to `reportRelationError` or not depending on the state of the type checker, so
                // we call `reportRelationError` here and then undo its effects to figure out what would be the diagnostic
                // if we hadn't supress it, and save that as a canonical diagnostic for deduplication purposes.
                const savedErrorState = captureErrorCalculationState();
                reportRelationError(headMessage, source, target);
                let canonical;
                if (errorInfo && errorInfo !== savedErrorState.errorInfo) {
                    canonical = { code: errorInfo.code, messageText: errorInfo.messageText };
                }
                resetErrorInfo(savedErrorState);
                if (canonical && errorInfo) {
                    errorInfo.canonicalHead = canonical;
                }

                lastSkippedInfo = [source, target];
                return;
            }
            reportRelationError(headMessage, source, target);
            if (source.flags & TypeFlags.TypeParameter && source.symbol?.declarations?.[0] && !getConstraintOfType(source as TypeVariable)) {
                const syntheticParam = cloneTypeParameter(source as TypeParameter);
                syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam));
                if (hasNonCircularBaseConstraint(syntheticParam)) {
                    const targetConstraintString = typeToString(target, source.symbol.declarations[0]);
                    associateRelatedInfo(createDiagnosticForNode(source.symbol.declarations[0], Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString));
                }
            }
        }

        function traceUnionsOrIntersectionsTooLarge(source: Type, target: Type): void {
            if (!tracing) {
                return;
            }

            if ((source.flags & TypeFlags.UnionOrIntersection) && (target.flags & TypeFlags.UnionOrIntersection)) {
                const sourceUnionOrIntersection = source as UnionOrIntersectionType;
                const targetUnionOrIntersection = target as UnionOrIntersectionType;

                if (sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlags.PrimitiveUnion) {
                    // There's a fast path for comparing primitive unions
                    return;
                }

                const sourceSize = sourceUnionOrIntersection.types.length;
                const targetSize = targetUnionOrIntersection.types.length;
                if (sourceSize * targetSize > 1E6) {
                    tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit", {
                        sourceId: source.id,
                        sourceSize,
                        targetId: target.id,
                        targetSize,
                        pos: errorNode?.pos,
                        end: errorNode?.end,
                    });
                }
            }
        }

        function getTypeOfPropertyInTypes(types: Type[], name: __String) {
            const appendPropType = (propTypes: Type[] | undefined, type: Type) => {
                type = getApparentType(type);
                const prop = type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name) : getPropertyOfObjectType(type, name);
                const propType = prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type, name)?.type || undefinedType;
                return append(propTypes, propType);
            };
            return getUnionType(reduceLeft(types, appendPropType, /*initial*/ undefined) || emptyArray);
        }

        function hasExcessProperties(source: FreshObjectLiteralType, target: Type, reportErrors: boolean): boolean {
            if (!isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(target) & ObjectFlags.JSLiteral) {
                return false; // Disable excess property checks on JS literals to simulate having an implicit "index signature" - but only outside of noImplicitAny
            }
            const isComparingJsxAttributes = !!(getObjectFlags(source) & ObjectFlags.JsxAttributes);
            if (
                (relation === assignableRelation || relation === comparableRelation) &&
                (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target)))
            ) {
                return false;
            }
            let reducedTarget = target;
            let checkTypes: Type[] | undefined;
            if (target.flags & TypeFlags.Union) {
                reducedTarget = findMatchingDiscriminantType(source, target as UnionType, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target as UnionType);
                checkTypes = reducedTarget.flags & TypeFlags.Union ? (reducedTarget as UnionType).types : [reducedTarget];
            }
            for (const prop of getPropertiesOfType(source)) {
                if (shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop)) {
                    if (!isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes)) {
                        if (reportErrors) {
                            // Report error in terms of object types in the target as those are the only ones
                            // we check in isKnownProperty.
                            const errorTarget = filterType(reducedTarget, isExcessPropertyCheckTarget);
                            // We know *exactly* where things went wrong when comparing the types.
                            // Use this property as the error node as this will be more helpful in
                            // reasoning about what went wrong.
                            if (!errorNode) return Debug.fail();
                            if (isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement(errorNode.parent)) {
                                // JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.
                                // However, using an object-literal error message will be very confusing to the users so we give different a message.
                                if (prop.valueDeclaration && isJsxAttribute(prop.valueDeclaration) && getSourceFileOfNode(errorNode) === getSourceFileOfNode(prop.valueDeclaration.name)) {
                                    // Note that extraneous children (as in `<NoChild>extra</NoChild>`) don't pass this check,
                                    // since `children` is a SyntaxKind.PropertySignature instead of a SyntaxKind.JsxAttribute.
                                    errorNode = prop.valueDeclaration.name;
                                }
                                const propName = symbolToString(prop);
                                const suggestionSymbol = getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget);
                                const suggestion = suggestionSymbol ? symbolToString(suggestionSymbol) : undefined;
                                if (suggestion) {
                                    reportError(Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion);
                                }
                                else {
                                    reportError(Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget));
                                }
                            }
                            else {
                                // use the property's value declaration if the property is assigned inside the literal itself
                                const objectLiteralDeclaration = source.symbol?.declarations && firstOrUndefined(source.symbol.declarations);
                                let suggestion: string | undefined;
                                if (prop.valueDeclaration && findAncestor(prop.valueDeclaration, d => d === objectLiteralDeclaration) && getSourceFileOfNode(objectLiteralDeclaration) === getSourceFileOfNode(errorNode)) {
                                    const propDeclaration = prop.valueDeclaration as ObjectLiteralElementLike;
                                    Debug.assertNode(propDeclaration, isObjectLiteralElementLike);

                                    const name = propDeclaration.name!;
                                    errorNode = name;

                                    if (isIdentifier(name)) {
                                        suggestion = getSuggestionForNonexistentProperty(name, errorTarget);
                                    }
                                }
                                if (suggestion !== undefined) {
                                    reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion);
                                }
                                else {
                                    reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget));
                                }
                            }
                        }
                        return true;
                    }
                    if (checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), RecursionFlags.Both, reportErrors)) {
                        if (reportErrors) {
                            reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop));
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        function shouldCheckAsExcessProperty(prop: Symbol, container: Symbol) {
            return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent === container.valueDeclaration;
        }

        function unionOrIntersectionRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            // Note that these checks are specifically ordered to produce correct results. In particular,
            // we need to deconstruct unions before intersections (because unions are always at the top),
            // and we need to handle "each" relations before "some" relations for the same kind of type.
            if (source.flags & TypeFlags.Union) {
                if (target.flags & TypeFlags.Union) {
                    // Intersections of union types are normalized into unions of intersection types, and such normalized
                    // unions can get very large and expensive to relate. The following fast path checks if the source union
                    // originated in an intersection. If so, and if that intersection contains the target type, then we know
                    // the result to be true (for any two types A and B, A & B is related to both A and B).
                    const sourceOrigin = (source as UnionType).origin;
                    if (sourceOrigin && sourceOrigin.flags & TypeFlags.Intersection && target.aliasSymbol && contains((sourceOrigin as IntersectionType).types, target)) {
                        return Ternary.True;
                    }
                    // Similarly, in unions of unions the we preserve the original list of unions. This original list is often
                    // much shorter than the normalized result, so we scan it in the following fast path.
                    const targetOrigin = (target as UnionType).origin;
                    if (targetOrigin && targetOrigin.flags & TypeFlags.Union && source.aliasSymbol && contains((targetOrigin as UnionType).types, source)) {
                        return Ternary.True;
                    }
                }
                return relation === comparableRelation ?
                    someTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) :
                    eachTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState);
            }
            if (target.flags & TypeFlags.Union) {
                return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target as UnionType, reportErrors && !(source.flags & TypeFlags.Primitive) && !(target.flags & TypeFlags.Primitive), intersectionState);
            }
            if (target.flags & TypeFlags.Intersection) {
                return typeRelatedToEachType(source, target as IntersectionType, reportErrors, IntersectionState.Target);
            }
            // Source is an intersection. For the comparable relation, if the target is a primitive type we hoist the
            // constraints of all non-primitive types in the source into a new intersection. We do this because the
            // intersection may further constrain the constraints of the non-primitive types. For example, given a type
            // parameter 'T extends 1 | 2', the intersection 'T & 1' should be reduced to '1' such that it doesn't
            // appear to be comparable to '2'.
            if (relation === comparableRelation && target.flags & TypeFlags.Primitive) {
                const constraints = sameMap((source as IntersectionType).types, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(t) || unknownType : t);
                if (constraints !== (source as IntersectionType).types) {
                    source = getIntersectionType(constraints);
                    if (source.flags & TypeFlags.Never) {
                        return Ternary.False;
                    }
                    if (!(source.flags & TypeFlags.Intersection)) {
                        return isRelatedTo(source, target, RecursionFlags.Source, /*reportErrors*/ false) ||
                            isRelatedTo(target, source, RecursionFlags.Source, /*reportErrors*/ false);
                    }
                }
            }
            // Check to see if any constituents of the intersection are immediately related to the target.
            // Don't report errors though. Elaborating on whether a source constituent is related to the target is
            // not actually useful and leads to some confusing error messages. Instead, we rely on the caller
            // checking whether the full intersection viewed as an object is related to the target.
            return someTypeRelatedToType(source as IntersectionType, target, /*reportErrors*/ false, IntersectionState.Source);
        }

        function eachTypeRelatedToSomeType(source: UnionOrIntersectionType, target: UnionOrIntersectionType): Ternary {
            let result = Ternary.True;
            const sourceTypes = source.types;
            for (const sourceType of sourceTypes) {
                const related = typeRelatedToSomeType(sourceType, target, /*reportErrors*/ false, IntersectionState.None);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function typeRelatedToSomeType(source: Type, target: UnionOrIntersectionType, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const targetTypes = target.types;
            if (target.flags & TypeFlags.Union) {
                if (containsType(targetTypes, source)) {
                    return Ternary.True;
                }
                if (
                    relation !== comparableRelation && getObjectFlags(target) & ObjectFlags.PrimitiveUnion && !(source.flags & TypeFlags.EnumLiteral) && (
                        source.flags & (TypeFlags.StringLiteral | TypeFlags.BooleanLiteral | TypeFlags.BigIntLiteral) ||
                        (relation === subtypeRelation || relation === strictSubtypeRelation) && source.flags & TypeFlags.NumberLiteral
                    )
                ) {
                    // When relating a literal type to a union of primitive types, we know the relation is false unless
                    // the union contains the base primitive type or the literal type in one of its fresh/regular forms.
                    // We exclude numeric literals for non-subtype relations because numeric literals are assignable to
                    // numeric enum literals with the same value. Similarly, we exclude enum literal types because
                    // identically named enum types are related (see isEnumTypeRelatedTo). We exclude the comparable
                    // relation in entirety because it needs to be checked in both directions.
                    const alternateForm = source === (source as StringLiteralType).regularType ? (source as StringLiteralType).freshType : (source as StringLiteralType).regularType;
                    const primitive = source.flags & TypeFlags.StringLiteral ? stringType :
                        source.flags & TypeFlags.NumberLiteral ? numberType :
                        source.flags & TypeFlags.BigIntLiteral ? bigintType :
                        undefined;
                    return primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm) ? Ternary.True : Ternary.False;
                }
                const match = getMatchingUnionConstituentForType(target as UnionType, source);
                if (match) {
                    const related = isRelatedTo(source, match, RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                    if (related) {
                        return related;
                    }
                }
            }
            for (const type of targetTypes) {
                const related = isRelatedTo(source, type, RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                if (related) {
                    return related;
                }
            }
            if (reportErrors) {
                // Elaborate only if we can find a best matching type in the target union
                const bestMatchingType = getBestMatchingType(source, target, isRelatedTo);
                if (bestMatchingType) {
                    isRelatedTo(source, bestMatchingType, RecursionFlags.Target, /*reportErrors*/ true, /*headMessage*/ undefined, intersectionState);
                }
            }
            return Ternary.False;
        }

        function typeRelatedToEachType(source: Type, target: IntersectionType, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            let result = Ternary.True;
            const targetTypes = target.types;
            for (const targetType of targetTypes) {
                const related = isRelatedTo(source, targetType, RecursionFlags.Target, reportErrors, /*headMessage*/ undefined, intersectionState);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function someTypeRelatedToType(source: UnionOrIntersectionType, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const sourceTypes = source.types;
            if (source.flags & TypeFlags.Union && containsType(sourceTypes, target)) {
                return Ternary.True;
            }
            const len = sourceTypes.length;
            for (let i = 0; i < len; i++) {
                const related = isRelatedTo(sourceTypes[i], target, RecursionFlags.Source, reportErrors && i === len - 1, /*headMessage*/ undefined, intersectionState);
                if (related) {
                    return related;
                }
            }
            return Ternary.False;
        }

        function getUndefinedStrippedTargetIfNeeded(source: Type, target: Type) {
            if (
                source.flags & TypeFlags.Union && target.flags & TypeFlags.Union &&
                !((source as UnionType).types[0].flags & TypeFlags.Undefined) && (target as UnionType).types[0].flags & TypeFlags.Undefined
            ) {
                return extractTypesOfKind(target, ~TypeFlags.Undefined);
            }
            return target;
        }

        function eachTypeRelatedToType(source: UnionOrIntersectionType, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            let result = Ternary.True;
            const sourceTypes = source.types;
            // We strip `undefined` from the target if the `source` trivially doesn't contain it for our correspondence-checking fastpath
            // since `undefined` is frequently added by optionality and would otherwise spoil a potentially useful correspondence
            const undefinedStrippedTarget = getUndefinedStrippedTargetIfNeeded(source, target as UnionType);
            for (let i = 0; i < sourceTypes.length; i++) {
                const sourceType = sourceTypes[i];
                if (undefinedStrippedTarget.flags & TypeFlags.Union && sourceTypes.length >= (undefinedStrippedTarget as UnionType).types.length && sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length === 0) {
                    // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison
                    // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large
                    // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,
                    // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`
                    // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union
                    const related = isRelatedTo(sourceType, (undefinedStrippedTarget as UnionType).types[i % (undefinedStrippedTarget as UnionType).types.length], RecursionFlags.Both, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                    if (related) {
                        result &= related;
                        continue;
                    }
                }
                const related = isRelatedTo(sourceType, target, RecursionFlags.Source, reportErrors, /*headMessage*/ undefined, intersectionState);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function typeArgumentsRelatedTo(sources: readonly Type[] = emptyArray, targets: readonly Type[] = emptyArray, variances: readonly VarianceFlags[] = emptyArray, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            if (sources.length !== targets.length && relation === identityRelation) {
                return Ternary.False;
            }
            const length = sources.length <= targets.length ? sources.length : targets.length;
            let result = Ternary.True;
            for (let i = 0; i < length; i++) {
                // When variance information isn't available we default to covariance. This happens
                // in the process of computing variance information for recursive types and when
                // comparing 'this' type arguments.
                const varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;
                const variance = varianceFlags & VarianceFlags.VarianceMask;
                // We ignore arguments for independent type parameters (because they're never witnessed).
                if (variance !== VarianceFlags.Independent) {
                    const s = sources[i];
                    const t = targets[i];
                    let related = Ternary.True;
                    if (varianceFlags & VarianceFlags.Unmeasurable) {
                        // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.
                        // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by
                        // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)
                        related = relation === identityRelation ? isRelatedTo(s, t, RecursionFlags.Both, /*reportErrors*/ false) : compareTypesIdentical(s, t);
                    }
                    else if (variance === VarianceFlags.Covariant) {
                        related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                    }
                    else if (variance === VarianceFlags.Contravariant) {
                        related = isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                    }
                    else if (variance === VarianceFlags.Bivariant) {
                        // In the bivariant case we first compare contravariantly without reporting
                        // errors. Then, if that doesn't succeed, we compare covariantly with error
                        // reporting. Thus, error elaboration will be based on the the covariant check,
                        // which is generally easier to reason about.
                        related = isRelatedTo(t, s, RecursionFlags.Both, /*reportErrors*/ false);
                        if (!related) {
                            related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                    }
                    else {
                        // In the invariant case we first compare covariantly, and only when that
                        // succeeds do we proceed to compare contravariantly. Thus, error elaboration
                        // will typically be based on the covariant check.
                        related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        if (related) {
                            related &= isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                    }
                    if (!related) {
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            return result;
        }

        // Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
        // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
        // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
        // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
        // and issue an error. Otherwise, actually compare the structure of the two types.
        function recursiveTypeRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState, recursionFlags: RecursionFlags): Ternary {
            if (overflow) {
                return Ternary.False;
            }
            const id = getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints*/ false);
            const entry = relation.get(id);
            if (entry !== undefined) {
                if (reportErrors && entry & RelationComparisonResult.Failed && !(entry & RelationComparisonResult.Overflow)) {
                    // We are elaborating errors and the cached result is a failure not due to a comparison overflow,
                    // so we will do the comparison again to generate an error message.
                }
                else {
                    if (outofbandVarianceMarkerHandler) {
                        // We're in the middle of variance checking - integrate any unmeasurable/unreliable flags from this cached component
                        const saved = entry & RelationComparisonResult.ReportsMask;
                        if (saved & RelationComparisonResult.ReportsUnmeasurable) {
                            instantiateType(source, reportUnmeasurableMapper);
                        }
                        if (saved & RelationComparisonResult.ReportsUnreliable) {
                            instantiateType(source, reportUnreliableMapper);
                        }
                    }
                    if (reportErrors && entry & RelationComparisonResult.Overflow) {
                        const message = entry & RelationComparisonResult.ComplexityOverflow ?
                            Diagnostics.Excessive_complexity_comparing_types_0_and_1 :
                            Diagnostics.Excessive_stack_depth_comparing_types_0_and_1;
                        reportError(message, typeToString(source), typeToString(target));
                        overrideNextErrorInfo++;
                    }
                    return entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False;
                }
            }
            if (relationCount <= 0) {
                overflow = true;
                return Ternary.False;
            }
            if (!maybeKeys) {
                maybeKeys = [];
                maybeKeysSet = new Set();
                sourceStack = [];
                targetStack = [];
            }
            else {
                // If source and target are already being compared, consider them related with assumptions
                if (maybeKeysSet.has(id)) {
                    return Ternary.Maybe;
                }

                // A key that starts with "*" is an indication that we have type references that reference constrained
                // type parameters. For such keys we also check against the key we would have gotten if all type parameters
                // were unconstrained.
                const broadestEquivalentId = id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints*/ true) : undefined;
                if (broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId)) {
                    return Ternary.Maybe;
                }

                if (sourceDepth === 100 || targetDepth === 100) {
                    overflow = true;
                    return Ternary.False;
                }
            }
            const maybeStart = maybeCount;
            maybeKeys[maybeCount] = id;
            maybeKeysSet.add(id);
            maybeCount++;
            const saveExpandingFlags = expandingFlags;
            if (recursionFlags & RecursionFlags.Source) {
                sourceStack[sourceDepth] = source;
                sourceDepth++;
                if (!(expandingFlags & ExpandingFlags.Source) && isDeeplyNestedType(source, sourceStack, sourceDepth)) expandingFlags |= ExpandingFlags.Source;
            }
            if (recursionFlags & RecursionFlags.Target) {
                targetStack[targetDepth] = target;
                targetDepth++;
                if (!(expandingFlags & ExpandingFlags.Target) && isDeeplyNestedType(target, targetStack, targetDepth)) expandingFlags |= ExpandingFlags.Target;
            }
            let originalHandler: typeof outofbandVarianceMarkerHandler;
            let propagatingVarianceFlags = 0 as RelationComparisonResult;
            if (outofbandVarianceMarkerHandler) {
                originalHandler = outofbandVarianceMarkerHandler;
                outofbandVarianceMarkerHandler = onlyUnreliable => {
                    propagatingVarianceFlags |= onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable;
                    return originalHandler!(onlyUnreliable);
                };
            }

            let result: Ternary;
            if (expandingFlags === ExpandingFlags.Both) {
                tracing?.instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit", {
                    sourceId: source.id,
                    sourceIdStack: sourceStack.map(t => t.id),
                    targetId: target.id,
                    targetIdStack: targetStack.map(t => t.id),
                    depth: sourceDepth,
                    targetDepth,
                });
                result = Ternary.Maybe;
            }
            else {
                tracing?.push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo", { sourceId: source.id, targetId: target.id });
                result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState);
                tracing?.pop();
            }

            if (outofbandVarianceMarkerHandler) {
                outofbandVarianceMarkerHandler = originalHandler;
            }
            if (recursionFlags & RecursionFlags.Source) {
                sourceDepth--;
            }
            if (recursionFlags & RecursionFlags.Target) {
                targetDepth--;
            }
            expandingFlags = saveExpandingFlags;
            if (result) {
                if (result === Ternary.True || (sourceDepth === 0 && targetDepth === 0)) {
                    if (result === Ternary.True || result === Ternary.Maybe) {
                        // If result is definitely true, record all maybe keys as having succeeded. Also, record Ternary.Maybe
                        // results as having succeeded once we reach depth 0, but never record Ternary.Unknown results.
                        resetMaybeStack(/*markAllAsSucceeded*/ true);
                    }
                    else {
                        resetMaybeStack(/*markAllAsSucceeded*/ false);
                    }
                }
                // Note: it's intentional that we don't reset in the else case;
                // we leave them on the stack such that when we hit depth zero
                // above, we can report all of them as successful.
            }
            else {
                // A false result goes straight into global cache (when something is false under
                // assumptions it will also be false without assumptions)
                relation.set(id, RelationComparisonResult.Failed | propagatingVarianceFlags);
                relationCount--;
                resetMaybeStack(/*markAllAsSucceeded*/ false);
            }
            return result;

            function resetMaybeStack(markAllAsSucceeded: boolean) {
                for (let i = maybeStart; i < maybeCount; i++) {
                    maybeKeysSet.delete(maybeKeys[i]);
                    if (markAllAsSucceeded) {
                        relation.set(maybeKeys[i], RelationComparisonResult.Succeeded | propagatingVarianceFlags);
                        relationCount--;
                    }
                }
                maybeCount = maybeStart;
            }
        }

        function structuredTypeRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const saveErrorInfo = captureErrorCalculationState();
            let result = structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo);
            if (relation !== identityRelation) {
                // The combined constraint of an intersection type is the intersection of the constraints of
                // the constituents. When an intersection type contains instantiable types with union type
                // constraints, there are situations where we need to examine the combined constraint. One is
                // when the target is a union type. Another is when the intersection contains types belonging
                // to one of the disjoint domains. For example, given type variables T and U, each with the
                // constraint 'string | number', the combined constraint of 'T & U' is 'string | number' and
                // we need to check this constraint against a union on the target side. Also, given a type
                // variable V constrained to 'string | number', 'V & number' has a combined constraint of
                // 'string & number | number & number' which reduces to just 'number'.
                // This also handles type parameters, as a type parameter with a union constraint compared against a union
                // needs to have its constraint hoisted into an intersection with said type parameter, this way
                // the type param can be compared with itself in the target (with the influence of its constraint to match other parts)
                // For example, if `T extends 1 | 2` and `U extends 2 | 3` and we compare `T & U` to `T & U & (1 | 2 | 3)`
                if (!result && (source.flags & TypeFlags.Intersection || source.flags & TypeFlags.TypeParameter && target.flags & TypeFlags.Union)) {
                    const constraint = getEffectiveConstraintOfIntersection(source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source], !!(target.flags & TypeFlags.Union));
                    if (constraint && everyType(constraint, c => c !== source)) { // Skip comparison if expansion contains the source itself
                        // TODO: Stack errors so we get a pyramid for the "normal" comparison above, _and_ a second for this
                        result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                    }
                }
                // When the target is an intersection we need an extra property check in order to detect nested excess
                // properties and nested weak types. The following are motivating examples that all should be errors, but
                // aren't without this extra property check:
                //
                //   let obj: { a: { x: string } } & { c: number } = { a: { x: 'hello', y: 2 }, c: 5 };  // Nested excess property
                //
                //   declare let wrong: { a: { y: string } };
                //   let weak: { a?: { x?: number } } & { c?: string } = wrong;  // Nested weak object type
                //
                if (
                    result && !(intersectionState & IntersectionState.Target) && target.flags & TypeFlags.Intersection &&
                    !isGenericObjectType(target) && source.flags & (TypeFlags.Object | TypeFlags.Intersection)
                ) {
                    result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties*/ undefined, /*optionalsOnly*/ false, IntersectionState.None);
                    if (result && isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral) {
                        result &= indexSignaturesRelatedTo(source, target, /*sourceIsPrimitive*/ false, reportErrors, IntersectionState.None);
                    }
                }
                // When the source is an intersection we need an extra check of any optional properties in the target to
                // detect possible mismatched property types. For example:
                //
                //   function foo<T extends object>(x: { a?: string }, y: T & { a: boolean }) {
                //     x = y;  // Mismatched property in source intersection
                //   }
                //
                else if (
                    result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) &&
                    source.flags & TypeFlags.Intersection && getApparentType(source).flags & TypeFlags.StructuredType &&
                    !some((source as IntersectionType).types, t => t === target || !!(getObjectFlags(t) & ObjectFlags.NonInferrableType))
                ) {
                    result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties*/ undefined, /*optionalsOnly*/ true, intersectionState);
                }
            }
            if (result) {
                resetErrorInfo(saveErrorInfo);
            }
            return result;
        }

        function getApparentMappedTypeKeys(nameType: Type, targetType: MappedType) {
            const modifiersType = getApparentType(getModifiersTypeFromMappedType(targetType));
            const mappedKeys: Type[] = [];
            forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(
                modifiersType,
                TypeFlags.StringOrNumberLiteralOrUnique,
                /*stringsOnly*/ false,
                t => void mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t))),
            );
            return getUnionType(mappedKeys);
        }

        function structuredTypeRelatedToWorker(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState, saveErrorInfo: ReturnType<typeof captureErrorCalculationState>): Ternary {
            let result: Ternary;
            let originalErrorInfo: DiagnosticMessageChain | undefined;
            let varianceCheckFailed = false;
            let sourceFlags = source.flags;
            const targetFlags = target.flags;
            if (relation === identityRelation) {
                // We've already checked that source.flags and target.flags are identical
                if (sourceFlags & TypeFlags.UnionOrIntersection) {
                    let result = eachTypeRelatedToSomeType(source as UnionOrIntersectionType, target as UnionOrIntersectionType);
                    if (result) {
                        result &= eachTypeRelatedToSomeType(target as UnionOrIntersectionType, source as UnionOrIntersectionType);
                    }
                    return result;
                }
                if (sourceFlags & TypeFlags.Index) {
                    return isRelatedTo((source as IndexType).type, (target as IndexType).type, RecursionFlags.Both, /*reportErrors*/ false);
                }
                if (sourceFlags & TypeFlags.IndexedAccess) {
                    if (result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors*/ false)) {
                        if (result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors*/ false)) {
                            return result;
                        }
                    }
                }
                if (sourceFlags & TypeFlags.Conditional) {
                    if ((source as ConditionalType).root.isDistributive === (target as ConditionalType).root.isDistributive) {
                        if (result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors*/ false)) {
                            if (result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors*/ false)) {
                                if (result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors*/ false)) {
                                    if (result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors*/ false)) {
                                        return result;
                                    }
                                }
                            }
                        }
                    }
                }
                if (sourceFlags & TypeFlags.Substitution) {
                    if (result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors*/ false)) {
                        if (result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors*/ false)) {
                            return result;
                        }
                    }
                }
                if (sourceFlags & TypeFlags.TemplateLiteral) {
                    if (arrayIsEqualTo((source as TemplateLiteralType).texts, (target as TemplateLiteralType).texts)) {
                        const sourceTypes = (source as TemplateLiteralType).types;
                        const targetTypes = (target as TemplateLiteralType).types;
                        result = Ternary.True;
                        for (let i = 0; i < sourceTypes.length; i++) {
                            if (!(result &= isRelatedTo(sourceTypes[i], targetTypes[i], RecursionFlags.Both, /*reportErrors*/ false))) {
                                break;
                            }
                        }
                        return result;
                    }
                }
                if (sourceFlags & TypeFlags.StringMapping) {
                    if ((source as StringMappingType).symbol === (target as StringMappingType).symbol) {
                        return isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, /*reportErrors*/ false);
                    }
                }
                if (!(sourceFlags & TypeFlags.Object)) {
                    return Ternary.False;
                }
            }
            else if (sourceFlags & TypeFlags.UnionOrIntersection || targetFlags & TypeFlags.UnionOrIntersection) {
                if (result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState)) {
                    return result;
                }
                // The ordered decomposition above doesn't handle all cases. Specifically, we also need to handle:
                // Source is instantiable (e.g. source has union or intersection constraint).
                // Source is an object, target is a union (e.g. { a, b: boolean } <=> { a, b: true } | { a, b: false }).
                // Source is an intersection, target is an object (e.g. { a } & { b } <=> { a, b }).
                // Source is an intersection, target is a union (e.g. { a } & { b: boolean } <=> { a, b: true } | { a, b: false }).
                // Source is an intersection, target instantiable (e.g. string & { tag } <=> T["a"] constrained to string & { tag }).
                if (
                    !(sourceFlags & TypeFlags.Instantiable ||
                        sourceFlags & TypeFlags.Object && targetFlags & TypeFlags.Union ||
                        sourceFlags & TypeFlags.Intersection && targetFlags & (TypeFlags.Object | TypeFlags.Union | TypeFlags.Instantiable))
                ) {
                    return Ternary.False;
                }
            }

            // We limit alias variance probing to only object and conditional types since their alias behavior
            // is more predictable than other, interned types, which may or may not have an alias depending on
            // the order in which things were checked.
            if (
                sourceFlags & (TypeFlags.Object | TypeFlags.Conditional) && source.aliasSymbol && source.aliasTypeArguments &&
                source.aliasSymbol === target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target))
            ) {
                const variances = getAliasVariances(source.aliasSymbol);
                if (variances === emptyArray) {
                    return Ternary.Unknown;
                }
                const params = getSymbolLinks(source.aliasSymbol).typeParameters!;
                const minParams = getMinTypeArgumentCount(params);
                const sourceTypes = fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                const targetTypes = fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                const varianceResult = relateVariances(sourceTypes, targetTypes, variances, intersectionState);
                if (varianceResult !== undefined) {
                    return varianceResult;
                }
            }

            // For a generic type T and a type U that is assignable to T, [...U] is assignable to T, U is assignable to readonly [...T],
            // and U is assignable to [...T] when U is constrained to a mutable array or tuple type.
            if (
                isSingleElementGenericTupleType(source) && !source.target.readonly && (result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source)) ||
                isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && (result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target))
            ) {
                return result;
            }

            if (targetFlags & TypeFlags.TypeParameter) {
                // A source type { [P in Q]: X } is related to a target type T if keyof T is related to Q and X is related to T[Q].
                if (getObjectFlags(source) & ObjectFlags.Mapped && !(source as MappedType).declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source as MappedType), RecursionFlags.Both)) {
                    if (!(getMappedTypeModifiers(source as MappedType) & MappedTypeModifiers.IncludeOptional)) {
                        const templateType = getTemplateTypeFromMappedType(source as MappedType);
                        const indexedAccessType = getIndexedAccessType(target, getTypeParameterFromMappedType(source as MappedType));
                        if (result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors)) {
                            return result;
                        }
                    }
                }
                if (relation === comparableRelation && sourceFlags & TypeFlags.TypeParameter) {
                    // This is a carve-out in comparability to essentially forbid comparing a type parameter
                    // with another type parameter unless one extends the other. (Remember: comparability is mostly bidirectional!)
                    let constraint = getConstraintOfTypeParameter(source);
                    if (constraint) {
                        while (constraint && someType(constraint, c => !!(c.flags & TypeFlags.TypeParameter))) {
                            if (result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors*/ false)) {
                                return result;
                            }
                            constraint = getConstraintOfTypeParameter(constraint);
                        }
                    }
                    return Ternary.False;
                }
            }
            else if (targetFlags & TypeFlags.Index) {
                const targetType = (target as IndexType).type;
                // A keyof S is related to a keyof T if T is related to S.
                if (sourceFlags & TypeFlags.Index) {
                    if (result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors*/ false)) {
                        return result;
                    }
                }
                if (isTupleType(targetType)) {
                    // An index type can have a tuple type target when the tuple type contains variadic elements.
                    // Check if the source is related to the known keys of the tuple type.
                    if (result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors)) {
                        return result;
                    }
                }
                else {
                    // A type S is assignable to keyof T if S is assignable to keyof C, where C is the
                    // simplified form of T or, if T doesn't simplify, the constraint of T.
                    const constraint = getSimplifiedTypeOrConstraint(targetType);
                    if (constraint) {
                        // We require Ternary.True here such that circular constraints don't cause
                        // false positives. For example, given 'T extends { [K in keyof T]: string }',
                        // 'keyof T' has itself as its constraint and produces a Ternary.Maybe when
                        // related to other types.
                        if (isRelatedTo(source, getIndexType(constraint, (target as IndexType).indexFlags | IndexFlags.NoReducibleCheck), RecursionFlags.Target, reportErrors) === Ternary.True) {
                            return Ternary.True;
                        }
                    }
                    else if (isGenericMappedType(targetType)) {
                        // generic mapped types that don't simplify or have a constraint still have a very simple set of keys we can compare against
                        // - their nameType or constraintType.
                        // In many ways, this comparison is a deferred version of what `getIndexTypeForMappedType` does to actually resolve the keys for _non_-generic types

                        const nameType = getNameTypeFromMappedType(targetType);
                        const constraintType = getConstraintTypeFromMappedType(targetType);
                        let targetKeys;
                        if (nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType)) {
                            // we need to get the apparent mappings and union them with the generic mappings, since some properties may be
                            // missing from the `constraintType` which will otherwise be mapped in the object
                            const mappedKeys = getApparentMappedTypeKeys(nameType, targetType);
                            // We still need to include the non-apparent (and thus still generic) keys in the target side of the comparison (in case they're in the source side)
                            targetKeys = getUnionType([mappedKeys, nameType]);
                        }
                        else {
                            targetKeys = nameType || constraintType;
                        }
                        if (isRelatedTo(source, targetKeys, RecursionFlags.Target, reportErrors) === Ternary.True) {
                            return Ternary.True;
                        }
                    }
                }
            }
            else if (targetFlags & TypeFlags.IndexedAccess) {
                if (sourceFlags & TypeFlags.IndexedAccess) {
                    // Relate components directly before falling back to constraint relationships
                    // A type S[K] is related to a type T[J] if S is related to T and K is related to J.
                    if (result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors)) {
                        result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, reportErrors);
                    }
                    if (result) {
                        return result;
                    }
                    if (reportErrors) {
                        originalErrorInfo = errorInfo;
                    }
                }
                // A type S is related to a type T[K] if S is related to C, where C is the base
                // constraint of T[K] for writing.
                if (relation === assignableRelation || relation === comparableRelation) {
                    const objectType = (target as IndexedAccessType).objectType;
                    const indexType = (target as IndexedAccessType).indexType;
                    const baseObjectType = getBaseConstraintOfType(objectType) || objectType;
                    const baseIndexType = getBaseConstraintOfType(indexType) || indexType;
                    if (!isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType)) {
                        const accessFlags = AccessFlags.Writing | (baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0);
                        const constraint = getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags);
                        if (constraint) {
                            if (reportErrors && originalErrorInfo) {
                                // create a new chain for the constraint error
                                resetErrorInfo(saveErrorInfo);
                            }
                            if (result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage*/ undefined, intersectionState)) {
                                return result;
                            }
                            // prefer the shorter chain of the constraint comparison chain, and the direct comparison chain
                            if (reportErrors && originalErrorInfo && errorInfo) {
                                errorInfo = countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo;
                            }
                        }
                    }
                }
                if (reportErrors) {
                    originalErrorInfo = undefined;
                }
            }
            else if (isGenericMappedType(target) && relation !== identityRelation) {
                // Check if source type `S` is related to target type `{ [P in Q]: T }` or `{ [P in Q as R]: T}`.
                const keysRemapped = !!target.declaration.nameType;
                const templateType = getTemplateTypeFromMappedType(target);
                const modifiers = getMappedTypeModifiers(target);
                if (!(modifiers & MappedTypeModifiers.ExcludeOptional)) {
                    // If the mapped type has shape `{ [P in Q]: T[P] }`,
                    // source `S` is related to target if `T` = `S`, i.e. `S` is related to `{ [P in Q]: S[P] }`.
                    if (
                        !keysRemapped && templateType.flags & TypeFlags.IndexedAccess && (templateType as IndexedAccessType).objectType === source &&
                        (templateType as IndexedAccessType).indexType === getTypeParameterFromMappedType(target)
                    ) {
                        return Ternary.True;
                    }
                    if (!isGenericMappedType(source)) {
                        // If target has shape `{ [P in Q as R]: T}`, then its keys have type `R`.
                        // If target has shape `{ [P in Q]: T }`, then its keys have type `Q`.
                        const targetKeys = keysRemapped ? getNameTypeFromMappedType(target)! : getConstraintTypeFromMappedType(target);
                        // Type of the keys of source type `S`, i.e. `keyof S`.
                        const sourceKeys = getIndexType(source, IndexFlags.NoIndexSignatures);
                        const includeOptional = modifiers & MappedTypeModifiers.IncludeOptional;
                        const filteredByApplicability = includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined;
                        // A source type `S` is related to a target type `{ [P in Q]: T }` if `Q` is related to `keyof S` and `S[Q]` is related to `T`.
                        // A source type `S` is related to a target type `{ [P in Q as R]: T }` if `R` is related to `keyof S` and `S[R]` is related to `T.
                        // A source type `S` is related to a target type `{ [P in Q]?: T }` if some constituent `Q'` of `Q` is related to `keyof S` and `S[Q']` is related to `T`.
                        // A source type `S` is related to a target type `{ [P in Q as R]?: T }` if some constituent `R'` of `R` is related to `keyof S` and `S[R']` is related to `T`.
                        if (
                            includeOptional
                                ? !(filteredByApplicability!.flags & TypeFlags.Never)
                                : isRelatedTo(targetKeys, sourceKeys, RecursionFlags.Both)
                        ) {
                            const templateType = getTemplateTypeFromMappedType(target);
                            const typeParameter = getTypeParameterFromMappedType(target);

                            // Fastpath: When the template type has the form `Obj[P]` where `P` is the mapped type parameter, directly compare source `S` with `Obj`
                            // to avoid creating the (potentially very large) number of new intermediate types made by manufacturing `S[P]`.
                            const nonNullComponent = extractTypesOfKind(templateType, ~TypeFlags.Nullable);
                            if (!keysRemapped && nonNullComponent.flags & TypeFlags.IndexedAccess && (nonNullComponent as IndexedAccessType).indexType === typeParameter) {
                                if (result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors)) {
                                    return result;
                                }
                            }
                            else {
                                // We need to compare the type of a property on the source type `S` to the type of the same property on the target type,
                                // so we need to construct an indexing type representing a property, and then use indexing type to index the source type for comparison.

                                // If the target type has shape `{ [P in Q]: T }`, then a property of the target has type `P`.
                                // If the target type has shape `{ [P in Q]?: T }`, then a property of the target has type `P`,
                                // but the property is optional, so we only want to compare properties `P` that are common between `keyof S` and `Q`.
                                // If the target type has shape `{ [P in Q as R]: T }`, then a property of the target has type `R`.
                                // If the target type has shape `{ [P in Q as R]?: T }`, then a property of the target has type `R`,
                                // but the property is optional, so we only want to compare properties `R` that are common between `keyof S` and `R`.
                                const indexingType = keysRemapped
                                    ? (filteredByApplicability || targetKeys)
                                    : filteredByApplicability
                                    ? getIntersectionType([filteredByApplicability, typeParameter])
                                    : typeParameter;
                                const indexedAccessType = getIndexedAccessType(source, indexingType);
                                // Compare `S[indexingType]` to `T`, where `T` is the type of a property of the target type.
                                if (result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors)) {
                                    return result;
                                }
                            }
                        }
                        originalErrorInfo = errorInfo;
                        resetErrorInfo(saveErrorInfo);
                    }
                }
            }
            else if (targetFlags & TypeFlags.Conditional) {
                // If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
                // conditional type and bail out with a Ternary.Maybe result.
                if (isDeeplyNestedType(target, targetStack, targetDepth, 10)) {
                    return Ternary.Maybe;
                }
                const c = target as ConditionalType;
                // We check for a relationship to a conditional type target only when the conditional type has no
                // 'infer' positions, is not distributive or is distributive but doesn't reference the check type
                // parameter in either of the result types, and the source isn't an instantiation of the same
                // conditional type (as happens when computing variance).
                if (!c.root.inferTypeParameters && !isDistributionDependent(c.root) && !(source.flags & TypeFlags.Conditional && (source as ConditionalType).root === c.root)) {
                    // Check if the conditional is always true or always false but still deferred for distribution purposes.
                    const skipTrue = !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType));
                    const skipFalse = !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType));
                    // TODO: Find a nice way to include potential conditional type breakdowns in error output, if they seem good (they usually don't)
                    if (result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState)) {
                        result &= skipFalse ? Ternary.True : isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            else if (targetFlags & TypeFlags.TemplateLiteral) {
                if (sourceFlags & TypeFlags.TemplateLiteral) {
                    if (relation === comparableRelation) {
                        return templateLiteralTypesDefinitelyUnrelated(source as TemplateLiteralType, target as TemplateLiteralType) ? Ternary.False : Ternary.True;
                    }
                    // Report unreliable variance for type variables referenced in template literal type placeholders.
                    // For example, `foo-${number}` is related to `foo-${string}` even though number isn't related to string.
                    instantiateType(source, reportUnreliableMapper);
                }
                if (isTypeMatchedByTemplateLiteralType(source, target as TemplateLiteralType)) {
                    return Ternary.True;
                }
            }
            else if (target.flags & TypeFlags.StringMapping) {
                if (!(source.flags & TypeFlags.StringMapping)) {
                    if (isMemberOfStringMapping(source, target)) {
                        return Ternary.True;
                    }
                }
            }

            if (sourceFlags & TypeFlags.TypeVariable) {
                // IndexedAccess comparisons are handled above in the `targetFlags & TypeFlage.IndexedAccess` branch
                if (!(sourceFlags & TypeFlags.IndexedAccess && targetFlags & TypeFlags.IndexedAccess)) {
                    const constraint = getConstraintOfType(source as TypeVariable) || unknownType;
                    // hi-speed no-this-instantiation check (less accurate, but avoids costly `this`-instantiation when the constraint will suffice), see #28231 for report on why this is needed
                    if (result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState)) {
                        return result;
                    }
                    // slower, fuller, this-instantiated check (necessary when comparing raw `this` types from base classes), see `subclassWithPolymorphicThisIsAssignable.ts` test for example
                    else if (result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage*/ undefined, intersectionState)) {
                        return result;
                    }
                    if (isMappedTypeGenericIndexedAccess(source)) {
                        // For an indexed access type { [P in K]: E}[X], above we have already explored an instantiation of E with X
                        // substituted for P. We also want to explore type { [P in K]: E }[C], where C is the constraint of X.
                        const indexConstraint = getConstraintOfType((source as IndexedAccessType).indexType);
                        if (indexConstraint) {
                            if (result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors)) {
                                return result;
                            }
                        }
                    }
                }
            }
            else if (sourceFlags & TypeFlags.Index) {
                const isDeferredMappedIndex = shouldDeferIndexType((source as IndexType).type, (source as IndexType).indexFlags) && getObjectFlags((source as IndexType).type) & ObjectFlags.Mapped;
                if (result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex)) {
                    return result;
                }
                if (isDeferredMappedIndex) {
                    const mappedType = (source as IndexType).type as MappedType;
                    const nameType = getNameTypeFromMappedType(mappedType);
                    // Unlike on the target side, on the source side we do *not* include the generic part of the `nameType`, since that comes from a
                    // (potentially anonymous) mapped type local type parameter, so that'd never assign outside the mapped type body, but we still want to
                    // allow assignments of index types of identical (or similar enough) mapped types.
                    // eg, `keyof {[X in keyof A]: Obj[X]}` should be assignable to `keyof {[Y in keyof A]: Tup[Y]}` because both map over the same set of keys (`keyof A`).
                    // Without this source-side breakdown, a `keyof {[X in keyof A]: Obj[X]}` style type won't be assignable to anything except itself, which is much too strict.
                    const sourceMappedKeys = nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType) ? getApparentMappedTypeKeys(nameType, mappedType) : (nameType || getConstraintTypeFromMappedType(mappedType));
                    if (result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors)) {
                        return result;
                    }
                }
            }
            else if (sourceFlags & TypeFlags.TemplateLiteral && !(targetFlags & TypeFlags.Object)) {
                if (!(targetFlags & TypeFlags.TemplateLiteral)) {
                    const constraint = getBaseConstraintOfType(source);
                    if (constraint && constraint !== source && (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors))) {
                        return result;
                    }
                }
            }
            else if (sourceFlags & TypeFlags.StringMapping) {
                if (targetFlags & TypeFlags.StringMapping) {
                    if ((source as StringMappingType).symbol !== (target as StringMappingType).symbol) {
                        return Ternary.False;
                    }
                    if (result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors)) {
                        return result;
                    }
                }
                else {
                    const constraint = getBaseConstraintOfType(source);
                    if (constraint && (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors))) {
                        return result;
                    }
                }
            }
            else if (sourceFlags & TypeFlags.Conditional) {
                // If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
                // conditional type and bail out with a Ternary.Maybe result.
                if (isDeeplyNestedType(source, sourceStack, sourceDepth, 10)) {
                    return Ternary.Maybe;
                }
                if (targetFlags & TypeFlags.Conditional) {
                    // Two conditional types 'T1 extends U1 ? X1 : Y1' and 'T2 extends U2 ? X2 : Y2' are related if
                    // one of T1 and T2 is related to the other, U1 and U2 are identical types, X1 is related to X2,
                    // and Y1 is related to Y2.
                    const sourceParams = (source as ConditionalType).root.inferTypeParameters;
                    let sourceExtends = (source as ConditionalType).extendsType;
                    let mapper: TypeMapper | undefined;
                    if (sourceParams) {
                        // If the source has infer type parameters, we instantiate them in the context of the target
                        const ctx = createInferenceContext(sourceParams, /*signature*/ undefined, InferenceFlags.None, isRelatedToWorker);
                        inferTypes(ctx.inferences, (target as ConditionalType).extendsType, sourceExtends, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);
                        sourceExtends = instantiateType(sourceExtends, ctx.mapper);
                        mapper = ctx.mapper;
                    }
                    if (
                        isTypeIdenticalTo(sourceExtends, (target as ConditionalType).extendsType) &&
                        (isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both) || isRelatedTo((target as ConditionalType).checkType, (source as ConditionalType).checkType, RecursionFlags.Both))
                    ) {
                        if (result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors)) {
                            result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors);
                        }
                        if (result) {
                            return result;
                        }
                    }
                }
                // conditionals can be related to one another via normal constraint, as, eg, `A extends B ? O : never` should be assignable to `O`
                // when `O` is a conditional (`never` is trivially assignable to `O`, as is `O`!).
                const defaultConstraint = getDefaultConstraintOfConditionalType(source as ConditionalType);
                if (defaultConstraint) {
                    if (result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors)) {
                        return result;
                    }
                }
                // conditionals aren't related to one another via distributive constraint as it is much too inaccurate and allows way
                // more assignments than are desirable (since it maps the source check type to its constraint, it loses information).
                const distributiveConstraint = !(targetFlags & TypeFlags.Conditional) && hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source as ConditionalType) : undefined;
                if (distributiveConstraint) {
                    resetErrorInfo(saveErrorInfo);
                    if (result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors)) {
                        return result;
                    }
                }
            }
            else {
                // An empty object type is related to any mapped type that includes a '?' modifier.
                if (relation !== subtypeRelation && relation !== strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source)) {
                    return Ternary.True;
                }
                if (isGenericMappedType(target)) {
                    if (isGenericMappedType(source)) {
                        if (result = mappedTypeRelatedTo(source, target, reportErrors)) {
                            return result;
                        }
                    }
                    return Ternary.False;
                }
                const sourceIsPrimitive = !!(sourceFlags & TypeFlags.Primitive);
                if (relation !== identityRelation) {
                    source = getApparentType(source);
                    sourceFlags = source.flags;
                }
                else if (isGenericMappedType(source)) {
                    return Ternary.False;
                }
                if (
                    getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (source as TypeReference).target === (target as TypeReference).target &&
                    !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target))
                ) {
                    // When strictNullChecks is disabled, the element type of the empty array literal is undefinedWideningType,
                    // and an empty array literal wouldn't be assignable to a `never[]` without this check.
                    if (isEmptyArrayLiteralType(source)) {
                        return Ternary.True;
                    }
                    // We have type references to the same generic type, and the type references are not marker
                    // type references (which are intended by be compared structurally). Obtain the variance
                    // information for the type parameters and relate the type arguments accordingly.
                    const variances = getVariances((source as TypeReference).target);
                    // We return Ternary.Maybe for a recursive invocation of getVariances (signalled by emptyArray). This
                    // effectively means we measure variance only from type parameter occurrences that aren't nested in
                    // recursive instantiations of the generic type.
                    if (variances === emptyArray) {
                        return Ternary.Unknown;
                    }
                    const varianceResult = relateVariances(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), variances, intersectionState);
                    if (varianceResult !== undefined) {
                        return varianceResult;
                    }
                }
                else if (isReadonlyArrayType(target) ? everyType(source, isArrayOrTupleType) : isArrayType(target) && everyType(source, t => isTupleType(t) && !t.target.readonly)) {
                    if (relation !== identityRelation) {
                        return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType, RecursionFlags.Both, reportErrors);
                    }
                    else {
                        // By flags alone, we know that the `target` is a readonly array while the source is a normal array or tuple
                        // or `target` is an array and source is a tuple - in both cases the types cannot be identical, by construction
                        return Ternary.False;
                    }
                }
                else if (isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target)) {
                    const constraint = getBaseConstraintOrType(source);
                    if (constraint !== source) {
                        return isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors);
                    }
                }
                // A fresh empty object type is never a subtype of a non-empty object type. This ensures fresh({}) <: { [x: string]: xxx }
                // but not vice-versa. Without this rule, those types would be mutual subtypes.
                else if ((relation === subtypeRelation || relation === strictSubtypeRelation) && isEmptyObjectType(target) && getObjectFlags(target) & ObjectFlags.FreshLiteral && !isEmptyObjectType(source)) {
                    return Ternary.False;
                }
                // Even if relationship doesn't hold for unions, intersections, or generic type references,
                // it may hold in a structural comparison.
                // In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
                // to X. Failing both of those we want to check if the aggregation of A and B's members structurally
                // relates to X. Thus, we include intersection types on the source side here.
                if (sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) && targetFlags & TypeFlags.Object) {
                    // Report structural errors only if we haven't reported any errors yet
                    const reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo.errorInfo && !sourceIsPrimitive;
                    result = propertiesRelatedTo(source, target, reportStructuralErrors, /*excludedProperties*/ undefined, /*optionalsOnly*/ false, intersectionState);
                    if (result) {
                        result &= signaturesRelatedTo(source, target, SignatureKind.Call, reportStructuralErrors, intersectionState);
                        if (result) {
                            result &= signaturesRelatedTo(source, target, SignatureKind.Construct, reportStructuralErrors, intersectionState);
                            if (result) {
                                result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState);
                            }
                        }
                    }
                    if (varianceCheckFailed && result) {
                        errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo; // Use variance error (there is no structural one) and return false
                    }
                    else if (result) {
                        return result;
                    }
                }
                // If S is an object type and T is a discriminated union, S may be related to T if
                // there exists a constituent of T for every combination of the discriminants of S
                // with respect to T. We do not report errors here, as we will use the existing
                // error result from checking each constituent of the union.
                if (sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) && targetFlags & TypeFlags.Union) {
                    const objectOnlyTarget = extractTypesOfKind(target, TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Substitution);
                    if (objectOnlyTarget.flags & TypeFlags.Union) {
                        const result = typeRelatedToDiscriminatedType(source, objectOnlyTarget as UnionType);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            return Ternary.False;

            function countMessageChainBreadth(info: DiagnosticMessageChain[] | undefined): number {
                if (!info) return 0;
                return reduceLeft(info, (value, chain) => value + 1 + countMessageChainBreadth(chain.next), 0);
            }

            function relateVariances(sourceTypeArguments: readonly Type[] | undefined, targetTypeArguments: readonly Type[] | undefined, variances: VarianceFlags[], intersectionState: IntersectionState) {
                if (result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState)) {
                    return result;
                }
                if (some(variances, v => !!(v & VarianceFlags.AllowsStructuralFallback))) {
                    // If some type parameter was `Unmeasurable` or `Unreliable`, and we couldn't pass by assuming it was identical, then we
                    // have to allow a structural fallback check
                    // We elide the variance-based error elaborations, since those might not be too helpful, since we'll potentially
                    // be assuming identity of the type parameter.
                    originalErrorInfo = undefined;
                    resetErrorInfo(saveErrorInfo);
                    return undefined;
                }
                const allowStructuralFallback = targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances);
                varianceCheckFailed = !allowStructuralFallback;
                // The type arguments did not relate appropriately, but it may be because we have no variance
                // information (in which case typeArgumentsRelatedTo defaulted to covariance for all type
                // arguments). It might also be the case that the target type has a 'void' type argument for
                // a covariant type parameter that is only used in return positions within the generic type
                // (in which case any type argument is permitted on the source side). In those cases we proceed
                // with a structural comparison. Otherwise, we know for certain the instantiations aren't
                // related and we can return here.
                if (variances !== emptyArray && !allowStructuralFallback) {
                    // In some cases generic types that are covariant in regular type checking mode become
                    // invariant in --strictFunctionTypes mode because one or more type parameters are used in
                    // both co- and contravariant positions. In order to make it easier to diagnose *why* such
                    // types are invariant, if any of the type parameters are invariant we reset the reported
                    // errors and instead force a structural comparison (which will include elaborations that
                    // reveal the reason).
                    // We can switch on `reportErrors` here, since varianceCheckFailed guarantees we return `False`,
                    // we can return `False` early here to skip calculating the structural error message we don't need.
                    if (varianceCheckFailed && !(reportErrors && some(variances, v => (v & VarianceFlags.VarianceMask) === VarianceFlags.Invariant))) {
                        return Ternary.False;
                    }
                    // We remember the original error information so we can restore it in case the structural
                    // comparison unexpectedly succeeds. This can happen when the structural comparison result
                    // is a Ternary.Maybe for example caused by the recursion depth limiter.
                    originalErrorInfo = errorInfo;
                    resetErrorInfo(saveErrorInfo);
                }
            }
        }

        // A type [P in S]: X is related to a type [Q in T]: Y if T is related to S and X' is
        // related to Y, where X' is an instantiation of X in which P is replaced with Q. Notice
        // that S and T are contra-variant whereas X and Y are co-variant.
        function mappedTypeRelatedTo(source: MappedType, target: MappedType, reportErrors: boolean): Ternary {
            const modifiersRelated = relation === comparableRelation || (relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) :
                getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target));
            if (modifiersRelated) {
                let result: Ternary;
                const targetConstraint = getConstraintTypeFromMappedType(target);
                const sourceConstraint = instantiateType(getConstraintTypeFromMappedType(source), getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper);
                if (result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors)) {
                    const mapper = createTypeMapper([getTypeParameterFromMappedType(source)], [getTypeParameterFromMappedType(target)]);
                    if (instantiateType(getNameTypeFromMappedType(source), mapper) === instantiateType(getNameTypeFromMappedType(target), mapper)) {
                        return result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlags.Both, reportErrors);
                    }
                }
            }
            return Ternary.False;
        }

        function typeRelatedToDiscriminatedType(source: Type, target: UnionType) {
            // 1. Generate the combinations of discriminant properties & types 'source' can satisfy.
            //    a. If the number of combinations is above a set limit, the comparison is too complex.
            // 2. Filter 'target' to the subset of types whose discriminants exist in the matrix.
            //    a. If 'target' does not satisfy all discriminants in the matrix, 'source' is not related.
            // 3. For each type in the filtered 'target', determine if all non-discriminant properties of
            //    'target' are related to a property in 'source'.
            //
            // NOTE: See ~/tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts
            //       for examples.

            const sourceProperties = getPropertiesOfType(source);
            const sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
            if (!sourcePropertiesFiltered) return Ternary.False;

            // Though we could compute the number of combinations as we generate
            // the matrix, this would incur additional memory overhead due to
            // array allocations. To reduce this overhead, we first compute
            // the number of combinations to ensure we will not surpass our
            // fixed limit before incurring the cost of any allocations:
            let numCombinations = 1;
            for (const sourceProperty of sourcePropertiesFiltered) {
                numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty));
                if (numCombinations > 25) {
                    // We've reached the complexity limit.
                    tracing?.instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit", { sourceId: source.id, targetId: target.id, numCombinations });
                    return Ternary.False;
                }
            }

            // Compute the set of types for each discriminant property.
            const sourceDiscriminantTypes: Type[][] = new Array<Type[]>(sourcePropertiesFiltered.length);
            const excludedProperties = new Set<__String>();
            for (let i = 0; i < sourcePropertiesFiltered.length; i++) {
                const sourceProperty = sourcePropertiesFiltered[i];
                const sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);
                sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union
                    ? (sourcePropertyType as UnionType).types
                    : [sourcePropertyType];
                excludedProperties.add(sourceProperty.escapedName);
            }

            // Match each combination of the cartesian product of discriminant properties to one or more
            // constituents of 'target'. If any combination does not have a match then 'source' is not relatable.
            const discriminantCombinations = cartesianProduct(sourceDiscriminantTypes);
            const matchingTypes: Type[] = [];
            for (const combination of discriminantCombinations) {
                let hasMatch = false;
                outer:
                for (const type of target.types) {
                    for (let i = 0; i < sourcePropertiesFiltered.length; i++) {
                        const sourceProperty = sourcePropertiesFiltered[i];
                        const targetProperty = getPropertyOfType(type, sourceProperty.escapedName);
                        if (!targetProperty) continue outer;
                        if (sourceProperty === targetProperty) continue;
                        // We compare the source property to the target in the context of a single discriminant type.
                        const related = propertyRelatedTo(source, target, sourceProperty, targetProperty, _ => combination[i], /*reportErrors*/ false, IntersectionState.None, /*skipOptional*/ strictNullChecks || relation === comparableRelation);
                        // If the target property could not be found, or if the properties were not related,
                        // then this constituent is not a match.
                        if (!related) {
                            continue outer;
                        }
                    }
                    pushIfUnique(matchingTypes, type, equateValues);
                    hasMatch = true;
                }
                if (!hasMatch) {
                    // We failed to match any type for this combination.
                    return Ternary.False;
                }
            }

            // Compare the remaining non-discriminant properties of each match.
            let result = Ternary.True;
            for (const type of matchingTypes) {
                result &= propertiesRelatedTo(source, type, /*reportErrors*/ false, excludedProperties, /*optionalsOnly*/ false, IntersectionState.None);
                if (result) {
                    result &= signaturesRelatedTo(source, type, SignatureKind.Call, /*reportErrors*/ false, IntersectionState.None);
                    if (result) {
                        result &= signaturesRelatedTo(source, type, SignatureKind.Construct, /*reportErrors*/ false, IntersectionState.None);
                        if (result && !(isTupleType(source) && isTupleType(type))) {
                            // Comparing numeric index types when both `source` and `type` are tuples is unnecessary as the
                            // element types should be sufficiently covered by `propertiesRelatedTo`. It also causes problems
                            // with index type assignability as the types for the excluded discriminants are still included
                            // in the index type.
                            result &= indexSignaturesRelatedTo(source, type, /*sourceIsPrimitive*/ false, /*reportErrors*/ false, IntersectionState.None);
                        }
                    }
                }
                if (!result) {
                    return result;
                }
            }
            return result;
        }

        function excludeProperties(properties: Symbol[], excludedProperties: Set<__String> | undefined) {
            if (!excludedProperties || properties.length === 0) return properties;
            let result: Symbol[] | undefined;
            for (let i = 0; i < properties.length; i++) {
                if (!excludedProperties.has(properties[i].escapedName)) {
                    if (result) {
                        result.push(properties[i]);
                    }
                }
                else if (!result) {
                    result = properties.slice(0, i);
                }
            }
            return result || properties;
        }

        function isPropertySymbolTypeRelated(sourceProp: Symbol, targetProp: Symbol, getTypeOfSourceProperty: (sym: Symbol) => Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const targetIsOptional = strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlags.Partial);
            const effectiveTarget = addOptionality(getNonMissingTypeOfSymbol(targetProp), /*isProperty*/ false, targetIsOptional);
            // source could resolve to `any` and that's not related to `unknown` target under strict subtype relation
            if (effectiveTarget.flags & (relation === strictSubtypeRelation ? TypeFlags.Any : TypeFlags.AnyOrUnknown)) {
                return Ternary.True;
            }
            const effectiveSource = getTypeOfSourceProperty(sourceProp);
            return isRelatedTo(effectiveSource, effectiveTarget, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
        }

        function propertyRelatedTo(source: Type, target: Type, sourceProp: Symbol, targetProp: Symbol, getTypeOfSourceProperty: (sym: Symbol) => Type, reportErrors: boolean, intersectionState: IntersectionState, skipOptional: boolean): Ternary {
            const sourcePropFlags = getDeclarationModifierFlagsFromSymbol(sourceProp);
            const targetPropFlags = getDeclarationModifierFlagsFromSymbol(targetProp);
            if (sourcePropFlags & ModifierFlags.Private || targetPropFlags & ModifierFlags.Private) {
                if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
                    if (reportErrors) {
                        if (sourcePropFlags & ModifierFlags.Private && targetPropFlags & ModifierFlags.Private) {
                            reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));
                        }
                        else {
                            reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourcePropFlags & ModifierFlags.Private ? source : target), typeToString(sourcePropFlags & ModifierFlags.Private ? target : source));
                        }
                    }
                    return Ternary.False;
                }
            }
            else if (targetPropFlags & ModifierFlags.Protected) {
                if (!isValidOverrideOf(sourceProp, targetProp)) {
                    if (reportErrors) {
                        reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target));
                    }
                    return Ternary.False;
                }
            }
            else if (sourcePropFlags & ModifierFlags.Protected) {
                if (reportErrors) {
                    reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                }
                return Ternary.False;
            }

            // Ensure {readonly a: whatever} is not a subtype of {a: whatever},
            // while {a: whatever} is a subtype of {readonly a: whatever}.
            // This ensures the subtype relationship is ordered, and preventing declaration order
            // from deciding which type "wins" in union subtype reduction.
            // They're still assignable to one another, since `readonly` doesn't affect assignability.
            // This is only applied during the strictSubtypeRelation -- currently used in subtype reduction
            if (
                relation === strictSubtypeRelation &&
                isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp)
            ) {
                return Ternary.False;
            }
            // If the target comes from a partial union prop, allow `undefined` in the target type
            const related = isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState);
            if (!related) {
                if (reportErrors) {
                    reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp));
                }
                return Ternary.False;
            }
            // When checking for comparability, be more lenient with optional properties.
            if (!skipOptional && sourceProp.flags & SymbolFlags.Optional && targetProp.flags & SymbolFlags.ClassMember && !(targetProp.flags & SymbolFlags.Optional)) {
                // TypeScript 1.0 spec (April 2014): 3.8.3
                // S is a subtype of a type T, and T is a supertype of S if ...
                // S' and T are object types and, for each member M in T..
                // M is a property and S' contains a property N where
                // if M is a required property, N is also a required property
                // (M - property in T)
                // (N - property in S)
                if (reportErrors) {
                    reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                }
                return Ternary.False;
            }
            return related;
        }

        function reportUnmatchedProperty(source: Type, target: Type, unmatchedProperty: Symbol, requireOptionalProperties: boolean) {
            let shouldSkipElaboration = false;
            // give specific error in case where private names have the same description
            if (
                unmatchedProperty.valueDeclaration
                && isNamedDeclaration(unmatchedProperty.valueDeclaration)
                && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name)
                && source.symbol
                && source.symbol.flags & SymbolFlags.Class
            ) {
                const privateIdentifierDescription = unmatchedProperty.valueDeclaration.name.escapedText;
                const symbolTableKey = getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription);
                if (symbolTableKey && getPropertyOfType(source, symbolTableKey)) {
                    const sourceName = factory.getDeclarationName(source.symbol.valueDeclaration);
                    const targetName = factory.getDeclarationName(target.symbol.valueDeclaration);
                    reportError(
                        Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2,
                        diagnosticName(privateIdentifierDescription),
                        diagnosticName(sourceName.escapedText === "" ? anon : sourceName),
                        diagnosticName(targetName.escapedText === "" ? anon : targetName),
                    );
                    return;
                }
            }
            const props = arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, /*matchDiscriminantProperties*/ false));
            if (
                !headMessage || (headMessage.code !== Diagnostics.Class_0_incorrectly_implements_interface_1.code &&
                    headMessage.code !== Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code)
            ) {
                shouldSkipElaboration = true; // Retain top-level error for interface implementing issues, otherwise omit it
            }
            if (props.length === 1) {
                const propName = symbolToString(unmatchedProperty, /*enclosingDeclaration*/ undefined, SymbolFlags.None, SymbolFormatFlags.AllowAnyNodeKind | SymbolFormatFlags.WriteComputedProps);
                reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName, ...getTypeNamesForErrorDisplay(source, target));
                if (length(unmatchedProperty.declarations)) {
                    associateRelatedInfo(createDiagnosticForNode(unmatchedProperty.declarations![0], Diagnostics._0_is_declared_here, propName));
                }
                if (shouldSkipElaboration && errorInfo) {
                    overrideNextErrorInfo++;
                }
            }
            else if (tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ false)) {
                if (props.length > 5) { // arbitrary cutoff for too-long list form
                    reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), map(props.slice(0, 4), p => symbolToString(p)).join(", "), props.length - 4);
                }
                else {
                    reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map(props, p => symbolToString(p)).join(", "));
                }
                if (shouldSkipElaboration && errorInfo) {
                    overrideNextErrorInfo++;
                }
            }
            // No array like or unmatched property error - just issue top level error (errorInfo = undefined)
        }

        function propertiesRelatedTo(source: Type, target: Type, reportErrors: boolean, excludedProperties: Set<__String> | undefined, optionalsOnly: boolean, intersectionState: IntersectionState): Ternary {
            if (relation === identityRelation) {
                return propertiesIdenticalTo(source, target, excludedProperties);
            }
            let result = Ternary.True;
            if (isTupleType(target)) {
                if (isArrayOrTupleType(source)) {
                    if (!target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly)) {
                        return Ternary.False;
                    }
                    const sourceArity = getTypeReferenceArity(source);
                    const targetArity = getTypeReferenceArity(target);
                    const sourceRestFlag = isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest;
                    const targetHasRestElement = !!(target.target.combinedFlags & ElementFlags.Variable);
                    const sourceMinLength = isTupleType(source) ? source.target.minLength : 0;
                    const targetMinLength = target.target.minLength;
                    if (!sourceRestFlag && sourceArity < targetMinLength) {
                        if (reportErrors) {
                            reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength);
                        }
                        return Ternary.False;
                    }
                    if (!targetHasRestElement && targetArity < sourceMinLength) {
                        if (reportErrors) {
                            reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity);
                        }
                        return Ternary.False;
                    }
                    if (!targetHasRestElement && (sourceRestFlag || targetArity < sourceArity)) {
                        if (reportErrors) {
                            if (sourceMinLength < targetMinLength) {
                                reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength);
                            }
                            else {
                                reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity);
                            }
                        }
                        return Ternary.False;
                    }
                    const sourceTypeArguments = getTypeArguments(source);
                    const targetTypeArguments = getTypeArguments(target);
                    const targetStartCount = getStartElementCount(target.target, ElementFlags.NonRest);
                    const targetEndCount = getEndElementCount(target.target, ElementFlags.NonRest);
                    let canExcludeDiscriminants = !!excludedProperties;
                    for (let sourcePosition = 0; sourcePosition < sourceArity; sourcePosition++) {
                        const sourceFlags = isTupleType(source) ? source.target.elementFlags[sourcePosition] : ElementFlags.Rest;
                        const sourcePositionFromEnd = sourceArity - 1 - sourcePosition;

                        const targetPosition = targetHasRestElement && sourcePosition >= targetStartCount
                            ? targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)
                            : sourcePosition;

                        const targetFlags = target.target.elementFlags[targetPosition];

                        if (targetFlags & ElementFlags.Variadic && !(sourceFlags & ElementFlags.Variadic)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition);
                            }
                            return Ternary.False;
                        }
                        if (sourceFlags & ElementFlags.Variadic && !(targetFlags & ElementFlags.Variable)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition);
                            }
                            return Ternary.False;
                        }
                        if (targetFlags & ElementFlags.Required && !(sourceFlags & ElementFlags.Required)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition);
                            }
                            return Ternary.False;
                        }
                        // We can only exclude discriminant properties if we have not yet encountered a variable-length element.
                        if (canExcludeDiscriminants) {
                            if (sourceFlags & ElementFlags.Variable || targetFlags & ElementFlags.Variable) {
                                canExcludeDiscriminants = false;
                            }
                            if (canExcludeDiscriminants && excludedProperties?.has(("" + sourcePosition) as __String)) {
                                continue;
                            }
                        }

                        const sourceType = removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlags.Optional));
                        const targetType = targetTypeArguments[targetPosition];

                        const targetCheckType = sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(targetType) :
                            removeMissingType(targetType, !!(targetFlags & ElementFlags.Optional));
                        const related = isRelatedTo(sourceType, targetCheckType, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        if (!related) {
                            if (reportErrors && (targetArity > 1 || sourceArity > 1)) {
                                if (targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount !== sourceArity - targetEndCount - 1) {
                                    reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity - targetEndCount - 1, targetPosition);
                                }
                                else {
                                    reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition);
                                }
                            }
                            return Ternary.False;
                        }
                        result &= related;
                    }
                    return result;
                }
                if (target.target.combinedFlags & ElementFlags.Variable) {
                    return Ternary.False;
                }
            }
            const requireOptionalProperties = (relation === subtypeRelation || relation === strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source);
            const unmatchedProperty = getUnmatchedProperty(source, target, requireOptionalProperties, /*matchDiscriminantProperties*/ false);
            if (unmatchedProperty) {
                if (reportErrors && shouldReportUnmatchedPropertyError(source, target)) {
                    reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties);
                }
                return Ternary.False;
            }
            if (isObjectLiteralType(target)) {
                for (const sourceProp of excludeProperties(getPropertiesOfType(source), excludedProperties)) {
                    if (!getPropertyOfObjectType(target, sourceProp.escapedName)) {
                        const sourceType = getTypeOfSymbol(sourceProp);
                        if (!(sourceType.flags & TypeFlags.Undefined)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target));
                            }
                            return Ternary.False;
                        }
                    }
                }
            }
            // We only call this for union target types when we're attempting to do excess property checking - in those cases, we want to get _all possible props_
            // from the target union, across all members
            const properties = getPropertiesOfType(target);
            const numericNamesOnly = isTupleType(source) && isTupleType(target);
            for (const targetProp of excludeProperties(properties, excludedProperties)) {
                const name = targetProp.escapedName;
                if (!(targetProp.flags & SymbolFlags.Prototype) && (!numericNamesOnly || isNumericLiteralName(name) || name === "length") && (!optionalsOnly || targetProp.flags & SymbolFlags.Optional)) {
                    const sourceProp = getPropertyOfType(source, name);
                    if (sourceProp && sourceProp !== targetProp) {
                        const related = propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation === comparableRelation);
                        if (!related) {
                            return Ternary.False;
                        }
                        result &= related;
                    }
                }
            }
            return result;
        }

        function propertiesIdenticalTo(source: Type, target: Type, excludedProperties: Set<__String> | undefined): Ternary {
            if (!(source.flags & TypeFlags.Object && target.flags & TypeFlags.Object)) {
                return Ternary.False;
            }
            const sourceProperties = excludeProperties(getPropertiesOfObjectType(source), excludedProperties);
            const targetProperties = excludeProperties(getPropertiesOfObjectType(target), excludedProperties);
            if (sourceProperties.length !== targetProperties.length) {
                return Ternary.False;
            }
            let result = Ternary.True;
            for (const sourceProp of sourceProperties) {
                const targetProp = getPropertyOfObjectType(target, sourceProp.escapedName);
                if (!targetProp) {
                    return Ternary.False;
                }
                const related = compareProperties(sourceProp, targetProp, isRelatedTo);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function signaturesRelatedTo(source: Type, target: Type, kind: SignatureKind, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            if (relation === identityRelation) {
                return signaturesIdenticalTo(source, target, kind);
            }
            if (target === anyFunctionType || source === anyFunctionType) {
                return Ternary.True;
            }

            const sourceIsJSConstructor = source.symbol && isJSConstructor(source.symbol.valueDeclaration);
            const targetIsJSConstructor = target.symbol && isJSConstructor(target.symbol.valueDeclaration);

            const sourceSignatures = getSignaturesOfType(
                source,
                (sourceIsJSConstructor && kind === SignatureKind.Construct) ?
                    SignatureKind.Call : kind,
            );
            const targetSignatures = getSignaturesOfType(
                target,
                (targetIsJSConstructor && kind === SignatureKind.Construct) ?
                    SignatureKind.Call : kind,
            );

            if (kind === SignatureKind.Construct && sourceSignatures.length && targetSignatures.length) {
                const sourceIsAbstract = !!(sourceSignatures[0].flags & SignatureFlags.Abstract);
                const targetIsAbstract = !!(targetSignatures[0].flags & SignatureFlags.Abstract);
                if (sourceIsAbstract && !targetIsAbstract) {
                    // An abstract constructor type is not assignable to a non-abstract constructor type
                    // as it would otherwise be possible to new an abstract class. Note that the assignability
                    // check we perform for an extends clause excludes construct signatures from the target,
                    // so this check never proceeds.
                    if (reportErrors) {
                        reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type);
                    }
                    return Ternary.False;
                }
                if (!constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors)) {
                    return Ternary.False;
                }
            }

            let result = Ternary.True;
            const incompatibleReporter = kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn;
            const sourceObjectFlags = getObjectFlags(source);
            const targetObjectFlags = getObjectFlags(target);
            if (
                sourceObjectFlags & ObjectFlags.Instantiated && targetObjectFlags & ObjectFlags.Instantiated && source.symbol === target.symbol ||
                sourceObjectFlags & ObjectFlags.Reference && targetObjectFlags & ObjectFlags.Reference && (source as TypeReference).target === (target as TypeReference).target
            ) {
                // We have instantiations of the same anonymous type (which typically will be the type of a
                // method). Simply do a pairwise comparison of the signatures in the two signature lists instead
                // of the much more expensive N * M comparison matrix we explore below. We erase type parameters
                // as they are known to always be the same.
                Debug.assertEqual(sourceSignatures.length, targetSignatures.length);
                for (let i = 0; i < targetSignatures.length; i++) {
                    const related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase*/ true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));
                    if (!related) {
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            else if (sourceSignatures.length === 1 && targetSignatures.length === 1) {
                // For simple functions (functions with a single signature) we only erase type parameters for
                // the comparable relation. Otherwise, if the source signature is generic, we instantiate it
                // in the context of the target signature before checking the relationship. Ideally we'd do
                // this regardless of the number of signatures, but the potential costs are prohibitive due
                // to the quadratic nature of the logic below.
                const eraseGenerics = relation === comparableRelation;
                const sourceSignature = first(sourceSignatures);
                const targetSignature = first(targetSignatures);
                result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature));
                if (
                    !result && reportErrors && kind === SignatureKind.Construct && (sourceObjectFlags & targetObjectFlags) &&
                    (targetSignature.declaration?.kind === SyntaxKind.Constructor || sourceSignature.declaration?.kind === SyntaxKind.Constructor)
                ) {
                    const constructSignatureToString = (signature: Signature) => signatureToString(signature, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrowStyleSignature, kind);
                    reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature));
                    reportError(Diagnostics.Types_of_construct_signatures_are_incompatible);
                    return result;
                }
            }
            else {
                outer:
                for (const t of targetSignatures) {
                    const saveErrorInfo = captureErrorCalculationState();
                    // Only elaborate errors from the first failure
                    let shouldElaborateErrors = reportErrors;
                    for (const s of sourceSignatures) {
                        const related = signatureRelatedTo(s, t, /*erase*/ true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t));
                        if (related) {
                            result &= related;
                            resetErrorInfo(saveErrorInfo);
                            continue outer;
                        }
                        shouldElaborateErrors = false;
                    }
                    if (shouldElaborateErrors) {
                        reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration*/ undefined, /*flags*/ undefined, kind));
                    }
                    return Ternary.False;
                }
            }
            return result;
        }

        function shouldReportUnmatchedPropertyError(source: Type, target: Type): boolean {
            const typeCallSignatures = getSignaturesOfStructuredType(source, SignatureKind.Call);
            const typeConstructSignatures = getSignaturesOfStructuredType(source, SignatureKind.Construct);
            const typeProperties = getPropertiesOfObjectType(source);
            if ((typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length) {
                if (
                    (getSignaturesOfType(target, SignatureKind.Call).length && typeCallSignatures.length) ||
                    (getSignaturesOfType(target, SignatureKind.Construct).length && typeConstructSignatures.length)
                ) {
                    return true; // target has similar signature kinds to source, still focus on the unmatched property
                }
                return false;
            }
            return true;
        }

        function reportIncompatibleCallSignatureReturn(siga: Signature, sigb: Signature) {
            if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
                return (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target));
            }
            return (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target));
        }

        function reportIncompatibleConstructSignatureReturn(siga: Signature, sigb: Signature) {
            if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
                return (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target));
            }
            return (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target));
        }

        /**
         * See signatureAssignableTo, compareSignaturesIdentical
         */
        function signatureRelatedTo(source: Signature, target: Signature, erase: boolean, reportErrors: boolean, intersectionState: IntersectionState, incompatibleReporter: (source: Type, target: Type) => void): Ternary {
            const checkMode = relation === subtypeRelation ? SignatureCheckMode.StrictTopSignature :
                relation === strictSubtypeRelation ? SignatureCheckMode.StrictTopSignature | SignatureCheckMode.StrictArity :
                SignatureCheckMode.None;
            return compareSignaturesRelated(erase ? getErasedSignature(source) : source, erase ? getErasedSignature(target) : target, checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper);
            function isRelatedToWorker(source: Type, target: Type, reportErrors?: boolean) {
                return isRelatedTo(source, target, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
            }
        }

        function signaturesIdenticalTo(source: Type, target: Type, kind: SignatureKind): Ternary {
            const sourceSignatures = getSignaturesOfType(source, kind);
            const targetSignatures = getSignaturesOfType(target, kind);
            if (sourceSignatures.length !== targetSignatures.length) {
                return Ternary.False;
            }
            let result = Ternary.True;
            for (let i = 0; i < sourceSignatures.length; i++) {
                const related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, isRelatedTo);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function membersRelatedToIndexInfo(source: Type, targetInfo: IndexInfo, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            let result = Ternary.True;
            const keyType = targetInfo.keyType;
            const props = source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(source as IntersectionType) : getPropertiesOfObjectType(source);
            for (const prop of props) {
                // Skip over ignored JSX and symbol-named members
                if (isIgnoredJsxProperty(source, prop)) {
                    continue;
                }
                if (isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique), keyType)) {
                    const propType = getNonMissingTypeOfSymbol(prop);
                    const type = exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional)
                        ? propType
                        : getTypeWithFacts(propType, TypeFacts.NEUndefined);
                    const related = isRelatedTo(type, targetInfo.type, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                    if (!related) {
                        if (reportErrors) {
                            reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));
                        }
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            for (const info of getIndexInfosOfType(source)) {
                if (isApplicableIndexType(info.keyType, keyType)) {
                    const related = indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState);
                    if (!related) {
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            return result;
        }

        function indexInfoRelatedTo(sourceInfo: IndexInfo, targetInfo: IndexInfo, reportErrors: boolean, intersectionState: IntersectionState) {
            const related = isRelatedTo(sourceInfo.type, targetInfo.type, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
            if (!related && reportErrors) {
                if (sourceInfo.keyType === targetInfo.keyType) {
                    reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType));
                }
                else {
                    reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType));
                }
            }
            return related;
        }

        function indexSignaturesRelatedTo(source: Type, target: Type, sourceIsPrimitive: boolean, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            if (relation === identityRelation) {
                return indexSignaturesIdenticalTo(source, target);
            }
            const indexInfos = getIndexInfosOfType(target);
            const targetHasStringIndex = some(indexInfos, info => info.keyType === stringType);
            let result = Ternary.True;
            for (const targetInfo of indexInfos) {
                const related = relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True :
                    isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, RecursionFlags.Both, reportErrors) :
                    typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function typeRelatedToIndexInfo(source: Type, targetInfo: IndexInfo, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
            if (sourceInfo) {
                return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState);
            }
            // Intersection constituents are never considered to have an inferred index signature. Also, in the strict subtype relation,
            // only fresh object literals are considered to have inferred index signatures. This ensures { [x: string]: xxx } <: {} but
            // not vice-versa. Without this rule, those types would be mutual strict subtypes.
            if (!(intersectionState & IntersectionState.Source) && (relation !== strictSubtypeRelation || getObjectFlags(source) & ObjectFlags.FreshLiteral) && isObjectTypeWithInferableIndex(source)) {
                return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState);
            }
            if (reportErrors) {
                reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source));
            }
            return Ternary.False;
        }

        function indexSignaturesIdenticalTo(source: Type, target: Type): Ternary {
            const sourceInfos = getIndexInfosOfType(source);
            const targetInfos = getIndexInfosOfType(target);
            if (sourceInfos.length !== targetInfos.length) {
                return Ternary.False;
            }
            for (const targetInfo of targetInfos) {
                const sourceInfo = getIndexInfoOfType(source, targetInfo.keyType);
                if (!(sourceInfo && isRelatedTo(sourceInfo.type, targetInfo.type, RecursionFlags.Both) && sourceInfo.isReadonly === targetInfo.isReadonly)) {
                    return Ternary.False;
                }
            }
            return Ternary.True;
        }

        function constructorVisibilitiesAreCompatible(sourceSignature: Signature, targetSignature: Signature, reportErrors: boolean) {
            if (!sourceSignature.declaration || !targetSignature.declaration) {
                return true;
            }

            const sourceAccessibility = getSelectedEffectiveModifierFlags(sourceSignature.declaration, ModifierFlags.NonPublicAccessibilityModifier);
            const targetAccessibility = getSelectedEffectiveModifierFlags(targetSignature.declaration, ModifierFlags.NonPublicAccessibilityModifier);

            // A public, protected and private signature is assignable to a private signature.
            if (targetAccessibility === ModifierFlags.Private) {
                return true;
            }

            // A public and protected signature is assignable to a protected signature.
            if (targetAccessibility === ModifierFlags.Protected && sourceAccessibility !== ModifierFlags.Private) {
                return true;
            }

            // Only a public signature is assignable to public signature.
            if (targetAccessibility !== ModifierFlags.Protected && !sourceAccessibility) {
                return true;
            }

            if (reportErrors) {
                reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility));
            }

            return false;
        }
    }

    function typeCouldHaveTopLevelSingletonTypes(type: Type): boolean {
        // Okay, yes, 'boolean' is a union of 'true | false', but that's not useful
        // in error reporting scenarios. If you need to use this function but that detail matters,
        // feel free to add a flag.
        if (type.flags & TypeFlags.Boolean) {
            return false;
        }

        if (type.flags & TypeFlags.UnionOrIntersection) {
            return !!forEach((type as IntersectionType).types, typeCouldHaveTopLevelSingletonTypes);
        }

        if (type.flags & TypeFlags.Instantiable) {
            const constraint = getConstraintOfType(type);
            if (constraint && constraint !== type) {
                return typeCouldHaveTopLevelSingletonTypes(constraint);
            }
        }

        return isUnitType(type) || !!(type.flags & TypeFlags.TemplateLiteral) || !!(type.flags & TypeFlags.StringMapping);
    }

    function getExactOptionalUnassignableProperties(source: Type, target: Type) {
        if (isTupleType(source) && isTupleType(target)) return emptyArray;
        return getPropertiesOfType(target)
            .filter(targetProp => isExactOptionalPropertyMismatch(getTypeOfPropertyOfType(source, targetProp.escapedName), getTypeOfSymbol(targetProp)));
    }

    function isExactOptionalPropertyMismatch(source: Type | undefined, target: Type | undefined) {
        return !!source && !!target && maybeTypeOfKind(source, TypeFlags.Undefined) && !!containsMissingType(target);
    }

    function getExactOptionalProperties(type: Type) {
        return getPropertiesOfType(type).filter(targetProp => containsMissingType(getTypeOfSymbol(targetProp)));
    }

    function getBestMatchingType(source: Type, target: UnionOrIntersectionType, isRelatedTo = compareTypesAssignable) {
        return findMatchingDiscriminantType(source, target, isRelatedTo) ||
            findMatchingTypeReferenceOrTypeAliasReference(source, target) ||
            findBestTypeForObjectLiteral(source, target) ||
            findBestTypeForInvokable(source, target) ||
            findMostOverlappyType(source, target);
    }

    function discriminateTypeByDiscriminableItems(target: UnionType, discriminators: (readonly [() => Type, __String])[], related: (source: Type, target: Type) => boolean | Ternary) {
        const types = target.types;
        const include: Ternary[] = types.map(t => t.flags & TypeFlags.Primitive ? Ternary.False : Ternary.True);
        for (const [getDiscriminatingType, propertyName] of discriminators) {
            // If the remaining target types include at least one with a matching discriminant, eliminate those that
            // have non-matching discriminants. This ensures that we ignore erroneous discriminators and gradually
            // refine the target set without eliminating every constituent (which would lead to `never`).
            let matched = false;
            for (let i = 0; i < types.length; i++) {
                if (include[i]) {
                    const targetType = getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName);
                    if (targetType) {
                        if (someType(getDiscriminatingType(), t => !!related(t, targetType))) {
                            matched = true;
                        }
                        else {
                            include[i] = Ternary.Maybe;
                        }
                    }
                }
            }
            // Turn each Ternary.Maybe into Ternary.False if there was a match. Otherwise, revert to Ternary.True.
            for (let i = 0; i < types.length; i++) {
                if (include[i] === Ternary.Maybe) {
                    include[i] = matched ? Ternary.False : Ternary.True;
                }
            }
        }
        const filtered = contains(include, Ternary.False) ? getUnionType(types.filter((_, i) => include[i]), UnionReduction.None) : target;
        return filtered.flags & TypeFlags.Never ? target : filtered;
    }

    /**
     * A type is 'weak' if it is an object type with at least one optional property
     * and no required properties, call/construct signatures or index signatures
     */
    function isWeakType(type: Type): boolean {
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            return resolved.callSignatures.length === 0 && resolved.constructSignatures.length === 0 && resolved.indexInfos.length === 0 &&
                resolved.properties.length > 0 && every(resolved.properties, p => !!(p.flags & SymbolFlags.Optional));
        }
        if (type.flags & TypeFlags.Substitution) {
            return isWeakType((type as SubstitutionType).baseType);
        }
        if (type.flags & TypeFlags.Intersection) {
            return every((type as IntersectionType).types, isWeakType);
        }
        return false;
    }

    function hasCommonProperties(source: Type, target: Type, isComparingJsxAttributes: boolean) {
        for (const prop of getPropertiesOfType(source)) {
            if (isKnownProperty(target, prop.escapedName, isComparingJsxAttributes)) {
                return true;
            }
        }
        return false;
    }

    function getVariances(type: GenericType): VarianceFlags[] {
        // Arrays and tuples are known to be covariant, no need to spend time computing this.
        return type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple ?
            arrayVariances :
            getVariancesWorker(type.symbol, type.typeParameters);
    }

    function getAliasVariances(symbol: Symbol) {
        return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters);
    }

    // Return an array containing the variance of each type parameter. The variance is effectively
    // a digest of the type comparisons that occur for each type argument when instantiations of the
    // generic type are structurally compared. We infer the variance information by comparing
    // instantiations of the generic type for type arguments with known relations. The function
    // returns the emptyArray singleton when invoked recursively for the given generic type.
    function getVariancesWorker(symbol: Symbol, typeParameters: readonly TypeParameter[] = emptyArray): VarianceFlags[] {
        const links = getSymbolLinks(symbol);
        if (!links.variances) {
            tracing?.push(tracing.Phase.CheckTypes, "getVariancesWorker", { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) });
            const oldVarianceComputation = inVarianceComputation;
            const saveResolutionStart = resolutionStart;
            if (!inVarianceComputation) {
                inVarianceComputation = true;
                resolutionStart = resolutionTargets.length;
            }
            links.variances = emptyArray;
            const variances = [];
            for (const tp of typeParameters) {
                const modifiers = getTypeParameterModifiers(tp);
                let variance = modifiers & ModifierFlags.Out ?
                    modifiers & ModifierFlags.In ? VarianceFlags.Invariant : VarianceFlags.Covariant :
                    modifiers & ModifierFlags.In ? VarianceFlags.Contravariant : undefined;
                if (variance === undefined) {
                    let unmeasurable = false;
                    let unreliable = false;
                    const oldHandler = outofbandVarianceMarkerHandler;
                    outofbandVarianceMarkerHandler = onlyUnreliable => onlyUnreliable ? unreliable = true : unmeasurable = true;
                    // We first compare instantiations where the type parameter is replaced with
                    // marker types that have a known subtype relationship. From this we can infer
                    // invariance, covariance, contravariance or bivariance.
                    const typeWithSuper = createMarkerType(symbol, tp, markerSuperType);
                    const typeWithSub = createMarkerType(symbol, tp, markerSubType);
                    variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0) |
                        (isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0);
                    // If the instantiations appear to be related bivariantly it may be because the
                    // type parameter is independent (i.e. it isn't witnessed anywhere in the generic
                    // type). To determine this we compare instantiations where the type parameter is
                    // replaced with marker types that are known to be unrelated.
                    if (variance === VarianceFlags.Bivariant && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper)) {
                        variance = VarianceFlags.Independent;
                    }
                    outofbandVarianceMarkerHandler = oldHandler;
                    if (unmeasurable || unreliable) {
                        if (unmeasurable) {
                            variance |= VarianceFlags.Unmeasurable;
                        }
                        if (unreliable) {
                            variance |= VarianceFlags.Unreliable;
                        }
                    }
                }
                variances.push(variance);
            }
            if (!oldVarianceComputation) {
                inVarianceComputation = false;
                resolutionStart = saveResolutionStart;
            }
            links.variances = variances;
            tracing?.pop({ variances: variances.map(Debug.formatVariance) });
        }
        return links.variances;
    }

    function createMarkerType(symbol: Symbol, source: TypeParameter, target: Type) {
        const mapper = makeUnaryTypeMapper(source, target);
        const type = getDeclaredTypeOfSymbol(symbol);
        if (isErrorType(type)) {
            return type;
        }
        const result = symbol.flags & SymbolFlags.TypeAlias ?
            getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters!, mapper)) :
            createTypeReference(type as GenericType, instantiateTypes((type as GenericType).typeParameters, mapper));
        markerTypes.add(getTypeId(result));
        return result;
    }

    function isMarkerType(type: Type) {
        return markerTypes.has(getTypeId(type));
    }

    function getTypeParameterModifiers(tp: TypeParameter): ModifierFlags {
        return reduceLeft(tp.symbol?.declarations, (modifiers, d) => modifiers | getEffectiveModifierFlags(d), ModifierFlags.None) & (ModifierFlags.In | ModifierFlags.Out | ModifierFlags.Const);
    }

    // Return true if the given type reference has a 'void' type argument for a covariant type parameter.
    // See comment at call in recursiveTypeRelatedTo for when this case matters.
    function hasCovariantVoidArgument(typeArguments: readonly Type[], variances: VarianceFlags[]): boolean {
        for (let i = 0; i < variances.length; i++) {
            if ((variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void) {
                return true;
            }
        }
        return false;
    }

    function isUnconstrainedTypeParameter(type: Type) {
        return type.flags & TypeFlags.TypeParameter && !getConstraintOfTypeParameter(type as TypeParameter);
    }

    function isNonDeferredTypeReference(type: Type): type is TypeReference {
        return !!(getObjectFlags(type) & ObjectFlags.Reference) && !(type as TypeReference).node;
    }

    function isTypeReferenceWithGenericArguments(type: Type): boolean {
        return isNonDeferredTypeReference(type) && some(getTypeArguments(type), t => !!(t.flags & TypeFlags.TypeParameter) || isTypeReferenceWithGenericArguments(t));
    }

    function getGenericTypeReferenceRelationKey(source: TypeReference, target: TypeReference, postFix: string, ignoreConstraints: boolean) {
        const typeParameters: Type[] = [];
        let constraintMarker = "";
        const sourceId = getTypeReferenceId(source, 0);
        const targetId = getTypeReferenceId(target, 0);
        return `${constraintMarker}${sourceId},${targetId}${postFix}`;
        // getTypeReferenceId(A<T, number, U>) returns "111=0-12=1"
        // where A.id=111 and number.id=12
        function getTypeReferenceId(type: TypeReference, depth = 0) {
            let result = "" + type.target.id;
            for (const t of getTypeArguments(type)) {
                if (t.flags & TypeFlags.TypeParameter) {
                    if (ignoreConstraints || isUnconstrainedTypeParameter(t)) {
                        let index = typeParameters.indexOf(t);
                        if (index < 0) {
                            index = typeParameters.length;
                            typeParameters.push(t);
                        }
                        result += "=" + index;
                        continue;
                    }
                    // We mark type references that reference constrained type parameters such that we know to obtain
                    // and look for a "broadest equivalent key" in the cache.
                    constraintMarker = "*";
                }
                else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {
                    result += "<" + getTypeReferenceId(t as TypeReference, depth + 1) + ">";
                    continue;
                }
                result += "-" + t.id;
            }
            return result;
        }
    }

    /**
     * To improve caching, the relation key for two generic types uses the target's id plus ids of the type parameters.
     * For other cases, the types ids are used.
     */
    function getRelationKey(source: Type, target: Type, intersectionState: IntersectionState, relation: Map<string, RelationComparisonResult>, ignoreConstraints: boolean) {
        if (relation === identityRelation && source.id > target.id) {
            const temp = source;
            source = target;
            target = temp;
        }
        const postFix = intersectionState ? ":" + intersectionState : "";
        return isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ?
            getGenericTypeReferenceRelationKey(source as TypeReference, target as TypeReference, postFix, ignoreConstraints) :
            `${source.id},${target.id}${postFix}`;
    }

    // Invoke the callback for each underlying property symbol of the given symbol and return the first
    // value that isn't undefined.
    function forEachProperty<T>(prop: Symbol, callback: (p: Symbol) => T): T | undefined {
        if (getCheckFlags(prop) & CheckFlags.Synthetic) {
            // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.Synthetic
            for (const t of (prop as TransientSymbol).links.containingType!.types) {
                const p = getPropertyOfType(t, prop.escapedName);
                const result = p && forEachProperty(p, callback);
                if (result) {
                    return result;
                }
            }
            return undefined;
        }
        return callback(prop);
    }

    // Return the declaring class type of a property or undefined if property not declared in class
    function getDeclaringClass(prop: Symbol) {
        return prop.parent && prop.parent.flags & SymbolFlags.Class ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)!) as InterfaceType : undefined;
    }

    // Return the inherited type of the given property or undefined if property doesn't exist in a base class.
    function getTypeOfPropertyInBaseClass(property: Symbol) {
        const classType = getDeclaringClass(property);
        const baseClassType = classType && getBaseTypes(classType)[0];
        return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName);
    }

    // Return true if some underlying source property is declared in a class that derives
    // from the given base class.
    function isPropertyInClassDerivedFrom(prop: Symbol, baseClass: Type | undefined) {
        return forEachProperty(prop, sp => {
            const sourceClass = getDeclaringClass(sp);
            return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
        });
    }

    // Return true if source property is a valid override of protected parts of target property.
    function isValidOverrideOf(sourceProp: Symbol, targetProp: Symbol) {
        return !forEachProperty(targetProp, tp =>
            getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ?
                !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false);
    }

    // Return true if the given class derives from each of the declaring classes of the protected
    // constituents of the given property.
    function isClassDerivedFromDeclaringClasses<T extends Type>(checkClass: T, prop: Symbol, writing: boolean) {
        return forEachProperty(prop, p =>
                getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlags.Protected ?
                    !hasBaseType(checkClass, getDeclaringClass(p)) : false) ? undefined : checkClass;
    }

    // Return true if the given type is deeply nested. We consider this to be the case when the given stack contains
    // maxDepth or more occurrences of types with the same recursion identity as the given type. The recursion identity
    // provides a shared identity for type instantiations that repeat in some (possibly infinite) pattern. For example,
    // in `type Deep<T> = { next: Deep<Deep<T>> }`, repeatedly referencing the `next` property leads to an infinite
    // sequence of ever deeper instantiations with the same recursion identity (in this case the symbol associated with
    // the object type literal).
    // A homomorphic mapped type is considered deeply nested if its target type is deeply nested, and an intersection is
    // considered deeply nested if any constituent of the intersection is deeply nested.
    // It is possible, though highly unlikely, for the deeply nested check to be true in a situation where a chain of
    // instantiations is not infinitely expanding. Effectively, we will generate a false positive when two types are
    // structurally equal to at least maxDepth levels, but unequal at some level beyond that.
    function isDeeplyNestedType(type: Type, stack: Type[], depth: number, maxDepth = 3): boolean {
        if (depth >= maxDepth) {
            if ((getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped) {
                type = getMappedTargetWithSymbol(type);
            }
            if (type.flags & TypeFlags.Intersection) {
                return some((type as IntersectionType).types, t => isDeeplyNestedType(t, stack, depth, maxDepth));
            }
            const identity = getRecursionIdentity(type);
            let count = 0;
            let lastTypeId = 0;
            for (let i = 0; i < depth; i++) {
                const t = stack[i];
                if (hasMatchingRecursionIdentity(t, identity)) {
                    // We only count occurrences with a higher type id than the previous occurrence, since higher
                    // type ids are an indicator of newer instantiations caused by recursion.
                    if (t.id >= lastTypeId) {
                        count++;
                        if (count >= maxDepth) {
                            return true;
                        }
                    }
                    lastTypeId = t.id;
                }
            }
        }
        return false;
    }

    // Unwrap nested homomorphic mapped types and return the deepest target type that has a symbol. This better
    // preserves unique type identities for mapped types applied to explicitly written object literals. For example
    // in `Mapped<{ x: Mapped<{ x: Mapped<{ x: string }>}>}>`, each of the mapped type applications will have a
    // unique recursion identity (that of their target object type literal) and thus avoid appearing deeply nested.
    function getMappedTargetWithSymbol(type: Type) {
        let target;
        while (
            (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped &&
            (target = getModifiersTypeFromMappedType(type as MappedType)) &&
            (target.symbol || target.flags & TypeFlags.Intersection && some((target as IntersectionType).types, t => !!t.symbol))
        ) {
            type = target;
        }
        return type;
    }

    function hasMatchingRecursionIdentity(type: Type, identity: object): boolean {
        if ((getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped) {
            type = getMappedTargetWithSymbol(type);
        }
        if (type.flags & TypeFlags.Intersection) {
            return some((type as IntersectionType).types, t => hasMatchingRecursionIdentity(t, identity));
        }
        return getRecursionIdentity(type) === identity;
    }

    // The recursion identity of a type is an object identity that is shared among multiple instantiations of the type.
    // We track recursion identities in order to identify deeply nested and possibly infinite type instantiations with
    // the same origin. For example, when type parameters are in scope in an object type such as { x: T }, all
    // instantiations of that type have the same recursion identity. The default recursion identity is the object
    // identity of the type, meaning that every type is unique. Generally, types with constituents that could circularly
    // reference the type have a recursion identity that differs from the object identity.
    function getRecursionIdentity(type: Type): object {
        // Object and array literals are known not to contain recursive references and don't need a recursion identity.
        if (type.flags & TypeFlags.Object && !isObjectOrArrayLiteralType(type)) {
            if (getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).node) {
                // Deferred type references are tracked through their associated AST node. This gives us finer
                // granularity than using their associated target because each manifest type reference has a
                // unique AST node.
                return (type as TypeReference).node!;
            }
            if (type.symbol && !(getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol.flags & SymbolFlags.Class)) {
                // We track object types that have a symbol by that symbol (representing the origin of the type), but
                // exclude the static side of a class since it shares its symbol with the instance side.
                return type.symbol;
            }
            if (isTupleType(type)) {
                return type.target;
            }
        }
        if (type.flags & TypeFlags.TypeParameter) {
            // We use the symbol of the type parameter such that all "fresh" instantiations of that type parameter
            // have the same recursion identity.
            return type.symbol;
        }
        if (type.flags & TypeFlags.IndexedAccess) {
            // Identity is the leftmost object type in a chain of indexed accesses, eg, in A[P1][P2][P3] it is A.
            do {
                type = (type as IndexedAccessType).objectType;
            }
            while (type.flags & TypeFlags.IndexedAccess);
            return type;
        }
        if (type.flags & TypeFlags.Conditional) {
            // The root object represents the origin of the conditional type
            return (type as ConditionalType).root;
        }
        return type;
    }

    function isPropertyIdenticalTo(sourceProp: Symbol, targetProp: Symbol): boolean {
        return compareProperties(sourceProp, targetProp, compareTypesIdentical) !== Ternary.False;
    }

    function compareProperties(sourceProp: Symbol, targetProp: Symbol, compareTypes: (source: Type, target: Type) => Ternary): Ternary {
        // Two members are considered identical when
        // - they are public properties with identical names, optionality, and types,
        // - they are private or protected properties originating in the same declaration and having identical types
        if (sourceProp === targetProp) {
            return Ternary.True;
        }
        const sourcePropAccessibility = getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlags.NonPublicAccessibilityModifier;
        const targetPropAccessibility = getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlags.NonPublicAccessibilityModifier;
        if (sourcePropAccessibility !== targetPropAccessibility) {
            return Ternary.False;
        }
        if (sourcePropAccessibility) {
            if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
                return Ternary.False;
            }
        }
        else {
            if ((sourceProp.flags & SymbolFlags.Optional) !== (targetProp.flags & SymbolFlags.Optional)) {
                return Ternary.False;
            }
        }
        if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) {
            return Ternary.False;
        }
        return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
    }

    function isMatchingSignature(source: Signature, target: Signature, partialMatch: boolean) {
        const sourceParameterCount = getParameterCount(source);
        const targetParameterCount = getParameterCount(target);
        const sourceMinArgumentCount = getMinArgumentCount(source);
        const targetMinArgumentCount = getMinArgumentCount(target);
        const sourceHasRestParameter = hasEffectiveRestParameter(source);
        const targetHasRestParameter = hasEffectiveRestParameter(target);
        // A source signature matches a target signature if the two signatures have the same number of required,
        // optional, and rest parameters.
        if (
            sourceParameterCount === targetParameterCount &&
            sourceMinArgumentCount === targetMinArgumentCount &&
            sourceHasRestParameter === targetHasRestParameter
        ) {
            return true;
        }
        // A source signature partially matches a target signature if the target signature has no fewer required
        // parameters
        if (partialMatch && sourceMinArgumentCount <= targetMinArgumentCount) {
            return true;
        }
        return false;
    }

    /**
     * See signatureRelatedTo, compareSignaturesIdentical
     */
    function compareSignaturesIdentical(source: Signature, target: Signature, partialMatch: boolean, ignoreThisTypes: boolean, ignoreReturnTypes: boolean, compareTypes: (s: Type, t: Type) => Ternary): Ternary {
        // TODO (drosen): De-duplicate code between related functions.
        if (source === target) {
            return Ternary.True;
        }
        if (!(isMatchingSignature(source, target, partialMatch))) {
            return Ternary.False;
        }
        // Check that the two signatures have the same number of type parameters.
        if (length(source.typeParameters) !== length(target.typeParameters)) {
            return Ternary.False;
        }
        // Check that type parameter constraints and defaults match. If they do, instantiate the source
        // signature with the type parameters of the target signature and continue the comparison.
        if (target.typeParameters) {
            const mapper = createTypeMapper(source.typeParameters!, target.typeParameters);
            for (let i = 0; i < target.typeParameters.length; i++) {
                const s = source.typeParameters![i];
                const t = target.typeParameters[i];
                if (
                    !(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&
                            compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))
                ) {
                    return Ternary.False;
                }
            }
            source = instantiateSignature(source, mapper, /*eraseTypeParameters*/ true);
        }
        let result = Ternary.True;
        if (!ignoreThisTypes) {
            const sourceThisType = getThisTypeOfSignature(source);
            if (sourceThisType) {
                const targetThisType = getThisTypeOfSignature(target);
                if (targetThisType) {
                    const related = compareTypes(sourceThisType, targetThisType);
                    if (!related) {
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
        }
        const targetLen = getParameterCount(target);
        for (let i = 0; i < targetLen; i++) {
            const s = getTypeAtPosition(source, i);
            const t = getTypeAtPosition(target, i);
            const related = compareTypes(t, s);
            if (!related) {
                return Ternary.False;
            }
            result &= related;
        }
        if (!ignoreReturnTypes) {
            const sourceTypePredicate = getTypePredicateOfSignature(source);
            const targetTypePredicate = getTypePredicateOfSignature(target);
            result &= sourceTypePredicate || targetTypePredicate ?
                compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :
                compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
        }
        return result;
    }

    function compareTypePredicatesIdentical(source: TypePredicate | undefined, target: TypePredicate | undefined, compareTypes: (s: Type, t: Type) => Ternary): Ternary {
        return !(source && target && typePredicateKindsMatch(source, target)) ? Ternary.False :
            source.type === target.type ? Ternary.True :
            source.type && target.type ? compareTypes(source.type, target.type) :
            Ternary.False;
    }

    function literalTypesWithSameBaseType(types: Type[]): boolean {
        let commonBaseType: Type | undefined;
        for (const t of types) {
            if (!(t.flags & TypeFlags.Never)) {
                const baseType = getBaseTypeOfLiteralType(t);
                commonBaseType ??= baseType;
                if (baseType === t || baseType !== commonBaseType) {
                    return false;
                }
            }
        }
        return true;
    }

    function getCombinedTypeFlags(types: Type[]): TypeFlags {
        return reduceLeft(types, (flags, t) => flags | (t.flags & TypeFlags.Union ? getCombinedTypeFlags((t as UnionType).types) : t.flags), 0 as TypeFlags);
    }

    function getCommonSupertype(types: Type[]): Type {
        if (types.length === 1) {
            return types[0];
        }
        // Remove nullable types from each of the candidates.
        const primaryTypes = strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & TypeFlags.Nullable))) : types;
        // When the candidate types are all literal types with the same base type, return a union
        // of those literal types. Otherwise, return the leftmost type for which no type to the
        // right is a supertype.
        const superTypeOrUnion = literalTypesWithSameBaseType(primaryTypes) ?
            getUnionType(primaryTypes) :
            getSingleCommonSupertype(primaryTypes);
        // Add any nullable types that occurred in the candidates back to the result.
        return primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & TypeFlags.Nullable);
    }

    function getSingleCommonSupertype(types: Type[]) {
        // First, find the leftmost type for which no type to the right is a strict supertype, and if that
        // type is a strict supertype of all other candidates, return it. Otherwise, return the leftmost type
        // for which no type to the right is a (regular) supertype.
        const candidate = reduceLeft(types, (s, t) => isTypeStrictSubtypeOf(s, t) ? t : s)!;
        return every(types, t => t === candidate || isTypeStrictSubtypeOf(t, candidate)) ?
            candidate :
            reduceLeft(types, (s, t) => isTypeSubtypeOf(s, t) ? t : s)!;
    }

    // Return the leftmost type for which no type to the right is a subtype.
    function getCommonSubtype(types: Type[]) {
        return reduceLeft(types, (s, t) => isTypeSubtypeOf(t, s) ? t : s)!;
    }

    function isArrayType(type: Type): type is TypeReference {
        return !!(getObjectFlags(type) & ObjectFlags.Reference) && ((type as TypeReference).target === globalArrayType || (type as TypeReference).target === globalReadonlyArrayType);
    }

    function isReadonlyArrayType(type: Type): boolean {
        return !!(getObjectFlags(type) & ObjectFlags.Reference) && (type as TypeReference).target === globalReadonlyArrayType;
    }

    function isArrayOrTupleType(type: Type): type is TypeReference {
        return isArrayType(type) || isTupleType(type);
    }

    function isMutableArrayOrTuple(type: Type): boolean {
        return isArrayType(type) && !isReadonlyArrayType(type) || isTupleType(type) && !type.target.readonly;
    }

    function getElementTypeOfArrayType(type: Type): Type | undefined {
        return isArrayType(type) ? getTypeArguments(type)[0] : undefined;
    }

    function isArrayLikeType(type: Type): boolean {
        // A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
        // or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
        return isArrayType(type) || !(type.flags & TypeFlags.Nullable) && isTypeAssignableTo(type, anyReadonlyArrayType);
    }

    function isMutableArrayLikeType(type: Type): boolean {
        // A type is mutable-array-like if it is a reference to the global Array type, or if it is not the
        // any, undefined or null type and if it is assignable to Array<any>
        return isMutableArrayOrTuple(type) || !(type.flags & (TypeFlags.Any | TypeFlags.Nullable)) && isTypeAssignableTo(type, anyArrayType);
    }

    function getSingleBaseForNonAugmentingSubtype(type: Type) {
        if (!(getObjectFlags(type) & ObjectFlags.Reference) || !(getObjectFlags((type as TypeReference).target) & ObjectFlags.ClassOrInterface)) {
            return undefined;
        }
        if (getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeCalculated) {
            return getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeExists ? (type as TypeReference).cachedEquivalentBaseType : undefined;
        }
        (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeCalculated;
        const target = (type as TypeReference).target as InterfaceType;
        if (getObjectFlags(target) & ObjectFlags.Class) {
            const baseTypeNode = getBaseTypeNodeOfClass(target);
            // A base type expression may circularly reference the class itself (e.g. as an argument to function call), so we only
            // check for base types specified as simple qualified names.
            if (baseTypeNode && baseTypeNode.expression.kind !== SyntaxKind.Identifier && baseTypeNode.expression.kind !== SyntaxKind.PropertyAccessExpression) {
                return undefined;
            }
        }
        const bases = getBaseTypes(target);
        if (bases.length !== 1) {
            return undefined;
        }
        if (getMembersOfSymbol(type.symbol).size) {
            return undefined; // If the interface has any members, they may subtype members in the base, so we should do a full structural comparison
        }
        let instantiatedBase = !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters!, getTypeArguments(type as TypeReference).slice(0, target.typeParameters!.length)));
        if (length(getTypeArguments(type as TypeReference)) > length(target.typeParameters)) {
            instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type as TypeReference)));
        }
        (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeExists;
        return (type as TypeReference).cachedEquivalentBaseType = instantiatedBase;
    }

    function isEmptyLiteralType(type: Type): boolean {
        return strictNullChecks ? type === implicitNeverType : type === undefinedWideningType;
    }

    function isEmptyArrayLiteralType(type: Type): boolean {
        const elementType = getElementTypeOfArrayType(type);
        return !!elementType && isEmptyLiteralType(elementType);
    }

    function isTupleLikeType(type: Type): boolean {
        let lengthType;
        return isTupleType(type) ||
            !!getPropertyOfType(type, "0" as __String) ||
            isArrayLikeType(type) && !!(lengthType = getTypeOfPropertyOfType(type, "length" as __String)) && everyType(lengthType, t => !!(t.flags & TypeFlags.NumberLiteral));
    }

    function isArrayOrTupleLikeType(type: Type): boolean {
        return isArrayLikeType(type) || isTupleLikeType(type);
    }

    function getTupleElementType(type: Type, index: number) {
        const propType = getTypeOfPropertyOfType(type, "" + index as __String);
        if (propType) {
            return propType;
        }
        if (everyType(type, isTupleType)) {
            return getTupleElementTypeOutOfStartCount(type, index, compilerOptions.noUncheckedIndexedAccess ? undefinedType : undefined);
        }
        return undefined;
    }

    function isNeitherUnitTypeNorNever(type: Type): boolean {
        return !(type.flags & (TypeFlags.Unit | TypeFlags.Never));
    }

    function isUnitType(type: Type): boolean {
        return !!(type.flags & TypeFlags.Unit);
    }

    function isUnitLikeType(type: Type): boolean {
        // Intersections that reduce to 'never' (e.g. 'T & null' where 'T extends {}') are not unit types.
        const t = getBaseConstraintOrType(type);
        // Scan intersections such that tagged literal types are considered unit types.
        return t.flags & TypeFlags.Intersection ? some((t as IntersectionType).types, isUnitType) : isUnitType(t);
    }

    function extractUnitType(type: Type) {
        return type.flags & TypeFlags.Intersection ? find((type as IntersectionType).types, isUnitType) || type : type;
    }

    function isLiteralType(type: Type): boolean {
        return type.flags & TypeFlags.Boolean ? true :
            type.flags & TypeFlags.Union ? type.flags & TypeFlags.EnumLiteral ? true : every((type as UnionType).types, isUnitType) :
            isUnitType(type);
    }

    function getBaseTypeOfLiteralType(type: Type): Type {
        return type.flags & TypeFlags.EnumLike ? getBaseTypeOfEnumLikeType(type as LiteralType) :
            type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :
            type.flags & TypeFlags.NumberLiteral ? numberType :
            type.flags & TypeFlags.BigIntLiteral ? bigintType :
            type.flags & TypeFlags.BooleanLiteral ? booleanType :
            type.flags & TypeFlags.Union ? getBaseTypeOfLiteralTypeUnion(type as UnionType) :
            type;
    }

    function getBaseTypeOfLiteralTypeUnion(type: UnionType) {
        const key = `B${getTypeId(type)}`;
        return getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType));
    }

    // This like getBaseTypeOfLiteralType, but instead treats enum literals as strings/numbers instead
    // of returning their enum base type (which depends on the types of other literals in the enum).
    function getBaseTypeOfLiteralTypeForComparison(type: Type): Type {
        return type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :
            type.flags & (TypeFlags.NumberLiteral | TypeFlags.Enum) ? numberType :
            type.flags & TypeFlags.BigIntLiteral ? bigintType :
            type.flags & TypeFlags.BooleanLiteral ? booleanType :
            type.flags & TypeFlags.Union ? mapType(type, getBaseTypeOfLiteralTypeForComparison) :
            type;
    }

    function getWidenedLiteralType(type: Type): Type {
        return type.flags & TypeFlags.EnumLike && isFreshLiteralType(type) ? getBaseTypeOfEnumLikeType(type as LiteralType) :
            type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type) ? stringType :
            type.flags & TypeFlags.NumberLiteral && isFreshLiteralType(type) ? numberType :
            type.flags & TypeFlags.BigIntLiteral && isFreshLiteralType(type) ? bigintType :
            type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(type) ? booleanType :
            type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedLiteralType) :
            type;
    }

    function getWidenedUniqueESSymbolType(type: Type): Type {
        return type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :
            type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedUniqueESSymbolType) :
            type;
    }

    function getWidenedLiteralLikeTypeForContextualType(type: Type, contextualType: Type | undefined) {
        if (!isLiteralOfContextualType(type, contextualType)) {
            type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type));
        }
        return getRegularTypeOfLiteralType(type);
    }

    function getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(type: Type | undefined, contextualSignatureReturnType: Type | undefined, isAsync: boolean) {
        if (type && isUnitType(type)) {
            const contextualType = !contextualSignatureReturnType ? undefined :
                isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) :
                contextualSignatureReturnType;
            type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
        }
        return type;
    }

    function getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(type: Type | undefined, contextualSignatureReturnType: Type | undefined, kind: IterationTypeKind, isAsyncGenerator: boolean) {
        if (type && isUnitType(type)) {
            const contextualType = !contextualSignatureReturnType ? undefined :
                getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator);
            type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
        }
        return type;
    }

    /**
     * Check if a Type was written as a tuple type literal.
     * Prefer using isTupleLikeType() unless the use of `elementTypes`/`getTypeArguments` is required.
     */
    function isTupleType(type: Type): type is TupleTypeReference {
        return !!(getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target.objectFlags & ObjectFlags.Tuple);
    }

    function isGenericTupleType(type: Type): type is TupleTypeReference {
        return isTupleType(type) && !!(type.target.combinedFlags & ElementFlags.Variadic);
    }

    function isSingleElementGenericTupleType(type: Type): type is TupleTypeReference {
        return isGenericTupleType(type) && type.target.elementFlags.length === 1;
    }

    function getRestTypeOfTupleType(type: TupleTypeReference) {
        return getElementTypeOfSliceOfTupleType(type, type.target.fixedLength);
    }

    function getTupleElementTypeOutOfStartCount(type: Type, index: number, undefinedOrMissingType: Type | undefined) {
        return mapType(type, t => {
            const tupleType = t as TupleTypeReference;
            const restType = getRestTypeOfTupleType(tupleType);
            if (!restType) {
                return undefinedType;
            }
            if (undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target)) {
                return getUnionType([restType, undefinedOrMissingType]);
            }
            return restType;
        });
    }

    function getRestArrayTypeOfTupleType(type: TupleTypeReference) {
        const restType = getRestTypeOfTupleType(type);
        return restType && createArrayType(restType);
    }

    function getElementTypeOfSliceOfTupleType(type: TupleTypeReference, index: number, endSkipCount = 0, writing = false, noReductions = false) {
        const length = getTypeReferenceArity(type) - endSkipCount;
        if (index < length) {
            const typeArguments = getTypeArguments(type);
            const elementTypes: Type[] = [];
            for (let i = index; i < length; i++) {
                const t = typeArguments[i];
                elementTypes.push(type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t);
            }
            return writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes, noReductions ? UnionReduction.None : UnionReduction.Literal);
        }
        return undefined;
    }

    function isTupleTypeStructureMatching(t1: TupleTypeReference, t2: TupleTypeReference) {
        return getTypeReferenceArity(t1) === getTypeReferenceArity(t2) &&
            every(t1.target.elementFlags, (f, i) => (f & ElementFlags.Variable) === (t2.target.elementFlags[i] & ElementFlags.Variable));
    }

    function isZeroBigInt({ value }: BigIntLiteralType) {
        return value.base10Value === "0";
    }

    function removeDefinitelyFalsyTypes(type: Type): Type {
        return filterType(type, t => hasTypeFacts(t, TypeFacts.Truthy));
    }

    function extractDefinitelyFalsyTypes(type: Type): Type {
        return mapType(type, getDefinitelyFalsyPartOfType);
    }

    function getDefinitelyFalsyPartOfType(type: Type): Type {
        return type.flags & TypeFlags.String ? emptyStringType :
            type.flags & TypeFlags.Number ? zeroType :
            type.flags & TypeFlags.BigInt ? zeroBigIntType :
            type === regularFalseType ||
                type === falseType ||
                type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null | TypeFlags.AnyOrUnknown) ||
                type.flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "" ||
                type.flags & TypeFlags.NumberLiteral && (type as NumberLiteralType).value === 0 ||
                type.flags & TypeFlags.BigIntLiteral && isZeroBigInt(type as BigIntLiteralType) ? type :
            neverType;
    }

    /**
     * Add undefined or null or both to a type if they are missing.
     * @param type - type to add undefined and/or null to if not present
     * @param flags - Either TypeFlags.Undefined or TypeFlags.Null, or both
     */
    function getNullableType(type: Type, flags: TypeFlags): Type {
        const missing = (flags & ~type.flags) & (TypeFlags.Undefined | TypeFlags.Null);
        return missing === 0 ? type :
            missing === TypeFlags.Undefined ? getUnionType([type, undefinedType]) :
            missing === TypeFlags.Null ? getUnionType([type, nullType]) :
            getUnionType([type, undefinedType, nullType]);
    }

    function getOptionalType(type: Type, isProperty = false): Type {
        Debug.assert(strictNullChecks);
        const missingOrUndefined = isProperty ? undefinedOrMissingType : undefinedType;
        return type === missingOrUndefined || type.flags & TypeFlags.Union && (type as UnionType).types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]);
    }

    function getGlobalNonNullableTypeInstantiation(type: Type) {
        if (!deferredGlobalNonNullableTypeAlias) {
            deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable" as __String, SymbolFlags.TypeAlias, /*diagnostic*/ undefined) || unknownSymbol;
        }
        return deferredGlobalNonNullableTypeAlias !== unknownSymbol ?
            getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) :
            getIntersectionType([type, emptyObjectType]);
    }

    function getNonNullableType(type: Type): Type {
        return strictNullChecks ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
    }

    function addOptionalTypeMarker(type: Type) {
        return strictNullChecks ? getUnionType([type, optionalType]) : type;
    }

    function removeOptionalTypeMarker(type: Type): Type {
        return strictNullChecks ? removeType(type, optionalType) : type;
    }

    function propagateOptionalTypeMarker(type: Type, node: OptionalChain, wasOptional: boolean) {
        return wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type;
    }

    function getOptionalExpressionType(exprType: Type, expression: Expression) {
        return isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) :
            isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) :
            exprType;
    }

    function removeMissingType(type: Type, isOptional: boolean) {
        return exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type;
    }

    function containsMissingType(type: Type) {
        return type === missingType || !!(type.flags & TypeFlags.Union) && (type as UnionType).types[0] === missingType;
    }

    function removeMissingOrUndefinedType(type: Type): Type {
        return exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, TypeFacts.NEUndefined);
    }

    /**
     * Is source potentially coercible to target type under `==`.
     * Assumes that `source` is a constituent of a union, hence
     * the boolean literal flag on the LHS, but not on the RHS.
     *
     * This does not fully replicate the semantics of `==`. The
     * intention is to catch cases that are clearly not right.
     *
     * Comparing (string | number) to number should not remove the
     * string element.
     *
     * Comparing (string | number) to 1 will remove the string
     * element, though this is not sound. This is a pragmatic
     * choice.
     *
     * @see narrowTypeByEquality
     *
     * @param source
     * @param target
     */
    function isCoercibleUnderDoubleEquals(source: Type, target: Type): boolean {
        return ((source.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.BooleanLiteral)) !== 0)
            && ((target.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.Boolean)) !== 0);
    }

    /**
     * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
     * with no call or construct signatures.
     */
    function isObjectTypeWithInferableIndex(type: Type): boolean {
        const objectFlags = getObjectFlags(type);
        return type.flags & TypeFlags.Intersection
            ? every((type as IntersectionType).types, isObjectTypeWithInferableIndex)
            : !!(
                type.symbol
                && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0
                && !(type.symbol.flags & SymbolFlags.Class)
                && !typeHasCallOrConstructSignatures(type)
            ) || !!(
                objectFlags & ObjectFlags.ObjectRestType
            ) || !!(objectFlags & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex((type as ReverseMappedType).source));
    }

    function createSymbolWithType(source: Symbol, type: Type | undefined) {
        const symbol = createSymbol(source.flags, source.escapedName, getCheckFlags(source) & CheckFlags.Readonly);
        symbol.declarations = source.declarations;
        symbol.parent = source.parent;
        symbol.links.type = type;
        symbol.links.target = source;
        if (source.valueDeclaration) {
            symbol.valueDeclaration = source.valueDeclaration;
        }
        const nameType = getSymbolLinks(source).nameType;
        if (nameType) {
            symbol.links.nameType = nameType;
        }
        return symbol;
    }

    function transformTypeOfMembers(type: Type, f: (propertyType: Type) => Type) {
        const members = createSymbolTable();
        for (const property of getPropertiesOfObjectType(type)) {
            const original = getTypeOfSymbol(property);
            const updated = f(original);
            members.set(property.escapedName, updated === original ? property : createSymbolWithType(property, updated));
        }
        return members;
    }

    /**
     * If the the provided object literal is subject to the excess properties check,
     * create a new that is exempt. Recursively mark object literal members as exempt.
     * Leave signatures alone since they are not subject to the check.
     */
    function getRegularTypeOfObjectLiteral(type: Type): Type {
        if (!(isObjectLiteralType(type) && getObjectFlags(type) & ObjectFlags.FreshLiteral)) {
            return type;
        }
        const regularType = (type as FreshObjectLiteralType).regularType;
        if (regularType) {
            return regularType;
        }

        const resolved = type as ResolvedType;
        const members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
        const regularNew = createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos);
        regularNew.flags = resolved.flags;
        regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlags.FreshLiteral;
        (type as FreshObjectLiteralType).regularType = regularNew;
        return regularNew;
    }

    function createWideningContext(parent: WideningContext | undefined, propertyName: __String | undefined, siblings: Type[] | undefined): WideningContext {
        return { parent, propertyName, siblings, resolvedProperties: undefined };
    }

    function getSiblingsOfContext(context: WideningContext): Type[] {
        if (!context.siblings) {
            const siblings: Type[] = [];
            for (const type of getSiblingsOfContext(context.parent!)) {
                if (isObjectLiteralType(type)) {
                    const prop = getPropertyOfObjectType(type, context.propertyName!);
                    if (prop) {
                        forEachType(getTypeOfSymbol(prop), t => {
                            siblings.push(t);
                        });
                    }
                }
            }
            context.siblings = siblings;
        }
        return context.siblings;
    }

    function getPropertiesOfContext(context: WideningContext): Symbol[] {
        if (!context.resolvedProperties) {
            const names = new Map<__String, Symbol>();
            for (const t of getSiblingsOfContext(context)) {
                if (isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlags.ContainsSpread)) {
                    for (const prop of getPropertiesOfType(t)) {
                        names.set(prop.escapedName, prop);
                    }
                }
            }
            context.resolvedProperties = arrayFrom(names.values());
        }
        return context.resolvedProperties;
    }

    function getWidenedProperty(prop: Symbol, context: WideningContext | undefined): Symbol {
        if (!(prop.flags & SymbolFlags.Property)) {
            // Since get accessors already widen their return value there is no need to
            // widen accessor based properties here.
            return prop;
        }
        const original = getTypeOfSymbol(prop);
        const propContext = context && createWideningContext(context, prop.escapedName, /*siblings*/ undefined);
        const widened = getWidenedTypeWithContext(original, propContext);
        return widened === original ? prop : createSymbolWithType(prop, widened);
    }

    function getUndefinedProperty(prop: Symbol) {
        const cached = undefinedProperties.get(prop.escapedName);
        if (cached) {
            return cached;
        }
        const result = createSymbolWithType(prop, undefinedOrMissingType);
        result.flags |= SymbolFlags.Optional;
        undefinedProperties.set(prop.escapedName, result);
        return result;
    }

    function getWidenedTypeOfObjectLiteral(type: Type, context: WideningContext | undefined): Type {
        const members = createSymbolTable();
        for (const prop of getPropertiesOfObjectType(type)) {
            members.set(prop.escapedName, getWidenedProperty(prop, context));
        }
        if (context) {
            for (const prop of getPropertiesOfContext(context)) {
                if (!members.has(prop.escapedName)) {
                    members.set(prop.escapedName, getUndefinedProperty(prop));
                }
            }
        }
        const result = createAnonymousType(type.symbol, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type), info => createIndexInfo(info.keyType, getWidenedType(info.type), info.isReadonly, info.declaration, info.components)));
        result.objectFlags |= getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.NonInferrableType); // Retain js literal flag through widening
        return result;
    }

    function getWidenedType(type: Type) {
        return getWidenedTypeWithContext(type, /*context*/ undefined);
    }

    function getWidenedTypeWithContext(type: Type, context: WideningContext | undefined): Type {
        if (getObjectFlags(type) & ObjectFlags.RequiresWidening) {
            if (context === undefined && type.widened) {
                return type.widened;
            }
            let result: Type | undefined;
            if (type.flags & (TypeFlags.Any | TypeFlags.Nullable)) {
                result = anyType;
            }
            else if (isObjectLiteralType(type)) {
                result = getWidenedTypeOfObjectLiteral(type, context);
            }
            else if (type.flags & TypeFlags.Union) {
                const unionContext = context || createWideningContext(/*parent*/ undefined, /*propertyName*/ undefined, (type as UnionType).types);
                const widenedTypes = sameMap((type as UnionType).types, t => t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(t, unionContext));
                // Widening an empty object literal transitions from a highly restrictive type to
                // a highly inclusive one. For that reason we perform subtype reduction here if the
                // union includes empty object types (e.g. reducing {} | string to just {}).
                result = getUnionType(widenedTypes, some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal);
            }
            else if (type.flags & TypeFlags.Intersection) {
                result = getIntersectionType(sameMap((type as IntersectionType).types, getWidenedType));
            }
            else if (isArrayOrTupleType(type)) {
                result = createTypeReference(type.target, sameMap(getTypeArguments(type), getWidenedType));
            }
            if (result && context === undefined) {
                type.widened = result;
            }
            return result || type;
        }
        return type;
    }

    /**
     * Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
     * to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
     * getWidenedType. But in some cases getWidenedType is called without reporting errors
     * (type argument inference is an example).
     *
     * The return value indicates whether an error was in fact reported. The particular circumstances
     * are on a best effort basis. Currently, if the null or undefined that causes widening is inside
     * an object literal property (arbitrarily deeply), this function reports an error. If no error is
     * reported, reportImplicitAnyError is a suitable fallback to report a general error.
     */
    function reportWideningErrorsInType(type: Type): boolean {
        let errorReported = false;
        if (getObjectFlags(type) & ObjectFlags.ContainsWideningType) {
            if (type.flags & TypeFlags.Union) {
                if (some((type as UnionType).types, isEmptyObjectType)) {
                    errorReported = true;
                }
                else {
                    for (const t of (type as UnionType).types) {
                        errorReported ||= reportWideningErrorsInType(t);
                    }
                }
            }
            else if (isArrayOrTupleType(type)) {
                for (const t of getTypeArguments(type)) {
                    errorReported ||= reportWideningErrorsInType(t);
                }
            }
            else if (isObjectLiteralType(type)) {
                for (const p of getPropertiesOfObjectType(type)) {
                    const t = getTypeOfSymbol(p);
                    if (getObjectFlags(t) & ObjectFlags.ContainsWideningType) {
                        errorReported = reportWideningErrorsInType(t);
                        if (!errorReported) {
                            // we need to account for property types coming from object literal type normalization in unions
                            const valueDeclaration = p.declarations?.find(d => d.symbol.valueDeclaration?.parent === type.symbol.valueDeclaration);
                            if (valueDeclaration) {
                                error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)));
                                errorReported = true;
                            }
                        }
                    }
                }
            }
        }
        return errorReported;
    }

    function reportImplicitAny(declaration: Declaration, type: Type, wideningKind?: WideningKind) {
        const typeAsString = typeToString(getWidenedType(type));
        if (isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions)) {
            // Only report implicit any errors/suggestions in TS and ts-check JS files
            return;
        }
        let diagnostic: DiagnosticMessage;
        switch (declaration.kind) {
            case SyntaxKind.BinaryExpression:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
                diagnostic = noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
                break;
            case SyntaxKind.Parameter:
                const param = declaration as ParameterDeclaration;
                if (isIdentifier(param.name)) {
                    const originalKeywordKind = identifierToKeywordKind(param.name);
                    if (
                        (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) &&
                        param.parent.parameters.includes(param) &&
                        (resolveName(param, param.name.escapedText, SymbolFlags.Type, /*nameNotFoundMessage*/ undefined, /*isUse*/ true) ||
                            originalKeywordKind && isTypeNodeKind(originalKeywordKind))
                    ) {
                        const newName = "arg" + param.parent.parameters.indexOf(param);
                        const typeName = declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");
                        errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName);
                        return;
                    }
                }
                diagnostic = (declaration as ParameterDeclaration).dotDotDotToken ?
                    noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage :
                    noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
                break;
            case SyntaxKind.BindingElement:
                diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type;
                if (!noImplicitAny) {
                    // Don't issue a suggestion for binding elements since the codefix doesn't yet support them.
                    return;
                }
                break;
            case SyntaxKind.JSDocFunctionType:
                error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                return;
            case SyntaxKind.JSDocSignature:
                if (noImplicitAny && isJSDocOverloadTag(declaration.parent)) {
                    error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString);
                }
                return;
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
                if (noImplicitAny && !(declaration as NamedDeclaration).name) {
                    if (wideningKind === WideningKind.GeneratorYield) {
                        error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_Consider_supplying_a_return_type_annotation, typeAsString);
                    }
                    else {
                        error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                    }
                    return;
                }
                diagnostic = !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage :
                    wideningKind === WideningKind.GeneratorYield ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type :
                    Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
                break;
            case SyntaxKind.MappedType:
                if (noImplicitAny) {
                    error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type);
                }
                return;
            default:
                diagnostic = noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
        }
        errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString);
    }

    function shouldReportErrorsFromWideningWithContextualSignature(declaration: FunctionLikeDeclaration, wideningKind: WideningKind) {
        const signature = getContextualSignatureForFunctionLikeDeclaration(declaration);
        if (!signature) {
            return true;
        }
        let returnType = getReturnTypeOfSignature(signature);
        const flags = getFunctionFlags(declaration);
        switch (wideningKind) {
            case WideningKind.FunctionReturn:
                if (flags & FunctionFlags.Generator) {
                    returnType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, returnType, !!(flags & FunctionFlags.Async)) ?? returnType;
                }
                else if (flags & FunctionFlags.Async) {
                    returnType = getAwaitedTypeNoAlias(returnType) ?? returnType;
                }
                return isGenericType(returnType);
            case WideningKind.GeneratorYield:
                const yieldType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Yield, returnType, !!(flags & FunctionFlags.Async));
                return !!yieldType && isGenericType(yieldType);
            case WideningKind.GeneratorNext:
                const nextType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Next, returnType, !!(flags & FunctionFlags.Async));
                return !!nextType && isGenericType(nextType);
        }
        return false;
    }

    function reportErrorsFromWidening(declaration: Declaration, type: Type, wideningKind?: WideningKind) {
        addLazyDiagnostic(() => {
            if (noImplicitAny && getObjectFlags(type) & ObjectFlags.ContainsWideningType) {
                if (!wideningKind || isFunctionLikeDeclaration(declaration) && shouldReportErrorsFromWideningWithContextualSignature(declaration, wideningKind)) {
                    // Report implicit any error within type if possible, otherwise report error on declaration
                    if (!reportWideningErrorsInType(type)) {
                        reportImplicitAny(declaration, type, wideningKind);
                    }
                }
            }
        });
    }

    function applyToParameterTypes(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {
        const sourceCount = getParameterCount(source);
        const targetCount = getParameterCount(target);
        const sourceRestType = getEffectiveRestType(source);
        const targetRestType = getEffectiveRestType(target);
        const targetNonRestCount = targetRestType ? targetCount - 1 : targetCount;
        const paramCount = sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount);
        const sourceThisType = getThisTypeOfSignature(source);
        if (sourceThisType) {
            const targetThisType = getThisTypeOfSignature(target);
            if (targetThisType) {
                callback(sourceThisType, targetThisType);
            }
        }
        for (let i = 0; i < paramCount; i++) {
            callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
        }
        if (targetRestType) {
            callback(getRestTypeAtPosition(source, paramCount, /*readonly*/ isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)), targetRestType);
        }
    }

    function applyToReturnTypes(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {
        const targetTypePredicate = getTypePredicateOfSignature(target);
        if (targetTypePredicate) {
            const sourceTypePredicate = getTypePredicateOfSignature(source);
            if (sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type && targetTypePredicate.type) {
                callback(sourceTypePredicate.type, targetTypePredicate.type);
                return;
            }
        }
        const targetReturnType = getReturnTypeOfSignature(target);
        if (couldContainTypeVariables(targetReturnType)) {
            callback(getReturnTypeOfSignature(source), targetReturnType);
        }
    }

    function createInferenceContext(typeParameters: readonly TypeParameter[], signature: Signature | undefined, flags: InferenceFlags, compareTypes?: TypeComparer): InferenceContext {
        return createInferenceContextWorker(typeParameters.map(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable);
    }

    function cloneInferenceContext<T extends InferenceContext | undefined>(context: T, extraFlags: InferenceFlags = 0): InferenceContext | T & undefined {
        return context && createInferenceContextWorker(map(context.inferences, cloneInferenceInfo), context.signature, context.flags | extraFlags, context.compareTypes);
    }

    function createInferenceContextWorker(inferences: InferenceInfo[], signature: Signature | undefined, flags: InferenceFlags, compareTypes: TypeComparer): InferenceContext {
        const context: InferenceContext = {
            inferences,
            signature,
            flags,
            compareTypes,
            mapper: reportUnmeasurableMapper, // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction
            nonFixingMapper: reportUnmeasurableMapper,
        };
        context.mapper = makeFixingMapperForContext(context);
        context.nonFixingMapper = makeNonFixingMapperForContext(context);
        return context;
    }

    function makeFixingMapperForContext(context: InferenceContext) {
        return makeDeferredTypeMapper(
            map(context.inferences, i => i.typeParameter),
            map(context.inferences, (inference, i) => () => {
                if (!inference.isFixed) {
                    // Before we commit to a particular inference (and thus lock out any further inferences),
                    // we infer from any intra-expression inference sites we have collected.
                    inferFromIntraExpressionSites(context);
                    clearCachedInferences(context.inferences);
                    inference.isFixed = true;
                }
                return getInferredType(context, i);
            }),
        );
    }

    function makeNonFixingMapperForContext(context: InferenceContext) {
        return makeDeferredTypeMapper(
            map(context.inferences, i => i.typeParameter),
            map(context.inferences, (_, i) => () => {
                return getInferredType(context, i);
            }),
        );
    }

    function clearCachedInferences(inferences: InferenceInfo[]) {
        for (const inference of inferences) {
            if (!inference.isFixed) {
                inference.inferredType = undefined;
            }
        }
    }

    function addIntraExpressionInferenceSite(context: InferenceContext, node: Expression | MethodDeclaration, type: Type) {
        (context.intraExpressionInferenceSites ??= []).push({ node, type });
    }

    // We collect intra-expression inference sites within object and array literals to handle cases where
    // inferred types flow between context sensitive element expressions. For example:
    //
    //   declare function foo<T>(arg: [(n: number) => T, (x: T) => void]): void;
    //   foo([_a => 0, n => n.toFixed()]);
    //
    // Above, both arrow functions in the tuple argument are context sensitive, thus both are omitted from the
    // pass that collects inferences from the non-context sensitive parts of the arguments. In the subsequent
    // pass where nothing is omitted, we need to commit to an inference for T in order to contextually type the
    // parameter in the second arrow function, but we want to first infer from the return type of the first
    // arrow function. This happens automatically when the arrow functions are discrete arguments (because we
    // infer from each argument before processing the next), but when the arrow functions are elements of an
    // object or array literal, we need to perform intra-expression inferences early.
    function inferFromIntraExpressionSites(context: InferenceContext) {
        if (context.intraExpressionInferenceSites) {
            for (const { node, type } of context.intraExpressionInferenceSites) {
                const contextualType = node.kind === SyntaxKind.MethodDeclaration ?
                    getContextualTypeForObjectLiteralMethod(node as MethodDeclaration, ContextFlags.NoConstraints) :
                    getContextualType(node, ContextFlags.NoConstraints);
                if (contextualType) {
                    inferTypes(context.inferences, type, contextualType);
                }
            }
            context.intraExpressionInferenceSites = undefined;
        }
    }

    function createInferenceInfo(typeParameter: TypeParameter): InferenceInfo {
        return {
            typeParameter,
            candidates: undefined,
            contraCandidates: undefined,
            inferredType: undefined,
            priority: undefined,
            topLevel: true,
            isFixed: false,
            impliedArity: undefined,
        };
    }

    function cloneInferenceInfo(inference: InferenceInfo): InferenceInfo {
        return {
            typeParameter: inference.typeParameter,
            candidates: inference.candidates && inference.candidates.slice(),
            contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),
            inferredType: inference.inferredType,
            priority: inference.priority,
            topLevel: inference.topLevel,
            isFixed: inference.isFixed,
            impliedArity: inference.impliedArity,
        };
    }

    function cloneInferredPartOfContext(context: InferenceContext): InferenceContext | undefined {
        const inferences = filter(context.inferences, hasInferenceCandidates);
        return inferences.length ?
            createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) :
            undefined;
    }

    function getMapperFromContext<T extends InferenceContext | undefined>(context: T): TypeMapper | T & undefined {
        return context && context.mapper;
    }

    // Return true if the given type could possibly reference a type parameter for which
    // we perform type inference (i.e. a type parameter of a generic function). We cache
    // results for union and intersection types for performance reasons.
    function couldContainTypeVariables(type: Type): boolean {
        const objectFlags = getObjectFlags(type);
        if (objectFlags & ObjectFlags.CouldContainTypeVariablesComputed) {
            return !!(objectFlags & ObjectFlags.CouldContainTypeVariables);
        }
        const result = !!(type.flags & TypeFlags.Instantiable ||
            type.flags & TypeFlags.Object && !isNonGenericTopLevelType(type) && (
                    objectFlags & ObjectFlags.Reference && ((type as TypeReference).node || some(getTypeArguments(type as TypeReference), couldContainTypeVariables)) ||
                    objectFlags & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) && type.symbol.declarations ||
                    objectFlags & (ObjectFlags.Mapped | ObjectFlags.ReverseMapped | ObjectFlags.ObjectRestType | ObjectFlags.InstantiationExpressionType)
                ) ||
            type.flags & TypeFlags.UnionOrIntersection && !(type.flags & TypeFlags.EnumLiteral) && !isNonGenericTopLevelType(type) && some((type as UnionOrIntersectionType).types, couldContainTypeVariables));
        if (type.flags & TypeFlags.ObjectFlagsType) {
            (type as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (result ? ObjectFlags.CouldContainTypeVariables : 0);
        }
        return result;
    }

    function isNonGenericTopLevelType(type: Type) {
        if (type.aliasSymbol && !type.aliasTypeArguments) {
            const declaration = getDeclarationOfKind(type.aliasSymbol, SyntaxKind.TypeAliasDeclaration);
            return !!(declaration && findAncestor(declaration.parent, n => n.kind === SyntaxKind.SourceFile ? true : n.kind === SyntaxKind.ModuleDeclaration ? false : "quit"));
        }
        return false;
    }

    function isTypeParameterAtTopLevel(type: Type, tp: TypeParameter, depth = 0): boolean {
        return !!(type === tp ||
            type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, t => isTypeParameterAtTopLevel(t, tp, depth)) ||
            depth < 3 && type.flags & TypeFlags.Conditional && (
                    isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type as ConditionalType), tp, depth + 1) ||
                    isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type as ConditionalType), tp, depth + 1)
                ));
    }

    function isTypeParameterAtTopLevelInReturnType(signature: Signature, typeParameter: TypeParameter) {
        const typePredicate = getTypePredicateOfSignature(signature);
        return typePredicate ? !!typePredicate.type && isTypeParameterAtTopLevel(typePredicate.type, typeParameter) :
            isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter);
    }

    /** Create an object with properties named in the string literal type. Every property has type `any` */
    function createEmptyObjectTypeFromStringLiteral(type: Type) {
        const members = createSymbolTable();
        forEachType(type, t => {
            if (!(t.flags & TypeFlags.StringLiteral)) {
                return;
            }
            const name = escapeLeadingUnderscores((t as StringLiteralType).value);
            const literalProp = createSymbol(SymbolFlags.Property, name);
            literalProp.links.type = anyType;
            if (t.symbol) {
                literalProp.declarations = t.symbol.declarations;
                literalProp.valueDeclaration = t.symbol.valueDeclaration;
            }
            members.set(name, literalProp);
        });
        const indexInfos = type.flags & TypeFlags.String ? [createIndexInfo(stringType, emptyObjectType, /*isReadonly*/ false)] : emptyArray;
        return createAnonymousType(/*symbol*/ undefined, members, emptyArray, emptyArray, indexInfos);
    }

    /**
     * Infer a suitable input type for a homomorphic mapped type { [P in keyof T]: X }. We construct
     * an object type with the same set of properties as the source type, where the type of each
     * property is computed by inferring from the source property type to X for the type
     * variable T[P] (i.e. we treat the type T[P] as the type variable we're inferring for).
     */
    function inferTypeForHomomorphicMappedType(source: Type, target: MappedType, constraint: IndexType): Type | undefined {
        const cacheKey = source.id + "," + target.id + "," + constraint.id;
        if (reverseHomomorphicMappedCache.has(cacheKey)) {
            return reverseHomomorphicMappedCache.get(cacheKey);
        }
        const type = createReverseMappedType(source, target, constraint);
        reverseHomomorphicMappedCache.set(cacheKey, type);
        return type;
    }

    // We consider a type to be partially inferable if it isn't marked non-inferable or if it is
    // an object literal type with at least one property of an inferable type. For example, an object
    // literal { a: 123, b: x => true } is marked non-inferable because it contains a context sensitive
    // arrow function, but is considered partially inferable because property 'a' has an inferable type.
    function isPartiallyInferableType(type: Type): boolean {
        return !(getObjectFlags(type) & ObjectFlags.NonInferrableType) ||
            isObjectLiteralType(type) && some(getPropertiesOfType(type), prop => isPartiallyInferableType(getTypeOfSymbol(prop))) ||
            isTupleType(type) && some(getElementTypes(type), isPartiallyInferableType);
    }

    function createReverseMappedType(source: Type, target: MappedType, constraint: IndexType) {
        // We consider a source type reverse mappable if it has a string index signature or if
        // it has one or more properties and is of a partially inferable type.
        if (!(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length !== 0 && isPartiallyInferableType(source))) {
            return undefined;
        }
        // For arrays and tuples we infer new arrays and tuples where the reverse mapping has been
        // applied to the element type(s).
        if (isArrayType(source)) {
            const elementType = inferReverseMappedType(getTypeArguments(source)[0], target, constraint);
            if (!elementType) {
                return undefined;
            }
            return createArrayType(elementType, isReadonlyArrayType(source));
        }
        if (isTupleType(source)) {
            const elementTypes = map(getElementTypes(source), t => inferReverseMappedType(t, target, constraint));
            if (!every(elementTypes, (t): t is Type => !!t)) {
                return undefined;
            }
            const elementFlags = getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ?
                sameMap(source.target.elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :
                source.target.elementFlags;
            return createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations);
        }
        // For all other object types we infer a new object type where the reverse mapping has been
        // applied to the type of each property.
        const reversed = createObjectType(ObjectFlags.ReverseMapped | ObjectFlags.Anonymous, /*symbol*/ undefined) as ReverseMappedType;
        reversed.source = source;
        reversed.mappedType = target;
        reversed.constraintType = constraint;
        return reversed;
    }

    function getTypeOfReverseMappedSymbol(symbol: ReverseMappedSymbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            links.type = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType;
        }
        return links.type;
    }

    function inferReverseMappedTypeWorker(sourceType: Type, target: MappedType, constraint: IndexType): Type {
        const typeParameter = getIndexedAccessType(constraint.type, getTypeParameterFromMappedType(target)) as TypeParameter;
        const templateType = getTemplateTypeFromMappedType(target);
        const inference = createInferenceInfo(typeParameter);
        inferTypes([inference], sourceType, templateType);
        return getTypeFromInference(inference) || unknownType;
    }

    function inferReverseMappedType(source: Type, target: MappedType, constraint: IndexType): Type | undefined {
        const cacheKey = source.id + "," + target.id + "," + constraint.id;
        if (reverseMappedCache.has(cacheKey)) {
            return reverseMappedCache.get(cacheKey) || unknownType;
        }
        reverseMappedSourceStack.push(source);
        reverseMappedTargetStack.push(target);
        const saveExpandingFlags = reverseExpandingFlags;
        if (isDeeplyNestedType(source, reverseMappedSourceStack, reverseMappedSourceStack.length, 2)) reverseExpandingFlags |= ExpandingFlags.Source;
        if (isDeeplyNestedType(target, reverseMappedTargetStack, reverseMappedTargetStack.length, 2)) reverseExpandingFlags |= ExpandingFlags.Target;
        let type;
        if (reverseExpandingFlags !== ExpandingFlags.Both) {
            type = inferReverseMappedTypeWorker(source, target, constraint);
        }
        reverseMappedSourceStack.pop();
        reverseMappedTargetStack.pop();
        reverseExpandingFlags = saveExpandingFlags;
        reverseMappedCache.set(cacheKey, type);
        return type;
    }

    function* getUnmatchedProperties(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): IterableIterator<Symbol> {
        const properties = getPropertiesOfType(target);
        for (const targetProp of properties) {
            // TODO: remove this when we support static private identifier fields and find other solutions to get privateNamesAndStaticFields test to pass
            if (isStaticPrivateIdentifierProperty(targetProp)) {
                continue;
            }
            if (requireOptionalProperties || !(targetProp.flags & SymbolFlags.Optional || getCheckFlags(targetProp) & CheckFlags.Partial)) {
                const sourceProp = getPropertyOfType(source, targetProp.escapedName);
                if (!sourceProp) {
                    yield targetProp;
                }
                else if (matchDiscriminantProperties) {
                    const targetType = getTypeOfSymbol(targetProp);
                    if (targetType.flags & TypeFlags.Unit) {
                        const sourceType = getTypeOfSymbol(sourceProp);
                        if (!(sourceType.flags & TypeFlags.Any || getRegularTypeOfLiteralType(sourceType) === getRegularTypeOfLiteralType(targetType))) {
                            yield targetProp;
                        }
                    }
                }
            }
        }
    }

    function getUnmatchedProperty(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): Symbol | undefined {
        return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties));
    }

    function tupleTypesDefinitelyUnrelated(source: TupleTypeReference, target: TupleTypeReference) {
        return !(target.target.combinedFlags & ElementFlags.Variadic) && target.target.minLength > source.target.minLength ||
            !(target.target.combinedFlags & ElementFlags.Variable) && (!!(source.target.combinedFlags & ElementFlags.Variable) || target.target.fixedLength < source.target.fixedLength);
    }

    function typesDefinitelyUnrelated(source: Type, target: Type) {
        // Two tuple types with incompatible arities are definitely unrelated.
        // Two object types that each have a property that is unmatched in the other are definitely unrelated.
        return isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(source, target) :
            !!getUnmatchedProperty(source, target, /*requireOptionalProperties*/ false, /*matchDiscriminantProperties*/ true) &&
            !!getUnmatchedProperty(target, source, /*requireOptionalProperties*/ false, /*matchDiscriminantProperties*/ false);
    }

    function getTypeFromInference(inference: InferenceInfo) {
        return inference.candidates ? getUnionType(inference.candidates, UnionReduction.Subtype) :
            inference.contraCandidates ? getIntersectionType(inference.contraCandidates) :
            undefined;
    }

    function hasSkipDirectInferenceFlag(node: Node) {
        return !!getNodeLinks(node).skipDirectInference;
    }

    function isFromInferenceBlockedSource(type: Type) {
        return !!(type.symbol && some(type.symbol.declarations, hasSkipDirectInferenceFlag));
    }

    function templateLiteralTypesDefinitelyUnrelated(source: TemplateLiteralType, target: TemplateLiteralType) {
        // Two template literal types with diffences in their starting or ending text spans are definitely unrelated.
        const sourceStart = source.texts[0];
        const targetStart = target.texts[0];
        const sourceEnd = source.texts[source.texts.length - 1];
        const targetEnd = target.texts[target.texts.length - 1];
        const startLen = Math.min(sourceStart.length, targetStart.length);
        const endLen = Math.min(sourceEnd.length, targetEnd.length);
        return sourceStart.slice(0, startLen) !== targetStart.slice(0, startLen) ||
            sourceEnd.slice(sourceEnd.length - endLen) !== targetEnd.slice(targetEnd.length - endLen);
    }

    /**
     * Tests whether the provided string can be parsed as a number.
     * @param s The string to test.
     * @param roundTripOnly Indicates the resulting number matches the input when converted back to a string.
     */
    function isValidNumberString(s: string, roundTripOnly: boolean): boolean {
        if (s === "") return false;
        const n = +s;
        return isFinite(n) && (!roundTripOnly || "" + n === s);
    }

    /**
     * @param text a valid bigint string excluding a trailing `n`, but including a possible prefix `-`. Use `isValidBigIntString(text, roundTripOnly)` before calling this function.
     */
    function parseBigIntLiteralType(text: string) {
        return getBigIntLiteralType(parseValidBigInt(text));
    }

    function isMemberOfStringMapping(source: Type, target: Type): boolean {
        if (target.flags & TypeFlags.Any) {
            return true;
        }
        if (target.flags & (TypeFlags.String | TypeFlags.TemplateLiteral)) {
            return isTypeAssignableTo(source, target);
        }
        if (target.flags & TypeFlags.StringMapping) {
            // We need to see whether applying the same mappings of the target
            // onto the source would produce an identical type *and* that
            // it's compatible with the inner-most non-string-mapped type.
            //
            // The intuition here is that if same mappings don't affect the source at all,
            // and the source is compatible with the unmapped target, then they must
            // still reside in the same domain.
            const mappingStack = [];
            while (target.flags & TypeFlags.StringMapping) {
                mappingStack.unshift(target.symbol);
                target = (target as StringMappingType).type;
            }
            const mappedSource = reduceLeft(mappingStack, (memo, value) => getStringMappingType(value, memo), source);
            return mappedSource === source && isMemberOfStringMapping(source, target);
        }
        return false;
    }

    function isValidTypeForTemplateLiteralPlaceholder(source: Type, target: Type): boolean {
        if (target.flags & TypeFlags.Intersection) {
            return every((target as IntersectionType).types, t => t === emptyTypeLiteralType || isValidTypeForTemplateLiteralPlaceholder(source, t));
        }
        if (target.flags & TypeFlags.String || isTypeAssignableTo(source, target)) {
            return true;
        }
        if (source.flags & TypeFlags.StringLiteral) {
            const value = (source as StringLiteralType).value;
            return !!(target.flags & TypeFlags.Number && isValidNumberString(value, /*roundTripOnly*/ false) ||
                target.flags & TypeFlags.BigInt && isValidBigIntString(value, /*roundTripOnly*/ false) ||
                target.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) && value === (target as IntrinsicType).intrinsicName ||
                target.flags & TypeFlags.StringMapping && isMemberOfStringMapping(source, target) ||
                target.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, target as TemplateLiteralType));
        }
        if (source.flags & TypeFlags.TemplateLiteral) {
            const texts = (source as TemplateLiteralType).texts;
            return texts.length === 2 && texts[0] === "" && texts[1] === "" && isTypeAssignableTo((source as TemplateLiteralType).types[0], target);
        }
        return false;
    }

    function inferTypesFromTemplateLiteralType(source: Type, target: TemplateLiteralType): Type[] | undefined {
        return source.flags & TypeFlags.StringLiteral ? inferFromLiteralPartsToTemplateLiteral([(source as StringLiteralType).value], emptyArray, target) :
            source.flags & TypeFlags.TemplateLiteral ?
            arrayIsEqualTo((source as TemplateLiteralType).texts, target.texts) ? map((source as TemplateLiteralType).types, (s, i) => {
                return isTypeAssignableTo(getBaseConstraintOrType(s), getBaseConstraintOrType(target.types[i])) ? s : getStringLikeTypeForType(s);
            }) :
                inferFromLiteralPartsToTemplateLiteral((source as TemplateLiteralType).texts, (source as TemplateLiteralType).types, target) :
            undefined;
    }

    function isTypeMatchedByTemplateLiteralType(source: Type, target: TemplateLiteralType): boolean {
        const inferences = inferTypesFromTemplateLiteralType(source, target);
        return !!inferences && every(inferences, (r, i) => isValidTypeForTemplateLiteralPlaceholder(r, target.types[i]));
    }

    function getStringLikeTypeForType(type: Type) {
        return type.flags & (TypeFlags.Any | TypeFlags.StringLike) ? type : getTemplateLiteralType(["", ""], [type]);
    }

    // This function infers from the text parts and type parts of a source literal to a target template literal. The number
    // of text parts is always one more than the number of type parts, and a source string literal is treated as a source
    // with one text part and zero type parts. The function returns an array of inferred string or template literal types
    // corresponding to the placeholders in the target template literal, or undefined if the source doesn't match the target.
    //
    // We first check that the starting source text part matches the starting target text part, and that the ending source
    // text part ends matches the ending target text part. We then iterate through the remaining target text parts, finding
    // a match for each in the source and inferring string or template literal types created from the segments of the source
    // that occur between the matches. During this iteration, seg holds the index of the current text part in the sourceTexts
    // array and pos holds the current character position in the current text part.
    //
    // Consider inference from type `<<${string}>.<${number}-${number}>>` to type `<${string}.${string}>`, i.e.
    //   sourceTexts = ['<<', '>.<', '-', '>>']
    //   sourceTypes = [string, number, number]
    //   target.texts = ['<', '.', '>']
    // We first match '<' in the target to the start of '<<' in the source and '>' in the target to the end of '>>' in
    // the source. The first match for the '.' in target occurs at character 1 in the source text part at index 1, and thus
    // the first inference is the template literal type `<${string}>`. The remainder of the source makes up the second
    // inference, the template literal type `<${number}-${number}>`.
    function inferFromLiteralPartsToTemplateLiteral(sourceTexts: readonly string[], sourceTypes: readonly Type[], target: TemplateLiteralType): Type[] | undefined {
        const lastSourceIndex = sourceTexts.length - 1;
        const sourceStartText = sourceTexts[0];
        const sourceEndText = sourceTexts[lastSourceIndex];
        const targetTexts = target.texts;
        const lastTargetIndex = targetTexts.length - 1;
        const targetStartText = targetTexts[0];
        const targetEndText = targetTexts[lastTargetIndex];
        if (
            lastSourceIndex === 0 && sourceStartText.length < targetStartText.length + targetEndText.length ||
            !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText)
        ) return undefined;
        const remainingEndText = sourceEndText.slice(0, sourceEndText.length - targetEndText.length);
        const matches: Type[] = [];
        let seg = 0;
        let pos = targetStartText.length;
        for (let i = 1; i < lastTargetIndex; i++) {
            const delim = targetTexts[i];
            if (delim.length > 0) {
                let s = seg;
                let p = pos;
                while (true) {
                    p = getSourceText(s).indexOf(delim, p);
                    if (p >= 0) break;
                    s++;
                    if (s === sourceTexts.length) return undefined;
                    p = 0;
                }
                addMatch(s, p);
                pos += delim.length;
            }
            else if (pos < getSourceText(seg).length) {
                addMatch(seg, pos + 1);
            }
            else if (seg < lastSourceIndex) {
                addMatch(seg + 1, 0);
            }
            else {
                return undefined;
            }
        }
        addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length);
        return matches;
        function getSourceText(index: number) {
            return index < lastSourceIndex ? sourceTexts[index] : remainingEndText;
        }
        function addMatch(s: number, p: number) {
            const matchType = s === seg ?
                getStringLiteralType(getSourceText(s).slice(pos, p)) :
                getTemplateLiteralType(
                    [sourceTexts[seg].slice(pos), ...sourceTexts.slice(seg + 1, s), getSourceText(s).slice(0, p)],
                    sourceTypes.slice(seg, s),
                );
            matches.push(matchType);
            seg = s;
            pos = p;
        }
    }

    function inferTypes(inferences: InferenceInfo[], originalSource: Type, originalTarget: Type, priority = InferencePriority.None, contravariant = false) {
        let bivariant = false;
        let propagationType: Type;
        let inferencePriority: number = InferencePriority.MaxValue;
        let visited: Map<string, number>;
        let sourceStack: Type[];
        let targetStack: Type[];
        let expandingFlags = ExpandingFlags.None;
        inferFromTypes(originalSource, originalTarget);

        function inferFromTypes(source: Type, target: Type): void {
            if (!couldContainTypeVariables(target) || isNoInferType(target)) {
                return;
            }
            if (source === wildcardType || source === blockedStringType) {
                // We are inferring from an 'any' type. We want to infer this type for every type parameter
                // referenced in the target type, so we record it as the propagation type and infer from the
                // target to itself. Then, as we find candidates we substitute the propagation type.
                const savePropagationType = propagationType;
                propagationType = source;
                inferFromTypes(target, target);
                propagationType = savePropagationType;
                return;
            }
            if (source.aliasSymbol && source.aliasSymbol === target.aliasSymbol) {
                if (source.aliasTypeArguments) {
                    // Source and target are types originating in the same generic type alias declaration.
                    // Simply infer from source type arguments to target type arguments, with defaults applied.
                    const params = getSymbolLinks(source.aliasSymbol).typeParameters!;
                    const minParams = getMinTypeArgumentCount(params);
                    const sourceTypes = fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                    const targetTypes = fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                    inferFromTypeArguments(sourceTypes, targetTypes!, getAliasVariances(source.aliasSymbol));
                }
                // And if there weren't any type arguments, there's no reason to run inference as the types must be the same.
                return;
            }
            if (source === target && source.flags & TypeFlags.UnionOrIntersection) {
                // When source and target are the same union or intersection type, just relate each constituent
                // type to itself.
                for (const t of (source as UnionOrIntersectionType).types) {
                    inferFromTypes(t, t);
                }
                return;
            }
            if (target.flags & TypeFlags.Union) {
                // First, infer between identically matching source and target constituents and remove the
                // matching types.
                const [tempSources, tempTargets] = inferFromMatchingTypes(source.flags & TypeFlags.Union ? (source as UnionType).types : [source], (target as UnionType).types, isTypeOrBaseIdenticalTo);
                // Next, infer between closely matching source and target constituents and remove
                // the matching types. Types closely match when they are instantiations of the same
                // object type or instantiations of the same type alias.
                const [sources, targets] = inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy);
                if (targets.length === 0) {
                    return;
                }
                target = getUnionType(targets);
                if (sources.length === 0) {
                    // All source constituents have been matched and there is nothing further to infer from.
                    // However, simply making no inferences is undesirable because it could ultimately mean
                    // inferring a type parameter constraint. Instead, make a lower priority inference from
                    // the full source to whatever remains in the target. For example, when inferring from
                    // string to 'string | T', make a lower priority inference of string for T.
                    inferWithPriority(source, target, InferencePriority.NakedTypeVariable);
                    return;
                }
                source = getUnionType(sources);
            }
            else if (target.flags & TypeFlags.Intersection && !every((target as IntersectionType).types, isNonGenericObjectType)) {
                // We reduce intersection types unless they're simple combinations of object types. For example,
                // when inferring from 'string[] & { extra: any }' to 'string[] & T' we want to remove string[] and
                // infer { extra: any } for T. But when inferring to 'string[] & Iterable<T>' we want to keep the
                // string[] on the source side and infer string for T.
                if (!(source.flags & TypeFlags.Union)) {
                    // Infer between identically matching source and target constituents and remove the matching types.
                    const [sources, targets] = inferFromMatchingTypes(source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source], (target as IntersectionType).types, isTypeIdenticalTo);
                    if (sources.length === 0 || targets.length === 0) {
                        return;
                    }
                    source = getIntersectionType(sources);
                    target = getIntersectionType(targets);
                }
            }
            if (target.flags & (TypeFlags.IndexedAccess | TypeFlags.Substitution)) {
                if (isNoInferType(target)) {
                    return;
                }
                target = getActualTypeVariable(target);
            }
            if (target.flags & TypeFlags.TypeVariable) {
                // Skip inference if the source is "blocked", which is used by the language service to
                // prevent inference on nodes currently being edited.
                if (isFromInferenceBlockedSource(source)) {
                    return;
                }
                const inference = getInferenceInfoForType(target);
                if (inference) {
                    // If target is a type parameter, make an inference, unless the source type contains
                    // a "non-inferrable" type. Types with this flag set are markers used to prevent inference.
                    //
                    // For example:
                    //     - anyFunctionType is a wildcard type that's used to avoid contextually typing functions;
                    //       it's internal, so should not be exposed to the user by adding it as a candidate.
                    //     - autoType (and autoArrayType) is a special "any" used in control flow; like anyFunctionType,
                    //       it's internal and should not be observable.
                    //     - silentNeverType is returned by getInferredType when instantiating a generic function for
                    //       inference (and a type variable has no mapping).
                    //
                    // This flag is infectious; if we produce Box<never> (where never is silentNeverType), Box<never> is
                    // also non-inferrable.
                    //
                    // As a special case, also ignore nonInferrableAnyType, which is a special form of the any type
                    // used as a stand-in for binding elements when they are being inferred.
                    if (getObjectFlags(source) & ObjectFlags.NonInferrableType || source === nonInferrableAnyType) {
                        return;
                    }
                    if (!inference.isFixed) {
                        const candidate = propagationType || source;
                        if (candidate === blockedStringType) {
                            return;
                        }
                        if (inference.priority === undefined || priority < inference.priority) {
                            inference.candidates = undefined;
                            inference.contraCandidates = undefined;
                            inference.topLevel = true;
                            inference.priority = priority;
                        }
                        if (priority === inference.priority) {
                            // We make contravariant inferences only if we are in a pure contravariant position,
                            // i.e. only if we have not descended into a bivariant position.
                            if (contravariant && !bivariant) {
                                if (!contains(inference.contraCandidates, candidate)) {
                                    inference.contraCandidates = append(inference.contraCandidates, candidate);
                                    clearCachedInferences(inferences);
                                }
                            }
                            else if (!contains(inference.candidates, candidate)) {
                                inference.candidates = append(inference.candidates, candidate);
                                clearCachedInferences(inferences);
                            }
                        }
                        if (!(priority & InferencePriority.ReturnType) && target.flags & TypeFlags.TypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target as TypeParameter)) {
                            inference.topLevel = false;
                            clearCachedInferences(inferences);
                        }
                    }
                    inferencePriority = Math.min(inferencePriority, priority);
                    return;
                }
                // Infer to the simplified version of an indexed access, if possible, to (hopefully) expose more bare type parameters to the inference engine
                const simplified = getSimplifiedType(target, /*writing*/ false);
                if (simplified !== target) {
                    inferFromTypes(source, simplified);
                }
                else if (target.flags & TypeFlags.IndexedAccess) {
                    const indexType = getSimplifiedType((target as IndexedAccessType).indexType, /*writing*/ false);
                    // Generally simplifications of instantiable indexes are avoided to keep relationship checking correct, however if our target is an access, we can consider
                    // that key of that access to be "instantiated", since we're looking to find the infernce goal in any way we can.
                    if (indexType.flags & TypeFlags.Instantiable) {
                        const simplified = distributeIndexOverObjectType(getSimplifiedType((target as IndexedAccessType).objectType, /*writing*/ false), indexType, /*writing*/ false);
                        if (simplified && simplified !== target) {
                            inferFromTypes(source, simplified);
                        }
                    }
                }
            }
            if (
                getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (
                    (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)
                ) &&
                !((source as TypeReference).node && (target as TypeReference).node)
            ) {
                // If source and target are references to the same generic type, infer from type arguments
                inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target));
            }
            else if (source.flags & TypeFlags.Index && target.flags & TypeFlags.Index) {
                inferFromContravariantTypes((source as IndexType).type, (target as IndexType).type);
            }
            else if ((isLiteralType(source) || source.flags & TypeFlags.String) && target.flags & TypeFlags.Index) {
                const empty = createEmptyObjectTypeFromStringLiteral(source);
                inferFromContravariantTypesWithPriority(empty, (target as IndexType).type, InferencePriority.LiteralKeyof);
            }
            else if (source.flags & TypeFlags.IndexedAccess && target.flags & TypeFlags.IndexedAccess) {
                inferFromTypes((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType);
                inferFromTypes((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType);
            }
            else if (source.flags & TypeFlags.StringMapping && target.flags & TypeFlags.StringMapping) {
                if ((source as StringMappingType).symbol === (target as StringMappingType).symbol) {
                    inferFromTypes((source as StringMappingType).type, (target as StringMappingType).type);
                }
            }
            else if (source.flags & TypeFlags.Substitution) {
                inferFromTypes((source as SubstitutionType).baseType, target);
                inferWithPriority(getSubstitutionIntersection(source as SubstitutionType), target, InferencePriority.SubstituteSource); // Make substitute inference at a lower priority
            }
            else if (target.flags & TypeFlags.Conditional) {
                invokeOnce(source, target as ConditionalType, inferToConditionalType);
            }
            else if (target.flags & TypeFlags.UnionOrIntersection) {
                inferToMultipleTypes(source, (target as UnionOrIntersectionType).types, target.flags);
            }
            else if (source.flags & TypeFlags.Union) {
                // Source is a union or intersection type, infer from each constituent type
                const sourceTypes = (source as UnionOrIntersectionType).types;
                for (const sourceType of sourceTypes) {
                    inferFromTypes(sourceType, target);
                }
            }
            else if (target.flags & TypeFlags.TemplateLiteral) {
                inferToTemplateLiteralType(source, target as TemplateLiteralType);
            }
            else {
                source = getReducedType(source);
                if (isGenericMappedType(source) && isGenericMappedType(target)) {
                    invokeOnce(source, target, inferFromGenericMappedTypes);
                }
                if (!(priority & InferencePriority.NoConstraints && source.flags & (TypeFlags.Intersection | TypeFlags.Instantiable))) {
                    const apparentSource = getApparentType(source);
                    // getApparentType can return _any_ type, since an indexed access or conditional may simplify to any other type.
                    // If that occurs and it doesn't simplify to an object or intersection, we'll need to restart `inferFromTypes`
                    // with the simplified source.
                    if (apparentSource !== source && !(apparentSource.flags & (TypeFlags.Object | TypeFlags.Intersection))) {
                        return inferFromTypes(apparentSource, target);
                    }
                    source = apparentSource;
                }
                if (source.flags & (TypeFlags.Object | TypeFlags.Intersection)) {
                    invokeOnce(source, target, inferFromObjectTypes);
                }
            }
        }

        function inferWithPriority(source: Type, target: Type, newPriority: InferencePriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferFromTypes(source, target);
            priority = savePriority;
        }

        function inferFromContravariantTypesWithPriority(source: Type, target: Type, newPriority: InferencePriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferFromContravariantTypes(source, target);
            priority = savePriority;
        }

        function inferToMultipleTypesWithPriority(source: Type, targets: Type[], targetFlags: TypeFlags, newPriority: InferencePriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferToMultipleTypes(source, targets, targetFlags);
            priority = savePriority;
        }

        // Ensure an inference action is performed only once for the given source and target types.
        // This includes two things:
        // Avoiding inferring between the same pair of source and target types,
        // and avoiding circularly inferring between source and target types.
        // For an example of the last, consider if we are inferring between source type
        // `type Deep<T> = { next: Deep<Deep<T>> }` and target type `type Loop<U> = { next: Loop<U> }`.
        // We would then infer between the types of the `next` property: `Deep<Deep<T>>` = `{ next: Deep<Deep<Deep<T>>> }` and `Loop<U>` = `{ next: Loop<U> }`.
        // We will then infer again between the types of the `next` property:
        // `Deep<Deep<Deep<T>>>` and `Loop<U>`, and so on, such that we would be forever inferring
        // between instantiations of the same types `Deep` and `Loop`.
        // In particular, we would be inferring from increasingly deep instantiations of `Deep` to `Loop`,
        // such that we would go on inferring forever, even though we would never infer
        // between the same pair of types.
        function invokeOnce<Source extends Type, Target extends Type>(source: Source, target: Target, action: (source: Source, target: Target) => void) {
            const key = source.id + "," + target.id;
            const status = visited && visited.get(key);
            if (status !== undefined) {
                inferencePriority = Math.min(inferencePriority, status);
                return;
            }
            (visited || (visited = new Map<string, number>())).set(key, InferencePriority.Circularity);
            const saveInferencePriority = inferencePriority;
            inferencePriority = InferencePriority.MaxValue;
            // We stop inferring and report a circularity if we encounter duplicate recursion identities on both
            // the source side and the target side.
            const saveExpandingFlags = expandingFlags;
            (sourceStack ??= []).push(source);
            (targetStack ??= []).push(target);
            if (isDeeplyNestedType(source, sourceStack, sourceStack.length, 2)) expandingFlags |= ExpandingFlags.Source;
            if (isDeeplyNestedType(target, targetStack, targetStack.length, 2)) expandingFlags |= ExpandingFlags.Target;
            if (expandingFlags !== ExpandingFlags.Both) {
                action(source, target);
            }
            else {
                inferencePriority = InferencePriority.Circularity;
            }
            targetStack.pop();
            sourceStack.pop();
            expandingFlags = saveExpandingFlags;
            visited.set(key, inferencePriority);
            inferencePriority = Math.min(inferencePriority, saveInferencePriority);
        }

        function inferFromMatchingTypes(sources: Type[], targets: Type[], matches: (s: Type, t: Type) => boolean): [Type[], Type[]] {
            let matchedSources: Type[] | undefined;
            let matchedTargets: Type[] | undefined;
            for (const t of targets) {
                for (const s of sources) {
                    if (matches(s, t)) {
                        inferFromTypes(s, t);
                        matchedSources = appendIfUnique(matchedSources, s);
                        matchedTargets = appendIfUnique(matchedTargets, t);
                    }
                }
            }
            return [
                matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources,
                matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets,
            ];
        }

        function inferFromTypeArguments(sourceTypes: readonly Type[], targetTypes: readonly Type[], variances: readonly VarianceFlags[]) {
            const count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
            for (let i = 0; i < count; i++) {
                if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) {
                    inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
                }
                else {
                    inferFromTypes(sourceTypes[i], targetTypes[i]);
                }
            }
        }

        function inferFromContravariantTypes(source: Type, target: Type) {
            contravariant = !contravariant;
            inferFromTypes(source, target);
            contravariant = !contravariant;
        }

        function inferFromContravariantTypesIfStrictFunctionTypes(source: Type, target: Type) {
            if (strictFunctionTypes || priority & InferencePriority.AlwaysStrict) {
                inferFromContravariantTypes(source, target);
            }
            else {
                inferFromTypes(source, target);
            }
        }

        function getInferenceInfoForType(type: Type) {
            if (type.flags & TypeFlags.TypeVariable) {
                for (const inference of inferences) {
                    if (type === inference.typeParameter) {
                        return inference;
                    }
                }
            }
            return undefined;
        }

        function getSingleTypeVariableFromIntersectionTypes(types: Type[]) {
            let typeVariable: Type | undefined;
            for (const type of types) {
                const t = type.flags & TypeFlags.Intersection && find((type as IntersectionType).types, t => !!getInferenceInfoForType(t));
                if (!t || typeVariable && t !== typeVariable) {
                    return undefined;
                }
                typeVariable = t;
            }
            return typeVariable;
        }

        function inferToMultipleTypes(source: Type, targets: Type[], targetFlags: TypeFlags) {
            let typeVariableCount = 0;
            if (targetFlags & TypeFlags.Union) {
                let nakedTypeVariable: Type | undefined;
                const sources = source.flags & TypeFlags.Union ? (source as UnionType).types : [source];
                const matched = new Array<boolean>(sources.length);
                let inferenceCircularity = false;
                // First infer to types that are not naked type variables. For each source type we
                // track whether inferences were made from that particular type to some target with
                // equal priority (i.e. of equal quality) to what we would infer for a naked type
                // parameter.
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        nakedTypeVariable = t;
                        typeVariableCount++;
                    }
                    else {
                        for (let i = 0; i < sources.length; i++) {
                            const saveInferencePriority = inferencePriority;
                            inferencePriority = InferencePriority.MaxValue;
                            inferFromTypes(sources[i], t);
                            if (inferencePriority === priority) matched[i] = true;
                            inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;
                            inferencePriority = Math.min(inferencePriority, saveInferencePriority);
                        }
                    }
                }
                if (typeVariableCount === 0) {
                    // If every target is an intersection of types containing a single naked type variable,
                    // make a lower priority inference to that type variable. This handles inferring from
                    // 'A | B' to 'T & (X | Y)' where we want to infer 'A | B' for T.
                    const intersectionTypeVariable = getSingleTypeVariableFromIntersectionTypes(targets);
                    if (intersectionTypeVariable) {
                        inferWithPriority(source, intersectionTypeVariable, InferencePriority.NakedTypeVariable);
                    }
                    return;
                }
                // If the target has a single naked type variable and no inference circularities were
                // encountered above (meaning we explored the types fully), create a union of the source
                // types from which no inferences have been made so far and infer from that union to the
                // naked type variable.
                if (typeVariableCount === 1 && !inferenceCircularity) {
                    const unmatched = flatMap(sources, (s, i) => matched[i] ? undefined : s);
                    if (unmatched.length) {
                        inferFromTypes(getUnionType(unmatched), nakedTypeVariable!);
                        return;
                    }
                }
            }
            else {
                // We infer from types that are not naked type variables first so that inferences we
                // make from nested naked type variables and given slightly higher priority by virtue
                // of being first in the candidates array.
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        typeVariableCount++;
                    }
                    else {
                        inferFromTypes(source, t);
                    }
                }
            }
            // Inferences directly to naked type variables are given lower priority as they are
            // less specific. For example, when inferring from Promise<string> to T | Promise<T>,
            // we want to infer string for T, not Promise<string> | string. For intersection types
            // we only infer to single naked type variables.
            if (targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0) {
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        inferWithPriority(source, t, InferencePriority.NakedTypeVariable);
                    }
                }
            }
        }

        function inferToMappedType(source: Type, target: MappedType, constraintType: Type): boolean {
            if ((constraintType.flags & TypeFlags.Union) || (constraintType.flags & TypeFlags.Intersection)) {
                let result = false;
                for (const type of (constraintType as (UnionType | IntersectionType)).types) {
                    result = inferToMappedType(source, target, type) || result;
                }
                return result;
            }
            if (constraintType.flags & TypeFlags.Index) {
                // We're inferring from some source type S to a homomorphic mapped type { [P in keyof T]: X },
                // where T is a type variable. Use inferTypeForHomomorphicMappedType to infer a suitable source
                // type and then make a secondary inference from that type to T. We make a secondary inference
                // such that direct inferences to T get priority over inferences to Partial<T>, for example.
                const inference = getInferenceInfoForType((constraintType as IndexType).type);
                if (inference && !inference.isFixed && !isFromInferenceBlockedSource(source)) {
                    const inferredType = inferTypeForHomomorphicMappedType(source, target, constraintType as IndexType);
                    if (inferredType) {
                        // We assign a lower priority to inferences made from types containing non-inferrable
                        // types because we may only have a partial result (i.e. we may have failed to make
                        // reverse inferences for some properties).
                        inferWithPriority(
                            inferredType,
                            inference.typeParameter,
                            getObjectFlags(source) & ObjectFlags.NonInferrableType ?
                                InferencePriority.PartialHomomorphicMappedType :
                                InferencePriority.HomomorphicMappedType,
                        );
                    }
                }
                return true;
            }
            if (constraintType.flags & TypeFlags.TypeParameter) {
                // We're inferring from some source type S to a mapped type { [P in K]: X }, where K is a type
                // parameter. First infer from 'keyof S' to K.
                inferWithPriority(getIndexType(source, /*indexFlags*/ !!source.pattern ? IndexFlags.NoIndexSignatures : IndexFlags.None), constraintType, InferencePriority.MappedTypeConstraint);
                // If K is constrained to a type C, also infer to C. Thus, for a mapped type { [P in K]: X },
                // where K extends keyof T, we make the same inferences as for a homomorphic mapped type
                // { [P in keyof T]: X }. This enables us to make meaningful inferences when the target is a
                // Pick<T, K>.
                const extendedConstraint = getConstraintOfType(constraintType);
                if (extendedConstraint && inferToMappedType(source, target, extendedConstraint)) {
                    return true;
                }
                // If no inferences can be made to K's constraint, infer from a union of the property types
                // in the source to the template type X.
                const propTypes = map(getPropertiesOfType(source), getTypeOfSymbol);
                const indexTypes = map(getIndexInfosOfType(source), info => info !== enumNumberIndexInfo ? info.type : neverType);
                inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target));
                return true;
            }
            return false;
        }

        function inferToConditionalType(source: Type, target: ConditionalType) {
            if (source.flags & TypeFlags.Conditional) {
                inferFromTypes((source as ConditionalType).checkType, target.checkType);
                inferFromTypes((source as ConditionalType).extendsType, target.extendsType);
                inferFromTypes(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target));
                inferFromTypes(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target));
            }
            else {
                const targetTypes = [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)];
                inferToMultipleTypesWithPriority(source, targetTypes, target.flags, contravariant ? InferencePriority.ContravariantConditional : 0);
            }
        }

        function inferToTemplateLiteralType(source: Type, target: TemplateLiteralType) {
            const matches = inferTypesFromTemplateLiteralType(source, target);
            const types = target.types;
            // When the target template literal contains only placeholders (meaning that inference is intended to extract
            // single characters and remainder strings) and inference fails to produce matches, we want to infer 'never' for
            // each placeholder such that instantiation with the inferred value(s) produces 'never', a type for which an
            // assignment check will fail. If we make no inferences, we'll likely end up with the constraint 'string' which,
            // upon instantiation, would collapse all the placeholders to just 'string', and an assignment check might
            // succeed. That would be a pointless and confusing outcome.
            if (matches || every(target.texts, s => s.length === 0)) {
                for (let i = 0; i < types.length; i++) {
                    const source = matches ? matches[i] : neverType;
                    const target = types[i];

                    // If we are inferring from a string literal type to a type variable whose constraint includes one of the
                    // allowed template literal placeholder types, infer from a literal type corresponding to the constraint.
                    if (source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.TypeVariable) {
                        const inferenceContext = getInferenceInfoForType(target);
                        const constraint = inferenceContext ? getBaseConstraintOfType(inferenceContext.typeParameter) : undefined;
                        if (constraint && !isTypeAny(constraint)) {
                            const constraintTypes = constraint.flags & TypeFlags.Union ? (constraint as UnionType).types : [constraint];
                            let allTypeFlags: TypeFlags = reduceLeft(constraintTypes, (flags, t) => flags | t.flags, 0 as TypeFlags);

                            // If the constraint contains `string`, we don't need to look for a more preferred type
                            if (!(allTypeFlags & TypeFlags.String)) {
                                const str = (source as StringLiteralType).value;

                                // If the type contains `number` or a number literal and the string isn't a valid number, exclude numbers
                                if (allTypeFlags & TypeFlags.NumberLike && !isValidNumberString(str, /*roundTripOnly*/ true)) {
                                    allTypeFlags &= ~TypeFlags.NumberLike;
                                }

                                // If the type contains `bigint` or a bigint literal and the string isn't a valid bigint, exclude bigints
                                if (allTypeFlags & TypeFlags.BigIntLike && !isValidBigIntString(str, /*roundTripOnly*/ true)) {
                                    allTypeFlags &= ~TypeFlags.BigIntLike;
                                }

                                // for each type in the constraint, find the highest priority matching type
                                const matchingType = reduceLeft(constraintTypes, (left, right) =>
                                    !(right.flags & allTypeFlags) ? left :
                                        left.flags & TypeFlags.String ? left : right.flags & TypeFlags.String ? source :
                                        left.flags & TypeFlags.TemplateLiteral ? left : right.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, right as TemplateLiteralType) ? source :
                                        left.flags & TypeFlags.StringMapping ? left : right.flags & TypeFlags.StringMapping && str === applyStringMapping(right.symbol, str) ? source :
                                        left.flags & TypeFlags.StringLiteral ? left : right.flags & TypeFlags.StringLiteral && (right as StringLiteralType).value === str ? right :
                                        left.flags & TypeFlags.Number ? left : right.flags & TypeFlags.Number ? getNumberLiteralType(+str) :
                                        left.flags & TypeFlags.Enum ? left : right.flags & TypeFlags.Enum ? getNumberLiteralType(+str) :
                                        left.flags & TypeFlags.NumberLiteral ? left : right.flags & TypeFlags.NumberLiteral && (right as NumberLiteralType).value === +str ? right :
                                        left.flags & TypeFlags.BigInt ? left : right.flags & TypeFlags.BigInt ? parseBigIntLiteralType(str) :
                                        left.flags & TypeFlags.BigIntLiteral ? left : right.flags & TypeFlags.BigIntLiteral && pseudoBigIntToString((right as BigIntLiteralType).value) === str ? right :
                                        left.flags & TypeFlags.Boolean ? left : right.flags & TypeFlags.Boolean ? str === "true" ? trueType : str === "false" ? falseType : booleanType :
                                        left.flags & TypeFlags.BooleanLiteral ? left : right.flags & TypeFlags.BooleanLiteral && (right as IntrinsicType).intrinsicName === str ? right :
                                        left.flags & TypeFlags.Undefined ? left : right.flags & TypeFlags.Undefined && (right as IntrinsicType).intrinsicName === str ? right :
                                        left.flags & TypeFlags.Null ? left : right.flags & TypeFlags.Null && (right as IntrinsicType).intrinsicName === str ? right :
                                        left, neverType as Type);

                                if (!(matchingType.flags & TypeFlags.Never)) {
                                    inferFromTypes(matchingType, target);
                                    continue;
                                }
                            }
                        }
                    }

                    inferFromTypes(source, target);
                }
            }
        }

        function inferFromGenericMappedTypes(source: MappedType, target: MappedType) {
            // The source and target types are generic types { [P in S]: X } and { [P in T]: Y }, so we infer
            // from S to T and from X to Y.
            inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target));
            inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target));
            const sourceNameType = getNameTypeFromMappedType(source);
            const targetNameType = getNameTypeFromMappedType(target);
            if (sourceNameType && targetNameType) inferFromTypes(sourceNameType, targetNameType);
        }

        function inferFromObjectTypes(source: Type, target: Type) {
            if (
                getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (
                    (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)
                )
            ) {
                // If source and target are references to the same generic type, infer from type arguments
                inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target));
                return;
            }
            if (isGenericMappedType(source) && isGenericMappedType(target)) {
                inferFromGenericMappedTypes(source, target);
            }
            if (getObjectFlags(target) & ObjectFlags.Mapped && !(target as MappedType).declaration.nameType) {
                const constraintType = getConstraintTypeFromMappedType(target as MappedType);
                if (inferToMappedType(source, target as MappedType, constraintType)) {
                    return;
                }
            }
            // Infer from the members of source and target only if the two types are possibly related
            if (!typesDefinitelyUnrelated(source, target)) {
                if (isArrayOrTupleType(source)) {
                    if (isTupleType(target)) {
                        const sourceArity = getTypeReferenceArity(source);
                        const targetArity = getTypeReferenceArity(target);
                        const elementTypes = getTypeArguments(target);
                        const elementFlags = target.target.elementFlags;
                        // When source and target are tuple types with the same structure (fixed, variadic, and rest are matched
                        // to the same kind in each position), simply infer between the element types.
                        if (isTupleType(source) && isTupleTypeStructureMatching(source, target)) {
                            for (let i = 0; i < targetArity; i++) {
                                inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                            }
                            return;
                        }
                        const startLength = isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0;
                        const endLength = Math.min(isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0, target.target.combinedFlags & ElementFlags.Variable ? getEndElementCount(target.target, ElementFlags.Fixed) : 0);
                        // Infer between starting fixed elements.
                        for (let i = 0; i < startLength; i++) {
                            inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                        }
                        if (!isTupleType(source) || sourceArity - startLength - endLength === 1 && source.target.elementFlags[startLength] & ElementFlags.Rest) {
                            // Single rest element remains in source, infer from that to every element in target
                            const restType = getTypeArguments(source)[startLength];
                            for (let i = startLength; i < targetArity - endLength; i++) {
                                inferFromTypes(elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType, elementTypes[i]);
                            }
                        }
                        else {
                            const middleLength = targetArity - startLength - endLength;
                            if (middleLength === 2) {
                                if (elementFlags[startLength] & elementFlags[startLength + 1] & ElementFlags.Variadic) {
                                    // Middle of target is [...T, ...U] and source is tuple type
                                    const targetInfo = getInferenceInfoForType(elementTypes[startLength]);
                                    if (targetInfo && targetInfo.impliedArity !== undefined) {
                                        // Infer slices from source based on implied arity of T.
                                        inferFromTypes(sliceTupleType(source, startLength, endLength + sourceArity - targetInfo.impliedArity), elementTypes[startLength]);
                                        inferFromTypes(sliceTupleType(source, startLength + targetInfo.impliedArity, endLength), elementTypes[startLength + 1]);
                                    }
                                }
                                else if (elementFlags[startLength] & ElementFlags.Variadic && elementFlags[startLength + 1] & ElementFlags.Rest) {
                                    // Middle of target is [...T, ...rest] and source is tuple type
                                    // if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
                                    const param = getInferenceInfoForType(elementTypes[startLength])?.typeParameter;
                                    const constraint = param && getBaseConstraintOfType(param);
                                    if (constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlags.Variable)) {
                                        const impliedArity = constraint.target.fixedLength;
                                        inferFromTypes(sliceTupleType(source, startLength, sourceArity - (startLength + impliedArity)), elementTypes[startLength]);
                                        inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength + impliedArity, endLength)!, elementTypes[startLength + 1]);
                                    }
                                }
                                else if (elementFlags[startLength] & ElementFlags.Rest && elementFlags[startLength + 1] & ElementFlags.Variadic) {
                                    // Middle of target is [...rest, ...T] and source is tuple type
                                    // if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
                                    const param = getInferenceInfoForType(elementTypes[startLength + 1])?.typeParameter;
                                    const constraint = param && getBaseConstraintOfType(param);
                                    if (constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlags.Variable)) {
                                        const impliedArity = constraint.target.fixedLength;
                                        const endIndex = sourceArity - getEndElementCount(target.target, ElementFlags.Fixed);
                                        const startIndex = endIndex - impliedArity;
                                        const trailingSlice = createTupleType(getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex), /*readonly*/ false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex));

                                        inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength, endLength + impliedArity)!, elementTypes[startLength]);
                                        inferFromTypes(trailingSlice, elementTypes[startLength + 1]);
                                    }
                                }
                            }
                            else if (middleLength === 1 && elementFlags[startLength] & ElementFlags.Variadic) {
                                // Middle of target is exactly one variadic element. Infer the slice between the fixed parts in the source.
                                // If target ends in optional element(s), make a lower priority a speculative inference.
                                const endsInOptional = target.target.elementFlags[targetArity - 1] & ElementFlags.Optional;
                                const sourceSlice = sliceTupleType(source, startLength, endLength);
                                inferWithPriority(sourceSlice, elementTypes[startLength], endsInOptional ? InferencePriority.SpeculativeTuple : 0);
                            }
                            else if (middleLength === 1 && elementFlags[startLength] & ElementFlags.Rest) {
                                // Middle of target is exactly one rest element. If middle of source is not empty, infer union of middle element types.
                                const restType = getElementTypeOfSliceOfTupleType(source, startLength, endLength);
                                if (restType) {
                                    inferFromTypes(restType, elementTypes[startLength]);
                                }
                            }
                        }
                        // Infer between ending fixed elements
                        for (let i = 0; i < endLength; i++) {
                            inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);
                        }
                        return;
                    }
                    if (isArrayType(target)) {
                        inferFromIndexTypes(source, target);
                        return;
                    }
                }
                inferFromProperties(source, target);
                inferFromSignatures(source, target, SignatureKind.Call);
                inferFromSignatures(source, target, SignatureKind.Construct);
                inferFromIndexTypes(source, target);
            }
        }

        function inferFromProperties(source: Type, target: Type) {
            const properties = getPropertiesOfObjectType(target);
            for (const targetProp of properties) {
                const sourceProp = getPropertyOfType(source, targetProp.escapedName);
                if (sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag)) {
                    inferFromTypes(
                        removeMissingType(getTypeOfSymbol(sourceProp), !!(sourceProp.flags & SymbolFlags.Optional)),
                        removeMissingType(getTypeOfSymbol(targetProp), !!(targetProp.flags & SymbolFlags.Optional)),
                    );
                }
            }
        }

        function inferFromSignatures(source: Type, target: Type, kind: SignatureKind) {
            const sourceSignatures = getSignaturesOfType(source, kind);
            const sourceLen = sourceSignatures.length;
            if (sourceLen > 0) {
                // We match source and target signatures from the bottom up, and if the source has fewer signatures
                // than the target, we infer from the first source signature to the excess target signatures.
                const targetSignatures = getSignaturesOfType(target, kind);
                const targetLen = targetSignatures.length;
                for (let i = 0; i < targetLen; i++) {
                    const sourceIndex = Math.max(sourceLen - targetLen + i, 0);
                    inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]));
                }
            }
        }

        function inferFromSignature(source: Signature, target: Signature) {
            if (!(source.flags & SignatureFlags.IsNonInferrable)) {
                const saveBivariant = bivariant;
                const kind = target.declaration ? target.declaration.kind : SyntaxKind.Unknown;
                // Once we descend into a bivariant signature we remain bivariant for all nested inferences
                bivariant = bivariant || kind === SyntaxKind.MethodDeclaration || kind === SyntaxKind.MethodSignature || kind === SyntaxKind.Constructor;
                applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes);
                bivariant = saveBivariant;
            }
            applyToReturnTypes(source, target, inferFromTypes);
        }

        function inferFromIndexTypes(source: Type, target: Type) {
            // Inferences across mapped type index signatures are pretty much the same a inferences to homomorphic variables
            const priority = (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0;
            const indexInfos = getIndexInfosOfType(target);
            if (isObjectTypeWithInferableIndex(source)) {
                for (const targetInfo of indexInfos) {
                    const propTypes: Type[] = [];
                    for (const prop of getPropertiesOfType(source)) {
                        if (isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique), targetInfo.keyType)) {
                            const propType = getTypeOfSymbol(prop);
                            propTypes.push(prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(propType) : propType);
                        }
                    }
                    for (const info of getIndexInfosOfType(source)) {
                        if (isApplicableIndexType(info.keyType, targetInfo.keyType)) {
                            propTypes.push(info.type);
                        }
                    }
                    if (propTypes.length) {
                        inferWithPriority(getUnionType(propTypes), targetInfo.type, priority);
                    }
                }
            }
            for (const targetInfo of indexInfos) {
                const sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
                if (sourceInfo) {
                    inferWithPriority(sourceInfo.type, targetInfo.type, priority);
                }
            }
        }
    }

    function isTypeOrBaseIdenticalTo(s: Type, t: Type) {
        return t === missingType ? s === t :
            (isTypeIdenticalTo(s, t) || !!(t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && s.flags & TypeFlags.NumberLiteral));
    }

    function isTypeCloselyMatchedBy(s: Type, t: Type) {
        return !!(s.flags & TypeFlags.Object && t.flags & TypeFlags.Object && s.symbol && s.symbol === t.symbol ||
            s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol);
    }

    function hasPrimitiveConstraint(type: TypeParameter): boolean {
        const constraint = getConstraintOfTypeParameter(type);
        return !!constraint && maybeTypeOfKind(constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);
    }

    function isObjectLiteralType(type: Type) {
        return !!(getObjectFlags(type) & ObjectFlags.ObjectLiteral);
    }

    function isObjectOrArrayLiteralType(type: Type) {
        return !!(getObjectFlags(type) & (ObjectFlags.ObjectLiteral | ObjectFlags.ArrayLiteral));
    }

    function unionObjectAndArrayLiteralCandidates(candidates: Type[]): Type[] {
        if (candidates.length > 1) {
            const objectLiterals = filter(candidates, isObjectOrArrayLiteralType);
            if (objectLiterals.length) {
                const literalsType = getUnionType(objectLiterals, UnionReduction.Subtype);
                return concatenate(filter(candidates, t => !isObjectOrArrayLiteralType(t)), [literalsType]);
            }
        }
        return candidates;
    }

    function getContravariantInference(inference: InferenceInfo) {
        return inference.priority! & InferencePriority.PriorityImpliesCombination ? getIntersectionType(inference.contraCandidates!) : getCommonSubtype(inference.contraCandidates!);
    }

    function getCovariantInference(inference: InferenceInfo, signature: Signature) {
        // Extract all object and array literal types and replace them with a single widened and normalized type.
        const candidates = unionObjectAndArrayLiteralCandidates(inference.candidates!);
        // We widen inferred literal types if
        // all inferences were made to top-level occurrences of the type parameter, and
        // the type parameter has no constraint or its constraint includes no primitive or literal types, and
        // the type parameter was fixed during inference or does not occur at top-level in the return type.
        const primitiveConstraint = hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter);
        const widenLiteralTypes = !primitiveConstraint && inference.topLevel &&
            (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter));
        const baseCandidates = primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) :
            widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) :
            candidates;
        // If all inferences were made from a position that implies a combined result, infer a union type.
        // Otherwise, infer a common supertype.
        const unwidenedType = inference.priority! & InferencePriority.PriorityImpliesCombination ?
            getUnionType(baseCandidates, UnionReduction.Subtype) :
            getCommonSupertype(baseCandidates);
        return getWidenedType(unwidenedType);
    }

    function getInferredType(context: InferenceContext, index: number): Type {
        const inference = context.inferences[index];
        if (!inference.inferredType) {
            let inferredType: Type | undefined;
            let fallbackType: Type | undefined;
            if (context.signature) {
                const inferredCovariantType = inference.candidates ? getCovariantInference(inference, context.signature) : undefined;
                const inferredContravariantType = inference.contraCandidates ? getContravariantInference(inference) : undefined;
                if (inferredCovariantType || inferredContravariantType) {
                    // If we have both co- and contra-variant inferences, we prefer the co-variant inference if it is not 'never',
                    // all co-variant inferences are assignable to it (i.e. it isn't one of a conflicting set of candidates), it is
                    // assignable to some contra-variant inference, and no other type parameter is constrained to this type parameter
                    // and has inferences that would conflict. Otherwise, we prefer the contra-variant inference.
                    // Similarly ignore co-variant `any` inference when both are available as almost everything is assignable to it
                    // and it would spoil the overall inference.
                    const preferCovariantType = inferredCovariantType && (!inferredContravariantType ||
                        !(inferredCovariantType.flags & (TypeFlags.Never | TypeFlags.Any)) &&
                            some(inference.contraCandidates, t => isTypeAssignableTo(inferredCovariantType, t)) &&
                            every(context.inferences, other =>
                                other !== inference && getConstraintOfTypeParameter(other.typeParameter) !== inference.typeParameter ||
                                every(other.candidates, t => isTypeAssignableTo(t, inferredCovariantType))));
                    inferredType = preferCovariantType ? inferredCovariantType : inferredContravariantType;
                    fallbackType = preferCovariantType ? inferredContravariantType : inferredCovariantType;
                }
                else if (context.flags & InferenceFlags.NoDefault) {
                    // We use silentNeverType as the wildcard that signals no inferences.
                    inferredType = silentNeverType;
                }
                else {
                    // Infer either the default or the empty object type when no inferences were
                    // made. It is important to remember that in this case, inference still
                    // succeeds, meaning there is no error for not having inference candidates. An
                    // inference error only occurs when there are *conflicting* candidates, i.e.
                    // candidates with no common supertype.
                    const defaultType = getDefaultFromTypeParameter(inference.typeParameter);
                    if (defaultType) {
                        // Instantiate the default type. Any forward reference to a type
                        // parameter should be instantiated to the empty object type.
                        inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper));
                    }
                }
            }
            else {
                inferredType = getTypeFromInference(inference);
            }

            inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlags.AnyDefault));

            const constraint = getConstraintOfTypeParameter(inference.typeParameter);
            if (constraint) {
                const instantiatedConstraint = instantiateType(constraint, context.nonFixingMapper);
                if (!inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType))) {
                    // If the fallback type satisfies the constraint, we pick it. Otherwise, we pick the constraint.
                    inference.inferredType = fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)) ? fallbackType : instantiatedConstraint;
                }
            }
            clearActiveMapperCaches();
        }

        return inference.inferredType;
    }

    function getDefaultTypeArgumentType(isInJavaScriptFile: boolean): Type {
        return isInJavaScriptFile ? anyType : unknownType;
    }

    function getInferredTypes(context: InferenceContext): Type[] {
        const result: Type[] = [];
        for (let i = 0; i < context.inferences.length; i++) {
            result.push(getInferredType(context, i));
        }
        return result;
    }

    // EXPRESSION TYPE CHECKING

    function getCannotFindNameDiagnosticForName(node: Identifier): DiagnosticMessage {
        switch (node.escapedText) {
            case "document":
            case "console":
                return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;
            case "$":
                return compilerOptions.types
                    ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig
                    : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery;
            case "describe":
            case "suite":
            case "it":
            case "test":
                return compilerOptions.types
                    ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig
                    : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha;
            case "process":
            case "require":
            case "Buffer":
            case "module":
                return compilerOptions.types
                    ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig
                    : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode;
            case "Bun":
                return compilerOptions.types
                    ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig
                    : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun;
            case "Map":
            case "Set":
            case "Promise":
            case "Symbol":
            case "WeakMap":
            case "WeakSet":
            case "Iterator":
            case "AsyncIterator":
            case "SharedArrayBuffer":
            case "Atomics":
            case "AsyncIterable":
            case "AsyncIterableIterator":
            case "AsyncGenerator":
            case "AsyncGeneratorFunction":
            case "BigInt":
            case "Reflect":
            case "BigInt64Array":
            case "BigUint64Array":
                return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later;
            case "await":
                if (isCallExpression(node.parent)) {
                    return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function;
                }
                // falls through
            default:
                if (node.parent.kind === SyntaxKind.ShorthandPropertyAssignment) {
                    return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;
                }
                else {
                    return Diagnostics.Cannot_find_name_0;
                }
        }
    }

    function getResolvedSymbol(node: Identifier): Symbol {
        const links = getNodeLinks(node);
        if (!links.resolvedSymbol) {
            links.resolvedSymbol = !nodeIsMissing(node) &&
                    resolveName(
                        node,
                        node,
                        SymbolFlags.Value | SymbolFlags.ExportValue,
                        getCannotFindNameDiagnosticForName(node),
                        !isWriteOnlyAccess(node),
                        /*excludeGlobals*/ false,
                    ) || unknownSymbol;
        }
        return links.resolvedSymbol;
    }

    function isInAmbientOrTypeNode(node: Node): boolean {
        return !!(node.flags & NodeFlags.Ambient || findAncestor(node, n => isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) || isTypeLiteralNode(n)));
    }

    // Return the flow cache key for a "dotted name" (i.e. a sequence of identifiers
    // separated by dots). The key consists of the id of the symbol referenced by the
    // leftmost identifier followed by zero or more property names separated by dots.
    // The result is undefined if the reference isn't a dotted name.
    function getFlowCacheKey(node: Node, declaredType: Type, initialType: Type, flowContainer: Node | undefined): string | undefined {
        switch (node.kind) {
            case SyntaxKind.Identifier:
                if (!isThisInTypeQuery(node)) {
                    const symbol = getResolvedSymbol(node as Identifier);
                    return symbol !== unknownSymbol ? `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` : undefined;
                }
                // falls through
            case SyntaxKind.ThisKeyword:
                return `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}`;
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.ParenthesizedExpression:
                return getFlowCacheKey((node as NonNullExpression | ParenthesizedExpression).expression, declaredType, initialType, flowContainer);
            case SyntaxKind.QualifiedName:
                const left = getFlowCacheKey((node as QualifiedName).left, declaredType, initialType, flowContainer);
                return left && `${left}.${(node as QualifiedName).right.escapedText}`;
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                const propName = getAccessedPropertyName(node as AccessExpression);
                if (propName !== undefined) {
                    const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);
                    return key && `${key}.${propName}`;
                }
                if (isElementAccessExpression(node) && isIdentifier(node.argumentExpression)) {
                    const symbol = getResolvedSymbol(node.argumentExpression);
                    if (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {
                        const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);
                        return key && `${key}.@${getSymbolId(symbol)}`;
                    }
                }
                break;
            case SyntaxKind.ObjectBindingPattern:
            case SyntaxKind.ArrayBindingPattern:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.MethodDeclaration:
                // Handle pseudo-references originating in getNarrowedTypeOfSymbol.
                return `${getNodeId(node)}#${getTypeId(declaredType)}`;
        }
        return undefined;
    }

    function isMatchingReference(source: Node, target: Node): boolean {
        switch (target.kind) {
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.NonNullExpression:
                return isMatchingReference(source, (target as NonNullExpression | ParenthesizedExpression).expression);
            case SyntaxKind.BinaryExpression:
                return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) ||
                    (isBinaryExpression(target) && target.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source, target.right));
        }
        switch (source.kind) {
            case SyntaxKind.MetaProperty:
                return target.kind === SyntaxKind.MetaProperty
                    && (source as MetaProperty).keywordToken === (target as MetaProperty).keywordToken
                    && (source as MetaProperty).name.escapedText === (target as MetaProperty).name.escapedText;
            case SyntaxKind.Identifier:
            case SyntaxKind.PrivateIdentifier:
                return isThisInTypeQuery(source) ?
                    target.kind === SyntaxKind.ThisKeyword :
                    target.kind === SyntaxKind.Identifier && getResolvedSymbol(source as Identifier) === getResolvedSymbol(target as Identifier) ||
                    (isVariableDeclaration(target) || isBindingElement(target)) &&
                        getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source as Identifier)) === getSymbolOfDeclaration(target);
            case SyntaxKind.ThisKeyword:
                return target.kind === SyntaxKind.ThisKeyword;
            case SyntaxKind.SuperKeyword:
                return target.kind === SyntaxKind.SuperKeyword;
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.SatisfiesExpression:
                return isMatchingReference((source as NonNullExpression | ParenthesizedExpression | SatisfiesExpression).expression, target);
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                const sourcePropertyName = getAccessedPropertyName(source as AccessExpression);
                if (sourcePropertyName !== undefined) {
                    const targetPropertyName = isAccessExpression(target) ? getAccessedPropertyName(target) : undefined;
                    if (targetPropertyName !== undefined) {
                        return targetPropertyName === sourcePropertyName && isMatchingReference((source as AccessExpression).expression, (target as AccessExpression).expression);
                    }
                }
                if (isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression)) {
                    const symbol = getResolvedSymbol(source.argumentExpression);
                    if (symbol === getResolvedSymbol(target.argumentExpression) && (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol))) {
                        return isMatchingReference(source.expression, target.expression);
                    }
                }
                break;
            case SyntaxKind.QualifiedName:
                return isAccessExpression(target) &&
                    (source as QualifiedName).right.escapedText === getAccessedPropertyName(target) &&
                    isMatchingReference((source as QualifiedName).left, target.expression);
            case SyntaxKind.BinaryExpression:
                return (isBinaryExpression(source) && source.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source.right, target));
        }
        return false;
    }

    function getAccessedPropertyName(access: AccessExpression | BindingElement | ParameterDeclaration): __String | undefined {
        if (isPropertyAccessExpression(access)) {
            return access.name.escapedText;
        }
        if (isElementAccessExpression(access)) {
            return tryGetElementAccessExpressionName(access);
        }
        if (isBindingElement(access)) {
            const name = getDestructuringPropertyName(access);
            return name ? escapeLeadingUnderscores(name) : undefined;
        }
        if (isParameter(access)) {
            return ("" + access.parent.parameters.indexOf(access)) as __String;
        }
        return undefined;
    }

    function tryGetNameFromType(type: Type) {
        return type.flags & TypeFlags.UniqueESSymbol ? (type as UniqueESSymbolType).escapedName :
            type.flags & TypeFlags.StringOrNumberLiteral ? escapeLeadingUnderscores("" + (type as StringLiteralType | NumberLiteralType).value) : undefined;
    }

    function tryGetElementAccessExpressionName(node: ElementAccessExpression) {
        return isStringOrNumericLiteralLike(node.argumentExpression) ? escapeLeadingUnderscores(node.argumentExpression.text) :
            isEntityNameExpression(node.argumentExpression) ? tryGetNameFromEntityNameExpression(node.argumentExpression) : undefined;
    }

    function tryGetNameFromEntityNameExpression(node: EntityNameOrEntityNameExpression) {
        const symbol = resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors*/ true);
        if (!symbol || !(isConstantVariable(symbol) || (symbol.flags & SymbolFlags.EnumMember))) return undefined;

        const declaration = symbol.valueDeclaration;
        if (declaration === undefined) return undefined;

        const type = tryGetTypeFromEffectiveTypeNode(declaration);
        if (type) {
            const name = tryGetNameFromType(type);
            if (name !== undefined) {
                return name;
            }
        }
        if (hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node)) {
            const initializer = getEffectiveInitializer(declaration);
            if (initializer) {
                const initializerType = isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration as BindingElement) : getTypeOfExpression(initializer);
                return initializerType && tryGetNameFromType(initializerType);
            }
            if (isEnumMember(declaration)) {
                return getTextOfPropertyName(declaration.name);
            }
        }
        return undefined;
    }

    function containsMatchingReference(source: Node, target: Node) {
        while (isAccessExpression(source)) {
            source = source.expression;
            if (isMatchingReference(source, target)) {
                return true;
            }
        }
        return false;
    }

    function optionalChainContainsReference(source: Node, target: Node) {
        while (isOptionalChain(source)) {
            source = source.expression;
            if (isMatchingReference(source, target)) {
                return true;
            }
        }
        return false;
    }

    function isDiscriminantProperty(type: Type | undefined, name: __String) {
        if (type && type.flags & TypeFlags.Union) {
            const prop = getUnionOrIntersectionProperty(type as UnionType, name);
            if (prop && getCheckFlags(prop) & CheckFlags.SyntheticProperty) {
                // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty
                if ((prop as TransientSymbol).links.isDiscriminantProperty === undefined) {
                    (prop as TransientSymbol).links.isDiscriminantProperty = ((prop as TransientSymbol).links.checkFlags & CheckFlags.Discriminant) === CheckFlags.Discriminant &&
                        !isGenericType(getTypeOfSymbol(prop));
                }
                return !!(prop as TransientSymbol).links.isDiscriminantProperty;
            }
        }
        return false;
    }

    function findDiscriminantProperties(sourceProperties: Symbol[], target: Type): Symbol[] | undefined {
        let result: Symbol[] | undefined;
        for (const sourceProperty of sourceProperties) {
            if (isDiscriminantProperty(target, sourceProperty.escapedName)) {
                if (result) {
                    result.push(sourceProperty);
                    continue;
                }
                result = [sourceProperty];
            }
        }
        return result;
    }

    // Given a set of constituent types and a property name, create and return a map keyed by the literal
    // types of the property by that name in each constituent type. No map is returned if some key property
    // has a non-literal type or if less than 10 or less than 50% of the constituents have a unique key.
    // Entries with duplicate keys have unknownType as the value.
    function mapTypesByKeyProperty(types: Type[], name: __String) {
        const map = new Map<TypeId, Type>();
        let count = 0;
        for (const type of types) {
            if (type.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {
                const discriminant = getTypeOfPropertyOfType(type, name);
                if (discriminant) {
                    if (!isLiteralType(discriminant)) {
                        return undefined;
                    }
                    let duplicate = false;
                    forEachType(discriminant, t => {
                        const id = getTypeId(getRegularTypeOfLiteralType(t));
                        const existing = map.get(id);
                        if (!existing) {
                            map.set(id, type);
                        }
                        else if (existing !== unknownType) {
                            map.set(id, unknownType);
                            duplicate = true;
                        }
                    });
                    if (!duplicate) count++;
                }
            }
        }
        return count >= 10 && count * 2 >= types.length ? map : undefined;
    }

    // Return the name of a discriminant property for which it was possible and feasible to construct a map of
    // constituent types keyed by the literal types of the property by that name in each constituent type.
    function getKeyPropertyName(unionType: UnionType): __String | undefined {
        const types = unionType.types;
        // We only construct maps for unions with many non-primitive constituents.
        if (
            types.length < 10 || getObjectFlags(unionType) & ObjectFlags.PrimitiveUnion ||
            countWhere(types, t => !!(t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive))) < 10
        ) {
            return undefined;
        }
        if (unionType.keyPropertyName === undefined) {
            // The candidate key property name is the name of the first property with a unit type in one of the
            // constituent types.
            const keyPropertyName = forEach(types, t =>
                t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ?
                    forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : undefined) :
                    undefined);
            const mapByKeyProperty = keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName);
            unionType.keyPropertyName = mapByKeyProperty ? keyPropertyName : "" as __String;
            unionType.constituentMap = mapByKeyProperty;
        }
        return (unionType.keyPropertyName as string).length ? unionType.keyPropertyName : undefined;
    }

    // Given a union type for which getKeyPropertyName returned a non-undefined result, return the constituent
    // that corresponds to the given key type for that property name.
    function getConstituentTypeForKeyType(unionType: UnionType, keyType: Type) {
        const result = unionType.constituentMap?.get(getTypeId(getRegularTypeOfLiteralType(keyType)));
        return result !== unknownType ? result : undefined;
    }

    function getMatchingUnionConstituentForType(unionType: UnionType, type: Type) {
        const keyPropertyName = getKeyPropertyName(unionType);
        const propType = keyPropertyName && getTypeOfPropertyOfType(type, keyPropertyName);
        return propType && getConstituentTypeForKeyType(unionType, propType);
    }

    function getMatchingUnionConstituentForObjectLiteral(unionType: UnionType, node: ObjectLiteralExpression) {
        const keyPropertyName = getKeyPropertyName(unionType);
        const propNode = keyPropertyName && find(node.properties, p =>
            p.symbol && p.kind === SyntaxKind.PropertyAssignment &&
            p.symbol.escapedName === keyPropertyName && isPossiblyDiscriminantValue(p.initializer));
        const propType = propNode && getContextFreeTypeOfExpression((propNode as PropertyAssignment).initializer);
        return propType && getConstituentTypeForKeyType(unionType, propType);
    }

    function isOrContainsMatchingReference(source: Node, target: Node) {
        return isMatchingReference(source, target) || containsMatchingReference(source, target);
    }

    function hasMatchingArgument(expression: CallExpression | NewExpression, reference: Node) {
        if (expression.arguments) {
            for (const argument of expression.arguments) {
                if (isOrContainsMatchingReference(reference, argument) || optionalChainContainsReference(argument, reference)) {
                    return true;
                }
            }
        }
        if (
            expression.expression.kind === SyntaxKind.PropertyAccessExpression &&
            isOrContainsMatchingReference(reference, (expression.expression as PropertyAccessExpression).expression)
        ) {
            return true;
        }
        return false;
    }

    function getFlowNodeId(flow: FlowNode): number {
        if (flow.id <= 0) {
            flow.id = nextFlowId;
            nextFlowId++;
        }
        return flow.id;
    }

    function typeMaybeAssignableTo(source: Type, target: Type) {
        if (!(source.flags & TypeFlags.Union)) {
            return isTypeAssignableTo(source, target);
        }
        for (const t of (source as UnionType).types) {
            if (isTypeAssignableTo(t, target)) {
                return true;
            }
        }
        return false;
    }

    // Remove those constituent types of declaredType to which no constituent type of assignedType is assignable.
    // For example, when a variable of type number | string | boolean is assigned a value of type number | boolean,
    // we remove type string.
    function getAssignmentReducedType(declaredType: UnionType, assignedType: Type) {
        if (declaredType === assignedType) {
            return declaredType;
        }
        if (assignedType.flags & TypeFlags.Never) {
            return assignedType;
        }
        const key = `A${getTypeId(declaredType)},${getTypeId(assignedType)}`;
        return getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType));
    }

    function getAssignmentReducedTypeWorker(declaredType: UnionType, assignedType: Type) {
        const filteredType = filterType(declaredType, t => typeMaybeAssignableTo(assignedType, t));
        // Ensure that we narrow to fresh types if the assignment is a fresh boolean literal type.
        const reducedType = assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType;
        // Our crude heuristic produces an invalid result in some cases: see GH#26130.
        // For now, when that happens, we give up and don't narrow at all.  (This also
        // means we'll never narrow for erroneous assignments where the assigned type
        // is not assignable to the declared type.)
        return isTypeAssignableTo(assignedType, reducedType) ? reducedType : declaredType;
    }

    function isFunctionObjectType(type: ObjectType): boolean {
        if (getObjectFlags(type) & ObjectFlags.EvolvingArray) {
            return false;
        }
        // We do a quick check for a "bind" property before performing the more expensive subtype
        // check. This gives us a quicker out in the common case where an object type is not a function.
        const resolved = resolveStructuredTypeMembers(type);
        return !!(resolved.callSignatures.length || resolved.constructSignatures.length ||
            resolved.members.get("bind" as __String) && isTypeSubtypeOf(type, globalFunctionType));
    }

    function getTypeFacts(type: Type, mask: TypeFacts): TypeFacts {
        return getTypeFactsWorker(type, mask) & mask;
    }

    function hasTypeFacts(type: Type, mask: TypeFacts): boolean {
        return getTypeFacts(type, mask) !== 0;
    }

    function getTypeFactsWorker(type: Type, callerOnlyNeeds: TypeFacts): TypeFacts {
        if (type.flags & (TypeFlags.Intersection | TypeFlags.Instantiable)) {
            type = getBaseConstraintOfType(type) || unknownType;
        }
        const flags = type.flags;
        if (flags & (TypeFlags.String | TypeFlags.StringMapping)) {
            return strictNullChecks ? TypeFacts.StringStrictFacts : TypeFacts.StringFacts;
        }
        if (flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral)) {
            const isEmpty = flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "";
            return strictNullChecks ?
                isEmpty ? TypeFacts.EmptyStringStrictFacts : TypeFacts.NonEmptyStringStrictFacts :
                isEmpty ? TypeFacts.EmptyStringFacts : TypeFacts.NonEmptyStringFacts;
        }
        if (flags & (TypeFlags.Number | TypeFlags.Enum)) {
            return strictNullChecks ? TypeFacts.NumberStrictFacts : TypeFacts.NumberFacts;
        }
        if (flags & TypeFlags.NumberLiteral) {
            const isZero = (type as NumberLiteralType).value === 0;
            return strictNullChecks ?
                isZero ? TypeFacts.ZeroNumberStrictFacts : TypeFacts.NonZeroNumberStrictFacts :
                isZero ? TypeFacts.ZeroNumberFacts : TypeFacts.NonZeroNumberFacts;
        }
        if (flags & TypeFlags.BigInt) {
            return strictNullChecks ? TypeFacts.BigIntStrictFacts : TypeFacts.BigIntFacts;
        }
        if (flags & TypeFlags.BigIntLiteral) {
            const isZero = isZeroBigInt(type as BigIntLiteralType);
            return strictNullChecks ?
                isZero ? TypeFacts.ZeroBigIntStrictFacts : TypeFacts.NonZeroBigIntStrictFacts :
                isZero ? TypeFacts.ZeroBigIntFacts : TypeFacts.NonZeroBigIntFacts;
        }
        if (flags & TypeFlags.Boolean) {
            return strictNullChecks ? TypeFacts.BooleanStrictFacts : TypeFacts.BooleanFacts;
        }
        if (flags & TypeFlags.BooleanLike) {
            return strictNullChecks ?
                (type === falseType || type === regularFalseType) ? TypeFacts.FalseStrictFacts : TypeFacts.TrueStrictFacts :
                (type === falseType || type === regularFalseType) ? TypeFacts.FalseFacts : TypeFacts.TrueFacts;
        }
        if (flags & TypeFlags.Object) {
            const possibleFacts = strictNullChecks
                ? TypeFacts.EmptyObjectStrictFacts | TypeFacts.FunctionStrictFacts | TypeFacts.ObjectStrictFacts
                : TypeFacts.EmptyObjectFacts | TypeFacts.FunctionFacts | TypeFacts.ObjectFacts;

            if ((callerOnlyNeeds & possibleFacts) === 0) {
                // If the caller doesn't care about any of the facts that we could possibly produce,
                // return zero so we can skip resolving members.
                return 0;
            }

            return getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(type as ObjectType) ?
                strictNullChecks ? TypeFacts.EmptyObjectStrictFacts : TypeFacts.EmptyObjectFacts :
                isFunctionObjectType(type as ObjectType) ?
                strictNullChecks ? TypeFacts.FunctionStrictFacts : TypeFacts.FunctionFacts :
                strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts;
        }
        if (flags & TypeFlags.Void) {
            return TypeFacts.VoidFacts;
        }
        if (flags & TypeFlags.Undefined) {
            return TypeFacts.UndefinedFacts;
        }
        if (flags & TypeFlags.Null) {
            return TypeFacts.NullFacts;
        }
        if (flags & TypeFlags.ESSymbolLike) {
            return strictNullChecks ? TypeFacts.SymbolStrictFacts : TypeFacts.SymbolFacts;
        }
        if (flags & TypeFlags.NonPrimitive) {
            return strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts;
        }
        if (flags & TypeFlags.Never) {
            return TypeFacts.None;
        }
        if (flags & TypeFlags.Union) {
            return reduceLeft((type as UnionType).types, (facts, t) => facts | getTypeFactsWorker(t, callerOnlyNeeds), TypeFacts.None);
        }
        if (flags & TypeFlags.Intersection) {
            return getIntersectionTypeFacts(type as IntersectionType, callerOnlyNeeds);
        }
        return TypeFacts.UnknownFacts;
    }

    function getIntersectionTypeFacts(type: IntersectionType, callerOnlyNeeds: TypeFacts): TypeFacts {
        // When an intersection contains a primitive type we ignore object type constituents as they are
        // presumably type tags. For example, in string & { __kind__: "name" } we ignore the object type.
        const ignoreObjects = maybeTypeOfKind(type, TypeFlags.Primitive);
        // When computing the type facts of an intersection type, certain type facts are computed as `and`
        // and others are computed as `or`.
        let oredFacts = TypeFacts.None;
        let andedFacts = TypeFacts.All;
        for (const t of type.types) {
            if (!(ignoreObjects && t.flags & TypeFlags.Object)) {
                const f = getTypeFactsWorker(t, callerOnlyNeeds);
                oredFacts |= f;
                andedFacts &= f;
            }
        }
        return oredFacts & TypeFacts.OrFactsMask | andedFacts & TypeFacts.AndFactsMask;
    }

    function getTypeWithFacts(type: Type, include: TypeFacts) {
        return filterType(type, t => hasTypeFacts(t, include));
    }

    // This function is similar to getTypeWithFacts, except that in strictNullChecks mode it replaces type
    // unknown with the union {} | null | undefined (and reduces that accordingly), and it intersects remaining
    // instantiable types with {}, {} | null, or {} | undefined in order to remove null and/or undefined.
    function getAdjustedTypeWithFacts(type: Type, facts: TypeFacts) {
        const reduced = recombineUnknownType(getTypeWithFacts(strictNullChecks && type.flags & TypeFlags.Unknown ? unknownUnionType : type, facts));
        if (strictNullChecks) {
            switch (facts) {
                case TypeFacts.NEUndefined:
                    return removeNullableByIntersection(reduced, TypeFacts.EQUndefined, TypeFacts.EQNull, TypeFacts.IsNull, nullType);
                case TypeFacts.NENull:
                    return removeNullableByIntersection(reduced, TypeFacts.EQNull, TypeFacts.EQUndefined, TypeFacts.IsUndefined, undefinedType);
                case TypeFacts.NEUndefinedOrNull:
                case TypeFacts.Truthy:
                    return mapType(reduced, t => hasTypeFacts(t, TypeFacts.EQUndefinedOrNull) ? getGlobalNonNullableTypeInstantiation(t) : t);
            }
        }
        return reduced;
    }

    function removeNullableByIntersection(type: Type, targetFacts: TypeFacts, otherFacts: TypeFacts, otherIncludesFacts: TypeFacts, otherType: Type) {
        const facts = getTypeFacts(type, TypeFacts.EQUndefined | TypeFacts.EQNull | TypeFacts.IsUndefined | TypeFacts.IsNull);
        // Simply return the type if it never compares equal to the target nullable.
        if (!(facts & targetFacts)) {
            return type;
        }
        // By default we intersect with a union of {} and the opposite nullable.
        const emptyAndOtherUnion = getUnionType([emptyObjectType, otherType]);
        // For each constituent type that can compare equal to the target nullable, intersect with the above union
        // if the type doesn't already include the opppsite nullable and the constituent can compare equal to the
        // opposite nullable; otherwise, just intersect with {}.
        return mapType(type, t => hasTypeFacts(t, targetFacts) ? getIntersectionType([t, !(facts & otherIncludesFacts) && hasTypeFacts(t, otherFacts) ? emptyAndOtherUnion : emptyObjectType]) : t);
    }

    function recombineUnknownType(type: Type) {
        return type === unknownUnionType ? unknownType : type;
    }

    function getTypeWithDefault(type: Type, defaultExpression: Expression) {
        return defaultExpression ?
            getUnionType([getNonUndefinedType(type), getTypeOfExpression(defaultExpression)]) :
            type;
    }

    function getTypeOfDestructuredProperty(type: Type, name: PropertyName) {
        const nameType = getLiteralTypeFromPropertyName(name);
        if (!isTypeUsableAsPropertyName(nameType)) return errorType;
        const text = getPropertyNameFromType(nameType);
        return getTypeOfPropertyOfType(type, text) || includeUndefinedInIndexSignature(getApplicableIndexInfoForName(type, text)?.type) || errorType;
    }

    function getTypeOfDestructuredArrayElement(type: Type, index: number) {
        return everyType(type, isTupleLikeType) && getTupleElementType(type, index) ||
            includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(IterationUse.Destructuring, type, undefinedType, /*errorNode*/ undefined)) ||
            errorType;
    }

    function includeUndefinedInIndexSignature(type: Type | undefined): Type | undefined {
        if (!type) return type;
        return compilerOptions.noUncheckedIndexedAccess ?
            getUnionType([type, missingType]) :
            type;
    }

    function getTypeOfDestructuredSpreadExpression(type: Type) {
        return createArrayType(checkIteratedTypeOrElementType(IterationUse.Destructuring, type, undefinedType, /*errorNode*/ undefined) || errorType);
    }

    function getAssignedTypeOfBinaryExpression(node: BinaryExpression): Type {
        const isDestructuringDefaultAssignment = node.parent.kind === SyntaxKind.ArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent) ||
            node.parent.kind === SyntaxKind.PropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent);
        return isDestructuringDefaultAssignment ?
            getTypeWithDefault(getAssignedType(node), node.right) :
            getTypeOfExpression(node.right);
    }

    function isDestructuringAssignmentTarget(parent: Node) {
        return parent.parent.kind === SyntaxKind.BinaryExpression && (parent.parent as BinaryExpression).left === parent ||
            parent.parent.kind === SyntaxKind.ForOfStatement && (parent.parent as ForOfStatement).initializer === parent;
    }

    function getAssignedTypeOfArrayLiteralElement(node: ArrayLiteralExpression, element: Expression): Type {
        return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element));
    }

    function getAssignedTypeOfSpreadExpression(node: SpreadElement): Type {
        return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent as ArrayLiteralExpression));
    }

    function getAssignedTypeOfPropertyAssignment(node: PropertyAssignment | ShorthandPropertyAssignment): Type {
        return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name);
    }

    function getAssignedTypeOfShorthandPropertyAssignment(node: ShorthandPropertyAssignment): Type {
        return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer!);
    }

    function getAssignedType(node: Expression): Type {
        const { parent } = node;
        switch (parent.kind) {
            case SyntaxKind.ForInStatement:
                return stringType;
            case SyntaxKind.ForOfStatement:
                return checkRightHandSideOfForOf(parent as ForOfStatement) || errorType;
            case SyntaxKind.BinaryExpression:
                return getAssignedTypeOfBinaryExpression(parent as BinaryExpression);
            case SyntaxKind.DeleteExpression:
                return undefinedType;
            case SyntaxKind.ArrayLiteralExpression:
                return getAssignedTypeOfArrayLiteralElement(parent as ArrayLiteralExpression, node);
            case SyntaxKind.SpreadElement:
                return getAssignedTypeOfSpreadExpression(parent as SpreadElement);
            case SyntaxKind.PropertyAssignment:
                return getAssignedTypeOfPropertyAssignment(parent as PropertyAssignment);
            case SyntaxKind.ShorthandPropertyAssignment:
                return getAssignedTypeOfShorthandPropertyAssignment(parent as ShorthandPropertyAssignment);
        }
        return errorType;
    }

    function getInitialTypeOfBindingElement(node: BindingElement): Type {
        const pattern = node.parent;
        const parentType = getInitialType(pattern.parent as VariableDeclaration | BindingElement);
        const type = pattern.kind === SyntaxKind.ObjectBindingPattern ?
            getTypeOfDestructuredProperty(parentType, node.propertyName || node.name as Identifier) :
            !node.dotDotDotToken ?
            getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node)) :
            getTypeOfDestructuredSpreadExpression(parentType);
        return getTypeWithDefault(type, node.initializer!);
    }

    function getTypeOfInitializer(node: Expression) {
        // Return the cached type if one is available. If the type of the variable was inferred
        // from its initializer, we'll already have cached the type. Otherwise we compute it now
        // without caching such that transient types are reflected.
        const links = getNodeLinks(node);
        return links.resolvedType || getTypeOfExpression(node);
    }

    function getInitialTypeOfVariableDeclaration(node: VariableDeclaration) {
        if (node.initializer) {
            return getTypeOfInitializer(node.initializer);
        }
        if (node.parent.parent.kind === SyntaxKind.ForInStatement) {
            return stringType;
        }
        if (node.parent.parent.kind === SyntaxKind.ForOfStatement) {
            return checkRightHandSideOfForOf(node.parent.parent) || errorType;
        }
        return errorType;
    }

    function getInitialType(node: VariableDeclaration | BindingElement) {
        return node.kind === SyntaxKind.VariableDeclaration ?
            getInitialTypeOfVariableDeclaration(node) :
            getInitialTypeOfBindingElement(node);
    }

    function isEmptyArrayAssignment(node: VariableDeclaration | BindingElement | Expression) {
        return node.kind === SyntaxKind.VariableDeclaration && (node as VariableDeclaration).initializer &&
                isEmptyArrayLiteral((node as VariableDeclaration).initializer!) ||
            node.kind !== SyntaxKind.BindingElement && node.parent.kind === SyntaxKind.BinaryExpression &&
                isEmptyArrayLiteral((node.parent as BinaryExpression).right);
    }

    function getReferenceCandidate(node: Expression): Expression {
        switch (node.kind) {
            case SyntaxKind.ParenthesizedExpression:
                return getReferenceCandidate((node as ParenthesizedExpression).expression);
            case SyntaxKind.BinaryExpression:
                switch ((node as BinaryExpression).operatorToken.kind) {
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.BarBarEqualsToken:
                    case SyntaxKind.AmpersandAmpersandEqualsToken:
                    case SyntaxKind.QuestionQuestionEqualsToken:
                        return getReferenceCandidate((node as BinaryExpression).left);
                    case SyntaxKind.CommaToken:
                        return getReferenceCandidate((node as BinaryExpression).right);
                }
        }
        return node;
    }

    function getReferenceRoot(node: Node): Node {
        const { parent } = node;
        return parent.kind === SyntaxKind.ParenthesizedExpression ||
                parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken && (parent as BinaryExpression).left === node ||
                parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken && (parent as BinaryExpression).right === node ?
            getReferenceRoot(parent) : node;
    }

    function getTypeOfSwitchClause(clause: CaseClause | DefaultClause) {
        if (clause.kind === SyntaxKind.CaseClause) {
            return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression));
        }
        return neverType;
    }

    function getSwitchClauseTypes(switchStatement: SwitchStatement): Type[] {
        const links = getNodeLinks(switchStatement);
        if (!links.switchTypes) {
            links.switchTypes = [];
            for (const clause of switchStatement.caseBlock.clauses) {
                links.switchTypes.push(getTypeOfSwitchClause(clause));
            }
        }
        return links.switchTypes;
    }

    // Get the type names from all cases in a switch on `typeof`. The default clause and/or duplicate type names are
    // represented as undefined. Return undefined if one or more case clause expressions are not string literals.
    function getSwitchClauseTypeOfWitnesses(switchStatement: SwitchStatement): (string | undefined)[] | undefined {
        if (some(switchStatement.caseBlock.clauses, clause => clause.kind === SyntaxKind.CaseClause && !isStringLiteralLike(clause.expression))) {
            return undefined;
        }
        const witnesses: (string | undefined)[] = [];
        for (const clause of switchStatement.caseBlock.clauses) {
            const text = clause.kind === SyntaxKind.CaseClause ? (clause.expression as StringLiteralLike).text : undefined;
            witnesses.push(text && !contains(witnesses, text) ? text : undefined);
        }
        return witnesses;
    }

    function eachTypeContainedIn(source: Type, types: Type[]) {
        return source.flags & TypeFlags.Union ? !forEach((source as UnionType).types, t => !contains(types, t)) : contains(types, source);
    }

    function isTypeSubsetOf(source: Type, target: Type) {
        return !!(source === target || source.flags & TypeFlags.Never || target.flags & TypeFlags.Union && isTypeSubsetOfUnion(source, target as UnionType));
    }

    function isTypeSubsetOfUnion(source: Type, target: UnionType) {
        if (source.flags & TypeFlags.Union) {
            for (const t of (source as UnionType).types) {
                if (!containsType(target.types, t)) {
                    return false;
                }
            }
            return true;
        }
        if (source.flags & TypeFlags.EnumLike && getBaseTypeOfEnumLikeType(source as LiteralType) === target) {
            return true;
        }
        return containsType(target.types, source);
    }

    function forEachType<T>(type: Type, f: (t: Type) => T | undefined): T | undefined {
        return type.flags & TypeFlags.Union ? forEach((type as UnionType).types, f) : f(type);
    }

    function someType(type: Type, f: (t: Type) => boolean): boolean {
        return type.flags & TypeFlags.Union ? some((type as UnionType).types, f) : f(type);
    }

    function everyType(type: Type, f: (t: Type) => boolean): boolean {
        return type.flags & TypeFlags.Union ? every((type as UnionType).types, f) : f(type);
    }

    function everyContainedType(type: Type, f: (t: Type) => boolean): boolean {
        return type.flags & TypeFlags.UnionOrIntersection ? every((type as UnionOrIntersectionType).types, f) : f(type);
    }

    function filterType(type: Type, f: (t: Type) => boolean): Type {
        if (type.flags & TypeFlags.Union) {
            const types = (type as UnionType).types;
            const filtered = filter(types, f);
            if (filtered === types) {
                return type;
            }
            const origin = (type as UnionType).origin;
            let newOrigin: Type | undefined;
            if (origin && origin.flags & TypeFlags.Union) {
                // If the origin type is a (denormalized) union type, filter its non-union constituents. If that ends
                // up removing a smaller number of types than in the normalized constituent set (meaning some of the
                // filtered types are within nested unions in the origin), then we can't construct a new origin type.
                // Otherwise, if we have exactly one type left in the origin set, return that as the filtered type.
                // Otherwise, construct a new filtered origin type.
                const originTypes = (origin as UnionType).types;
                const originFiltered = filter(originTypes, t => !!(t.flags & TypeFlags.Union) || f(t));
                if (originTypes.length - originFiltered.length === types.length - filtered.length) {
                    if (originFiltered.length === 1) {
                        return originFiltered[0];
                    }
                    newOrigin = createOriginUnionOrIntersectionType(TypeFlags.Union, originFiltered);
                }
            }
            // filtering could remove intersections so `ContainsIntersections` might be forwarded "incorrectly"
            // it is purely an optimization hint so there is no harm in accidentally forwarding it
            return getUnionTypeFromSortedList(filtered, (type as UnionType).objectFlags & (ObjectFlags.PrimitiveUnion | ObjectFlags.ContainsIntersections), /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, newOrigin);
        }
        return type.flags & TypeFlags.Never || f(type) ? type : neverType;
    }

    function removeType(type: Type, targetType: Type) {
        return filterType(type, t => t !== targetType);
    }

    function countTypes(type: Type) {
        return type.flags & TypeFlags.Union ? (type as UnionType).types.length : 1;
    }

    // Apply a mapping function to a type and return the resulting type. If the source type
    // is a union type, the mapping function is applied to each constituent type and a union
    // of the resulting types is returned.
    function mapType(type: Type, mapper: (t: Type) => Type, noReductions?: boolean): Type;
    function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined;
    function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined {
        if (type.flags & TypeFlags.Never) {
            return type;
        }
        if (!(type.flags & TypeFlags.Union)) {
            return mapper(type);
        }
        const origin = (type as UnionType).origin;
        const types = origin && origin.flags & TypeFlags.Union ? (origin as UnionType).types : (type as UnionType).types;
        let mappedTypes: Type[] | undefined;
        let changed = false;
        for (const t of types) {
            const mapped = t.flags & TypeFlags.Union ? mapType(t, mapper, noReductions) : mapper(t);
            changed ||= t !== mapped;
            if (mapped) {
                if (!mappedTypes) {
                    mappedTypes = [mapped];
                }
                else {
                    mappedTypes.push(mapped);
                }
            }
        }
        return changed ? mappedTypes && getUnionType(mappedTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) : type;
    }

    function mapTypeWithAlias(type: Type, mapper: (t: Type) => Type, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined) {
        return type.flags & TypeFlags.Union && aliasSymbol ?
            getUnionType(map((type as UnionType).types, mapper), UnionReduction.Literal, aliasSymbol, aliasTypeArguments) :
            mapType(type, mapper);
    }

    function extractTypesOfKind(type: Type, kind: TypeFlags) {
        return filterType(type, t => (t.flags & kind) !== 0);
    }

    // Return a new type in which occurrences of the string, number and bigint primitives and placeholder template
    // literal types in typeWithPrimitives have been replaced with occurrences of compatible and more specific types
    // from typeWithLiterals. This is essentially a limited form of intersection between the two types. We avoid a
    // true intersection because it is more costly and, when applied to union types, generates a large number of
    // types we don't actually care about.
    function replacePrimitivesWithLiterals(typeWithPrimitives: Type, typeWithLiterals: Type) {
        if (
            maybeTypeOfKind(typeWithPrimitives, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.Number | TypeFlags.BigInt) &&
            maybeTypeOfKind(typeWithLiterals, TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping | TypeFlags.NumberLiteral | TypeFlags.BigIntLiteral)
        ) {
            return mapType(typeWithPrimitives, t =>
                t.flags & TypeFlags.String ? extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) :
                    isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) :
                    t.flags & TypeFlags.Number ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.NumberLiteral) :
                    t.flags & TypeFlags.BigInt ? extractTypesOfKind(typeWithLiterals, TypeFlags.BigInt | TypeFlags.BigIntLiteral) : t);
        }
        return typeWithPrimitives;
    }

    function isIncomplete(flowType: FlowType) {
        return flowType.flags === 0;
    }

    function getTypeFromFlowType(flowType: FlowType) {
        return flowType.flags === 0 ? flowType.type : flowType as Type;
    }

    function createFlowType(type: Type, incomplete: boolean): FlowType {
        return incomplete ? { flags: 0, type: type.flags & TypeFlags.Never ? silentNeverType : type } : type;
    }

    // An evolving array type tracks the element types that have so far been seen in an
    // 'x.push(value)' or 'x[n] = value' operation along the control flow graph. Evolving
    // array types are ultimately converted into manifest array types (using getFinalArrayType)
    // and never escape the getFlowTypeOfReference function.
    function createEvolvingArrayType(elementType: Type): EvolvingArrayType {
        const result = createObjectType(ObjectFlags.EvolvingArray) as EvolvingArrayType;
        result.elementType = elementType;
        return result;
    }

    function getEvolvingArrayType(elementType: Type): EvolvingArrayType {
        return evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType));
    }

    // When adding evolving array element types we do not perform subtype reduction. Instead,
    // we defer subtype reduction until the evolving array type is finalized into a manifest
    // array type.
    function addEvolvingArrayElementType(evolvingArrayType: EvolvingArrayType, node: Expression): EvolvingArrayType {
        const elementType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)));
        return isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType]));
    }

    function createFinalArrayType(elementType: Type) {
        return elementType.flags & TypeFlags.Never ?
            autoArrayType :
            createArrayType(
                elementType.flags & TypeFlags.Union ?
                    getUnionType((elementType as UnionType).types, UnionReduction.Subtype) :
                    elementType,
            );
    }

    // We perform subtype reduction upon obtaining the final array type from an evolving array type.
    function getFinalArrayType(evolvingArrayType: EvolvingArrayType): Type {
        return evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType));
    }

    function finalizeEvolvingArrayType(type: Type): Type {
        return getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(type as EvolvingArrayType) : type;
    }

    function getElementTypeOfEvolvingArrayType(type: Type) {
        return getObjectFlags(type) & ObjectFlags.EvolvingArray ? (type as EvolvingArrayType).elementType : neverType;
    }

    function isEvolvingArrayTypeList(types: Type[]) {
        let hasEvolvingArrayType = false;
        for (const t of types) {
            if (!(t.flags & TypeFlags.Never)) {
                if (!(getObjectFlags(t) & ObjectFlags.EvolvingArray)) {
                    return false;
                }
                hasEvolvingArrayType = true;
            }
        }
        return hasEvolvingArrayType;
    }

    // Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
    // 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
    function isEvolvingArrayOperationTarget(node: Node) {
        const root = getReferenceRoot(node);
        const parent = root.parent;
        const isLengthPushOrUnshift = isPropertyAccessExpression(parent) && (
            parent.name.escapedText === "length" ||
            parent.parent.kind === SyntaxKind.CallExpression
                && isIdentifier(parent.name)
                && isPushOrUnshiftIdentifier(parent.name)
        );
        const isElementAssignment = parent.kind === SyntaxKind.ElementAccessExpression &&
            (parent as ElementAccessExpression).expression === root &&
            parent.parent.kind === SyntaxKind.BinaryExpression &&
            (parent.parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken &&
            (parent.parent as BinaryExpression).left === parent &&
            !isAssignmentTarget(parent.parent) &&
            isTypeAssignableToKind(getTypeOfExpression((parent as ElementAccessExpression).argumentExpression), TypeFlags.NumberLike);
        return isLengthPushOrUnshift || isElementAssignment;
    }

    function isDeclarationWithExplicitTypeAnnotation(node: Declaration) {
        return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) &&
            !!(getEffectiveTypeAnnotationNode(node) ||
                isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer));
    }

    function getExplicitTypeOfSymbol(symbol: Symbol, diagnostic?: Diagnostic) {
        symbol = resolveSymbol(symbol);
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.ValueModule)) {
            return getTypeOfSymbol(symbol);
        }
        if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {
            if (getCheckFlags(symbol) & CheckFlags.Mapped) {
                const origin = (symbol as MappedSymbol).links.syntheticOrigin;
                if (origin && getExplicitTypeOfSymbol(origin)) {
                    return getTypeOfSymbol(symbol);
                }
            }
            const declaration = symbol.valueDeclaration;
            if (declaration) {
                if (isDeclarationWithExplicitTypeAnnotation(declaration)) {
                    return getTypeOfSymbol(symbol);
                }
                if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForOfStatement) {
                    const statement = declaration.parent.parent;
                    const expressionType = getTypeOfDottedName(statement.expression, /*diagnostic*/ undefined);
                    if (expressionType) {
                        const use = statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf;
                        return checkIteratedTypeOrElementType(use, expressionType, undefinedType, /*errorNode*/ undefined);
                    }
                }
                if (diagnostic) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)));
                }
            }
        }
    }

    // We require the dotted function name in an assertion expression to be comprised of identifiers
    // that reference function, method, class or value module symbols; or variable, property or
    // parameter symbols with declarations that have explicit type annotations. Such references are
    // resolvable with no possibility of triggering circularities in control flow analysis.
    function getTypeOfDottedName(node: Expression, diagnostic: Diagnostic | undefined): Type | undefined {
        if (!(node.flags & NodeFlags.InWithStatement)) {
            switch (node.kind) {
                case SyntaxKind.Identifier:
                    const symbol = getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node as Identifier));
                    return getExplicitTypeOfSymbol(symbol, diagnostic);
                case SyntaxKind.ThisKeyword:
                    return getExplicitThisType(node);
                case SyntaxKind.SuperKeyword:
                    return checkSuperExpression(node);
                case SyntaxKind.PropertyAccessExpression: {
                    const type = getTypeOfDottedName((node as PropertyAccessExpression).expression, diagnostic);
                    if (type) {
                        const name = (node as PropertyAccessExpression).name;
                        let prop: Symbol | undefined;
                        if (isPrivateIdentifier(name)) {
                            if (!type.symbol) {
                                return undefined;
                            }
                            prop = getPropertyOfType(type, getSymbolNameForPrivateIdentifier(type.symbol, name.escapedText));
                        }
                        else {
                            prop = getPropertyOfType(type, name.escapedText);
                        }
                        return prop && getExplicitTypeOfSymbol(prop, diagnostic);
                    }
                    return undefined;
                }
                case SyntaxKind.ParenthesizedExpression:
                    return getTypeOfDottedName((node as ParenthesizedExpression).expression, diagnostic);
            }
        }
    }

    function getEffectsSignature(node: CallExpression | InstanceofExpression) {
        const links = getNodeLinks(node);
        let signature = links.effectsSignature;
        if (signature === undefined) {
            // A call expression parented by an expression statement is a potential assertion. Other call
            // expressions are potential type predicate function calls. In order to avoid triggering
            // circularities in control flow analysis, we use getTypeOfDottedName when resolving the call
            // target expression of an assertion.
            let funcType: Type | undefined;
            if (isBinaryExpression(node)) {
                const rightType = checkNonNullExpression(node.right);
                funcType = getSymbolHasInstanceMethodOfObjectType(rightType);
            }
            else if (node.parent.kind === SyntaxKind.ExpressionStatement) {
                funcType = getTypeOfDottedName(node.expression, /*diagnostic*/ undefined);
            }
            else if (node.expression.kind !== SyntaxKind.SuperKeyword) {
                if (isOptionalChain(node)) {
                    funcType = checkNonNullType(
                        getOptionalExpressionType(checkExpression(node.expression), node.expression),
                        node.expression,
                    );
                }
                else {
                    funcType = checkNonNullExpression(node.expression);
                }
            }
            const signatures = getSignaturesOfType(funcType && getApparentType(funcType) || unknownType, SignatureKind.Call);
            const candidate = signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] :
                some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) :
                undefined;
            signature = links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature;
        }
        return signature === unknownSignature ? undefined : signature;
    }

    function hasTypePredicateOrNeverReturnType(signature: Signature) {
        return !!(getTypePredicateOfSignature(signature) ||
            signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags & TypeFlags.Never);
    }

    function getTypePredicateArgument(predicate: TypePredicate, callExpression: CallExpression) {
        if (predicate.kind === TypePredicateKind.Identifier || predicate.kind === TypePredicateKind.AssertsIdentifier) {
            return callExpression.arguments[predicate.parameterIndex];
        }
        const invokedExpression = skipParentheses(callExpression.expression);
        return isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : undefined;
    }

    function reportFlowControlError(node: Node) {
        const block = findAncestor(node, isFunctionOrModuleBlock) as Block | ModuleBlock | SourceFile;
        const sourceFile = getSourceFileOfNode(node);
        const span = getSpanOfTokenAtPosition(sourceFile, block.statements.pos);
        diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis));
    }

    function isReachableFlowNode(flow: FlowNode) {
        const result = isReachableFlowNodeWorker(flow, /*noCacheCheck*/ false);
        lastFlowNode = flow;
        lastFlowNodeReachable = result;
        return result;
    }

    function isFalseExpression(expr: Expression): boolean {
        const node = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
        return node.kind === SyntaxKind.FalseKeyword || node.kind === SyntaxKind.BinaryExpression && (
                    (node as BinaryExpression).operatorToken.kind === SyntaxKind.AmpersandAmpersandToken && (isFalseExpression((node as BinaryExpression).left) || isFalseExpression((node as BinaryExpression).right)) ||
                    (node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken && isFalseExpression((node as BinaryExpression).left) && isFalseExpression((node as BinaryExpression).right)
                );
    }

    function isReachableFlowNodeWorker(flow: FlowNode, noCacheCheck: boolean): boolean {
        while (true) {
            if (flow === lastFlowNode) {
                return lastFlowNodeReachable;
            }
            const flags = flow.flags;
            if (flags & FlowFlags.Shared) {
                if (!noCacheCheck) {
                    const id = getFlowNodeId(flow);
                    const reachable = flowNodeReachable[id];
                    return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck*/ true));
                }
                noCacheCheck = false;
            }
            if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation)) {
                flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation).antecedent;
            }
            else if (flags & FlowFlags.Call) {
                const signature = getEffectsSignature((flow as FlowCall).node);
                if (signature) {
                    const predicate = getTypePredicateOfSignature(signature);
                    if (predicate && predicate.kind === TypePredicateKind.AssertsIdentifier && !predicate.type) {
                        const predicateArgument = (flow as FlowCall).node.arguments[predicate.parameterIndex];
                        if (predicateArgument && isFalseExpression(predicateArgument)) {
                            return false;
                        }
                    }
                    if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {
                        return false;
                    }
                }
                flow = (flow as FlowCall).antecedent;
            }
            else if (flags & FlowFlags.BranchLabel) {
                // A branching point is reachable if any branch is reachable.
                return some((flow as FlowLabel).antecedent, f => isReachableFlowNodeWorker(f, /*noCacheCheck*/ false));
            }
            else if (flags & FlowFlags.LoopLabel) {
                const antecedents = (flow as FlowLabel).antecedent;
                if (antecedents === undefined || antecedents.length === 0) {
                    return false;
                }
                // A loop is reachable if the control flow path that leads to the top is reachable.
                flow = antecedents[0];
            }
            else if (flags & FlowFlags.SwitchClause) {
                // The control flow path representing an unmatched value in a switch statement with
                // no default clause is unreachable if the switch statement is exhaustive.
                const data = (flow as FlowSwitchClause).node;
                if (data.clauseStart === data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement)) {
                    return false;
                }
                flow = (flow as FlowSwitchClause).antecedent;
            }
            else if (flags & FlowFlags.ReduceLabel) {
                // Cache is unreliable once we start adjusting labels
                lastFlowNode = undefined;
                const target = (flow as FlowReduceLabel).node.target;
                const saveAntecedents = target.antecedent;
                target.antecedent = (flow as FlowReduceLabel).node.antecedents;
                const result = isReachableFlowNodeWorker((flow as FlowReduceLabel).antecedent, /*noCacheCheck*/ false);
                target.antecedent = saveAntecedents;
                return result;
            }
            else {
                return !(flags & FlowFlags.Unreachable);
            }
        }
    }

    // Return true if the given flow node is preceded by a 'super(...)' call in every possible code path
    // leading to the node.
    function isPostSuperFlowNode(flow: FlowNode, noCacheCheck: boolean): boolean {
        while (true) {
            const flags = flow.flags;
            if (flags & FlowFlags.Shared) {
                if (!noCacheCheck) {
                    const id = getFlowNodeId(flow);
                    const postSuper = flowNodePostSuper[id];
                    return postSuper !== undefined ? postSuper : (flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck*/ true));
                }
                noCacheCheck = false;
            }
            if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation | FlowFlags.SwitchClause)) {
                flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation | FlowSwitchClause).antecedent;
            }
            else if (flags & FlowFlags.Call) {
                if ((flow as FlowCall).node.expression.kind === SyntaxKind.SuperKeyword) {
                    return true;
                }
                flow = (flow as FlowCall).antecedent;
            }
            else if (flags & FlowFlags.BranchLabel) {
                // A branching point is post-super if every branch is post-super.
                return every((flow as FlowLabel).antecedent, f => isPostSuperFlowNode(f, /*noCacheCheck*/ false));
            }
            else if (flags & FlowFlags.LoopLabel) {
                // A loop is post-super if the control flow path that leads to the top is post-super.
                flow = (flow as FlowLabel).antecedent![0];
            }
            else if (flags & FlowFlags.ReduceLabel) {
                const target = (flow as FlowReduceLabel).node.target;
                const saveAntecedents = target.antecedent;
                target.antecedent = (flow as FlowReduceLabel).node.antecedents;
                const result = isPostSuperFlowNode((flow as FlowReduceLabel).antecedent, /*noCacheCheck*/ false);
                target.antecedent = saveAntecedents;
                return result;
            }
            else {
                // Unreachable nodes are considered post-super to silence errors
                return !!(flags & FlowFlags.Unreachable);
            }
        }
    }

    function isConstantReference(node: Node): boolean {
        switch (node.kind) {
            case SyntaxKind.ThisKeyword:
                return true;
            case SyntaxKind.Identifier:
                if (!isThisInTypeQuery(node)) {
                    const symbol = getResolvedSymbol(node as Identifier);
                    return isConstantVariable(symbol)
                        || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)
                        || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration);
                }
                break;
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                // The resolvedSymbol property is initialized by checkPropertyAccess or checkElementAccess before we get here.
                return isConstantReference((node as AccessExpression).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol);
            case SyntaxKind.ObjectBindingPattern:
            case SyntaxKind.ArrayBindingPattern:
                const rootDeclaration = getRootDeclaration(node.parent);
                return isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration)
                    ? !isSomeSymbolAssigned(rootDeclaration)
                    : isVariableDeclaration(rootDeclaration) && isVarConstLike(rootDeclaration);
        }
        return false;
    }

    function getFlowTypeOfReference(reference: Node, declaredType: Type, initialType = declaredType, flowContainer?: Node, flowNode = tryCast(reference, canHaveFlowNode)?.flowNode) {
        let key: string | undefined;
        let isKeySet = false;
        let flowDepth = 0;
        if (flowAnalysisDisabled) {
            return errorType;
        }
        if (!flowNode) {
            return declaredType;
        }
        flowInvocationCount++;
        const sharedFlowStart = sharedFlowCount;
        const evolvedType = getTypeFromFlowType(getTypeAtFlowNode(flowNode));
        sharedFlowCount = sharedFlowStart;
        // When the reference is 'x' in an 'x.length', 'x.push(value)', 'x.unshift(value)' or x[n] = value' operation,
        // we give type 'any[]' to 'x' instead of using the type determined by control flow analysis such that operations
        // on empty arrays are possible without implicit any errors and new element types can be inferred without
        // type mismatch errors.
        const resultType = getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType);
        if (resultType === unreachableNeverType || reference.parent && reference.parent.kind === SyntaxKind.NonNullExpression && !(resultType.flags & TypeFlags.Never) && getTypeWithFacts(resultType, TypeFacts.NEUndefinedOrNull).flags & TypeFlags.Never) {
            return declaredType;
        }
        return resultType;

        function getOrSetCacheKey() {
            if (isKeySet) {
                return key;
            }
            isKeySet = true;
            return key = getFlowCacheKey(reference, declaredType, initialType, flowContainer);
        }

        function getTypeAtFlowNode(flow: FlowNode): FlowType {
            if (flowDepth === 2000) {
                // We have made 2000 recursive invocations. To avoid overflowing the call stack we report an error
                // and disable further control flow analysis in the containing function or module body.
                tracing?.instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit", { flowId: flow.id });
                flowAnalysisDisabled = true;
                reportFlowControlError(reference);
                return errorType;
            }
            flowDepth++;
            let sharedFlow: FlowNode | undefined;
            while (true) {
                const flags = flow.flags;
                if (flags & FlowFlags.Shared) {
                    // We cache results of flow type resolution for shared nodes that were previously visited in
                    // the same getFlowTypeOfReference invocation. A node is considered shared when it is the
                    // antecedent of more than one node.
                    for (let i = sharedFlowStart; i < sharedFlowCount; i++) {
                        if (sharedFlowNodes[i] === flow) {
                            flowDepth--;
                            return sharedFlowTypes[i];
                        }
                    }
                    sharedFlow = flow;
                }
                let type: FlowType | undefined;
                if (flags & FlowFlags.Assignment) {
                    type = getTypeAtFlowAssignment(flow as FlowAssignment);
                    if (!type) {
                        flow = (flow as FlowAssignment).antecedent;
                        continue;
                    }
                }
                else if (flags & FlowFlags.Call) {
                    type = getTypeAtFlowCall(flow as FlowCall);
                    if (!type) {
                        flow = (flow as FlowCall).antecedent;
                        continue;
                    }
                }
                else if (flags & FlowFlags.Condition) {
                    type = getTypeAtFlowCondition(flow as FlowCondition);
                }
                else if (flags & FlowFlags.SwitchClause) {
                    type = getTypeAtSwitchClause(flow as FlowSwitchClause);
                }
                else if (flags & FlowFlags.Label) {
                    if ((flow as FlowLabel).antecedent!.length === 1) {
                        flow = (flow as FlowLabel).antecedent![0];
                        continue;
                    }
                    type = flags & FlowFlags.BranchLabel ?
                        getTypeAtFlowBranchLabel(flow as FlowLabel) :
                        getTypeAtFlowLoopLabel(flow as FlowLabel);
                }
                else if (flags & FlowFlags.ArrayMutation) {
                    type = getTypeAtFlowArrayMutation(flow as FlowArrayMutation);
                    if (!type) {
                        flow = (flow as FlowArrayMutation).antecedent;
                        continue;
                    }
                }
                else if (flags & FlowFlags.ReduceLabel) {
                    const target = (flow as FlowReduceLabel).node.target;
                    const saveAntecedents = target.antecedent;
                    target.antecedent = (flow as FlowReduceLabel).node.antecedents;
                    type = getTypeAtFlowNode((flow as FlowReduceLabel).antecedent);
                    target.antecedent = saveAntecedents;
                }
                else if (flags & FlowFlags.Start) {
                    // Check if we should continue with the control flow of the containing function.
                    const container = (flow as FlowStart).node;
                    if (
                        container && container !== flowContainer &&
                        reference.kind !== SyntaxKind.PropertyAccessExpression &&
                        reference.kind !== SyntaxKind.ElementAccessExpression &&
                        !(reference.kind === SyntaxKind.ThisKeyword && container.kind !== SyntaxKind.ArrowFunction)
                    ) {
                        flow = container.flowNode!;
                        continue;
                    }
                    // At the top of the flow we have the initial type.
                    type = initialType;
                }
                else {
                    // Unreachable code errors are reported in the binding phase. Here we
                    // simply return the non-auto declared type to reduce follow-on errors.
                    type = convertAutoToAny(declaredType);
                }
                if (sharedFlow) {
                    // Record visited node and the associated type in the cache.
                    sharedFlowNodes[sharedFlowCount] = sharedFlow;
                    sharedFlowTypes[sharedFlowCount] = type;
                    sharedFlowCount++;
                }
                flowDepth--;
                return type;
            }
        }

        function getInitialOrAssignedType(flow: FlowAssignment) {
            const node = flow.node;
            return getNarrowableTypeForReference(
                node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ?
                    getInitialType(node as VariableDeclaration | BindingElement) :
                    getAssignedType(node),
                reference,
            );
        }

        function getTypeAtFlowAssignment(flow: FlowAssignment) {
            const node = flow.node;
            // Assignments only narrow the computed type if the declared type is a union type. Thus, we
            // only need to evaluate the assigned type if the declared type is a union type.
            if (isMatchingReference(reference, node)) {
                if (!isReachableFlowNode(flow)) {
                    return unreachableNeverType;
                }
                if (getAssignmentTargetKind(node) === AssignmentKind.Compound) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType));
                }
                if (declaredType === autoType || declaredType === autoArrayType) {
                    if (isEmptyArrayAssignment(node)) {
                        return getEvolvingArrayType(neverType);
                    }
                    const assignedType = getWidenedLiteralType(getInitialOrAssignedType(flow));
                    return isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType;
                }
                const t = isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(declaredType) : declaredType;
                if (t.flags & TypeFlags.Union) {
                    return getAssignmentReducedType(t as UnionType, getInitialOrAssignedType(flow));
                }
                return t;
            }
            // We didn't have a direct match. However, if the reference is a dotted name, this
            // may be an assignment to a left hand part of the reference. For example, for a
            // reference 'x.y.z', we may be at an assignment to 'x.y' or 'x'. In that case,
            // return the declared type.
            if (containsMatchingReference(reference, node)) {
                if (!isReachableFlowNode(flow)) {
                    return unreachableNeverType;
                }
                // A matching dotted name might also be an expando property on a function *expression*,
                // in which case we continue control flow analysis back to the function's declaration
                if (isVariableDeclaration(node) && (isInJSFile(node) || isVarConstLike(node))) {
                    const init = getDeclaredExpandoInitializer(node);
                    if (init && (init.kind === SyntaxKind.FunctionExpression || init.kind === SyntaxKind.ArrowFunction)) {
                        return getTypeAtFlowNode(flow.antecedent);
                    }
                }
                return declaredType;
            }
            // for (const _ in ref) acts as a nonnull on ref
            if (
                isVariableDeclaration(node) &&
                node.parent.parent.kind === SyntaxKind.ForInStatement &&
                (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference))
            ) {
                return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))));
            }
            // Assignment doesn't affect reference
            return undefined;
        }

        function narrowTypeByAssertion(type: Type, expr: Expression): Type {
            const node = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
            if (node.kind === SyntaxKind.FalseKeyword) {
                return unreachableNeverType;
            }
            if (node.kind === SyntaxKind.BinaryExpression) {
                if ((node as BinaryExpression).operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {
                    return narrowTypeByAssertion(narrowTypeByAssertion(type, (node as BinaryExpression).left), (node as BinaryExpression).right);
                }
                if ((node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken) {
                    return getUnionType([narrowTypeByAssertion(type, (node as BinaryExpression).left), narrowTypeByAssertion(type, (node as BinaryExpression).right)]);
                }
            }
            return narrowType(type, node, /*assumeTrue*/ true);
        }

        function getTypeAtFlowCall(flow: FlowCall): FlowType | undefined {
            const signature = getEffectsSignature(flow.node);
            if (signature) {
                const predicate = getTypePredicateOfSignature(signature);
                if (predicate && (predicate.kind === TypePredicateKind.AssertsThis || predicate.kind === TypePredicateKind.AssertsIdentifier)) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    const type = finalizeEvolvingArrayType(getTypeFromFlowType(flowType));
                    const narrowedType = predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, /*assumeTrue*/ true) :
                        predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) :
                        type;
                    return narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType));
                }
                if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {
                    return unreachableNeverType;
                }
            }
            return undefined;
        }

        function getTypeAtFlowArrayMutation(flow: FlowArrayMutation): FlowType | undefined {
            if (declaredType === autoType || declaredType === autoArrayType) {
                const node = flow.node;
                const expr = node.kind === SyntaxKind.CallExpression ?
                    (node.expression as PropertyAccessExpression).expression :
                    (node.left as ElementAccessExpression).expression;
                if (isMatchingReference(reference, getReferenceCandidate(expr))) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    const type = getTypeFromFlowType(flowType);
                    if (getObjectFlags(type) & ObjectFlags.EvolvingArray) {
                        let evolvedType = type as EvolvingArrayType;
                        if (node.kind === SyntaxKind.CallExpression) {
                            for (const arg of node.arguments) {
                                evolvedType = addEvolvingArrayElementType(evolvedType, arg);
                            }
                        }
                        else {
                            // We must get the context free expression type so as to not recur in an uncached fashion on the LHS (which causes exponential blowup in compile time)
                            const indexType = getContextFreeTypeOfExpression((node.left as ElementAccessExpression).argumentExpression);
                            if (isTypeAssignableToKind(indexType, TypeFlags.NumberLike)) {
                                evolvedType = addEvolvingArrayElementType(evolvedType, node.right);
                            }
                        }
                        return evolvedType === type ? flowType : createFlowType(evolvedType, isIncomplete(flowType));
                    }
                    return flowType;
                }
            }
            return undefined;
        }

        function getTypeAtFlowCondition(flow: FlowCondition): FlowType {
            const flowType = getTypeAtFlowNode(flow.antecedent);
            const type = getTypeFromFlowType(flowType);
            if (type.flags & TypeFlags.Never) {
                return flowType;
            }
            // If we have an antecedent type (meaning we're reachable in some way), we first
            // attempt to narrow the antecedent type. If that produces the never type, and if
            // the antecedent type is incomplete (i.e. a transient type in a loop), then we
            // take the type guard as an indication that control *could* reach here once we
            // have the complete type. We proceed by switching to the silent never type which
            // doesn't report errors when operators are applied to it. Note that this is the
            // *only* place a silent never type is ever generated.
            const assumeTrue = (flow.flags & FlowFlags.TrueCondition) !== 0;
            const nonEvolvingType = finalizeEvolvingArrayType(type);
            const narrowedType = narrowType(nonEvolvingType, flow.node, assumeTrue);
            if (narrowedType === nonEvolvingType) {
                return flowType;
            }
            return createFlowType(narrowedType, isIncomplete(flowType));
        }

        function getTypeAtSwitchClause(flow: FlowSwitchClause): FlowType {
            const expr = skipParentheses(flow.node.switchStatement.expression);
            const flowType = getTypeAtFlowNode(flow.antecedent);
            let type = getTypeFromFlowType(flowType);
            if (isMatchingReference(reference, expr)) {
                type = narrowTypeBySwitchOnDiscriminant(type, flow.node);
            }
            else if (expr.kind === SyntaxKind.TypeOfExpression && isMatchingReference(reference, (expr as TypeOfExpression).expression)) {
                type = narrowTypeBySwitchOnTypeOf(type, flow.node);
            }
            else if (expr.kind === SyntaxKind.TrueKeyword) {
                type = narrowTypeBySwitchOnTrue(type, flow.node);
            }
            else {
                if (strictNullChecks) {
                    if (optionalChainContainsReference(expr, reference)) {
                        type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & (TypeFlags.Undefined | TypeFlags.Never)));
                    }
                    else if (expr.kind === SyntaxKind.TypeOfExpression && optionalChainContainsReference((expr as TypeOfExpression).expression, reference)) {
                        type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & TypeFlags.Never || t.flags & TypeFlags.StringLiteral && (t as StringLiteralType).value === "undefined"));
                    }
                }
                const access = getDiscriminantPropertyAccess(expr, type);
                if (access) {
                    type = narrowTypeBySwitchOnDiscriminantProperty(type, access, flow.node);
                }
            }
            return createFlowType(type, isIncomplete(flowType));
        }

        function getTypeAtFlowBranchLabel(flow: FlowLabel): FlowType {
            const antecedentTypes: Type[] = [];
            let subtypeReduction = false;
            let seenIncomplete = false;
            let bypassFlow: FlowSwitchClause | undefined;
            for (const antecedent of flow.antecedent!) {
                if (!bypassFlow && antecedent.flags & FlowFlags.SwitchClause && (antecedent as FlowSwitchClause).node.clauseStart === (antecedent as FlowSwitchClause).node.clauseEnd) {
                    // The antecedent is the bypass branch of a potentially exhaustive switch statement.
                    bypassFlow = antecedent as FlowSwitchClause;
                    continue;
                }
                const flowType = getTypeAtFlowNode(antecedent);
                const type = getTypeFromFlowType(flowType);
                // If the type at a particular antecedent path is the declared type and the
                // reference is known to always be assigned (i.e. when declared and initial types
                // are the same), there is no reason to process more antecedents since the only
                // possible outcome is subtypes that will be removed in the final union type anyway.
                if (type === declaredType && declaredType === initialType) {
                    return type;
                }
                pushIfUnique(antecedentTypes, type);
                // If an antecedent type is not a subset of the declared type, we need to perform
                // subtype reduction. This happens when a "foreign" type is injected into the control
                // flow using the instanceof operator or a user defined type predicate.
                if (!isTypeSubsetOf(type, initialType)) {
                    subtypeReduction = true;
                }
                if (isIncomplete(flowType)) {
                    seenIncomplete = true;
                }
            }
            if (bypassFlow) {
                const flowType = getTypeAtFlowNode(bypassFlow);
                const type = getTypeFromFlowType(flowType);
                // If the bypass flow contributes a type we haven't seen yet and the switch statement
                // isn't exhaustive, process the bypass flow type. Since exhaustiveness checks increase
                // the risk of circularities, we only want to perform them when they make a difference.
                if (!(type.flags & TypeFlags.Never) && !contains(antecedentTypes, type) && !isExhaustiveSwitchStatement(bypassFlow.node.switchStatement)) {
                    if (type === declaredType && declaredType === initialType) {
                        return type;
                    }
                    antecedentTypes.push(type);
                    if (!isTypeSubsetOf(type, initialType)) {
                        subtypeReduction = true;
                    }
                    if (isIncomplete(flowType)) {
                        seenIncomplete = true;
                    }
                }
            }
            return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal), seenIncomplete);
        }

        function getTypeAtFlowLoopLabel(flow: FlowLabel): FlowType {
            // If we have previously computed the control flow type for the reference at
            // this flow loop junction, return the cached type.
            const id = getFlowNodeId(flow);
            const cache = flowLoopCaches[id] || (flowLoopCaches[id] = new Map<string, Type>());
            const key = getOrSetCacheKey();
            if (!key) {
                // No cache key is generated when binding patterns are in unnarrowable situations
                return declaredType;
            }
            const cached = cache.get(key);
            if (cached) {
                return cached;
            }
            // If this flow loop junction and reference are already being processed, return
            // the union of the types computed for each branch so far, marked as incomplete.
            // It is possible to see an empty array in cases where loops are nested and the
            // back edge of the outer loop reaches an inner loop that is already being analyzed.
            // In such cases we restart the analysis of the inner loop, which will then see
            // a non-empty in-process array for the outer loop and eventually terminate because
            // the first antecedent of a loop junction is always the non-looping control flow
            // path that leads to the top.
            for (let i = flowLoopStart; i < flowLoopCount; i++) {
                if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {
                    return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReduction.Literal), /*incomplete*/ true);
                }
            }
            // Add the flow loop junction and reference to the in-process stack and analyze
            // each antecedent code path.
            const antecedentTypes: Type[] = [];
            let subtypeReduction = false;
            let firstAntecedentType: FlowType | undefined;
            for (const antecedent of flow.antecedent!) {
                let flowType;
                if (!firstAntecedentType) {
                    // The first antecedent of a loop junction is always the non-looping control
                    // flow path that leads to the top.
                    flowType = firstAntecedentType = getTypeAtFlowNode(antecedent);
                }
                else {
                    // All but the first antecedent are the looping control flow paths that lead
                    // back to the loop junction. We track these on the flow loop stack.
                    flowLoopNodes[flowLoopCount] = flow;
                    flowLoopKeys[flowLoopCount] = key;
                    flowLoopTypes[flowLoopCount] = antecedentTypes;
                    flowLoopCount++;
                    const saveFlowTypeCache = flowTypeCache;
                    flowTypeCache = undefined;
                    flowType = getTypeAtFlowNode(antecedent);
                    flowTypeCache = saveFlowTypeCache;
                    flowLoopCount--;
                    // If we see a value appear in the cache it is a sign that control flow analysis
                    // was restarted and completed by checkExpressionCached. We can simply pick up
                    // the resulting type and bail out.
                    const cached = cache.get(key);
                    if (cached) {
                        return cached;
                    }
                }
                const type = getTypeFromFlowType(flowType);
                pushIfUnique(antecedentTypes, type);
                // If an antecedent type is not a subset of the declared type, we need to perform
                // subtype reduction. This happens when a "foreign" type is injected into the control
                // flow using the instanceof operator or a user defined type predicate.
                if (!isTypeSubsetOf(type, initialType)) {
                    subtypeReduction = true;
                }
                // If the type at a particular antecedent path is the declared type there is no
                // reason to process more antecedents since the only possible outcome is subtypes
                // that will be removed in the final union type anyway.
                if (type === declaredType) {
                    break;
                }
            }
            // The result is incomplete if the first antecedent (the non-looping control flow path)
            // is incomplete.
            const result = getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal);
            if (isIncomplete(firstAntecedentType!)) {
                return createFlowType(result, /*incomplete*/ true);
            }
            cache.set(key, result);
            return result;
        }

        // At flow control branch or loop junctions, if the type along every antecedent code path
        // is an evolving array type, we construct a combined evolving array type. Otherwise we
        // finalize all evolving array types.
        function getUnionOrEvolvingArrayType(types: Type[], subtypeReduction: UnionReduction) {
            if (isEvolvingArrayTypeList(types)) {
                return getEvolvingArrayType(getUnionType(map(types, getElementTypeOfEvolvingArrayType)));
            }
            const result = recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction));
            if (result !== declaredType && result.flags & declaredType.flags & TypeFlags.Union && arrayIsEqualTo((result as UnionType).types, (declaredType as UnionType).types)) {
                return declaredType;
            }
            return result;
        }

        function getCandidateDiscriminantPropertyAccess(expr: Expression) {
            if (isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference)) {
                // When the reference is a binding pattern or function or arrow expression, we are narrowing a pesudo-reference in
                // getNarrowedTypeOfSymbol. An identifier for a destructuring variable declared in the same binding pattern or
                // parameter declared in the same parameter list is a candidate.
                if (isIdentifier(expr)) {
                    const symbol = getResolvedSymbol(expr);
                    const declaration = getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
                    if (declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference === declaration.parent && !declaration.initializer && !declaration.dotDotDotToken) {
                        return declaration;
                    }
                }
            }
            else if (isAccessExpression(expr)) {
                // An access expression is a candidate if the reference matches the left hand expression.
                if (isMatchingReference(reference, expr.expression)) {
                    return expr;
                }
            }
            else if (isIdentifier(expr)) {
                const symbol = getResolvedSymbol(expr);
                if (isConstantVariable(symbol)) {
                    const declaration = symbol.valueDeclaration!;
                    // Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'
                    if (
                        isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(declaration.initializer) &&
                        isMatchingReference(reference, declaration.initializer.expression)
                    ) {
                        return declaration.initializer;
                    }
                    // Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'
                    if (isBindingElement(declaration) && !declaration.initializer) {
                        const parent = declaration.parent.parent;
                        if (
                            isVariableDeclaration(parent) && !parent.type && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) &&
                            isMatchingReference(reference, parent.initializer)
                        ) {
                            return declaration;
                        }
                    }
                }
            }
            return undefined;
        }

        function getDiscriminantPropertyAccess(expr: Expression, computedType: Type) {
            // As long as the computed type is a subset of the declared type, we use the full declared type to detect
            // a discriminant property. In cases where the computed type isn't a subset, e.g because of a preceding type
            // predicate narrowing, we use the actual computed type.
            if (declaredType.flags & TypeFlags.Union || computedType.flags & TypeFlags.Union) {
                const access = getCandidateDiscriminantPropertyAccess(expr);
                if (access) {
                    const name = getAccessedPropertyName(access);
                    if (name) {
                        const type = declaredType.flags & TypeFlags.Union && isTypeSubsetOf(computedType, declaredType) ? declaredType : computedType;
                        if (isDiscriminantProperty(type, name)) {
                            return access;
                        }
                    }
                }
            }
            return undefined;
        }

        function narrowTypeByDiscriminant(type: Type, access: AccessExpression | BindingElement | ParameterDeclaration, narrowType: (t: Type) => Type): Type {
            const propName = getAccessedPropertyName(access);
            if (propName === undefined) {
                return type;
            }
            const optionalChain = isOptionalChain(access);
            const removeNullable = strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type, TypeFlags.Nullable);
            let propType = getTypeOfPropertyOfType(removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type, propName);
            if (!propType) {
                return type;
            }
            propType = removeNullable && optionalChain ? getOptionalType(propType) : propType;
            const narrowedPropType = narrowType(propType);
            return filterType(type, t => {
                const discriminantType = getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType;
                return !(discriminantType.flags & TypeFlags.Never) && !(narrowedPropType.flags & TypeFlags.Never) && areTypesComparable(narrowedPropType, discriminantType);
            });
        }

        function narrowTypeByDiscriminantProperty(type: Type, access: AccessExpression | BindingElement | ParameterDeclaration, operator: SyntaxKind, value: Expression, assumeTrue: boolean) {
            if ((operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) && type.flags & TypeFlags.Union) {
                const keyPropertyName = getKeyPropertyName(type as UnionType);
                if (keyPropertyName && keyPropertyName === getAccessedPropertyName(access)) {
                    const candidate = getConstituentTypeForKeyType(type as UnionType, getTypeOfExpression(value));
                    if (candidate) {
                        return operator === (assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken) ? candidate :
                            isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) :
                            type;
                    }
                }
            }
            return narrowTypeByDiscriminant(type, access, t => narrowTypeByEquality(t, operator, value, assumeTrue));
        }

        function narrowTypeBySwitchOnDiscriminantProperty(type: Type, access: AccessExpression | BindingElement | ParameterDeclaration, data: FlowSwitchClauseData) {
            if (data.clauseStart < data.clauseEnd && type.flags & TypeFlags.Union && getKeyPropertyName(type as UnionType) === getAccessedPropertyName(access)) {
                const clauseTypes = getSwitchClauseTypes(data.switchStatement).slice(data.clauseStart, data.clauseEnd);
                const candidate = getUnionType(map(clauseTypes, t => getConstituentTypeForKeyType(type as UnionType, t) || unknownType));
                if (candidate !== unknownType) {
                    return candidate;
                }
            }
            return narrowTypeByDiscriminant(type, access, t => narrowTypeBySwitchOnDiscriminant(t, data));
        }

        function narrowTypeByTruthiness(type: Type, expr: Expression, assumeTrue: boolean): Type {
            if (isMatchingReference(reference, expr)) {
                return getAdjustedTypeWithFacts(type, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy);
            }
            if (strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference)) {
                type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
            }
            const access = getDiscriminantPropertyAccess(expr, type);
            if (access) {
                return narrowTypeByDiscriminant(type, access, t => getTypeWithFacts(t, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy));
            }
            return type;
        }

        function isTypePresencePossible(type: Type, propName: __String, assumeTrue: boolean) {
            const prop = getPropertyOfType(type, propName);
            return prop ?
                !!(prop.flags & SymbolFlags.Optional || getCheckFlags(prop) & CheckFlags.Partial) || assumeTrue :
                !!getApplicableIndexInfoForName(type, propName) || !assumeTrue;
        }

        function narrowTypeByInKeyword(type: Type, nameType: StringLiteralType | NumberLiteralType | UniqueESSymbolType, assumeTrue: boolean) {
            const name = getPropertyNameFromType(nameType);
            const isKnownProperty = someType(type, t => isTypePresencePossible(t, name, /*assumeTrue*/ true));
            if (isKnownProperty) {
                // If the check is for a known property (i.e. a property declared in some constituent of
                // the target type), we filter the target type by presence of absence of the property.
                return filterType(type, t => isTypePresencePossible(t, name, assumeTrue));
            }
            if (assumeTrue) {
                // If the check is for an unknown property, we intersect the target type with `Record<X, unknown>`,
                // where X is the name of the property.
                const recordSymbol = getGlobalRecordSymbol();
                if (recordSymbol) {
                    return getIntersectionType([type, getTypeAliasInstantiation(recordSymbol, [nameType, unknownType])]);
                }
            }
            return type;
        }

        function narrowTypeByBooleanComparison(type: Type, expr: Expression, bool: BooleanLiteral, operator: BinaryOperator, assumeTrue: boolean): Type {
            assumeTrue = (assumeTrue !== (bool.kind === SyntaxKind.TrueKeyword)) !== (operator !== SyntaxKind.ExclamationEqualsEqualsToken && operator !== SyntaxKind.ExclamationEqualsToken);
            return narrowType(type, expr, assumeTrue);
        }

        function narrowTypeByBinaryExpression(type: Type, expr: BinaryExpression, assumeTrue: boolean): Type {
            switch (expr.operatorToken.kind) {
                case SyntaxKind.EqualsToken:
                case SyntaxKind.BarBarEqualsToken:
                case SyntaxKind.AmpersandAmpersandEqualsToken:
                case SyntaxKind.QuestionQuestionEqualsToken:
                    return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.EqualsEqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsEqualsToken:
                    const operator = expr.operatorToken.kind;
                    const left = getReferenceCandidate(expr.left);
                    const right = getReferenceCandidate(expr.right);
                    if (left.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(right)) {
                        return narrowTypeByTypeof(type, left as TypeOfExpression, operator, right, assumeTrue);
                    }
                    if (right.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(left)) {
                        return narrowTypeByTypeof(type, right as TypeOfExpression, operator, left, assumeTrue);
                    }
                    if (isMatchingReference(reference, left)) {
                        return narrowTypeByEquality(type, operator, right, assumeTrue);
                    }
                    if (isMatchingReference(reference, right)) {
                        return narrowTypeByEquality(type, operator, left, assumeTrue);
                    }
                    if (strictNullChecks) {
                        if (optionalChainContainsReference(left, reference)) {
                            type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);
                        }
                        else if (optionalChainContainsReference(right, reference)) {
                            type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);
                        }
                    }
                    const leftAccess = getDiscriminantPropertyAccess(left, type);
                    if (leftAccess) {
                        return narrowTypeByDiscriminantProperty(type, leftAccess, operator, right, assumeTrue);
                    }
                    const rightAccess = getDiscriminantPropertyAccess(right, type);
                    if (rightAccess) {
                        return narrowTypeByDiscriminantProperty(type, rightAccess, operator, left, assumeTrue);
                    }
                    if (isMatchingConstructorReference(left)) {
                        return narrowTypeByConstructor(type, operator, right, assumeTrue);
                    }
                    if (isMatchingConstructorReference(right)) {
                        return narrowTypeByConstructor(type, operator, left, assumeTrue);
                    }
                    if (isBooleanLiteral(right) && !isAccessExpression(left)) {
                        return narrowTypeByBooleanComparison(type, left, right, operator, assumeTrue);
                    }
                    if (isBooleanLiteral(left) && !isAccessExpression(right)) {
                        return narrowTypeByBooleanComparison(type, right, left, operator, assumeTrue);
                    }
                    break;
                case SyntaxKind.InstanceOfKeyword:
                    return narrowTypeByInstanceof(type, expr as InstanceofExpression, assumeTrue);
                case SyntaxKind.InKeyword:
                    if (isPrivateIdentifier(expr.left)) {
                        return narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue);
                    }
                    const target = getReferenceCandidate(expr.right);
                    if (containsMissingType(type) && isAccessExpression(reference) && isMatchingReference(reference.expression, target)) {
                        const leftType = getTypeOfExpression(expr.left);
                        if (isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) === getPropertyNameFromType(leftType)) {
                            return getTypeWithFacts(type, assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined);
                        }
                    }
                    if (isMatchingReference(reference, target)) {
                        const leftType = getTypeOfExpression(expr.left);
                        if (isTypeUsableAsPropertyName(leftType)) {
                            return narrowTypeByInKeyword(type, leftType, assumeTrue);
                        }
                    }
                    break;
                case SyntaxKind.CommaToken:
                    return narrowType(type, expr.right, assumeTrue);
                // Ordinarily we won't see && and || expressions in control flow analysis because the Binder breaks those
                // expressions down to individual conditional control flows. However, we may encounter them when analyzing
                // aliased conditional expressions.
                case SyntaxKind.AmpersandAmpersandToken:
                    return assumeTrue ?
                        narrowType(narrowType(type, expr.left, /*assumeTrue*/ true), expr.right, /*assumeTrue*/ true) :
                        getUnionType([narrowType(type, expr.left, /*assumeTrue*/ false), narrowType(type, expr.right, /*assumeTrue*/ false)]);
                case SyntaxKind.BarBarToken:
                    return assumeTrue ?
                        getUnionType([narrowType(type, expr.left, /*assumeTrue*/ true), narrowType(type, expr.right, /*assumeTrue*/ true)]) :
                        narrowType(narrowType(type, expr.left, /*assumeTrue*/ false), expr.right, /*assumeTrue*/ false);
            }
            return type;
        }

        function narrowTypeByPrivateIdentifierInInExpression(type: Type, expr: BinaryExpression, assumeTrue: boolean): Type {
            const target = getReferenceCandidate(expr.right);
            if (!isMatchingReference(reference, target)) {
                return type;
            }

            Debug.assertNode(expr.left, isPrivateIdentifier);
            const symbol = getSymbolForPrivateIdentifierExpression(expr.left);
            if (symbol === undefined) {
                return type;
            }
            const classSymbol = symbol.parent!;
            const targetType = hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration"))
                ? getTypeOfSymbol(classSymbol) as InterfaceType
                : getDeclaredTypeOfSymbol(classSymbol);
            return getNarrowedType(type, targetType, assumeTrue, /*checkDerived*/ true);
        }

        function narrowTypeByOptionalChainContainment(type: Type, operator: SyntaxKind, value: Expression, assumeTrue: boolean): Type {
            // We are in a branch of obj?.foo === value (or any one of the other equality operators). We narrow obj as follows:
            // When operator is === and type of value excludes undefined, null and undefined is removed from type of obj in true branch.
            // When operator is !== and type of value excludes undefined, null and undefined is removed from type of obj in false branch.
            // When operator is == and type of value excludes null and undefined, null and undefined is removed from type of obj in true branch.
            // When operator is != and type of value excludes null and undefined, null and undefined is removed from type of obj in false branch.
            // When operator is === and type of value is undefined, null and undefined is removed from type of obj in false branch.
            // When operator is !== and type of value is undefined, null and undefined is removed from type of obj in true branch.
            // When operator is == and type of value is null or undefined, null and undefined is removed from type of obj in false branch.
            // When operator is != and type of value is null or undefined, null and undefined is removed from type of obj in true branch.
            const equalsOperator = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;
            const nullableFlags = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined;
            const valueType = getTypeOfExpression(value);
            // Note that we include any and unknown in the exclusion test because their domain includes null and undefined.
            const removeNullable = equalsOperator !== assumeTrue && everyType(valueType, t => !!(t.flags & nullableFlags)) ||
                equalsOperator === assumeTrue && everyType(valueType, t => !(t.flags & (TypeFlags.AnyOrUnknown | nullableFlags)));
            return removeNullable ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
        }

        function narrowTypeByEquality(type: Type, operator: SyntaxKind, value: Expression, assumeTrue: boolean): Type {
            if (type.flags & TypeFlags.Any) {
                return type;
            }
            if (operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) {
                assumeTrue = !assumeTrue;
            }
            const valueType = getTypeOfExpression(value);
            const doubleEquals = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken;
            if (valueType.flags & TypeFlags.Nullable) {
                if (!strictNullChecks) {
                    return type;
                }
                const facts = doubleEquals ?
                    assumeTrue ? TypeFacts.EQUndefinedOrNull : TypeFacts.NEUndefinedOrNull :
                    valueType.flags & TypeFlags.Null ?
                    assumeTrue ? TypeFacts.EQNull : TypeFacts.NENull :
                    assumeTrue ? TypeFacts.EQUndefined : TypeFacts.NEUndefined;
                return getAdjustedTypeWithFacts(type, facts);
            }
            if (assumeTrue) {
                if (!doubleEquals && (type.flags & TypeFlags.Unknown || someType(type, isEmptyAnonymousObjectType))) {
                    if (valueType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) || isEmptyAnonymousObjectType(valueType)) {
                        return valueType;
                    }
                    if (valueType.flags & TypeFlags.Object) {
                        return nonPrimitiveType;
                    }
                }
                const filteredType = filterType(type, t => areTypesComparable(t, valueType) || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType));
                return replacePrimitivesWithLiterals(filteredType, valueType);
            }
            if (isUnitType(valueType)) {
                return filterType(type, t => !(isUnitLikeType(t) && areTypesComparable(t, valueType)));
            }
            return type;
        }

        function narrowTypeByTypeof(type: Type, typeOfExpr: TypeOfExpression, operator: SyntaxKind, literal: LiteralExpression, assumeTrue: boolean): Type {
            // We have '==', '!=', '===', or !==' operator with 'typeof xxx' and string literal operands
            if (operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) {
                assumeTrue = !assumeTrue;
            }
            const target = getReferenceCandidate(typeOfExpr.expression);
            if (!isMatchingReference(reference, target)) {
                if (strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue === (literal.text !== "undefined")) {
                    type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
                }
                const propertyAccess = getDiscriminantPropertyAccess(target, type);
                if (propertyAccess) {
                    return narrowTypeByDiscriminant(type, propertyAccess, t => narrowTypeByLiteralExpression(t, literal, assumeTrue));
                }
                return type;
            }
            return narrowTypeByLiteralExpression(type, literal, assumeTrue);
        }

        function narrowTypeByLiteralExpression(type: Type, literal: LiteralExpression, assumeTrue: boolean) {
            return assumeTrue ?
                narrowTypeByTypeName(type, literal.text) :
                getAdjustedTypeWithFacts(type, typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject);
        }

        function narrowTypeBySwitchOptionalChainContainment(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData, clauseCheck: (type: Type) => boolean) {
            const everyClauseChecks = clauseStart !== clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck);
            return everyClauseChecks ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
        }

        function narrowTypeBySwitchOnDiscriminant(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData) {
            // We only narrow if all case expressions specify
            // values with unit types, except for the case where
            // `type` is unknown. In this instance we map object
            // types to the nonPrimitive type and narrow with that.
            const switchTypes = getSwitchClauseTypes(switchStatement);
            if (!switchTypes.length) {
                return type;
            }
            const clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
            const hasDefaultClause = clauseStart === clauseEnd || contains(clauseTypes, neverType);
            if ((type.flags & TypeFlags.Unknown) && !hasDefaultClause) {
                let groundClauseTypes: Type[] | undefined;
                for (let i = 0; i < clauseTypes.length; i += 1) {
                    const t = clauseTypes[i];
                    if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {
                        if (groundClauseTypes !== undefined) {
                            groundClauseTypes.push(t);
                        }
                    }
                    else if (t.flags & TypeFlags.Object) {
                        if (groundClauseTypes === undefined) {
                            groundClauseTypes = clauseTypes.slice(0, i);
                        }
                        groundClauseTypes.push(nonPrimitiveType);
                    }
                    else {
                        return type;
                    }
                }
                return getUnionType(groundClauseTypes === undefined ? clauseTypes : groundClauseTypes);
            }
            const discriminantType = getUnionType(clauseTypes);
            const caseType = discriminantType.flags & TypeFlags.Never ? neverType :
                replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType);
            if (!hasDefaultClause) {
                return caseType;
            }
            const defaultType = filterType(type, t => !(isUnitLikeType(t) && contains(switchTypes, t.flags & TypeFlags.Undefined ? undefinedType : getRegularTypeOfLiteralType(extractUnitType(t)))));
            return caseType.flags & TypeFlags.Never ? defaultType : getUnionType([caseType, defaultType]);
        }

        function narrowTypeByTypeName(type: Type, typeName: string) {
            switch (typeName) {
                case "string":
                    return narrowTypeByTypeFacts(type, stringType, TypeFacts.TypeofEQString);
                case "number":
                    return narrowTypeByTypeFacts(type, numberType, TypeFacts.TypeofEQNumber);
                case "bigint":
                    return narrowTypeByTypeFacts(type, bigintType, TypeFacts.TypeofEQBigInt);
                case "boolean":
                    return narrowTypeByTypeFacts(type, booleanType, TypeFacts.TypeofEQBoolean);
                case "symbol":
                    return narrowTypeByTypeFacts(type, esSymbolType, TypeFacts.TypeofEQSymbol);
                case "object":
                    return type.flags & TypeFlags.Any ? type : getUnionType([narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQObject), narrowTypeByTypeFacts(type, nullType, TypeFacts.EQNull)]);
                case "function":
                    return type.flags & TypeFlags.Any ? type : narrowTypeByTypeFacts(type, globalFunctionType, TypeFacts.TypeofEQFunction);
                case "undefined":
                    return narrowTypeByTypeFacts(type, undefinedType, TypeFacts.EQUndefined);
            }
            return narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQHostObject);
        }

        function narrowTypeByTypeFacts(type: Type, impliedType: Type, facts: TypeFacts) {
            return mapType(type, t =>
                // We first check if a constituent is a subtype of the implied type. If so, we either keep or eliminate
                // the constituent based on its type facts. We use the strict subtype relation because it treats `object`
                // as a subtype of `{}`, and we need the type facts check because function types are subtypes of `object`,
                // but are classified as "function" according to `typeof`.
                isTypeRelatedTo(t, impliedType, strictSubtypeRelation) ? hasTypeFacts(t, facts) ? t : neverType :
                    // We next check if the consituent is a supertype of the implied type. If so, we substitute the implied
                    // type. This handles top types like `unknown` and `{}`, and supertypes like `{ toString(): string }`.
                    isTypeSubtypeOf(impliedType, t) ? impliedType :
                    // Neither the constituent nor the implied type is a subtype of the other, however their domains may still
                    // overlap. For example, an unconstrained type parameter and type `string`. If the type facts indicate
                    // possible overlap, we form an intersection. Otherwise, we eliminate the constituent.
                    hasTypeFacts(t, facts) ? getIntersectionType([t, impliedType]) :
                    neverType);
        }

        function narrowTypeBySwitchOnTypeOf(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData): Type {
            const witnesses = getSwitchClauseTypeOfWitnesses(switchStatement);
            if (!witnesses) {
                return type;
            }
            // Equal start and end denotes implicit fallthrough; undefined marks explicit default clause.
            const defaultIndex = findIndex(switchStatement.caseBlock.clauses, clause => clause.kind === SyntaxKind.DefaultClause);
            const hasDefaultClause = clauseStart === clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd);
            if (hasDefaultClause) {
                // In the default clause we filter constituents down to those that are not-equal to all handled cases.
                const notEqualFacts = getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses);
                return filterType(type, t => getTypeFacts(t, notEqualFacts) === notEqualFacts);
            }
            // In the non-default cause we create a union of the type narrowed by each of the listed cases.
            const clauseWitnesses = witnesses.slice(clauseStart, clauseEnd);
            return getUnionType(map(clauseWitnesses, text => text ? narrowTypeByTypeName(type, text) : neverType));
        }

        function narrowTypeBySwitchOnTrue(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData): Type {
            const defaultIndex = findIndex(switchStatement.caseBlock.clauses, clause => clause.kind === SyntaxKind.DefaultClause);
            const hasDefaultClause = clauseStart === clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd);

            // First, narrow away all of the cases that preceded this set of cases.
            for (let i = 0; i < clauseStart; i++) {
                const clause = switchStatement.caseBlock.clauses[i];
                if (clause.kind === SyntaxKind.CaseClause) {
                    type = narrowType(type, clause.expression, /*assumeTrue*/ false);
                }
            }

            // If our current set has a default, then none the other cases were hit either.
            // There's no point in narrowing by the the other cases in the set, since we can
            // get here through other paths.
            if (hasDefaultClause) {
                for (let i = clauseEnd; i < switchStatement.caseBlock.clauses.length; i++) {
                    const clause = switchStatement.caseBlock.clauses[i];
                    if (clause.kind === SyntaxKind.CaseClause) {
                        type = narrowType(type, clause.expression, /*assumeTrue*/ false);
                    }
                }
                return type;
            }

            // Now, narrow based on the cases in this set.
            const clauses = switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd);
            return getUnionType(map(clauses, clause => clause.kind === SyntaxKind.CaseClause ? narrowType(type, clause.expression, /*assumeTrue*/ true) : neverType));
        }

        function isMatchingConstructorReference(expr: Expression) {
            return (isPropertyAccessExpression(expr) && idText(expr.name) === "constructor" ||
                isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text === "constructor") &&
                isMatchingReference(reference, expr.expression);
        }

        function narrowTypeByConstructor(type: Type, operator: SyntaxKind, identifier: Expression, assumeTrue: boolean): Type {
            // Do not narrow when checking inequality.
            if (assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken)) {
                return type;
            }

            // Get the type of the constructor identifier expression, if it is not a function then do not narrow.
            const identifierType = getTypeOfExpression(identifier);
            if (!isFunctionType(identifierType) && !isConstructorType(identifierType)) {
                return type;
            }

            // Get the prototype property of the type identifier so we can find out its type.
            const prototypeProperty = getPropertyOfType(identifierType, "prototype" as __String);
            if (!prototypeProperty) {
                return type;
            }

            // Get the type of the prototype, if it is undefined, or the global `Object` or `Function` types then do not narrow.
            const prototypeType = getTypeOfSymbol(prototypeProperty);
            const candidate = !isTypeAny(prototypeType) ? prototypeType : undefined;
            if (!candidate || candidate === globalObjectType || candidate === globalFunctionType) {
                return type;
            }

            // If the type that is being narrowed is `any` then just return the `candidate` type since every type is a subtype of `any`.
            if (isTypeAny(type)) {
                return candidate;
            }

            // Filter out types that are not considered to be "constructed by" the `candidate` type.
            return filterType(type, t => isConstructedBy(t, candidate));

            function isConstructedBy(source: Type, target: Type) {
                // If either the source or target type are a class type then we need to check that they are the same exact type.
                // This is because you may have a class `A` that defines some set of properties, and another class `B`
                // that defines the same set of properties as class `A`, in that case they are structurally the same
                // type, but when you do something like `instanceOfA.constructor === B` it will return false.
                if (
                    source.flags & TypeFlags.Object && getObjectFlags(source) & ObjectFlags.Class ||
                    target.flags & TypeFlags.Object && getObjectFlags(target) & ObjectFlags.Class
                ) {
                    return source.symbol === target.symbol;
                }

                // For all other types just check that the `source` type is a subtype of the `target` type.
                return isTypeSubtypeOf(source, target);
            }
        }

        function narrowTypeByInstanceof(type: Type, expr: InstanceofExpression, assumeTrue: boolean): Type {
            const left = getReferenceCandidate(expr.left);
            if (!isMatchingReference(reference, left)) {
                if (assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference)) {
                    return getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
                }
                return type;
            }
            const right = expr.right;
            const rightType = getTypeOfExpression(right);
            if (!isTypeDerivedFrom(rightType, globalObjectType)) {
                return type;
            }

            // if the right-hand side has an object type with a custom `[Symbol.hasInstance]` method, and that method
            // has a type predicate, use the type predicate to perform narrowing. This allows normal `object` types to
            // participate in `instanceof`, as per Step 2 of https://tc39.es/ecma262/#sec-instanceofoperator.
            const signature = getEffectsSignature(expr);
            const predicate = signature && getTypePredicateOfSignature(signature);
            if (predicate && predicate.kind === TypePredicateKind.Identifier && predicate.parameterIndex === 0) {
                return getNarrowedType(type, predicate.type, assumeTrue, /*checkDerived*/ true);
            }
            if (!isTypeDerivedFrom(rightType, globalFunctionType)) {
                return type;
            }
            const instanceType = mapType(rightType, getInstanceType);
            // Don't narrow from `any` if the target type is exactly `Object` or `Function`, and narrow
            // in the false branch only if the target is a non-empty object type.
            if (
                isTypeAny(type) && (instanceType === globalObjectType || instanceType === globalFunctionType) ||
                !assumeTrue && !(instanceType.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(instanceType))
            ) {
                return type;
            }
            return getNarrowedType(type, instanceType, assumeTrue, /*checkDerived*/ true);
        }

        function getInstanceType(constructorType: Type) {
            const prototypePropertyType = getTypeOfPropertyOfType(constructorType, "prototype" as __String);
            if (prototypePropertyType && !isTypeAny(prototypePropertyType)) {
                return prototypePropertyType;
            }
            const constructSignatures = getSignaturesOfType(constructorType, SignatureKind.Construct);
            if (constructSignatures.length) {
                return getUnionType(map(constructSignatures, signature => getReturnTypeOfSignature(getErasedSignature(signature))));
            }
            // We use the empty object type to indicate we don't know the type of objects created by
            // this constructor function.
            return emptyObjectType;
        }

        function getNarrowedType(type: Type, candidate: Type, assumeTrue: boolean, checkDerived: boolean): Type {
            const key = type.flags & TypeFlags.Union ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : undefined;
            return getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived));
        }

        function getNarrowedTypeWorker(type: Type, candidate: Type, assumeTrue: boolean, checkDerived: boolean) {
            if (!assumeTrue) {
                if (type === candidate) {
                    return neverType;
                }
                if (checkDerived) {
                    return filterType(type, t => !isTypeDerivedFrom(t, candidate));
                }
                type = type.flags & TypeFlags.Unknown ? unknownUnionType : type;
                const trueType = getNarrowedType(type, candidate, /*assumeTrue*/ true, /*checkDerived*/ false);
                return recombineUnknownType(filterType(type, t => !isTypeSubsetOf(t, trueType)));
            }
            if (type.flags & TypeFlags.AnyOrUnknown) {
                return candidate;
            }
            if (type === candidate) {
                return candidate;
            }

            // We first attempt to filter the current type, narrowing constituents as appropriate and removing
            // constituents that are unrelated to the candidate.
            const isRelated = checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf;
            const keyPropertyName = type.flags & TypeFlags.Union ? getKeyPropertyName(type as UnionType) : undefined;
            const narrowedType = mapType(candidate, c => {
                // If a discriminant property is available, use that to reduce the type.
                const discriminant = keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName);
                const matching = discriminant && getConstituentTypeForKeyType(type as UnionType, discriminant);
                // For each constituent t in the current type, if t and and c are directly related, pick the most
                // specific of the two. When t and c are related in both directions, we prefer c for type predicates
                // because that is the asserted type, but t for `instanceof` because generics aren't reflected in
                // prototype object types.
                const directlyRelated = mapType(
                    matching || type,
                    checkDerived ?
                        t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType :
                        t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType,
                );
                // If no constituents are directly related, create intersections for any generic constituents that
                // are related by constraint.
                return directlyRelated.flags & TypeFlags.Never ?
                    mapType(type, t => maybeTypeOfKind(t, TypeFlags.Instantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) :
                    directlyRelated;
            });
            // If filtering produced a non-empty type, return that. Otherwise, pick the most specific of the two
            // based on assignability, or as a last resort produce an intersection.
            return !(narrowedType.flags & TypeFlags.Never) ? narrowedType :
                isTypeSubtypeOf(candidate, type) ? candidate :
                isTypeAssignableTo(type, candidate) ? type :
                isTypeAssignableTo(candidate, type) ? candidate :
                getIntersectionType([type, candidate]);
        }

        function narrowTypeByCallExpression(type: Type, callExpression: CallExpression, assumeTrue: boolean): Type {
            if (hasMatchingArgument(callExpression, reference)) {
                const signature = assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined;
                const predicate = signature && getTypePredicateOfSignature(signature);
                if (predicate && (predicate.kind === TypePredicateKind.This || predicate.kind === TypePredicateKind.Identifier)) {
                    return narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue);
                }
            }
            if (containsMissingType(type) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression)) {
                const callAccess = callExpression.expression;
                if (
                    isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) &&
                    isIdentifier(callAccess.name) && callAccess.name.escapedText === "hasOwnProperty" && callExpression.arguments.length === 1
                ) {
                    const argument = callExpression.arguments[0];
                    if (isStringLiteralLike(argument) && getAccessedPropertyName(reference) === escapeLeadingUnderscores(argument.text)) {
                        return getTypeWithFacts(type, assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined);
                    }
                }
            }
            return type;
        }

        function narrowTypeByTypePredicate(type: Type, predicate: TypePredicate, callExpression: CallExpression, assumeTrue: boolean): Type {
            // Don't narrow from 'any' if the predicate type is exactly 'Object' or 'Function'
            if (predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType))) {
                const predicateArgument = getTypePredicateArgument(predicate, callExpression);
                if (predicateArgument) {
                    if (isMatchingReference(reference, predicateArgument)) {
                        return getNarrowedType(type, predicate.type, assumeTrue, /*checkDerived*/ false);
                    }
                    if (
                        strictNullChecks && optionalChainContainsReference(predicateArgument, reference) &&
                        (
                            assumeTrue && !(hasTypeFacts(predicate.type, TypeFacts.EQUndefined)) ||
                            !assumeTrue && everyType(predicate.type, isNullableType)
                        )
                    ) {
                        type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
                    }
                    const access = getDiscriminantPropertyAccess(predicateArgument, type);
                    if (access) {
                        return narrowTypeByDiscriminant(type, access, t => getNarrowedType(t, predicate.type!, assumeTrue, /*checkDerived*/ false));
                    }
                }
            }
            return type;
        }

        // Narrow the given type based on the given expression having the assumed boolean value. The returned type
        // will be a subtype or the same type as the argument.
        function narrowType(type: Type, expr: Expression, assumeTrue: boolean): Type {
            // for `a?.b`, we emulate a synthetic `a !== null && a !== undefined` condition for `a`
            if (
                isExpressionOfOptionalChainRoot(expr) ||
                isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionToken || expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionEqualsToken) && expr.parent.left === expr
            ) {
                return narrowTypeByOptionality(type, expr, assumeTrue);
            }
            switch (expr.kind) {
                case SyntaxKind.Identifier:
                    // When narrowing a reference to a const variable, non-assigned parameter, or readonly property, we inline
                    // up to five levels of aliased conditional expressions that are themselves declared as const variables.
                    if (!isMatchingReference(reference, expr) && inlineLevel < 5) {
                        const symbol = getResolvedSymbol(expr as Identifier);
                        if (isConstantVariable(symbol)) {
                            const declaration = symbol.valueDeclaration;
                            if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(reference)) {
                                inlineLevel++;
                                const result = narrowType(type, declaration.initializer, assumeTrue);
                                inlineLevel--;
                                return result;
                            }
                        }
                    }
                    // falls through
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.SuperKeyword:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                    return narrowTypeByTruthiness(type, expr, assumeTrue);
                case SyntaxKind.CallExpression:
                    return narrowTypeByCallExpression(type, expr as CallExpression, assumeTrue);
                case SyntaxKind.ParenthesizedExpression:
                case SyntaxKind.NonNullExpression:
                case SyntaxKind.SatisfiesExpression:
                    return narrowType(type, (expr as ParenthesizedExpression | NonNullExpression | SatisfiesExpression).expression, assumeTrue);
                case SyntaxKind.BinaryExpression:
                    return narrowTypeByBinaryExpression(type, expr as BinaryExpression, assumeTrue);
                case SyntaxKind.PrefixUnaryExpression:
                    if ((expr as PrefixUnaryExpression).operator === SyntaxKind.ExclamationToken) {
                        return narrowType(type, (expr as PrefixUnaryExpression).operand, !assumeTrue);
                    }
                    break;
            }
            return type;
        }

        function narrowTypeByOptionality(type: Type, expr: Expression, assumePresent: boolean): Type {
            if (isMatchingReference(reference, expr)) {
                return getAdjustedTypeWithFacts(type, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull);
            }
            const access = getDiscriminantPropertyAccess(expr, type);
            if (access) {
                return narrowTypeByDiscriminant(type, access, t => getTypeWithFacts(t, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull));
            }
            return type;
        }
    }

    function getTypeOfSymbolAtLocation(symbol: Symbol, location: Node) {
        symbol = getExportSymbolOfValueSymbolIfExported(symbol);

        // If we have an identifier or a property access at the given location, if the location is
        // an dotted name expression, and if the location is not an assignment target, obtain the type
        // of the expression (which will reflect control flow analysis). If the expression indeed
        // resolved to the given symbol, return the narrowed type.
        if (location.kind === SyntaxKind.Identifier || location.kind === SyntaxKind.PrivateIdentifier) {
            if (isRightSideOfQualifiedNameOrPropertyAccess(location)) {
                location = location.parent;
            }
            if (isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location))) {
                const type = removeOptionalTypeMarker(
                    isWriteAccess(location) && location.kind === SyntaxKind.PropertyAccessExpression ?
                        checkPropertyAccessExpression(location as PropertyAccessExpression, /*checkMode*/ undefined, /*writeOnly*/ true) :
                        getTypeOfExpression(location as Expression),
                );
                if (getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol) {
                    return type;
                }
            }
        }
        if (isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent)) {
            return getWriteTypeOfAccessors(location.parent.symbol);
        }
        // The location isn't a reference to the given symbol, meaning we're being asked
        // a hypothetical question of what type the symbol would have if there was a reference
        // to it at the given location. Since we have no control flow information for the
        // hypothetical reference (control flow information is created and attached by the
        // binder), we simply return the declared type of the symbol.
        return isRightSideOfAccessExpression(location) && isWriteAccess(location.parent) ? getWriteTypeOfSymbol(symbol) : getNonMissingTypeOfSymbol(symbol);
    }

    function getControlFlowContainer(node: Node): Node {
        return findAncestor(node.parent, node =>
            isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) ||
            node.kind === SyntaxKind.ModuleBlock ||
            node.kind === SyntaxKind.SourceFile ||
            node.kind === SyntaxKind.PropertyDeclaration)!;
    }

    // Check if a parameter, catch variable, or mutable local variable is assigned anywhere definitely
    function isSymbolAssignedDefinitely(symbol: Symbol) {
        if (symbol.lastAssignmentPos !== undefined) {
            return symbol.lastAssignmentPos < 0;
        }
        return isSymbolAssigned(symbol) && symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0;
    }

    // Check if a parameter, catch variable, or mutable local variable is assigned anywhere
    function isSymbolAssigned(symbol: Symbol) {
        return !isPastLastAssignment(symbol, /*location*/ undefined);
    }

    // Return true if there are no assignments to the given symbol or if the given location
    // is past the last assignment to the symbol.
    function isPastLastAssignment(symbol: Symbol, location: Node | undefined) {
        const parent = findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile);
        if (!parent) {
            return false;
        }
        const links = getNodeLinks(parent);
        if (!(links.flags & NodeCheckFlags.AssignmentsMarked)) {
            links.flags |= NodeCheckFlags.AssignmentsMarked;
            if (!hasParentWithAssignmentsMarked(parent)) {
                markNodeAssignments(parent);
            }
        }
        return !symbol.lastAssignmentPos || location && Math.abs(symbol.lastAssignmentPos) < location.pos;
    }

    // Check if a parameter or catch variable (or their bindings elements) is assigned anywhere
    function isSomeSymbolAssigned(rootDeclaration: Node) {
        Debug.assert(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration));
        return isSomeSymbolAssignedWorker(rootDeclaration.name);
    }

    function isSomeSymbolAssignedWorker(node: BindingName): boolean {
        if (node.kind === SyntaxKind.Identifier) {
            return isSymbolAssigned(getSymbolOfDeclaration(node.parent as Declaration));
        }

        return some(node.elements, e => e.kind !== SyntaxKind.OmittedExpression && isSomeSymbolAssignedWorker(e.name));
    }

    function hasParentWithAssignmentsMarked(node: Node) {
        return !!findAncestor(node.parent, node => isFunctionOrSourceFile(node) && !!(getNodeLinks(node).flags & NodeCheckFlags.AssignmentsMarked));
    }

    function isFunctionOrSourceFile(node: Node) {
        return isFunctionLikeDeclaration(node) || isSourceFile(node);
    }

    // For all assignments within the given root node, record the last assignment source position for all
    // referenced parameters and mutable local variables. When assignments occur in nested functions  or
    // references occur in export specifiers, record Number.MAX_VALUE as the assignment position. When
    // assignments occur in compound statements, record the ending source position of the compound statement
    // as the assignment position (this is more conservative than full control flow analysis, but requires
    // only a single walk over the AST).
    function markNodeAssignments(node: Node) {
        switch (node.kind) {
            case SyntaxKind.Identifier:
                const assigmentTarget = getAssignmentTargetKind(node);
                if (assigmentTarget !== AssignmentKind.None) {
                    const symbol = getResolvedSymbol(node as Identifier);
                    const hasDefiniteAssignment = assigmentTarget === AssignmentKind.Definite || (symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0);
                    if (isParameterOrMutableLocalVariable(symbol)) {
                        if (symbol.lastAssignmentPos === undefined || Math.abs(symbol.lastAssignmentPos) !== Number.MAX_VALUE) {
                            const referencingFunction = findAncestor(node, isFunctionOrSourceFile);
                            const declaringFunction = findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile);
                            symbol.lastAssignmentPos = referencingFunction === declaringFunction ? extendAssignmentPosition(node, symbol.valueDeclaration!) : Number.MAX_VALUE;
                        }
                        if (hasDefiniteAssignment && symbol.lastAssignmentPos > 0) {
                            symbol.lastAssignmentPos *= -1;
                        }
                    }
                }
                return;
            case SyntaxKind.ExportSpecifier:
                const exportDeclaration = (node as ExportSpecifier).parent.parent;
                const name = (node as ExportSpecifier).propertyName || (node as ExportSpecifier).name;
                if (!(node as ExportSpecifier).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind !== SyntaxKind.StringLiteral) {
                    const symbol = resolveEntityName(name, SymbolFlags.Value, /*ignoreErrors*/ true, /*dontResolveAlias*/ true);
                    if (symbol && isParameterOrMutableLocalVariable(symbol)) {
                        const sign = symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0 ? -1 : 1;
                        symbol.lastAssignmentPos = sign * Number.MAX_VALUE;
                    }
                }
                return;
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.EnumDeclaration:
                return;
        }
        if (isTypeNode(node)) {
            return;
        }
        forEachChild(node, markNodeAssignments);
    }

    // Extend the position of the given assignment target node to the end of any intervening variable statement,
    // expression statement, compound statement, or class declaration occurring between the node and the given
    // declaration node.
    function extendAssignmentPosition(node: Node, declaration: Declaration) {
        let pos = node.pos;
        while (node && node.pos > declaration.pos) {
            switch (node.kind) {
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ExpressionStatement:
                case SyntaxKind.IfStatement:
                case SyntaxKind.DoStatement:
                case SyntaxKind.WhileStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.ForOfStatement:
                case SyntaxKind.WithStatement:
                case SyntaxKind.SwitchStatement:
                case SyntaxKind.TryStatement:
                case SyntaxKind.ClassDeclaration:
                    pos = node.end;
            }
            node = node.parent;
        }
        return pos;
    }

    function isConstantVariable(symbol: Symbol) {
        return symbol.flags & SymbolFlags.Variable && (getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant) !== 0;
    }

    function isParameterOrMutableLocalVariable(symbol: Symbol) {
        // Return true if symbol is a parameter, a catch clause variable, or a mutable local variable
        const declaration = symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration);
        return !!declaration && (
            isParameter(declaration) ||
            isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration))
        );
    }

    function isMutableLocalVariableDeclaration(declaration: VariableDeclaration) {
        // Return true if symbol is a non-exported and non-global `let` variable
        return !!(declaration.parent.flags & NodeFlags.Let) && !(
            getCombinedModifierFlags(declaration) & ModifierFlags.Export ||
            declaration.parent.parent.kind === SyntaxKind.VariableStatement && isGlobalSourceFile(declaration.parent.parent.parent)
        );
    }

    function parameterInitializerContainsUndefined(declaration: ParameterDeclaration): boolean {
        const links = getNodeLinks(declaration);

        if (links.parameterInitializerContainsUndefined === undefined) {
            if (!pushTypeResolution(declaration, TypeSystemPropertyName.ParameterInitializerContainsUndefined)) {
                reportCircularityError(declaration.symbol);
                return true;
            }

            const containsUndefined = !!(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined));

            if (!popTypeResolution()) {
                reportCircularityError(declaration.symbol);
                return true;
            }

            links.parameterInitializerContainsUndefined ??= containsUndefined;
        }

        return links.parameterInitializerContainsUndefined;
    }

    /** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */
    function removeOptionalityFromDeclaredType(declaredType: Type, declaration: VariableLikeDeclaration): Type {
        const removeUndefined = strictNullChecks &&
            declaration.kind === SyntaxKind.Parameter &&
            declaration.initializer &&
            hasTypeFacts(declaredType, TypeFacts.IsUndefined) &&
            !parameterInitializerContainsUndefined(declaration);

        return removeUndefined ? getTypeWithFacts(declaredType, TypeFacts.NEUndefined) : declaredType;
    }

    function isConstraintPosition(type: Type, node: Node) {
        const parent = node.parent;
        // In an element access obj[x], we consider obj to be in a constraint position, except when obj is of
        // a generic type without a nullable constraint and x is a generic type. This is because when both obj
        // and x are of generic types T and K, we want the resulting type to be T[K].
        return parent.kind === SyntaxKind.PropertyAccessExpression ||
            parent.kind === SyntaxKind.QualifiedName ||
            parent.kind === SyntaxKind.CallExpression && (parent as CallExpression).expression === node ||
            parent.kind === SyntaxKind.NewExpression && (parent as NewExpression).expression === node ||
            parent.kind === SyntaxKind.ElementAccessExpression && (parent as ElementAccessExpression).expression === node &&
                !(someType(type, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent as ElementAccessExpression).argumentExpression)));
    }

    function isGenericTypeWithUnionConstraint(type: Type): boolean {
        return type.flags & TypeFlags.Intersection ?
            some((type as IntersectionType).types, isGenericTypeWithUnionConstraint) :
            !!(type.flags & TypeFlags.Instantiable && getBaseConstraintOrType(type).flags & (TypeFlags.Nullable | TypeFlags.Union));
    }

    function isGenericTypeWithoutNullableConstraint(type: Type): boolean {
        return type.flags & TypeFlags.Intersection ?
            some((type as IntersectionType).types, isGenericTypeWithoutNullableConstraint) :
            !!(type.flags & TypeFlags.Instantiable && !maybeTypeOfKind(getBaseConstraintOrType(type), TypeFlags.Nullable));
    }

    function hasContextualTypeWithNoGenericTypes(node: Node, checkMode: CheckMode | undefined) {
        // Computing the contextual type for a child of a JSX element involves resolving the type of the
        // element's tag name, so we exclude that here to avoid circularities.
        // If check mode has `CheckMode.RestBindingElement`, we skip binding pattern contextual types,
        // as we want the type of a rest element to be generic when possible.
        const contextualType = (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) &&
            !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName === node) &&
            (checkMode && checkMode & CheckMode.RestBindingElement ?
                getContextualType(node, ContextFlags.SkipBindingPatterns)
                : getContextualType(node, /*contextFlags*/ undefined));
        return contextualType && !isGenericType(contextualType);
    }

    function getNarrowableTypeForReference(type: Type, reference: Node, checkMode?: CheckMode) {
        if (isNoInferType(type)) {
            type = (type as SubstitutionType).baseType;
        }
        // When the type of a reference is or contains an instantiable type with a union type constraint, and
        // when the reference is in a constraint position (where it is known we'll obtain the apparent type) or
        // has a contextual type containing no top-level instantiables (meaning constraints will determine
        // assignability), we substitute constraints for all instantiables in the type of the reference to give
        // control flow analysis an opportunity to narrow it further. For example, for a reference of a type
        // parameter type 'T extends string | undefined' with a contextual type 'string', we substitute
        // 'string | undefined' to give control flow analysis the opportunity to narrow to type 'string'.
        const substituteConstraints = !(checkMode && checkMode & CheckMode.Inferential) &&
            someType(type, isGenericTypeWithUnionConstraint) &&
            (isConstraintPosition(type, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode));
        return substituteConstraints ? mapType(type, getBaseConstraintOrType) : type;
    }

    function isExportOrExportExpression(location: Node) {
        return !!findAncestor(location, n => {
            const parent = n.parent;
            if (parent === undefined) {
                return "quit";
            }
            if (isExportAssignment(parent)) {
                return parent.expression === n && isEntityNameExpression(n);
            }
            if (isExportSpecifier(parent)) {
                return parent.name === n || parent.propertyName === n;
            }
            return false;
        });
    }

    /**
     * This function marks all the imports the given location refers to as `.referenced` in `NodeLinks` (transitively through local import aliases).
     * (This corresponds to not getting elided in JS emit.)
     * It can be called on *most* nodes in the AST with `ReferenceHint.Unspecified` and will filter its inputs, but care should be taken to avoid calling it on the RHS of an `import =` or specifiers in a `import {} from "..."`,
     * unless you *really* want to *definitely* mark those as referenced.
     * These shouldn't be directly marked, and should only get marked transitively by the internals of this function.
     *
     * @param location The location to mark js import refernces for
     * @param hint The kind of reference `location` has already been checked to be
     * @param propSymbol The optional symbol of the property we're looking up - this is used for property accesses when `const enum`s do not count as references (no `isolatedModules`, no `preserveConstEnums` + export). It will be calculated if not provided.
     * @param parentType The optional type of the parent of the LHS of the property access - this will be recalculated if not provided (but is costly).
     */
    function markLinkedReferences(location: PropertyAccessExpression | QualifiedName, hint: ReferenceHint.Property, propSymbol: Symbol | undefined, parentType: Type): void;
    function markLinkedReferences(location: Identifier, hint: ReferenceHint.Identifier): void;
    function markLinkedReferences(location: ExportAssignment, hint: ReferenceHint.ExportAssignment): void;
    function markLinkedReferences(location: JsxOpeningLikeElement | JsxOpeningFragment, hint: ReferenceHint.Jsx): void;
    function markLinkedReferences(location: FunctionLikeDeclaration | MethodSignature, hint: ReferenceHint.AsyncFunction): void;
    function markLinkedReferences(location: ImportEqualsDeclaration, hint: ReferenceHint.ExportImportEquals): void;
    function markLinkedReferences(location: ExportSpecifier, hint: ReferenceHint.ExportSpecifier): void;
    function markLinkedReferences(location: HasDecorators, hint: ReferenceHint.Decorator): void;
    function markLinkedReferences(location: Node, hint: ReferenceHint.Unspecified, propSymbol?: Symbol, parentType?: Type): void;
    function markLinkedReferences(location: Node, hint: ReferenceHint, propSymbol?: Symbol, parentType?: Type) {
        if (!canCollectSymbolAliasAccessabilityData) {
            return;
        }
        if (location.flags & NodeFlags.Ambient && !isPropertySignature(location) && !isPropertyDeclaration(location)) {
            // References within types and declaration files are never going to contribute to retaining a JS import,
            // except for properties (which can be decorated).
            return;
        }
        switch (hint) {
            case ReferenceHint.Identifier:
                return markIdentifierAliasReferenced(location as Identifier);
            case ReferenceHint.Property:
                return markPropertyAliasReferenced(location as PropertyAccessExpression | QualifiedName, propSymbol, parentType);
            case ReferenceHint.ExportAssignment:
                return markExportAssignmentAliasReferenced(location as ExportAssignment);
            case ReferenceHint.Jsx:
                return markJsxAliasReferenced(location as JsxOpeningLikeElement | JsxOpeningFragment);
            case ReferenceHint.AsyncFunction:
                return markAsyncFunctionAliasReferenced(location as FunctionLikeDeclaration | MethodSignature);
            case ReferenceHint.ExportImportEquals:
                return markImportEqualsAliasReferenced(location as ImportEqualsDeclaration);
            case ReferenceHint.ExportSpecifier:
                return markExportSpecifierAliasReferenced(location as ExportSpecifier);
            case ReferenceHint.Decorator:
                return markDecoratorAliasReferenced(location as HasDecorators);
            case ReferenceHint.Unspecified: {
                // Identifiers in expression contexts are emitted, so we need to follow their referenced aliases and mark them as used
                // Some non-expression identifiers are also treated as expression identifiers for this purpose, eg, `a` in `b = {a}` or `q` in `import r = q`
                // This is the exception, rather than the rule - most non-expression identifiers are declaration names.
                if (isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference === location)) && shouldMarkIdentifierAliasReferenced(location)) {
                    if (isPropertyAccessOrQualifiedName(location.parent)) {
                        const left = isPropertyAccessExpression(location.parent) ? location.parent.expression : location.parent.left;
                        if (left !== location) return; // Only mark the LHS (the RHS is a property lookup)
                    }
                    markIdentifierAliasReferenced(location);
                    return;
                }
                if (isPropertyAccessOrQualifiedName(location)) {
                    let topProp: Node | undefined = location;
                    while (isPropertyAccessOrQualifiedName(topProp)) {
                        if (isPartOfTypeNode(topProp)) return;
                        topProp = topProp.parent;
                    }
                    return markPropertyAliasReferenced(location);
                }
                if (isExportAssignment(location)) {
                    return markExportAssignmentAliasReferenced(location);
                }
                if (isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location)) {
                    return markJsxAliasReferenced(location);
                }
                if (isImportEqualsDeclaration(location)) {
                    if (isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location)) {
                        return markImportEqualsAliasReferenced(location);
                    }
                    return;
                }
                if (isExportSpecifier(location)) {
                    return markExportSpecifierAliasReferenced(location);
                }
                if (isFunctionLikeDeclaration(location) || isMethodSignature(location)) {
                    markAsyncFunctionAliasReferenced(location);
                    // Might be decorated, fall through to decorator final case
                }
                if (!compilerOptions.emitDecoratorMetadata) {
                    return;
                }
                if (!canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(legacyDecorators, location, location.parent, location.parent.parent)) {
                    return;
                }

                return markDecoratorAliasReferenced(location);
            }
            default:
                Debug.assertNever(hint, `Unhandled reference hint: ${hint}`);
        }
    }

    function markIdentifierAliasReferenced(location: Identifier) {
        const symbol = getResolvedSymbol(location);
        if (symbol && symbol !== argumentsSymbol && symbol !== unknownSymbol && !isThisInTypeQuery(location)) {
            markAliasReferenced(symbol, location);
        }
    }

    function markPropertyAliasReferenced(location: PropertyAccessExpression | QualifiedName, propSymbol?: Symbol, parentType?: Type) {
        const left = isPropertyAccessExpression(location) ? location.expression : location.left;
        if (isThisIdentifier(left) || !isIdentifier(left)) {
            return;
        }
        const parentSymbol = getResolvedSymbol(left);
        if (!parentSymbol || parentSymbol === unknownSymbol) {
            return;
        }
        // In `Foo.Bar.Baz`, 'Foo' is not referenced if 'Bar' is a const enum or a module containing only const enums.
        // `Foo` is also not referenced in `enum FooCopy { Bar = Foo.Bar }`, because the enum member value gets inlined
        // here even if `Foo` is not a const enum.
        //
        // The exceptions are:
        //   1. if 'isolatedModules' is enabled, because the const enum value will not be inlined, and
        //   2. if 'preserveConstEnums' is enabled and the expression is itself an export, e.g. `export = Foo.Bar.Baz`.
        //
        // The property lookup is deferred as much as possible, in as many situations as possible, to avoid alias marking
        // pulling on types/symbols it doesn't strictly need to.
        if (getIsolatedModules(compilerOptions) || (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location))) {
            markAliasReferenced(parentSymbol, location);
            return;
        }
        // Hereafter, this relies on type checking - but every check prior to this only used symbol information
        const leftType = parentType || checkExpressionCached(left);
        if (isTypeAny(leftType) || leftType === silentNeverType) {
            markAliasReferenced(parentSymbol, location);
            return;
        }
        let prop = propSymbol;
        if (!prop && !parentType) {
            const right = isPropertyAccessExpression(location) ? location.name : location.right;
            const lexicallyScopedSymbol = isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right);
            const assignmentKind = getAssignmentTargetKind(location);
            const apparentType = getApparentType(assignmentKind !== AssignmentKind.None || isMethodAccessForCall(location) ? getWidenedType(leftType) : leftType);
            prop = isPrivateIdentifier(right) ? lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || undefined : getPropertyOfType(apparentType, right.escapedText);
        }
        if (
            !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags & SymbolFlags.EnumMember && location.parent.kind === SyntaxKind.EnumMember))
        ) {
            markAliasReferenced(parentSymbol, location);
        }
        return;
    }

    function markExportAssignmentAliasReferenced(location: ExportAssignment) {
        if (isIdentifier(location.expression)) {
            const id = location.expression;
            const sym = getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlags.All, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, location));
            if (sym) {
                markAliasReferenced(sym, id);
            }
        }
    }

    function markJsxAliasReferenced(node: JsxOpeningLikeElement | JsxOpeningFragment) {
        if (!getJsxNamespaceContainerForImplicitImport(node)) {
            // The reactNamespace/jsxFactory's root symbol should be marked as 'used' so we don't incorrectly elide its import.
            // And if there is no reactNamespace/jsxFactory's symbol in scope when targeting React emit, we should issue an error.
            const jsxFactoryRefErr = diagnostics && compilerOptions.jsx === JsxEmit.React ? Diagnostics.This_JSX_tag_requires_0_to_be_in_scope_but_it_could_not_be_found : undefined;
            const jsxFactoryNamespace = getJsxNamespace(node);
            const jsxFactoryLocation = isJsxOpeningLikeElement(node) ? node.tagName : node;
            const shouldFactoryRefErr = compilerOptions.jsx !== JsxEmit.Preserve && compilerOptions.jsx !== JsxEmit.ReactNative;

            // #38720/60122, allow null as jsxFragmentFactory
            let jsxFactorySym: Symbol | undefined;
            if (!(isJsxOpeningFragment(node) && jsxFactoryNamespace === "null")) {
                jsxFactorySym = resolveName(
                    jsxFactoryLocation,
                    jsxFactoryNamespace,
                    shouldFactoryRefErr ? SymbolFlags.Value : SymbolFlags.Value & ~SymbolFlags.Enum,
                    jsxFactoryRefErr,
                    /*isUse*/ true,
                );
            }

            if (jsxFactorySym) {
                // Mark local symbol as referenced here because it might not have been marked
                // if jsx emit was not jsxFactory as there wont be error being emitted
                jsxFactorySym.isReferenced = SymbolFlags.All;

                // If react/jsxFactory symbol is alias, mark it as refereced
                if (canCollectSymbolAliasAccessabilityData && jsxFactorySym.flags & SymbolFlags.Alias && !getTypeOnlyAliasDeclaration(jsxFactorySym)) {
                    markAliasSymbolAsReferenced(jsxFactorySym);
                }
            }

            // if JsxFragment, additionally mark jsx pragma as referenced, since `getJsxNamespace` above would have resolved to only the fragment factory if they are distinct
            if (isJsxOpeningFragment(node)) {
                const file = getSourceFileOfNode(node);
                const entity = getJsxFactoryEntity(file);
                if (entity) {
                    const localJsxNamespace = getFirstIdentifier(entity).escapedText;
                    resolveName(
                        jsxFactoryLocation,
                        localJsxNamespace,
                        shouldFactoryRefErr ? SymbolFlags.Value : SymbolFlags.Value & ~SymbolFlags.Enum,
                        jsxFactoryRefErr,
                        /*isUse*/ true,
                    );
                }
            }
        }
        return;
    }

    function markAsyncFunctionAliasReferenced(location: FunctionLikeDeclaration | MethodSignature) {
        if (languageVersion < ScriptTarget.ES2015) {
            if (getFunctionFlags(location) & FunctionFlags.Async) {
                const returnTypeNode = getEffectiveReturnTypeNode(location);
                markTypeNodeAsReferenced(returnTypeNode);
            }
        }
    }

    function markImportEqualsAliasReferenced(location: ImportEqualsDeclaration) {
        if (hasSyntacticModifier(location, ModifierFlags.Export)) {
            markExportAsReferenced(location);
        }
    }

    function markExportSpecifierAliasReferenced(location: ExportSpecifier) {
        if (!location.parent.parent.moduleSpecifier && !location.isTypeOnly && !location.parent.parent.isTypeOnly) {
            const exportedName = location.propertyName || location.name;
            if (exportedName.kind === SyntaxKind.StringLiteral) {
                return; // Skip for invalid syntax like this: export { "x" }
            }
            const symbol = resolveName(exportedName, exportedName.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
            if (symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0])))) {
                // Do nothing, non-local symbol
            }
            else {
                const target = symbol && (symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol);
                if (!target || getSymbolFlags(target) & SymbolFlags.Value) {
                    markExportAsReferenced(location); // marks export as used
                    markIdentifierAliasReferenced(exportedName); // marks target of export as used
                }
            }
            return;
        }
    }

    function markDecoratorAliasReferenced(node: HasDecorators) {
        if (compilerOptions.emitDecoratorMetadata) {
            const firstDecorator = find(node.modifiers, isDecorator);
            if (!firstDecorator) {
                return;
            }

            checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Metadata);

            // we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.
            switch (node.kind) {
                case SyntaxKind.ClassDeclaration:
                    const constructor = getFirstConstructorWithBody(node);
                    if (constructor) {
                        for (const parameter of constructor.parameters) {
                            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                        }
                    }
                    break;

                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    const otherKind = node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;
                    const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(node), otherKind);
                    markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor));
                    break;
                case SyntaxKind.MethodDeclaration:
                    for (const parameter of node.parameters) {
                        markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                    }

                    markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node));
                    break;

                case SyntaxKind.PropertyDeclaration:
                    markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node));
                    break;

                case SyntaxKind.Parameter:
                    markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));
                    const containingSignature = node.parent;
                    for (const parameter of containingSignature.parameters) {
                        markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                    }
                    markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature));
                    break;
            }
        }
    }

    function markAliasReferenced(symbol: Symbol, location: Node) {
        if (!canCollectSymbolAliasAccessabilityData) {
            return;
        }
        if (isNonLocalAlias(symbol, /*excludes*/ SymbolFlags.Value) && !isInTypeQuery(location)) {
            const target = resolveAlias(symbol);
            if (getSymbolFlags(symbol, /*excludeTypeOnlyMeanings*/ true) & (SymbolFlags.Value | SymbolFlags.ExportValue)) {
                // An alias resolving to a const enum cannot be elided if (1) 'isolatedModules' is enabled
                // (because the const enum value will not be inlined), or if (2) the alias is an export
                // of a const enum declaration that will be preserved.
                if (
                    getIsolatedModules(compilerOptions) ||
                    shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) ||
                    !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target))
                ) {
                    markAliasSymbolAsReferenced(symbol);
                }
            }
        }
    }

    // When an alias symbol is referenced, we need to mark the entity it references as referenced and in turn repeat that until
    // we reach a non-alias or an exported entity (which is always considered referenced). We do this by checking the target of
    // the alias as an expression (which recursively takes us back here if the target references another alias).
    function markAliasSymbolAsReferenced(symbol: Symbol) {
        Debug.assert(canCollectSymbolAliasAccessabilityData);
        const links = getSymbolLinks(symbol);
        if (!links.referenced) {
            links.referenced = true;
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            // We defer checking of the reference of an `import =` until the import itself is referenced,
            // This way a chain of imports can be elided if ultimately the final input is only used in a type
            // position.
            if (isInternalModuleImportEqualsDeclaration(node)) {
                if (getSymbolFlags(resolveSymbol(symbol)) & SymbolFlags.Value) {
                    // import foo = <symbol>
                    const left = getFirstIdentifier(node.moduleReference as EntityNameExpression);
                    markIdentifierAliasReferenced(left);
                }
            }
        }
    }

    function markExportAsReferenced(node: ImportEqualsDeclaration | ExportSpecifier) {
        const symbol = getSymbolOfDeclaration(node);
        const target = resolveAlias(symbol);
        if (target) {
            const markAlias = target === unknownSymbol ||
                ((getSymbolFlags(symbol, /*excludeTypeOnlyMeanings*/ true) & SymbolFlags.Value) && !isConstEnumOrConstEnumOnlyModule(target));

            if (markAlias) {
                markAliasSymbolAsReferenced(symbol);
            }
        }
    }

    function markEntityNameOrEntityExpressionAsReference(typeName: EntityNameOrEntityNameExpression | undefined, forDecoratorMetadata: boolean) {
        if (!typeName) return;

        const rootName = getFirstIdentifier(typeName);
        const meaning = (typeName.kind === SyntaxKind.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace) | SymbolFlags.Alias;
        const rootSymbol = resolveName(rootName, rootName.escapedText, meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
        if (rootSymbol && rootSymbol.flags & SymbolFlags.Alias) {
            if (
                canCollectSymbolAliasAccessabilityData
                && symbolIsValue(rootSymbol)
                && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol))
                && !getTypeOnlyAliasDeclaration(rootSymbol)
            ) {
                markAliasSymbolAsReferenced(rootSymbol);
            }
            else if (
                forDecoratorMetadata
                && getIsolatedModules(compilerOptions)
                && getEmitModuleKind(compilerOptions) >= ModuleKind.ES2015
                && !symbolIsValue(rootSymbol)
                && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration)
            ) {
                const diag = error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled);
                const aliasDeclaration = find(rootSymbol.declarations || emptyArray, isAliasSymbolDeclaration);
                if (aliasDeclaration) {
                    addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)));
                }
            }
        }
    }

    /**
     * If a TypeNode can be resolved to a value symbol imported from an external module, it is
     * marked as referenced to prevent import elision.
     */
    function markTypeNodeAsReferenced(node: TypeNode | undefined) {
        markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node), /*forDecoratorMetadata*/ false);
    }

    /**
     * This function marks the type used for metadata decorator as referenced if it is import
     * from external module.
     * This is different from markTypeNodeAsReferenced because it tries to simplify type nodes in
     * union and intersection type
     * @param node
     */
    function markDecoratorMedataDataTypeNodeAsReferenced(node: TypeNode | undefined): void {
        const entityName = getEntityNameForDecoratorMetadata(node);
        if (entityName && isEntityName(entityName)) {
            markEntityNameOrEntityExpressionAsReference(entityName, /*forDecoratorMetadata*/ true);
        }
    }

    function getNarrowedTypeOfSymbol(symbol: Symbol, location: Identifier) {
        const type = getTypeOfSymbol(symbol);
        const declaration = symbol.valueDeclaration;
        if (declaration) {
            // If we have a non-rest binding element with no initializer declared as a const variable or a const-like
            // parameter (a parameter for which there are no assignments in the function body), and if the parent type
            // for the destructuring is a union type, one or more of the binding elements may represent discriminant
            // properties, and we want the effects of conditional checks on such discriminants to affect the types of
            // other binding elements from the same destructuring. Consider:
            //
            //   type Action =
            //       | { kind: 'A', payload: number }
            //       | { kind: 'B', payload: string };
            //
            //   function f({ kind, payload }: Action) {
            //       if (kind === 'A') {
            //           payload.toFixed();
            //       }
            //       if (kind === 'B') {
            //           payload.toUpperCase();
            //       }
            //   }
            //
            // Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
            // the binding pattern AST instance for '{ kind, payload }' as a pseudo-reference and narrow this reference
            // as if it occurred in the specified location. We then recompute the narrowed binding element type by
            // destructuring from the narrowed parent type.
            if (isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2) {
                const parent = declaration.parent.parent;
                const rootDeclaration = getRootDeclaration(parent);
                if (rootDeclaration.kind === SyntaxKind.VariableDeclaration && getCombinedNodeFlagsCached(rootDeclaration) & NodeFlags.Constant || rootDeclaration.kind === SyntaxKind.Parameter) {
                    const links = getNodeLinks(parent);
                    if (!(links.flags & NodeCheckFlags.InCheckIdentifier)) {
                        links.flags |= NodeCheckFlags.InCheckIdentifier;
                        const parentType = getTypeForBindingElementParent(parent, CheckMode.Normal);
                        const parentTypeConstraint = parentType && mapType(parentType, getBaseConstraintOrType);
                        links.flags &= ~NodeCheckFlags.InCheckIdentifier;
                        if (parentTypeConstraint && parentTypeConstraint.flags & TypeFlags.Union && !(rootDeclaration.kind === SyntaxKind.Parameter && isSomeSymbolAssigned(rootDeclaration))) {
                            const pattern = declaration.parent;
                            const narrowedType = getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, /*flowContainer*/ undefined, location.flowNode);
                            if (narrowedType.flags & TypeFlags.Never) {
                                return neverType;
                            }
                            // Destructurings are validated against the parent type elsewhere. Here we disable tuple bounds
                            // checks because the narrowed type may have lower arity than the full parent type. For example,
                            // for the declaration [x, y]: [1, 2] | [3], we may have narrowed the parent type to just [3].
                            return getBindingElementTypeFromParentType(declaration, narrowedType, /*noTupleBoundsCheck*/ true);
                        }
                    }
                }
            }
            // If we have a const-like parameter with no type annotation or initializer, and if the parameter is contextually
            // typed by a signature with a single rest parameter of a union of tuple types, one or more of the parameters may
            // represent discriminant tuple elements, and we want the effects of conditional checks on such discriminants to
            // affect the types of other parameters in the same parameter list. Consider:
            //
            //   type Action = [kind: 'A', payload: number] | [kind: 'B', payload: string];
            //
            //   const f: (...args: Action) => void = (kind, payload) => {
            //       if (kind === 'A') {
            //           payload.toFixed();
            //       }
            //       if (kind === 'B') {
            //           payload.toUpperCase();
            //       }
            //   }
            //
            // Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
            // the arrow function AST node for '(kind, payload) => ...' as a pseudo-reference and narrow this reference as
            // if it occurred in the specified location. We then recompute the narrowed parameter type by indexing into the
            // narrowed tuple type.
            if (isParameter(declaration) && !declaration.type && !declaration.initializer && !declaration.dotDotDotToken) {
                const func = declaration.parent;
                if (func.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                    const contextualSignature = getContextualSignature(func);
                    if (contextualSignature && contextualSignature.parameters.length === 1 && signatureHasRestParameter(contextualSignature)) {
                        const restType = getReducedApparentType(instantiateType(getTypeOfSymbol(contextualSignature.parameters[0]), getInferenceContext(func)?.nonFixingMapper));
                        if (restType.flags & TypeFlags.Union && everyType(restType, isTupleType) && !some(func.parameters, isSomeSymbolAssigned)) {
                            const narrowedType = getFlowTypeOfReference(func, restType, restType, /*flowContainer*/ undefined, location.flowNode);
                            const index = func.parameters.indexOf(declaration) - (getThisParameter(func) ? 1 : 0);
                            return getIndexedAccessType(narrowedType, getNumberLiteralType(index));
                        }
                    }
                }
            }
        }
        return type;
    }

    /**
     * This part of `checkIdentifier` is kept seperate from the rest, so `NodeCheckFlags` (and related diagnostics) can be lazily calculated
     * without calculating the flow type of the identifier.
     */
    function checkIdentifierCalculateNodeCheckFlags(node: Identifier, symbol: Symbol) {
        if (isThisInTypeQuery(node)) return;

        // As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
        // Although in down-level emit of arrow function, we emit it using function expression which means that
        // arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
        // will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
        // To avoid that we will give an error to users if they use arguments objects in arrow function so that they
        // can explicitly bound arguments objects
        if (symbol === argumentsSymbol) {
            if (isInPropertyInitializerOrClassStaticBlock(node, /*ignoreArrowFunctions*/ true)) {
                error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers_or_class_static_initialization_blocks);
                return;
            }

            let container = getContainingFunction(node);
            if (container) {
                if (languageVersion < ScriptTarget.ES2015) {
                    if (container.kind === SyntaxKind.ArrowFunction) {
                        error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression);
                    }
                    else if (hasSyntacticModifier(container, ModifierFlags.Async)) {
                        error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method);
                    }
                }

                getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments;
                while (container && isArrowFunction(container)) {
                    container = getContainingFunction(container);
                    if (container) {
                        getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments;
                    }
                }
            }
            return;
        }

        const localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
        const targetSymbol = resolveAliasWithDeprecationCheck(localOrExportSymbol, node);
        if (isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations) {
            addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText as string);
        }

        const declaration = localOrExportSymbol.valueDeclaration;
        if (declaration && localOrExportSymbol.flags & SymbolFlags.Class) {
            // When we downlevel classes we may emit some code outside of the class body. Due to the fact the
            // class name is double-bound, we must ensure we mark references to the class name so that we can
            // emit an alias to the class later.
            if (isClassLike(declaration) && declaration.name !== node) {
                let container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
                while (container.kind !== SyntaxKind.SourceFile && container.parent !== declaration) {
                    container = getThisContainer(container, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
                }

                if (container.kind !== SyntaxKind.SourceFile) {
                    getNodeLinks(declaration).flags |= NodeCheckFlags.ContainsConstructorReference;
                    getNodeLinks(container).flags |= NodeCheckFlags.ContainsConstructorReference;
                    getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReference;
                }
            }
        }

        checkNestedBlockScopedBinding(node, symbol);
    }

    function checkIdentifier(node: Identifier, checkMode: CheckMode | undefined): Type {
        if (isThisInTypeQuery(node)) {
            return checkThisExpression(node);
        }

        const symbol = getResolvedSymbol(node);
        if (symbol === unknownSymbol) {
            return errorType;
        }

        checkIdentifierCalculateNodeCheckFlags(node, symbol);

        if (symbol === argumentsSymbol) {
            if (isInPropertyInitializerOrClassStaticBlock(node)) {
                return errorType;
            }
            return getTypeOfSymbol(symbol);
        }

        if (shouldMarkIdentifierAliasReferenced(node)) {
            markLinkedReferences(node, ReferenceHint.Identifier);
        }

        const localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
        let declaration = localOrExportSymbol.valueDeclaration;
        const immediateDeclaration = declaration;

        // If the identifier is declared in a binding pattern for which we're currently computing the implied type and the
        // reference occurs with the same binding pattern, return the non-inferrable any type. This for example occurs in
        // 'const [a, b = a + 1] = [2]' when we're computing the contextual type for the array literal '[2]'.
        if (declaration && declaration.kind === SyntaxKind.BindingElement && contains(contextualBindingPatterns, declaration.parent) && findAncestor(node, parent => parent === declaration!.parent)) {
            return nonInferrableAnyType;
        }

        let type = getNarrowedTypeOfSymbol(localOrExportSymbol, node);
        const assignmentKind = getAssignmentTargetKind(node);

        if (assignmentKind) {
            if (
                !(localOrExportSymbol.flags & SymbolFlags.Variable) &&
                !(isInJSFile(node) && localOrExportSymbol.flags & SymbolFlags.ValueModule)
            ) {
                const assignmentError = localOrExportSymbol.flags & SymbolFlags.Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum
                    : localOrExportSymbol.flags & SymbolFlags.Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class
                    : localOrExportSymbol.flags & SymbolFlags.Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace
                    : localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function
                    : localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import
                    : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable;

                error(node, assignmentError, symbolToString(symbol));
                return errorType;
            }
            if (isReadonlySymbol(localOrExportSymbol)) {
                if (localOrExportSymbol.flags & SymbolFlags.Variable) {
                    error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol));
                }
                else {
                    error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol));
                }
                return errorType;
            }
        }

        const isAlias = localOrExportSymbol.flags & SymbolFlags.Alias;

        // We only narrow variables and parameters occurring in a non-assignment position. For all other
        // entities we simply return the declared type.
        if (localOrExportSymbol.flags & SymbolFlags.Variable) {
            if (assignmentKind === AssignmentKind.Definite) {
                return isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(type) : type;
            }
        }
        else if (isAlias) {
            declaration = getDeclarationOfAliasSymbol(symbol);
        }
        else {
            return type;
        }

        if (!declaration) {
            return type;
        }

        type = getNarrowableTypeForReference(type, node, checkMode);

        // The declaration container is the innermost function that encloses the declaration of the variable
        // or parameter. The flow container is the innermost function starting with which we analyze the control
        // flow graph to determine the control flow based type.
        const isParameter = getRootDeclaration(declaration).kind === SyntaxKind.Parameter;
        const declarationContainer = getControlFlowContainer(declaration);
        let flowContainer = getControlFlowContainer(node);
        const isOuterVariable = flowContainer !== declarationContainer;
        const isSpreadDestructuringAssignmentTarget = node.parent && node.parent.parent && isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent);
        const isModuleExports = symbol.flags & SymbolFlags.ModuleExports;
        const typeIsAutomatic = type === autoType || type === autoArrayType;
        const isAutomaticTypeInNonNull = typeIsAutomatic && node.parent.kind === SyntaxKind.NonNullExpression;
        // When the control flow originates in a function expression, arrow function, method, or accessor, and
        // we are referencing a closed-over const variable or parameter or mutable local variable past its last
        // assignment, we extend the origin of the control flow analysis to include the immediately enclosing
        // control flow container.
        while (
            flowContainer !== declarationContainer && (
                flowContainer.kind === SyntaxKind.FunctionExpression ||
                flowContainer.kind === SyntaxKind.ArrowFunction ||
                isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)
            ) && (
                isConstantVariable(localOrExportSymbol) && type !== autoArrayType ||
                isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)
            )
        ) {
            flowContainer = getControlFlowContainer(flowContainer);
        }
        // We only look for uninitialized variables in strict null checking mode, and only when we can analyze
        // the entire control flow graph from the variable's declaration (i.e. when the flow container and
        // declaration container are the same).
        const isNeverInitialized = immediateDeclaration && isVariableDeclaration(immediateDeclaration) && !immediateDeclaration.initializer && !immediateDeclaration.exclamationToken && isMutableLocalVariableDeclaration(immediateDeclaration) && !isSymbolAssignedDefinitely(symbol);
        const assumeInitialized = isParameter || isAlias ||
            (isOuterVariable && !isNeverInitialized) ||
            isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) ||
            type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void)) !== 0 ||
                    isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind === SyntaxKind.ExportSpecifier) ||
            node.parent.kind === SyntaxKind.NonNullExpression ||
            declaration.kind === SyntaxKind.VariableDeclaration && (declaration as VariableDeclaration).exclamationToken ||
            declaration.flags & NodeFlags.Ambient;
        const initialType = isAutomaticTypeInNonNull ? undefinedType :
            assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration) : type) :
            typeIsAutomatic ? undefinedType : getOptionalType(type);
        const flowType = isAutomaticTypeInNonNull ? getNonNullableType(getFlowTypeOfReference(node, type, initialType, flowContainer)) :
            getFlowTypeOfReference(node, type, initialType, flowContainer);
        // A variable is considered uninitialized when it is possible to analyze the entire control flow graph
        // from declaration to use, and when the variable's declared type doesn't include undefined but the
        // control flow based type does include undefined.
        if (!isEvolvingArrayOperationTarget(node) && (type === autoType || type === autoArrayType)) {
            if (flowType === autoType || flowType === autoArrayType) {
                if (noImplicitAny) {
                    error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType));
                    error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                }
                return convertAutoToAny(flowType);
            }
        }
        else if (!assumeInitialized && !containsUndefinedType(type) && containsUndefinedType(flowType)) {
            error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol));
            // Return the declared type to reduce follow-on errors
            return type;
        }
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }

    function isSameScopedBindingElement(node: Identifier, declaration: Declaration) {
        if (isBindingElement(declaration)) {
            const bindingElement = findAncestor(node, isBindingElement);
            return bindingElement && getRootDeclaration(bindingElement) === getRootDeclaration(declaration);
        }
    }

    function shouldMarkIdentifierAliasReferenced(node: Identifier): boolean {
        const parent = node.parent;
        if (parent) {
            // A property access expression LHS? checkPropertyAccessExpression will handle that.
            if (isPropertyAccessExpression(parent) && parent.expression === node) {
                return false;
            }
            // Next two check for an identifier inside a type only export.
            if (isExportSpecifier(parent) && parent.isTypeOnly) {
                return false;
            }
            const greatGrandparent = parent.parent?.parent;
            if (greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly) {
                return false;
            }
        }
        return true;
    }

    function isInsideFunctionOrInstancePropertyInitializer(node: Node, threshold: Node): boolean {
        return !!findAncestor(node, n =>
            n === threshold ? "quit" : isFunctionLike(n) || (
                n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer === n
            ));
    }

    function getPartOfForStatementContainingNode(node: Node, container: ForStatement) {
        return findAncestor(node, n => n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement);
    }

    function getEnclosingIterationStatement(node: Node): Node | undefined {
        return findAncestor(node, n => (!n || nodeStartsNewLexicalEnvironment(n)) ? "quit" : isIterationStatement(n, /*lookInLabeledStatements*/ false));
    }

    function checkNestedBlockScopedBinding(node: Identifier, symbol: Symbol): void {
        if (
            languageVersion >= ScriptTarget.ES2015 ||
            (symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.Class)) === 0 ||
            !symbol.valueDeclaration ||
            isSourceFile(symbol.valueDeclaration) ||
            symbol.valueDeclaration.parent.kind === SyntaxKind.CatchClause
        ) {
            return;
        }

        // 1. walk from the use site up to the declaration and check
        // if there is anything function like between declaration and use-site (is binding/class is captured in function).
        // 2. walk from the declaration up to the boundary of lexical environment and check
        // if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)

        const container = getEnclosingBlockScopeContainer(symbol.valueDeclaration);
        const isCaptured = isInsideFunctionOrInstancePropertyInitializer(node, container);

        const enclosingIterationStatement = getEnclosingIterationStatement(container);
        if (enclosingIterationStatement) {
            if (isCaptured) {
                // mark iteration statement as containing block-scoped binding captured in some function
                let capturesBlockScopeBindingInLoopBody = true;
                if (isForStatement(container)) {
                    const varDeclList = getAncestor(symbol.valueDeclaration, SyntaxKind.VariableDeclarationList);
                    if (varDeclList && varDeclList.parent === container) {
                        const part = getPartOfForStatementContainingNode(node.parent, container);
                        if (part) {
                            const links = getNodeLinks(part);
                            links.flags |= NodeCheckFlags.ContainsCapturedBlockScopeBinding;

                            const capturedBindings = links.capturedBlockScopeBindings || (links.capturedBlockScopeBindings = []);
                            pushIfUnique(capturedBindings, symbol);

                            if (part === container.initializer) {
                                capturesBlockScopeBindingInLoopBody = false; // Initializer is outside of loop body
                            }
                        }
                    }
                }
                if (capturesBlockScopeBindingInLoopBody) {
                    getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
                }
            }

            // mark variables that are declared in loop initializer and reassigned inside the body of ForStatement.
            // if body of ForStatement will be converted to function then we'll need a extra machinery to propagate reassigned values back.
            if (isForStatement(container)) {
                const varDeclList = getAncestor(symbol.valueDeclaration, SyntaxKind.VariableDeclarationList);
                if (varDeclList && varDeclList.parent === container && isAssignedInBodyOfForStatement(node, container)) {
                    getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.NeedsLoopOutParameter;
                }
            }

            // set 'declared inside loop' bit on the block-scoped binding
            getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
        }

        if (isCaptured) {
            getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.CapturedBlockScopedBinding;
        }
    }

    function isBindingCapturedByNode(node: Node, decl: VariableDeclaration | BindingElement) {
        const links = getNodeLinks(node);
        return !!links && contains(links.capturedBlockScopeBindings, getSymbolOfDeclaration(decl));
    }

    function isAssignedInBodyOfForStatement(node: Identifier, container: ForStatement): boolean {
        // skip parenthesized nodes
        let current: Node = node;
        while (current.parent.kind === SyntaxKind.ParenthesizedExpression) {
            current = current.parent;
        }

        // check if node is used as LHS in some assignment expression
        let isAssigned = false;
        if (isAssignmentTarget(current)) {
            isAssigned = true;
        }
        else if ((current.parent.kind === SyntaxKind.PrefixUnaryExpression || current.parent.kind === SyntaxKind.PostfixUnaryExpression)) {
            const expr = current.parent as PrefixUnaryExpression | PostfixUnaryExpression;
            isAssigned = expr.operator === SyntaxKind.PlusPlusToken || expr.operator === SyntaxKind.MinusMinusToken;
        }

        if (!isAssigned) {
            return false;
        }

        // at this point we know that node is the target of assignment
        // now check that modification happens inside the statement part of the ForStatement
        return !!findAncestor(current, n => n === container ? "quit" : n === container.statement);
    }

    function captureLexicalThis(node: Node, container: Node): void {
        getNodeLinks(node).flags |= NodeCheckFlags.LexicalThis;
        if (container.kind === SyntaxKind.PropertyDeclaration || container.kind === SyntaxKind.Constructor) {
            const classNode = container.parent;
            getNodeLinks(classNode).flags |= NodeCheckFlags.CaptureThis;
        }
        else {
            getNodeLinks(container).flags |= NodeCheckFlags.CaptureThis;
        }
    }

    function findFirstSuperCall(node: Node): SuperCall | undefined {
        return isSuperCall(node) ? node :
            isFunctionLike(node) ? undefined :
            forEachChild(node, findFirstSuperCall);
    }

    /**
     * Check if the given class-declaration extends null then return true.
     * Otherwise, return false
     * @param classDecl a class declaration to check if it extends null
     */
    function classDeclarationExtendsNull(classDecl: ClassLikeDeclaration): boolean {
        const classSymbol = getSymbolOfDeclaration(classDecl);
        const classInstanceType = getDeclaredTypeOfSymbol(classSymbol) as InterfaceType;
        const baseConstructorType = getBaseConstructorTypeOfClass(classInstanceType);

        return baseConstructorType === nullWideningType;
    }

    function checkThisBeforeSuper(node: Node, container: Node, diagnosticMessage: DiagnosticMessage) {
        const containingClassDecl = container.parent as ClassDeclaration;
        const baseTypeNode = getClassExtendsHeritageElement(containingClassDecl);

        // If a containing class does not have extends clause or the class extends null
        // skip checking whether super statement is called before "this" accessing.
        if (baseTypeNode && !classDeclarationExtendsNull(containingClassDecl)) {
            if (canHaveFlowNode(node) && node.flowNode && !isPostSuperFlowNode(node.flowNode, /*noCacheCheck*/ false)) {
                error(node, diagnosticMessage);
            }
        }
    }

    function checkThisInStaticClassFieldInitializerInDecoratedClass(thisExpression: Node, container: Node) {
        if (
            isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators &&
            container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent)
        ) {
            error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class);
        }
    }

    function checkThisExpression(node: Node): Type {
        const isNodeInTypeQuery = isInTypeQuery(node);
        // Stop at the first arrow function so that we can
        // tell whether 'this' needs to be captured.
        let container = getThisContainer(node, /*includeArrowFunctions*/ true, /*includeClassComputedPropertyName*/ true);
        let capturedByArrowFunction = false;
        let thisInComputedPropertyName = false;

        if (container.kind === SyntaxKind.Constructor) {
            checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class);
        }

        while (true) {
            // Now skip arrow functions to get the "real" owner of 'this'.
            if (container.kind === SyntaxKind.ArrowFunction) {
                container = getThisContainer(container, /*includeArrowFunctions*/ false, !thisInComputedPropertyName);
                capturedByArrowFunction = true;
            }

            if (container.kind === SyntaxKind.ComputedPropertyName) {
                container = getThisContainer(container, !capturedByArrowFunction, /*includeClassComputedPropertyName*/ false);
                thisInComputedPropertyName = true;
                continue;
            }

            break;
        }

        checkThisInStaticClassFieldInitializerInDecoratedClass(node, container);
        if (thisInComputedPropertyName) {
            error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name);
        }
        else {
            switch (container.kind) {
                case SyntaxKind.ModuleDeclaration:
                    error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);
                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    break;
                case SyntaxKind.EnumDeclaration:
                    error(node, Diagnostics.this_cannot_be_referenced_in_current_location);
                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    break;
            }
        }

        // When targeting es6, mark that we'll need to capture `this` in its lexically bound scope.
        if (!isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTarget.ES2015) {
            captureLexicalThis(node, container);
        }

        const type = tryGetThisTypeAt(node, /*includeGlobalThis*/ true, container);
        if (noImplicitThis) {
            const globalThisType = getTypeOfSymbol(globalThisSymbol);
            if (type === globalThisType && capturedByArrowFunction) {
                error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this);
            }
            else if (!type) {
                // With noImplicitThis, functions may not reference 'this' if it has type 'any'
                const diag = error(node, Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation);
                if (!isSourceFile(container)) {
                    const outsideThis = tryGetThisTypeAt(container);
                    if (outsideThis && outsideThis !== globalThisType) {
                        addRelatedInfo(diag, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container));
                    }
                }
            }
        }
        return type || anyType;
    }

    function tryGetThisTypeAt(node: Node, includeGlobalThis = true, container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false)): Type | undefined {
        const isInJS = isInJSFile(node);
        if (
            isFunctionLike(container) &&
            (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container))
        ) {
            let thisType = getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container);
            // Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
            // If this is a function in a JS file, it might be a class method.
            if (!thisType) {
                const className = getClassNameFromPrototypeMethod(container);
                if (isInJS && className) {
                    const classSymbol = checkExpression(className).symbol;
                    if (classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlags.Function)) {
                        thisType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType;
                    }
                }
                else if (isJSConstructor(container)) {
                    thisType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)) as InterfaceType).thisType;
                }
                thisType ||= getContextualThisParameterType(container);
            }

            if (thisType) {
                return getFlowTypeOfReference(node, thisType);
            }
        }

        if (isClassLike(container.parent)) {
            const symbol = getSymbolOfDeclaration(container.parent);
            const type = isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType!;
            return getFlowTypeOfReference(node, type);
        }

        if (isSourceFile(container)) {
            // look up in the source file's locals or exports
            if (container.commonJsModuleIndicator) {
                const fileSymbol = getSymbolOfDeclaration(container);
                return fileSymbol && getTypeOfSymbol(fileSymbol);
            }
            else if (container.externalModuleIndicator) {
                // TODO: Maybe issue a better error than 'object is possibly undefined'
                return undefinedType;
            }
            else if (includeGlobalThis) {
                return getTypeOfSymbol(globalThisSymbol);
            }
        }
    }

    function getExplicitThisType(node: Expression) {
        const container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
        if (isFunctionLike(container)) {
            const signature = getSignatureFromDeclaration(container);
            if (signature.thisParameter) {
                return getExplicitTypeOfSymbol(signature.thisParameter);
            }
        }
        if (isClassLike(container.parent)) {
            const symbol = getSymbolOfDeclaration(container.parent);
            return isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType!;
        }
    }

    function getClassNameFromPrototypeMethod(container: Node) {
        // Check if it's the RHS of a x.prototype.y = function [name]() { .... }
        if (
            container.kind === SyntaxKind.FunctionExpression &&
            isBinaryExpression(container.parent) &&
            getAssignmentDeclarationKind(container.parent) === AssignmentDeclarationKind.PrototypeProperty
        ) {
            // Get the 'x' of 'x.prototype.y = container'
            return ((container.parent // x.prototype.y = container
                .left as PropertyAccessExpression) // x.prototype.y
                .expression as PropertyAccessExpression) // x.prototype
                .expression; // x
        }
        // x.prototype = { method() { } }
        else if (
            container.kind === SyntaxKind.MethodDeclaration &&
            container.parent.kind === SyntaxKind.ObjectLiteralExpression &&
            isBinaryExpression(container.parent.parent) &&
            getAssignmentDeclarationKind(container.parent.parent) === AssignmentDeclarationKind.Prototype
        ) {
            return (container.parent.parent.left as PropertyAccessExpression).expression;
        }
        // x.prototype = { method: function() { } }
        else if (
            container.kind === SyntaxKind.FunctionExpression &&
            container.parent.kind === SyntaxKind.PropertyAssignment &&
            container.parent.parent.kind === SyntaxKind.ObjectLiteralExpression &&
            isBinaryExpression(container.parent.parent.parent) &&
            getAssignmentDeclarationKind(container.parent.parent.parent) === AssignmentDeclarationKind.Prototype
        ) {
            return (container.parent.parent.parent.left as PropertyAccessExpression).expression;
        }
        // Object.defineProperty(x, "method", { value: function() { } });
        // Object.defineProperty(x, "method", { set: (x: () => void) => void });
        // Object.defineProperty(x, "method", { get: () => function() { }) });
        else if (
            container.kind === SyntaxKind.FunctionExpression &&
            isPropertyAssignment(container.parent) &&
            isIdentifier(container.parent.name) &&
            (container.parent.name.escapedText === "value" || container.parent.name.escapedText === "get" || container.parent.name.escapedText === "set") &&
            isObjectLiteralExpression(container.parent.parent) &&
            isCallExpression(container.parent.parent.parent) &&
            container.parent.parent.parent.arguments[2] === container.parent.parent &&
            getAssignmentDeclarationKind(container.parent.parent.parent) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
        ) {
            return (container.parent.parent.parent.arguments[0] as PropertyAccessExpression).expression;
        }
        // Object.defineProperty(x, "method", { value() { } });
        // Object.defineProperty(x, "method", { set(x: () => void) {} });
        // Object.defineProperty(x, "method", { get() { return () => {} } });
        else if (
            isMethodDeclaration(container) &&
            isIdentifier(container.name) &&
            (container.name.escapedText === "value" || container.name.escapedText === "get" || container.name.escapedText === "set") &&
            isObjectLiteralExpression(container.parent) &&
            isCallExpression(container.parent.parent) &&
            container.parent.parent.arguments[2] === container.parent &&
            getAssignmentDeclarationKind(container.parent.parent) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
        ) {
            return (container.parent.parent.arguments[0] as PropertyAccessExpression).expression;
        }
    }

    function getTypeForThisExpressionFromJSDoc(node: SignatureDeclaration) {
        const thisTag = getJSDocThisTag(node);
        if (thisTag && thisTag.typeExpression) {
            return getTypeFromTypeNode(thisTag.typeExpression);
        }
        const signature = getSignatureOfTypeTag(node);
        if (signature) {
            return getThisTypeOfSignature(signature);
        }
    }

    function isInConstructorArgumentInitializer(node: Node, constructorDecl: Node): boolean {
        return !!findAncestor(node, n => isFunctionLikeDeclaration(n) ? "quit" : n.kind === SyntaxKind.Parameter && n.parent === constructorDecl);
    }

    function checkSuperExpression(node: Node): Type {
        const isCallExpression = node.parent.kind === SyntaxKind.CallExpression && (node.parent as CallExpression).expression === node;

        const immediateContainer = getSuperContainer(node, /*stopOnFunctions*/ true);
        let container = immediateContainer;
        let needToCaptureLexicalThis = false;
        let inAsyncFunction = false;

        // adjust the container reference in case if super is used inside arrow functions with arbitrarily deep nesting
        if (!isCallExpression) {
            while (container && container.kind === SyntaxKind.ArrowFunction) {
                if (hasSyntacticModifier(container, ModifierFlags.Async)) inAsyncFunction = true;
                container = getSuperContainer(container, /*stopOnFunctions*/ true);
                needToCaptureLexicalThis = languageVersion < ScriptTarget.ES2015;
            }
            if (container && hasSyntacticModifier(container, ModifierFlags.Async)) inAsyncFunction = true;
        }

        let nodeCheckFlag: NodeCheckFlags = 0;

        if (!container || !isLegalUsageOfSuperExpression(container)) {
            // issue more specific error if super is used in computed property name
            // class A { foo() { return "1" }}
            // class B {
            //     [super.foo()]() {}
            // }
            const current = findAncestor(node, n => n === container ? "quit" : n.kind === SyntaxKind.ComputedPropertyName);
            if (current && current.kind === SyntaxKind.ComputedPropertyName) {
                error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name);
            }
            else if (isCallExpression) {
                error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            }
            else if (!container || !container.parent || !(isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression)) {
                error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
            }
            else {
                error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            }
            return errorType;
        }

        if (!isCallExpression && immediateContainer!.kind === SyntaxKind.Constructor) {
            checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class);
        }

        if (isStatic(container) || isCallExpression) {
            nodeCheckFlag = NodeCheckFlags.SuperStatic;
            if (
                !isCallExpression &&
                languageVersion >= ScriptTarget.ES2015 && languageVersion <= ScriptTarget.ES2021 &&
                (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container))
            ) {
                // for `super.x` or `super[x]` in a static initializer, mark all enclosing
                // block scope containers so that we can report potential collisions with
                // `Reflect`.
                forEachEnclosingBlockScopeContainer(node.parent, current => {
                    if (!isSourceFile(current) || isExternalOrCommonJsModule(current)) {
                        getNodeLinks(current).flags |= NodeCheckFlags.ContainsSuperPropertyInStaticInitializer;
                    }
                });
            }
        }
        else {
            nodeCheckFlag = NodeCheckFlags.SuperInstance;
        }

        getNodeLinks(node).flags |= nodeCheckFlag;

        // Due to how we emit async functions, we need to specialize the emit for an async method that contains a `super` reference.
        // This is due to the fact that we emit the body of an async function inside of a generator function. As generator
        // functions cannot reference `super`, we emit a helper inside of the method body, but outside of the generator. This helper
        // uses an arrow function, which is permitted to reference `super`.
        //
        // There are two primary ways we can access `super` from within an async method. The first is getting the value of a property
        // or indexed access on super, either as part of a right-hand-side expression or call expression. The second is when setting the value
        // of a property or indexed access, either as part of an assignment expression or destructuring assignment.
        //
        // The simplest case is reading a value, in which case we will emit something like the following:
        //
        //  // ts
        //  ...
        //  async asyncMethod() {
        //    let x = await super.asyncMethod();
        //    return x;
        //  }
        //  ...
        //
        //  // js
        //  ...
        //  asyncMethod() {
        //      const _super = Object.create(null, {
        //        asyncMethod: { get: () => super.asyncMethod },
        //      });
        //      return __awaiter(this, arguments, Promise, function *() {
        //          let x = yield _super.asyncMethod.call(this);
        //          return x;
        //      });
        //  }
        //  ...
        //
        // The more complex case is when we wish to assign a value, especially as part of a destructuring assignment. As both cases
        // are legal in ES6, but also likely less frequent, we only emit setters if there is an assignment:
        //
        //  // ts
        //  ...
        //  async asyncMethod(ar: Promise<any[]>) {
        //      [super.a, super.b] = await ar;
        //  }
        //  ...
        //
        //  // js
        //  ...
        //  asyncMethod(ar) {
        //      const _super = Object.create(null, {
        //        a: { get: () => super.a, set: (v) => super.a = v },
        //        b: { get: () => super.b, set: (v) => super.b = v }
        //      };
        //      return __awaiter(this, arguments, Promise, function *() {
        //          [_super.a, _super.b] = yield ar;
        //      });
        //  }
        //  ...
        //
        // Creating an object that has getter and setters instead of just an accessor function is required for destructuring assignments
        // as a call expression cannot be used as the target of a destructuring assignment while a property access can.
        //
        // For element access expressions (`super[x]`), we emit a generic helper that forwards the element access in both situations.
        if (container.kind === SyntaxKind.MethodDeclaration && inAsyncFunction) {
            if (isSuperProperty(node.parent) && isAssignmentTarget(node.parent)) {
                getNodeLinks(container).flags |= NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync;
            }
            else {
                getNodeLinks(container).flags |= NodeCheckFlags.MethodWithSuperPropertyAccessInAsync;
            }
        }

        if (needToCaptureLexicalThis) {
            // call expressions are allowed only in constructors so they should always capture correct 'this'
            // super property access expressions can also appear in arrow functions -
            // in this case they should also use correct lexical this
            captureLexicalThis(node.parent, container);
        }

        if (container.parent.kind === SyntaxKind.ObjectLiteralExpression) {
            if (languageVersion < ScriptTarget.ES2015) {
                error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher);
                return errorType;
            }
            else {
                // for object literal assume that type of 'super' is 'any'
                return anyType;
            }
        }

        // at this point the only legal case for parent is ClassLikeDeclaration
        const classLikeDeclaration = container.parent as ClassLikeDeclaration;
        if (!getClassExtendsHeritageElement(classLikeDeclaration)) {
            error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class);
            return errorType;
        }

        if (classDeclarationExtendsNull(classLikeDeclaration)) {
            return isCallExpression ? errorType : nullWideningType;
        }

        const classType = getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration)) as InterfaceType;
        const baseClassType = classType && getBaseTypes(classType)[0];
        if (!baseClassType) {
            return errorType;
        }

        if (container.kind === SyntaxKind.Constructor && isInConstructorArgumentInitializer(node, container)) {
            // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
            error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
            return errorType;
        }

        return nodeCheckFlag === NodeCheckFlags.SuperStatic
            ? getBaseConstructorTypeOfClass(classType)
            : getTypeWithThisArgument(baseClassType, classType.thisType);

        function isLegalUsageOfSuperExpression(container: Node): boolean {
            if (isCallExpression) {
                // TS 1.0 SPEC (April 2014): 4.8.1
                // Super calls are only permitted in constructors of derived classes
                return container.kind === SyntaxKind.Constructor;
            }
            else {
                // TS 1.0 SPEC (April 2014)
                // 'super' property access is allowed
                // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
                // - In a static member function or static member accessor

                // topmost container must be something that is directly nested in the class declaration\object literal expression
                if (isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression) {
                    if (isStatic(container)) {
                        return container.kind === SyntaxKind.MethodDeclaration ||
                            container.kind === SyntaxKind.MethodSignature ||
                            container.kind === SyntaxKind.GetAccessor ||
                            container.kind === SyntaxKind.SetAccessor ||
                            container.kind === SyntaxKind.PropertyDeclaration ||
                            container.kind === SyntaxKind.ClassStaticBlockDeclaration;
                    }
                    else {
                        return container.kind === SyntaxKind.MethodDeclaration ||
                            container.kind === SyntaxKind.MethodSignature ||
                            container.kind === SyntaxKind.GetAccessor ||
                            container.kind === SyntaxKind.SetAccessor ||
                            container.kind === SyntaxKind.PropertyDeclaration ||
                            container.kind === SyntaxKind.PropertySignature ||
                            container.kind === SyntaxKind.Constructor;
                    }
                }
            }

            return false;
        }
    }

    function getContainingObjectLiteral(func: SignatureDeclaration): ObjectLiteralExpression | undefined {
        return (func.kind === SyntaxKind.MethodDeclaration ||
                func.kind === SyntaxKind.GetAccessor ||
                func.kind === SyntaxKind.SetAccessor) && func.parent.kind === SyntaxKind.ObjectLiteralExpression ? func.parent :
            func.kind === SyntaxKind.FunctionExpression && func.parent.kind === SyntaxKind.PropertyAssignment ? func.parent.parent as ObjectLiteralExpression :
            undefined;
    }

    function getThisTypeArgument(type: Type): Type | undefined {
        return getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target === globalThisType ? getTypeArguments(type as TypeReference)[0] : undefined;
    }

    function getThisTypeFromContextualType(type: Type): Type | undefined {
        return mapType(type, t => {
            return t.flags & TypeFlags.Intersection ? forEach((t as IntersectionType).types, getThisTypeArgument) : getThisTypeArgument(t);
        });
    }

    function getThisTypeOfObjectLiteralFromContextualType(containingLiteral: ObjectLiteralExpression, contextualType: Type | undefined) {
        let literal = containingLiteral;
        let type = contextualType;
        while (type) {
            const thisType = getThisTypeFromContextualType(type);
            if (thisType) {
                return thisType;
            }
            if (literal.parent.kind !== SyntaxKind.PropertyAssignment) {
                break;
            }
            literal = literal.parent.parent as ObjectLiteralExpression;
            type = getApparentTypeOfContextualType(literal, /*contextFlags*/ undefined);
        }
    }

    function getContextualThisParameterType(func: SignatureDeclaration): Type | undefined {
        if (func.kind === SyntaxKind.ArrowFunction) {
            return undefined;
        }
        if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
            const contextualSignature = getContextualSignature(func);
            if (contextualSignature) {
                const thisParameter = contextualSignature.thisParameter;
                if (thisParameter) {
                    return getTypeOfSymbol(thisParameter);
                }
            }
        }
        const inJs = isInJSFile(func);
        if (noImplicitThis || inJs) {
            const containingLiteral = getContainingObjectLiteral(func);
            if (containingLiteral) {
                // We have an object literal method. Check if the containing object literal has a contextual type
                // that includes a ThisType<T>. If so, T is the contextual type for 'this'. We continue looking in
                // any directly enclosing object literals.
                const contextualType = getApparentTypeOfContextualType(containingLiteral, /*contextFlags*/ undefined);
                const thisType = getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType);
                if (thisType) {
                    return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)));
                }
                // There was no contextual ThisType<T> for the containing object literal, so the contextual type
                // for 'this' is the non-null form of the contextual type for the containing object literal or
                // the type of the object literal itself.
                return getWidenedType(contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral));
            }
            // In an assignment of the form 'obj.xxx = function(...)' or 'obj[xxx] = function(...)', the
            // contextual type for 'this' is 'obj'.
            const parent = walkUpParenthesizedExpressions(func.parent);
            if (isAssignmentExpression(parent)) {
                const target = parent.left;
                if (isAccessExpression(target)) {
                    const { expression } = target;
                    // Don't contextually type `this` as `exports` in `exports.Point = function(x, y) { this.x = x; this.y = y; }`
                    if (inJs && isIdentifier(expression)) {
                        const sourceFile = getSourceFileOfNode(parent);
                        if (sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) === sourceFile.symbol) {
                            return undefined;
                        }
                    }

                    return getWidenedType(checkExpressionCached(expression));
                }
            }
        }
        return undefined;
    }

    // Return contextual type of parameter or undefined if no contextual type is available
    function getContextuallyTypedParameterType(parameter: ParameterDeclaration): Type | undefined {
        const func = parameter.parent;
        if (!isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
            return undefined;
        }
        const iife = getImmediatelyInvokedFunctionExpression(func);
        if (iife && iife.arguments) {
            const args = getEffectiveCallArguments(iife);
            const indexOfParameter = func.parameters.indexOf(parameter);
            if (parameter.dotDotDotToken) {
                return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, /*context*/ undefined, CheckMode.Normal);
            }
            const links = getNodeLinks(iife);
            const cached = links.resolvedSignature;
            links.resolvedSignature = anySignature;
            const type = indexOfParameter < args.length ?
                getWidenedLiteralType(checkExpression(args[indexOfParameter])) :
                parameter.initializer ? undefined : undefinedWideningType;
            links.resolvedSignature = cached;
            return type;
        }
        const contextualSignature = getContextualSignature(func);
        if (contextualSignature) {
            const index = func.parameters.indexOf(parameter) - (getThisParameter(func) ? 1 : 0);
            return parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ?
                getRestTypeAtPosition(contextualSignature, index) :
                tryGetTypeAtPosition(contextualSignature, index);
        }
    }

    function getContextualTypeForVariableLikeDeclaration(declaration: VariableLikeDeclaration, contextFlags: ContextFlags | undefined): Type | undefined {
        const typeNode = getEffectiveTypeAnnotationNode(declaration) || (isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : undefined);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
        switch (declaration.kind) {
            case SyntaxKind.Parameter:
                return getContextuallyTypedParameterType(declaration);
            case SyntaxKind.BindingElement:
                return getContextualTypeForBindingElement(declaration, contextFlags);
            case SyntaxKind.PropertyDeclaration:
                if (isStatic(declaration)) {
                    return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags);
                }
                // By default, do nothing and return undefined - only the above cases have context implied by a parent
        }
    }

    function getContextualTypeForBindingElement(declaration: BindingElement, contextFlags: ContextFlags | undefined): Type | undefined {
        const parent = declaration.parent.parent;
        const name = declaration.propertyName || declaration.name;
        const parentType = getContextualTypeForVariableLikeDeclaration(parent, contextFlags) ||
            parent.kind !== SyntaxKind.BindingElement && parent.initializer && checkDeclarationInitializer(parent, declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal);
        if (!parentType || isBindingPattern(name) || isComputedNonLiteralName(name)) return undefined;
        if (parent.name.kind === SyntaxKind.ArrayBindingPattern) {
            const index = indexOfNode(declaration.parent.elements, declaration);
            if (index < 0) return undefined;
            return getContextualTypeForElementExpression(parentType, index);
        }
        const nameType = getLiteralTypeFromPropertyName(name);
        if (isTypeUsableAsPropertyName(nameType)) {
            const text = getPropertyNameFromType(nameType);
            return getTypeOfPropertyOfType(parentType, text);
        }
    }

    function getContextualTypeForStaticPropertyDeclaration(declaration: PropertyDeclaration, contextFlags: ContextFlags | undefined): Type | undefined {
        const parentType = isExpression(declaration.parent) && getContextualType(declaration.parent, contextFlags);
        if (!parentType) return undefined;
        return getTypeOfPropertyOfContextualType(parentType, getSymbolOfDeclaration(declaration).escapedName);
    }

    // In a variable, parameter or property declaration with a type annotation,
    //   the contextual type of an initializer expression is the type of the variable, parameter or property.
    // Otherwise, in a parameter declaration of a contextually typed function expression,
    //   the contextual type of an initializer expression is the contextual type of the parameter.
    // Otherwise, in a variable or parameter declaration with a binding pattern name,
    //   the contextual type of an initializer expression is the type implied by the binding pattern.
    // Otherwise, in a binding pattern inside a variable or parameter declaration,
    //   the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
    function getContextualTypeForInitializerExpression(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const declaration = node.parent as VariableLikeDeclaration;
        if (hasInitializer(declaration) && node === declaration.initializer) {
            const result = getContextualTypeForVariableLikeDeclaration(declaration, contextFlags);
            if (result) {
                return result;
            }
            if (!(contextFlags! & ContextFlags.SkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0) {
                return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true, /*reportErrors*/ false);
            }
        }
        return undefined;
    }

    function getContextualTypeForReturnExpression(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const func = getContainingFunction(node);
        if (func) {
            let contextualReturnType = getContextualReturnType(func, contextFlags);
            if (contextualReturnType) {
                const functionFlags = getFunctionFlags(func);
                if (functionFlags & FunctionFlags.Generator) { // Generator or AsyncGenerator function
                    const isAsyncGenerator = (functionFlags & FunctionFlags.Async) !== 0;
                    if (contextualReturnType.flags & TypeFlags.Union) {
                        contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator));
                    }
                    const iterationReturnType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, contextualReturnType, (functionFlags & FunctionFlags.Async) !== 0);
                    if (!iterationReturnType) {
                        return undefined;
                    }
                    contextualReturnType = iterationReturnType;
                    // falls through to unwrap Promise for AsyncGenerators
                }

                if (functionFlags & FunctionFlags.Async) { // Async function or AsyncGenerator function
                    // Get the awaited type without the `Awaited<T>` alias
                    const contextualAwaitedType = mapType(contextualReturnType, getAwaitedTypeNoAlias);
                    return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
                }

                return contextualReturnType; // Regular function or Generator function
            }
        }
        return undefined;
    }

    function getContextualTypeForAwaitOperand(node: AwaitExpression, contextFlags: ContextFlags | undefined): Type | undefined {
        const contextualType = getContextualType(node, contextFlags);
        if (contextualType) {
            const contextualAwaitedType = getAwaitedTypeNoAlias(contextualType);
            return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
        }
        return undefined;
    }

    function getContextualTypeForYieldOperand(node: YieldExpression, contextFlags: ContextFlags | undefined): Type | undefined {
        const func = getContainingFunction(node);
        if (func) {
            const functionFlags = getFunctionFlags(func);
            let contextualReturnType = getContextualReturnType(func, contextFlags);
            if (contextualReturnType) {
                const isAsyncGenerator = (functionFlags & FunctionFlags.Async) !== 0;
                if (!node.asteriskToken && contextualReturnType.flags & TypeFlags.Union) {
                    contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator));
                }
                if (node.asteriskToken) {
                    const iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator);
                    const yieldType = iterationTypes?.yieldType ?? silentNeverType;
                    const returnType = getContextualType(node, contextFlags) ?? silentNeverType;
                    const nextType = iterationTypes?.nextType ?? unknownType;
                    const generatorType = createGeneratorType(yieldType, returnType, nextType, /*isAsyncGenerator*/ false);
                    if (isAsyncGenerator) {
                        const asyncGeneratorType = createGeneratorType(yieldType, returnType, nextType, /*isAsyncGenerator*/ true);
                        return getUnionType([generatorType, asyncGeneratorType]);
                    }
                    return generatorType;
                }
                return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Yield, contextualReturnType, isAsyncGenerator);
            }
        }

        return undefined;
    }

    function isInParameterInitializerBeforeContainingFunction(node: Node) {
        let inBindingInitializer = false;
        while (node.parent && !isFunctionLike(node.parent)) {
            if (isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)) {
                return true;
            }
            if (isBindingElement(node.parent) && node.parent.initializer === node) {
                inBindingInitializer = true;
            }

            node = node.parent;
        }

        return false;
    }

    function getContextualIterationType(kind: IterationTypeKind, functionDecl: SignatureDeclaration): Type | undefined {
        const isAsync = !!(getFunctionFlags(functionDecl) & FunctionFlags.Async);
        const contextualReturnType = getContextualReturnType(functionDecl, /*contextFlags*/ undefined);
        if (contextualReturnType) {
            return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync)
                || undefined;
        }

        return undefined;
    }

    function getContextualReturnType(functionDecl: SignatureDeclaration, contextFlags: ContextFlags | undefined): Type | undefined {
        // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
        // corresponding set accessor has a type annotation, return statements in the function are contextually typed
        const returnType = getReturnTypeFromAnnotation(functionDecl);
        if (returnType) {
            return returnType;
        }
        // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
        // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
        const signature = getContextualSignatureForFunctionLikeDeclaration(functionDecl as FunctionExpression);
        if (signature && !isResolvingReturnTypeOfSignature(signature)) {
            const returnType = getReturnTypeOfSignature(signature);
            const functionFlags = getFunctionFlags(functionDecl);
            if (functionFlags & FunctionFlags.Generator) {
                return filterType(returnType, t => {
                    return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive)) || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, /*errorNode*/ undefined);
                });
            }
            if (functionFlags & FunctionFlags.Async) {
                return filterType(returnType, t => {
                    return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive)) || !!getAwaitedTypeOfPromise(t);
                });
            }
            return returnType;
        }
        const iife = getImmediatelyInvokedFunctionExpression(functionDecl);
        if (iife) {
            return getContextualType(iife, contextFlags);
        }
        return undefined;
    }

    // In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
    function getContextualTypeForArgument(callTarget: CallLikeExpression, arg: Expression): Type | undefined {
        const args = getEffectiveCallArguments(callTarget);
        const argIndex = args.indexOf(arg); // -1 for e.g. the expression of a CallExpression, or the tag of a TaggedTemplateExpression
        return argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex);
    }

    function getContextualTypeForArgumentAtIndex(callTarget: CallLikeExpression, argIndex: number): Type {
        if (isImportCall(callTarget)) {
            return argIndex === 0 ? stringType :
                argIndex === 1 ? getGlobalImportCallOptionsType(/*reportErrors*/ false) :
                anyType;
        }

        // If we're already in the process of resolving the given signature, don't resolve again as
        // that could cause infinite recursion. Instead, return anySignature.
        const signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget);

        if (isJsxOpeningLikeElement(callTarget) && argIndex === 0) {
            return getEffectiveFirstArgumentForJsxSignature(signature, callTarget);
        }
        const restIndex = signature.parameters.length - 1;
        return signatureHasRestParameter(signature) && argIndex >= restIndex ?
            getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), AccessFlags.Contextual) :
            getTypeAtPosition(signature, argIndex);
    }

    function getContextualTypeForDecorator(decorator: Decorator): Type | undefined {
        const signature = getDecoratorCallSignature(decorator);
        return signature ? getOrCreateTypeFromSignature(signature) : undefined;
    }

    function getContextualTypeForSubstitutionExpression(template: TemplateExpression, substitutionExpression: Expression) {
        if (template.parent.kind === SyntaxKind.TaggedTemplateExpression) {
            return getContextualTypeForArgument(template.parent as TaggedTemplateExpression, substitutionExpression);
        }

        return undefined;
    }

    function getContextualTypeForBinaryOperand(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const binaryExpression = node.parent as BinaryExpression;
        const { left, operatorToken, right } = binaryExpression;
        switch (operatorToken.kind) {
            case SyntaxKind.EqualsToken:
            case SyntaxKind.AmpersandAmpersandEqualsToken:
            case SyntaxKind.BarBarEqualsToken:
            case SyntaxKind.QuestionQuestionEqualsToken:
                return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : undefined;
            case SyntaxKind.BarBarToken:
            case SyntaxKind.QuestionQuestionToken:
                // When an || expression has a contextual type, the operands are contextually typed by that type, except
                // when that type originates in a binding pattern, the right operand is contextually typed by the type of
                // the left operand. When an || expression has no contextual type, the right operand is contextually typed
                // by the type of the left operand, except for the special case of Javascript declarations of the form
                // `namespace.prop = namespace.prop || {}`.
                const type = getContextualType(binaryExpression, contextFlags);
                return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ?
                    getTypeOfExpression(left) : type;
            case SyntaxKind.AmpersandAmpersandToken:
            case SyntaxKind.CommaToken:
                return node === right ? getContextualType(binaryExpression, contextFlags) : undefined;
            default:
                return undefined;
        }
    }

    /**
     * Try to find a resolved symbol for an expression without also resolving its type, as
     * getSymbolAtLocation would (as that could be reentrant into contextual typing)
     */
    function getSymbolForExpression(e: Expression) {
        if (canHaveSymbol(e) && e.symbol) {
            return e.symbol;
        }
        if (isIdentifier(e)) {
            return getResolvedSymbol(e);
        }
        if (isPropertyAccessExpression(e)) {
            const lhsType = getTypeOfExpression(e.expression);
            return isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText);
        }
        if (isElementAccessExpression(e)) {
            const propType = checkExpressionCached(e.argumentExpression);
            if (!isTypeUsableAsPropertyName(propType)) {
                return undefined;
            }
            const lhsType = getTypeOfExpression(e.expression);
            return getPropertyOfType(lhsType, getPropertyNameFromType(propType));
        }
        return undefined;

        function tryGetPrivateIdentifierPropertyOfType(type: Type, id: PrivateIdentifier) {
            const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id);
            return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type, lexicallyScopedSymbol);
        }
    }

    // In an assignment expression, the right operand is contextually typed by the type of the left operand.
    // Don't do this for assignment declarations unless there is a type tag on the assignment, to avoid circularity from checking the right operand.
    function getContextualTypeForAssignmentDeclaration(binaryExpression: BinaryExpression): Type | undefined {
        const kind = getAssignmentDeclarationKind(binaryExpression);
        switch (kind) {
            case AssignmentDeclarationKind.None:
            case AssignmentDeclarationKind.ThisProperty:
                const lhsSymbol = getSymbolForExpression(binaryExpression.left);
                const decl = lhsSymbol && lhsSymbol.valueDeclaration;
                // Unannotated, uninitialized property declarations have a type implied by their usage in the constructor.
                // We avoid calling back into `getTypeOfExpression` and reentering contextual typing to avoid a bogus circularity error in that case.
                if (decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))) {
                    const overallAnnotation = getEffectiveTypeAnnotationNode(decl);
                    return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) ||
                        (isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : undefined);
                }
                if (kind === AssignmentDeclarationKind.None) {
                    return getTypeOfExpression(binaryExpression.left);
                }
                return getContextualTypeForThisPropertyAssignment(binaryExpression);
            case AssignmentDeclarationKind.Property:
                if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {
                    return getContextualTypeForThisPropertyAssignment(binaryExpression);
                }
                // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.
                // See `bindStaticPropertyAssignment` in `binder.ts`.
                else if (!canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol) {
                    return getTypeOfExpression(binaryExpression.left);
                }
                else {
                    const decl = binaryExpression.left.symbol.valueDeclaration;
                    if (!decl) {
                        return undefined;
                    }
                    const lhs = cast(binaryExpression.left, isAccessExpression);
                    const overallAnnotation = getEffectiveTypeAnnotationNode(decl);
                    if (overallAnnotation) {
                        return getTypeFromTypeNode(overallAnnotation);
                    }
                    else if (isIdentifier(lhs.expression)) {
                        const id = lhs.expression;
                        const parentSymbol = resolveName(id, id.escapedText, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
                        if (parentSymbol) {
                            const annotated = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);
                            if (annotated) {
                                const nameStr = getElementOrPropertyAccessName(lhs);
                                if (nameStr !== undefined) {
                                    return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr);
                                }
                            }
                            return undefined;
                        }
                    }
                    return isInJSFile(decl) || decl === binaryExpression.left ? undefined : getTypeOfExpression(binaryExpression.left);
                }
            case AssignmentDeclarationKind.ExportsProperty:
            case AssignmentDeclarationKind.Prototype:
            case AssignmentDeclarationKind.PrototypeProperty:
            case AssignmentDeclarationKind.ModuleExports:
                let valueDeclaration: Declaration | undefined;
                if (kind !== AssignmentDeclarationKind.ModuleExports) {
                    valueDeclaration = canHaveSymbol(binaryExpression.left) ? binaryExpression.left.symbol?.valueDeclaration : undefined;
                }
                valueDeclaration ||= binaryExpression.symbol?.valueDeclaration;
                const annotated = valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration);
                return annotated ? getTypeFromTypeNode(annotated) : undefined;
            case AssignmentDeclarationKind.ObjectDefinePropertyValue:
            case AssignmentDeclarationKind.ObjectDefinePropertyExports:
            case AssignmentDeclarationKind.ObjectDefinePrototypeProperty:
                return Debug.fail("Does not apply");
            default:
                return Debug.assertNever(kind);
        }
    }

    function isPossiblyAliasedThisProperty(declaration: BinaryExpression, kind = getAssignmentDeclarationKind(declaration)) {
        if (kind === AssignmentDeclarationKind.ThisProperty) {
            return true;
        }
        if (!isInJSFile(declaration) || kind !== AssignmentDeclarationKind.Property || !isIdentifier((declaration.left as AccessExpression).expression)) {
            return false;
        }
        const name = ((declaration.left as AccessExpression).expression as Identifier).escapedText;
        const symbol = resolveName(declaration.left, name, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ true, /*excludeGlobals*/ true);
        return isThisInitializedDeclaration(symbol?.valueDeclaration);
    }

    function getContextualTypeForThisPropertyAssignment(binaryExpression: BinaryExpression): Type | undefined {
        if (!binaryExpression.symbol) return getTypeOfExpression(binaryExpression.left);
        if (binaryExpression.symbol.valueDeclaration) {
            const annotated = getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration);
            if (annotated) {
                const type = getTypeFromTypeNode(annotated);
                if (type) {
                    return type;
                }
            }
        }
        const thisAccess = cast(binaryExpression.left, isAccessExpression);
        if (!isObjectLiteralMethod(getThisContainer(thisAccess.expression, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false))) {
            return undefined;
        }
        const thisType = checkThisExpression(thisAccess.expression);
        const nameStr = getElementOrPropertyAccessName(thisAccess);
        return nameStr !== undefined && getTypeOfPropertyOfContextualType(thisType, nameStr) || undefined;
    }

    function isCircularMappedProperty(symbol: Symbol) {
        return !!(getCheckFlags(symbol) & CheckFlags.Mapped && !(symbol as MappedSymbol).links.type && findResolutionCycleStartIndex(symbol, TypeSystemPropertyName.Type) >= 0);
    }

    function isExcludedMappedPropertyName(constraint: Type, propertyNameType: Type): boolean {
        if (constraint.flags & TypeFlags.Conditional) {
            const type = constraint as ConditionalType;
            return !!(getReducedType(getTrueTypeFromConditionalType(type)).flags & TypeFlags.Never) &&
                getActualTypeVariable(getFalseTypeFromConditionalType(type)) === getActualTypeVariable(type.checkType) &&
                isTypeAssignableTo(propertyNameType, type.extendsType);
        }
        if (constraint.flags & TypeFlags.Intersection) {
            return some((constraint as IntersectionType).types, t => isExcludedMappedPropertyName(t, propertyNameType));
        }
        return false;
    }

    function getTypeOfPropertyOfContextualType(type: Type, name: __String, nameType?: Type) {
        return mapType(type, t => {
            if (t.flags & TypeFlags.Intersection) {
                let types: Type[] | undefined;
                let indexInfoCandidates: Type[] | undefined;
                let ignoreIndexInfos = false;
                for (const constituentType of (t as IntersectionType).types) {
                    if (!(constituentType.flags & TypeFlags.Object)) {
                        continue;
                    }
                    if (isGenericMappedType(constituentType) && getMappedTypeNameTypeKind(constituentType) !== MappedTypeNameTypeKind.Remapping) {
                        const substitutedType = getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType);
                        types = appendContextualPropertyTypeConstituent(types, substitutedType);
                        continue;
                    }
                    const propertyType = getTypeOfConcretePropertyOfContextualType(constituentType, name);
                    if (!propertyType) {
                        if (!ignoreIndexInfos) {
                            indexInfoCandidates = append(indexInfoCandidates, constituentType);
                        }
                        continue;
                    }
                    ignoreIndexInfos = true;
                    indexInfoCandidates = undefined;
                    types = appendContextualPropertyTypeConstituent(types, propertyType);
                }
                if (indexInfoCandidates) {
                    for (const candidate of indexInfoCandidates) {
                        const indexInfoType = getTypeFromIndexInfosOfContextualType(candidate, name, nameType);
                        types = appendContextualPropertyTypeConstituent(types, indexInfoType);
                    }
                }
                if (!types) {
                    return;
                }
                if (types.length === 1) {
                    return types[0];
                }
                return getIntersectionType(types);
            }
            if (!(t.flags & TypeFlags.Object)) {
                return;
            }
            return isGenericMappedType(t) && getMappedTypeNameTypeKind(t) !== MappedTypeNameTypeKind.Remapping
                ? getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)
                : getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType);
        }, /*noReductions*/ true);
    }

    function appendContextualPropertyTypeConstituent(types: Type[] | undefined, type: Type | undefined) {
        // any doesn't provide any contextual information but could spoil the overall result by nullifying contextual information provided by other intersection constituents
        // so it gets replaced with `unknown` as `T & unknown` is just `T` and all types computed based on the contextual information provided by other constituens are still assignable to any
        return type ? append(types, type.flags & TypeFlags.Any ? unknownType : type) : types;
    }

    function getIndexedMappedTypeSubstitutedTypeOfContextualType(type: MappedType, name: __String, nameType: Type | undefined) {
        const propertyNameType = nameType || getStringLiteralType(unescapeLeadingUnderscores(name));
        const constraint = getConstraintTypeFromMappedType(type);
        // special case for conditional types pretending to be negated types
        if (type.nameType && isExcludedMappedPropertyName(type.nameType, propertyNameType) || isExcludedMappedPropertyName(constraint, propertyNameType)) {
            return;
        }
        const constraintOfConstraint = getBaseConstraintOfType(constraint) || constraint;
        if (!isTypeAssignableTo(propertyNameType, constraintOfConstraint)) {
            return;
        }
        return substituteIndexedMappedType(type, propertyNameType);
    }

    function getTypeOfConcretePropertyOfContextualType(type: Type, name: __String) {
        const prop = getPropertyOfType(type, name);
        if (!prop || isCircularMappedProperty(prop)) {
            return;
        }
        return removeMissingType(getTypeOfSymbol(prop), !!(prop.flags & SymbolFlags.Optional));
    }

    function getTypeFromIndexInfosOfContextualType(type: Type, name: __String, nameType: Type | undefined) {
        if (isTupleType(type) && isNumericLiteralName(name) && +name >= 0) {
            const restType = getElementTypeOfSliceOfTupleType(type, type.target.fixedLength, /*endSkipCount*/ 0, /*writing*/ false, /*noReductions*/ true);
            if (restType) {
                return restType;
            }
        }
        return findApplicableIndexInfo(getIndexInfosOfStructuredType(type), nameType || getStringLiteralType(unescapeLeadingUnderscores(name)))?.type;
    }

    // In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
    // the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
    // exists. Otherwise, it is the type of the string index signature in T, if one exists.
    function getContextualTypeForObjectLiteralMethod(node: MethodDeclaration, contextFlags: ContextFlags | undefined): Type | undefined {
        Debug.assert(isObjectLiteralMethod(node));
        if (node.flags & NodeFlags.InWithStatement) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return undefined;
        }
        return getContextualTypeForObjectLiteralElement(node, contextFlags);
    }

    function getContextualTypeForObjectLiteralElement(element: ObjectLiteralElementLike, contextFlags: ContextFlags | undefined) {
        const objectLiteral = element.parent as ObjectLiteralExpression;
        const propertyAssignmentType = isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags);
        if (propertyAssignmentType) {
            return propertyAssignmentType;
        }
        const type = getApparentTypeOfContextualType(objectLiteral, contextFlags);
        if (type) {
            if (hasBindableName(element)) {
                // For a (non-symbol) computed property, there is no reason to look up the name
                // in the type. It will just be "__computed", which does not appear in any
                // SymbolTable.
                const symbol = getSymbolOfDeclaration(element);
                return getTypeOfPropertyOfContextualType(type, symbol.escapedName, getSymbolLinks(symbol).nameType);
            }
            if (hasDynamicName(element)) {
                const name = getNameOfDeclaration(element);
                if (name && isComputedPropertyName(name)) {
                    const exprType = checkExpression(name.expression);
                    const propType = isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type, getPropertyNameFromType(exprType));
                    if (propType) {
                        return propType;
                    }
                }
            }
            if (element.name) {
                const nameType = getLiteralTypeFromPropertyName(element.name);
                // We avoid calling getApplicableIndexInfo here because it performs potentially expensive intersection reduction.
                return mapType(type, t => findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType)?.type, /*noReductions*/ true);
            }
        }
        return undefined;
    }

    function getSpreadIndices(elements: readonly Node[]) {
        let first, last;
        for (let i = 0; i < elements.length; i++) {
            if (isSpreadElement(elements[i])) {
                first ??= i;
                last = i;
            }
        }
        return { first, last };
    }

    function getContextualTypeForElementExpression(type: Type | undefined, index: number, length?: number, firstSpreadIndex?: number, lastSpreadIndex?: number): Type | undefined {
        return type && mapType(type, t => {
            if (isTupleType(t)) {
                // If index is before any spread element and within the fixed part of the contextual tuple type, return
                // the type of the contextual tuple element.
                if ((firstSpreadIndex === undefined || index < firstSpreadIndex) && index < t.target.fixedLength) {
                    return removeMissingType(getTypeArguments(t)[index], !!(t.target.elementFlags[index] && ElementFlags.Optional));
                }
                // When the length is known and the index is after all spread elements we compute the offset from the element
                // to the end and the number of ending fixed elements in the contextual tuple type.
                const offset = length !== undefined && (lastSpreadIndex === undefined || index > lastSpreadIndex) ? length - index : 0;
                const fixedEndLength = offset > 0 && (t.target.combinedFlags & ElementFlags.Variable) ? getEndElementCount(t.target, ElementFlags.Fixed) : 0;
                // If the offset is within the ending fixed part of the contextual tuple type, return the type of the contextual
                // tuple element.
                if (offset > 0 && offset <= fixedEndLength) {
                    return getTypeArguments(t)[getTypeReferenceArity(t) - offset];
                }
                // Return a union of the possible contextual element types with no subtype reduction.
                return getElementTypeOfSliceOfTupleType(t, firstSpreadIndex === undefined ? t.target.fixedLength : Math.min(t.target.fixedLength, firstSpreadIndex), length === undefined || lastSpreadIndex === undefined ? fixedEndLength : Math.min(fixedEndLength, length - lastSpreadIndex), /*writing*/ false, /*noReductions*/ true);
            }
            // If element index is known and a contextual property with that name exists, return it. Otherwise return the
            // iterated or element type of the contextual type.
            return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t, "" + index as __String) ||
                getIteratedTypeOrElementType(IterationUse.Element, t, undefinedType, /*errorNode*/ undefined, /*checkAssignability*/ false);
        }, /*noReductions*/ true);
    }

    // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
    function getContextualTypeForConditionalOperand(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const conditional = node.parent as ConditionalExpression;
        return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined;
    }

    function getContextualTypeForChildJsxExpression(node: JsxElement, child: JsxChild, contextFlags: ContextFlags | undefined) {
        const attributesType = getApparentTypeOfContextualType(node.openingElement.attributes, contextFlags);
        // JSX expression is in children of JSX Element, we will look for an "children" attribute (we get the name from JSX.ElementAttributesProperty)
        const jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
        if (!(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName !== "")) {
            return undefined;
        }
        const realChildren = getSemanticJsxChildren(node.children);
        const childIndex = realChildren.indexOf(child);
        const childFieldType = getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName);
        return childFieldType && (realChildren.length === 1 ? childFieldType : mapType(childFieldType, t => {
            if (isArrayLikeType(t)) {
                return getIndexedAccessType(t, getNumberLiteralType(childIndex));
            }
            else {
                return t;
            }
        }, /*noReductions*/ true));
    }

    function getContextualTypeForJsxExpression(node: JsxExpression, contextFlags: ContextFlags | undefined): Type | undefined {
        const exprParent = node.parent;
        return isJsxAttributeLike(exprParent)
            ? getContextualType(node, contextFlags)
            : isJsxElement(exprParent)
            ? getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)
            : undefined;
    }

    function getContextualTypeForJsxAttribute(attribute: JsxAttribute | JsxSpreadAttribute, contextFlags: ContextFlags | undefined): Type | undefined {
        // When we trying to resolve JsxOpeningLikeElement as a stateless function element, we will already give its attributes a contextual type
        // which is a type of the parameter of the signature we are trying out.
        // If there is no contextual type (e.g. we are trying to resolve stateful component), get attributes type from resolving element's tagName
        if (isJsxAttribute(attribute)) {
            const attributesType = getApparentTypeOfContextualType(attribute.parent, contextFlags);
            if (!attributesType || isTypeAny(attributesType)) {
                return undefined;
            }
            return getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName(attribute.name));
        }
        else {
            return getContextualType(attribute.parent, contextFlags);
        }
    }

    // Return true if the given expression is possibly a discriminant value. We limit the kinds of
    // expressions we check to those that don't depend on their contextual type in order not to cause
    // recursive (and possibly infinite) invocations of getContextualType.
    function isPossiblyDiscriminantValue(node: Expression): boolean {
        switch (node.kind) {
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.BigIntLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateExpression:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.Identifier:
            case SyntaxKind.UndefinedKeyword:
                return true;
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ParenthesizedExpression:
                return isPossiblyDiscriminantValue((node as PropertyAccessExpression | ParenthesizedExpression).expression);
            case SyntaxKind.JsxExpression:
                return !(node as JsxExpression).expression || isPossiblyDiscriminantValue((node as JsxExpression).expression!);
        }
        return false;
    }

    function discriminateContextualTypeByObjectMembers(node: ObjectLiteralExpression, contextualType: UnionType) {
        const key = `D${getNodeId(node)},${getTypeId(contextualType)}`;
        return getCachedType(key) ?? setCachedType(
            key,
            getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems(
                contextualType,
                concatenate(
                    map(
                        filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => {
                            if (!p.symbol) {
                                return false;
                            }
                            if (p.kind === SyntaxKind.PropertyAssignment) {
                                return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName);
                            }
                            if (p.kind === SyntaxKind.ShorthandPropertyAssignment) {
                                return isDiscriminantProperty(contextualType, p.symbol.escapedName);
                            }
                            return false;
                        }),
                        prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const),
                    ),
                    map(
                        filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),
                        s => [() => undefinedType, s.escapedName] as const,
                    ),
                ),
                isTypeAssignableTo,
            ),
        );
    }

    function discriminateContextualTypeByJSXAttributes(node: JsxAttributes, contextualType: UnionType) {
        const key = `D${getNodeId(node)},${getTypeId(contextualType)}`;
        const cached = getCachedType(key);
        if (cached) return cached;
        const jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
        return setCachedType(
            key,
            discriminateTypeByDiscriminableItems(
                contextualType,
                concatenate(
                    map(
                        filter(node.properties, p => !!p.symbol && p.kind === SyntaxKind.JsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer))),
                        prop => ([!(prop as JsxAttribute).initializer ? (() => trueType) : (() => getContextFreeTypeOfExpression((prop as JsxAttribute).initializer!)), prop.symbol.escapedName] as const),
                    ),
                    map(
                        filter(getPropertiesOfType(contextualType), s => {
                            if (!(s.flags & SymbolFlags.Optional) || !node?.symbol?.members) {
                                return false;
                            }
                            const element = node.parent.parent;
                            if (s.escapedName === jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length) {
                                return false;
                            }
                            return !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName);
                        }),
                        s => [() => undefinedType, s.escapedName] as const,
                    ),
                ),
                isTypeAssignableTo,
            ),
        );
    }

    // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
    // be "pushed" onto a node using the contextualType property.
    function getApparentTypeOfContextualType(node: Expression | MethodDeclaration, contextFlags: ContextFlags | undefined): Type | undefined {
        const contextualType = isObjectLiteralMethod(node) ?
            getContextualTypeForObjectLiteralMethod(node, contextFlags) :
            getContextualType(node, contextFlags);
        const instantiatedType = instantiateContextualType(contextualType, node, contextFlags);
        if (instantiatedType && !(contextFlags && contextFlags & ContextFlags.NoConstraints && instantiatedType.flags & TypeFlags.TypeVariable)) {
            const apparentType = mapType(
                instantiatedType,
                // When obtaining apparent type of *contextual* type we don't want to get apparent type of mapped types.
                // That would evaluate mapped types with array or tuple type constraints too eagerly
                // and thus it would prevent `getTypeOfPropertyOfContextualType` from obtaining per-position contextual type for elements of array literal expressions.
                // Apparent type of other mapped types is already the mapped type itself so we can just avoid calling `getApparentType` here for all mapped types.
                t => getObjectFlags(t) & ObjectFlags.Mapped ? t : getApparentType(t),
                /*noReductions*/ true,
            );
            return apparentType.flags & TypeFlags.Union && isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType as UnionType) :
                apparentType.flags & TypeFlags.Union && isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType) :
                apparentType;
        }
    }

    // If the given contextual type contains instantiable types and if a mapper representing
    // return type inferences is available, instantiate those types using that mapper.
    function instantiateContextualType(contextualType: Type | undefined, node: Node, contextFlags: ContextFlags | undefined): Type | undefined {
        if (contextualType && maybeTypeOfKind(contextualType, TypeFlags.Instantiable)) {
            const inferenceContext = getInferenceContext(node);
            // If no inferences have been made, and none of the type parameters for which we are inferring
            // specify default types, nothing is gained from instantiating as type parameters would just be
            // replaced with their constraints similar to the apparent type.
            if (inferenceContext && contextFlags! & ContextFlags.Signature && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault)) {
                // For contextual signatures we incorporate all inferences made so far, e.g. from return
                // types as well as arguments to the left in a function call.
                return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper);
            }
            if (inferenceContext?.returnMapper) {
                // For other purposes (e.g. determining whether to produce literal types) we only
                // incorporate inferences made from the return type in a function call. We remove
                // the 'boolean' type from the contextual type such that contextually typed boolean
                // literals actually end up widening to 'boolean' (see #48363).
                const type = instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper);
                return type.flags & TypeFlags.Union && containsType((type as UnionType).types, regularFalseType) && containsType((type as UnionType).types, regularTrueType) ?
                    filterType(type, t => t !== regularFalseType && t !== regularTrueType) :
                    type;
            }
        }
        return contextualType;
    }

    // This function is similar to instantiateType, except that (a) it only instantiates types that
    // are classified as instantiable (i.e. it doesn't instantiate object types), and (b) it performs
    // no reductions on instantiated union types.
    function instantiateInstantiableTypes(type: Type, mapper: TypeMapper): Type {
        if (type.flags & TypeFlags.Instantiable) {
            return instantiateType(type, mapper);
        }
        if (type.flags & TypeFlags.Union) {
            return getUnionType(map((type as UnionType).types, t => instantiateInstantiableTypes(t, mapper)), UnionReduction.None);
        }
        if (type.flags & TypeFlags.Intersection) {
            return getIntersectionType(map((type as IntersectionType).types, t => instantiateInstantiableTypes(t, mapper)));
        }
        return type;
    }

    /**
     * Whoa! Do you really want to use this function?
     *
     * Unless you're trying to get the *non-apparent* type for a
     * value-literal type or you're authoring relevant portions of this algorithm,
     * you probably meant to use 'getApparentTypeOfContextualType'.
     * Otherwise this may not be very useful.
     *
     * In cases where you *are* working on this function, you should understand
     * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
     *
     *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
     *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
     *
     * @param node the expression whose contextual type will be returned.
     * @returns the contextual type of an expression.
     */
    function getContextualType(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        if (node.flags & NodeFlags.InWithStatement) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return undefined;
        }
        // Cached contextual types are obtained with no ContextFlags, so we can only consult them for
        // requests with no ContextFlags.
        const index = findContextualNode(node, /*includeCaches*/ !contextFlags);
        if (index >= 0) {
            return contextualTypes[index];
        }
        const { parent } = node;
        switch (parent.kind) {
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.BindingElement:
                return getContextualTypeForInitializerExpression(node, contextFlags);
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.ReturnStatement:
                return getContextualTypeForReturnExpression(node, contextFlags);
            case SyntaxKind.YieldExpression:
                return getContextualTypeForYieldOperand(parent as YieldExpression, contextFlags);
            case SyntaxKind.AwaitExpression:
                return getContextualTypeForAwaitOperand(parent as AwaitExpression, contextFlags);
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
                return getContextualTypeForArgument(parent as CallExpression | NewExpression | Decorator, node);
            case SyntaxKind.Decorator:
                return getContextualTypeForDecorator(parent as Decorator);
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.AsExpression:
                return isConstTypeReference((parent as AssertionExpression).type) ? getContextualType(parent as AssertionExpression, contextFlags) : getTypeFromTypeNode((parent as AssertionExpression).type);
            case SyntaxKind.BinaryExpression:
                return getContextualTypeForBinaryOperand(node, contextFlags);
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return getContextualTypeForObjectLiteralElement(parent as PropertyAssignment | ShorthandPropertyAssignment, contextFlags);
            case SyntaxKind.SpreadAssignment:
                return getContextualType(parent.parent as ObjectLiteralExpression, contextFlags);
            case SyntaxKind.ArrayLiteralExpression: {
                const arrayLiteral = parent as ArrayLiteralExpression;
                const type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);
                const elementIndex = indexOfNode(arrayLiteral.elements, node);
                const spreadIndices = getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements);
                return getContextualTypeForElementExpression(type, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last);
            }
            case SyntaxKind.ConditionalExpression:
                return getContextualTypeForConditionalOperand(node, contextFlags);
            case SyntaxKind.TemplateSpan:
                Debug.assert(parent.parent.kind === SyntaxKind.TemplateExpression);
                return getContextualTypeForSubstitutionExpression(parent.parent as TemplateExpression, node);
            case SyntaxKind.ParenthesizedExpression: {
                if (isInJSFile(parent)) {
                    if (isJSDocSatisfiesExpression(parent)) {
                        return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent));
                    }
                    // Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
                    const typeTag = getJSDocTypeTag(parent);
                    if (typeTag && !isConstTypeReference(typeTag.typeExpression.type)) {
                        return getTypeFromTypeNode(typeTag.typeExpression.type);
                    }
                }
                return getContextualType(parent as ParenthesizedExpression, contextFlags);
            }
            case SyntaxKind.NonNullExpression:
                return getContextualType(parent as NonNullExpression, contextFlags);
            case SyntaxKind.SatisfiesExpression:
                return getTypeFromTypeNode((parent as SatisfiesExpression).type);
            case SyntaxKind.ExportAssignment:
                return tryGetTypeFromEffectiveTypeNode(parent as ExportAssignment);
            case SyntaxKind.JsxExpression:
                return getContextualTypeForJsxExpression(parent as JsxExpression, contextFlags);
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.JsxSpreadAttribute:
                return getContextualTypeForJsxAttribute(parent as JsxAttribute | JsxSpreadAttribute, contextFlags);
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return getContextualJsxElementAttributesType(parent as JsxOpeningLikeElement, contextFlags);
            case SyntaxKind.ImportAttribute:
                return getContextualImportAttributeType(parent as ImportAttribute);
        }
        return undefined;
    }

    function pushCachedContextualType(node: Expression) {
        pushContextualType(node, getContextualType(node, /*contextFlags*/ undefined), /*isCache*/ true);
    }

    function pushContextualType(node: Expression, type: Type | undefined, isCache: boolean) {
        contextualTypeNodes[contextualTypeCount] = node;
        contextualTypes[contextualTypeCount] = type;
        contextualIsCache[contextualTypeCount] = isCache;
        contextualTypeCount++;
    }

    function popContextualType() {
        contextualTypeCount--;
    }

    function findContextualNode(node: Node, includeCaches: boolean) {
        for (let i = contextualTypeCount - 1; i >= 0; i--) {
            if (node === contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i])) {
                return i;
            }
        }
        return -1;
    }

    function pushInferenceContext(node: Node, inferenceContext: InferenceContext | undefined) {
        inferenceContextNodes[inferenceContextCount] = node;
        inferenceContexts[inferenceContextCount] = inferenceContext;
        inferenceContextCount++;
    }

    function popInferenceContext() {
        inferenceContextCount--;
    }

    function getInferenceContext(node: Node) {
        for (let i = inferenceContextCount - 1; i >= 0; i--) {
            if (isNodeDescendantOf(node, inferenceContextNodes[i])) {
                return inferenceContexts[i];
            }
        }
    }

    function pushActiveMapper(mapper: TypeMapper) {
        activeTypeMappers[activeTypeMappersCount] = mapper;
        activeTypeMappersCaches[activeTypeMappersCount] = new Map();
        activeTypeMappersCount++;
    }

    function popActiveMapper() {
        activeTypeMappersCount--;
    }

    function findActiveMapper(mapper: TypeMapper) {
        for (let i = activeTypeMappersCount - 1; i >= 0; i--) {
            if (mapper === activeTypeMappers[i]) {
                return i;
            }
        }
        return -1;
    }

    function clearActiveMapperCaches() {
        for (let i = activeTypeMappersCount - 1; i >= 0; i--) {
            activeTypeMappersCaches[i].clear();
        }
    }

    function getContextualImportAttributeType(node: ImportAttribute) {
        return getTypeOfPropertyOfContextualType(getGlobalImportAttributesType(/*reportErrors*/ false), getNameFromImportAttribute(node));
    }

    function getContextualJsxElementAttributesType(node: JsxOpeningLikeElement, contextFlags: ContextFlags | undefined) {
        if (isJsxOpeningElement(node) && contextFlags !== ContextFlags.Completions) {
            const index = findContextualNode(node.parent, /*includeCaches*/ !contextFlags);
            if (index >= 0) {
                // Contextually applied type is moved from attributes up to the outer jsx attributes so when walking up from the children they get hit
                // _However_ to hit them from the _attributes_ we must look for them here; otherwise we'll used the declared type
                // (as below) instead!
                return contextualTypes[index];
            }
        }
        return getContextualTypeForArgumentAtIndex(node, 0);
    }

    function getEffectiveFirstArgumentForJsxSignature(signature: Signature, node: JsxCallLike) {
        return isJsxOpeningFragment(node) || getJsxReferenceKind(node) !== JsxReferenceKind.Component
            ? getJsxPropsTypeFromCallSignature(signature, node)
            : getJsxPropsTypeFromClassType(signature, node);
    }

    function getJsxPropsTypeFromCallSignature(sig: Signature, context: JsxCallLike) {
        let propsType = getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType);
        propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType);
        const intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
        if (!isErrorType(intrinsicAttribs)) {
            propsType = intersectTypes(intrinsicAttribs, propsType);
        }
        return propsType;
    }

    function getJsxPropsTypeForSignatureFromMember(sig: Signature, forcedLookupLocation: __String) {
        if (sig.compositeSignatures) {
            // JSX Elements using the legacy `props`-field based lookup (eg, react class components) need to treat the `props` member as an input
            // instead of an output position when resolving the signature. We need to go back to the input signatures of the composite signature,
            // get the type of `props` on each return type individually, and then _intersect them_, rather than union them (as would normally occur
            // for a union signature). It's an unfortunate quirk of looking in the output of the signature for the type we want to use for the input.
            // The default behavior of `getTypeOfFirstParameterOfSignatureWithFallback` when no `props` member name is defined is much more sane.
            const results: Type[] = [];
            for (const signature of sig.compositeSignatures) {
                const instance = getReturnTypeOfSignature(signature);
                if (isTypeAny(instance)) {
                    return instance;
                }
                const propType = getTypeOfPropertyOfType(instance, forcedLookupLocation);
                if (!propType) {
                    return;
                }
                results.push(propType);
            }
            return getIntersectionType(results); // Same result for both union and intersection signatures
        }
        const instanceType = getReturnTypeOfSignature(sig);
        return isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation);
    }

    function getStaticTypeOfReferencedJsxConstructor(context: JsxCallLike) {
        if (isJsxOpeningFragment(context)) return getJSXFragmentType(context);
        if (isJsxIntrinsicTagName(context.tagName)) {
            const result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context);
            const fakeSignature = createSignatureForJSXIntrinsic(context, result);
            return getOrCreateTypeFromSignature(fakeSignature);
        }
        const tagType = checkExpressionCached(context.tagName);
        if (tagType.flags & TypeFlags.StringLiteral) {
            const result = getIntrinsicAttributesTypeFromStringLiteralType(tagType as StringLiteralType, context);
            if (!result) {
                return errorType;
            }
            const fakeSignature = createSignatureForJSXIntrinsic(context, result);
            return getOrCreateTypeFromSignature(fakeSignature);
        }
        return tagType;
    }

    function getJsxManagedAttributesFromLocatedAttributes(context: JsxCallLike, ns: Symbol, attributesType: Type) {
        const managedSym = getJsxLibraryManagedAttributes(ns);
        if (managedSym) {
            const ctorType = getStaticTypeOfReferencedJsxConstructor(context);
            const result = instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType);
            if (result) {
                return result;
            }
        }
        return attributesType;
    }

    function getJsxPropsTypeFromClassType(sig: Signature, context: JsxOpeningLikeElement) {
        const ns = getJsxNamespaceAt(context);
        const forcedLookupLocation = getJsxElementPropertiesName(ns);
        let attributesType = forcedLookupLocation === undefined
            // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type
            ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
            : forcedLookupLocation === ""
            // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead
            ? getReturnTypeOfSignature(sig)
            // Otherwise get the type of the property on the signature return type
            : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation);

        if (!attributesType) {
            // There is no property named 'props' on this instance type
            if (!!forcedLookupLocation && !!length(context.attributes.properties)) {
                error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation));
            }
            return unknownType;
        }

        attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType);

        if (isTypeAny(attributesType)) {
            // Props is of type 'any' or unknown
            return attributesType;
        }
        else {
            // Normal case -- add in IntrinsicClassElements<T> and IntrinsicElements
            let apparentAttributesType = attributesType;
            const intrinsicClassAttribs = getJsxType(JsxNames.IntrinsicClassAttributes, context);
            if (!isErrorType(intrinsicClassAttribs)) {
                const typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol);
                const hostClassType = getReturnTypeOfSignature(sig);
                let libraryManagedAttributeType: Type;
                if (typeParams) {
                    // apply JSX.IntrinsicClassElements<hostClassType, ...>
                    const inferredArgs = fillMissingTypeArguments([hostClassType], typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context));
                    libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs));
                }
                // or JSX.IntrinsicClassElements has no generics.
                else libraryManagedAttributeType = intrinsicClassAttribs;
                apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType);
            }

            const intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
            if (!isErrorType(intrinsicAttribs)) {
                apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType);
            }

            return apparentAttributesType;
        }
    }

    function getIntersectedSignatures(signatures: readonly Signature[]) {
        return getStrictOptionValue(compilerOptions, "noImplicitAny")
            ? reduceLeft(
                signatures,
                (left: Signature | undefined, right) =>
                    left === right || !left ? left
                        : compareTypeParametersIdentical(left.typeParameters, right!.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right!)
                        : undefined,
            )
            : undefined;
    }

    function combineIntersectionThisParam(left: Symbol | undefined, right: Symbol | undefined, mapper: TypeMapper | undefined): Symbol | undefined {
        if (!left || !right) {
            return left || right;
        }
        // A signature `this` type might be a read or a write position... It's very possible that it should be invariant
        // and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
        // pessimistic when contextual typing, for now, we'll union the `this` types.
        const thisType = getUnionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
        return createSymbolWithType(left, thisType);
    }

    function combineIntersectionParameters(left: Signature, right: Signature, mapper: TypeMapper | undefined) {
        const leftCount = getParameterCount(left);
        const rightCount = getParameterCount(right);
        const longest = leftCount >= rightCount ? left : right;
        const shorter = longest === left ? right : left;
        const longestCount = longest === left ? leftCount : rightCount;
        const eitherHasEffectiveRest = hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right);
        const needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
        const params = new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0));
        for (let i = 0; i < longestCount; i++) {
            let longestParamType = tryGetTypeAtPosition(longest, i)!;
            if (longest === right) {
                longestParamType = instantiateType(longestParamType, mapper);
            }
            let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
            if (shorter === right) {
                shorterParamType = instantiateType(shorterParamType, mapper);
            }
            const unionParamType = getUnionType([longestParamType, shorterParamType]);
            const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
            const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
            const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
            const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);

            const paramName = leftName === rightName ? leftName :
                !leftName ? rightName :
                !rightName ? leftName :
                undefined;
            const paramSymbol = createSymbol(
                SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),
                paramName || `arg${i}` as __String,
                isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0,
            );
            paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
            params[i] = paramSymbol;
        }
        if (needsExtraRestElement) {
            const restParamSymbol = createSymbol(SymbolFlags.FunctionScopedVariable, "args" as __String, CheckFlags.RestParameter);
            restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount));
            if (shorter === right) {
                restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper);
            }
            params[longestCount] = restParamSymbol;
        }
        return params;
    }

    function combineSignaturesOfIntersectionMembers(left: Signature, right: Signature): Signature {
        const typeParams = left.typeParameters || right.typeParameters;
        let paramMapper: TypeMapper | undefined;
        if (left.typeParameters && right.typeParameters) {
            paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
            // We just use the type parameter defaults from the first signature
        }
        let flags = (left.flags | right.flags) & (SignatureFlags.PropagatingFlags & ~SignatureFlags.HasRestParameter);
        const declaration = left.declaration;
        const params = combineIntersectionParameters(left, right, paramMapper);
        const lastParam = lastOrUndefined(params);
        if (lastParam && getCheckFlags(lastParam) & CheckFlags.RestParameter) {
            flags |= SignatureFlags.HasRestParameter;
        }
        const thisParam = combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper);
        const minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
        const result = createSignature(
            declaration,
            typeParams,
            thisParam,
            params,
            /*resolvedReturnType*/ undefined,
            /*resolvedTypePredicate*/ undefined,
            minArgCount,
            flags,
        );
        result.compositeKind = TypeFlags.Intersection;
        result.compositeSignatures = concatenate(left.compositeKind === TypeFlags.Intersection && left.compositeSignatures || [left], [right]);
        if (paramMapper) {
            result.mapper = left.compositeKind === TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
        }
        return result;
    }

    // If the given type is an object or union type with a single signature, and if that signature has at
    // least as many parameters as the given function, return the signature. Otherwise return undefined.
    function getContextualCallSignature(type: Type, node: SignatureDeclaration): Signature | undefined {
        const signatures = getSignaturesOfType(type, SignatureKind.Call);
        const applicableByArity = filter(signatures, s => !isAritySmaller(s, node));
        return applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity);
    }

    /** If the contextual signature has fewer parameters than the function expression, do not use it */
    function isAritySmaller(signature: Signature, target: SignatureDeclaration) {
        let targetParameterCount = 0;
        for (; targetParameterCount < target.parameters.length; targetParameterCount++) {
            const param = target.parameters[targetParameterCount];
            if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {
                break;
            }
        }
        if (target.parameters.length && parameterIsThisKeyword(target.parameters[0])) {
            targetParameterCount--;
        }
        return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount;
    }

    function getContextualSignatureForFunctionLikeDeclaration(node: FunctionLikeDeclaration): Signature | undefined {
        // Only function expressions, arrow functions, and object literal methods are contextually typed.
        return isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node)
            ? getContextualSignature(node as FunctionExpression)
            : undefined;
    }

    // Return the contextual signature for a given expression node. A contextual type provides a
    // contextual signature if it has a single call signature and if that call signature is non-generic.
    // If the contextual type is a union type, get the signature from each type possible and if they are
    // all identical ignoring their return type, the result is same signature but with return type as
    // union type of return types from these signatures
    function getContextualSignature(node: FunctionExpression | ArrowFunction | MethodDeclaration): Signature | undefined {
        Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));
        const typeTagSignature = getSignatureOfTypeTag(node);
        if (typeTagSignature) {
            return typeTagSignature;
        }
        const type = getApparentTypeOfContextualType(node, ContextFlags.Signature);
        if (!type) {
            return undefined;
        }
        if (!(type.flags & TypeFlags.Union)) {
            return getContextualCallSignature(type, node);
        }
        let signatureList: Signature[] | undefined;
        const types = (type as UnionType).types;
        for (const current of types) {
            const signature = getContextualCallSignature(current, node);
            if (signature) {
                if (!signatureList) {
                    // This signature will contribute to contextual union signature
                    signatureList = [signature];
                }
                else if (!compareSignaturesIdentical(signatureList[0], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true, compareTypesIdentical)) {
                    // Signatures aren't identical, do not use
                    return undefined;
                }
                else {
                    // Use this signature for contextual union signature
                    signatureList.push(signature);
                }
            }
        }
        // Result is union of signatures collected (return type is union of return types of this signature set)
        if (signatureList) {
            return signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList);
        }
    }

    function checkGrammarRegularExpressionLiteral(node: RegularExpressionLiteral) {
        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile) && !node.isUnterminated) {
            let lastError: DiagnosticWithLocation | undefined;
            scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia*/ true);
            scanner.setScriptTarget(sourceFile.languageVersion);
            scanner.setLanguageVariant(sourceFile.languageVariant);
            scanner.setOnError((message, length, arg0) => {
                // For providing spelling suggestions
                const start = scanner!.getTokenEnd();
                if (message.category === DiagnosticCategory.Message && lastError && start === lastError.start && length === lastError.length) {
                    const error = createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0);
                    addRelatedInfo(lastError, error);
                }
                else if (!lastError || start !== lastError.start) {
                    lastError = createFileDiagnostic(sourceFile, start, length, message, arg0);
                    diagnostics.add(lastError);
                }
            });
            scanner.setText(sourceFile.text, node.pos, node.end - node.pos);
            try {
                scanner.scan();
                Debug.assert(scanner.reScanSlashToken(/*reportErrors*/ true) === SyntaxKind.RegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral");
                return !!lastError;
            }
            finally {
                scanner.setText("");
                scanner.setOnError(/*onError*/ undefined);
            }
        }
        return false;
    }

    function checkRegularExpressionLiteral(node: RegularExpressionLiteral) {
        const nodeLinks = getNodeLinks(node);
        if (!(nodeLinks.flags & NodeCheckFlags.TypeChecked)) {
            nodeLinks.flags |= NodeCheckFlags.TypeChecked;
            addLazyDiagnostic(() => checkGrammarRegularExpressionLiteral(node));
        }
        return globalRegExpType;
    }

    function checkSpreadExpression(node: SpreadElement, checkMode?: CheckMode): Type {
        if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {
            checkExternalEmitHelpers(node, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);
        }

        const arrayOrIterableType = checkExpression(node.expression, checkMode);
        return checkIteratedTypeOrElementType(IterationUse.Spread, arrayOrIterableType, undefinedType, node.expression);
    }

    function checkSyntheticExpression(node: SyntheticExpression): Type {
        return node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type;
    }

    function hasDefaultValue(node: BindingElement | ObjectLiteralElementLike | Expression): boolean {
        return node.kind === SyntaxKind.BindingElement && !!(node as BindingElement).initializer ||
            node.kind === SyntaxKind.PropertyAssignment && hasDefaultValue((node as PropertyAssignment).initializer) ||
            node.kind === SyntaxKind.ShorthandPropertyAssignment && !!(node as ShorthandPropertyAssignment).objectAssignmentInitializer ||
            node.kind === SyntaxKind.BinaryExpression && (node as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken;
    }

    function isSpreadIntoCallOrNew(node: ArrayLiteralExpression) {
        const parent = walkUpParenthesizedExpressions(node.parent);
        return isSpreadElement(parent) && isCallOrNewExpression(parent.parent);
    }

    function checkArrayLiteral(node: ArrayLiteralExpression, checkMode: CheckMode | undefined, forceTuple: boolean | undefined): Type {
        const elements = node.elements;
        const elementCount = elements.length;
        const elementTypes: Type[] = [];
        const elementFlags: ElementFlags[] = [];
        pushCachedContextualType(node);
        const inDestructuringPattern = isAssignmentTarget(node);
        const inConstContext = isConstContext(node);
        const contextualType = getApparentTypeOfContextualType(node, /*contextFlags*/ undefined);
        const inTupleContext = isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType, t => isTupleLikeType(t) || isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target as MappedType || t));

        let hasOmittedExpression = false;
        for (let i = 0; i < elementCount; i++) {
            const e = elements[i];
            if (e.kind === SyntaxKind.SpreadElement) {
                if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {
                    checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);
                }
                const spreadType = checkExpression((e as SpreadElement).expression, checkMode, forceTuple);
                if (isArrayLikeType(spreadType)) {
                    elementTypes.push(spreadType);
                    elementFlags.push(ElementFlags.Variadic);
                }
                else if (inDestructuringPattern) {
                    // Given the following situation:
                    //    var c: {};
                    //    [...c] = ["", 0];
                    //
                    // c is represented in the tree as a spread element in an array literal.
                    // But c really functions as a rest element, and its purpose is to provide
                    // a contextual type for the right hand side of the assignment. Therefore,
                    // instead of calling checkExpression on "...c", which will give an error
                    // if c is not iterable/array-like, we need to act as if we are trying to
                    // get the contextual element type from it. So we do something similar to
                    // getContextualTypeForElementExpression, which will crucially not error
                    // if there is no index type / iterated type.
                    const restElementType = getIndexTypeOfType(spreadType, numberType) ||
                        getIteratedTypeOrElementType(IterationUse.Destructuring, spreadType, undefinedType, /*errorNode*/ undefined, /*checkAssignability*/ false) ||
                        unknownType;
                    elementTypes.push(restElementType);
                    elementFlags.push(ElementFlags.Rest);
                }
                else {
                    elementTypes.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, (e as SpreadElement).expression));
                    elementFlags.push(ElementFlags.Rest);
                }
            }
            else if (exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression) {
                hasOmittedExpression = true;
                elementTypes.push(undefinedOrMissingType);
                elementFlags.push(ElementFlags.Optional);
            }
            else {
                const type = checkExpressionForMutableLocation(e, checkMode, forceTuple);
                elementTypes.push(addOptionality(type, /*isProperty*/ true, hasOmittedExpression));
                elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);
                if (inTupleContext && checkMode && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(e)) {
                    const inferenceContext = getInferenceContext(node);
                    Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context
                    addIntraExpressionInferenceSite(inferenceContext, e, type);
                }
            }
        }
        popContextualType();
        if (inDestructuringPattern) {
            return createTupleType(elementTypes, elementFlags);
        }
        if (forceTuple || inConstContext || inTupleContext) {
            return createArrayLiteralType(createTupleType(elementTypes, elementFlags, /*readonly*/ inConstContext && !(contextualType && someType(contextualType, isMutableArrayLikeType))));
        }
        return createArrayLiteralType(createArrayType(
            elementTypes.length ?
                getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), UnionReduction.Subtype) :
                strictNullChecks ? implicitNeverType : undefinedWideningType,
            inConstContext,
        ));
    }

    function createArrayLiteralType(type: Type) {
        if (!(getObjectFlags(type) & ObjectFlags.Reference)) {
            return type;
        }
        let literalType = (type as TypeReference).literalType;
        if (!literalType) {
            literalType = (type as TypeReference).literalType = cloneTypeReference(type as TypeReference);
            literalType.objectFlags |= ObjectFlags.ArrayLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
        }
        return literalType;
    }

    function isNumericName(name: DeclarationName): boolean {
        switch (name.kind) {
            case SyntaxKind.ComputedPropertyName:
                return isNumericComputedName(name);
            case SyntaxKind.Identifier:
                return isNumericLiteralName(name.escapedText);
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.StringLiteral:
                return isNumericLiteralName(name.text);
            default:
                return false;
        }
    }

    function isNumericComputedName(name: ComputedPropertyName): boolean {
        // It seems odd to consider an expression of type Any to result in a numeric name,
        // but this behavior is consistent with checkIndexedAccess
        return isTypeAssignableToKind(checkComputedPropertyName(name), TypeFlags.NumberLike);
    }

    function checkComputedPropertyName(node: ComputedPropertyName): Type {
        const links = getNodeLinks(node.expression);
        if (!links.resolvedType) {
            if (
                (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent))
                && isBinaryExpression(node.expression) && node.expression.operatorToken.kind === SyntaxKind.InKeyword
                && node.parent.kind !== SyntaxKind.GetAccessor && node.parent.kind !== SyntaxKind.SetAccessor
            ) {
                return links.resolvedType = errorType;
            }
            links.resolvedType = checkExpression(node.expression);
            // The computed property name of a non-static class field within a loop must be stored in a block-scoped binding.
            // (It needs to be bound at class evaluation time.)
            if (isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent)) {
                const container = getEnclosingBlockScopeContainer(node.parent.parent);
                const enclosingIterationStatement = getEnclosingIterationStatement(container);
                if (enclosingIterationStatement) {
                    // The computed field name will use a block scoped binding which can be unique for each iteration of the loop.
                    getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
                    // The generated variable which stores the computed field name must be block-scoped.
                    getNodeLinks(node).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
                    // The generated variable which stores the class must be block-scoped.
                    getNodeLinks(node.parent.parent).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
                }
            }
            // This will allow types number, string, symbol or any. It will also allow enums, the unknown
            // type, and any union of these types (like string | number).
            if (
                links.resolvedType.flags & TypeFlags.Nullable ||
                !isTypeAssignableToKind(links.resolvedType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike) &&
                    !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType)
            ) {
                error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
            }
        }

        return links.resolvedType;
    }

    function isSymbolWithNumericName(symbol: Symbol) {
        const firstDecl = symbol.declarations?.[0];
        return isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name));
    }

    function isSymbolWithSymbolName(symbol: Symbol) {
        const firstDecl = symbol.declarations?.[0];
        return isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) &&
            isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), TypeFlags.ESSymbol));
    }

    function isSymbolWithComputedName(symbol: Symbol) {
        const firstDecl = symbol.declarations?.[0];
        return firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name);
    }

    // NOTE: currently does not make pattern literal indexers, eg `${number}px`
    function getObjectLiteralIndexInfo(isReadonly: boolean, offset: number, properties: Symbol[], keyType: Type): IndexInfo {
        const propTypes: Type[] = [];
        let components: ElementWithComputedPropertyName[] | undefined;
        for (let i = offset; i < properties.length; i++) {
            const prop = properties[i];
            if (
                keyType === stringType && !isSymbolWithSymbolName(prop) ||
                keyType === numberType && isSymbolWithNumericName(prop) ||
                keyType === esSymbolType && isSymbolWithSymbolName(prop)
            ) {
                propTypes.push(getTypeOfSymbol(properties[i]));
                if (isSymbolWithComputedName(properties[i])) {
                    components = append(components, properties[i].declarations?.[0]! as ElementWithComputedPropertyName);
                }
            }
        }
        const unionType = propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType;
        return createIndexInfo(keyType, unionType, isReadonly, /*declaration*/ undefined, components);
    }

    function getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined {
        Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here.");
        const links = getSymbolLinks(symbol);
        if (!links.immediateTarget) {
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            links.immediateTarget = getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve*/ true);
        }

        return links.immediateTarget;
    }

    function checkObjectLiteral(node: ObjectLiteralExpression, checkMode: CheckMode = CheckMode.Normal): Type {
        const inDestructuringPattern = isAssignmentTarget(node);
        // Grammar checking
        checkGrammarObjectLiteralExpression(node, inDestructuringPattern);

        const allPropertiesTable = strictNullChecks ? createSymbolTable() : undefined;
        let propertiesTable = createSymbolTable();
        let propertiesArray: Symbol[] = [];
        let spread: Type = emptyObjectType;

        pushCachedContextualType(node);
        const contextualType = getApparentTypeOfContextualType(node, /*contextFlags*/ undefined);
        const contextualTypeHasPattern = contextualType && contextualType.pattern &&
            (contextualType.pattern.kind === SyntaxKind.ObjectBindingPattern || contextualType.pattern.kind === SyntaxKind.ObjectLiteralExpression);
        const inConstContext = isConstContext(node);
        const checkFlags = inConstContext ? CheckFlags.Readonly : 0;
        const isInJavascript = isInJSFile(node) && !isInJsonFile(node);
        const enumTag = isInJavascript ? getJSDocEnumTag(node) : undefined;
        const isJSObjectLiteral = !contextualType && isInJavascript && !enumTag;
        let objectFlags: ObjectFlags = ObjectFlags.FreshLiteral;
        let patternWithComputedProperties = false;
        let hasComputedStringProperty = false;
        let hasComputedNumberProperty = false;
        let hasComputedSymbolProperty = false;

        // Spreads may cause an early bail; ensure computed names are always checked (this is cached)
        // As otherwise they may not be checked until exports for the type at this position are retrieved,
        // which may never occur.
        for (const elem of node.properties) {
            if (elem.name && isComputedPropertyName(elem.name)) {
                checkComputedPropertyName(elem.name);
            }
        }

        let offset = 0;
        for (const memberDecl of node.properties) {
            let member = getSymbolOfDeclaration(memberDecl);
            const computedNameType = memberDecl.name && memberDecl.name.kind === SyntaxKind.ComputedPropertyName ?
                checkComputedPropertyName(memberDecl.name) : undefined;
            if (
                memberDecl.kind === SyntaxKind.PropertyAssignment ||
                memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ||
                isObjectLiteralMethod(memberDecl)
            ) {
                let type = memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(memberDecl, checkMode) :
                    // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring
                    // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.
                    // we don't want to say "could not find 'a'".
                    memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) :
                    checkObjectLiteralMethod(memberDecl, checkMode);
                if (isInJavascript) {
                    const jsDocType = getTypeForDeclarationFromJSDocComment(memberDecl);
                    if (jsDocType) {
                        checkTypeAssignableTo(type, jsDocType, memberDecl);
                        type = jsDocType;
                    }
                    else if (enumTag && enumTag.typeExpression) {
                        checkTypeAssignableTo(type, getTypeFromTypeNode(enumTag.typeExpression), memberDecl);
                    }
                }
                objectFlags |= getObjectFlags(type) & ObjectFlags.PropagatingFlags;
                const nameType = computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined;
                const prop = nameType ?
                    createSymbol(SymbolFlags.Property | member.flags, getPropertyNameFromType(nameType), checkFlags | CheckFlags.Late) :
                    createSymbol(SymbolFlags.Property | member.flags, member.escapedName, checkFlags);
                if (nameType) {
                    prop.links.nameType = nameType;
                }

                if (inDestructuringPattern && hasDefaultValue(memberDecl)) {
                    // If object literal is an assignment pattern and if the assignment pattern specifies a default value
                    // for the property, make the property optional.
                    prop.flags |= SymbolFlags.Optional;
                }
                else if (contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlags.ObjectLiteralPatternWithComputedProperties)) {
                    // If object literal is contextually typed by the implied type of a binding pattern, and if the
                    // binding pattern specifies a default value for the property, make the property optional.
                    const impliedProp = getPropertyOfType(contextualType, member.escapedName);
                    if (impliedProp) {
                        prop.flags |= impliedProp.flags & SymbolFlags.Optional;
                    }
                    else if (!getIndexInfoOfType(contextualType, stringType)) {
                        error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType));
                    }
                }

                prop.declarations = member.declarations;
                prop.parent = member.parent;
                if (member.valueDeclaration) {
                    prop.valueDeclaration = member.valueDeclaration;
                }

                prop.links.type = type;
                prop.links.target = member;
                member = prop;
                allPropertiesTable?.set(prop.escapedName, prop);

                if (
                    contextualType && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) &&
                    (memberDecl.kind === SyntaxKind.PropertyAssignment || memberDecl.kind === SyntaxKind.MethodDeclaration) && isContextSensitive(memberDecl)
                ) {
                    const inferenceContext = getInferenceContext(node);
                    Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context
                    const inferenceNode = memberDecl.kind === SyntaxKind.PropertyAssignment ? memberDecl.initializer : memberDecl;
                    addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type);
                }
            }
            else if (memberDecl.kind === SyntaxKind.SpreadAssignment) {
                if (languageVersion < LanguageFeatureMinimumTarget.ObjectAssign) {
                    checkExternalEmitHelpers(memberDecl, ExternalEmitHelpers.Assign);
                }
                if (propertiesArray.length > 0) {
                    spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
                    propertiesArray = [];
                    propertiesTable = createSymbolTable();
                    hasComputedStringProperty = false;
                    hasComputedNumberProperty = false;
                    hasComputedSymbolProperty = false;
                }
                const type = getReducedType(checkExpression(memberDecl.expression, checkMode & CheckMode.Inferential));
                if (isValidSpreadType(type)) {
                    const mergedType = tryMergeUnionOfObjectTypeAndEmptyObject(type, inConstContext);
                    if (allPropertiesTable) {
                        checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl);
                    }
                    offset = propertiesArray.length;
                    if (isErrorType(spread)) {
                        continue;
                    }
                    spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext);
                }
                else {
                    error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types);
                    spread = errorType;
                }
                continue;
            }
            else {
                // TypeScript 1.0 spec (April 2014)
                // A get accessor declaration is processed in the same manner as
                // an ordinary function declaration(section 6.1) with no parameters.
                // A set accessor declaration is processed in the same manner
                // as an ordinary function declaration with a single parameter and a Void return type.
                Debug.assert(memberDecl.kind === SyntaxKind.GetAccessor || memberDecl.kind === SyntaxKind.SetAccessor);
                checkNodeDeferred(memberDecl);
            }

            if (computedNameType && !(computedNameType.flags & TypeFlags.StringOrNumberLiteralOrUnique)) {
                if (isTypeAssignableTo(computedNameType, stringNumberSymbolType)) {
                    if (isTypeAssignableTo(computedNameType, numberType)) {
                        hasComputedNumberProperty = true;
                    }
                    else if (isTypeAssignableTo(computedNameType, esSymbolType)) {
                        hasComputedSymbolProperty = true;
                    }
                    else {
                        hasComputedStringProperty = true;
                    }
                    if (inDestructuringPattern) {
                        patternWithComputedProperties = true;
                    }
                }
            }
            else {
                propertiesTable.set(member.escapedName, member);
            }
            propertiesArray.push(member);
        }
        popContextualType();

        if (isErrorType(spread)) {
            return errorType;
        }

        if (spread !== emptyObjectType) {
            if (propertiesArray.length > 0) {
                spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
                propertiesArray = [];
                propertiesTable = createSymbolTable();
                hasComputedStringProperty = false;
                hasComputedNumberProperty = false;
            }
            // remap the raw emptyObjectType fed in at the top into a fresh empty object literal type, unique to this use site
            return mapType(spread, t => t === emptyObjectType ? createObjectLiteralType() : t);
        }

        return createObjectLiteralType();

        function createObjectLiteralType() {
            const indexInfos = [];
            const isReadonly = isConstContext(node);
            if (hasComputedStringProperty) indexInfos.push(getObjectLiteralIndexInfo(isReadonly, offset, propertiesArray, stringType));
            if (hasComputedNumberProperty) indexInfos.push(getObjectLiteralIndexInfo(isReadonly, offset, propertiesArray, numberType));
            if (hasComputedSymbolProperty) indexInfos.push(getObjectLiteralIndexInfo(isReadonly, offset, propertiesArray, esSymbolType));
            const result = createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos);
            result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
            if (isJSObjectLiteral) {
                result.objectFlags |= ObjectFlags.JSLiteral;
            }
            if (patternWithComputedProperties) {
                result.objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;
            }
            if (inDestructuringPattern) {
                result.pattern = node;
            }
            return result;
        }
    }

    function isValidSpreadType(type: Type): boolean {
        const t = removeDefinitelyFalsyTypes(mapType(type, getBaseConstraintOrType));
        return !!(t.flags & (TypeFlags.Any | TypeFlags.NonPrimitive | TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ||
            t.flags & TypeFlags.UnionOrIntersection && every((t as UnionOrIntersectionType).types, isValidSpreadType));
    }

    function checkJsxSelfClosingElementDeferred(node: JsxSelfClosingElement) {
        checkJsxOpeningLikeElementOrOpeningFragment(node);
    }

    function checkJsxSelfClosingElement(node: JsxSelfClosingElement, _checkMode: CheckMode | undefined): Type {
        checkNodeDeferred(node);
        return getJsxElementTypeAt(node) || anyType;
    }

    function checkJsxElementDeferred(node: JsxElement) {
        // Check attributes
        checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement);

        // Perform resolution on the closing tag so that rename/go to definition/etc work
        if (isJsxIntrinsicTagName(node.closingElement.tagName)) {
            getIntrinsicTagSymbol(node.closingElement);
        }
        else {
            checkExpression(node.closingElement.tagName);
        }

        checkJsxChildren(node);
    }

    function checkJsxElement(node: JsxElement, _checkMode: CheckMode | undefined): Type {
        checkNodeDeferred(node);

        return getJsxElementTypeAt(node) || anyType;
    }

    function checkJsxFragment(node: JsxFragment): Type {
        checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment);

        // by default, jsx:'react' will use jsxFactory = React.createElement and jsxFragmentFactory = React.Fragment
        // if jsxFactory compiler option is provided, ensure jsxFragmentFactory compiler option or @jsxFrag pragma is provided too
        const nodeSourceFile = getSourceFileOfNode(node);
        if (
            getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx"))
            && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag")
        ) {
            error(
                node,
                compilerOptions.jsxFactory
                    ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option
                    : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments,
            );
        }

        checkJsxChildren(node);
        const jsxElementType = getJsxElementTypeAt(node);
        return isErrorType(jsxElementType) ? anyType : jsxElementType;
    }

    function isHyphenatedJsxName(name: string | __String) {
        return (name as string).includes("-");
    }

    /**
     * Returns true iff React would emit this tag name as a string rather than an identifier or qualified name
     */
    function isJsxIntrinsicTagName(tagName: Node): tagName is Identifier | JsxNamespacedName {
        return isIdentifier(tagName) && isIntrinsicJsxName(tagName.escapedText) || isJsxNamespacedName(tagName);
    }

    function checkJsxAttribute(node: JsxAttribute, checkMode?: CheckMode) {
        return node.initializer
            ? checkExpressionForMutableLocation(node.initializer, checkMode)
            : trueType; // <Elem attr /> is sugar for <Elem attr={true} />
    }

    /**
     * Get attributes type of the JSX opening-like element. The result is from resolving "attributes" property of the opening-like element.
     *
     * @param openingLikeElement a JSX opening-like element
     * @param filter a function to remove attributes that will not participate in checking whether attributes are assignable
     * @return an anonymous type (similar to the one returned by checkObjectLiteral) in which its properties are attributes property.
     * @remarks Because this function calls getSpreadType, it needs to use the same checks as checkObjectLiteral,
     * which also calls getSpreadType.
     */
    function createJsxAttributesTypeFromAttributesProperty(openingLikeElement: JsxCallLike, checkMode: CheckMode = CheckMode.Normal) {
        const allAttributesTable = strictNullChecks ? createSymbolTable() : undefined;
        let attributesTable = createSymbolTable();
        let spread: Type = emptyJsxObjectType;
        let hasSpreadAnyType = false;
        let typeToIntersect: Type | undefined;
        let explicitlySpecifyChildrenAttribute = false;
        let objectFlags: ObjectFlags = ObjectFlags.JsxAttributes;
        const jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement));

        const isJsxOpenFragment = isJsxOpeningFragment(openingLikeElement);

        let attributesSymbol: Symbol | undefined;
        let attributeParent: Node = openingLikeElement;
        if (!isJsxOpenFragment) {
            const attributes = openingLikeElement.attributes;
            attributesSymbol = attributes.symbol;
            attributeParent = attributes;
            const contextualType = getContextualType(attributes, ContextFlags.None);
            for (const attributeDecl of attributes.properties) {
                const member = attributeDecl.symbol;
                if (isJsxAttribute(attributeDecl)) {
                    const exprType = checkJsxAttribute(attributeDecl, checkMode);
                    objectFlags |= getObjectFlags(exprType) & ObjectFlags.PropagatingFlags;

                    const attributeSymbol = createSymbol(SymbolFlags.Property | member.flags, member.escapedName);
                    attributeSymbol.declarations = member.declarations;
                    attributeSymbol.parent = member.parent;
                    if (member.valueDeclaration) {
                        attributeSymbol.valueDeclaration = member.valueDeclaration;
                    }
                    attributeSymbol.links.type = exprType;
                    attributeSymbol.links.target = member;
                    attributesTable.set(attributeSymbol.escapedName, attributeSymbol);
                    allAttributesTable?.set(attributeSymbol.escapedName, attributeSymbol);
                    if (getEscapedTextOfJsxAttributeName(attributeDecl.name) === jsxChildrenPropertyName) {
                        explicitlySpecifyChildrenAttribute = true;
                    }
                    if (contextualType) {
                        const prop = getPropertyOfType(contextualType, member.escapedName);
                        if (prop && prop.declarations && isDeprecatedSymbol(prop) && isIdentifier(attributeDecl.name)) {
                            addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText as string);
                        }
                    }
                    if (contextualType && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(attributeDecl)) {
                        const inferenceContext = getInferenceContext(attributes);
                        Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context
                        const inferenceNode = (attributeDecl.initializer as JsxExpression).expression!;
                        addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType);
                    }
                }
                else {
                    Debug.assert(attributeDecl.kind === SyntaxKind.JsxSpreadAttribute);
                    if (attributesTable.size > 0) {
                        spread = getSpreadType(spread, createJsxAttributesTypeHelper(), attributes.symbol, objectFlags, /*readonly*/ false);
                        attributesTable = createSymbolTable();
                    }
                    const exprType = getReducedType(checkExpression(attributeDecl.expression, checkMode & CheckMode.Inferential));
                    if (isTypeAny(exprType)) {
                        hasSpreadAnyType = true;
                    }
                    if (isValidSpreadType(exprType)) {
                        spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, /*readonly*/ false);
                        if (allAttributesTable) {
                            checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl);
                        }
                    }
                    else {
                        error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types);
                        typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType;
                    }
                }
            }

            if (!hasSpreadAnyType) {
                if (attributesTable.size > 0) {
                    spread = getSpreadType(spread, createJsxAttributesTypeHelper(), attributes.symbol, objectFlags, /*readonly*/ false);
                }
            }
        }

        // Handle children attribute
        const parent = openingLikeElement.parent;
        // We have to check that openingElement of the parent is the one we are visiting as this may not be true for selfClosingElement
        if (
            (isJsxElement(parent) && parent.openingElement === openingLikeElement || isJsxFragment(parent) && parent.openingFragment === openingLikeElement) &&
            getSemanticJsxChildren(parent.children).length > 0
        ) {
            const childrenTypes: Type[] = checkJsxChildren(parent, checkMode);

            if (!hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== "") {
                // Error if there is a attribute named "children" explicitly specified and children element.
                // This is because children element will overwrite the value from attributes.
                // Note: we will not warn "children" attribute overwritten if "children" attribute is specified in object spread.
                if (explicitlySpecifyChildrenAttribute) {
                    error(attributeParent, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName));
                }

                const contextualType = isJsxOpeningElement(openingLikeElement) ? getApparentTypeOfContextualType(openingLikeElement.attributes, /*contextFlags*/ undefined) : undefined;
                const childrenContextualType = contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName);
                // If there are children in the body of JSX element, create dummy attribute "children" with the union of children types so that it will pass the attribute checking process
                const childrenPropSymbol = createSymbol(SymbolFlags.Property, jsxChildrenPropertyName);
                childrenPropSymbol.links.type = childrenTypes.length === 1 ? childrenTypes[0] :
                    childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) :
                    createArrayType(getUnionType(childrenTypes));
                // Fake up a property declaration for the children
                childrenPropSymbol.valueDeclaration = factory.createPropertySignature(/*modifiers*/ undefined, unescapeLeadingUnderscores(jsxChildrenPropertyName), /*questionToken*/ undefined, /*type*/ undefined);
                setParent(childrenPropSymbol.valueDeclaration, attributeParent);
                childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol;
                const childPropMap = createSymbolTable();
                childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol);
                spread = getSpreadType(spread, createAnonymousType(attributesSymbol, childPropMap, emptyArray, emptyArray, emptyArray), attributesSymbol, objectFlags, /*readonly*/ false);
            }
        }

        if (hasSpreadAnyType) {
            return anyType;
        }
        if (typeToIntersect && spread !== emptyJsxObjectType) {
            return getIntersectionType([typeToIntersect, spread]);
        }
        return typeToIntersect || (spread === emptyJsxObjectType ? createJsxAttributesTypeHelper() : spread);

        function createJsxAttributesTypeHelper() {
            objectFlags |= ObjectFlags.FreshLiteral;
            return createJsxAttributesType(objectFlags, attributesSymbol, attributesTable);
        }
    }
    /**
     * Create anonymous type from given attributes symbol table.
     * @param symbol a symbol of JsxAttributes containing attributes corresponding to attributesTable
     * @param attributesTable a symbol table of attributes property
     */
    function createJsxAttributesType(objectFlags: ObjectFlags, attributesSymbol: Symbol | undefined, attributesTable: SymbolTable): Type {
        const result = createAnonymousType(attributesSymbol, attributesTable, emptyArray, emptyArray, emptyArray);
        result.objectFlags |= objectFlags | ObjectFlags.FreshLiteral | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
        return result;
    }

    function checkJsxChildren(node: JsxElement | JsxFragment, checkMode?: CheckMode) {
        const childrenTypes: Type[] = [];
        for (const child of node.children) {
            // In React, JSX text that contains only whitespaces will be ignored so we don't want to type-check that
            // because then type of children property will have constituent of string type.
            if (child.kind === SyntaxKind.JsxText) {
                if (!child.containsOnlyTriviaWhiteSpaces) {
                    childrenTypes.push(stringType);
                }
            }
            else if (child.kind === SyntaxKind.JsxExpression && !child.expression) {
                continue; // empty jsx expressions don't *really* count as present children
            }
            else {
                childrenTypes.push(checkExpressionForMutableLocation(child, checkMode));
            }
        }
        return childrenTypes;
    }

    function checkSpreadPropOverrides(type: Type, props: SymbolTable, spread: SpreadAssignment | JsxSpreadAttribute) {
        for (const right of getPropertiesOfType(type)) {
            if (!(right.flags & SymbolFlags.Optional)) {
                const left = props.get(right.escapedName);
                if (left) {
                    const diagnostic = error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName));
                    addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property));
                }
            }
        }
    }

    /**
     * Check attributes property of opening-like element. This function is called during chooseOverload to get call signature of a JSX opening-like element.
     * (See "checkApplicableSignatureForJsxOpeningLikeElement" for how the function is used)
     * @param node a JSXAttributes to be resolved of its type
     */
    function checkJsxAttributes(node: JsxAttributes, checkMode: CheckMode | undefined) {
        return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode);
    }

    function getJsxType(name: __String, location: Node | undefined) {
        const namespace = getJsxNamespaceAt(location);
        const exports = namespace && getExportsOfSymbol(namespace);
        const typeSymbol = exports && getSymbol(exports, name, SymbolFlags.Type);
        return typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType;
    }

    /**
     * Looks up an intrinsic tag name and returns a symbol that either points to an intrinsic
     * property (in which case nodeLinks.jsxFlags will be IntrinsicNamedElement) or an intrinsic
     * string index signature (in which case nodeLinks.jsxFlags will be IntrinsicIndexedElement).
     * May also return unknownSymbol if both of these lookups fail.
     */
    function getIntrinsicTagSymbol(node: JsxOpeningLikeElement | JsxClosingElement): Symbol {
        const links = getNodeLinks(node);
        if (!links.resolvedSymbol) {
            const intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, node);
            if (!isErrorType(intrinsicElementsType)) {
                // Property case
                if (!isIdentifier(node.tagName) && !isJsxNamespacedName(node.tagName)) return Debug.fail();
                const propName = isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText;
                const intrinsicProp = getPropertyOfType(intrinsicElementsType, propName);
                if (intrinsicProp) {
                    links.jsxFlags |= JsxFlags.IntrinsicNamedElement;
                    return links.resolvedSymbol = intrinsicProp;
                }

                // Intrinsic string indexer case
                const indexSymbol = getApplicableIndexSymbol(intrinsicElementsType, getStringLiteralType(unescapeLeadingUnderscores(propName)));
                if (indexSymbol) {
                    links.jsxFlags |= JsxFlags.IntrinsicIndexedElement;
                    return links.resolvedSymbol = indexSymbol;
                }

                if (getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName)) {
                    links.jsxFlags |= JsxFlags.IntrinsicIndexedElement;
                    return links.resolvedSymbol = intrinsicElementsType.symbol;
                }

                // Wasn't found
                error(node, Diagnostics.Property_0_does_not_exist_on_type_1, intrinsicTagNameToString(node.tagName), "JSX." + JsxNames.IntrinsicElements);
                return links.resolvedSymbol = unknownSymbol;
            }
            else {
                if (noImplicitAny) {
                    error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements));
                }
                return links.resolvedSymbol = unknownSymbol;
            }
        }
        return links.resolvedSymbol;
    }

    function getJsxNamespaceContainerForImplicitImport(location: Node | undefined): Symbol | undefined {
        const file = location && getSourceFileOfNode(location);
        const links = file && getNodeLinks(file);
        if (links && links.jsxImplicitImportContainer === false) {
            return undefined;
        }
        if (links && links.jsxImplicitImportContainer) {
            return links.jsxImplicitImportContainer;
        }
        const runtimeImportSpecifier = getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions);
        if (!runtimeImportSpecifier) {
            return undefined;
        }
        const isClassic = getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Classic;
        const errorMessage = isClassic
            ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option
            : Diagnostics.This_JSX_tag_requires_the_module_path_0_to_exist_but_none_could_be_found_Make_sure_you_have_types_for_the_appropriate_package_installed;
        const specifier = getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier);
        const mod = resolveExternalModule(specifier || location!, runtimeImportSpecifier, errorMessage, location);
        const result = mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : undefined;
        if (links) {
            links.jsxImplicitImportContainer = result || false;
        }
        return result;
    }

    function getJsxNamespaceAt(location: Node | undefined): Symbol {
        const links = location && getNodeLinks(location);
        if (links && links.jsxNamespace) {
            return links.jsxNamespace;
        }
        if (!links || links.jsxNamespace !== false) {
            let resolvedNamespace = getJsxNamespaceContainerForImplicitImport(location);

            if (!resolvedNamespace || resolvedNamespace === unknownSymbol) {
                const namespaceName = getJsxNamespace(location);
                resolvedNamespace = resolveName(location, namespaceName, SymbolFlags.Namespace, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
            }

            if (resolvedNamespace) {
                const candidate = resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), JsxNames.JSX, SymbolFlags.Namespace));
                if (candidate && candidate !== unknownSymbol) {
                    if (links) {
                        links.jsxNamespace = candidate;
                    }
                    return candidate;
                }
            }
            if (links) {
                links.jsxNamespace = false;
            }
        }
        // JSX global fallback
        const s = resolveSymbol(getGlobalSymbol(JsxNames.JSX, SymbolFlags.Namespace, /*diagnostic*/ undefined));
        if (s === unknownSymbol) {
            return undefined!; // TODO: GH#18217
        }
        return s!; // TODO: GH#18217
    }

    /**
     * Look into JSX namespace and then look for container with matching name as nameOfAttribPropContainer.
     * Get a single property from that container if existed. Report an error if there are more than one property.
     *
     * @param nameOfAttribPropContainer a string of value JsxNames.ElementAttributesPropertyNameContainer or JsxNames.ElementChildrenAttributeNameContainer
     *          if other string is given or the container doesn't exist, return undefined.
     */
    function getNameFromJsxElementAttributesContainer(nameOfAttribPropContainer: __String, jsxNamespace: Symbol): __String | undefined {
        // JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [symbol]
        const jsxElementAttribPropInterfaceSym = jsxNamespace && getSymbol(jsxNamespace.exports!, nameOfAttribPropContainer, SymbolFlags.Type);
        // JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [type]
        const jsxElementAttribPropInterfaceType = jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym);
        // The properties of JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute
        const propertiesOfJsxElementAttribPropInterface = jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType);
        if (propertiesOfJsxElementAttribPropInterface) {
            // Element Attributes has zero properties, so the element attributes type will be the class instance type
            if (propertiesOfJsxElementAttribPropInterface.length === 0) {
                return "" as __String;
            }
            // Element Attributes has one property, so the element attributes type will be the type of the corresponding
            // property of the class instance type
            else if (propertiesOfJsxElementAttribPropInterface.length === 1) {
                return propertiesOfJsxElementAttribPropInterface[0].escapedName;
            }
            else if (propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations) {
                // More than one property on ElementAttributesProperty is an error
                error(jsxElementAttribPropInterfaceSym.declarations[0], Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer));
            }
        }
        return undefined;
    }

    function getJsxLibraryManagedAttributes(jsxNamespace: Symbol) {
        // JSX.LibraryManagedAttributes [symbol]
        return jsxNamespace && getSymbol(jsxNamespace.exports!, JsxNames.LibraryManagedAttributes, SymbolFlags.Type);
    }

    function getJsxElementTypeSymbol(jsxNamespace: Symbol) {
        // JSX.ElementType [symbol]
        return jsxNamespace && getSymbol(jsxNamespace.exports!, JsxNames.ElementType, SymbolFlags.Type);
    }

    /// e.g. "props" for React.d.ts,
    /// or 'undefined' if ElementAttributesProperty doesn't exist (which means all
    ///     non-intrinsic elements' attributes type is 'any'),
    /// or '' if it has 0 properties (which means every
    ///     non-intrinsic elements' attributes type is the element instance type)
    function getJsxElementPropertiesName(jsxNamespace: Symbol) {
        return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace);
    }

    function getJsxElementChildrenPropertyName(jsxNamespace: Symbol): __String | undefined {
        if (compilerOptions.jsx === JsxEmit.ReactJSX || compilerOptions.jsx === JsxEmit.ReactJSXDev) {
            // In these JsxEmit modes the children property is fixed to 'children'
            return "children" as __String;
        }
        return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace);
    }

    function getUninstantiatedJsxSignaturesOfType(elementType: Type, caller: JsxCallLike): readonly Signature[] {
        if (elementType.flags & TypeFlags.String) {
            return [anySignature];
        }
        else if (elementType.flags & TypeFlags.StringLiteral) {
            const intrinsicType = getIntrinsicAttributesTypeFromStringLiteralType(elementType as StringLiteralType, caller);
            if (!intrinsicType) {
                error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, (elementType as StringLiteralType).value, "JSX." + JsxNames.IntrinsicElements);
                return emptyArray;
            }
            else {
                const fakeSignature = createSignatureForJSXIntrinsic(caller, intrinsicType);
                return [fakeSignature];
            }
        }
        const apparentElemType = getApparentType(elementType);
        // Resolve the signatures, preferring constructor
        let signatures = getSignaturesOfType(apparentElemType, SignatureKind.Construct);
        if (signatures.length === 0) {
            // No construct signatures, try call signatures
            signatures = getSignaturesOfType(apparentElemType, SignatureKind.Call);
        }
        if (signatures.length === 0 && apparentElemType.flags & TypeFlags.Union) {
            // If each member has some combination of new/call signatures; make a union signature list for those
            signatures = getUnionSignatures(map((apparentElemType as UnionType).types, t => getUninstantiatedJsxSignaturesOfType(t, caller)));
        }
        return signatures;
    }

    function getIntrinsicAttributesTypeFromStringLiteralType(type: StringLiteralType, location: Node): Type | undefined {
        // If the elemType is a stringLiteral type, we can then provide a check to make sure that the string literal type is one of the Jsx intrinsic element type
        // For example:
        //      var CustomTag: "h1" = "h1";
        //      <CustomTag> Hello World </CustomTag>
        const intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, location);
        if (!isErrorType(intrinsicElementsType)) {
            const stringLiteralTypeName = type.value;
            const intrinsicProp = getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName));
            if (intrinsicProp) {
                return getTypeOfSymbol(intrinsicProp);
            }
            const indexSignatureType = getIndexTypeOfType(intrinsicElementsType, stringType);
            if (indexSignatureType) {
                return indexSignatureType;
            }
            return undefined;
        }
        // If we need to report an error, we already done so here. So just return any to prevent any more error downstream
        return anyType;
    }

    function checkJsxReturnAssignableToAppropriateBound(refKind: JsxReferenceKind, elemInstanceType: Type, openingLikeElement: JsxOpeningLikeElement) {
        if (refKind === JsxReferenceKind.Function) {
            const sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
            if (sfcReturnConstraint) {
                checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
            }
        }
        else if (refKind === JsxReferenceKind.Component) {
            const classConstraint = getJsxElementClassTypeAt(openingLikeElement);
            if (classConstraint) {
                // Issue an error if this return type isn't assignable to JSX.ElementClass, failing that
                checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
            }
        }
        else { // Mixed
            const sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
            const classConstraint = getJsxElementClassTypeAt(openingLikeElement);
            if (!sfcReturnConstraint || !classConstraint) {
                return;
            }
            const combined = getUnionType([sfcReturnConstraint, classConstraint]);
            checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
        }

        function generateInitialErrorChain(): DiagnosticMessageChain {
            const componentName = getTextOfNode(openingLikeElement.tagName);
            return chainDiagnosticMessages(/*details*/ undefined, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName);
        }
    }

    /**
     * Get attributes type of the given intrinsic opening-like Jsx element by resolving the tag name.
     * The function is intended to be called from a function which has checked that the opening element is an intrinsic element.
     * @param node an intrinsic JSX opening-like element
     */
    function getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node: JsxOpeningLikeElement): Type {
        Debug.assert(isJsxIntrinsicTagName(node.tagName));
        const links = getNodeLinks(node);
        if (!links.resolvedJsxElementAttributesType) {
            const symbol = getIntrinsicTagSymbol(node);
            if (links.jsxFlags & JsxFlags.IntrinsicNamedElement) {
                return links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType;
            }
            else if (links.jsxFlags & JsxFlags.IntrinsicIndexedElement) {
                const propName = isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText;
                return links.resolvedJsxElementAttributesType = getApplicableIndexInfoForName(getJsxType(JsxNames.IntrinsicElements, node), propName)?.type || errorType;
            }
            else {
                return links.resolvedJsxElementAttributesType = errorType;
            }
        }
        return links.resolvedJsxElementAttributesType;
    }

    function getJsxElementClassTypeAt(location: Node): Type | undefined {
        const type = getJsxType(JsxNames.ElementClass, location);
        if (isErrorType(type)) return undefined;
        return type;
    }

    function getJsxElementTypeAt(location: Node): Type {
        return getJsxType(JsxNames.Element, location);
    }

    function getJsxStatelessElementTypeAt(location: Node): Type | undefined {
        const jsxElementType = getJsxElementTypeAt(location);
        if (jsxElementType) {
            return getUnionType([jsxElementType, nullType]);
        }
    }

    function getJsxElementTypeTypeAt(location: Node): Type | undefined {
        const ns = getJsxNamespaceAt(location);
        if (!ns) return undefined;
        const sym = getJsxElementTypeSymbol(ns);
        if (!sym) return undefined;
        const type = instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location));
        if (!type || isErrorType(type)) return undefined;
        return type;
    }

    function instantiateAliasOrInterfaceWithDefaults(managedSym: Symbol, inJs: boolean, ...typeArguments: Type[]) {
        const declaredManagedType = getDeclaredTypeOfSymbol(managedSym); // fetches interface type, or initializes symbol links type parmaeters
        if (managedSym.flags & SymbolFlags.TypeAlias) {
            const params = getSymbolLinks(managedSym).typeParameters;
            if (length(params) >= typeArguments.length) {
                const args = fillMissingTypeArguments(typeArguments, params, typeArguments.length, inJs);
                return length(args) === 0 ? declaredManagedType : getTypeAliasInstantiation(managedSym, args);
            }
        }
        if (length((declaredManagedType as GenericType).typeParameters) >= typeArguments.length) {
            const args = fillMissingTypeArguments(typeArguments, (declaredManagedType as GenericType).typeParameters, typeArguments.length, inJs);
            return createTypeReference(declaredManagedType as GenericType, args);
        }
        return undefined;
    }

    /**
     * Returns all the properties of the Jsx.IntrinsicElements interface
     */
    function getJsxIntrinsicTagNamesAt(location: Node): Symbol[] {
        const intrinsics = getJsxType(JsxNames.IntrinsicElements, location);
        return intrinsics ? getPropertiesOfType(intrinsics) : emptyArray;
    }

    function checkJsxPreconditions(errorNode: Node) {
        // Preconditions for using JSX
        if ((compilerOptions.jsx || JsxEmit.None) === JsxEmit.None) {
            error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided);
        }

        if (getJsxElementTypeAt(errorNode) === undefined) {
            if (noImplicitAny) {
                error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist);
            }
        }
    }

    function checkJsxOpeningLikeElementOrOpeningFragment(node: JsxOpeningLikeElement | JsxOpeningFragment) {
        const isNodeOpeningLikeElement = isJsxOpeningLikeElement(node);

        if (isNodeOpeningLikeElement) {
            checkGrammarJsxElement(node);
        }

        checkJsxPreconditions(node);

        markJsxAliasReferenced(node);

        const sig = getResolvedSignature(node);
        checkDeprecatedSignature(sig, node);

        if (isNodeOpeningLikeElement) {
            const jsxOpeningLikeNode = node;
            const elementTypeConstraint = getJsxElementTypeTypeAt(jsxOpeningLikeNode);
            if (elementTypeConstraint !== undefined) {
                const tagName = jsxOpeningLikeNode.tagName;
                const tagType = isJsxIntrinsicTagName(tagName)
                    ? getStringLiteralType(intrinsicTagNameToString(tagName))
                    : checkExpression(tagName);
                checkTypeRelatedTo(tagType, elementTypeConstraint, assignableRelation, tagName, Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type, () => {
                    const componentName = getTextOfNode(tagName);
                    return chainDiagnosticMessages(/*details*/ undefined, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName);
                });
            }
            else {
                checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode);
            }
        }
    }

    /**
     * Check if a property with the given name is known anywhere in the given type. In an object type, a property
     * is considered known if
     * 1. the object type is empty and the check is for assignability, or
     * 2. if the object type has index signatures, or
     * 3. if the property is actually declared in the object type
     *    (this means that 'toString', for example, is not usually a known property).
     * 4. In a union or intersection type,
     *    a property is considered known if it is known in any constituent type.
     * @param targetType a type to search a given name in
     * @param name a property name to search
     * @param isComparingJsxAttributes a boolean flag indicating whether we are searching in JsxAttributesType
     */
    function isKnownProperty(targetType: Type, name: __String, isComparingJsxAttributes: boolean): boolean {
        if (targetType.flags & TypeFlags.Object) {
            // For backwards compatibility a symbol-named property is satisfied by a string index signature. This
            // is incorrect and inconsistent with element access expressions, where it is an error, so eventually
            // we should remove this exception.
            if (
                getPropertyOfObjectType(targetType, name) ||
                getApplicableIndexInfoForName(targetType, name) ||
                isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) ||
                isComparingJsxAttributes && isHyphenatedJsxName(name)
            ) {
                // For JSXAttributes, if the attribute has a hyphenated name, consider that the attribute to be known.
                return true;
            }
        }
        if (targetType.flags & TypeFlags.Substitution) {
            return isKnownProperty((targetType as SubstitutionType).baseType, name, isComparingJsxAttributes);
        }
        if (targetType.flags & TypeFlags.UnionOrIntersection && isExcessPropertyCheckTarget(targetType)) {
            for (const t of (targetType as UnionOrIntersectionType).types) {
                if (isKnownProperty(t, name, isComparingJsxAttributes)) {
                    return true;
                }
            }
        }
        return false;
    }

    function isExcessPropertyCheckTarget(type: Type): boolean {
        return !!(type.flags & TypeFlags.Object && !(getObjectFlags(type) & ObjectFlags.ObjectLiteralPatternWithComputedProperties) ||
            type.flags & TypeFlags.NonPrimitive ||
            type.flags & TypeFlags.Substitution && isExcessPropertyCheckTarget((type as SubstitutionType).baseType) ||
            type.flags & TypeFlags.Union && some((type as UnionType).types, isExcessPropertyCheckTarget) ||
            type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isExcessPropertyCheckTarget));
    }

    function checkJsxExpression(node: JsxExpression, checkMode?: CheckMode) {
        checkGrammarJsxExpression(node);
        if (node.expression) {
            const type = checkExpression(node.expression, checkMode);
            if (node.dotDotDotToken && type !== anyType && !isArrayType(type)) {
                error(node, Diagnostics.JSX_spread_child_must_be_an_array_type);
            }
            return type;
        }
        else {
            return errorType;
        }
    }

    function getDeclarationNodeFlagsFromSymbol(s: Symbol): NodeFlags {
        return s.valueDeclaration ? getCombinedNodeFlagsCached(s.valueDeclaration) : 0;
    }

    /**
     * Return whether this symbol is a member of a prototype somewhere
     * Note that this is not tracked well within the compiler, so the answer may be incorrect.
     */
    function isPrototypeProperty(symbol: Symbol) {
        if (symbol.flags & SymbolFlags.Method || getCheckFlags(symbol) & CheckFlags.SyntheticMethod) {
            return true;
        }
        if (isInJSFile(symbol.valueDeclaration)) {
            const parent = symbol.valueDeclaration!.parent;
            return parent && isBinaryExpression(parent) &&
                getAssignmentDeclarationKind(parent) === AssignmentDeclarationKind.PrototypeProperty;
        }
    }

    /**
     * Check whether the requested property access is valid.
     * Returns true if node is a valid property access, and false otherwise.
     * @param node The node to be checked.
     * @param isSuper True if the access is from `super.`.
     * @param type The type of the object whose property is being accessed. (Not the type of the property.)
     * @param prop The symbol for the property being accessed.
     */
    function checkPropertyAccessibility(
        node: PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement,
        isSuper: boolean,
        writing: boolean,
        type: Type,
        prop: Symbol,
        reportError = true,
    ): boolean {
        const errorNode = !reportError ? undefined :
            node.kind === SyntaxKind.QualifiedName ? node.right :
            node.kind === SyntaxKind.ImportType ? node :
            node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name;

        return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type, prop, errorNode);
    }

    /**
     * Check whether the requested property can be accessed at the requested location.
     * Returns true if node is a valid property access, and false otherwise.
     * @param location The location node where we want to check if the property is accessible.
     * @param isSuper True if the access is from `super.`.
     * @param writing True if this is a write property access, false if it is a read property access.
     * @param containingType The type of the object whose property is being accessed. (Not the type of the property.)
     * @param prop The symbol for the property being accessed.
     * @param errorNode The node where we should report an invalid property access error, or undefined if we should not report errors.
     */
    function checkPropertyAccessibilityAtLocation(location: Node, isSuper: boolean, writing: boolean, containingType: Type, prop: Symbol, errorNode?: Node): boolean {
        const flags = getDeclarationModifierFlagsFromSymbol(prop, writing);

        if (isSuper) {
            // TS 1.0 spec (April 2014): 4.8.2
            // - In a constructor, instance member function, instance member accessor, or
            //   instance member variable initializer where this references a derived class instance,
            //   a super property access is permitted and must specify a public instance member function of the base class.
            // - In a static member function or static member accessor
            //   where this references the constructor function object of a derived class,
            //   a super property access is permitted and must specify a public static member function of the base class.
            if (languageVersion < ScriptTarget.ES2015) {
                if (symbolHasNonMethodDeclaration(prop)) {
                    if (errorNode) {
                        error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                    }
                    return false;
                }
            }
            if (flags & ModifierFlags.Abstract) {
                // A method cannot be accessed in a super property access if the method is abstract.
                // This error could mask a private property access error. But, a member
                // cannot simultaneously be private and abstract, so this will trigger an
                // additional error elsewhere.
                if (errorNode) {
                    error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)!));
                }
                return false;
            }
            // A class field cannot be accessed via super.* from a derived class.
            // This is true for both [[Set]] (old) and [[Define]] (ES spec) semantics.
            if (!(flags & ModifierFlags.Static) && prop.declarations?.some(isClassInstanceProperty)) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, symbolToString(prop));
                }
                return false;
            }
        }

        // Referencing abstract properties within their own constructors is not allowed
        if (
            (flags & ModifierFlags.Abstract) && symbolHasNonMethodDeclaration(prop) &&
            (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent))
        ) {
            const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!);
            if (declaringClassDeclaration && isNodeUsedDuringClassInitialization(location)) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name!));
                }
                return false;
            }
        }

        // Public properties are otherwise accessible.
        if (!(flags & ModifierFlags.NonPublicAccessibilityModifier)) {
            return true;
        }

        // Property is known to be private or protected at this point

        // Private property is accessible if the property is within the declaring class
        if (flags & ModifierFlags.Private) {
            const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!)!;
            if (!isNodeWithinClass(location, declaringClassDeclaration)) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)!));
                }
                return false;
            }
            return true;
        }

        // Property is known to be protected at this point

        // All protected properties of a supertype are accessible in a super access
        if (isSuper) {
            return true;
        }

        // Find the first enclosing class that has the declaring classes of the protected constituents
        // of the property as base classes
        let enclosingClass = forEachEnclosingClass(location, enclosingDeclaration => {
            const enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration)) as InterfaceType;
            return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);
        });
        // A protected property is accessible if the property is within the declaring class or classes derived from it
        if (!enclosingClass) {
            // allow PropertyAccessibility if context is in function with this parameter
            // static member access is disallowed
            enclosingClass = getEnclosingClassFromThisParameter(location);
            enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);
            if (flags & ModifierFlags.Static || !enclosingClass) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType));
                }
                return false;
            }
        }
        // No further restrictions for static properties
        if (flags & ModifierFlags.Static) {
            return true;
        }
        if (containingType.flags & TypeFlags.TypeParameter) {
            // get the original type -- represented as the type constraint of the 'this' type
            containingType = (containingType as TypeParameter).isThisType ? getConstraintOfTypeParameter(containingType as TypeParameter)! : getBaseConstraintOfType(containingType as TypeParameter)!; // TODO: GH#18217 Use a different variable that's allowed to be undefined
        }
        if (!containingType || !hasBaseType(containingType, enclosingClass)) {
            if (errorNode) {
                error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType));
            }
            return false;
        }
        return true;
    }

    function getEnclosingClassFromThisParameter(node: Node): InterfaceType | undefined {
        // 'this' type for a node comes from, in priority order...
        // 1. The type of a syntactic 'this' parameter in the enclosing function scope
        const thisParameter = getThisParameterFromNodeContext(node);
        let thisType = thisParameter?.type && getTypeFromTypeNode(thisParameter.type);
        if (thisType) {
            // 2. The constraint of a type parameter used for an explicit 'this' parameter
            if (thisType.flags & TypeFlags.TypeParameter) {
                thisType = getConstraintOfTypeParameter(thisType as TypeParameter);
            }
        }
        else {
            // 3. The 'this' parameter of a contextual type
            const thisContainer = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
            if (isFunctionLike(thisContainer)) {
                thisType = getContextualThisParameterType(thisContainer);
            }
        }
        if (thisType && getObjectFlags(thisType) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference)) {
            return getTargetType(thisType) as InterfaceType;
        }
        return undefined;
    }

    function getThisParameterFromNodeContext(node: Node) {
        const thisContainer = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
        return thisContainer && isFunctionLike(thisContainer) ? getThisParameter(thisContainer) : undefined;
    }

    function symbolHasNonMethodDeclaration(symbol: Symbol) {
        return !!forEachProperty(symbol, prop => !(prop.flags & SymbolFlags.Method));
    }

    function checkNonNullExpression(node: Expression | QualifiedName) {
        return checkNonNullType(checkExpression(node), node);
    }

    function isNullableType(type: Type) {
        return hasTypeFacts(type, TypeFacts.IsUndefinedOrNull);
    }

    function getNonNullableTypeIfNeeded(type: Type) {
        return isNullableType(type) ? getNonNullableType(type) : type;
    }

    function reportObjectPossiblyNullOrUndefinedError(node: Node, facts: TypeFacts) {
        const nodeText = isEntityNameExpression(node) ? entityNameToString(node) : undefined;
        if (node.kind === SyntaxKind.NullKeyword) {
            error(node, Diagnostics.The_value_0_cannot_be_used_here, "null");
            return;
        }
        if (nodeText !== undefined && nodeText.length < 100) {
            if (isIdentifier(node) && nodeText === "undefined") {
                error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined");
                return;
            }
            error(
                node,
                facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?
                    Diagnostics._0_is_possibly_null_or_undefined :
                    Diagnostics._0_is_possibly_undefined :
                    Diagnostics._0_is_possibly_null,
                nodeText,
            );
        }
        else {
            error(
                node,
                facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?
                    Diagnostics.Object_is_possibly_null_or_undefined :
                    Diagnostics.Object_is_possibly_undefined :
                    Diagnostics.Object_is_possibly_null,
            );
        }
    }

    function reportCannotInvokePossiblyNullOrUndefinedError(node: Node, facts: TypeFacts) {
        error(
            node,
            facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?
                Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined :
                Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined :
                Diagnostics.Cannot_invoke_an_object_which_is_possibly_null,
        );
    }

    function checkNonNullTypeWithReporter(
        type: Type,
        node: Node,
        reportError: (node: Node, facts: TypeFacts) => void,
    ): Type {
        if (strictNullChecks && type.flags & TypeFlags.Unknown) {
            if (isEntityNameExpression(node)) {
                const nodeText = entityNameToString(node);
                if (nodeText.length < 100) {
                    error(node, Diagnostics._0_is_of_type_unknown, nodeText);
                    return errorType;
                }
            }
            error(node, Diagnostics.Object_is_of_type_unknown);
            return errorType;
        }
        const facts = getTypeFacts(type, TypeFacts.IsUndefinedOrNull);
        if (facts & TypeFacts.IsUndefinedOrNull) {
            reportError(node, facts);
            const t = getNonNullableType(type);
            return t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t;
        }
        return type;
    }

    function checkNonNullType(type: Type, node: Node) {
        return checkNonNullTypeWithReporter(type, node, reportObjectPossiblyNullOrUndefinedError);
    }

    function checkNonNullNonVoidType(type: Type, node: Node): Type {
        const nonNullType = checkNonNullType(type, node);
        if (nonNullType.flags & TypeFlags.Void) {
            if (isEntityNameExpression(node)) {
                const nodeText = entityNameToString(node);
                if (isIdentifier(node) && nodeText === "undefined") {
                    error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText);
                    return nonNullType;
                }
                if (nodeText.length < 100) {
                    error(node, Diagnostics._0_is_possibly_undefined, nodeText);
                    return nonNullType;
                }
            }
            error(node, Diagnostics.Object_is_possibly_undefined);
        }
        return nonNullType;
    }

    function checkPropertyAccessExpression(node: PropertyAccessExpression, checkMode: CheckMode | undefined, writeOnly?: boolean) {
        return node.flags & NodeFlags.OptionalChain ? checkPropertyAccessChain(node as PropertyAccessChain, checkMode) :
            checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode, writeOnly);
    }

    function checkPropertyAccessChain(node: PropertyAccessChain, checkMode: CheckMode | undefined) {
        const leftType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(leftType, node.expression);
        return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType !== leftType);
    }

    function checkQualifiedName(node: QualifiedName, checkMode: CheckMode | undefined) {
        const leftType = isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left);
        return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode);
    }

    function isMethodAccessForCall(node: Node) {
        while (node.parent.kind === SyntaxKind.ParenthesizedExpression) {
            node = node.parent;
        }
        return isCallOrNewExpression(node.parent) && node.parent.expression === node;
    }

    // Lookup the private identifier lexically.
    function lookupSymbolForPrivateIdentifierDeclaration(propName: __String, location: Node): Symbol | undefined {
        for (let containingClass = getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass)) {
            const { symbol } = containingClass;
            const name = getSymbolNameForPrivateIdentifier(symbol, propName);
            const prop = (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name));
            if (prop) {
                return prop;
            }
        }
    }

    function checkGrammarPrivateIdentifierExpression(privId: PrivateIdentifier): boolean {
        if (!getContainingClass(privId)) {
            return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
        }

        if (!isForInStatement(privId.parent)) {
            if (!isExpressionNode(privId)) {
                return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression);
            }

            const isInOperation = isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind === SyntaxKind.InKeyword;
            if (!getSymbolForPrivateIdentifierExpression(privId) && !isInOperation) {
                return grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId));
            }
        }

        return false;
    }

    function checkPrivateIdentifierExpression(privId: PrivateIdentifier): Type {
        checkGrammarPrivateIdentifierExpression(privId);
        const symbol = getSymbolForPrivateIdentifierExpression(privId);
        if (symbol) {
            markPropertyAsReferenced(symbol, /*nodeForCheckWriteOnly*/ undefined, /*isSelfTypeAccess*/ false);
        }
        return anyType;
    }

    function getSymbolForPrivateIdentifierExpression(privId: PrivateIdentifier): Symbol | undefined {
        if (!isExpressionNode(privId)) {
            return undefined;
        }

        const links = getNodeLinks(privId);
        if (links.resolvedSymbol === undefined) {
            links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId);
        }
        return links.resolvedSymbol;
    }

    function getPrivateIdentifierPropertyOfType(leftType: Type, lexicallyScopedIdentifier: Symbol): Symbol | undefined {
        return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName);
    }

    function checkPrivateIdentifierPropertyAccess(leftType: Type, right: PrivateIdentifier, lexicallyScopedIdentifier: Symbol | undefined): boolean {
        // Either the identifier could not be looked up in the lexical scope OR the lexically scoped identifier did not exist on the type.
        // Find a private identifier with the same description on the type.
        let propertyOnType: Symbol | undefined;
        const properties = getPropertiesOfType(leftType);
        if (properties) {
            forEach(properties, (symbol: Symbol) => {
                const decl = symbol.valueDeclaration;
                if (decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText === right.escapedText) {
                    propertyOnType = symbol;
                    return true;
                }
            });
        }
        const diagName = diagnosticName(right);
        if (propertyOnType) {
            const typeValueDecl = Debug.checkDefined(propertyOnType.valueDeclaration);
            const typeClass = Debug.checkDefined(getContainingClass(typeValueDecl));
            // We found a private identifier property with the same description.
            // Either:
            // - There is a lexically scoped private identifier AND it shadows the one we found on the type.
            // - It is an attempt to access the private identifier outside of the class.
            if (lexicallyScopedIdentifier?.valueDeclaration) {
                const lexicalValueDecl = lexicallyScopedIdentifier.valueDeclaration;
                const lexicalClass = getContainingClass(lexicalValueDecl);
                Debug.assert(!!lexicalClass);
                if (findAncestor(lexicalClass, n => typeClass === n)) {
                    const diagnostic = error(
                        right,
                        Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling,
                        diagName,
                        typeToString(leftType),
                    );

                    addRelatedInfo(
                        diagnostic,
                        createDiagnosticForNode(
                            lexicalValueDecl,
                            Diagnostics.The_shadowing_declaration_of_0_is_defined_here,
                            diagName,
                        ),
                        createDiagnosticForNode(
                            typeValueDecl,
                            Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here,
                            diagName,
                        ),
                    );
                    return true;
                }
            }
            error(
                right,
                Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier,
                diagName,
                diagnosticName(typeClass.name || anon),
            );
            return true;
        }
        return false;
    }

    function isThisPropertyAccessInConstructor(node: ElementAccessExpression | PropertyAccessExpression | QualifiedName, prop: Symbol) {
        return (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop))
            && getThisContainer(node, /*includeArrowFunctions*/ true, /*includeClassComputedPropertyName*/ false) === getDeclaringConstructor(prop);
    }

    function checkPropertyAccessExpressionOrQualifiedName(node: PropertyAccessExpression | QualifiedName, left: Expression | QualifiedName, leftType: Type, right: Identifier | PrivateIdentifier, checkMode: CheckMode | undefined, writeOnly?: boolean) {
        const parentSymbol = getNodeLinks(left).resolvedSymbol;
        const assignmentKind = getAssignmentTargetKind(node);
        const apparentType = getApparentType(assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType);
        const isAnyLike = isTypeAny(apparentType) || apparentType === silentNeverType;
        let prop: Symbol | undefined;
        if (isPrivateIdentifier(right)) {
            if (
                languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||
                languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators ||
                !useDefineForClassFields
            ) {
                if (assignmentKind !== AssignmentKind.None) {
                    checkExternalEmitHelpers(node, ExternalEmitHelpers.ClassPrivateFieldSet);
                }
                if (assignmentKind !== AssignmentKind.Definite) {
                    checkExternalEmitHelpers(node, ExternalEmitHelpers.ClassPrivateFieldGet);
                }
            }

            const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right);
            if (assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration)) {
                grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right));
            }
            if (isAnyLike) {
                if (lexicallyScopedSymbol) {
                    return isErrorType(apparentType) ? errorType : apparentType;
                }
                if (getContainingClassExcludingClassDecorators(right) === undefined) {
                    grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
                    return anyType;
                }
            }

            prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol);
            if (prop === undefined) {
                // Check for private-identifier-specific shadowing and lexical-scoping errors.
                if (checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol)) {
                    return errorType;
                }
                const containingClass = getContainingClassExcludingClassDecorators(right);
                if (containingClass && isPlainJsFile(getSourceFileOfNode(containingClass), compilerOptions.checkJs)) {
                    grammarErrorOnNode(right, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class, idText(right));
                }
            }
            else {
                const isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
                if (isSetonlyAccessor && assignmentKind !== AssignmentKind.Definite) {
                    error(node, Diagnostics.Private_accessor_was_defined_without_a_getter);
                }
            }
        }
        else {
            if (isAnyLike) {
                if (isIdentifier(left) && parentSymbol) {
                    markLinkedReferences(node, ReferenceHint.Property, /*propSymbol*/ undefined, leftType);
                }
                return isErrorType(apparentType) ? errorType : apparentType;
            }
            prop = getPropertyOfType(apparentType, right.escapedText, /*skipObjectFunctionPropertyAugment*/ isConstEnumObjectType(apparentType), /*includeTypeOnlyMembers*/ node.kind === SyntaxKind.QualifiedName);
        }
        markLinkedReferences(node, ReferenceHint.Property, prop, leftType);

        let propType: Type;
        if (!prop) {
            const indexInfo = !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)) ?
                getApplicableIndexInfoForName(apparentType, right.escapedText) : undefined;
            if (!(indexInfo && indexInfo.type)) {
                const isUncheckedJS = isUncheckedJSSuggestion(node, leftType.symbol, /*excludeClasses*/ true);
                if (!isUncheckedJS && isJSLiteralType(leftType)) {
                    return anyType;
                }
                if (leftType.symbol === globalThisSymbol) {
                    if (globalThisSymbol.exports!.has(right.escapedText) && (globalThisSymbol.exports!.get(right.escapedText)!.flags & SymbolFlags.BlockScoped)) {
                        error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType));
                    }
                    else if (noImplicitAny) {
                        error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType));
                    }
                    return anyType;
                }
                if (right.escapedText && !checkAndReportErrorForExtendingInterface(node)) {
                    reportNonexistentProperty(right, isThisTypeParameter(leftType) ? apparentType : leftType, isUncheckedJS);
                }
                return errorType;
            }
            if (indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node))) {
                error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType));
            }

            propType = indexInfo.type;
            if (compilerOptions.noUncheckedIndexedAccess && getAssignmentTargetKind(node) !== AssignmentKind.Definite) {
                propType = getUnionType([propType, missingType]);
            }
            if (compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node)) {
                error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText));
            }
            if (indexInfo.declaration && isDeprecatedDeclaration(indexInfo.declaration)) {
                addDeprecatedSuggestion(right, [indexInfo.declaration], right.escapedText as string);
            }
        }
        else {
            const targetPropSymbol = resolveAliasWithDeprecationCheck(prop, right);
            if (isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations) {
                addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.escapedText as string);
            }
            checkPropertyNotUsedBeforeDeclaration(prop, node, right);
            markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol));
            getNodeLinks(node).resolvedSymbol = prop;
            checkPropertyAccessibility(node, left.kind === SyntaxKind.SuperKeyword, isWriteAccess(node), apparentType, prop);
            if (isAssignmentToReadonlyEntity(node as Expression, prop, assignmentKind)) {
                error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right));
                return errorType;
            }

            propType = isThisPropertyAccessInConstructor(node, prop) ? autoType : writeOnly || isWriteOnlyAccess(node) ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop);
        }

        return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode);
    }

    /**
     * Determines whether a did-you-mean error should be a suggestion in an unchecked JS file.
     * Only applies to unchecked JS files without checkJS, // @ts-check or // @ts-nocheck
     * It does not suggest when the suggestion:
     * - Is from a global file that is different from the reference file, or
     * - (optionally) Is a class, or is a this.x property access expression
     */
    function isUncheckedJSSuggestion(node: Node | undefined, suggestion: Symbol | undefined, excludeClasses: boolean): boolean {
        const file = getSourceFileOfNode(node);
        if (file) {
            if (compilerOptions.checkJs === undefined && file.checkJsDirective === undefined && (file.scriptKind === ScriptKind.JS || file.scriptKind === ScriptKind.JSX)) {
                const declarationFile = forEach(suggestion?.declarations, getSourceFileOfNode);
                const suggestionHasNoExtendsOrDecorators = !suggestion?.valueDeclaration
                    || !isClassLike(suggestion.valueDeclaration)
                    || suggestion.valueDeclaration.heritageClauses?.length
                    || classOrConstructorParameterIsDecorated(/*useLegacyDecorators*/ false, suggestion.valueDeclaration);
                return !(file !== declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile))
                    && !(excludeClasses && suggestion && suggestion.flags & SymbolFlags.Class && suggestionHasNoExtendsOrDecorators)
                    && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind === SyntaxKind.ThisKeyword && suggestionHasNoExtendsOrDecorators);
            }
        }
        return false;
    }

    function getFlowTypeOfAccessExpression(node: ElementAccessExpression | PropertyAccessExpression | QualifiedName, prop: Symbol | undefined, propType: Type, errorNode: Node, checkMode: CheckMode | undefined) {
        // Only compute control flow type if this is a property access expression that isn't an
        // assignment target, and the referenced property was declared as a variable, property,
        // accessor, or optional method.
        const assignmentKind = getAssignmentTargetKind(node);
        if (assignmentKind === AssignmentKind.Definite) {
            return removeMissingType(propType, !!(prop && prop.flags & SymbolFlags.Optional));
        }
        if (
            prop &&
            !(prop.flags & (SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.Accessor))
            && !(prop.flags & SymbolFlags.Method && propType.flags & TypeFlags.Union)
            && !isDuplicatedCommonJSExport(prop.declarations)
        ) {
            return propType;
        }
        if (propType === autoType) {
            return getFlowTypeOfProperty(node, prop);
        }
        propType = getNarrowableTypeForReference(propType, node, checkMode);
        // If strict null checks and strict property initialization checks are enabled, if we have
        // a this.xxx property access, if the property is an instance property without an initializer,
        // and if we are in a constructor of the same class as the property declaration, assume that
        // the property is uninitialized at the top of the control flow.
        let assumeUninitialized = false;
        if (strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind === SyntaxKind.ThisKeyword) {
            const declaration = prop && prop.valueDeclaration;
            if (declaration && isPropertyWithoutInitializer(declaration)) {
                if (!isStatic(declaration)) {
                    const flowContainer = getControlFlowContainer(node);
                    if (flowContainer.kind === SyntaxKind.Constructor && flowContainer.parent === declaration.parent && !(declaration.flags & NodeFlags.Ambient)) {
                        assumeUninitialized = true;
                    }
                }
            }
        }
        else if (
            strictNullChecks && prop && prop.valueDeclaration &&
            isPropertyAccessExpression(prop.valueDeclaration) &&
            getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) &&
            getControlFlowContainer(node) === getControlFlowContainer(prop.valueDeclaration)
        ) {
            assumeUninitialized = true;
        }
        const flowType = getFlowTypeOfReference(node, propType, assumeUninitialized ? getOptionalType(propType) : propType);
        if (assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType)) {
            error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop!)); // TODO: GH#18217
            // Return the declared type to reduce follow-on errors
            return propType;
        }
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }

    function checkPropertyNotUsedBeforeDeclaration(prop: Symbol, node: PropertyAccessExpression | QualifiedName, right: Identifier | PrivateIdentifier): void {
        const { valueDeclaration } = prop;
        if (!valueDeclaration || getSourceFileOfNode(node).isDeclarationFile) {
            return;
        }

        let diagnosticMessage;
        const declarationName = idText(right);
        if (
            isInPropertyInitializerOrClassStaticBlock(node)
            && !isOptionalPropertyDeclaration(valueDeclaration)
            && !(isAccessExpression(node) && isAccessExpression(node.expression))
            && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)
            && !(isMethodDeclaration(valueDeclaration) && getCombinedModifierFlagsCached(valueDeclaration) & ModifierFlags.Static)
            && (useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop))
        ) {
            diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName);
        }
        else if (
            valueDeclaration.kind === SyntaxKind.ClassDeclaration &&
            node.parent.kind !== SyntaxKind.TypeReference &&
            !(valueDeclaration.flags & NodeFlags.Ambient) &&
            !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)
        ) {
            diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName);
        }

        if (diagnosticMessage) {
            addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName));
        }
    }

    function isInPropertyInitializerOrClassStaticBlock(node: Node, ignoreArrowFunctions?: boolean): boolean {
        return !!findAncestor(node, node => {
            switch (node.kind) {
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.ClassStaticBlockDeclaration:
                    return true;
                case SyntaxKind.TypeQuery:
                case SyntaxKind.JsxClosingElement: // already reported in JsxOpeningElement
                    return "quit";
                case SyntaxKind.ArrowFunction:
                    return ignoreArrowFunctions ? false : "quit";
                case SyntaxKind.Block:
                    return isFunctionLikeDeclaration(node.parent) && node.parent.kind !== SyntaxKind.ArrowFunction ? "quit" : false;
                default:
                    return false;
            }
        });
    }

    /**
     * It's possible that "prop.valueDeclaration" is a local declaration, but the property was also declared in a superclass.
     * In that case we won't consider it used before its declaration, because it gets its value from the superclass' declaration.
     */
    function isPropertyDeclaredInAncestorClass(prop: Symbol): boolean {
        if (!(prop.parent!.flags & SymbolFlags.Class)) {
            return false;
        }
        let classType: InterfaceType | undefined = getTypeOfSymbol(prop.parent!) as InterfaceType;
        while (true) {
            classType = classType.symbol && getSuperClass(classType) as InterfaceType | undefined;
            if (!classType) {
                return false;
            }
            const superProperty = getPropertyOfType(classType, prop.escapedName);
            if (superProperty && superProperty.valueDeclaration) {
                return true;
            }
        }
    }

    function getSuperClass(classType: InterfaceType): Type | undefined {
        const x = getBaseTypes(classType);
        if (x.length === 0) {
            return undefined;
        }
        return getIntersectionType(x);
    }

    function reportNonexistentProperty(propNode: Identifier | PrivateIdentifier, containingType: Type, isUncheckedJS: boolean) {
        const links = getNodeLinks(propNode);
        const cache = (links.nonExistentPropCheckCache ||= new Set());
        const key = `${getTypeId(containingType)}|${isUncheckedJS}`;
        if (cache.has(key)) {
            return;
        }
        cache.add(key);
        let errorInfo: DiagnosticMessageChain | undefined;
        let relatedInfo: Diagnostic | undefined;
        if (!isPrivateIdentifier(propNode) && containingType.flags & TypeFlags.Union && !(containingType.flags & TypeFlags.Primitive)) {
            for (const subtype of (containingType as UnionType).types) {
                if (!getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(subtype, propNode.escapedText)) {
                    errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype));
                    break;
                }
            }
        }
        if (typeHasStaticProperty(propNode.escapedText, containingType)) {
            const propName = declarationNameToString(propNode);
            const typeName = typeToString(containingType);
            errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "." + propName);
        }
        else {
            const promisedType = getPromisedTypeOfPromise(containingType);
            if (promisedType && getPropertyOfType(promisedType, propNode.escapedText)) {
                errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType));
                relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await);
            }
            else {
                const missingProperty = declarationNameToString(propNode);
                const container = typeToString(containingType);
                const libSuggestion = getSuggestedLibForNonExistentProperty(missingProperty, containingType);
                if (libSuggestion !== undefined) {
                    errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion);
                }
                else {
                    const suggestion = getSuggestedSymbolForNonexistentProperty(propNode, containingType);
                    if (suggestion !== undefined) {
                        const suggestedName = symbolName(suggestion);
                        const message = isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2;
                        errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName);
                        relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName);
                    }
                    else {
                        const diagnostic = containerSeemsToBeEmptyDomElement(containingType)
                            ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom
                            : Diagnostics.Property_0_does_not_exist_on_type_1;
                        errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container);
                    }
                }
            }
        }
        const resultDiagnostic = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo);
        if (relatedInfo) {
            addRelatedInfo(resultDiagnostic, relatedInfo);
        }
        addErrorOrSuggestion(!isUncheckedJS || errorInfo.code !== Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic);
    }

    function containerSeemsToBeEmptyDomElement(containingType: Type) {
        return (compilerOptions.lib && !compilerOptions.lib.includes("lib.dom.d.ts")) &&
            everyContainedType(containingType, type => type.symbol && /^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$/.test(unescapeLeadingUnderscores(type.symbol.escapedName))) &&
            isEmptyObjectType(containingType);
    }

    function typeHasStaticProperty(propName: __String, containingType: Type): boolean {
        const prop = containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName);
        return prop !== undefined && !!prop.valueDeclaration && isStatic(prop.valueDeclaration);
    }

    function getSuggestedLibForNonExistentName(name: __String | Identifier) {
        const missingName = diagnosticName(name);
        const allFeatures = getScriptTargetFeatures();
        const typeFeatures = allFeatures.get(missingName);
        return typeFeatures && firstIterator(typeFeatures.keys());
    }

    function getSuggestedLibForNonExistentProperty(missingProperty: string, containingType: Type) {
        const container = getApparentType(containingType).symbol;
        if (!container) {
            return undefined;
        }
        const containingTypeName = symbolName(container);
        const allFeatures = getScriptTargetFeatures();
        const typeFeatures = allFeatures.get(containingTypeName);
        if (typeFeatures) {
            for (const [libTarget, featuresOfType] of typeFeatures) {
                if (contains(featuresOfType, missingProperty)) {
                    return libTarget;
                }
            }
        }
    }

    function getSuggestedSymbolForNonexistentClassMember(name: string, baseType: Type): Symbol | undefined {
        return getSpellingSuggestionForName(name, getPropertiesOfType(baseType), SymbolFlags.ClassMember);
    }

    function getSuggestedSymbolForNonexistentProperty(name: Identifier | PrivateIdentifier | string, containingType: Type): Symbol | undefined {
        let props = getPropertiesOfType(containingType);
        if (typeof name !== "string") {
            const parent = name.parent;
            if (isPropertyAccessExpression(parent)) {
                props = filter(props, prop => isValidPropertyAccessForCompletions(parent, containingType, prop));
            }
            name = idText(name);
        }
        return getSpellingSuggestionForName(name, props, SymbolFlags.Value);
    }

    function getSuggestedSymbolForNonexistentJSXAttribute(name: Identifier | PrivateIdentifier | string, containingType: Type): Symbol | undefined {
        const strName = isString(name) ? name : idText(name);
        const properties = getPropertiesOfType(containingType);
        const jsxSpecific = strName === "for" ? find(properties, x => symbolName(x) === "htmlFor")
            : strName === "class" ? find(properties, x => symbolName(x) === "className")
            : undefined;
        return jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value);
    }

    function getSuggestionForNonexistentProperty(name: Identifier | PrivateIdentifier | string, containingType: Type): string | undefined {
        const suggestion = getSuggestedSymbolForNonexistentProperty(name, containingType);
        return suggestion && symbolName(suggestion);
    }

    function getSuggestionForSymbolNameLookup(symbols: SymbolTable, name: __String, meaning: SymbolFlags) {
        const symbol = getSymbol(symbols, name, meaning);
        // Sometimes the symbol is found when location is a return type of a function: `typeof x` and `x` is declared in the body of the function
        // So the table *contains* `x` but `x` isn't actually in scope.
        // However, resolveNameHelper will continue and call this callback again, so we'll eventually get a correct suggestion.
        if (symbol) return symbol;
        let candidates: Symbol[];
        if (symbols === globals) {
            const primitives = mapDefined(
                ["string", "number", "boolean", "object", "bigint", "symbol"],
                s => symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) as __String)
                    ? createSymbol(SymbolFlags.TypeAlias, s as __String) as Symbol
                    : undefined,
            );
            candidates = primitives.concat(arrayFrom(symbols.values()));
        }
        else {
            candidates = arrayFrom(symbols.values());
        }
        return getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning);
    }
    function getSuggestedSymbolForNonexistentSymbol(location: Node | undefined, outerName: __String, meaning: SymbolFlags): Symbol | undefined {
        Debug.assert(outerName !== undefined, "outername should always be defined");
        const result = resolveNameForSymbolSuggestion(location, outerName, meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ false, /*excludeGlobals*/ false);
        return result;
    }

    function getSuggestedSymbolForNonexistentModule(name: Identifier, targetModule: Symbol): Symbol | undefined {
        return targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), SymbolFlags.ModuleMember);
    }

    function getSuggestionForNonexistentIndexSignature(objectType: Type, expr: ElementAccessExpression, keyedType: Type): string | undefined {
        // check if object type has setter or getter
        function hasProp(name: "set" | "get") {
            const prop = getPropertyOfObjectType(objectType, name as __String);
            if (prop) {
                const s = getSingleCallSignature(getTypeOfSymbol(prop));
                return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0));
            }
            return false;
        }

        const suggestedMethod = isAssignmentTarget(expr) ? "set" : "get";
        if (!hasProp(suggestedMethod)) {
            return undefined;
        }

        let suggestion = tryGetPropertyAccessOrIdentifierToString(expr.expression);
        if (suggestion === undefined) {
            suggestion = suggestedMethod;
        }
        else {
            suggestion += "." + suggestedMethod;
        }

        return suggestion;
    }

    function getSuggestedTypeForNonexistentStringLiteralType(source: StringLiteralType, target: UnionType): StringLiteralType | undefined {
        const candidates = target.types.filter((type): type is StringLiteralType => !!(type.flags & TypeFlags.StringLiteral));
        return getSpellingSuggestion(source.value, candidates, type => type.value);
    }

    /**
     * Given a name and a list of symbols whose names are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
     * Names less than length 3 only check for case-insensitive equality, not levenshtein distance.
     *
     * If there is a candidate that's the same except for case, return that.
     * If there is a candidate that's within one edit of the name, return that.
     * Otherwise, return the candidate with the smallest Levenshtein distance,
     *    except for candidates:
     *      * With no name
     *      * Whose meaning doesn't match the `meaning` parameter.
     *      * Whose length differs from the target name by more than 0.34 of the length of the name.
     *      * Whose levenshtein distance is more than 0.4 of the length of the name
     *        (0.4 allows 1 substitution/transposition for every 5 characters,
     *         and 1 insertion/deletion at 3 characters)
     */
    function getSpellingSuggestionForName(name: string, symbols: Symbol[], meaning: SymbolFlags): Symbol | undefined {
        return getSpellingSuggestion(name, symbols, getCandidateName);

        function getCandidateName(candidate: Symbol) {
            const candidateName = symbolName(candidate);
            if (startsWith(candidateName, '"')) {
                return undefined;
            }

            if (candidate.flags & meaning) {
                return candidateName;
            }

            if (candidate.flags & SymbolFlags.Alias) {
                const alias = tryResolveAlias(candidate);
                if (alias && alias.flags & meaning) {
                    return candidateName;
                }
            }

            return undefined;
        }
    }

    function markPropertyAsReferenced(prop: Symbol, nodeForCheckWriteOnly: Node | undefined, isSelfTypeAccess: boolean) {
        const valueDeclaration = prop && (prop.flags & SymbolFlags.ClassMember) && prop.valueDeclaration;
        if (!valueDeclaration) {
            return;
        }
        const hasPrivateModifier = hasEffectiveModifier(valueDeclaration, ModifierFlags.Private);
        const hasPrivateIdentifier = prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name);
        if (!hasPrivateModifier && !hasPrivateIdentifier) {
            return;
        }
        if (nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlags.SetAccessor)) {
            return;
        }
        if (isSelfTypeAccess) {
            // Find any FunctionLikeDeclaration because those create a new 'this' binding. But this should only matter for methods (or getters/setters).
            const containingMethod = findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration);
            if (containingMethod && containingMethod.symbol === prop) {
                return;
            }
        }

        (getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop)!.isReferenced = SymbolFlags.All;
    }

    function isSelfTypeAccess(name: Expression | QualifiedName, parent: Symbol | undefined) {
        return name.kind === SyntaxKind.ThisKeyword
            || !!parent && isEntityNameExpression(name) && parent === getResolvedSymbol(getFirstIdentifier(name));
    }

    function isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: __String): boolean {
        switch (node.kind) {
            case SyntaxKind.PropertyAccessExpression:
                return isValidPropertyAccessWithType(node, node.expression.kind === SyntaxKind.SuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)));
            case SyntaxKind.QualifiedName:
                return isValidPropertyAccessWithType(node, /*isSuper*/ false, propertyName, getWidenedType(checkExpression(node.left)));
            case SyntaxKind.ImportType:
                return isValidPropertyAccessWithType(node, /*isSuper*/ false, propertyName, getTypeFromTypeNode(node));
        }
    }

    /**
     * Checks if an existing property access is valid for completions purposes.
     * @param node a property access-like node where we want to check if we can access a property.
     * This node does not need to be an access of the property we are checking.
     * e.g. in completions, this node will often be an incomplete property access node, as in `foo.`.
     * Besides providing a location (i.e. scope) used to check property accessibility, we use this node for
     * computing whether this is a `super` property access.
     * @param type the type whose property we are checking.
     * @param property the accessed property's symbol.
     */
    function isValidPropertyAccessForCompletions(node: PropertyAccessExpression | ImportTypeNode | QualifiedName, type: Type, property: Symbol): boolean {
        return isPropertyAccessible(node, node.kind === SyntaxKind.PropertyAccessExpression && node.expression.kind === SyntaxKind.SuperKeyword, /*isWrite*/ false, type, property);
        // Previously we validated the 'this' type of methods but this adversely affected performance. See #31377 for more context.
    }

    function isValidPropertyAccessWithType(
        node: PropertyAccessExpression | QualifiedName | ImportTypeNode,
        isSuper: boolean,
        propertyName: __String,
        type: Type,
    ): boolean {
        // Short-circuiting for improved performance.
        if (isTypeAny(type)) {
            return true;
        }

        const prop = getPropertyOfType(type, propertyName);
        return !!prop && isPropertyAccessible(node, isSuper, /*isWrite*/ false, type, prop);
    }

    /**
     * Checks if a property can be accessed in a location.
     * The location is given by the `node` parameter.
     * The node does not need to be a property access.
     * @param node location where to check property accessibility
     * @param isSuper whether to consider this a `super` property access, e.g. `super.foo`.
     * @param isWrite whether this is a write access, e.g. `++foo.x`.
     * @param containingType type where the property comes from.
     * @param property property symbol.
     */
    function isPropertyAccessible(
        node: Node,
        isSuper: boolean,
        isWrite: boolean,
        containingType: Type,
        property: Symbol,
    ): boolean {
        // Short-circuiting for improved performance.
        if (isTypeAny(containingType)) {
            return true;
        }

        // A #private property access in an optional chain is an error dealt with by the parser.
        // The checker does not check for it, so we need to do our own check here.
        if (property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration)) {
            const declClass = getContainingClass(property.valueDeclaration);
            return !isOptionalChain(node) && !!findAncestor(node, parent => parent === declClass);
        }

        return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property);
    }

    /**
     * Return the symbol of the for-in variable declared or referenced by the given for-in statement.
     */
    function getForInVariableSymbol(node: ForInStatement): Symbol | undefined {
        const initializer = node.initializer;
        if (initializer.kind === SyntaxKind.VariableDeclarationList) {
            const variable = (initializer as VariableDeclarationList).declarations[0];
            if (variable && !isBindingPattern(variable.name)) {
                return getSymbolOfDeclaration(variable);
            }
        }
        else if (initializer.kind === SyntaxKind.Identifier) {
            return getResolvedSymbol(initializer as Identifier);
        }
        return undefined;
    }

    /**
     * Return true if the given type is considered to have numeric property names.
     */
    function hasNumericPropertyNames(type: Type) {
        return getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, numberType);
    }

    /**
     * Return true if given node is an expression consisting of an identifier (possibly parenthesized)
     * that references a for-in variable for an object with numeric property names.
     */
    function isForInVariableForNumericPropertyNames(expr: Expression) {
        const e = skipParentheses(expr);
        if (e.kind === SyntaxKind.Identifier) {
            const symbol = getResolvedSymbol(e as Identifier);
            if (symbol.flags & SymbolFlags.Variable) {
                let child: Node = expr;
                let node = expr.parent;
                while (node) {
                    if (
                        node.kind === SyntaxKind.ForInStatement &&
                        child === (node as ForInStatement).statement &&
                        getForInVariableSymbol(node as ForInStatement) === symbol &&
                        hasNumericPropertyNames(getTypeOfExpression((node as ForInStatement).expression))
                    ) {
                        return true;
                    }
                    child = node;
                    node = node.parent;
                }
            }
        }
        return false;
    }

    function checkIndexedAccess(node: ElementAccessExpression, checkMode: CheckMode | undefined): Type {
        return node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(node as ElementAccessChain, checkMode) :
            checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode);
    }

    function checkElementAccessChain(node: ElementAccessChain, checkMode: CheckMode | undefined) {
        const exprType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(exprType, node.expression);
        return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression), checkMode), node, nonOptionalType !== exprType);
    }

    function checkElementAccessExpression(node: ElementAccessExpression, exprType: Type, checkMode: CheckMode | undefined): Type {
        const objectType = getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType;
        const indexExpression = node.argumentExpression;
        const indexType = checkExpression(indexExpression);

        if (isErrorType(objectType) || objectType === silentNeverType) {
            return objectType;
        }

        if (isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression)) {
            error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
            return errorType;
        }

        const effectiveIndexType = isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType;
        const assignmentTargetKind = getAssignmentTargetKind(node);
        let accessFlags: AccessFlags;
        if (assignmentTargetKind === AssignmentKind.None) {
            accessFlags = AccessFlags.ExpressionPosition;
        }
        else {
            accessFlags = AccessFlags.Writing | (isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0);
            if (assignmentTargetKind === AssignmentKind.Compound) {
                accessFlags |= AccessFlags.ExpressionPosition;
            }
        }
        const indexedAccessType = getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType;
        return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node);
    }

    function callLikeExpressionMayHaveTypeArguments(node: CallLikeExpression): node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement {
        return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node);
    }

    function resolveUntypedCall(node: CallLikeExpression): Signature {
        if (callLikeExpressionMayHaveTypeArguments(node)) {
            // Check type arguments even though we will give an error that untyped calls may not accept type arguments.
            // This gets us diagnostics for the type arguments and marks them as referenced.
            forEach(node.typeArguments, checkSourceElement);
        }

        if (node.kind === SyntaxKind.TaggedTemplateExpression) {
            checkExpression(node.template);
        }
        else if (isJsxOpeningLikeElement(node)) {
            checkExpression(node.attributes);
        }
        else if (isBinaryExpression(node)) {
            checkExpression(node.left);
        }
        else if (isCallOrNewExpression(node)) {
            forEach(node.arguments, argument => {
                checkExpression(argument);
            });
        }
        return anySignature;
    }

    function resolveErrorCall(node: CallLikeExpression): Signature {
        resolveUntypedCall(node);
        return unknownSignature;
    }

    // Re-order candidate signatures into the result array. Assumes the result array to be empty.
    // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
    // A nit here is that we reorder only signatures that belong to the same symbol,
    // so order how inherited signatures are processed is still preserved.
    // interface A { (x: string): void }
    // interface B extends A { (x: 'foo'): string }
    // const b: B;
    // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
    function reorderCandidates(signatures: readonly Signature[], result: Signature[], callChainFlags: SignatureFlags): void {
        let lastParent: Node | undefined;
        let lastSymbol: Symbol | undefined;
        let cutoffIndex = 0;
        let index: number | undefined;
        let specializedIndex = -1;
        let spliceIndex: number;
        Debug.assert(!result.length);
        for (const signature of signatures) {
            const symbol = signature.declaration && getSymbolOfDeclaration(signature.declaration);
            const parent = signature.declaration && signature.declaration.parent;
            if (!lastSymbol || symbol === lastSymbol) {
                if (lastParent && parent === lastParent) {
                    index = index! + 1;
                }
                else {
                    lastParent = parent;
                    index = cutoffIndex;
                }
            }
            else {
                // current declaration belongs to a different symbol
                // set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
                index = cutoffIndex = result.length;
                lastParent = parent;
            }
            lastSymbol = symbol;

            // specialized signatures always need to be placed before non-specialized signatures regardless
            // of the cutoff position; see GH#1133
            if (signatureHasLiteralTypes(signature)) {
                specializedIndex++;
                spliceIndex = specializedIndex;
                // The cutoff index always needs to be greater than or equal to the specialized signature index
                // in order to prevent non-specialized signatures from being added before a specialized
                // signature.
                cutoffIndex++;
            }
            else {
                spliceIndex = index;
            }

            result.splice(spliceIndex, 0, callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature);
        }
    }

    function isSpreadArgument(arg: Expression | undefined): arg is Expression {
        return !!arg && (arg.kind === SyntaxKind.SpreadElement || arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).isSpread);
    }

    function getSpreadArgumentIndex(args: readonly Expression[]): number {
        return findIndex(args, isSpreadArgument);
    }

    function acceptsVoid(t: Type): boolean {
        return !!(t.flags & TypeFlags.Void);
    }

    function acceptsVoidUndefinedUnknownOrAny(t: Type): boolean {
        return !!(t.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Unknown | TypeFlags.Any));
    }

    function hasCorrectArity(node: CallLikeExpression, args: readonly Expression[], signature: Signature, signatureHelpTrailingComma = false) {
        if (isJsxOpeningFragment(node)) return true;

        let argCount: number;
        let callIsIncomplete = false; // In incomplete call we want to be lenient when we have too few arguments
        let effectiveParameterCount = getParameterCount(signature);
        let effectiveMinimumArguments = getMinArgumentCount(signature);

        if (node.kind === SyntaxKind.TaggedTemplateExpression) {
            argCount = args.length;
            if (node.template.kind === SyntaxKind.TemplateExpression) {
                // If a tagged template expression lacks a tail literal, the call is incomplete.
                // Specifically, a template only can end in a TemplateTail or a Missing literal.
                const lastSpan = last(node.template.templateSpans); // we should always have at least one span.
                callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
            }
            else {
                // If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
                // then this might actually turn out to be a TemplateHead in the future;
                // so we consider the call to be incomplete.
                const templateLiteral = node.template as LiteralExpression;
                Debug.assert(templateLiteral.kind === SyntaxKind.NoSubstitutionTemplateLiteral);
                callIsIncomplete = !!templateLiteral.isUnterminated;
            }
        }
        else if (node.kind === SyntaxKind.Decorator) {
            argCount = getDecoratorArgumentCount(node, signature);
        }
        else if (node.kind === SyntaxKind.BinaryExpression) {
            argCount = 1;
        }
        else if (isJsxOpeningLikeElement(node)) {
            callIsIncomplete = node.attributes.end === node.end;
            if (callIsIncomplete) {
                return true;
            }
            argCount = effectiveMinimumArguments === 0 ? args.length : 1;
            effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1; // class may have argumentless ctor functions - still resolve ctor and compare vs props member type
            effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1); // sfc may specify context argument - handled by framework and not typechecked
        }
        else if (!node.arguments) {
            // This only happens when we have something of the form: 'new C'
            Debug.assert(node.kind === SyntaxKind.NewExpression);
            return getMinArgumentCount(signature) === 0;
        }
        else {
            argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;

            // If we are missing the close parenthesis, the call is incomplete.
            callIsIncomplete = node.arguments.end === node.end;

            // If a spread argument is present, check that it corresponds to a rest parameter or at least that it's in the valid range.
            const spreadArgIndex = getSpreadArgumentIndex(args);
            if (spreadArgIndex >= 0) {
                return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature));
            }
        }

        // Too many arguments implies incorrect arity.
        if (!hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount) {
            return false;
        }

        // If the call is incomplete, we should skip the lower bound check.
        // JSX signatures can have extra parameters provided by the library which we don't check
        if (callIsIncomplete || argCount >= effectiveMinimumArguments) {
            return true;
        }
        for (let i = argCount; i < effectiveMinimumArguments; i++) {
            const type = getTypeAtPosition(signature, i);
            if (filterType(type, isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid).flags & TypeFlags.Never) {
                return false;
            }
        }
        return true;
    }

    function hasCorrectTypeArgumentArity(signature: Signature, typeArguments: NodeArray<TypeNode> | undefined) {
        // If the user supplied type arguments, but the number of type arguments does not match
        // the declared number of type parameters, the call has an incorrect arity.
        const numTypeParameters = length(signature.typeParameters);
        const minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
        return !some(typeArguments) ||
            (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
    }

    function isInstantiatedGenericParameter(signature: Signature, pos: number) {
        let type;
        return !!(signature.target && (type = tryGetTypeAtPosition(signature.target, pos)) && isGenericType(type));
    }

    // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
    function getSingleCallSignature(type: Type): Signature | undefined {
        return getSingleSignature(type, SignatureKind.Call, /*allowMembers*/ false);
    }

    function getSingleCallOrConstructSignature(type: Type): Signature | undefined {
        return getSingleSignature(type, SignatureKind.Call, /*allowMembers*/ false) ||
            getSingleSignature(type, SignatureKind.Construct, /*allowMembers*/ false);
    }

    function getSingleSignature(type: Type, kind: SignatureKind, allowMembers: boolean): Signature | undefined {
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            if (allowMembers || resolved.properties.length === 0 && resolved.indexInfos.length === 0) {
                if (kind === SignatureKind.Call && resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0) {
                    return resolved.callSignatures[0];
                }
                if (kind === SignatureKind.Construct && resolved.constructSignatures.length === 1 && resolved.callSignatures.length === 0) {
                    return resolved.constructSignatures[0];
                }
            }
        }
        return undefined;
    }

    // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
    function instantiateSignatureInContextOf(signature: Signature, contextualSignature: Signature, inferenceContext?: InferenceContext, compareTypes?: TypeComparer): Signature {
        const context = createInferenceContext(getTypeParametersForMapper(signature)!, signature, InferenceFlags.None, compareTypes);
        // We clone the inferenceContext to avoid fixing. For example, when the source signature is <T>(x: T) => T[] and
        // the contextual signature is (...args: A) => B, we want to infer the element type of A's constraint (say 'any')
        // for T but leave it possible to later infer '[any]' back to A.
        const restType = getEffectiveRestType(contextualSignature);
        const mapper = inferenceContext && (restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper);
        const sourceSignature = mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature;
        applyToParameterTypes(sourceSignature, signature, (source, target) => {
            // Type parameters from outer context referenced by source type are fixed by instantiation of the source type
            inferTypes(context.inferences, source, target);
        });
        if (!inferenceContext) {
            applyToReturnTypes(contextualSignature, signature, (source, target) => {
                inferTypes(context.inferences, source, target, InferencePriority.ReturnType);
            });
        }
        return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration));
    }

    function inferJsxTypeArguments(node: JsxOpeningLikeElement, signature: Signature, checkMode: CheckMode, context: InferenceContext): Type[] {
        const paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
        const checkAttrType = checkExpressionWithContextualType(node.attributes, paramType, context, checkMode);
        inferTypes(context.inferences, checkAttrType, paramType);
        return getInferredTypes(context);
    }

    function getThisArgumentType(thisArgumentNode: Expression | undefined) {
        if (!thisArgumentNode) {
            return voidType;
        }
        const thisArgumentType = checkExpression(thisArgumentNode);
        return isRightSideOfInstanceofExpression(thisArgumentNode) ? thisArgumentType :
            isOptionalChainRoot(thisArgumentNode.parent) ? getNonNullableType(thisArgumentType) :
            isOptionalChain(thisArgumentNode.parent) ? removeOptionalTypeMarker(thisArgumentType) :
            thisArgumentType;
    }

    function inferTypeArguments(node: CallLikeExpression, signature: Signature, args: readonly Expression[], checkMode: CheckMode, context: InferenceContext): Type[] {
        if (isJsxOpeningLikeElement(node)) {
            return inferJsxTypeArguments(node, signature, checkMode, context);
        }

        // If a contextual type is available, infer from that type to the return type of the call expression. For
        // example, given a 'function wrap<T, U>(cb: (x: T) => U): (x: T) => U' and a call expression
        // 'let f: (x: string) => number = wrap(s => s.length)', we infer from the declared type of 'f' to the
        // return type of 'wrap'.
        if (node.kind !== SyntaxKind.Decorator && node.kind !== SyntaxKind.BinaryExpression) {
            const skipBindingPatterns = every(signature.typeParameters, p => !!getDefaultFromTypeParameter(p));
            const contextualType = getContextualType(node, skipBindingPatterns ? ContextFlags.SkipBindingPatterns : ContextFlags.None);
            if (contextualType) {
                const inferenceTargetType = getReturnTypeOfSignature(signature);
                if (couldContainTypeVariables(inferenceTargetType)) {
                    const outerContext = getInferenceContext(node);
                    const isFromBindingPattern = !skipBindingPatterns && getContextualType(node, ContextFlags.SkipBindingPatterns) !== contextualType;
                    // A return type inference from a binding pattern can be used in instantiating the contextual
                    // type of an argument later in inference, but cannot stand on its own as the final return type.
                    // It is incorporated into `context.returnMapper` which is used in `instantiateContextualType`,
                    // but doesn't need to go into `context.inferences`. This allows a an array binding pattern to
                    // produce a tuple for `T` in
                    //   declare function f<T>(cb: () => T): T;
                    //   const [e1, e2, e3] = f(() => [1, "hi", true]);
                    // but does not produce any inference for `T` in
                    //   declare function f<T>(): T;
                    //   const [e1, e2, e3] = f();
                    if (!isFromBindingPattern) {
                        // We clone the inference context to avoid disturbing a resolution in progress for an
                        // outer call expression. Effectively we just want a snapshot of whatever has been
                        // inferred for any outer call expression so far.
                        const outerMapper = getMapperFromContext(cloneInferenceContext(outerContext, InferenceFlags.NoDefault));
                        const instantiatedType = instantiateType(contextualType, outerMapper);
                        // If the contextual type is a generic function type with a single call signature, we
                        // instantiate the type with its own type parameters and type arguments. This ensures that
                        // the type parameters are not erased to type any during type inference such that they can
                        // be inferred as actual types from the contextual type. For example:
                        //   declare function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[];
                        //   const boxElements: <A>(a: A[]) => { value: A }[] = arrayMap(value => ({ value }));
                        // Above, the type of the 'value' parameter is inferred to be 'A'.
                        const contextualSignature = getSingleCallSignature(instantiatedType);
                        const inferenceSourceType = contextualSignature && contextualSignature.typeParameters ?
                            getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) :
                            instantiatedType;
                        // Inferences made from return types have lower priority than all other inferences.
                        inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriority.ReturnType);
                    }
                    // Create a type mapper for instantiating generic contextual types using the inferences made
                    // from the return type. We need a separate inference pass here because (a) instantiation of
                    // the source type uses the outer context's return mapper (which excludes inferences made from
                    // outer arguments), and (b) we don't want any further inferences going into this context.
                    // We use `createOuterReturnMapper` to ensure that all occurrences of outer type parameters are
                    // replaced with inferences produced from the outer return type or preceding outer arguments.
                    // This protects against circular inferences, i.e. avoiding situations where inferences reference
                    // type parameters for which the inferences are being made.
                    const returnContext = createInferenceContext(signature.typeParameters!, signature, context.flags);
                    const returnSourceType = instantiateType(contextualType, outerContext && createOuterReturnMapper(outerContext));
                    inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType);
                    context.returnMapper = some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined;
                }
            }
        }

        const restType = getNonArrayRestType(signature);
        const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
        if (restType && restType.flags & TypeFlags.TypeParameter) {
            const info = find(context.inferences, info => info.typeParameter === restType);
            if (info) {
                info.impliedArity = findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined;
            }
        }

        const thisType = getThisTypeOfSignature(signature);
        if (thisType && couldContainTypeVariables(thisType)) {
            const thisArgumentNode = getThisArgumentOfCall(node);
            inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType);
        }

        for (let i = 0; i < argCount; i++) {
            const arg = args[i];
            if (arg.kind !== SyntaxKind.OmittedExpression) {
                const paramType = getTypeAtPosition(signature, i);
                if (couldContainTypeVariables(paramType)) {
                    const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);
                    inferTypes(context.inferences, argType, paramType);
                }
            }
        }

        if (restType && couldContainTypeVariables(restType)) {
            const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode);
            inferTypes(context.inferences, spreadType, restType);
        }

        return getInferredTypes(context);
    }

    function getMutableArrayOrTupleType(type: Type) {
        return type.flags & TypeFlags.Union ? mapType(type, getMutableArrayOrTupleType) :
            type.flags & TypeFlags.Any || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type :
            isTupleType(type) ? createTupleType(getElementTypes(type), type.target.elementFlags, /*readonly*/ false, type.target.labeledElementDeclarations) :
            createTupleType([type], [ElementFlags.Variadic]);
    }

    function getSpreadArgumentType(args: readonly Expression[], index: number, argCount: number, restType: Type, context: InferenceContext | undefined, checkMode: CheckMode) {
        const inConstContext = isConstTypeVariable(restType);

        if (index >= argCount - 1) {
            const arg = args[argCount - 1];
            if (isSpreadArgument(arg)) {
                // We are inferring from a spread expression in the last argument position, i.e. both the parameter
                // and the argument are ...x forms.
                const spreadType = arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type :
                    checkExpressionWithContextualType((arg as SpreadElement).expression, restType, context, checkMode);

                if (isArrayLikeType(spreadType)) {
                    return getMutableArrayOrTupleType(spreadType);
                }

                return createArrayType(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg), inConstContext);
            }
        }
        const types = [];
        const flags = [];
        const names = [];
        for (let i = index; i < argCount; i++) {
            const arg = args[i];
            if (isSpreadArgument(arg)) {
                const spreadType = arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : checkExpression((arg as SpreadElement).expression);
                if (isArrayLikeType(spreadType)) {
                    types.push(spreadType);
                    flags.push(ElementFlags.Variadic);
                }
                else {
                    types.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg));
                    flags.push(ElementFlags.Rest);
                }
            }
            else {
                const contextualType = isTupleType(restType) ?
                    getContextualTypeForElementExpression(restType, i - index, argCount - index) || unknownType :
                    getIndexedAccessType(restType, getNumberLiteralType(i - index), AccessFlags.Contextual);
                const argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);
                const hasPrimitiveContextualType = inConstContext || maybeTypeOfKind(contextualType, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);
                types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));
                flags.push(ElementFlags.Required);
            }
            if (arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).tupleNameSource) {
                names.push((arg as SyntheticExpression).tupleNameSource!);
            }
            else {
                names.push(undefined);
            }
        }
        return createTupleType(types, flags, inConstContext && !someType(restType, isMutableArrayLikeType), names);
    }

    function checkTypeArguments(signature: Signature, typeArgumentNodes: readonly TypeNode[], reportErrors: boolean, headMessage?: DiagnosticMessage): Type[] | undefined {
        const isJavascript = isInJSFile(signature.declaration);
        const typeParameters = signature.typeParameters!;
        const typeArgumentTypes = fillMissingTypeArguments(map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
        let mapper: TypeMapper | undefined;
        for (let i = 0; i < typeArgumentNodes.length; i++) {
            Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");
            const constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (constraint) {
                const errorInfo = reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined;
                const typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                if (!mapper) {
                    mapper = createTypeMapper(typeParameters, typeArgumentTypes);
                }
                const typeArgument = typeArgumentTypes[i];
                if (
                    !checkTypeAssignableTo(
                        typeArgument,
                        getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),
                        reportErrors ? typeArgumentNodes[i] : undefined,
                        typeArgumentHeadMessage,
                        errorInfo,
                    )
                ) {
                    return undefined;
                }
            }
        }
        return typeArgumentTypes;
    }

    function getJsxReferenceKind(node: JsxOpeningLikeElement): JsxReferenceKind {
        if (isJsxIntrinsicTagName(node.tagName)) {
            return JsxReferenceKind.Mixed;
        }
        const tagType = getApparentType(checkExpression(node.tagName));
        if (length(getSignaturesOfType(tagType, SignatureKind.Construct))) {
            return JsxReferenceKind.Component;
        }
        if (length(getSignaturesOfType(tagType, SignatureKind.Call))) {
            return JsxReferenceKind.Function;
        }
        return JsxReferenceKind.Mixed;
    }

    /**
     * Check if the given signature can possibly be a signature called by the JSX opening-like element.
     * @param node a JSX opening-like element we are trying to figure its call signature
     * @param signature a candidate signature we are trying whether it is a call signature
     * @param relation a relationship to check parameter and argument type
     */
    function checkApplicableSignatureForJsxCallLikeElement(
        node: JsxCallLike,
        signature: Signature,
        relation: Map<string, RelationComparisonResult>,
        checkMode: CheckMode,
        reportErrors: boolean,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: ErrorOutputContainer,
    ) {
        // Stateless function components can have maximum of three arguments: "props", "context", and "updater".
        // However "context" and "updater" are implicit and can't be specify by users. Only the first parameter, props,
        // can be specified by users through attributes property.
        const paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
        const attributesType = isJsxOpeningFragment(node) ? createJsxAttributesTypeFromAttributesProperty(node) : checkExpressionWithContextualType(node.attributes, paramType, /*inferenceContext*/ undefined, checkMode);
        const checkAttributesType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(attributesType) : attributesType;
        return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(
            checkAttributesType,
            paramType,
            relation,
            reportErrors ? isJsxOpeningFragment(node) ? node : node.tagName : undefined,
            isJsxOpeningFragment(node) ? undefined : node.attributes,
            /*headMessage*/ undefined,
            containingMessageChain,
            errorOutputContainer,
        );

        function checkTagNameDoesNotExpectTooManyArguments(): boolean {
            if (getJsxNamespaceContainerForImplicitImport(node)) {
                return true; // factory is implicitly jsx/jsxdev - assume it fits the bill, since we don't strongly look for the jsx/jsxs/jsxDEV factory APIs anywhere else (at least not yet)
            }

            // We assume fragments have the correct arity since the node does not have attributes
            const tagType = (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)) ? checkExpression(node.tagName) : undefined;
            if (!tagType) {
                return true;
            }
            const tagCallSignatures = getSignaturesOfType(tagType, SignatureKind.Call);
            if (!length(tagCallSignatures)) {
                return true;
            }
            const factory = getJsxFactoryEntity(node);
            if (!factory) {
                return true;
            }
            const factorySymbol = resolveEntityName(factory, SymbolFlags.Value, /*ignoreErrors*/ true, /*dontResolveAlias*/ false, node);
            if (!factorySymbol) {
                return true;
            }

            const factoryType = getTypeOfSymbol(factorySymbol);
            const callSignatures = getSignaturesOfType(factoryType, SignatureKind.Call);
            if (!length(callSignatures)) {
                return true;
            }

            let hasFirstParamSignatures = false;
            let maxParamCount = 0;
            // Check that _some_ first parameter expects a FC-like thing, and that some overload of the SFC expects an acceptable number of arguments
            for (const sig of callSignatures) {
                const firstparam = getTypeAtPosition(sig, 0);
                const signaturesOfParam = getSignaturesOfType(firstparam, SignatureKind.Call);
                if (!length(signaturesOfParam)) continue;
                for (const paramSig of signaturesOfParam) {
                    hasFirstParamSignatures = true;
                    if (hasEffectiveRestParameter(paramSig)) {
                        return true; // some signature has a rest param, so function components can have an arbitrary number of arguments
                    }
                    const paramCount = getParameterCount(paramSig);
                    if (paramCount > maxParamCount) {
                        maxParamCount = paramCount;
                    }
                }
            }
            if (!hasFirstParamSignatures) {
                // Not a single signature had a first parameter which expected a signature - for back compat, and
                // to guard against generic factories which won't have signatures directly, do not error
                return true;
            }
            let absoluteMinArgCount = Infinity;
            for (const tagSig of tagCallSignatures) {
                const tagRequiredArgCount = getMinArgumentCount(tagSig);
                if (tagRequiredArgCount < absoluteMinArgCount) {
                    absoluteMinArgCount = tagRequiredArgCount;
                }
            }
            if (absoluteMinArgCount <= maxParamCount) {
                return true; // some signature accepts the number of arguments the function component provides
            }

            if (reportErrors) {
                // We will not report errors in this function for fragments, since we do not check them in this function
                const tagName = (node as JsxOpeningElement | JsxSelfClosingElement).tagName;
                const diag = createDiagnosticForNode(tagName, Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, entityNameToString(tagName), absoluteMinArgCount, entityNameToString(factory), maxParamCount);
                const tagNameDeclaration = getSymbolAtLocation(tagName)?.valueDeclaration;
                if (tagNameDeclaration) {
                    addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(tagName)));
                }
                if (errorOutputContainer && errorOutputContainer.skipLogging) {
                    (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                }
                if (!errorOutputContainer.skipLogging) {
                    diagnostics.add(diag);
                }
            }
            return false;
        }
    }

    function getEffectiveCheckNode(argument: Expression): Expression {
        const flags = isInJSFile(argument)
            ? OuterExpressionKinds.Parentheses | OuterExpressionKinds.Satisfies | OuterExpressionKinds.ExcludeJSDocTypeAssertion
            : OuterExpressionKinds.Parentheses | OuterExpressionKinds.Satisfies;
        return skipOuterExpressions(argument, flags);
    }

    function getSignatureApplicabilityError(
        node: CallLikeExpression,
        args: readonly Expression[],
        signature: Signature,
        relation: Map<string, RelationComparisonResult>,
        checkMode: CheckMode,
        reportErrors: boolean,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    ): readonly Diagnostic[] | undefined {
        const errorOutputContainer: ErrorOutputContainer = { errors: undefined, skipLogging: true };
        if (isJsxCallLike(node)) {
            if (!checkApplicableSignatureForJsxCallLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer)) {
                Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors");
                return errorOutputContainer.errors || emptyArray;
            }
            return undefined;
        }
        const thisType = getThisTypeOfSignature(signature);
        if (thisType && thisType !== voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression))) {
            // If the called expression is not of the form `x.f` or `x["f"]`, then sourceType = voidType
            // If the signature's 'this' type is voidType, then the check is skipped -- anything is compatible.
            // If the expression is a new expression or super call expression, then the check is skipped.
            const thisArgumentNode = getThisArgumentOfCall(node);
            const thisArgumentType = getThisArgumentType(thisArgumentNode);
            const errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
            const headMessage = Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
            if (!checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)) {
                Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors");
                return errorOutputContainer.errors || emptyArray;
            }
        }
        const headMessage = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
        const restType = getNonArrayRestType(signature);
        const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
        for (let i = 0; i < argCount; i++) {
            const arg = args[i];
            if (arg.kind !== SyntaxKind.OmittedExpression) {
                const paramType = getTypeAtPosition(signature, i);
                const argType = checkExpressionWithContextualType(arg, paramType, /*inferenceContext*/ undefined, checkMode);
                // If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),
                // we obtain the regular type of any object literal arguments because we may not have inferred complete
                // parameter types yet and therefore excess property checks may yield false positives (see #17041).
                const checkArgType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType;
                const effectiveCheckArgumentNode = getEffectiveCheckNode(arg);
                if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? effectiveCheckArgumentNode : undefined, effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer)) {
                    Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");
                    maybeAddMissingAwaitInfo(arg, checkArgType, paramType);
                    return errorOutputContainer.errors || emptyArray;
                }
            }
        }
        if (restType) {
            const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, /*context*/ undefined, checkMode);
            const restArgCount = args.length - argCount;
            const errorNode = !reportErrors ? undefined :
                restArgCount === 0 ? node :
                restArgCount === 1 ? getEffectiveCheckNode(args[argCount]) :
                setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end);
            if (!checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, /*containingMessageChain*/ undefined, errorOutputContainer)) {
                Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors");
                maybeAddMissingAwaitInfo(errorNode, spreadType, restType);
                return errorOutputContainer.errors || emptyArray;
            }
        }
        return undefined;

        function maybeAddMissingAwaitInfo(errorNode: Node | undefined, source: Type, target: Type) {
            if (errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length) {
                // Bail if target is Promise-like---something else is wrong
                if (getAwaitedTypeOfPromise(target)) {
                    return;
                }
                const awaitedTypeOfSource = getAwaitedTypeOfPromise(source);
                if (awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation)) {
                    addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await));
                }
            }
        }
    }

    /**
     * Returns the this argument in calls like x.f(...) and x[f](...). Undefined otherwise.
     */
    function getThisArgumentOfCall(node: CallLikeExpression): Expression | undefined {
        if (node.kind === SyntaxKind.BinaryExpression) {
            return node.right;
        }

        const expression = node.kind === SyntaxKind.CallExpression ? node.expression :
            node.kind === SyntaxKind.TaggedTemplateExpression ? node.tag :
            node.kind === SyntaxKind.Decorator && !legacyDecorators ? node.expression :
            undefined;
        if (expression) {
            const callee = skipOuterExpressions(expression);
            if (isAccessExpression(callee)) {
                return callee.expression;
            }
        }
    }

    function createSyntheticExpression(parent: Node, type: Type, isSpread?: boolean, tupleNameSource?: ParameterDeclaration | NamedTupleMember) {
        const result = parseNodeFactory.createSyntheticExpression(type, isSpread, tupleNameSource);
        setTextRangeWorker(result, parent);
        setParent(result, parent);
        return result;
    }

    /**
     * Returns the effective arguments for an expression that works like a function invocation.
     */
    function getEffectiveCallArguments(node: CallLikeExpression): readonly Expression[] {
        if (isJsxOpeningFragment(node)) {
            // This attributes Type does not include a children property yet, the same way a fragment created with <React.Fragment> does not at this stage
            return [createSyntheticExpression(node, emptyFreshJsxObjectType)];
        }

        if (node.kind === SyntaxKind.TaggedTemplateExpression) {
            const template = node.template;
            const args: Expression[] = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
            if (template.kind === SyntaxKind.TemplateExpression) {
                forEach(template.templateSpans, span => {
                    args.push(span.expression);
                });
            }
            return args;
        }
        if (node.kind === SyntaxKind.Decorator) {
            return getEffectiveDecoratorArguments(node);
        }
        if (node.kind === SyntaxKind.BinaryExpression) {
            return [node.left];
        }
        if (isJsxOpeningLikeElement(node)) {
            return node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : emptyArray;
        }
        const args = node.arguments || emptyArray;
        const spreadIndex = getSpreadArgumentIndex(args);
        if (spreadIndex >= 0) {
            // Create synthetic arguments from spreads of tuple types.
            const effectiveArgs = args.slice(0, spreadIndex);
            for (let i = spreadIndex; i < args.length; i++) {
                const arg = args[i];
                // We can call checkExpressionCached because spread expressions never have a contextual type.
                const spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression));
                if (spreadType && isTupleType(spreadType)) {
                    forEach(getElementTypes(spreadType), (t, i) => {
                        const flags = spreadType.target.elementFlags[i];
                        const syntheticArg = createSyntheticExpression(arg, flags & ElementFlags.Rest ? createArrayType(t) : t, !!(flags & ElementFlags.Variable), spreadType.target.labeledElementDeclarations?.[i]);
                        effectiveArgs.push(syntheticArg);
                    });
                }
                else {
                    effectiveArgs.push(arg);
                }
            }
            return effectiveArgs;
        }
        return args;
    }

    /**
     * Returns the synthetic argument list for a decorator invocation.
     */
    function getEffectiveDecoratorArguments(node: Decorator): readonly Expression[] {
        const expr = node.expression;
        const signature = getDecoratorCallSignature(node);
        if (signature) {
            const args: Expression[] = [];
            for (const param of signature.parameters) {
                const type = getTypeOfSymbol(param);
                args.push(createSyntheticExpression(expr, type));
            }
            return args;
        }
        return Debug.fail();
    }

    /**
     * Returns the argument count for a decorator node that works like a function invocation.
     */
    function getDecoratorArgumentCount(node: Decorator, signature: Signature) {
        return compilerOptions.experimentalDecorators ?
            getLegacyDecoratorArgumentCount(node, signature) :
            // Allow the runtime to oversupply arguments to an ES decorator as long as there's at least one parameter.
            Math.min(Math.max(getParameterCount(signature), 1), 2);
    }

    /**
     * Returns the argument count for a decorator node that works like a function invocation.
     */
    function getLegacyDecoratorArgumentCount(node: Decorator, signature: Signature) {
        switch (node.parent.kind) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return 1;
            case SyntaxKind.PropertyDeclaration:
                return hasAccessorModifier(node.parent) ? 3 : 2;
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
                // For decorators with only two parameters we supply only two arguments
                return signature.parameters.length <= 2 ? 2 : 3;
            case SyntaxKind.Parameter:
                return 3;
            default:
                return Debug.fail();
        }
    }

    function getDiagnosticSpanForCallNode(node: CallExpression) {
        const sourceFile = getSourceFileOfNode(node);
        const { start, length } = getErrorSpanForNode(sourceFile, isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression);
        return { start, length, sourceFile };
    }

    function getDiagnosticForCallNode(node: CallLikeExpression, message: DiagnosticMessage | DiagnosticMessageChain, ...args: DiagnosticArguments): DiagnosticWithLocation {
        if (isCallExpression(node)) {
            const { sourceFile, start, length } = getDiagnosticSpanForCallNode(node);
            if ("message" in message) { // eslint-disable-line local/no-in-operator
                return createFileDiagnostic(sourceFile, start, length, message, ...args);
            }
            return createDiagnosticForFileFromMessageChain(sourceFile, message);
        }
        else {
            if ("message" in message) { // eslint-disable-line local/no-in-operator
                return createDiagnosticForNode(node, message, ...args);
            }
            return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message);
        }
    }

    function getErrorNodeForCallNode(callLike: CallLikeExpression): Node {
        if (isCallOrNewExpression(callLike)) {
            return isPropertyAccessExpression(callLike.expression) ? callLike.expression.name : callLike.expression;
        }
        if (isTaggedTemplateExpression(callLike)) {
            return isPropertyAccessExpression(callLike.tag) ? callLike.tag.name : callLike.tag;
        }
        if (isJsxOpeningLikeElement(callLike)) {
            return callLike.tagName;
        }
        return callLike;
    }

    function isPromiseResolveArityError(node: CallLikeExpression) {
        if (!isCallExpression(node) || !isIdentifier(node.expression)) return false;

        const symbol = resolveName(node.expression, node.expression.escapedText, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
        const decl = symbol?.valueDeclaration;
        if (!decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression)) {
            return false;
        }

        const globalPromiseSymbol = getGlobalPromiseConstructorSymbol(/*reportErrors*/ false);
        if (!globalPromiseSymbol) return false;

        const constructorSymbol = getSymbolAtLocation(decl.parent.parent.expression, /*ignoreErrors*/ true);
        return constructorSymbol === globalPromiseSymbol;
    }

    function getArgumentArityError(node: CallLikeExpression, signatures: readonly Signature[], args: readonly Expression[], headMessage?: DiagnosticMessage) {
        const spreadIndex = getSpreadArgumentIndex(args);
        if (spreadIndex > -1) {
            return createDiagnosticForNode(args[spreadIndex], Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter);
        }
        let min = Number.POSITIVE_INFINITY; // smallest parameter count
        let max = Number.NEGATIVE_INFINITY; // largest parameter count
        let maxBelow = Number.NEGATIVE_INFINITY; // largest parameter count that is smaller than the number of arguments
        let minAbove = Number.POSITIVE_INFINITY; // smallest parameter count that is larger than the number of arguments

        let closestSignature: Signature | undefined;
        for (const sig of signatures) {
            const minParameter = getMinArgumentCount(sig);
            const maxParameter = getParameterCount(sig);
            // smallest/largest parameter counts
            if (minParameter < min) {
                min = minParameter;
                closestSignature = sig;
            }
            max = Math.max(max, maxParameter);
            // shortest parameter count *longer than the call*/longest parameter count *shorter than the call*
            if (minParameter < args.length && minParameter > maxBelow) maxBelow = minParameter;
            if (args.length < maxParameter && maxParameter < minAbove) minAbove = maxParameter;
        }
        const hasRestParameter = some(signatures, hasEffectiveRestParameter);
        const parameterRange = hasRestParameter ? min
            : min < max ? min + "-" + max
            : min;
        const isVoidPromiseError = !hasRestParameter && parameterRange === 1 && args.length === 0 && isPromiseResolveArityError(node);
        if (isVoidPromiseError && isInJSFile(node)) {
            return getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments);
        }
        const error = isDecorator(node) ?
            hasRestParameter ? Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 :
                Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 :
            hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 :
            isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise :
            Diagnostics.Expected_0_arguments_but_got_1;

        if (min < args.length && args.length < max) {
            // between min and max, but with no matching overload
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove);
                chain = chainDiagnosticMessages(chain, headMessage);
                return getDiagnosticForCallNode(node, chain);
            }
            return getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove);
        }
        else if (args.length < min) {
            // too short: put the error span on the call expression, not any of the args
            let diagnostic: Diagnostic;
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, error, parameterRange, args.length);
                chain = chainDiagnosticMessages(chain, headMessage);
                diagnostic = getDiagnosticForCallNode(node, chain);
            }
            else {
                diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length);
            }
            const parameter = closestSignature?.declaration?.parameters[closestSignature.thisParameter ? args.length + 1 : args.length];
            if (parameter) {
                const messageAndArgs: DiagnosticAndArguments = isBindingPattern(parameter.name) ? [Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided]
                    : isRestParameter(parameter) ? [Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))]
                    : [Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : idText(getFirstIdentifier(parameter.name))];
                const parameterError = createDiagnosticForNode(parameter, ...messageAndArgs);
                return addRelatedInfo(diagnostic, parameterError);
            }
            return diagnostic;
        }
        else {
            // too long; error goes on the excess parameters
            const errorSpan = factory.createNodeArray(args.slice(max));
            const pos = first(errorSpan).pos;
            let end = last(errorSpan).end;
            if (end === pos) {
                end++;
            }
            setTextRangePosEnd(errorSpan, pos, end);
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, error, parameterRange, args.length);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange, args.length);
        }
    }

    function getTypeArgumentArityError(node: Node, signatures: readonly Signature[], typeArguments: NodeArray<TypeNode>, headMessage?: DiagnosticMessage) {
        const argCount = typeArguments.length;
        // No overloads exist
        if (signatures.length === 1) {
            const sig = signatures[0];
            const min = getMinTypeArgumentCount(sig.typeParameters);
            const max = length(sig.typeParameters);
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Expected_0_type_arguments_but_got_1, min < max ? min + "-" + max : min, argCount);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, min < max ? min + "-" + max : min, argCount);
        }
        // Overloads exist
        let belowArgCount = -Infinity;
        let aboveArgCount = Infinity;
        for (const sig of signatures) {
            const min = getMinTypeArgumentCount(sig.typeParameters);
            const max = length(sig.typeParameters);
            if (min > argCount) {
                aboveArgCount = Math.min(aboveArgCount, min);
            }
            else if (max < argCount) {
                belowArgCount = Math.max(belowArgCount, max);
            }
        }
        if (belowArgCount !== -Infinity && aboveArgCount !== Infinity) {
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
        }
        if (headMessage) {
            let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
            chain = chainDiagnosticMessages(chain, headMessage);
            return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
        }
        return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
    }

    function resolveCall(node: CallLikeExpression, signatures: readonly Signature[], candidatesOutArray: Signature[] | undefined, checkMode: CheckMode, callChainFlags: SignatureFlags, headMessage?: DiagnosticMessage): Signature {
        const isTaggedTemplate = node.kind === SyntaxKind.TaggedTemplateExpression;
        const isDecorator = node.kind === SyntaxKind.Decorator;
        const isJsxOpeningOrSelfClosingElement = isJsxOpeningLikeElement(node);
        const isJsxOpenFragment = isJsxOpeningFragment(node);
        const isInstanceof = node.kind === SyntaxKind.BinaryExpression;
        const reportErrors = !isInferencePartiallyBlocked && !candidatesOutArray;

        // The following variables are captured and modified by calls to chooseOverload.
        // If overload resolution or type argument inference fails, we want to report the
        // best error possible. The best error is one which says that an argument was not
        // assignable to a parameter. This implies that everything else about the overload
        // was fine. So if there is any overload that is only incorrect because of an
        // argument, we will report an error on that one.
        //
        //     function foo(s: string): void;
        //     function foo(n: number): void; // Report argument error on this overload
        //     function foo(): void;
        //     foo(true);
        //
        // If none of the overloads even made it that far, there are two possibilities.
        // There was a problem with type arguments for some overload, in which case
        // report an error on that. Or none of the overloads even had correct arity,
        // in which case give an arity error.
        //
        //     function foo<T extends string>(x: T): void; // Report type argument error
        //     function foo(): void;
        //     foo<number>(0);
        //
        let candidatesForArgumentError: Signature[] | undefined;
        let candidateForArgumentArityError: Signature | undefined;
        let candidateForTypeArgumentError: Signature | undefined;
        let result: Signature | undefined;
        let argCheckMode = CheckMode.Normal;

        let candidates: Signature[] = [];
        let typeArguments: NodeArray<TypeNode> | undefined;
        if (!isDecorator && !isInstanceof && !isSuperCall(node) && !isJsxOpenFragment) {
            typeArguments = (node as CallExpression).typeArguments;

            // We already perform checking on the type arguments on the class declaration itself.
            if (isTaggedTemplate || isJsxOpeningOrSelfClosingElement || (node as CallExpression).expression.kind !== SyntaxKind.SuperKeyword) {
                forEach(typeArguments, checkSourceElement);
            }
        }

        candidates = candidatesOutArray || [];
        // reorderCandidates fills up the candidates array directly
        reorderCandidates(signatures, candidates, callChainFlags);
        if (!isJsxOpenFragment) {
            Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this");
        }
        const args = getEffectiveCallArguments(node);

        // The excludeArgument array contains true for each context sensitive argument (an argument
        // is context sensitive it is susceptible to a one-time permanent contextual typing).
        //
        // The idea is that we will perform type argument inference & assignability checking once
        // without using the susceptible parameters that are functions, and once more for those
        // parameters, contextually typing each as we go along.
        //
        // For a tagged template, then the first argument be 'undefined' if necessary because it
        // represents a TemplateStringsArray.
        //
        // For a decorator, no arguments are susceptible to contextual typing due to the fact
        // decorators are applied to a declaration by the emitter, and not to an expression.
        const isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
        if (!isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive)) {
            argCheckMode = CheckMode.SkipContextSensitive;
        }

        // If we are in signature help, a trailing comma indicates that we intend to provide another argument,
        // so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
        const signatureHelpTrailingComma = !!(checkMode & CheckMode.IsForSignatureHelp) && node.kind === SyntaxKind.CallExpression && node.arguments.hasTrailingComma;

        // Section 4.12.1:
        // if the candidate list contains one or more signatures for which the type of each argument
        // expression is a subtype of each corresponding parameter type, the return type of the first
        // of those signatures becomes the return type of the function call.
        // Otherwise, the return type of the first signature in the candidate list becomes the return
        // type of the function call.
        //
        // Whether the call is an error is determined by assignability of the arguments. The subtype pass
        // is just important for choosing the best signature. So in the case where there is only one
        // signature, the subtype pass is useless. So skipping it is an optimization.
        if (candidates.length > 1) {
            result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
        }
        if (!result) {
            result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
        }
        const links = getNodeLinks(node);
        if (links.resolvedSignature !== resolvingSignature && !candidatesOutArray) {
            // There are 2 situations in which it's good to preemptively return the cached result here:
            //
            // 1. if the signature resolution originated on a node that itself depends on the contextual type
            // then it's possible that the resolved signature might not be the same as the one that would be computed in source order
            // since resolving such signature leads to resolving the potential outer signature, its arguments and thus the very same signature
            // it's possible that this inner resolution sets the resolvedSignature first.
            // In such a case we ignore the local result and reuse the correct one that was cached.
            //
            // 2. In certain circular-like situations it's possible that the compiler reentries this function for the same node.
            // It's possible to resolve the inner call against preemptively set empty members (for example in `resolveAnonymousTypeMembers`) of some type.
            // When that happens the compiler might report an error for that inner call but at the same time it might end up resolving the actual members of the other type.
            // This in turn creates a situation in which the outer call fails in `getSignatureApplicabilityError` due to a cached `RelationComparisonResult.Failed`
            // but when the compiler tries to report that error (in the code below) it also tries to elaborate it and that can succeed as types would be related against the *resolved* members of the other type.
            // This can hit `No error for last overload signature` assert but since that error was already reported when the inner call failed we can skip this step altogether here by returning the cached signature early.
            Debug.assert(links.resolvedSignature);
            return links.resolvedSignature;
        }
        if (result) {
            return result;
        }
        result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode);
        // Preemptively cache the result; getResolvedSignature will do this after we return, but
        // we need to ensure that the result is present for the error checks below so that if
        // this signature is encountered again, we handle the circularity (rather than producing a
        // different result which may produce no errors and assert). Callers of getResolvedSignature
        // don't hit this issue because they only observe this result after it's had a chance to
        // be cached, but the error reporting code below executes before getResolvedSignature sets
        // resolvedSignature.
        links.resolvedSignature = result;

        // No signatures were applicable. Now report errors based on the last applicable signature with
        // no arguments excluded from assignability checks.
        // If candidate is undefined, it means that no candidates had a suitable arity. In that case,
        // skip the checkApplicableSignature check.
        if (reportErrors) {
            // If the call expression is a synthetic call to a `[Symbol.hasInstance]` method then we will produce a head
            // message when reporting diagnostics that explains how we got to `right[Symbol.hasInstance](left)` from
            // `left instanceof right`, as it pertains to "Argument" related messages reported for the call.
            if (!headMessage && isInstanceof) {
                headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method;
            }
            if (candidatesForArgumentError) {
                if (candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3) {
                    const last = candidatesForArgumentError[candidatesForArgumentError.length - 1];
                    let chain: DiagnosticMessageChain | undefined;
                    if (candidatesForArgumentError.length > 3) {
                        chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error);
                        chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call);
                    }
                    if (headMessage) {
                        chain = chainDiagnosticMessages(chain, headMessage);
                    }
                    const diags = getSignatureApplicabilityError(node, args, last, assignableRelation, CheckMode.Normal, /*reportErrors*/ true, () => chain);
                    if (diags) {
                        for (const d of diags) {
                            if (last.declaration && candidatesForArgumentError.length > 3) {
                                addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here));
                            }
                            addImplementationSuccessElaboration(last, d);
                            diagnostics.add(d);
                        }
                    }
                    else {
                        Debug.fail("No error for last overload signature");
                    }
                }
                else {
                    const allDiagnostics: (readonly DiagnosticRelatedInformation[])[] = [];
                    let max = 0;
                    let min = Number.MAX_VALUE;
                    let minIndex = 0;
                    let i = 0;
                    for (const c of candidatesForArgumentError) {
                        const chain = () => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i + 1, candidates.length, signatureToString(c));
                        const diags = getSignatureApplicabilityError(node, args, c, assignableRelation, CheckMode.Normal, /*reportErrors*/ true, chain);
                        if (diags) {
                            if (diags.length <= min) {
                                min = diags.length;
                                minIndex = i;
                            }
                            max = Math.max(max, diags.length);
                            allDiagnostics.push(diags);
                        }
                        else {
                            Debug.fail("No error for 3 or fewer overload signatures");
                        }
                        i++;
                    }

                    const diags = max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics);
                    Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures");
                    let chain = chainDiagnosticMessages(
                        map(diags, createDiagnosticMessageChainFromDiagnostic),
                        Diagnostics.No_overload_matches_this_call,
                    );
                    if (headMessage) {
                        chain = chainDiagnosticMessages(chain, headMessage);
                    }
                    // The below is a spread to guarantee we get a new (mutable) array - our `flatMap` helper tries to do "smart" optimizations where it reuses input
                    // arrays and the emptyArray singleton where possible, which is decidedly not what we want while we're still constructing this diagnostic
                    const related = [...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[]];
                    let diag: Diagnostic;
                    if (every(diags, d => d.start === diags[0].start && d.length === diags[0].length && d.file === diags[0].file)) {
                        const { file, start, length } = diags[0];
                        diag = { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related };
                    }
                    else {
                        diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related);
                    }
                    addImplementationSuccessElaboration(candidatesForArgumentError[0], diag);
                    diagnostics.add(diag);
                }
            }
            else if (candidateForArgumentArityError) {
                diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args, headMessage));
            }
            else if (candidateForTypeArgumentError) {
                checkTypeArguments(candidateForTypeArgumentError, (node as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement).typeArguments!, /*reportErrors*/ true, headMessage);
            }
            else if (!isJsxOpenFragment) {
                const signaturesWithCorrectTypeArgumentArity = filter(signatures, s => hasCorrectTypeArgumentArity(s, typeArguments));
                if (signaturesWithCorrectTypeArgumentArity.length === 0) {
                    diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments!, headMessage));
                }
                else {
                    diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage));
                }
            }
        }

        return result;

        function addImplementationSuccessElaboration(failed: Signature, diagnostic: Diagnostic) {
            const oldCandidatesForArgumentError = candidatesForArgumentError;
            const oldCandidateForArgumentArityError = candidateForArgumentArityError;
            const oldCandidateForTypeArgumentError = candidateForTypeArgumentError;

            const failedSignatureDeclarations = failed.declaration?.symbol?.declarations || emptyArray;
            const isOverload = failedSignatureDeclarations.length > 1;
            const implDecl = isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined;
            if (implDecl) {
                const candidate = getSignatureFromDeclaration(implDecl as FunctionLikeDeclaration);
                const isSingleNonGenericCandidate = !candidate.typeParameters;
                if (chooseOverload([candidate], assignableRelation, isSingleNonGenericCandidate)) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible));
                }
            }

            candidatesForArgumentError = oldCandidatesForArgumentError;
            candidateForArgumentArityError = oldCandidateForArgumentArityError;
            candidateForTypeArgumentError = oldCandidateForTypeArgumentError;
        }

        function chooseOverload(candidates: Signature[], relation: Map<string, RelationComparisonResult>, isSingleNonGenericCandidate: boolean, signatureHelpTrailingComma = false) {
            candidatesForArgumentError = undefined;
            candidateForArgumentArityError = undefined;
            candidateForTypeArgumentError = undefined;

            if (isSingleNonGenericCandidate) {
                const candidate = candidates[0];
                if (some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                    return undefined;
                }
                if (getSignatureApplicabilityError(node, args, candidate, relation, CheckMode.Normal, /*reportErrors*/ false, /*containingMessageChain*/ undefined)) {
                    candidatesForArgumentError = [candidate];
                    return undefined;
                }
                return candidate;
            }

            for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {
                const candidate = candidates[candidateIndex];
                if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                    continue;
                }

                let checkCandidate: Signature;
                let inferenceContext: InferenceContext | undefined;

                if (candidate.typeParameters) {
                    let typeArgumentTypes: Type[] | undefined;
                    if (some(typeArguments)) {
                        typeArgumentTypes = checkTypeArguments(candidate, typeArguments, /*reportErrors*/ false);
                        if (!typeArgumentTypes) {
                            candidateForTypeArgumentError = candidate;
                            continue;
                        }
                    }
                    else {
                        inferenceContext = createInferenceContext(candidate.typeParameters, candidate, /*flags*/ isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);
                        typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode | CheckMode.SkipGenericFunctions, inferenceContext);
                        argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal;
                    }
                    checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
                    // If the original signature has a generic rest type, instantiation may produce a
                    // signature with different arity and we need to perform another arity check.
                    if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                        candidateForArgumentArityError = checkCandidate;
                        continue;
                    }
                }
                else {
                    checkCandidate = candidate;
                }
                if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors*/ false, /*containingMessageChain*/ undefined)) {
                    // Give preference to error candidates that have no rest parameters (as they are more specific)
                    (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                    continue;
                }
                if (argCheckMode) {
                    // If one or more context sensitive arguments were excluded, we start including
                    // them now (and keeping do so for any subsequent candidates) and perform a second
                    // round of type inference and applicability checking for this particular candidate.
                    argCheckMode = CheckMode.Normal;
                    if (inferenceContext) {
                        const typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext);
                        checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters);
                        // If the original signature has a generic rest type, instantiation may produce a
                        // signature with different arity and we need to perform another arity check.
                        if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                            candidateForArgumentArityError = checkCandidate;
                            continue;
                        }
                    }
                    if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors*/ false, /*containingMessageChain*/ undefined)) {
                        // Give preference to error candidates that have no rest parameters (as they are more specific)
                        (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                        continue;
                    }
                }
                candidates[candidateIndex] = checkCandidate;
                return checkCandidate;
            }

            return undefined;
        }
    }

    // No signature was applicable. We have already reported the errors for the invalid signature.
    function getCandidateForOverloadFailure(
        node: CallLikeExpression,
        candidates: Signature[],
        args: readonly Expression[],
        hasCandidatesOutArray: boolean,
        checkMode: CheckMode,
    ): Signature {
        Debug.assert(candidates.length > 0); // Else should not have called this.
        checkNodeDeferred(node);
        // Normally we will combine overloads. Skip this if they have type parameters since that's hard to combine.
        // Don't do this if there is a `candidatesOutArray`,
        // because then we want the chosen best candidate to be one of the overloads, not a combination.
        return hasCandidatesOutArray || candidates.length === 1 || candidates.some(c => !!c.typeParameters)
            ? pickLongestCandidateSignature(node, candidates, args, checkMode)
            : createUnionOfSignaturesForOverloadFailure(candidates);
    }

    function createUnionOfSignaturesForOverloadFailure(candidates: readonly Signature[]): Signature {
        const thisParameters = mapDefined(candidates, c => c.thisParameter);
        let thisParameter: Symbol | undefined;
        if (thisParameters.length) {
            thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter));
        }
        const { min: minArgumentCount, max: maxNonRestParam } = minAndMax(candidates, getNumNonRestParameters);
        const parameters: Symbol[] = [];
        for (let i = 0; i < maxNonRestParam; i++) {
            const symbols = mapDefined(candidates, s =>
                signatureHasRestParameter(s) ?
                    i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) :
                    i < s.parameters.length ? s.parameters[i] : undefined);
            Debug.assert(symbols.length !== 0);
            parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, candidate => tryGetTypeAtPosition(candidate, i))));
        }
        const restParameterSymbols = mapDefined(candidates, c => signatureHasRestParameter(c) ? last(c.parameters) : undefined);
        let flags = SignatureFlags.IsSignatureCandidateForOverloadFailure;
        if (restParameterSymbols.length !== 0) {
            const type = createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), UnionReduction.Subtype));
            parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type));
            flags |= SignatureFlags.HasRestParameter;
        }
        if (candidates.some(signatureHasLiteralTypes)) {
            flags |= SignatureFlags.HasLiteralTypes;
        }
        return createSignature(
            candidates[0].declaration,
            /*typeParameters*/ undefined, // Before calling this we tested for `!candidates.some(c => !!c.typeParameters)`.
            thisParameter,
            parameters,
            /*resolvedReturnType*/ getIntersectionType(candidates.map(getReturnTypeOfSignature)),
            /*resolvedTypePredicate*/ undefined,
            minArgumentCount,
            flags,
        );
    }

    function getNumNonRestParameters(signature: Signature): number {
        const numParams = signature.parameters.length;
        return signatureHasRestParameter(signature) ? numParams - 1 : numParams;
    }

    function createCombinedSymbolFromTypes(sources: readonly Symbol[], types: Type[]): Symbol {
        return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, UnionReduction.Subtype));
    }

    function createCombinedSymbolForOverloadFailure(sources: readonly Symbol[], type: Type): Symbol {
        // This function is currently only used for erroneous overloads, so it's good enough to just use the first source.
        return createSymbolWithType(first(sources), type);
    }

    function pickLongestCandidateSignature(node: CallLikeExpression, candidates: Signature[], args: readonly Expression[], checkMode: CheckMode): Signature {
        // Pick the longest signature. This way we can get a contextual type for cases like:
        //     declare function f(a: { xa: number; xb: number; }, b: number);
        //     f({ |
        // Also, use explicitly-supplied type arguments if they are provided, so we can get a contextual signature in cases like:
        //     declare function f<T>(k: keyof T);
        //     f<Foo>("
        const bestIndex = getLongestCandidateIndex(candidates, apparentArgumentCount === undefined ? args.length : apparentArgumentCount);
        const candidate = candidates[bestIndex];
        const { typeParameters } = candidate;
        if (!typeParameters) {
            return candidate;
        }

        const typeArgumentNodes: readonly TypeNode[] | undefined = callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined;
        const instantiated = typeArgumentNodes
            ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))
            : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode);
        candidates[bestIndex] = instantiated;
        return instantiated;
    }

    function getTypeArgumentsFromNodes(typeArgumentNodes: readonly TypeNode[], typeParameters: readonly TypeParameter[], isJs: boolean): readonly Type[] {
        const typeArguments = typeArgumentNodes.map(getTypeOfNode);
        while (typeArguments.length > typeParameters.length) {
            typeArguments.pop();
        }
        while (typeArguments.length < typeParameters.length) {
            typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));
        }
        return typeArguments;
    }

    function inferSignatureInstantiationForOverloadFailure(node: CallLikeExpression, typeParameters: readonly TypeParameter[], candidate: Signature, args: readonly Expression[], checkMode: CheckMode): Signature {
        const inferenceContext = createInferenceContext(typeParameters, candidate, /*flags*/ isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);
        const typeArgumentTypes = inferTypeArguments(node, candidate, args, checkMode | CheckMode.SkipContextSensitive | CheckMode.SkipGenericFunctions, inferenceContext);
        return createSignatureInstantiation(candidate, typeArgumentTypes);
    }

    function getLongestCandidateIndex(candidates: Signature[], argsCount: number): number {
        let maxParamsIndex = -1;
        let maxParams = -1;

        for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            const paramCount = getParameterCount(candidate);
            if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {
                return i;
            }
            if (paramCount > maxParams) {
                maxParams = paramCount;
                maxParamsIndex = i;
            }
        }

        return maxParamsIndex;
    }

    function resolveCallExpression(node: CallExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        if (node.expression.kind === SyntaxKind.SuperKeyword) {
            const superType = checkSuperExpression(node.expression);
            if (isTypeAny(superType)) {
                for (const arg of node.arguments) {
                    checkExpression(arg); // Still visit arguments so they get marked for visibility, etc
                }
                return anySignature;
            }
            if (!isErrorType(superType)) {
                // In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
                // with the type arguments specified in the extends clause.
                const baseTypeNode = getEffectiveBaseTypeNode(getContainingClass(node)!);
                if (baseTypeNode) {
                    const baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
                    return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlags.None);
                }
            }
            return resolveUntypedCall(node);
        }

        let callChainFlags: SignatureFlags;
        let funcType = checkExpression(node.expression);
        if (isCallChain(node)) {
            const nonOptionalType = getOptionalExpressionType(funcType, node.expression);
            callChainFlags = nonOptionalType === funcType ? SignatureFlags.None :
                isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain :
                SignatureFlags.IsInnerCallChain;
            funcType = nonOptionalType;
        }
        else {
            callChainFlags = SignatureFlags.None;
        }

        funcType = checkNonNullTypeWithReporter(
            funcType,
            node.expression,
            reportCannotInvokePossiblyNullOrUndefinedError,
        );

        if (funcType === silentNeverType) {
            return silentNeverSignature;
        }

        const apparentType = getApparentType(funcType);
        if (isErrorType(apparentType)) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }

        // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // but we are not including call signatures that may have been added to the Object or
        // Function interface, since they have none by default. This is a bit of a leap of faith
        // that the user will not add any.
        const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
        const numConstructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct).length;

        // TS 1.0 Spec: 4.12
        // In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
        // types are provided for the argument expressions, and the result is always of type Any.
        if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
            // The unknownType indicates that an error already occurred (and was reported).  No
            // need to report another error in this case.
            if (!isErrorType(funcType) && node.typeArguments) {
                error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }
        // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
        // TypeScript employs overload resolution in typed function calls in order to support functions
        // with multiple call signatures.
        if (!callSignatures.length) {
            if (numConstructSignatures) {
                error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            }
            else {
                let relatedInformation: DiagnosticRelatedInformation | undefined;
                if (node.arguments.length === 1) {
                    const text = getSourceFileOfNode(node).text;
                    if (isLineBreak(text.charCodeAt(skipTrivia(text, node.expression.end, /*stopAfterLineBreak*/ true) - 1))) {
                        relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon);
                    }
                }
                invocationError(node.expression, apparentType, SignatureKind.Call, relatedInformation);
            }
            return resolveErrorCall(node);
        }
        // When a call to a generic function is an argument to an outer call to a generic function for which
        // inference is in process, we have a choice to make. If the inner call relies on inferences made from
        // its contextual type to its return type, deferring the inner call processing allows the best possible
        // contextual type to accumulate. But if the outer call relies on inferences made from the return type of
        // the inner call, the inner call should be processed early. There's no sure way to know which choice is
        // right (only a full unification algorithm can determine that), so we resort to the following heuristic:
        // If no type arguments are specified in the inner call and at least one call signature is generic and
        // returns a function type, we choose to defer processing. This narrowly permits function composition
        // operators to flow inferences through return types, but otherwise processes calls right away. We
        // use the resolvingSignature singleton to indicate that we deferred processing. This result will be
        // propagated out and eventually turned into silentNeverType (a type that is assignable to anything and
        // from which we never make inferences).
        if (checkMode & CheckMode.SkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction)) {
            skippedGenericFunction(node, checkMode);
            return resolvingSignature;
        }
        // If the function is explicitly marked with `@class`, then it must be constructed.
        if (callSignatures.some(sig => isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration!))) {
            error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            return resolveErrorCall(node);
        }

        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags);
    }

    function isGenericFunctionReturningFunction(signature: Signature) {
        return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)));
    }

    /**
     * TS 1.0 spec: 4.12
     * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
     * but is a subtype of the Function interface, the call is an untyped function call.
     */
    function isUntypedFunctionCall(funcType: Type, apparentFuncType: Type, numCallSignatures: number, numConstructSignatures: number): boolean {
        // We exclude union types because we may have a union of function types that happen to have no common signatures.
        return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags & TypeFlags.TypeParameter) ||
            !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & TypeFlags.Union) && !(getReducedType(apparentFuncType).flags & TypeFlags.Never) && isTypeAssignableTo(funcType, globalFunctionType);
    }

    function resolveNewExpression(node: NewExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        let expressionType = checkNonNullExpression(node.expression);
        if (expressionType === silentNeverType) {
            return silentNeverSignature;
        }

        // If expressionType's apparent type(section 3.8.1) is an object type with one or
        // more construct signatures, the expression is processed in the same manner as a
        // function call, but using the construct signatures as the initial set of candidate
        // signatures for overload resolution. The result type of the function call becomes
        // the result type of the operation.
        expressionType = getApparentType(expressionType);
        if (isErrorType(expressionType)) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }

        // TS 1.0 spec: 4.11
        // If expressionType is of type Any, Args can be any argument
        // list and the result of the operation is of type Any.
        if (isTypeAny(expressionType)) {
            if (node.typeArguments) {
                error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }

        // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // but we are not including construct signatures that may have been added to the Object or
        // Function interface, since they have none by default. This is a bit of a leap of faith
        // that the user will not add any.
        const constructSignatures = getSignaturesOfType(expressionType, SignatureKind.Construct);
        if (constructSignatures.length) {
            if (!isConstructorAccessible(node, constructSignatures[0])) {
                return resolveErrorCall(node);
            }
            // If the expression is a class of abstract type, or an abstract construct signature,
            // then it cannot be instantiated.
            // In the case of a merged class-module or class-interface declaration,
            // only the class declaration node will have the Abstract flag set.
            if (someSignature(constructSignatures, signature => !!(signature.flags & SignatureFlags.Abstract))) {
                error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                return resolveErrorCall(node);
            }
            const valueDecl = expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol);
            if (valueDecl && hasSyntacticModifier(valueDecl, ModifierFlags.Abstract)) {
                error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                return resolveErrorCall(node);
            }

            return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
        }

        // If expressionType's apparent type is an object type with no construct signatures but
        // one or more call signatures, the expression is processed as a function call. A compile-time
        // error occurs if the result of the function call is not Void. The type of the result of the
        // operation is Any. It is an error to have a Void this type.
        const callSignatures = getSignaturesOfType(expressionType, SignatureKind.Call);
        if (callSignatures.length) {
            const signature = resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
            if (!noImplicitAny) {
                if (signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType) {
                    error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                }
                if (getThisTypeOfSignature(signature) === voidType) {
                    error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
                }
            }
            return signature;
        }

        invocationError(node.expression, expressionType, SignatureKind.Construct);
        return resolveErrorCall(node);
    }

    function someSignature(signatures: Signature | readonly Signature[], f: (s: Signature) => boolean): boolean {
        if (isArray(signatures)) {
            return some(signatures, signature => someSignature(signature, f));
        }
        return signatures.compositeKind === TypeFlags.Union ? some(signatures.compositeSignatures, f) : f(signatures);
    }

    function typeHasProtectedAccessibleBase(target: Symbol, type: InterfaceType): boolean {
        const baseTypes = getBaseTypes(type);
        if (!length(baseTypes)) {
            return false;
        }
        const firstBase = baseTypes[0];
        if (firstBase.flags & TypeFlags.Intersection) {
            const types = (firstBase as IntersectionType).types;
            const mixinFlags = findMixins(types);
            let i = 0;
            for (const intersectionMember of (firstBase as IntersectionType).types) {
                // We want to ignore mixin ctors
                if (!mixinFlags[i]) {
                    if (getObjectFlags(intersectionMember) & (ObjectFlags.Class | ObjectFlags.Interface)) {
                        if (intersectionMember.symbol === target) {
                            return true;
                        }
                        if (typeHasProtectedAccessibleBase(target, intersectionMember as InterfaceType)) {
                            return true;
                        }
                    }
                }
                i++;
            }
            return false;
        }
        if (firstBase.symbol === target) {
            return true;
        }
        return typeHasProtectedAccessibleBase(target, firstBase as InterfaceType);
    }

    function isConstructorAccessible(node: NewExpression, signature: Signature) {
        if (!signature || !signature.declaration) {
            return true;
        }

        const declaration = signature.declaration;
        const modifiers = getSelectedEffectiveModifierFlags(declaration, ModifierFlags.NonPublicAccessibilityModifier);

        // (1) Public constructors and (2) constructor functions are always accessible.
        if (!modifiers || declaration.kind !== SyntaxKind.Constructor) {
            return true;
        }

        const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(declaration.parent.symbol)!;
        const declaringClass = getDeclaredTypeOfSymbol(declaration.parent.symbol) as InterfaceType;

        // A private or protected constructor can only be instantiated within its own class (or a subclass, for protected)
        if (!isNodeWithinClass(node, declaringClassDeclaration)) {
            const containingClass = getContainingClass(node);
            if (containingClass && modifiers & ModifierFlags.Protected) {
                const containingType = getTypeOfNode(containingClass);
                if (typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType as InterfaceType)) {
                    return true;
                }
            }
            if (modifiers & ModifierFlags.Private) {
                error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
            }
            if (modifiers & ModifierFlags.Protected) {
                error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
            }
            return false;
        }

        return true;
    }

    function invocationErrorDetails(errorTarget: Node, apparentType: Type, kind: SignatureKind): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } {
        let errorInfo: DiagnosticMessageChain | undefined;
        const isCall = kind === SignatureKind.Call;
        const awaitedType = getAwaitedType(apparentType);
        const maybeMissingAwait = awaitedType && getSignaturesOfType(awaitedType, kind).length > 0;
        if (apparentType.flags & TypeFlags.Union) {
            const types = (apparentType as UnionType).types;
            let hasSignatures = false;
            for (const constituent of types) {
                const signatures = getSignaturesOfType(constituent, kind);
                if (signatures.length !== 0) {
                    hasSignatures = true;
                    if (errorInfo) {
                        // Bail early if we already have an error, no chance of "No constituent of type is callable"
                        break;
                    }
                }
                else {
                    // Error on the first non callable constituent only
                    if (!errorInfo) {
                        errorInfo = chainDiagnosticMessages(
                            errorInfo,
                            isCall ?
                                Diagnostics.Type_0_has_no_call_signatures :
                                Diagnostics.Type_0_has_no_construct_signatures,
                            typeToString(constituent),
                        );
                        errorInfo = chainDiagnosticMessages(
                            errorInfo,
                            isCall ?
                                Diagnostics.Not_all_constituents_of_type_0_are_callable :
                                Diagnostics.Not_all_constituents_of_type_0_are_constructable,
                            typeToString(apparentType),
                        );
                    }
                    if (hasSignatures) {
                        // Bail early if we already found a siganture, no chance of "No constituent of type is callable"
                        break;
                    }
                }
            }
            if (!hasSignatures) {
                errorInfo = chainDiagnosticMessages(
                    /*details*/ undefined,
                    isCall ?
                        Diagnostics.No_constituent_of_type_0_is_callable :
                        Diagnostics.No_constituent_of_type_0_is_constructable,
                    typeToString(apparentType),
                );
            }
            if (!errorInfo) {
                errorInfo = chainDiagnosticMessages(
                    errorInfo,
                    isCall ?
                        Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :
                        Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other,
                    typeToString(apparentType),
                );
            }
        }
        else {
            errorInfo = chainDiagnosticMessages(
                errorInfo,
                isCall ?
                    Diagnostics.Type_0_has_no_call_signatures :
                    Diagnostics.Type_0_has_no_construct_signatures,
                typeToString(apparentType),
            );
        }

        let headMessage = isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable;

        // Diagnose get accessors incorrectly called as functions
        if (isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length === 0) {
            const { resolvedSymbol } = getNodeLinks(errorTarget);
            if (resolvedSymbol && resolvedSymbol.flags & SymbolFlags.GetAccessor) {
                headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without;
            }
        }

        return {
            messageChain: chainDiagnosticMessages(errorInfo, headMessage),
            relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : undefined,
        };
    }
    function invocationError(errorTarget: Node, apparentType: Type, kind: SignatureKind, relatedInformation?: DiagnosticRelatedInformation) {
        const { messageChain, relatedMessage: relatedInfo } = invocationErrorDetails(errorTarget, apparentType, kind);
        const diagnostic = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain);
        if (relatedInfo) {
            addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo));
        }
        if (isCallExpression(errorTarget.parent)) {
            const { start, length } = getDiagnosticSpanForCallNode(errorTarget.parent);
            diagnostic.start = start;
            diagnostic.length = length;
        }
        diagnostics.add(diagnostic);
        invocationErrorRecovery(apparentType, kind, relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic);
    }

    function invocationErrorRecovery(apparentType: Type, kind: SignatureKind, diagnostic: Diagnostic) {
        if (!apparentType.symbol) {
            return;
        }
        const importNode = getSymbolLinks(apparentType.symbol).originatingImport;
        // Create a diagnostic on the originating import if possible onto which we can attach a quickfix
        //  An import call expression cannot be rewritten into another form to correct the error - the only solution is to use `.default` at the use-site
        if (importNode && !isImportCall(importNode)) {
            const sigs = getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target!), kind);
            if (!sigs || !sigs.length) return;

            addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead));
        }
    }

    function resolveTaggedTemplateExpression(node: TaggedTemplateExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        const tagType = checkExpression(node.tag);
        const apparentType = getApparentType(tagType);

        if (isErrorType(apparentType)) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }

        const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
        const numConstructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct).length;

        if (isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures)) {
            return resolveUntypedCall(node);
        }

        if (!callSignatures.length) {
            if (isArrayLiteralExpression(node.parent)) {
                const diagnostic = createDiagnosticForNode(node.tag, Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked);
                diagnostics.add(diagnostic);
                return resolveErrorCall(node);
            }

            invocationError(node.tag, apparentType, SignatureKind.Call);
            return resolveErrorCall(node);
        }

        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
    }

    /**
     * Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.
     */
    function getDiagnosticHeadMessageForDecoratorResolution(node: Decorator) {
        switch (node.parent.kind) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;

            case SyntaxKind.Parameter:
                return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;

            case SyntaxKind.PropertyDeclaration:
                return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;

            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
                return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;

            default:
                return Debug.fail();
        }
    }

    /**
     * Resolves a decorator as if it were a call expression.
     */
    function resolveDecorator(node: Decorator, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        const funcType = checkExpression(node.expression);
        const apparentType = getApparentType(funcType);
        if (isErrorType(apparentType)) {
            return resolveErrorCall(node);
        }

        const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
        const numConstructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct).length;
        if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
            return resolveUntypedCall(node);
        }

        if (isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression)) {
            const nodeStr = getTextOfNode(node.expression, /*includeTrivia*/ false);
            error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr);
            return resolveErrorCall(node);
        }

        const headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
        if (!callSignatures.length) {
            const errorDetails = invocationErrorDetails(node.expression, apparentType, SignatureKind.Call);
            const messageChain = chainDiagnosticMessages(errorDetails.messageChain, headMessage);
            const diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node.expression), node.expression, messageChain);
            if (errorDetails.relatedMessage) {
                addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage));
            }
            diagnostics.add(diag);
            invocationErrorRecovery(apparentType, SignatureKind.Call, diag);
            return resolveErrorCall(node);
        }

        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None, headMessage);
    }

    function createSignatureForJSXIntrinsic(node: JsxCallLike, result: Type): Signature {
        const namespace = getJsxNamespaceAt(node);
        const exports = namespace && getExportsOfSymbol(namespace);
        // We fake up a SFC signature for each intrinsic, however a more specific per-element signature drawn from the JSX declaration
        // file would probably be preferable.
        const typeSymbol = exports && getSymbol(exports, JsxNames.Element, SymbolFlags.Type);
        const returnNode = typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlags.Type, node);
        const declaration = factory.createFunctionTypeNode(/*typeParameters*/ undefined, [factory.createParameterDeclaration(/*modifiers*/ undefined, /*dotDotDotToken*/ undefined, "props", /*questionToken*/ undefined, nodeBuilder.typeToTypeNode(result, node))], returnNode ? factory.createTypeReferenceNode(returnNode, /*typeArguments*/ undefined) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword));
        const parameterSymbol = createSymbol(SymbolFlags.FunctionScopedVariable, "props" as __String);
        parameterSymbol.links.type = result;
        return createSignature(
            declaration,
            /*typeParameters*/ undefined,
            /*thisParameter*/ undefined,
            [parameterSymbol],
            typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType,
            /*resolvedTypePredicate*/ undefined,
            1,
            SignatureFlags.None,
        );
    }

    function getJSXFragmentType(node: JsxOpeningFragment): Type {
        // An opening fragment is required in order for `getJsxNamespace` to give the fragment factory
        const sourceFileLinks = getNodeLinks(getSourceFileOfNode(node));
        if (sourceFileLinks.jsxFragmentType !== undefined) return sourceFileLinks.jsxFragmentType;

        const jsxFragmentFactoryName = getJsxNamespace(node);

        // #38720/60122, allow null as jsxFragmentFactory
        const shouldResolveFactoryReference = (compilerOptions.jsx === JsxEmit.React || compilerOptions.jsxFragmentFactory !== undefined) && jsxFragmentFactoryName !== "null";
        if (!shouldResolveFactoryReference) return sourceFileLinks.jsxFragmentType = anyType;

        const shouldModuleRefErr = compilerOptions.jsx !== JsxEmit.Preserve && compilerOptions.jsx !== JsxEmit.ReactNative;
        const jsxFactoryRefErr = diagnostics ? Diagnostics.Using_JSX_fragments_requires_fragment_factory_0_to_be_in_scope_but_it_could_not_be_found : undefined;
        const jsxFactorySymbol = getJsxNamespaceContainerForImplicitImport(node) ??
            resolveName(
                node,
                jsxFragmentFactoryName,
                shouldModuleRefErr ? SymbolFlags.Value : SymbolFlags.Value & ~SymbolFlags.Enum,
                /*nameNotFoundMessage*/ jsxFactoryRefErr,
                /*isUse*/ true,
            );

        if (jsxFactorySymbol === undefined) return sourceFileLinks.jsxFragmentType = errorType;
        if (jsxFactorySymbol.escapedName === ReactNames.Fragment) return sourceFileLinks.jsxFragmentType = getTypeOfSymbol(jsxFactorySymbol);

        const resolvedAlias = (jsxFactorySymbol.flags & SymbolFlags.Alias) === 0 ? jsxFactorySymbol : resolveAlias(jsxFactorySymbol);
        const reactExports = jsxFactorySymbol && getExportsOfSymbol(resolvedAlias);
        const typeSymbol = reactExports && getSymbol(reactExports, ReactNames.Fragment, SymbolFlags.BlockScopedVariable);
        const type = typeSymbol && getTypeOfSymbol(typeSymbol);
        return sourceFileLinks.jsxFragmentType = type === undefined ? errorType : type;
    }

    function resolveJsxOpeningLikeElement(node: JsxCallLike, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        const isJsxOpenFragment = isJsxOpeningFragment(node);
        let exprTypes: Type;
        if (!isJsxOpenFragment) {
            if (isJsxIntrinsicTagName(node.tagName)) {
                const result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
                const fakeSignature = createSignatureForJSXIntrinsic(node, result);
                checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), /*inferenceContext*/ undefined, CheckMode.Normal), result, node.tagName, node.attributes);
                if (length(node.typeArguments)) {
                    forEach(node.typeArguments, checkSourceElement);
                    diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), node.typeArguments!, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments)));
                }
                return fakeSignature;
            }
            exprTypes = checkExpression(node.tagName);
        }
        else {
            exprTypes = getJSXFragmentType(node);
        }
        const apparentType = getApparentType(exprTypes);
        if (isErrorType(apparentType)) {
            return resolveErrorCall(node);
        }
        const signatures = getUninstantiatedJsxSignaturesOfType(exprTypes, node);
        if (isUntypedFunctionCall(exprTypes, apparentType, signatures.length, /*constructSignatures*/ 0)) {
            return resolveUntypedCall(node);
        }

        if (signatures.length === 0) {
            // We found no signatures at all, which is an error
            if (isJsxOpenFragment) {
                error(node, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node));
            }
            else {
                error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName));
            }
            return resolveErrorCall(node);
        }

        return resolveCall(node, signatures, candidatesOutArray, checkMode, SignatureFlags.None);
    }

    function resolveInstanceofExpression(node: InstanceofExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        // if rightType is an object type with a custom `[Symbol.hasInstance]` method, then it is potentially
        // valid on the right-hand side of the `instanceof` operator. This allows normal `object` types to
        // participate in `instanceof`, as per Step 2 of https://tc39.es/ecma262/#sec-instanceofoperator.
        const rightType = checkExpression(node.right);
        if (!isTypeAny(rightType)) {
            const hasInstanceMethodType = getSymbolHasInstanceMethodOfObjectType(rightType);
            if (hasInstanceMethodType) {
                const apparentType = getApparentType(hasInstanceMethodType);
                if (isErrorType(apparentType)) {
                    return resolveErrorCall(node);
                }

                const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
                const constructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct);
                if (isUntypedFunctionCall(hasInstanceMethodType, apparentType, callSignatures.length, constructSignatures.length)) {
                    return resolveUntypedCall(node);
                }

                if (callSignatures.length) {
                    return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
                }
            }
            // NOTE: do not raise error if right is unknown as related error was already reported
            else if (!(typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType))) {
                error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method);
                return resolveErrorCall(node);
            }
        }
        // fall back to a default signature
        return anySignature;
    }

    /**
     * Sometimes, we have a decorator that could accept zero arguments,
     * but is receiving too many arguments as part of the decorator invocation.
     * In those cases, a user may have meant to *call* the expression before using it as a decorator.
     */
    function isPotentiallyUncalledDecorator(decorator: Decorator, signatures: readonly Signature[]) {
        return signatures.length && every(signatures, signature =>
            signature.minArgumentCount === 0 &&
            !signatureHasRestParameter(signature) &&
            signature.parameters.length < getDecoratorArgumentCount(decorator, signature));
    }

    function resolveSignature(node: CallLikeExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        switch (node.kind) {
            case SyntaxKind.CallExpression:
                return resolveCallExpression(node, candidatesOutArray, checkMode);
            case SyntaxKind.NewExpression:
                return resolveNewExpression(node, candidatesOutArray, checkMode);
            case SyntaxKind.TaggedTemplateExpression:
                return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);
            case SyntaxKind.Decorator:
                return resolveDecorator(node, candidatesOutArray, checkMode);
            case SyntaxKind.JsxOpeningFragment:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);
            case SyntaxKind.BinaryExpression:
                return resolveInstanceofExpression(node, candidatesOutArray, checkMode);
        }
        Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.");
    }

    /**
     * Resolve a signature of a given call-like expression.
     * @param node a call-like expression to try resolve a signature for
     * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
     *                           the function will fill it up with appropriate candidate signatures
     * @return a signature of the call-like expression or undefined if one can't be found
     */
    function getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[] | undefined, checkMode?: CheckMode): Signature {
        const links = getNodeLinks(node);
        // If getResolvedSignature has already been called, we will have cached the resolvedSignature.
        // However, it is possible that either candidatesOutArray was not passed in the first time,
        // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
        // to correctly fill the candidatesOutArray.
        const cached = links.resolvedSignature;
        if (cached && cached !== resolvingSignature && !candidatesOutArray) {
            return cached;
        }
        const saveResolutionStart = resolutionStart;
        if (!cached) {
            // If we haven't already done so, temporarily reset the resolution stack. This allows us to
            // handle "inverted" situations where, for example, an API client asks for the type of a symbol
            // containined in a function call argument whose contextual type depends on the symbol itself
            // through resolution of the containing function call. By resetting the resolution stack we'll
            // retry the symbol type resolution with the resolvingSignature marker in place to suppress
            // the contextual type circularity.
            resolutionStart = resolutionTargets.length;
        }
        links.resolvedSignature = resolvingSignature;
        const result = resolveSignature(node, candidatesOutArray, checkMode || CheckMode.Normal);
        resolutionStart = saveResolutionStart;
        // When CheckMode.SkipGenericFunctions is set we use resolvingSignature to indicate that call
        // resolution should be deferred.
        if (result !== resolvingSignature) {
            // If signature resolution originated in control flow type analysis (for example to compute the
            // assigned type in a flow assignment) we don't cache the result as it may be based on temporary
            // types from the control flow analysis.
            links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
        }
        return result;
    }

    /**
     * Indicates whether a declaration can be treated as a constructor in a JavaScript
     * file.
     */
    function isJSConstructor(node: Node | undefined): node is FunctionDeclaration | FunctionExpression {
        if (!node || !isInJSFile(node)) {
            return false;
        }
        const func = isFunctionDeclaration(node) || isFunctionExpression(node) ? node :
            (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer :
            undefined;
        if (func) {
            // If the node has a @class or @constructor tag, treat it like a constructor.
            if (getJSDocClassTag(node)) return true;

            // If the node is a property of an object literal.
            if (isPropertyAssignment(walkUpParenthesizedExpressions(func.parent))) return false;

            // If the symbol of the node has members, treat it like a constructor.
            const symbol = getSymbolOfDeclaration(func);
            return !!symbol?.members?.size;
        }
        return false;
    }

    function mergeJSSymbols(target: Symbol, source: Symbol | undefined) {
        if (source) {
            const links = getSymbolLinks(source);
            if (!links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target))) {
                const inferred = isTransientSymbol(target) ? target : cloneSymbol(target);
                inferred.exports = inferred.exports || createSymbolTable();
                inferred.members = inferred.members || createSymbolTable();
                inferred.flags |= source.flags & SymbolFlags.Class;
                if (source.exports?.size) {
                    mergeSymbolTable(inferred.exports, source.exports);
                }
                if (source.members?.size) {
                    mergeSymbolTable(inferred.members, source.members);
                }
                (links.inferredClassSymbol || (links.inferredClassSymbol = new Map())).set(getSymbolId(inferred), inferred);
                return inferred;
            }
            return links.inferredClassSymbol.get(getSymbolId(target));
        }
    }

    function getAssignedClassSymbol(decl: Declaration): Symbol | undefined {
        const assignmentSymbol = decl && getSymbolOfExpando(decl, /*allowDeclaration*/ true);
        const prototype = assignmentSymbol?.exports?.get("prototype" as __String);
        const init = prototype?.valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration);
        return init ? getSymbolOfDeclaration(init) : undefined;
    }

    function getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined {
        if (!node.parent) {
            return undefined;
        }
        let name: Expression | BindingName | undefined;
        let decl: Node | undefined;
        if (isVariableDeclaration(node.parent) && node.parent.initializer === node) {
            if (!isInJSFile(node) && !(isVarConstLike(node.parent) && isFunctionLikeDeclaration(node))) {
                return undefined;
            }
            name = node.parent.name;
            decl = node.parent;
        }
        else if (isBinaryExpression(node.parent)) {
            const parentNode = node.parent;
            const parentNodeOperator = node.parent.operatorToken.kind;
            if (parentNodeOperator === SyntaxKind.EqualsToken && (allowDeclaration || parentNode.right === node)) {
                name = parentNode.left;
                decl = name;
            }
            else if (parentNodeOperator === SyntaxKind.BarBarToken || parentNodeOperator === SyntaxKind.QuestionQuestionToken) {
                if (isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer === parentNode) {
                    name = parentNode.parent.name;
                    decl = parentNode.parent;
                }
                else if (isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind === SyntaxKind.EqualsToken && (allowDeclaration || parentNode.parent.right === parentNode)) {
                    name = parentNode.parent.left;
                    decl = name;
                }

                if (!name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left)) {
                    return undefined;
                }
            }
        }
        else if (allowDeclaration && isFunctionDeclaration(node)) {
            name = node.name;
            decl = node;
        }

        if (!decl || !name || (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name)))) {
            return undefined;
        }
        return getSymbolOfNode(decl);
    }

    function getAssignedJSPrototype(node: Node) {
        if (!node.parent) {
            return false;
        }
        let parent: Node = node.parent;
        while (parent && parent.kind === SyntaxKind.PropertyAccessExpression) {
            parent = parent.parent;
        }
        if (parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind === SyntaxKind.EqualsToken) {
            const right = getInitializerOfBinaryExpression(parent);
            return isObjectLiteralExpression(right) && right;
        }
    }

    /**
     * Syntactically and semantically checks a call or new expression.
     * @param node The call/new expression to be checked.
     * @returns On success, the expression's signature's return type. On failure, anyType.
     */
    function checkCallExpression(node: CallExpression | NewExpression, checkMode?: CheckMode): Type {
        checkGrammarTypeArguments(node, node.typeArguments);

        const signature = getResolvedSignature(node, /*candidatesOutArray*/ undefined, checkMode);
        if (signature === resolvingSignature) {
            // CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
            // returns a function type. We defer checking and return silentNeverType.
            return silentNeverType;
        }

        checkDeprecatedSignature(signature, node);

        if (node.expression.kind === SyntaxKind.SuperKeyword) {
            return voidType;
        }

        if (node.kind === SyntaxKind.NewExpression) {
            const declaration = signature.declaration;

            if (
                declaration &&
                declaration.kind !== SyntaxKind.Constructor &&
                declaration.kind !== SyntaxKind.ConstructSignature &&
                declaration.kind !== SyntaxKind.ConstructorType &&
                !(isJSDocSignature(declaration) && getJSDocRoot(declaration)?.parent?.kind === SyntaxKind.Constructor) &&
                !isJSDocConstructSignature(declaration) &&
                !isJSConstructor(declaration)
            ) {
                // When resolved signature is a call signature (and not a construct signature) the result type is any
                if (noImplicitAny) {
                    error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                }
                return anyType;
            }
        }

        // In JavaScript files, calls to any identifier 'require' are treated as external module imports
        if (isInJSFile(node) && isCommonJsRequire(node)) {
            return resolveExternalModuleTypeByLiteral(node.arguments![0] as StringLiteral);
        }

        const returnType = getReturnTypeOfSignature(signature);
        // Treat any call to the global 'Symbol' function that is part of a const variable or readonly property
        // as a fresh unique symbol literal type.
        if (returnType.flags & TypeFlags.ESSymbolLike && isSymbolOrSymbolForCall(node)) {
            return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent));
        }
        if (
            node.kind === SyntaxKind.CallExpression && !node.questionDotToken && node.parent.kind === SyntaxKind.ExpressionStatement &&
            returnType.flags & TypeFlags.Void && getTypePredicateOfSignature(signature)
        ) {
            if (!isDottedName(node.expression)) {
                error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name);
            }
            else if (!getEffectsSignature(node)) {
                const diagnostic = error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation);
                getTypeOfDottedName(node.expression, diagnostic);
            }
        }

        if (isInJSFile(node)) {
            const jsSymbol = getSymbolOfExpando(node, /*allowDeclaration*/ false);
            if (jsSymbol?.exports?.size) {
                const jsAssignmentType = createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray);
                jsAssignmentType.objectFlags |= ObjectFlags.JSLiteral;
                return getIntersectionType([returnType, jsAssignmentType]);
            }
        }

        return returnType;
    }

    function checkDeprecatedSignature(signature: Signature, node: CallLikeExpression) {
        if (signature.flags & SignatureFlags.IsSignatureCandidateForOverloadFailure) return;
        if (signature.declaration && signature.declaration.flags & NodeFlags.Deprecated) {
            const suggestionNode = getDeprecatedSuggestionNode(node);
            const name = tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node));
            addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature));
        }
    }

    function getDeprecatedSuggestionNode(node: Node): Node {
        node = skipParentheses(node);
        switch (node.kind) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.Decorator:
            case SyntaxKind.NewExpression:
                return getDeprecatedSuggestionNode((node as Decorator | CallExpression | NewExpression).expression);
            case SyntaxKind.TaggedTemplateExpression:
                return getDeprecatedSuggestionNode((node as TaggedTemplateExpression).tag);
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return getDeprecatedSuggestionNode((node as JsxOpeningLikeElement).tagName);
            case SyntaxKind.ElementAccessExpression:
                return (node as ElementAccessExpression).argumentExpression;
            case SyntaxKind.PropertyAccessExpression:
                return (node as PropertyAccessExpression).name;
            case SyntaxKind.TypeReference:
                const typeReference = node as TypeReferenceNode;
                return isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;
            default:
                return node;
        }
    }

    function isSymbolOrSymbolForCall(node: Node) {
        if (!isCallExpression(node)) return false;
        let left = node.expression;
        if (isPropertyAccessExpression(left) && left.name.escapedText === "for") {
            left = left.expression;
        }
        if (!isIdentifier(left) || left.escapedText !== "Symbol") {
            return false;
        }

        // make sure `Symbol` is the global symbol
        const globalESSymbol = getGlobalESSymbolConstructorSymbol(/*reportErrors*/ false);
        if (!globalESSymbol) {
            return false;
        }

        return globalESSymbol === resolveName(left, "Symbol" as __String, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
    }

    function checkImportCallExpression(node: ImportCall): Type {
        // Check grammar of dynamic import
        checkGrammarImportCallExpression(node);

        if (node.arguments.length === 0) {
            return createPromiseReturnType(node, anyType);
        }

        const specifier = node.arguments[0];
        const specifierType = checkExpressionCached(specifier);
        const optionsType = node.arguments.length > 1 ? checkExpressionCached(node.arguments[1]) : undefined;
        // Even though multiple arguments is grammatically incorrect, type-check extra arguments for completion
        for (let i = 2; i < node.arguments.length; ++i) {
            checkExpressionCached(node.arguments[i]);
        }

        if (specifierType.flags & TypeFlags.Undefined || specifierType.flags & TypeFlags.Null || !isTypeAssignableTo(specifierType, stringType)) {
            error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType));
        }

        if (optionsType) {
            const importCallOptionsType = getGlobalImportCallOptionsType(/*reportErrors*/ true);
            if (importCallOptionsType !== emptyObjectType) {
                checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType, TypeFlags.Undefined), node.arguments[1]);
            }
        }

        // resolveExternalModuleName will return undefined if the moduleReferenceExpression is not a string literal
        const moduleSymbol = resolveExternalModuleName(node, specifier);
        if (moduleSymbol) {
            const esModuleSymbol = resolveESModuleSymbol(moduleSymbol, specifier, /*dontResolveAlias*/ true, /*suppressInteropError*/ false);
            if (esModuleSymbol) {
                return createPromiseReturnType(
                    node,
                    getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) ||
                        getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier),
                );
            }
        }
        return createPromiseReturnType(node, anyType);
    }

    function createDefaultPropertyWrapperForModule(symbol: Symbol, originalSymbol: Symbol | undefined, anonymousSymbol?: Symbol | undefined) {
        const memberTable = createSymbolTable();
        const newSymbol = createSymbol(SymbolFlags.Alias, InternalSymbolName.Default);
        newSymbol.parent = originalSymbol;
        newSymbol.links.nameType = getStringLiteralType("default");
        newSymbol.links.aliasTarget = resolveSymbol(symbol);
        memberTable.set(InternalSymbolName.Default, newSymbol);
        return createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray);
    }

    function getTypeWithSyntheticDefaultOnly(type: Type, symbol: Symbol, originalSymbol: Symbol, moduleSpecifier: Expression) {
        const hasDefaultOnly = isOnlyImportableAsDefault(moduleSpecifier);
        if (hasDefaultOnly && type && !isErrorType(type)) {
            const synthType = type as SyntheticDefaultModuleType;
            if (!synthType.defaultOnlyType) {
                const type = createDefaultPropertyWrapperForModule(symbol, originalSymbol);
                synthType.defaultOnlyType = type;
            }
            return synthType.defaultOnlyType;
        }
        return undefined;
    }

    function getTypeWithSyntheticDefaultImportType(type: Type, symbol: Symbol, originalSymbol: Symbol, moduleSpecifier: Expression): Type {
        if (allowSyntheticDefaultImports && type && !isErrorType(type)) {
            const synthType = type as SyntheticDefaultModuleType;
            if (!synthType.syntheticType) {
                const file = originalSymbol.declarations?.find(isSourceFile);
                const hasSyntheticDefault = canHaveSyntheticDefault(file, originalSymbol, /*dontResolveAlias*/ false, moduleSpecifier);
                if (hasSyntheticDefault) {
                    const anonymousSymbol = createSymbol(SymbolFlags.TypeLiteral, InternalSymbolName.Type);
                    const defaultContainingObject = createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol);
                    anonymousSymbol.links.type = defaultContainingObject;
                    synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, /*objectFlags*/ 0, /*readonly*/ false) : defaultContainingObject;
                }
                else {
                    synthType.syntheticType = type;
                }
            }
            return synthType.syntheticType;
        }
        return type;
    }

    function isCommonJsRequire(node: Node): boolean {
        if (!isRequireCall(node, /*requireStringLiteralLikeArgument*/ true)) {
            return false;
        }

        // Make sure require is not a local function
        if (!isIdentifier(node.expression)) return Debug.fail();
        const resolvedRequire = resolveName(node.expression, node.expression.escapedText, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ true)!; // TODO: GH#18217
        if (resolvedRequire === requireSymbol) {
            return true;
        }
        // project includes symbol named 'require' - make sure that it is ambient and local non-alias
        if (resolvedRequire.flags & SymbolFlags.Alias) {
            return false;
        }

        const targetDeclarationKind = resolvedRequire.flags & SymbolFlags.Function
            ? SyntaxKind.FunctionDeclaration
            : resolvedRequire.flags & SymbolFlags.Variable
            ? SyntaxKind.VariableDeclaration
            : SyntaxKind.Unknown;
        if (targetDeclarationKind !== SyntaxKind.Unknown) {
            const decl = getDeclarationOfKind(resolvedRequire, targetDeclarationKind)!;
            // function/variable declaration should be ambient
            return !!decl && !!(decl.flags & NodeFlags.Ambient);
        }
        return false;
    }

    function checkTaggedTemplateExpression(node: TaggedTemplateExpression): Type {
        if (!checkGrammarTaggedTemplateChain(node)) checkGrammarTypeArguments(node, node.typeArguments);
        if (languageVersion < LanguageFeatureMinimumTarget.TaggedTemplates) {
            checkExternalEmitHelpers(node, ExternalEmitHelpers.MakeTemplateObject);
        }
        const signature = getResolvedSignature(node);
        checkDeprecatedSignature(signature, node);
        return getReturnTypeOfSignature(signature);
    }

    function checkAssertion(node: AssertionExpression, checkMode: CheckMode | undefined) {
        if (node.kind === SyntaxKind.TypeAssertionExpression) {
            const file = getSourceFileOfNode(node);
            if (file && fileExtensionIsOneOf(file.fileName, [Extension.Cts, Extension.Mts])) {
                grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead);
            }
            if (compilerOptions.erasableSyntaxOnly) {
                const start = skipTrivia(file.text, node.pos);
                const end = node.expression.pos;
                diagnostics.add(createFileDiagnostic(file, start, end - start, Diagnostics.This_syntax_is_not_allowed_when_erasableSyntaxOnly_is_enabled));
            }
        }
        return checkAssertionWorker(node, checkMode);
    }

    function isValidConstAssertionArgument(node: Node): boolean {
        switch (node.kind) {
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.BigIntLiteral:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            case SyntaxKind.ParenthesizedExpression:
                return isValidConstAssertionArgument((node as ParenthesizedExpression).expression);
            case SyntaxKind.PrefixUnaryExpression:
                const op = (node as PrefixUnaryExpression).operator;
                const arg = (node as PrefixUnaryExpression).operand;
                return op === SyntaxKind.MinusToken && (arg.kind === SyntaxKind.NumericLiteral || arg.kind === SyntaxKind.BigIntLiteral) ||
                    op === SyntaxKind.PlusToken && arg.kind === SyntaxKind.NumericLiteral;
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                const expr = skipParentheses((node as PropertyAccessExpression | ElementAccessExpression).expression);
                const symbol = isEntityNameExpression(expr) ? resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors*/ true) : undefined;
                return !!(symbol && symbol.flags & SymbolFlags.Enum);
        }
        return false;
    }

    function checkAssertionWorker(node: JSDocTypeAssertion | AssertionExpression, checkMode: CheckMode | undefined) {
        const { type, expression } = getAssertionTypeAndExpression(node);
        const exprType = checkExpression(expression, checkMode);
        if (isConstTypeReference(type)) {
            if (!isValidConstAssertionArgument(expression)) {
                error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals);
            }
            return getRegularTypeOfLiteralType(exprType);
        }
        const links = getNodeLinks(node);
        links.assertionExpressionType = exprType;
        checkSourceElement(type);
        checkNodeDeferred(node);
        return getTypeFromTypeNode(type);
    }

    function getAssertionTypeAndExpression(node: JSDocTypeAssertion | AssertionExpression) {
        let type: TypeNode;
        let expression: Expression;
        switch (node.kind) {
            case SyntaxKind.AsExpression:
            case SyntaxKind.TypeAssertionExpression:
                type = node.type;
                expression = node.expression;
                break;
            case SyntaxKind.ParenthesizedExpression:
                type = getJSDocTypeAssertionType(node);
                expression = node.expression;
                break;
        }

        return { type, expression };
    }

    function checkAssertionDeferred(node: JSDocTypeAssertion | AssertionExpression) {
        const { type } = getAssertionTypeAndExpression(node);
        const errNode = isParenthesizedExpression(node) ? type : node;
        const links = getNodeLinks(node);
        Debug.assertIsDefined(links.assertionExpressionType);
        const exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(links.assertionExpressionType));
        const targetType = getTypeFromTypeNode(type);
        if (!isErrorType(targetType)) {
            addLazyDiagnostic(() => {
                const widenedType = getWidenedType(exprType);
                if (!isTypeComparableTo(targetType, widenedType)) {
                    checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);
                }
            });
        }
    }

    function checkNonNullChain(node: NonNullChain) {
        const leftType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(leftType, node.expression);
        return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType !== leftType);
    }

    function checkNonNullAssertion(node: NonNullExpression) {
        return node.flags & NodeFlags.OptionalChain ? checkNonNullChain(node as NonNullChain) :
            getNonNullableType(checkExpression(node.expression));
    }

    function checkExpressionWithTypeArguments(node: ExpressionWithTypeArguments | TypeQueryNode) {
        checkGrammarExpressionWithTypeArguments(node);
        forEach(node.typeArguments, checkSourceElement);
        if (node.kind === SyntaxKind.ExpressionWithTypeArguments) {
            const parent = walkUpParenthesizedExpressions(node.parent);
            if (parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.InstanceOfKeyword && isNodeDescendantOf(node, (parent as BinaryExpression).right)) {
                error(node, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression);
            }
        }
        const exprType = node.kind === SyntaxKind.ExpressionWithTypeArguments ? checkExpression(node.expression) :
            isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) :
            checkExpression(node.exprName);
        return getInstantiationExpressionType(exprType, node);
    }

    function getInstantiationExpressionType(exprType: Type, node: NodeWithTypeArguments) {
        const typeArguments = node.typeArguments;
        if (exprType === silentNeverType || isErrorType(exprType) || !some(typeArguments)) {
            return exprType;
        }
        const links = getNodeLinks(node);
        if (!links.instantiationExpressionTypes) {
            links.instantiationExpressionTypes = new Map();
        }
        if (links.instantiationExpressionTypes.has(exprType.id)) {
            return links.instantiationExpressionTypes.get(exprType.id)!;
        }
        let hasSomeApplicableSignature = false;
        let nonApplicableType: Type | undefined;
        const result = getInstantiatedType(exprType);
        links.instantiationExpressionTypes.set(exprType.id, result);
        const errorType = hasSomeApplicableSignature ? nonApplicableType : exprType;
        if (errorType) {
            diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, typeToString(errorType)));
        }
        return result;

        function getInstantiatedType(type: Type): Type {
            let hasSignatures = false;
            let hasApplicableSignature = false;
            const result = getInstantiatedTypePart(type);
            hasSomeApplicableSignature ||= hasApplicableSignature;
            if (hasSignatures && !hasApplicableSignature) {
                nonApplicableType ??= type;
            }
            return result;

            function getInstantiatedTypePart(type: Type): Type {
                if (type.flags & TypeFlags.Object) {
                    const resolved = resolveStructuredTypeMembers(type as ObjectType);
                    const callSignatures = getInstantiatedSignatures(resolved.callSignatures);
                    const constructSignatures = getInstantiatedSignatures(resolved.constructSignatures);
                    hasSignatures ||= resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0;
                    hasApplicableSignature ||= callSignatures.length !== 0 || constructSignatures.length !== 0;
                    if (callSignatures !== resolved.callSignatures || constructSignatures !== resolved.constructSignatures) {
                        const result = createAnonymousType(createSymbol(SymbolFlags.None, InternalSymbolName.InstantiationExpression), resolved.members, callSignatures, constructSignatures, resolved.indexInfos) as ResolvedType & InstantiationExpressionType;
                        result.objectFlags |= ObjectFlags.InstantiationExpressionType;
                        result.node = node;
                        return result;
                    }
                }
                else if (type.flags & TypeFlags.InstantiableNonPrimitive) {
                    const constraint = getBaseConstraintOfType(type);
                    if (constraint) {
                        const instantiated = getInstantiatedTypePart(constraint);
                        if (instantiated !== constraint) {
                            return instantiated;
                        }
                    }
                }
                else if (type.flags & TypeFlags.Union) {
                    return mapType(type, getInstantiatedType);
                }
                else if (type.flags & TypeFlags.Intersection) {
                    return getIntersectionType(sameMap((type as IntersectionType).types, getInstantiatedTypePart));
                }
                return type;
            }
        }

        function getInstantiatedSignatures(signatures: readonly Signature[]) {
            const applicableSignatures = filter(signatures, sig => !!sig.typeParameters && hasCorrectTypeArgumentArity(sig, typeArguments));
            return sameMap(applicableSignatures, sig => {
                const typeArgumentTypes = checkTypeArguments(sig, typeArguments!, /*reportErrors*/ true);
                return typeArgumentTypes ? getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration)) : sig;
            });
        }
    }

    function checkSatisfiesExpression(node: SatisfiesExpression) {
        checkSourceElement(node.type);
        return checkSatisfiesExpressionWorker(node.expression, node.type);
    }

    function checkSatisfiesExpressionWorker(expression: Expression, target: TypeNode, checkMode?: CheckMode) {
        const exprType = checkExpression(expression, checkMode);
        const targetType = getTypeFromTypeNode(target);
        if (isErrorType(targetType)) {
            return targetType;
        }
        const errorNode = findAncestor(target.parent, n => n.kind === SyntaxKind.SatisfiesExpression || n.kind === SyntaxKind.JSDocSatisfiesTag);
        checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1);
        return exprType;
    }

    function checkMetaProperty(node: MetaProperty): Type {
        checkGrammarMetaProperty(node);

        if (node.keywordToken === SyntaxKind.NewKeyword) {
            return checkNewTargetMetaProperty(node);
        }

        if (node.keywordToken === SyntaxKind.ImportKeyword) {
            if (node.name.escapedText === "defer") {
                Debug.assert(!isCallExpression(node.parent) || node.parent.expression !== node, "Trying to get the type of `import.defer` in `import.defer(...)`");
                return errorType;
            }
            return checkImportMetaProperty(node);
        }

        return Debug.assertNever(node.keywordToken);
    }

    function checkMetaPropertyKeyword(node: MetaProperty): Type {
        switch (node.keywordToken) {
            case SyntaxKind.ImportKeyword:
                return getGlobalImportMetaExpressionType();
            case SyntaxKind.NewKeyword:
                const type = checkNewTargetMetaProperty(node);
                return isErrorType(type) ? errorType : createNewTargetExpressionType(type);
            default:
                Debug.assertNever(node.keywordToken);
        }
    }

    function checkNewTargetMetaProperty(node: MetaProperty) {
        const container = getNewTargetContainer(node);
        if (!container) {
            error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target");
            return errorType;
        }
        else if (container.kind === SyntaxKind.Constructor) {
            const symbol = getSymbolOfDeclaration(container.parent);
            return getTypeOfSymbol(symbol);
        }
        else {
            const symbol = getSymbolOfDeclaration(container);
            return getTypeOfSymbol(symbol);
        }
    }

    function checkImportMetaProperty(node: MetaProperty) {
        if (ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext) {
            if (getSourceFileOfNode(node).impliedNodeFormat !== ModuleKind.ESNext) {
                error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output);
            }
        }
        else if (moduleKind < ModuleKind.ES2020 && moduleKind !== ModuleKind.System) {
            error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_node18_node20_or_nodenext);
        }
        const file = getSourceFileOfNode(node);
        Debug.assert(!!(file.flags & NodeFlags.PossiblyContainsImportMeta), "Containing file is missing import meta node flag.");
        return node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType;
    }

    function getTypeOfParameter(symbol: Symbol) {
        const declaration = symbol.valueDeclaration;
        return addOptionality(
            getTypeOfSymbol(symbol),
            /*isProperty*/ false,
            /*isOptional*/ !!declaration && (hasInitializer(declaration) || isOptionalDeclaration(declaration)),
        );
    }

    /**
     * Gets a tuple element label by recursively walking `ArrayBindingPattern` nodes in a `BindingName`.
     * @param node The source node from which to derive a label
     * @param index The index into the tuple
     * @param elementFlags The {@see ElementFlags} of the tuple element
     */
    function getTupleElementLabelFromBindingElement(node: BindingElement | ParameterDeclaration, index: number, elementFlags: ElementFlags): __String {
        switch (node.name.kind) {
            case SyntaxKind.Identifier: {
                const name = node.name.escapedText;
                if (node.dotDotDotToken) {
                    // given
                    //   (...[x, y, ...z]: [number, number, ...number[]]) => ...
                    // this produces
                    //   (x: number, y: number, ...z: number[]) => ...
                    // which preserves rest elements of 'z'

                    // given
                    //   (...[x, y, ...z]: [number, number, ...[...number[], number]]) => ...
                    // this produces
                    //   (x: number, y: number, ...z: number[], z_1: number) => ...
                    // which preserves rest elements of z but gives distinct numbers to fixed elements of 'z'
                    return elementFlags & ElementFlags.Variable ? name : `${name}_${index}` as __String;
                }
                else {
                    // given
                    //   (...[x]: [number]) => ...
                    // this produces
                    //   (x: number) => ...
                    // which preserves fixed elements of 'x'

                    // given
                    //   (...[x]: ...number[]) => ...
                    // this produces
                    //   (x_0: number) => ...
                    // which which numbers fixed elements of 'x' whose tuple element type is variable
                    return elementFlags & ElementFlags.Fixed ? name : `${name}_n` as __String;
                }
            }
            case SyntaxKind.ArrayBindingPattern: {
                if (node.dotDotDotToken) {
                    const elements = node.name.elements;
                    const lastElement = tryCast(lastOrUndefined(elements), isBindingElement);
                    const elementCount = elements.length - (lastElement?.dotDotDotToken ? 1 : 0);
                    if (index < elementCount) {
                        const element = elements[index];
                        if (isBindingElement(element)) {
                            return getTupleElementLabelFromBindingElement(element, index, elementFlags);
                        }
                    }
                    else if (lastElement?.dotDotDotToken) {
                        return getTupleElementLabelFromBindingElement(lastElement, index - elementCount, elementFlags);
                    }
                }
                break;
            }
        }
        return `arg_${index}` as __String;
    }

    function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember): __String;
    function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember | undefined, index: number, elementFlags: ElementFlags, restSymbol?: Symbol): __String;
    function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember | undefined, index = 0, elementFlags = ElementFlags.Fixed, restSymbol?: Symbol) {
        if (!d) {
            const restParameter = tryCast(restSymbol?.valueDeclaration, isParameter);
            return restParameter ? getTupleElementLabelFromBindingElement(restParameter, index, elementFlags) :
                `${restSymbol?.escapedName ?? "arg"}_${index}` as __String;
        }
        Debug.assert(isIdentifier(d.name)); // Parameter declarations could be binding patterns, but we only allow identifier names
        return d.name.escapedText;
    }

    function getParameterNameAtPosition(signature: Signature, pos: number, overrideRestType?: Type) {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            return signature.parameters[pos].escapedName;
        }
        const restParameter = signature.parameters[paramCount] || unknownSymbol;
        const restType = overrideRestType || getTypeOfSymbol(restParameter);
        if (isTupleType(restType)) {
            const tupleType = (restType as TypeReference).target as TupleType;
            const index = pos - paramCount;
            const associatedName = tupleType.labeledElementDeclarations?.[index];
            const elementFlags = tupleType.elementFlags[index];
            return getTupleElementLabel(associatedName, index, elementFlags, restParameter);
        }
        return restParameter.escapedName;
    }

    function getParameterIdentifierInfoAtPosition(signature: Signature, pos: number): { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } | undefined {
        if (signature.declaration?.kind === SyntaxKind.JSDocFunctionType) {
            return undefined;
        }
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            const param = signature.parameters[pos];
            const paramIdent = getParameterDeclarationIdentifier(param);
            return paramIdent ? {
                parameter: paramIdent,
                parameterName: param.escapedName,
                isRestParameter: false,
            } : undefined;
        }

        const restParameter = signature.parameters[paramCount] || unknownSymbol;
        const restIdent = getParameterDeclarationIdentifier(restParameter);
        if (!restIdent) {
            return undefined;
        }

        const restType = getTypeOfSymbol(restParameter);
        if (isTupleType(restType)) {
            const associatedNames = ((restType as TypeReference).target as TupleType).labeledElementDeclarations;
            const index = pos - paramCount;
            const associatedName = associatedNames?.[index];
            const isRestTupleElement = !!associatedName?.dotDotDotToken;

            if (associatedName) {
                Debug.assert(isIdentifier(associatedName.name));
                return { parameter: associatedName.name, parameterName: associatedName.name.escapedText, isRestParameter: isRestTupleElement };
            }

            return undefined;
        }

        if (pos === paramCount) {
            return { parameter: restIdent, parameterName: restParameter.escapedName, isRestParameter: true };
        }
        return undefined;
    }

    function getParameterDeclarationIdentifier(symbol: Symbol) {
        return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name) && symbol.valueDeclaration.name;
    }
    function isValidDeclarationForTupleLabel(d: Declaration): d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) {
        return d.kind === SyntaxKind.NamedTupleMember || (isParameter(d) && d.name && isIdentifier(d.name));
    }

    function getNameableDeclarationAtPosition(signature: Signature, pos: number) {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            const decl = signature.parameters[pos].valueDeclaration;
            return decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined;
        }
        const restParameter = signature.parameters[paramCount] || unknownSymbol;
        const restType = getTypeOfSymbol(restParameter);
        if (isTupleType(restType)) {
            const associatedNames = ((restType as TypeReference).target as TupleType).labeledElementDeclarations;
            const index = pos - paramCount;
            return associatedNames && associatedNames[index];
        }
        return restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : undefined;
    }

    function getTypeAtPosition(signature: Signature, pos: number): Type {
        return tryGetTypeAtPosition(signature, pos) || anyType;
    }

    function tryGetTypeAtPosition(signature: Signature, pos: number): Type | undefined {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            return getTypeOfParameter(signature.parameters[pos]);
        }
        if (signatureHasRestParameter(signature)) {
            // We want to return the value undefined for an out of bounds parameter position,
            // so we need to check bounds here before calling getIndexedAccessType (which
            // otherwise would return the type 'undefined').
            const restType = getTypeOfSymbol(signature.parameters[paramCount]);
            const index = pos - paramCount;
            if (!isTupleType(restType) || restType.target.combinedFlags & ElementFlags.Variable || index < restType.target.fixedLength) {
                return getIndexedAccessType(restType, getNumberLiteralType(index));
            }
        }
        return undefined;
    }

    function getRestTypeAtPosition(source: Signature, pos: number, readonly?: boolean): Type {
        const parameterCount = getParameterCount(source);
        const minArgumentCount = getMinArgumentCount(source);
        const restType = getEffectiveRestType(source);
        if (restType && pos >= parameterCount - 1) {
            return pos === parameterCount - 1 ? restType : createArrayType(getIndexedAccessType(restType, numberType));
        }
        const types = [];
        const flags = [];
        const names = [];
        for (let i = pos; i < parameterCount; i++) {
            if (!restType || i < parameterCount - 1) {
                types.push(getTypeAtPosition(source, i));
                flags.push(i < minArgumentCount ? ElementFlags.Required : ElementFlags.Optional);
            }
            else {
                types.push(restType);
                flags.push(ElementFlags.Variadic);
            }
            names.push(getNameableDeclarationAtPosition(source, i));
        }
        return createTupleType(types, flags, readonly, names);
    }

    // Return the rest type at the given position, transforming `any[]` into just `any`. We do this because
    // in signatures we want `any[]` in a rest position to be compatible with anything, but `any[]` isn't
    // assignable to tuple types with required elements.
    function getRestOrAnyTypeAtPosition(source: Signature, pos: number): Type {
        const restType = getRestTypeAtPosition(source, pos);
        const elementType = restType && getElementTypeOfArrayType(restType);
        return elementType && isTypeAny(elementType) ? anyType : restType;
    }

    // Return the number of parameters in a signature. The rest parameter, if present, counts as one
    // parameter. For example, the parameter count of (x: number, y: number, ...z: string[]) is 3 and
    // the parameter count of (x: number, ...args: [number, ...string[], boolean])) is also 3. In the
    // latter example, the effective rest type is [...string[], boolean].
    function getParameterCount(signature: Signature) {
        const length = signature.parameters.length;
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[length - 1]);
            if (isTupleType(restType)) {
                return length + restType.target.fixedLength - (restType.target.combinedFlags & ElementFlags.Variable ? 0 : 1);
            }
        }
        return length;
    }

    function getMinArgumentCount(signature: Signature, flags?: MinArgumentCountFlags) {
        const strongArityForUntypedJS = flags! & MinArgumentCountFlags.StrongArityForUntypedJS;
        const voidIsNonOptional = flags! & MinArgumentCountFlags.VoidIsNonOptional;
        if (voidIsNonOptional || signature.resolvedMinArgumentCount === undefined) {
            let minArgumentCount: number | undefined;
            if (signatureHasRestParameter(signature)) {
                const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                if (isTupleType(restType)) {
                    const firstOptionalIndex = findIndex(restType.target.elementFlags, f => !(f & ElementFlags.Required));
                    const requiredCount = firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex;
                    if (requiredCount > 0) {
                        minArgumentCount = signature.parameters.length - 1 + requiredCount;
                    }
                }
            }
            if (minArgumentCount === undefined) {
                if (!strongArityForUntypedJS && signature.flags & SignatureFlags.IsUntypedSignatureInJSFile) {
                    return 0;
                }
                minArgumentCount = signature.minArgumentCount;
            }
            if (voidIsNonOptional) {
                return minArgumentCount;
            }
            for (let i = minArgumentCount - 1; i >= 0; i--) {
                const type = getTypeAtPosition(signature, i);
                if (filterType(type, acceptsVoid).flags & TypeFlags.Never) {
                    break;
                }
                minArgumentCount = i;
            }
            signature.resolvedMinArgumentCount = minArgumentCount;
        }
        return signature.resolvedMinArgumentCount;
    }

    function hasEffectiveRestParameter(signature: Signature) {
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            return !isTupleType(restType) || !!(restType.target.combinedFlags & ElementFlags.Variable);
        }
        return false;
    }

    function getEffectiveRestType(signature: Signature) {
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            if (!isTupleType(restType)) {
                return isTypeAny(restType) ? anyArrayType : restType;
            }
            if (restType.target.combinedFlags & ElementFlags.Variable) {
                return sliceTupleType(restType, restType.target.fixedLength);
            }
        }
        return undefined;
    }

    function getNonArrayRestType(signature: Signature) {
        const restType = getEffectiveRestType(signature);
        return restType && !isArrayType(restType) && !isTypeAny(restType) ? restType : undefined;
    }

    function getTypeOfFirstParameterOfSignature(signature: Signature) {
        return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType);
    }

    function getTypeOfFirstParameterOfSignatureWithFallback(signature: Signature, fallbackType: Type) {
        return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType;
    }

    function inferFromAnnotatedParametersAndReturn(signature: Signature, context: Signature, inferenceContext: InferenceContext) {
        const len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        for (let i = 0; i < len; i++) {
            const declaration = signature.parameters[i].valueDeclaration as ParameterDeclaration;
            const typeNode = getEffectiveTypeAnnotationNode(declaration);
            if (typeNode) {
                const source = addOptionality(getTypeFromTypeNode(typeNode), /*isProperty*/ false, isOptionalDeclaration(declaration));
                const target = getTypeAtPosition(context, i);
                inferTypes(inferenceContext.inferences, source, target);
            }
        }
        const typeNode = signature.declaration && getEffectiveReturnTypeNode(signature.declaration);
        if (typeNode) {
            const source = getTypeFromTypeNode(typeNode);
            const target = getReturnTypeOfSignature(context);
            inferTypes(inferenceContext.inferences, source, target);
        }
    }

    function assignContextualParameterTypes(signature: Signature, context: Signature) {
        if (context.typeParameters) {
            if (!signature.typeParameters) {
                signature.typeParameters = context.typeParameters;
            }
            else {
                return; // This signature has already has a contextual inference performed and cached on it!
            }
        }
        if (context.thisParameter) {
            const parameter = signature.thisParameter;
            if (!parameter || parameter.valueDeclaration && !(parameter.valueDeclaration as ParameterDeclaration).type) {
                if (!parameter) {
                    signature.thisParameter = createSymbolWithType(context.thisParameter, /*type*/ undefined);
                }
                assignParameterType(signature.thisParameter!, getTypeOfSymbol(context.thisParameter));
            }
        }
        const len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        for (let i = 0; i < len; i++) {
            const parameter = signature.parameters[i];
            const declaration = parameter.valueDeclaration as ParameterDeclaration;
            if (!getEffectiveTypeAnnotationNode(declaration)) {
                let type = tryGetTypeAtPosition(context, i);
                if (type && declaration.initializer) {
                    let initializerType = checkDeclarationInitializer(declaration, CheckMode.Normal);
                    if (!isTypeAssignableTo(initializerType, type) && isTypeAssignableTo(type, initializerType = widenTypeInferredFromInitializer(declaration, initializerType))) {
                        type = initializerType;
                    }
                }
                assignParameterType(parameter, type);
            }
        }
        if (signatureHasRestParameter(signature)) {
            // parameter might be a transient symbol generated by use of `arguments` in the function body.
            const parameter = last(signature.parameters);
            if (
                parameter.valueDeclaration
                    ? !getEffectiveTypeAnnotationNode(parameter.valueDeclaration as ParameterDeclaration)
                    // a declarationless parameter may still have a `.type` already set by its construction logic
                    // (which may pull a type from a jsdoc) - only allow fixing on `DeferredType` parameters with a fallback type
                    : !!(getCheckFlags(parameter) & CheckFlags.DeferredType)
            ) {
                const contextualParameterType = getRestTypeAtPosition(context, len);
                assignParameterType(parameter, contextualParameterType);
            }
        }
    }

    function assignNonContextualParameterTypes(signature: Signature) {
        if (signature.thisParameter) {
            assignParameterType(signature.thisParameter);
        }
        for (const parameter of signature.parameters) {
            assignParameterType(parameter);
        }
    }

    function assignParameterType(parameter: Symbol, contextualType?: Type) {
        const links = getSymbolLinks(parameter);
        if (!links.type) {
            const declaration = parameter.valueDeclaration as ParameterDeclaration | undefined;
            links.type = addOptionality(
                contextualType || (declaration ? getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors*/ true) : getTypeOfSymbol(parameter)),
                /*isProperty*/ false,
                /*isOptional*/ !!declaration && !declaration.initializer && isOptionalDeclaration(declaration),
            );
            if (declaration && declaration.name.kind !== SyntaxKind.Identifier) {
                // if inference didn't come up with anything but unknown, fall back to the binding pattern if present.
                if (links.type === unknownType) {
                    links.type = getTypeFromBindingPattern(declaration.name);
                }
                assignBindingElementTypes(declaration.name, links.type);
            }
        }
        else if (contextualType) {
            Debug.assertEqual(links.type, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type");
        }
    }

    // When contextual typing assigns a type to a parameter that contains a binding pattern, we also need to push
    // the destructured type into the contained binding elements.
    function assignBindingElementTypes(pattern: BindingPattern, parentType: Type) {
        for (const element of pattern.elements) {
            if (!isOmittedExpression(element)) {
                const type = getBindingElementTypeFromParentType(element, parentType, /*noTupleBoundsCheck*/ false);
                if (element.name.kind === SyntaxKind.Identifier) {
                    getSymbolLinks(getSymbolOfDeclaration(element)).type = type;
                }
                else {
                    assignBindingElementTypes(element.name, type);
                }
            }
        }
    }

    function createClassDecoratorContextType(classType: Type) {
        return tryCreateTypeReference(getGlobalClassDecoratorContextType(/*reportErrors*/ true), [classType]);
    }

    function createClassMethodDecoratorContextType(thisType: Type, valueType: Type) {
        return tryCreateTypeReference(getGlobalClassMethodDecoratorContextType(/*reportErrors*/ true), [thisType, valueType]);
    }

    function createClassGetterDecoratorContextType(thisType: Type, valueType: Type) {
        return tryCreateTypeReference(getGlobalClassGetterDecoratorContextType(/*reportErrors*/ true), [thisType, valueType]);
    }

    function createClassSetterDecoratorContextType(thisType: Type, valueType: Type) {
        return tryCreateTypeReference(getGlobalClassSetterDecoratorContextType(/*reportErrors*/ true), [thisType, valueType]);
    }

    function createClassAccessorDecoratorContextType(thisType: Type, valueType: Type) {
        return tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType(/*reportErrors*/ true), [thisType, valueType]);
    }

    function createClassFieldDecoratorContextType(thisType: Type, valueType: Type) {
        return tryCreateTypeReference(getGlobalClassFieldDecoratorContextType(/*reportErrors*/ true), [thisType, valueType]);
    }

    /**
     * Gets a type like `{ name: "foo", private: false, static: true }` that is used to provided member-specific
     * details that will be intersected with a decorator context type.
     */
    function getClassMemberDecoratorContextOverrideType(nameType: Type, isPrivate: boolean, isStatic: boolean) {
        const key = `${isPrivate ? "p" : "P"}${isStatic ? "s" : "S"}${nameType.id}` as const;
        let overrideType = decoratorContextOverrideTypeCache.get(key);
        if (!overrideType) {
            const members = createSymbolTable();
            members.set("name" as __String, createProperty("name" as __String, nameType));
            members.set("private" as __String, createProperty("private" as __String, isPrivate ? trueType : falseType));
            members.set("static" as __String, createProperty("static" as __String, isStatic ? trueType : falseType));
            overrideType = createAnonymousType(/*symbol*/ undefined, members, emptyArray, emptyArray, emptyArray);
            decoratorContextOverrideTypeCache.set(key, overrideType);
        }
        return overrideType;
    }

    function createClassMemberDecoratorContextTypeForNode(node: MethodDeclaration | AccessorDeclaration | PropertyDeclaration, thisType: Type, valueType: Type) {
        const isStatic = hasStaticModifier(node);
        const isPrivate = isPrivateIdentifier(node.name);
        const nameType = isPrivate ? getStringLiteralType(idText(node.name)) : getLiteralTypeFromPropertyName(node.name);
        const contextType = isMethodDeclaration(node) ? createClassMethodDecoratorContextType(thisType, valueType) :
            isGetAccessorDeclaration(node) ? createClassGetterDecoratorContextType(thisType, valueType) :
            isSetAccessorDeclaration(node) ? createClassSetterDecoratorContextType(thisType, valueType) :
            isAutoAccessorPropertyDeclaration(node) ? createClassAccessorDecoratorContextType(thisType, valueType) :
            isPropertyDeclaration(node) ? createClassFieldDecoratorContextType(thisType, valueType) :
            Debug.failBadSyntaxKind(node);
        const overrideType = getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic);
        return getIntersectionType([contextType, overrideType]);
    }

    function createClassAccessorDecoratorTargetType(thisType: Type, valueType: Type) {
        return tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType(/*reportErrors*/ true), [thisType, valueType]);
    }

    function createClassAccessorDecoratorResultType(thisType: Type, valueType: Type) {
        return tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType(/*reportErrors*/ true), [thisType, valueType]);
    }

    function createClassFieldDecoratorInitializerMutatorType(thisType: Type, valueType: Type) {
        const thisParam = createParameter("this" as __String, thisType);
        const valueParam = createParameter("value" as __String, valueType);
        return createFunctionType(/*typeParameters*/ undefined, thisParam, [valueParam], valueType, /*typePredicate*/ undefined, 1);
    }

    /**
     * Creates a call signature for an ES Decorator. This method is used by the semantics of
     * `getESDecoratorCallSignature`, which you should probably be using instead.
     */
    function createESDecoratorCallSignature(targetType: Type, contextType: Type, nonOptionalReturnType: Type) {
        const targetParam = createParameter("target" as __String, targetType);
        const contextParam = createParameter("context" as __String, contextType);
        const returnType = getUnionType([nonOptionalReturnType, voidType]);
        return createCallSignature(/*typeParameters*/ undefined, /*thisParameter*/ undefined, [targetParam, contextParam], returnType);
    }

    /**
     * Gets a call signature that should be used when resolving `decorator` as a call. This does not use the value
     * of the decorator itself, but instead uses the declaration on which it is placed along with its relative
     * position amongst other decorators on the same declaration to determine the applicable signature. The
     * resulting signature can be used for call resolution, inference, and contextual typing.
     */
    function getESDecoratorCallSignature(decorator: Decorator) {
        // We are considering a future change that would allow the type of a decorator to affect the type of the
        // class and its members, such as a `@Stringify` decorator changing the type of a `number` field to `string`, or
        // a `@Callable` decorator adding a call signature to a `class`. The type arguments for the various context
        // types may eventually change to reflect such mutations.
        //
        // In some cases we describe such potential mutations as coming from a "prior decorator application". It is
        // important to note that, while decorators are *evaluated* left to right, they are *applied* right to left
        // to preserve f ৹ g -> f(g(x)) application order. In these cases, a "prior" decorator usually means the
        // next decorator following this one in document order.
        //
        // The "original type" of a class or member is the type it was declared as, or the type we infer from
        // initializers, before _any_ decorators are applied.
        //
        // The type of a class or member that is a result of a prior decorator application represents the
        // "current type", i.e., the type for the declaration at the time the decorator is _applied_.
        //
        // The type of a class or member that is the result of the application of *all* relevant decorators is the
        // "final type".
        //
        // Any decorator that allows mutation or replacement will also refer to an "input type" and an
        // "output type". The "input type" corresponds to the "current type" of the declaration, while the
        // "output type" will become either the "input type/current type" for a subsequent decorator application,
        // or the "final type" for the decorated declaration.
        //
        // It is important to understand decorator application order as it relates to how the "current", "input",
        // "output", and "final" types will be determined:
        //
        //  @E2 @E1 class SomeClass {
        //      @A2 @A1 static f() {}
        //      @B2 @B1 g() {}
        //      @C2 @C1 static x;
        //      @D2 @D1 y;
        //  }
        //
        // Per [the specification][1], decorators are applied in the following order:
        //
        // 1. For each static method (incl. get/set methods and `accessor` fields), in document order:
        //    a. Apply each decorator for that method, in reverse order (`A1`, `A2`).
        // 2. For each instance method (incl. get/set methods and `accessor` fields), in document order:
        //    a. Apply each decorator for that method, in reverse order (`B1`, `B2`).
        // 3. For each static field (excl. auto-accessors), in document order:
        //    a. Apply each decorator for that field, in reverse order (`C1`, `C2`).
        // 4. For each instance field (excl. auto-accessors), in document order:
        //    a. Apply each decorator for that field, in reverse order (`D1`, `D2`).
        // 5. Apply each decorator for the class, in reverse order (`E1`, `E2`).
        //
        // As a result, "current" types at each decorator application are as follows:
        // - For `A1`, the "current" types of the class and method are their "original" types.
        // - For `A2`, the "current type" of the method is the "output type" of `A1`, and the "current type" of the
        //   class is the type of `SomeClass` where `f` is the "output type" of `A1`. This becomes the "final type"
        //   of `f`.
        // - For `B1`, the "current type" of the method is its "original type", and the "current type" of the class
        //   is the type of `SomeClass` where `f` now has its "final type".
        // - etc.
        //
        // [1]: https://arai-a.github.io/ecma262-compare/?pr=2417&id=sec-runtime-semantics-classdefinitionevaluation
        //
        // This seems complicated at first glance, but is not unlike our existing inference for functions:
        //
        //  declare function pipe<Original, A1, A2, B1, B2, C1, C2, D1, D2, E1, E2>(
        //      original: Original,
        //      a1: (input: Original, context: Context<E2>) => A1,
        //      a2: (input: A1, context: Context<E2>) => A2,
        //      b1: (input: A2, context: Context<E2>) => B1,
        //      b2: (input: B1, context: Context<E2>) => B2,
        //      c1: (input: B2, context: Context<E2>) => C1,
        //      c2: (input: C1, context: Context<E2>) => C2,
        //      d1: (input: C2, context: Context<E2>) => D1,
        //      d2: (input: D1, context: Context<E2>) => D2,
        //      e1: (input: D2, context: Context<E2>) => E1,
        //      e2: (input: E1, context: Context<E2>) => E2,
        //  ): E2;

        // When a decorator is applied, it is passed two arguments: "target", which is a value representing the
        // thing being decorated (constructors for classes, functions for methods/accessors, `undefined` for fields,
        // and a `{ get, set }` object for auto-accessors), and "context", which is an object that provides
        // reflection information about the decorated element, as well as the ability to add additional "extra"
        // initializers. In most cases, the "target" argument corresponds to the "input type" in some way, and the
        // return value similarly corresponds to the "output type" (though if the "output type" is `void` or
        // `undefined` then the "output type" is the "input type").

        const { parent } = decorator;
        const links = getNodeLinks(parent);
        if (!links.decoratorSignature) {
            links.decoratorSignature = anySignature;
            switch (parent.kind) {
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression: {
                    // Class decorators have a `context` of `ClassDecoratorContext<Class>`, where the `Class` type
                    // argument will be the "final type" of the class after all decorators are applied.

                    const node = parent as ClassDeclaration | ClassExpression;
                    const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));
                    const contextType = createClassDecoratorContextType(targetType);
                    links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType);
                    break;
                }

                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor: {
                    const node = parent as MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;
                    if (!isClassLike(node.parent)) break;

                    // Method decorators have a `context` of `ClassMethodDecoratorContext<This, Value>`, where the
                    // `Value` type argument corresponds to the "final type" of the method.
                    //
                    // Getter decorators have a `context` of `ClassGetterDecoratorContext<This, Value>`, where the
                    // `Value` type argument corresponds to the "final type" of the value returned by the getter.
                    //
                    // Setter decorators have a `context` of `ClassSetterDecoratorContext<This, Value>`, where the
                    // `Value` type argument corresponds to the "final type" of the parameter of the setter.
                    //
                    // In all three cases, the `This` type argument is the "final type" of either the class or
                    // instance, depending on whether the member was `static`.

                    const valueType = isMethodDeclaration(node) ? getOrCreateTypeFromSignature(getSignatureFromDeclaration(node)) :
                        getTypeOfNode(node);

                    const thisType = hasStaticModifier(node) ?
                        getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :
                        getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));

                    // We wrap the "input type", if necessary, to match the decoration target. For getters this is
                    // something like `() => inputType`, for setters it's `(value: inputType) => void` and for
                    // methods it is just the input type.
                    const targetType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :
                        isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :
                        valueType;

                    const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);

                    // We also wrap the "output type", as needed.
                    const returnType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :
                        isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :
                        valueType;

                    links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);
                    break;
                }

                case SyntaxKind.PropertyDeclaration: {
                    const node = parent as PropertyDeclaration;
                    if (!isClassLike(node.parent)) break;

                    // Field decorators have a `context` of `ClassFieldDecoratorContext<This, Value>` and
                    // auto-accessor decorators have a `context` of `ClassAccessorDecoratorContext<This, Value>. In
                    // both cases, the `This` type argument is the "final type" of either the class or instance,
                    // depending on whether the member was `static`, and the `Value` type argument corresponds to
                    // the "final type" of the value stored in the field.

                    const valueType = getTypeOfNode(node);
                    const thisType = hasStaticModifier(node) ?
                        getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :
                        getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));

                    // The `target` of an auto-accessor decorator is a `{ get, set }` object, representing the
                    // runtime-generated getter and setter that are added to the class/prototype. The `target` of a
                    // regular field decorator is always `undefined` as it isn't installed until it is initialized.
                    const targetType = hasAccessorModifier(node) ? createClassAccessorDecoratorTargetType(thisType, valueType) :
                        undefinedType;

                    const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);

                    // We wrap the "output type" depending on the declaration. For auto-accessors, we wrap the
                    // "output type" in a `ClassAccessorDecoratorResult<This, In, Out>` type, which allows for
                    // mutation of the runtime-generated getter and setter, as well as the injection of an
                    // initializer mutator. For regular fields, we wrap the "output type" in an initializer mutator.
                    const returnType = hasAccessorModifier(node) ? createClassAccessorDecoratorResultType(thisType, valueType) :
                        createClassFieldDecoratorInitializerMutatorType(thisType, valueType);

                    links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);
                    break;
                }
            }
        }
        return links.decoratorSignature === anySignature ? undefined : links.decoratorSignature;
    }

    function getLegacyDecoratorCallSignature(decorator: Decorator) {
        const { parent } = decorator;
        const links = getNodeLinks(parent);
        if (!links.decoratorSignature) {
            links.decoratorSignature = anySignature;
            switch (parent.kind) {
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression: {
                    const node = parent as ClassDeclaration | ClassExpression;
                    // For a class decorator, the `target` is the type of the class (e.g. the
                    // "static" or "constructor" side of the class).
                    const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));
                    const targetParam = createParameter("target" as __String, targetType);
                    links.decoratorSignature = createCallSignature(
                        /*typeParameters*/ undefined,
                        /*thisParameter*/ undefined,
                        [targetParam],
                        getUnionType([targetType, voidType]),
                    );
                    break;
                }
                case SyntaxKind.Parameter: {
                    const node = parent as ParameterDeclaration;
                    if (
                        !isConstructorDeclaration(node.parent) &&
                        !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent))
                    ) {
                        break;
                    }

                    if (getThisParameter(node.parent) === node) {
                        break;
                    }

                    const index = getThisParameter(node.parent) ?
                        node.parent.parameters.indexOf(node) - 1 :
                        node.parent.parameters.indexOf(node);
                    Debug.assert(index >= 0);

                    // A parameter declaration decorator will have three arguments (see `ParameterDecorator` in
                    // core.d.ts).

                    const targetType = isConstructorDeclaration(node.parent) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent)) :
                        getParentTypeOfClassElement(node.parent);

                    const keyType = isConstructorDeclaration(node.parent) ? undefinedType :
                        getClassElementPropertyKeyType(node.parent);

                    const indexType = getNumberLiteralType(index);

                    const targetParam = createParameter("target" as __String, targetType);
                    const keyParam = createParameter("propertyKey" as __String, keyType);
                    const indexParam = createParameter("parameterIndex" as __String, indexType);
                    links.decoratorSignature = createCallSignature(
                        /*typeParameters*/ undefined,
                        /*thisParameter*/ undefined,
                        [targetParam, keyParam, indexParam],
                        voidType,
                    );
                    break;
                }
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.PropertyDeclaration: {
                    const node = parent as MethodDeclaration | AccessorDeclaration | PropertyDeclaration;
                    if (!isClassLike(node.parent)) break;

                    // A method or accessor declaration decorator will have either two or three arguments (see
                    // `PropertyDecorator` and `MethodDecorator` in core.d.ts).

                    const targetType = getParentTypeOfClassElement(node);
                    const targetParam = createParameter("target" as __String, targetType);

                    const keyType = getClassElementPropertyKeyType(node);
                    const keyParam = createParameter("propertyKey" as __String, keyType);

                    const returnType = isPropertyDeclaration(node) ? voidType :
                        createTypedPropertyDescriptorType(getTypeOfNode(node));

                    const hasPropDesc = !isPropertyDeclaration(parent) || hasAccessorModifier(parent);
                    if (hasPropDesc) {
                        const descriptorType = createTypedPropertyDescriptorType(getTypeOfNode(node));
                        const descriptorParam = createParameter("descriptor" as __String, descriptorType);
                        links.decoratorSignature = createCallSignature(
                            /*typeParameters*/ undefined,
                            /*thisParameter*/ undefined,
                            [targetParam, keyParam, descriptorParam],
                            getUnionType([returnType, voidType]),
                        );
                    }
                    else {
                        links.decoratorSignature = createCallSignature(
                            /*typeParameters*/ undefined,
                            /*thisParameter*/ undefined,
                            [targetParam, keyParam],
                            getUnionType([returnType, voidType]),
                        );
                    }
                    break;
                }
            }
        }
        return links.decoratorSignature === anySignature ? undefined : links.decoratorSignature;
    }

    function getDecoratorCallSignature(decorator: Decorator) {
        return legacyDecorators ? getLegacyDecoratorCallSignature(decorator) :
            getESDecoratorCallSignature(decorator);
    }

    function createPromiseType(promisedType: Type): Type {
        // creates a `Promise<T>` type where `T` is the promisedType argument
        const globalPromiseType = getGlobalPromiseType(/*reportErrors*/ true);
        if (globalPromiseType !== emptyGenericType) {
            // if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
            // Unwrap an `Awaited<T>` to `T` to improve inference.
            promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType;
            return createTypeReference(globalPromiseType, [promisedType]);
        }

        return unknownType;
    }

    function createPromiseLikeType(promisedType: Type): Type {
        // creates a `PromiseLike<T>` type where `T` is the promisedType argument
        const globalPromiseLikeType = getGlobalPromiseLikeType(/*reportErrors*/ true);
        if (globalPromiseLikeType !== emptyGenericType) {
            // if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
            // Unwrap an `Awaited<T>` to `T` to improve inference.
            promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType;
            return createTypeReference(globalPromiseLikeType, [promisedType]);
        }

        return unknownType;
    }

    function createPromiseReturnType(func: FunctionLikeDeclaration | ImportCall, promisedType: Type) {
        const promiseType = createPromiseType(promisedType);
        if (promiseType === unknownType) {
            error(
                func,
                isImportCall(func) ?
                    Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :
                    Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option,
            );
            return errorType;
        }
        else if (!getGlobalPromiseConstructorSymbol(/*reportErrors*/ true)) {
            error(
                func,
                isImportCall(func) ?
                    Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :
                    Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option,
            );
        }

        return promiseType;
    }

    function createNewTargetExpressionType(targetType: Type): Type {
        // Create a synthetic type `NewTargetExpression { target: TargetType; }`
        const symbol = createSymbol(SymbolFlags.None, "NewTargetExpression" as __String);

        const targetPropertySymbol = createSymbol(SymbolFlags.Property, "target" as __String, CheckFlags.Readonly);
        targetPropertySymbol.parent = symbol;
        targetPropertySymbol.links.type = targetType;

        const members = createSymbolTable([targetPropertySymbol]);
        symbol.members = members;
        return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
    }

    function getReturnTypeFromBody(func: FunctionLikeDeclaration, checkMode?: CheckMode): Type {
        if (!func.body) {
            return errorType;
        }

        const functionFlags = getFunctionFlags(func);
        const isAsync = (functionFlags & FunctionFlags.Async) !== 0;
        const isGenerator = (functionFlags & FunctionFlags.Generator) !== 0;

        let returnType: Type | undefined;
        let yieldType: Type | undefined;
        let nextType: Type | undefined;
        let fallbackReturnType: Type = voidType;
        if (func.body.kind !== SyntaxKind.Block) { // Async or normal arrow function
            returnType = checkExpressionCached(func.body, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);
            if (isAsync) {
                // From within an async function you can return either a non-promise value or a promise. Any
                // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                // return type of the body should be unwrapped to its awaited type, which we will wrap in
                // the native Promise<T> type later in this function.
                returnType = unwrapAwaitedType(checkAwaitedType(returnType, /*withAlias*/ false, /*errorNode*/ func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
            }
        }
        else if (isGenerator) { // Generator or AsyncGenerator function
            const returnTypes = checkAndAggregateReturnExpressionTypes(func, checkMode);
            if (!returnTypes) {
                fallbackReturnType = neverType;
            }
            else if (returnTypes.length > 0) {
                returnType = getUnionType(returnTypes, UnionReduction.Subtype);
            }
            const { yieldTypes, nextTypes } = checkAndAggregateYieldOperandTypes(func, checkMode);
            yieldType = some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined;
            nextType = some(nextTypes) ? getIntersectionType(nextTypes) : undefined;
        }
        else { // Async or normal function
            const types = checkAndAggregateReturnExpressionTypes(func, checkMode);
            if (!types) {
                // For an async function, the return type will not be never, but rather a Promise for never.
                return functionFlags & FunctionFlags.Async
                    ? createPromiseReturnType(func, neverType) // Async function
                    : neverType; // Normal function
            }
            if (types.length === 0) {
                // For an async function, the return type will not be void/undefined, but rather a Promise for void/undefined.
                const contextualReturnType = getContextualReturnType(func, /*contextFlags*/ undefined);
                const returnType = contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags & TypeFlags.Undefined ? undefinedType : voidType;
                return functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, returnType) : // Async function
                    returnType; // Normal function
            }

            // Return a union of the return expression types.
            returnType = getUnionType(types, UnionReduction.Subtype);
        }

        if (returnType || yieldType || nextType) {
            if (yieldType) reportErrorsFromWidening(func, yieldType, WideningKind.GeneratorYield);
            if (returnType) reportErrorsFromWidening(func, returnType, WideningKind.FunctionReturn);
            if (nextType) reportErrorsFromWidening(func, nextType, WideningKind.GeneratorNext);
            if (
                returnType && isUnitType(returnType) ||
                yieldType && isUnitType(yieldType) ||
                nextType && isUnitType(nextType)
            ) {
                const contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
                const contextualType = !contextualSignature ? undefined :
                    contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :
                    instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, /*contextFlags*/ undefined);
                if (isGenerator) {
                    yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKind.Yield, isAsync);
                    returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKind.Return, isAsync);
                    nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKind.Next, isAsync);
                }
                else {
                    returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync);
                }
            }

            if (yieldType) yieldType = getWidenedType(yieldType);
            if (returnType) returnType = getWidenedType(returnType);
            if (nextType) nextType = getWidenedType(nextType);
        }

        if (isGenerator) {
            return createGeneratorType(
                yieldType || neverType,
                returnType || fallbackReturnType,
                nextType || getContextualIterationType(IterationTypeKind.Next, func) || unknownType,
                isAsync,
            );
        }
        else {
            // From within an async function you can return either a non-promise value or a promise. Any
            // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
            // return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
            return isAsync
                ? createPromiseType(returnType || fallbackReturnType)
                : returnType || fallbackReturnType;
        }
    }

    function createGeneratorType(yieldType: Type, returnType: Type, nextType: Type, isAsyncGenerator: boolean) {
        const resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
        const globalGeneratorType = resolver.getGlobalGeneratorType(/*reportErrors*/ false);
        yieldType = resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || unknownType;
        returnType = resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || unknownType;
        if (globalGeneratorType === emptyGenericType) {
            // Fall back to the global IterableIterator type.
            const globalIterableIteratorType = resolver.getGlobalIterableIteratorType(/*reportErrors*/ false);
            if (globalIterableIteratorType !== emptyGenericType) {
                return createTypeFromGenericGlobalType(globalIterableIteratorType, [yieldType, returnType, nextType]);
            }

            // The global Generator type doesn't exist, so report an error
            resolver.getGlobalIterableIteratorType(/*reportErrors*/ true);
            return emptyObjectType;
        }

        return createTypeFromGenericGlobalType(globalGeneratorType, [yieldType, returnType, nextType]);
    }

    function checkAndAggregateYieldOperandTypes(func: FunctionLikeDeclaration, checkMode: CheckMode | undefined) {
        const yieldTypes: Type[] = [];
        const nextTypes: Type[] = [];
        const isAsync = (getFunctionFlags(func) & FunctionFlags.Async) !== 0;
        forEachYieldExpression(func.body as Block, yieldExpression => {
            const yieldExpressionType = yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType;
            pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync));
            let nextType: Type | undefined;
            if (yieldExpression.asteriskToken) {
                const iterationTypes = getIterationTypesOfIterable(
                    yieldExpressionType,
                    isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar,
                    yieldExpression.expression,
                );
                nextType = iterationTypes && iterationTypes.nextType;
            }
            else {
                nextType = getContextualType(yieldExpression, /*contextFlags*/ undefined);
            }
            if (nextType) pushIfUnique(nextTypes, nextType);
        });
        return { yieldTypes, nextTypes };
    }

    function getYieldedTypeOfYieldExpression(node: YieldExpression, expressionType: Type, sentType: Type, isAsync: boolean): Type | undefined {
        const errorNode = node.expression || node;
        // A `yield*` expression effectively yields everything that its operand yields
        const yieldedType = node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, expressionType, sentType, errorNode) : expressionType;
        return !isAsync ? yieldedType : getAwaitedType(
            yieldedType,
            errorNode,
            node.asteriskToken
                ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
                : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
        );
    }

    // Return the combined not-equal type facts for all cases except those between the start and end indices.
    function getNotEqualFactsFromTypeofSwitch(start: number, end: number, witnesses: (string | undefined)[]): TypeFacts {
        let facts: TypeFacts = TypeFacts.None;
        for (let i = 0; i < witnesses.length; i++) {
            const witness = i < start || i >= end ? witnesses[i] : undefined;
            facts |= witness !== undefined ? typeofNEFacts.get(witness) || TypeFacts.TypeofNEHostObject : 0;
        }
        return facts;
    }

    function isExhaustiveSwitchStatement(node: SwitchStatement): boolean {
        const links = getNodeLinks(node);
        if (links.isExhaustive === undefined) {
            links.isExhaustive = 0; // Indicate resolution is in process
            const exhaustive = computeExhaustiveSwitchStatement(node);
            if (links.isExhaustive === 0) {
                links.isExhaustive = exhaustive;
            }
        }
        else if (links.isExhaustive === 0) {
            links.isExhaustive = false; // Resolve circularity to false
        }
        return links.isExhaustive;
    }

    function computeExhaustiveSwitchStatement(node: SwitchStatement): boolean {
        if (node.expression.kind === SyntaxKind.TypeOfExpression) {
            const witnesses = getSwitchClauseTypeOfWitnesses(node);
            if (!witnesses) {
                return false;
            }
            const operandConstraint = getBaseConstraintOrType(checkExpressionCached((node.expression as TypeOfExpression).expression));
            // Get the not-equal flags for all handled cases.
            const notEqualFacts = getNotEqualFactsFromTypeofSwitch(0, 0, witnesses);
            if (operandConstraint.flags & TypeFlags.AnyOrUnknown) {
                // We special case the top types to be exhaustive when all cases are handled.
                return (TypeFacts.AllTypeofNE & notEqualFacts) === TypeFacts.AllTypeofNE;
            }
            // A missing not-equal flag indicates that the type wasn't handled by some case.
            return !someType(operandConstraint, t => getTypeFacts(t, notEqualFacts) === notEqualFacts);
        }
        const type = getBaseConstraintOrType(checkExpressionCached(node.expression));
        if (!isLiteralType(type)) {
            return false;
        }
        const switchTypes = getSwitchClauseTypes(node);
        if (!switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever)) {
            return false;
        }
        return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
    }

    function functionHasImplicitReturn(func: FunctionLikeDeclaration) {
        return func.endFlowNode && isReachableFlowNode(func.endFlowNode);
    }

    /** NOTE: Return value of `[]` means a different thing than `undefined`. `[]` means func returns `void`, `undefined` means it returns `never`. */
    function checkAndAggregateReturnExpressionTypes(func: FunctionLikeDeclaration, checkMode: CheckMode | undefined): Type[] | undefined {
        const functionFlags = getFunctionFlags(func);
        const aggregatedTypes: Type[] = [];
        let hasReturnWithNoExpression = functionHasImplicitReturn(func);
        let hasReturnOfTypeNever = false;
        forEachReturnStatement(func.body as Block, returnStatement => {
            let expr = returnStatement.expression;
            if (expr) {
                expr = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
                // Bare calls to this same function don't contribute to inference
                // and `return await` is also safe to unwrap here
                if (functionFlags & FunctionFlags.Async && expr.kind === SyntaxKind.AwaitExpression) {
                    expr = skipParentheses((expr as AwaitExpression).expression, /*excludeJSDocTypeAssertions*/ true);
                }
                if (
                    expr.kind === SyntaxKind.CallExpression &&
                    (expr as CallExpression).expression.kind === SyntaxKind.Identifier &&
                    checkExpressionCached((expr as CallExpression).expression).symbol === getMergedSymbol(func.symbol) &&
                    (!isFunctionExpressionOrArrowFunction(func.symbol.valueDeclaration!) || isConstantReference((expr as CallExpression).expression))
                ) {
                    hasReturnOfTypeNever = true;
                    return;
                }

                let type = checkExpressionCached(expr, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);
                if (functionFlags & FunctionFlags.Async) {
                    // From within an async function you can return either a non-promise value or a promise. Any
                    // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                    // return type of the body should be unwrapped to its awaited type, which should be wrapped in
                    // the native Promise<T> type by the caller.
                    type = unwrapAwaitedType(checkAwaitedType(type, /*withAlias*/ false, func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
                }
                if (type.flags & TypeFlags.Never) {
                    hasReturnOfTypeNever = true;
                }
                pushIfUnique(aggregatedTypes, type);
            }
            else {
                hasReturnWithNoExpression = true;
            }
        });
        if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func))) {
            return undefined;
        }
        if (
            strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression &&
            !(isJSConstructor(func) && aggregatedTypes.some(t => t.symbol === func.symbol))
        ) {
            // Javascript "callable constructors", containing eg `if (!(this instanceof A)) return new A()` should not add undefined
            pushIfUnique(aggregatedTypes, undefinedType);
        }
        return aggregatedTypes;
    }
    function mayReturnNever(func: FunctionLikeDeclaration): boolean {
        switch (func.kind) {
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
                return true;
            case SyntaxKind.MethodDeclaration:
                return func.parent.kind === SyntaxKind.ObjectLiteralExpression;
            default:
                return false;
        }
    }

    function getTypePredicateFromBody(func: FunctionLikeDeclaration): TypePredicate | undefined {
        switch (func.kind) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
                return undefined;
        }
        const functionFlags = getFunctionFlags(func);
        if (functionFlags !== FunctionFlags.Normal) return undefined;

        // Only attempt to infer a type predicate if there's exactly one return.
        let singleReturn: Expression | undefined;
        if (func.body && func.body.kind !== SyntaxKind.Block) {
            singleReturn = func.body; // arrow function
        }
        else {
            const bailedEarly = forEachReturnStatement(func.body as Block, returnStatement => {
                if (singleReturn || !returnStatement.expression) return true;
                singleReturn = returnStatement.expression;
            });
            if (bailedEarly || !singleReturn || functionHasImplicitReturn(func)) return undefined;
        }
        return checkIfExpressionRefinesAnyParameter(func, singleReturn);
    }

    function checkIfExpressionRefinesAnyParameter(func: FunctionLikeDeclaration, expr: Expression): TypePredicate | undefined {
        expr = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
        const returnType = checkExpressionCached(expr);
        if (!(returnType.flags & TypeFlags.Boolean)) return undefined;

        return forEach(func.parameters, (param, i) => {
            const initType = getTypeOfSymbol(param.symbol);
            if (!initType || initType.flags & TypeFlags.Boolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param)) {
                // Refining "x: boolean" to "x is true" or "x is false" isn't useful.
                return;
            }
            const trueType = checkIfExpressionRefinesParameter(func, expr, param, initType);
            if (trueType) {
                return createTypePredicate(TypePredicateKind.Identifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType);
            }
        });
    }

    function checkIfExpressionRefinesParameter(func: FunctionLikeDeclaration, expr: Expression, param: ParameterDeclaration, initType: Type): Type | undefined {
        const antecedent = canHaveFlowNode(expr) && expr.flowNode ||
            expr.parent.kind === SyntaxKind.ReturnStatement && (expr.parent as ReturnStatement).flowNode ||
            createFlowNode(FlowFlags.Start, /*node*/ undefined, /*antecedent*/ undefined);
        const trueCondition = createFlowNode(FlowFlags.TrueCondition, expr, antecedent);

        const trueType = getFlowTypeOfReference(param.name, initType, initType, func, trueCondition);
        if (trueType === initType) return undefined;

        // "x is T" means that x is T if and only if it returns true. If it returns false then x is not T.
        // This means that if the function is called with an argument of type trueType, there can't be anything left in the `else` branch. It must reduce to `never`.
        const falseCondition = createFlowNode(FlowFlags.FalseCondition, expr, antecedent);
        const falseSubtype = getReducedType(getFlowTypeOfReference(param.name, initType, trueType, func, falseCondition));
        return falseSubtype.flags & TypeFlags.Never ? trueType : undefined;
    }

    /**
     * TypeScript Specification 1.0 (6.3) - July 2014
     *   An explicitly typed function whose return type isn't the Void type,
     *   the Any type, or a union type containing the Void or Any type as a constituent
     *   must have at least one return statement somewhere in its body.
     *   An exception to this rule is if the function implementation consists of a single 'throw' statement.
     *
     * @param returnType - return type of the function, can be undefined if return type is not explicitly specified
     */
    function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func: FunctionLikeDeclaration | MethodSignature, returnType: Type | undefined) {
        addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics);
        return;

        function checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics(): void {
            const functionFlags = getFunctionFlags(func);
            const type = returnType && unwrapReturnType(returnType, functionFlags);

            // Functions with an explicitly specified return type that includes `void` or is exactly `any` or `undefined` don't
            // need any return statements.
            if (type && (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined))) {
                return;
            }

            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
            // also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
            if (func.kind === SyntaxKind.MethodSignature || nodeIsMissing(func.body) || func.body!.kind !== SyntaxKind.Block || !functionHasImplicitReturn(func)) {
                return;
            }

            const hasExplicitReturn = func.flags & NodeFlags.HasExplicitReturn;
            const errorNode = getEffectiveReturnTypeNode(func) || func;

            if (type && type.flags & TypeFlags.Never) {
                error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point);
            }
            else if (type && !hasExplicitReturn) {
                // minimal check: function has syntactic return type annotation and no explicit return statements in the body
                // this function does not conform to the specification.
                error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value);
            }
            else if (type && strictNullChecks && !isTypeAssignableTo(undefinedType, type)) {
                error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
            }
            else if (compilerOptions.noImplicitReturns) {
                if (!type) {
                    // If return type annotation is omitted check if function has any explicit return statements.
                    // If it does not have any - its inferred return type is void - don't do any checks.
                    // Otherwise get inferred return type from function body and report error only if it is not void / anytype
                    if (!hasExplicitReturn) {
                        return;
                    }
                    const inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                    if (isUnwrappedReturnTypeUndefinedVoidOrAny(func, inferredReturnType)) {
                        return;
                    }
                }
                error(errorNode, Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
    }

    function checkFunctionExpressionOrObjectLiteralMethod(node: FunctionExpression | ArrowFunction | MethodDeclaration, checkMode?: CheckMode): Type {
        Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));
        checkNodeDeferred(node);

        if (isFunctionExpression(node)) {
            checkCollisionsForDeclarationName(node, node.name);
        }

        // The identityMapper object is used to indicate that function expressions are wildcards
        if (checkMode && checkMode & CheckMode.SkipContextSensitive && isContextSensitive(node)) {
            // Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
            if (!getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node)) {
                // Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
                const contextualSignature = getContextualSignature(node);
                if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
                    const links = getNodeLinks(node);
                    if (links.contextFreeType) {
                        return links.contextFreeType;
                    }
                    const returnType = getReturnTypeFromBody(node, checkMode);
                    const returnOnlySignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, returnType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.IsNonInferrable);
                    const returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], emptyArray, emptyArray);
                    returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType;
                    return links.contextFreeType = returnOnlyType;
                }
            }
            return anyFunctionType;
        }

        // Grammar checking
        const hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
        if (!hasGrammarError && node.kind === SyntaxKind.FunctionExpression) {
            checkGrammarForGenerator(node);
        }

        contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);

        return getTypeOfSymbol(getSymbolOfDeclaration(node));
    }

    function contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node: FunctionExpression | ArrowFunction | MethodDeclaration, checkMode?: CheckMode) {
        const links = getNodeLinks(node);
        // Check if function expression is contextually typed and assign parameter types if so.
        if (!(links.flags & NodeCheckFlags.ContextChecked)) {
            const contextualSignature = getContextualSignature(node);
            // If a type check is started at a function expression that is an argument of a function call, obtaining the
            // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
            // already assigned contextual types.
            if (!(links.flags & NodeCheckFlags.ContextChecked)) {
                links.flags |= NodeCheckFlags.ContextChecked;
                const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKind.Call));
                if (!signature) {
                    return;
                }
                if (isContextSensitive(node)) {
                    if (contextualSignature) {
                        const inferenceContext = getInferenceContext(node);
                        let instantiatedContextualSignature: Signature | undefined;
                        if (checkMode && checkMode & CheckMode.Inferential) {
                            inferFromAnnotatedParametersAndReturn(signature, contextualSignature, inferenceContext!);
                            const restType = getEffectiveRestType(contextualSignature);
                            if (restType && restType.flags & TypeFlags.TypeParameter) {
                                instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext!.nonFixingMapper);
                            }
                        }
                        instantiatedContextualSignature ||= inferenceContext ?
                            instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature;
                        assignContextualParameterTypes(signature, instantiatedContextualSignature);
                    }
                    else {
                        // Force resolution of all parameter types such that the absence of a contextual type is consistently reflected.
                        assignNonContextualParameterTypes(signature);
                    }
                }
                else if (contextualSignature && !node.typeParameters && contextualSignature.parameters.length > node.parameters.length) {
                    const inferenceContext = getInferenceContext(node);
                    if (checkMode && checkMode & CheckMode.Inferential) {
                        inferFromAnnotatedParametersAndReturn(signature, contextualSignature, inferenceContext!);
                    }
                }
                if (contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType) {
                    const returnType = getReturnTypeFromBody(node, checkMode);
                    if (!signature.resolvedReturnType) {
                        signature.resolvedReturnType = returnType;
                    }
                }
                checkSignatureDeclaration(node);
            }
        }
    }

    function checkFunctionExpressionOrObjectLiteralMethodDeferred(node: ArrowFunction | FunctionExpression | MethodDeclaration) {
        Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));

        const functionFlags = getFunctionFlags(node);
        const returnType = getReturnTypeFromAnnotation(node);
        checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);

        if (node.body) {
            if (!getEffectiveReturnTypeNode(node)) {
                // There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
                // we need. An example is the noImplicitAny errors resulting from widening the return expression
                // of a function. Because checking of function expression bodies is deferred, there was never an
                // appropriate time to do this during the main walk of the file (see the comment at the top of
                // checkFunctionExpressionBodies). So it must be done now.
                getReturnTypeOfSignature(getSignatureFromDeclaration(node));
            }

            if (node.body.kind === SyntaxKind.Block) {
                checkSourceElement(node.body);
            }
            else {
                // From within an async function you can return either a non-promise value or a promise. Any
                // Promise/A+ compatible implementation will always assimilate any foreign promise, so we
                // should not be checking assignability of a promise to the return type. Instead, we need to
                // check assignability of the awaited type of the expression body against the promised type of
                // its return type annotation.
                const exprType = checkExpression(node.body);
                const returnOrPromisedType = returnType && unwrapReturnType(returnType, functionFlags);
                if (returnOrPromisedType) {
                    checkReturnExpression(node, returnOrPromisedType, node.body, node.body, exprType);
                }
            }
        }
    }

    function checkArithmeticOperandType(operand: Node, type: Type, diagnostic: DiagnosticMessage, isAwaitValid = false): boolean {
        if (!isTypeAssignableTo(type, numberOrBigIntType)) {
            const awaitedType = isAwaitValid && getAwaitedTypeOfPromise(type);
            errorAndMaybeSuggestAwait(
                operand,
                !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType),
                diagnostic,
            );
            return false;
        }
        return true;
    }

    function isReadonlyAssignmentDeclaration(d: Declaration) {
        if (!isCallExpression(d)) {
            return false;
        }
        if (!isBindableObjectDefinePropertyCall(d)) {
            return false;
        }
        const objectLitType = checkExpressionCached(d.arguments[2]);
        const valueType = getTypeOfPropertyOfType(objectLitType, "value" as __String);
        if (valueType) {
            const writableProp = getPropertyOfType(objectLitType, "writable" as __String);
            const writableType = writableProp && getTypeOfSymbol(writableProp);
            if (!writableType || writableType === falseType || writableType === regularFalseType) {
                return true;
            }
            // We include this definition whereupon we walk back and check the type at the declaration because
            // The usual definition of `Object.defineProperty` will _not_ cause literal types to be preserved in the
            // argument types, should the type be contextualized by the call itself.
            if (writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration)) {
                const initializer = writableProp.valueDeclaration.initializer;
                const rawOriginalType = checkExpression(initializer);
                if (rawOriginalType === falseType || rawOriginalType === regularFalseType) {
                    return true;
                }
            }
            return false;
        }
        const setProp = getPropertyOfType(objectLitType, "set" as __String);
        return !setProp;
    }

    function isReadonlySymbol(symbol: Symbol): boolean {
        // The following symbols are considered read-only:
        // Properties with a 'readonly' modifier
        // Variables declared with 'const'
        // Get accessors without matching set accessors
        // Enum members
        // Object.defineProperty assignments with writable false or no setter
        // Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
        return !!(getCheckFlags(symbol) & CheckFlags.Readonly ||
            symbol.flags & SymbolFlags.Property && getDeclarationModifierFlagsFromSymbol(symbol) & ModifierFlags.Readonly ||
            symbol.flags & SymbolFlags.Variable && getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant ||
            symbol.flags & SymbolFlags.Accessor && !(symbol.flags & SymbolFlags.SetAccessor) ||
            symbol.flags & SymbolFlags.EnumMember ||
            some(symbol.declarations, isReadonlyAssignmentDeclaration));
    }

    function isAssignmentToReadonlyEntity(expr: Expression, symbol: Symbol, assignmentKind: AssignmentKind) {
        if (assignmentKind === AssignmentKind.None) {
            // no assigment means it doesn't matter whether the entity is readonly
            return false;
        }
        if (isReadonlySymbol(symbol)) {
            // Allow assignments to readonly properties within constructors of the same class declaration.
            if (
                symbol.flags & SymbolFlags.Property &&
                isAccessExpression(expr) &&
                expr.expression.kind === SyntaxKind.ThisKeyword
            ) {
                // Look for if this is the constructor for the class that `symbol` is a property of.
                const ctor = getControlFlowContainer(expr);
                if (!(ctor && (ctor.kind === SyntaxKind.Constructor || isJSConstructor(ctor)))) {
                    return true;
                }
                if (symbol.valueDeclaration) {
                    const isAssignmentDeclaration = isBinaryExpression(symbol.valueDeclaration);
                    const isLocalPropertyDeclaration = ctor.parent === symbol.valueDeclaration.parent;
                    const isLocalParameterProperty = ctor === symbol.valueDeclaration.parent;
                    const isLocalThisPropertyAssignment = isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor.parent;
                    const isLocalThisPropertyAssignmentConstructorFunction = isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor;
                    const isWriteableSymbol = isLocalPropertyDeclaration
                        || isLocalParameterProperty
                        || isLocalThisPropertyAssignment
                        || isLocalThisPropertyAssignmentConstructorFunction;
                    return !isWriteableSymbol;
                }
            }
            return true;
        }
        if (isAccessExpression(expr)) {
            // references through namespace import should be readonly
            const node = skipParentheses(expr.expression);
            if (node.kind === SyntaxKind.Identifier) {
                const symbol = getNodeLinks(node).resolvedSymbol!;
                if (symbol.flags & SymbolFlags.Alias) {
                    const declaration = getDeclarationOfAliasSymbol(symbol);
                    return !!declaration && declaration.kind === SyntaxKind.NamespaceImport;
                }
            }
        }
        return false;
    }

    function checkReferenceExpression(expr: Expression, invalidReferenceMessage: DiagnosticMessage, invalidOptionalChainMessage: DiagnosticMessage): boolean {
        // References are combinations of identifiers, parentheses, and property accesses.
        const node = skipOuterExpressions(expr, OuterExpressionKinds.Assertions | OuterExpressionKinds.Parentheses);
        if (node.kind !== SyntaxKind.Identifier && !isAccessExpression(node)) {
            error(expr, invalidReferenceMessage);
            return false;
        }
        if (node.flags & NodeFlags.OptionalChain) {
            error(expr, invalidOptionalChainMessage);
            return false;
        }
        return true;
    }

    function checkDeleteExpression(node: DeleteExpression): Type {
        checkExpression(node.expression);
        const expr = skipParentheses(node.expression);
        if (!isAccessExpression(expr)) {
            error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference);
            return booleanType;
        }
        if (isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name)) {
            error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier);
        }
        const links = getNodeLinks(expr);
        const symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
        if (symbol) {
            if (isReadonlySymbol(symbol)) {
                error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property);
            }
            else {
                checkDeleteExpressionMustBeOptional(expr, symbol);
            }
        }
        return booleanType;
    }

    function checkDeleteExpressionMustBeOptional(expr: AccessExpression, symbol: Symbol) {
        const type = getTypeOfSymbol(symbol);
        if (
            strictNullChecks &&
            !(type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Never)) &&
            !(exactOptionalPropertyTypes ? symbol.flags & SymbolFlags.Optional : hasTypeFacts(type, TypeFacts.IsUndefined))
        ) {
            error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional);
        }
    }

    function checkTypeOfExpression(node: TypeOfExpression): Type {
        checkExpression(node.expression);
        return typeofType;
    }

    function checkVoidExpression(node: VoidExpression): Type {
        checkNodeDeferred(node);
        return undefinedWideningType;
    }

    function checkAwaitGrammar(node: AwaitExpression | VariableDeclarationList): boolean {
        // Grammar checking
        let hasError = false;
        const container = getContainingFunctionOrClassStaticBlock(node);
        if (container && isClassStaticBlockDeclaration(container)) {
            // NOTE: We report this regardless as to whether there are parse diagnostics.
            const message = isAwaitExpression(node) ? Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block :
                Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block;
            error(node, message);
            hasError = true;
        }
        else if (!(node.flags & NodeFlags.AwaitContext)) {
            if (isInTopLevelContext(node)) {
                const sourceFile = getSourceFileOfNode(node);
                if (!hasParseDiagnostics(sourceFile)) {
                    let span: TextSpan | undefined;
                    if (!isEffectiveExternalModule(sourceFile, compilerOptions)) {
                        span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);
                        const message = isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module :
                            Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module;
                        const diagnostic = createFileDiagnostic(sourceFile, span.start, span.length, message);
                        diagnostics.add(diagnostic);
                        hasError = true;
                    }
                    switch (moduleKind) {
                        case ModuleKind.Node16:
                        case ModuleKind.Node18:
                        case ModuleKind.Node20:
                        case ModuleKind.NodeNext:
                            if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {
                                span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);
                                diagnostics.add(
                                    createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),
                                );
                                hasError = true;
                                break;
                            }
                            // fallthrough
                        case ModuleKind.ES2022:
                        case ModuleKind.ESNext:
                        case ModuleKind.Preserve:
                        case ModuleKind.System:
                            if (languageVersion >= ScriptTarget.ES2017) {
                                break;
                            }
                            // fallthrough
                        default:
                            span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);
                            const message = isAwaitExpression(node) ? Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_node18_node20_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher :
                                Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_node18_node20_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher;
                            diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message));
                            hasError = true;
                            break;
                    }
                }
            }
            else {
                // use of 'await' in non-async function
                const sourceFile = getSourceFileOfNode(node);
                if (!hasParseDiagnostics(sourceFile)) {
                    const span = getSpanOfTokenAtPosition(sourceFile, node.pos);
                    const message = isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules :
                        Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules;
                    const diagnostic = createFileDiagnostic(sourceFile, span.start, span.length, message);
                    if (container && container.kind !== SyntaxKind.Constructor && (getFunctionFlags(container) & FunctionFlags.Async) === 0) {
                        const relatedInfo = createDiagnosticForNode(container, Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                        addRelatedInfo(diagnostic, relatedInfo);
                    }
                    diagnostics.add(diagnostic);
                    hasError = true;
                }
            }
        }

        if (isAwaitExpression(node) && isInParameterInitializerBeforeContainingFunction(node)) {
            // NOTE: We report this regardless as to whether there are parse diagnostics.
            error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer);
            hasError = true;
        }

        return hasError;
    }

    function checkAwaitExpression(node: AwaitExpression): Type {
        addLazyDiagnostic(() => checkAwaitGrammar(node));

        const operandType = checkExpression(node.expression);
        const awaitedType = checkAwaitedType(operandType, /*withAlias*/ true, node, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        if (awaitedType === operandType && !isErrorType(awaitedType) && !(operandType.flags & TypeFlags.AnyOrUnknown)) {
            addErrorOrSuggestion(/*isError*/ false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression));
        }
        return awaitedType;
    }

    function checkPrefixUnaryExpression(node: PrefixUnaryExpression): Type {
        const operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        switch (node.operand.kind) {
            case SyntaxKind.NumericLiteral:
                switch (node.operator) {
                    case SyntaxKind.MinusToken:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand as NumericLiteral).text));
                    case SyntaxKind.PlusToken:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand as NumericLiteral).text));
                }
                break;
            case SyntaxKind.BigIntLiteral:
                if (node.operator === SyntaxKind.MinusToken) {
                    return getFreshTypeOfLiteralType(getBigIntLiteralType({
                        negative: true,
                        base10Value: parsePseudoBigInt((node.operand as BigIntLiteral).text),
                    }));
                }
        }
        switch (node.operator) {
            case SyntaxKind.PlusToken:
            case SyntaxKind.MinusToken:
            case SyntaxKind.TildeToken:
                checkNonNullType(operandType, node.operand);
                if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.ESSymbolLike)) {
                    error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator));
                }
                if (node.operator === SyntaxKind.PlusToken) {
                    if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.BigIntLike)) {
                        error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));
                    }
                    return numberType;
                }
                return getUnaryResultType(operandType);
            case SyntaxKind.ExclamationToken:
                checkTruthinessOfType(operandType, node.operand);
                const facts = getTypeFacts(operandType, TypeFacts.Truthy | TypeFacts.Falsy);
                return facts === TypeFacts.Truthy ? falseType :
                    facts === TypeFacts.Falsy ? trueType :
                    booleanType;
            case SyntaxKind.PlusPlusToken:
            case SyntaxKind.MinusMinusToken:
                const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
                if (ok) {
                    // run check only if former checks succeeded to avoid reporting cascading errors
                    checkReferenceExpression(
                        node.operand,
                        Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
                        Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,
                    );
                }
                return getUnaryResultType(operandType);
        }
        return errorType;
    }

    function checkPostfixUnaryExpression(node: PostfixUnaryExpression): Type {
        const operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        const ok = checkArithmeticOperandType(
            node.operand,
            checkNonNullType(operandType, node.operand),
            Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type,
        );
        if (ok) {
            // run check only if former checks succeeded to avoid reporting cascading errors
            checkReferenceExpression(
                node.operand,
                Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
                Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,
            );
        }
        return getUnaryResultType(operandType);
    }

    function getUnaryResultType(operandType: Type): Type {
        if (maybeTypeOfKind(operandType, TypeFlags.BigIntLike)) {
            return isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlags.NumberLike)
                ? numberOrBigIntType
                : bigintType;
        }
        // If it's not a bigint type, implicit coercion will result in a number
        return numberType;
    }

    function maybeTypeOfKindConsideringBaseConstraint(type: Type, kind: TypeFlags): boolean {
        if (maybeTypeOfKind(type, kind)) {
            return true;
        }

        const baseConstraint = getBaseConstraintOrType(type);
        return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind);
    }

    // Return true if type might be of the given kind. A union or intersection type might be of a given
    // kind if at least one constituent type is of the given kind.
    function maybeTypeOfKind(type: Type, kind: TypeFlags): boolean {
        if (type.flags & kind) {
            return true;
        }
        if (type.flags & TypeFlags.UnionOrIntersection) {
            const types = (type as UnionOrIntersectionType).types;
            for (const t of types) {
                if (maybeTypeOfKind(t, kind)) {
                    return true;
                }
            }
        }
        return false;
    }

    function isTypeAssignableToKind(source: Type, kind: TypeFlags, strict?: boolean): boolean {
        if (source.flags & kind) {
            return true;
        }
        if (strict && source.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null)) {
            return false;
        }
        return !!(kind & TypeFlags.NumberLike) && isTypeAssignableTo(source, numberType) ||
            !!(kind & TypeFlags.BigIntLike) && isTypeAssignableTo(source, bigintType) ||
            !!(kind & TypeFlags.StringLike) && isTypeAssignableTo(source, stringType) ||
            !!(kind & TypeFlags.BooleanLike) && isTypeAssignableTo(source, booleanType) ||
            !!(kind & TypeFlags.Void) && isTypeAssignableTo(source, voidType) ||
            !!(kind & TypeFlags.Never) && isTypeAssignableTo(source, neverType) ||
            !!(kind & TypeFlags.Null) && isTypeAssignableTo(source, nullType) ||
            !!(kind & TypeFlags.Undefined) && isTypeAssignableTo(source, undefinedType) ||
            !!(kind & TypeFlags.ESSymbol) && isTypeAssignableTo(source, esSymbolType) ||
            !!(kind & TypeFlags.NonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType);
    }

    function allTypesAssignableToKind(source: Type, kind: TypeFlags, strict?: boolean): boolean {
        return source.flags & TypeFlags.Union ?
            every((source as UnionType).types, subType => allTypesAssignableToKind(subType, kind, strict)) :
            isTypeAssignableToKind(source, kind, strict);
    }

    function isConstEnumObjectType(type: Type): boolean {
        return !!(getObjectFlags(type) & ObjectFlags.Anonymous) && !!type.symbol && isConstEnumSymbol(type.symbol);
    }

    function isConstEnumSymbol(symbol: Symbol): boolean {
        return (symbol.flags & SymbolFlags.ConstEnum) !== 0;
    }

    /**
     * Get the type of the `[Symbol.hasInstance]` method of an object type.
     */
    function getSymbolHasInstanceMethodOfObjectType(type: Type) {
        const hasInstancePropertyName = getPropertyNameForKnownSymbolName("hasInstance");
        if (allTypesAssignableToKind(type, TypeFlags.NonPrimitive)) {
            const hasInstanceProperty = getPropertyOfType(type, hasInstancePropertyName);
            if (hasInstanceProperty) {
                const hasInstancePropertyType = getTypeOfSymbol(hasInstanceProperty);
                if (hasInstancePropertyType && getSignaturesOfType(hasInstancePropertyType, SignatureKind.Call).length !== 0) {
                    return hasInstancePropertyType;
                }
            }
        }
    }

    function checkInstanceOfExpression(left: Expression, right: Expression, leftType: Type, rightType: Type, checkMode?: CheckMode): Type {
        if (leftType === silentNeverType || rightType === silentNeverType) {
            return silentNeverType;
        }

        // TypeScript 1.0 spec (April 2014): 4.15.4
        // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
        // and the right operand to be of type Any, a subtype of the 'Function' interface type, or have a call or construct signature.
        // The result is always of the Boolean primitive type.
        // NOTE: do not raise error if leftType is unknown as related error was already reported
        if (
            !isTypeAny(leftType) &&
            allTypesAssignableToKind(leftType, TypeFlags.Primitive)
        ) {
            error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
        }

        Debug.assert(isInstanceOfExpression(left.parent));
        const signature = getResolvedSignature(left.parent, /*candidatesOutArray*/ undefined, checkMode);
        if (signature === resolvingSignature) {
            // CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
            // returns a function type. We defer checking and return silentNeverType.
            return silentNeverType;
        }

        // If rightType has a `[Symbol.hasInstance]` method that is not `(value: unknown) => boolean`, we
        // must check the expression as if it were a call to `right[Symbol.hasInstance](left)`. The call to
        // `getResolvedSignature`, below, will check that leftType is assignable to the type of the first
        // parameter.
        const returnType = getReturnTypeOfSignature(signature);

        // We also verify that the return type of the `[Symbol.hasInstance]` method is assignable to
        // `boolean`. According to the spec, the runtime will actually perform `ToBoolean` on the result,
        // but this is more type-safe.
        checkTypeAssignableTo(returnType, booleanType, right, Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression);

        return booleanType;
    }

    function hasEmptyObjectIntersection(type: Type): boolean {
        return someType(type, t => t === unknownEmptyObjectType || !!(t.flags & TypeFlags.Intersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t)));
    }

    function checkInExpression(left: Expression, right: Expression, leftType: Type, rightType: Type): Type {
        if (leftType === silentNeverType || rightType === silentNeverType) {
            return silentNeverType;
        }
        if (isPrivateIdentifier(left)) {
            if (
                languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||
                languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators ||
                !useDefineForClassFields
            ) {
                checkExternalEmitHelpers(left, ExternalEmitHelpers.ClassPrivateFieldIn);
            }
            // Unlike in 'checkPrivateIdentifierExpression' we now have access to the RHS type
            // which provides us with the opportunity to emit more detailed errors
            if (!getNodeLinks(left).resolvedSymbol && getContainingClass(left)) {
                const isUncheckedJS = isUncheckedJSSuggestion(left, rightType.symbol, /*excludeClasses*/ true);
                reportNonexistentProperty(left, rightType, isUncheckedJS);
            }
        }
        else {
            // The type of the lef operand must be assignable to string, number, or symbol.
            checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left);
        }
        // The type of the right operand must be assignable to 'object'.
        if (checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right)) {
            // The {} type is assignable to the object type, yet {} might represent a primitive type. Here we
            // detect and error on {} that results from narrowing the unknown type, as well as intersections
            // that include {} (we know that the other types in such intersections are assignable to object
            // since we already checked for that).
            if (hasEmptyObjectIntersection(rightType)) {
                error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType));
            }
        }
        // The result is always of the Boolean primitive type.
        return booleanType;
    }

    function checkObjectLiteralAssignment(node: ObjectLiteralExpression, sourceType: Type, rightIsThis?: boolean): Type {
        const properties = node.properties;
        if (strictNullChecks && properties.length === 0) {
            return checkNonNullType(sourceType, node);
        }
        for (let i = 0; i < properties.length; i++) {
            checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);
        }
        return sourceType;
    }

    /** Note: If property cannot be a SpreadAssignment, then allProperties does not need to be provided */
    function checkObjectLiteralDestructuringPropertyAssignment(node: ObjectLiteralExpression, objectLiteralType: Type, propertyIndex: number, allProperties?: NodeArray<ObjectLiteralElementLike>, rightIsThis = false) {
        const properties = node.properties;
        const property = properties[propertyIndex];
        if (property.kind === SyntaxKind.PropertyAssignment || property.kind === SyntaxKind.ShorthandPropertyAssignment) {
            const name = property.name;
            const exprType = getLiteralTypeFromPropertyName(name);
            if (isTypeUsableAsPropertyName(exprType)) {
                const text = getPropertyNameFromType(exprType);
                const prop = getPropertyOfType(objectLiteralType, text);
                if (prop) {
                    markPropertyAsReferenced(prop, property, rightIsThis);
                    checkPropertyAccessibility(property, /*isSuper*/ false, /*writing*/ true, objectLiteralType, prop);
                }
            }
            const elementType = getIndexedAccessType(objectLiteralType, exprType, AccessFlags.ExpressionPosition | (hasDefaultValue(property) ? AccessFlags.AllowMissing : 0), name);
            const type = getFlowTypeOfDestructuring(property, elementType);
            return checkDestructuringAssignment(property.kind === SyntaxKind.ShorthandPropertyAssignment ? property : property.initializer, type);
        }
        else if (property.kind === SyntaxKind.SpreadAssignment) {
            if (propertyIndex < properties.length - 1) {
                error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
            }
            else {
                if (languageVersion < LanguageFeatureMinimumTarget.ObjectSpreadRest) {
                    checkExternalEmitHelpers(property, ExternalEmitHelpers.Rest);
                }
                const nonRestNames: PropertyName[] = [];
                if (allProperties) {
                    for (const otherProperty of allProperties) {
                        if (!isSpreadAssignment(otherProperty)) {
                            nonRestNames.push(otherProperty.name);
                        }
                    }
                }
                const type = getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol);
                checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                return checkDestructuringAssignment(property.expression, type);
            }
        }
        else {
            error(property, Diagnostics.Property_assignment_expected);
        }
    }

    function checkArrayLiteralAssignment(node: ArrayLiteralExpression, sourceType: Type, checkMode?: CheckMode): Type {
        const elements = node.elements;
        if (languageVersion < LanguageFeatureMinimumTarget.DestructuringAssignment && compilerOptions.downlevelIteration) {
            checkExternalEmitHelpers(node, ExternalEmitHelpers.Read);
        }
        // This elementType will be used if the specific property corresponding to this index is not
        // present (aka the tuple element property). This call also checks that the parentType is in
        // fact an iterable or array (depending on target language).
        const possiblyOutOfBoundsType = checkIteratedTypeOrElementType(IterationUse.Destructuring | IterationUse.PossiblyOutOfBounds, sourceType, undefinedType, node) || errorType;
        let inBoundsType: Type | undefined = compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType;
        for (let i = 0; i < elements.length; i++) {
            let type = possiblyOutOfBoundsType;
            if (node.elements[i].kind === SyntaxKind.SpreadElement) {
                type = inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType);
            }
            checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type, checkMode);
        }
        return sourceType;
    }

    function checkArrayLiteralDestructuringElementAssignment(node: ArrayLiteralExpression, sourceType: Type, elementIndex: number, elementType: Type, checkMode?: CheckMode) {
        const elements = node.elements;
        const element = elements[elementIndex];
        if (element.kind !== SyntaxKind.OmittedExpression) {
            if (element.kind !== SyntaxKind.SpreadElement) {
                const indexType = getNumberLiteralType(elementIndex);
                if (isArrayLikeType(sourceType)) {
                    // We create a synthetic expression so that getIndexedAccessType doesn't get confused
                    // when the element is a SyntaxKind.ElementAccessExpression.
                    const accessFlags = AccessFlags.ExpressionPosition | (hasDefaultValue(element) ? AccessFlags.AllowMissing : 0);
                    const elementType = getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType;
                    const assignedType = hasDefaultValue(element) ? getTypeWithFacts(elementType, TypeFacts.NEUndefined) : elementType;
                    const type = getFlowTypeOfDestructuring(element, assignedType);
                    return checkDestructuringAssignment(element, type, checkMode);
                }
                return checkDestructuringAssignment(element, elementType, checkMode);
            }
            if (elementIndex < elements.length - 1) {
                error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
            }
            else {
                const restExpression = (element as SpreadElement).expression;
                if (restExpression.kind === SyntaxKind.BinaryExpression && (restExpression as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken) {
                    error((restExpression as BinaryExpression).operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer);
                }
                else {
                    checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                    const type = everyType(sourceType, isTupleType) ?
                        mapType(sourceType, t => sliceTupleType(t as TupleTypeReference, elementIndex)) :
                        createArrayType(elementType);
                    return checkDestructuringAssignment(restExpression, type, checkMode);
                }
            }
        }
        return undefined;
    }

    function checkDestructuringAssignment(exprOrAssignment: Expression | ShorthandPropertyAssignment, sourceType: Type, checkMode?: CheckMode, rightIsThis?: boolean): Type {
        let target: Expression;
        if (exprOrAssignment.kind === SyntaxKind.ShorthandPropertyAssignment) {
            const prop = exprOrAssignment as ShorthandPropertyAssignment;
            if (prop.objectAssignmentInitializer) {
                // In strict null checking mode, if a default value of a non-undefined type is specified, remove
                // undefined from the final type.
                if (
                    strictNullChecks &&
                    !(hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFacts.IsUndefined))
                ) {
                    sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined);
                }
                checkBinaryLikeExpression(prop.name, prop.equalsToken!, prop.objectAssignmentInitializer, checkMode);
            }
            target = (exprOrAssignment as ShorthandPropertyAssignment).name;
        }
        else {
            target = exprOrAssignment;
        }

        if (target.kind === SyntaxKind.BinaryExpression && (target as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken) {
            checkBinaryExpression(target as BinaryExpression, checkMode);
            target = (target as BinaryExpression).left;
            // A default value is specified, so remove undefined from the final type.
            if (strictNullChecks) {
                sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined);
            }
        }
        if (target.kind === SyntaxKind.ObjectLiteralExpression) {
            return checkObjectLiteralAssignment(target as ObjectLiteralExpression, sourceType, rightIsThis);
        }
        if (target.kind === SyntaxKind.ArrayLiteralExpression) {
            return checkArrayLiteralAssignment(target as ArrayLiteralExpression, sourceType, checkMode);
        }
        return checkReferenceAssignment(target, sourceType, checkMode);
    }

    function checkReferenceAssignment(target: Expression, sourceType: Type, checkMode?: CheckMode): Type {
        const targetType = checkExpression(target, checkMode);
        const error = target.parent.kind === SyntaxKind.SpreadAssignment ?
            Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :
            Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
        const optionalError = target.parent.kind === SyntaxKind.SpreadAssignment ?
            Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access :
            Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access;
        if (checkReferenceExpression(target, error, optionalError)) {
            checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target);
        }
        if (isPrivateIdentifierPropertyAccessExpression(target)) {
            // NOTE: we do not limit this to LanguageFeatureTargets.PrivateNames as some other feature downleveling still requires this.
            checkExternalEmitHelpers(target.parent, ExternalEmitHelpers.ClassPrivateFieldSet);
        }
        return sourceType;
    }

    /**
     * This is a *shallow* check: An expression is side-effect-free if the
     * evaluation of the expression *itself* cannot produce side effects.
     * For example, x++ / 3 is side-effect free because the / operator
     * does not have side effects.
     * The intent is to "smell test" an expression for correctness in positions where
     * its value is discarded (e.g. the left side of the comma operator).
     */
    function isSideEffectFree(node: Node): boolean {
        node = skipParentheses(node);
        switch (node.kind) {
            case SyntaxKind.Identifier:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.BigIntLiteral:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.UndefinedKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.JsxElement:
                return true;

            case SyntaxKind.ConditionalExpression:
                return isSideEffectFree((node as ConditionalExpression).whenTrue) &&
                    isSideEffectFree((node as ConditionalExpression).whenFalse);

            case SyntaxKind.BinaryExpression:
                if (isAssignmentOperator((node as BinaryExpression).operatorToken.kind)) {
                    return false;
                }
                return isSideEffectFree((node as BinaryExpression).left) &&
                    isSideEffectFree((node as BinaryExpression).right);

            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PostfixUnaryExpression:
                // Unary operators ~, !, +, and - have no side effects.
                // The rest do.
                switch ((node as PrefixUnaryExpression).operator) {
                    case SyntaxKind.ExclamationToken:
                    case SyntaxKind.PlusToken:
                    case SyntaxKind.MinusToken:
                    case SyntaxKind.TildeToken:
                        return true;
                }
                return false;

            // Some forms listed here for clarity
            case SyntaxKind.VoidExpression: // Explicit opt-out
            case SyntaxKind.TypeAssertionExpression: // Not SEF, but can produce useful type warnings
            case SyntaxKind.AsExpression: // Not SEF, but can produce useful type warnings
            default:
                return false;
        }
    }

    function isTypeEqualityComparableTo(source: Type, target: Type) {
        return (target.flags & TypeFlags.Nullable) !== 0 || isTypeComparableTo(source, target);
    }

    function createCheckBinaryExpression() {
        interface WorkArea {
            readonly checkMode: CheckMode | undefined;
            skip: boolean;
            stackIndex: number;
            /**
             * Holds the types from the left-side of an expression from [0..stackIndex].
             * Holds the type of the result at stackIndex+1. This allows us to reuse existing stack entries
             * and avoid storing an extra property on the object (i.e., `lastResult`).
             */
            typeStack: (Type | undefined)[];
        }

        const trampoline = createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState);

        return (node: BinaryExpression, checkMode: CheckMode | undefined) => {
            const result = trampoline(node, checkMode);
            Debug.assertIsDefined(result);
            return result;
        };

        function onEnter(node: BinaryExpression, state: WorkArea | undefined, checkMode: CheckMode | undefined) {
            if (state) {
                state.stackIndex++;
                state.skip = false;
                setLeftType(state, /*type*/ undefined);
                setLastResult(state, /*type*/ undefined);
            }
            else {
                state = {
                    checkMode,
                    skip: false,
                    stackIndex: 0,
                    typeStack: [undefined, undefined],
                };
            }

            if (isInJSFile(node) && getAssignedExpandoInitializer(node)) {
                state.skip = true;
                setLastResult(state, checkExpression(node.right, checkMode));
                return state;
            }

            checkNullishCoalesceOperands(node);

            const operator = node.operatorToken.kind;
            if (operator === SyntaxKind.EqualsToken && (node.left.kind === SyntaxKind.ObjectLiteralExpression || node.left.kind === SyntaxKind.ArrayLiteralExpression)) {
                state.skip = true;
                setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind === SyntaxKind.ThisKeyword));
                return state;
            }

            return state;
        }

        function onLeft(left: Expression, state: WorkArea, _node: BinaryExpression) {
            if (!state.skip) {
                return maybeCheckExpression(state, left);
            }
        }

        function onOperator(operatorToken: BinaryOperatorToken, state: WorkArea, node: BinaryExpression) {
            if (!state.skip) {
                const leftType = getLastResult(state);
                Debug.assertIsDefined(leftType);
                setLeftType(state, leftType);
                setLastResult(state, /*type*/ undefined);
                const operator = operatorToken.kind;
                if (isLogicalOrCoalescingBinaryOperator(operator)) {
                    let parent = node.parent;
                    while (parent.kind === SyntaxKind.ParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent)) {
                        parent = parent.parent;
                    }
                    if (operator === SyntaxKind.AmpersandAmpersandToken || isIfStatement(parent)) {
                        checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType, isIfStatement(parent) ? parent.thenStatement : undefined);
                    }
                    if (isBinaryLogicalOperator(operator)) {
                        checkTruthinessOfType(leftType, node.left);
                    }
                }
            }
        }

        function onRight(right: Expression, state: WorkArea, _node: BinaryExpression) {
            if (!state.skip) {
                return maybeCheckExpression(state, right);
            }
        }

        function onExit(node: BinaryExpression, state: WorkArea): Type | undefined {
            let result: Type | undefined;
            if (state.skip) {
                result = getLastResult(state);
            }
            else {
                const leftType = getLeftType(state);
                Debug.assertIsDefined(leftType);

                const rightType = getLastResult(state);
                Debug.assertIsDefined(rightType);

                result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node);
            }

            state.skip = false;
            setLeftType(state, /*type*/ undefined);
            setLastResult(state, /*type*/ undefined);
            state.stackIndex--;
            return result;
        }

        function foldState(state: WorkArea, result: Type | undefined, _side: "left" | "right") {
            setLastResult(state, result);
            return state;
        }

        function maybeCheckExpression(state: WorkArea, node: Expression): BinaryExpression | undefined {
            if (isBinaryExpression(node)) {
                return node;
            }
            setLastResult(state, checkExpression(node, state.checkMode));
        }

        function getLeftType(state: WorkArea) {
            return state.typeStack[state.stackIndex];
        }

        function setLeftType(state: WorkArea, type: Type | undefined) {
            state.typeStack[state.stackIndex] = type;
        }

        function getLastResult(state: WorkArea) {
            return state.typeStack[state.stackIndex + 1];
        }

        function setLastResult(state: WorkArea, type: Type | undefined) {
            // To reduce overhead, reuse the next stack entry to store the
            // last result. This avoids the overhead of an additional property
            // on `WorkArea` and reuses empty stack entries as we walk back up
            // the stack.
            state.typeStack[state.stackIndex + 1] = type;
        }
    }

    function checkNullishCoalesceOperands(node: BinaryExpression) {
        const { left, operatorToken, right } = node;
        if (operatorToken.kind === SyntaxKind.QuestionQuestionToken) {
            if (isBinaryExpression(left) && (left.operatorToken.kind === SyntaxKind.BarBarToken || left.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken)) {
                grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind));
            }
            if (isBinaryExpression(right) && (right.operatorToken.kind === SyntaxKind.BarBarToken || right.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken)) {
                grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind));
            }

            checkNullishCoalesceOperandLeft(node);
            checkNullishCoalesceOperandRight(node);
        }
    }

    function checkNullishCoalesceOperandLeft(node: BinaryExpression) {
        const leftTarget = skipOuterExpressions(node.left, OuterExpressionKinds.All);

        const nullishSemantics = getSyntacticNullishnessSemantics(leftTarget);
        if (nullishSemantics !== PredicateSemantics.Sometimes) {
            if (nullishSemantics === PredicateSemantics.Always) {
                error(leftTarget, Diagnostics.This_expression_is_always_nullish);
            }
            else {
                error(leftTarget, Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish);
            }
        }
    }

    function checkNullishCoalesceOperandRight(node: BinaryExpression) {
        const rightTarget = skipOuterExpressions(node.right, OuterExpressionKinds.All);
        const nullishSemantics = getSyntacticNullishnessSemantics(rightTarget);
        if (isNotWithinNullishCoalesceExpression(node)) {
            return;
        }

        if (nullishSemantics === PredicateSemantics.Always) {
            error(rightTarget, Diagnostics.This_expression_is_always_nullish);
        }
        else if (nullishSemantics === PredicateSemantics.Never) {
            error(rightTarget, Diagnostics.This_expression_is_never_nullish);
        }
    }

    function isNotWithinNullishCoalesceExpression(node: BinaryExpression) {
        return !isBinaryExpression(node.parent) || node.parent.operatorToken.kind !== SyntaxKind.QuestionQuestionToken;
    }

    function getSyntacticNullishnessSemantics(node: Node): PredicateSemantics {
        node = skipOuterExpressions(node);
        switch (node.kind) {
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.ThisKeyword:
                return PredicateSemantics.Sometimes;
            case SyntaxKind.BinaryExpression:
                // List of operators that can produce null/undefined:
                // = ??= ?? || ||= && &&=
                switch ((node as BinaryExpression).operatorToken.kind) {
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.QuestionQuestionToken:
                    case SyntaxKind.QuestionQuestionEqualsToken:
                    case SyntaxKind.BarBarToken:
                    case SyntaxKind.BarBarEqualsToken:
                    case SyntaxKind.AmpersandAmpersandToken:
                    case SyntaxKind.AmpersandAmpersandEqualsToken:
                        return PredicateSemantics.Sometimes;
                    case SyntaxKind.CommaToken:
                        return getSyntacticNullishnessSemantics((node as BinaryExpression).right);
                }
                return PredicateSemantics.Never;
            case SyntaxKind.ConditionalExpression:
                return getSyntacticNullishnessSemantics((node as ConditionalExpression).whenTrue) | getSyntacticNullishnessSemantics((node as ConditionalExpression).whenFalse);
            case SyntaxKind.NullKeyword:
                return PredicateSemantics.Always;
            case SyntaxKind.Identifier:
                if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {
                    return PredicateSemantics.Always;
                }
                return PredicateSemantics.Sometimes;
        }
        return PredicateSemantics.Never;
    }

    // Note that this and `checkBinaryExpression` above should behave mostly the same, except this elides some
    // expression-wide checks and does not use a work stack to fold nested binary expressions into the same callstack frame
    function checkBinaryLikeExpression(left: Expression, operatorToken: BinaryOperatorToken, right: Expression, checkMode?: CheckMode, errorNode?: Node): Type {
        const operator = operatorToken.kind;
        if (operator === SyntaxKind.EqualsToken && (left.kind === SyntaxKind.ObjectLiteralExpression || left.kind === SyntaxKind.ArrayLiteralExpression)) {
            return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind === SyntaxKind.ThisKeyword);
        }
        let leftType: Type;
        if (isBinaryLogicalOperator(operator)) {
            leftType = checkTruthinessExpression(left, checkMode);
        }
        else {
            leftType = checkExpression(left, checkMode);
        }

        const rightType = checkExpression(right, checkMode);
        return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode);
    }

    function checkBinaryLikeExpressionWorker(
        left: Expression,
        operatorToken: BinaryOperatorToken,
        right: Expression,
        leftType: Type,
        rightType: Type,
        checkMode?: CheckMode,
        errorNode?: Node,
    ): Type {
        const operator = operatorToken.kind;
        switch (operator) {
            case SyntaxKind.AsteriskToken:
            case SyntaxKind.AsteriskAsteriskToken:
            case SyntaxKind.AsteriskEqualsToken:
            case SyntaxKind.AsteriskAsteriskEqualsToken:
            case SyntaxKind.SlashToken:
            case SyntaxKind.SlashEqualsToken:
            case SyntaxKind.PercentToken:
            case SyntaxKind.PercentEqualsToken:
            case SyntaxKind.MinusToken:
            case SyntaxKind.MinusEqualsToken:
            case SyntaxKind.LessThanLessThanToken:
            case SyntaxKind.LessThanLessThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
            case SyntaxKind.BarToken:
            case SyntaxKind.BarEqualsToken:
            case SyntaxKind.CaretToken:
            case SyntaxKind.CaretEqualsToken:
            case SyntaxKind.AmpersandToken:
            case SyntaxKind.AmpersandEqualsToken:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }

                leftType = checkNonNullType(leftType, left);
                rightType = checkNonNullType(rightType, right);

                let suggestedOperator: PunctuationSyntaxKind | undefined;
                // if a user tries to apply a bitwise operator to 2 boolean operands
                // try and return them a helpful suggestion
                if (
                    (leftType.flags & TypeFlags.BooleanLike) &&
                    (rightType.flags & TypeFlags.BooleanLike) &&
                    (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined
                ) {
                    error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator));
                    return numberType;
                }
                else {
                    // otherwise just check each operand separately and report errors as normal
                    const leftOk = checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/ true);
                    const rightOk = checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/ true);
                    let resultType: Type;
                    // If both are any or unknown, allow operation; assume it will resolve to number
                    if (
                        (isTypeAssignableToKind(leftType, TypeFlags.AnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlags.AnyOrUnknown)) ||
                        // Or, if neither could be bigint, implicit coercion results in a number result
                        !(maybeTypeOfKind(leftType, TypeFlags.BigIntLike) || maybeTypeOfKind(rightType, TypeFlags.BigIntLike))
                    ) {
                        resultType = numberType;
                    }
                    // At least one is assignable to bigint, so check that both are
                    else if (bothAreBigIntLike(leftType, rightType)) {
                        switch (operator) {
                            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                                reportOperatorError();
                                break;
                            case SyntaxKind.AsteriskAsteriskToken:
                            case SyntaxKind.AsteriskAsteriskEqualsToken:
                                if (languageVersion < ScriptTarget.ES2016) {
                                    error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);
                                }
                        }
                        resultType = bigintType;
                    }
                    // Exactly one of leftType/rightType is assignable to bigint
                    else {
                        reportOperatorError(bothAreBigIntLike);
                        resultType = errorType;
                    }
                    if (leftOk && rightOk) {
                        checkAssignmentOperator(resultType);
                        switch (operator) {
                            case SyntaxKind.LessThanLessThanToken:
                            case SyntaxKind.LessThanLessThanEqualsToken:
                            case SyntaxKind.GreaterThanGreaterThanToken:
                            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                                const rhsEval = evaluate(right);
                                if (typeof rhsEval.value === "number" && Math.abs(rhsEval.value) >= 32) {
                                    errorOrSuggestion(
                                        isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), // elevate from suggestion to error within an enum member
                                        errorNode || operatorToken,
                                        Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2,
                                        getTextOfNode(left),
                                        tokenToString(operator),
                                        rhsEval.value % 32,
                                    );
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    return resultType;
                }
            case SyntaxKind.PlusToken:
            case SyntaxKind.PlusEqualsToken:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }

                if (!isTypeAssignableToKind(leftType, TypeFlags.StringLike) && !isTypeAssignableToKind(rightType, TypeFlags.StringLike)) {
                    leftType = checkNonNullType(leftType, left);
                    rightType = checkNonNullType(rightType, right);
                }

                let resultType: Type | undefined;
                if (isTypeAssignableToKind(leftType, TypeFlags.NumberLike, /*strict*/ true) && isTypeAssignableToKind(rightType, TypeFlags.NumberLike, /*strict*/ true)) {
                    // Operands of an enum type are treated as having the primitive type Number.
                    // If both operands are of the Number primitive type, the result is of the Number primitive type.
                    resultType = numberType;
                }
                else if (isTypeAssignableToKind(leftType, TypeFlags.BigIntLike, /*strict*/ true) && isTypeAssignableToKind(rightType, TypeFlags.BigIntLike, /*strict*/ true)) {
                    // If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.
                    resultType = bigintType;
                }
                else if (isTypeAssignableToKind(leftType, TypeFlags.StringLike, /*strict*/ true) || isTypeAssignableToKind(rightType, TypeFlags.StringLike, /*strict*/ true)) {
                    // If one or both operands are of the String primitive type, the result is of the String primitive type.
                    resultType = stringType;
                }
                else if (isTypeAny(leftType) || isTypeAny(rightType)) {
                    // Otherwise, the result is of type Any.
                    // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                    resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;
                }

                // Symbols are not allowed at all in arithmetic expressions
                if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
                    return resultType;
                }

                if (!resultType) {
                    // Types that have a reasonably good chance of being a valid operand type.
                    // If both types have an awaited type of one of these, we'll assume the user
                    // might be missing an await without doing an exhaustive check that inserting
                    // await(s) will actually be a completely valid binary expression.
                    const closeEnoughKind = TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.AnyOrUnknown;
                    reportOperatorError((left, right) =>
                        isTypeAssignableToKind(left, closeEnoughKind) &&
                        isTypeAssignableToKind(right, closeEnoughKind)
                    );
                    return anyType;
                }

                if (operator === SyntaxKind.PlusEqualsToken) {
                    checkAssignmentOperator(resultType);
                }
                return resultType;
            case SyntaxKind.LessThanToken:
            case SyntaxKind.GreaterThanToken:
            case SyntaxKind.LessThanEqualsToken:
            case SyntaxKind.GreaterThanEqualsToken:
                if (checkForDisallowedESSymbolOperand(operator)) {
                    leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left));
                    rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right));
                    reportOperatorErrorUnless((left, right) => {
                        if (isTypeAny(left) || isTypeAny(right)) {
                            return true;
                        }
                        const leftAssignableToNumber = isTypeAssignableTo(left, numberOrBigIntType);
                        const rightAssignableToNumber = isTypeAssignableTo(right, numberOrBigIntType);
                        return leftAssignableToNumber && rightAssignableToNumber ||
                            !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right);
                    });
                }
                return booleanType;
            case SyntaxKind.EqualsEqualsToken:
            case SyntaxKind.ExclamationEqualsToken:
            case SyntaxKind.EqualsEqualsEqualsToken:
            case SyntaxKind.ExclamationEqualsEqualsToken:
                // We suppress errors in CheckMode.TypeOnly (meaning the invocation came from getTypeOfExpression). During
                // control flow analysis it is possible for operands to temporarily have narrower types, and those narrower
                // types may cause the operands to not be comparable. We don't want such errors reported (see #46475).
                if (!(checkMode && checkMode & CheckMode.TypeOnly)) {
                    if (
                        (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) &&
                        // only report for === and !== in JS, not == or !=
                        (!isInJSFile(left) || (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken))
                    ) {
                        const eqType = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;
                        error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, eqType ? "false" : "true");
                    }
                    checkNaNEquality(errorNode, operator, left, right);
                    reportOperatorErrorUnless((left, right) => isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left));
                }
                return booleanType;
            case SyntaxKind.InstanceOfKeyword:
                return checkInstanceOfExpression(left, right, leftType, rightType, checkMode);
            case SyntaxKind.InKeyword:
                return checkInExpression(left, right, leftType, rightType);
            case SyntaxKind.AmpersandAmpersandToken:
            case SyntaxKind.AmpersandAmpersandEqualsToken: {
                const resultType = hasTypeFacts(leftType, TypeFacts.Truthy) ?
                    getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :
                    leftType;
                if (operator === SyntaxKind.AmpersandAmpersandEqualsToken) {
                    checkAssignmentOperator(rightType);
                }
                return resultType;
            }
            case SyntaxKind.BarBarToken:
            case SyntaxKind.BarBarEqualsToken: {
                const resultType = hasTypeFacts(leftType, TypeFacts.Falsy) ?
                    getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], UnionReduction.Subtype) :
                    leftType;
                if (operator === SyntaxKind.BarBarEqualsToken) {
                    checkAssignmentOperator(rightType);
                }
                return resultType;
            }
            case SyntaxKind.QuestionQuestionToken:
            case SyntaxKind.QuestionQuestionEqualsToken: {
                const resultType = hasTypeFacts(leftType, TypeFacts.EQUndefinedOrNull) ?
                    getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) :
                    leftType;
                if (operator === SyntaxKind.QuestionQuestionEqualsToken) {
                    checkAssignmentOperator(rightType);
                }
                return resultType;
            }
            case SyntaxKind.EqualsToken:
                const declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None;
                checkAssignmentDeclaration(declKind, rightType);
                if (isAssignmentDeclaration(declKind)) {
                    if (
                        !(rightType.flags & TypeFlags.Object) ||
                        declKind !== AssignmentDeclarationKind.ModuleExports &&
                            declKind !== AssignmentDeclarationKind.Prototype &&
                            !isEmptyObjectType(rightType) &&
                            !isFunctionObjectType(rightType as ObjectType) &&
                            !(getObjectFlags(rightType) & ObjectFlags.Class)
                    ) {
                        // don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete
                        checkAssignmentOperator(rightType);
                    }
                    return leftType;
                }
                else {
                    checkAssignmentOperator(rightType);
                    return rightType;
                }
            case SyntaxKind.CommaToken:
                if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent as BinaryExpression)) {
                    const sf = getSourceFileOfNode(left);
                    const sourceText = sf.text;
                    const start = skipTrivia(sourceText, left.pos);
                    const isInDiag2657 = sf.parseDiagnostics.some(diag => {
                        if (diag.code !== Diagnostics.JSX_expressions_must_have_one_parent_element.code) return false;
                        return textSpanContainsPosition(diag, start);
                    });
                    if (!isInDiag2657) error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
                }
                return rightType;

            default:
                return Debug.fail();
        }

        function bothAreBigIntLike(left: Type, right: Type): boolean {
            return isTypeAssignableToKind(left, TypeFlags.BigIntLike) && isTypeAssignableToKind(right, TypeFlags.BigIntLike);
        }

        function checkAssignmentDeclaration(kind: AssignmentDeclarationKind, rightType: Type) {
            if (kind === AssignmentDeclarationKind.ModuleExports) {
                for (const prop of getPropertiesOfObjectType(rightType)) {
                    const propType = getTypeOfSymbol(prop);
                    if (propType.symbol && propType.symbol.flags & SymbolFlags.Class) {
                        const name = prop.escapedName;
                        const symbol = resolveName(prop.valueDeclaration, name, SymbolFlags.Type, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
                        if (symbol?.declarations && symbol.declarations.some(isJSDocTypedefTag)) {
                            addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop);
                            addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol);
                        }
                    }
                }
            }
        }

        // Return true for "indirect calls", (i.e. `(0, x.f)(...)` or `(0, eval)(...)`), which prevents passing `this`.
        function isIndirectCall(node: BinaryExpression): boolean {
            return node.parent.kind === SyntaxKind.ParenthesizedExpression &&
                isNumericLiteral(node.left) &&
                node.left.text === "0" &&
                (isCallExpression(node.parent.parent) && node.parent.parent.expression === node.parent || node.parent.parent.kind === SyntaxKind.TaggedTemplateExpression) &&
                // special-case for "eval" because it's the only non-access case where an indirect call actually affects behavior.
                (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText === "eval");
        }

        // Return true if there was no error, false if there was an error.
        function checkForDisallowedESSymbolOperand(operator: PunctuationSyntaxKind): boolean {
            const offendingSymbolOperand = maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlags.ESSymbolLike) ? left :
                maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlags.ESSymbolLike) ? right :
                undefined;

            if (offendingSymbolOperand) {
                error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator));
                return false;
            }

            return true;
        }

        function getSuggestedBooleanOperator(operator: SyntaxKind): PunctuationSyntaxKind | undefined {
            switch (operator) {
                case SyntaxKind.BarToken:
                case SyntaxKind.BarEqualsToken:
                    return SyntaxKind.BarBarToken;
                case SyntaxKind.CaretToken:
                case SyntaxKind.CaretEqualsToken:
                    return SyntaxKind.ExclamationEqualsEqualsToken;
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AmpersandEqualsToken:
                    return SyntaxKind.AmpersandAmpersandToken;
                default:
                    return undefined;
            }
        }

        function checkAssignmentOperator(valueType: Type): void {
            if (isAssignmentOperator(operator)) {
                addLazyDiagnostic(checkAssignmentOperatorWorker);
            }

            function checkAssignmentOperatorWorker() {
                let assigneeType = leftType;

                // getters can be a subtype of setters, so to check for assignability we use the setter's type instead
                if (isCompoundAssignment(operatorToken.kind) && left.kind === SyntaxKind.PropertyAccessExpression) {
                    assigneeType = checkPropertyAccessExpression(left as PropertyAccessExpression, /*checkMode*/ undefined, /*writeOnly*/ true);
                }

                // TypeScript 1.0 spec (April 2014): 4.17
                // An assignment of the form
                //    VarExpr = ValueExpr
                // requires VarExpr to be classified as a reference
                // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
                // and the type of the non-compound operation to be assignable to the type of VarExpr.

                if (checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access)) {
                    let headMessage: DiagnosticMessage | undefined;
                    if (exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, TypeFlags.Undefined)) {
                        const target = getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.escapedText);
                        if (isExactOptionalPropertyMismatch(valueType, target)) {
                            headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target;
                        }
                    }
                    // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
                    checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage);
                }
            }
        }

        function isAssignmentDeclaration(kind: AssignmentDeclarationKind) {
            switch (kind) {
                case AssignmentDeclarationKind.ModuleExports:
                    return true;
                case AssignmentDeclarationKind.ExportsProperty:
                case AssignmentDeclarationKind.Property:
                case AssignmentDeclarationKind.Prototype:
                case AssignmentDeclarationKind.PrototypeProperty:
                case AssignmentDeclarationKind.ThisProperty:
                    const symbol = getSymbolOfNode(left);
                    const init = getAssignedExpandoInitializer(right);
                    return !!init && isObjectLiteralExpression(init) &&
                        !!symbol?.exports?.size;
                default:
                    return false;
            }
        }

        /**
         * Returns true if an error is reported
         */
        function reportOperatorErrorUnless(typesAreCompatible: (left: Type, right: Type) => boolean): boolean {
            if (!typesAreCompatible(leftType, rightType)) {
                reportOperatorError(typesAreCompatible);
                return true;
            }
            return false;
        }

        function reportOperatorError(isRelated?: (left: Type, right: Type) => boolean) {
            let wouldWorkWithAwait = false;
            const errNode = errorNode || operatorToken;
            if (isRelated) {
                const awaitedLeftType = getAwaitedTypeNoAlias(leftType);
                const awaitedRightType = getAwaitedTypeNoAlias(rightType);
                wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType)
                    && !!(awaitedLeftType && awaitedRightType)
                    && isRelated(awaitedLeftType, awaitedRightType);
            }

            let effectiveLeft = leftType;
            let effectiveRight = rightType;
            if (!wouldWorkWithAwait && isRelated) {
                [effectiveLeft, effectiveRight] = getBaseTypesIfUnrelated(leftType, rightType, isRelated);
            }
            const [leftStr, rightStr] = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight);
            if (!tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr)) {
                errorAndMaybeSuggestAwait(
                    errNode,
                    wouldWorkWithAwait,
                    Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2,
                    tokenToString(operatorToken.kind),
                    leftStr,
                    rightStr,
                );
            }
        }

        function tryGiveBetterPrimaryError(errNode: Node, maybeMissingAwait: boolean, leftStr: string, rightStr: string) {
            switch (operatorToken.kind) {
                case SyntaxKind.EqualsEqualsEqualsToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                    return errorAndMaybeSuggestAwait(
                        errNode,
                        maybeMissingAwait,
                        Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap,
                        leftStr,
                        rightStr,
                    );
                default:
                    return undefined;
            }
        }

        function checkNaNEquality(errorNode: Node | undefined, operator: SyntaxKind, left: Expression, right: Expression) {
            const isLeftNaN = isGlobalNaN(skipParentheses(left));
            const isRightNaN = isGlobalNaN(skipParentheses(right));
            if (isLeftNaN || isRightNaN) {
                const err = error(errorNode, Diagnostics.This_condition_will_always_return_0, tokenToString(operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.EqualsEqualsToken ? SyntaxKind.FalseKeyword : SyntaxKind.TrueKeyword));
                if (isLeftNaN && isRightNaN) return;
                const operatorString = operator === SyntaxKind.ExclamationEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? tokenToString(SyntaxKind.ExclamationToken) : "";
                const location = isLeftNaN ? right : left;
                const expression = skipParentheses(location);
                addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0, `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})`));
            }
        }

        function isGlobalNaN(expr: Expression): boolean {
            if (isIdentifier(expr) && expr.escapedText === "NaN") {
                const globalNaNSymbol = getGlobalNaNSymbol();
                return !!globalNaNSymbol && globalNaNSymbol === getResolvedSymbol(expr);
            }
            return false;
        }
    }

    function getBaseTypesIfUnrelated(leftType: Type, rightType: Type, isRelated: (left: Type, right: Type) => boolean): [Type, Type] {
        let effectiveLeft = leftType;
        let effectiveRight = rightType;
        const leftBase = getBaseTypeOfLiteralType(leftType);
        const rightBase = getBaseTypeOfLiteralType(rightType);
        if (!isRelated(leftBase, rightBase)) {
            effectiveLeft = leftBase;
            effectiveRight = rightBase;
        }
        return [effectiveLeft, effectiveRight];
    }

    function checkYieldExpression(node: YieldExpression): Type {
        addLazyDiagnostic(checkYieldExpressionGrammar);

        const func = getContainingFunction(node);
        if (!func) return anyType;
        const functionFlags = getFunctionFlags(func);

        if (!(functionFlags & FunctionFlags.Generator)) {
            // If the user's code is syntactically correct, the func should always have a star. After all, we are in a yield context.
            return anyType;
        }

        const isAsync = (functionFlags & FunctionFlags.Async) !== 0;
        if (node.asteriskToken) {
            // Async generator functions prior to ES2018 require the __await, __asyncDelegator,
            // and __asyncValues helpers
            if (isAsync && languageVersion < LanguageFeatureMinimumTarget.AsyncGenerators) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.AsyncDelegatorIncludes);
            }

            // Generator functions prior to ES2015 require the __values helper
            if (!isAsync && languageVersion < LanguageFeatureMinimumTarget.Generators && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.Values);
            }
        }

        // There is no point in doing an assignability check if the function
        // has no explicit return type because the return type is directly computed
        // from the yield expressions.
        let returnType = getReturnTypeFromAnnotation(func);
        if (returnType && returnType.flags & TypeFlags.Union) {
            returnType = filterType(returnType, t => checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, /*errorNode*/ undefined));
        }
        const iterationTypes = returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync);
        const signatureYieldType = iterationTypes && iterationTypes.yieldType || anyType;
        const signatureNextType = iterationTypes && iterationTypes.nextType || anyType;
        const yieldExpressionType = node.expression ? checkExpression(node.expression) : undefinedWideningType;
        const yieldedType = getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync);
        if (returnType && yieldedType) {
            checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression);
        }

        if (node.asteriskToken) {
            const use = isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar;
            return getIterationTypeOfIterable(use, IterationTypeKind.Return, yieldExpressionType, node.expression)
                || anyType;
        }
        else if (returnType) {
            return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Next, returnType, isAsync)
                || anyType;
        }
        let type = getContextualIterationType(IterationTypeKind.Next, func);
        if (!type) {
            type = anyType;
            addLazyDiagnostic(() => {
                if (noImplicitAny && !expressionResultIsUnused(node)) {
                    const contextualType = getContextualType(node, /*contextFlags*/ undefined);
                    if (!contextualType || isTypeAny(contextualType)) {
                        error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation);
                    }
                }
            });
        }
        return type;

        function checkYieldExpressionGrammar() {
            if (!(node.flags & NodeFlags.YieldContext)) {
                grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body);
            }

            if (isInParameterInitializerBeforeContainingFunction(node)) {
                error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer);
            }
        }
    }

    function checkConditionalExpression(node: ConditionalExpression, checkMode?: CheckMode): Type {
        const type = checkTruthinessExpression(node.condition, checkMode);
        checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type, node.whenTrue);
        const type1 = checkExpression(node.whenTrue, checkMode);
        const type2 = checkExpression(node.whenFalse, checkMode);
        return getUnionType([type1, type2], UnionReduction.Subtype);
    }

    function isTemplateLiteralContext(node: Node): boolean {
        const parent = node.parent;
        return isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) ||
            isElementAccessExpression(parent) && parent.argumentExpression === node;
    }

    function checkTemplateExpression(node: TemplateExpression): Type {
        const texts = [node.head.text];
        const types = [];
        for (const span of node.templateSpans) {
            const type = checkExpression(span.expression);
            if (maybeTypeOfKindConsideringBaseConstraint(type, TypeFlags.ESSymbolLike)) {
                error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String);
            }
            texts.push(span.literal.text);
            types.push(isTypeAssignableTo(type, templateConstraintType) ? type : stringType);
        }
        const evaluated = node.parent.kind !== SyntaxKind.TaggedTemplateExpression && evaluate(node).value;
        if (evaluated) {
            return getFreshTypeOfLiteralType(getStringLiteralType(evaluated));
        }
        if (isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node, /*contextFlags*/ undefined) || unknownType, isTemplateLiteralContextualType)) {
            return getTemplateLiteralType(texts, types);
        }
        return stringType;
    }

    function isTemplateLiteralContextualType(type: Type): boolean {
        return !!(type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral) ||
            type.flags & TypeFlags.InstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, TypeFlags.StringLike));
    }

    function getContextNode(node: Expression): Expression {
        if (isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent)) {
            return node.parent.parent; // Needs to be the root JsxElement, so it encompasses the attributes _and_ the children (which are essentially part of the attributes)
        }
        return node;
    }

    function checkExpressionWithContextualType(node: Expression, contextualType: Type, inferenceContext: InferenceContext | undefined, checkMode: CheckMode): Type {
        const contextNode = getContextNode(node);
        pushContextualType(contextNode, contextualType, /*isCache*/ false);
        pushInferenceContext(contextNode, inferenceContext);
        const type = checkExpression(node, checkMode | CheckMode.Contextual | (inferenceContext ? CheckMode.Inferential : 0));
        // In CheckMode.Inferential we collect intra-expression inference sites to process before fixing any type
        // parameters. This information is no longer needed after the call to checkExpression.
        if (inferenceContext && inferenceContext.intraExpressionInferenceSites) {
            inferenceContext.intraExpressionInferenceSites = undefined;
        }
        // We strip literal freshness when an appropriate contextual type is present such that contextually typed
        // literals always preserve their literal types (otherwise they might widen during type inference). An alternative
        // here would be to not mark contextually typed literals as fresh in the first place.
        const result = maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, /*contextFlags*/ undefined)) ?
            getRegularTypeOfLiteralType(type) : type;
        popInferenceContext();
        popContextualType();
        return result;
    }

    function checkExpressionCached(node: Expression | QualifiedName, checkMode?: CheckMode): Type {
        if (checkMode) {
            return checkExpression(node, checkMode);
        }
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            // When computing a type that we're going to cache, we need to ignore any ongoing control flow
            // analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
            // to the top of the stack ensures all transient types are computed from a known point.
            const saveFlowLoopStart = flowLoopStart;
            const saveFlowTypeCache = flowTypeCache;
            flowLoopStart = flowLoopCount;
            flowTypeCache = undefined;
            links.resolvedType = checkExpression(node, checkMode);
            flowTypeCache = saveFlowTypeCache;
            flowLoopStart = saveFlowLoopStart;
        }
        return links.resolvedType;
    }

    function isTypeAssertion(node: Expression) {
        node = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        return node.kind === SyntaxKind.TypeAssertionExpression ||
            node.kind === SyntaxKind.AsExpression ||
            isJSDocTypeAssertion(node);
    }

    function checkDeclarationInitializer(
        declaration: HasExpressionInitializer,
        checkMode: CheckMode,
        contextualType?: Type | undefined,
    ) {
        const initializer = getEffectiveInitializer(declaration)!;
        if (isInJSFile(declaration)) {
            const typeNode = tryGetJSDocSatisfiesTypeNode(declaration);
            if (typeNode) {
                return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode);
            }
        }
        const type = getQuickTypeOfExpression(initializer) || (contextualType ?
            checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext*/ undefined, checkMode || CheckMode.Normal) :
            checkExpressionCached(initializer, checkMode));
        if (isParameter(isBindingElement(declaration) ? walkUpBindingElementsAndPatterns(declaration) : declaration)) {
            if (declaration.name.kind === SyntaxKind.ObjectBindingPattern && isObjectLiteralType(type)) {
                return padObjectLiteralType(type as ObjectType, declaration.name);
            }
            if (declaration.name.kind === SyntaxKind.ArrayBindingPattern && isTupleType(type)) {
                return padTupleType(type, declaration.name);
            }
        }
        return type;
    }

    function padObjectLiteralType(type: ObjectType, pattern: ObjectBindingPattern): Type {
        let missingElements: BindingElement[] | undefined;
        for (const e of pattern.elements) {
            if (e.initializer) {
                const name = getPropertyNameFromBindingElement(e);
                if (name && !getPropertyOfType(type, name)) {
                    missingElements = append(missingElements, e);
                }
            }
        }
        if (!missingElements) {
            return type;
        }
        const members = createSymbolTable();
        for (const prop of getPropertiesOfObjectType(type)) {
            members.set(prop.escapedName, prop);
        }
        for (const e of missingElements) {
            const symbol = createSymbol(SymbolFlags.Property | SymbolFlags.Optional, getPropertyNameFromBindingElement(e)!);
            symbol.links.type = getTypeFromBindingElement(e, /*includePatternInType*/ false, /*reportErrors*/ false);
            members.set(symbol.escapedName, symbol);
        }
        const result = createAnonymousType(type.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type));
        result.objectFlags = type.objectFlags;
        return result;
    }

    function getPropertyNameFromBindingElement(e: BindingElement) {
        const exprType = getLiteralTypeFromPropertyName(e.propertyName || e.name as Identifier);
        return isTypeUsableAsPropertyName(exprType) ? getPropertyNameFromType(exprType) : undefined;
    }

    function padTupleType(type: TupleTypeReference, pattern: ArrayBindingPattern) {
        if (type.target.combinedFlags & ElementFlags.Variable || getTypeReferenceArity(type) >= pattern.elements.length) {
            return type;
        }
        const patternElements = pattern.elements;
        const elementTypes = getElementTypes(type).slice();
        const elementFlags = type.target.elementFlags.slice();
        for (let i = getTypeReferenceArity(type); i < patternElements.length; i++) {
            const e = patternElements[i];
            if (i < patternElements.length - 1 || !(e.kind === SyntaxKind.BindingElement && e.dotDotDotToken)) {
                elementTypes.push(!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, /*includePatternInType*/ false, /*reportErrors*/ false) : anyType);
                elementFlags.push(ElementFlags.Optional);
                if (!isOmittedExpression(e) && !hasDefaultValue(e)) {
                    reportImplicitAny(e, anyType);
                }
            }
        }
        return createTupleType(elementTypes, elementFlags, type.target.readonly);
    }

    function widenTypeInferredFromInitializer(declaration: HasExpressionInitializer, type: Type) {
        const widened = getWidenedLiteralTypeForInitializer(declaration, type);
        if (isInJSFile(declaration)) {
            if (isEmptyLiteralType(widened)) {
                reportImplicitAny(declaration, anyType);
                return anyType;
            }
            else if (isEmptyArrayLiteralType(widened)) {
                reportImplicitAny(declaration, anyArrayType);
                return anyArrayType;
            }
        }
        return widened;
    }

    function getWidenedLiteralTypeForInitializer(declaration: HasExpressionInitializer, type: Type) {
        return getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type);
    }

    function isLiteralOfContextualType(candidateType: Type, contextualType: Type | undefined): boolean {
        if (contextualType) {
            if (contextualType.flags & TypeFlags.UnionOrIntersection) {
                const types = (contextualType as UnionType).types;
                return some(types, t => isLiteralOfContextualType(candidateType, t));
            }
            if (contextualType.flags & TypeFlags.InstantiableNonPrimitive) {
                // If the contextual type is a type variable constrained to a primitive type, consider
                // this a literal context for literals of that primitive type. For example, given a
                // type parameter 'T extends string', infer string literal types for T.
                const constraint = getBaseConstraintOfType(contextualType) || unknownType;
                return maybeTypeOfKind(constraint, TypeFlags.String) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral) ||
                    maybeTypeOfKind(constraint, TypeFlags.Number) && maybeTypeOfKind(candidateType, TypeFlags.NumberLiteral) ||
                    maybeTypeOfKind(constraint, TypeFlags.BigInt) && maybeTypeOfKind(candidateType, TypeFlags.BigIntLiteral) ||
                    maybeTypeOfKind(constraint, TypeFlags.ESSymbol) && maybeTypeOfKind(candidateType, TypeFlags.UniqueESSymbol) ||
                    isLiteralOfContextualType(candidateType, constraint);
            }
            // If the contextual type is a literal of a particular primitive type, we consider this a
            // literal context for all literals of that primitive type.
            return !!(contextualType.flags & (TypeFlags.StringLiteral | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral) ||
                contextualType.flags & TypeFlags.NumberLiteral && maybeTypeOfKind(candidateType, TypeFlags.NumberLiteral) ||
                contextualType.flags & TypeFlags.BigIntLiteral && maybeTypeOfKind(candidateType, TypeFlags.BigIntLiteral) ||
                contextualType.flags & TypeFlags.BooleanLiteral && maybeTypeOfKind(candidateType, TypeFlags.BooleanLiteral) ||
                contextualType.flags & TypeFlags.UniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlags.UniqueESSymbol));
        }
        return false;
    }

    function isConstContext(node: Expression): boolean {
        const parent = node.parent;
        return isAssertionExpression(parent) && isConstTypeReference(parent.type) ||
            isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) ||
            isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node, ContextFlags.None)) ||
            (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(parent) ||
            (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && isConstContext(parent.parent);
    }

    function checkExpressionForMutableLocation(node: Expression, checkMode: CheckMode | undefined, forceTuple?: boolean): Type {
        const type = checkExpression(node, checkMode, forceTuple);
        return isConstContext(node) || isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) :
            isTypeAssertion(node) ? type :
            getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(getContextualType(node, /*contextFlags*/ undefined), node, /*contextFlags*/ undefined));
    }

    function checkPropertyAssignment(node: PropertyAssignment, checkMode?: CheckMode): Type {
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name.kind === SyntaxKind.ComputedPropertyName) {
            checkComputedPropertyName(node.name);
        }

        return checkExpressionForMutableLocation(node.initializer, checkMode);
    }

    function checkObjectLiteralMethod(node: MethodDeclaration, checkMode?: CheckMode): Type {
        // Grammar checking
        checkGrammarMethod(node);

        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name.kind === SyntaxKind.ComputedPropertyName) {
            checkComputedPropertyName(node.name);
        }

        const uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
        return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
    }

    function instantiateTypeWithSingleGenericCallSignature(node: Expression | MethodDeclaration | QualifiedName, type: Type, checkMode?: CheckMode) {
        if (checkMode && checkMode & (CheckMode.Inferential | CheckMode.SkipGenericFunctions)) {
            const callSignature = getSingleSignature(type, SignatureKind.Call, /*allowMembers*/ true);
            const constructSignature = getSingleSignature(type, SignatureKind.Construct, /*allowMembers*/ true);
            const signature = callSignature || constructSignature;
            if (signature && signature.typeParameters) {
                const contextualType = getApparentTypeOfContextualType(node as Expression, ContextFlags.NoConstraints);
                if (contextualType) {
                    const contextualSignature = getSingleSignature(getNonNullableType(contextualType), callSignature ? SignatureKind.Call : SignatureKind.Construct, /*allowMembers*/ false);
                    if (contextualSignature && !contextualSignature.typeParameters) {
                        if (checkMode & CheckMode.SkipGenericFunctions) {
                            skippedGenericFunction(node, checkMode);
                            return anyFunctionType;
                        }
                        const context = getInferenceContext(node)!;
                        // We have an expression that is an argument of a generic function for which we are performing
                        // type argument inference. The expression is of a function type with a single generic call
                        // signature and a contextual function type with a single non-generic call signature. Now check
                        // if the outer function returns a function type with a single non-generic call signature and
                        // if some of the outer function type parameters have no inferences so far. If so, we can
                        // potentially add inferred type parameters to the outer function return type.
                        const returnType = context.signature && getReturnTypeOfSignature(context.signature);
                        const returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
                        if (returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates)) {
                            // Instantiate the signature with its own type parameters as type arguments, possibly
                            // renaming the type parameters to ensure they have unique names.
                            const uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
                            const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
                            // Infer from the parameters of the instantiated signature to the parameters of the
                            // contextual signature starting with an empty set of inference candidates.
                            const inferences = map(context.inferences, info => createInferenceInfo(info.typeParameter));
                            applyToParameterTypes(instantiatedSignature, contextualSignature, (source, target) => {
                                inferTypes(inferences, source, target, /*priority*/ 0, /*contravariant*/ true);
                            });
                            if (some(inferences, hasInferenceCandidates)) {
                                // We have inference candidates, indicating that one or more type parameters are referenced
                                // in the parameter types of the contextual signature. Now also infer from the return type.
                                applyToReturnTypes(instantiatedSignature, contextualSignature, (source, target) => {
                                    inferTypes(inferences, source, target);
                                });
                                // If the type parameters for which we produced candidates do not have any inferences yet,
                                // we adopt the new inference candidates and add the type parameters of the expression type
                                // to the set of inferred type parameters for the outer function return type.
                                if (!hasOverlappingInferences(context.inferences, inferences)) {
                                    mergeInferences(context.inferences, inferences);
                                    context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                                    return getOrCreateTypeFromSignature(instantiatedSignature);
                                }
                            }
                        }
                        return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context));
                    }
                }
            }
        }
        return type;
    }

    function skippedGenericFunction(node: Node, checkMode: CheckMode) {
        if (checkMode & CheckMode.Inferential) {
            // We have skipped a generic function during inferential typing. Obtain the inference context and
            // indicate this has occurred such that we know a second pass of inference is be needed.
            const context = getInferenceContext(node)!;
            context.flags |= InferenceFlags.SkippedGenericFunction;
        }
    }

    function hasInferenceCandidates(info: InferenceInfo) {
        return !!(info.candidates || info.contraCandidates);
    }

    function hasInferenceCandidatesOrDefault(info: InferenceInfo) {
        return !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter));
    }

    function hasOverlappingInferences(a: InferenceInfo[], b: InferenceInfo[]) {
        for (let i = 0; i < a.length; i++) {
            if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {
                return true;
            }
        }
        return false;
    }

    function mergeInferences(target: InferenceInfo[], source: InferenceInfo[]) {
        for (let i = 0; i < target.length; i++) {
            if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {
                target[i] = source[i];
            }
        }
    }

    function getUniqueTypeParameters(context: InferenceContext, typeParameters: readonly TypeParameter[]): readonly TypeParameter[] {
        const result: TypeParameter[] = [];
        let oldTypeParameters: TypeParameter[] | undefined;
        let newTypeParameters: TypeParameter[] | undefined;
        for (const tp of typeParameters) {
            const name = tp.symbol.escapedName;
            if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {
                const newName = getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name);
                const symbol = createSymbol(SymbolFlags.TypeParameter, newName);
                const newTypeParameter = createTypeParameter(symbol);
                newTypeParameter.target = tp;
                oldTypeParameters = append(oldTypeParameters, tp);
                newTypeParameters = append(newTypeParameters, newTypeParameter);
                result.push(newTypeParameter);
            }
            else {
                result.push(tp);
            }
        }
        if (newTypeParameters) {
            const mapper = createTypeMapper(oldTypeParameters!, newTypeParameters);
            for (const tp of newTypeParameters) {
                tp.mapper = mapper;
            }
        }
        return result;
    }

    function hasTypeParameterByName(typeParameters: readonly TypeParameter[] | undefined, name: __String) {
        return some(typeParameters, tp => tp.symbol.escapedName === name);
    }

    function getUniqueTypeParameterName(typeParameters: readonly TypeParameter[], baseName: __String) {
        let len = (baseName as string).length;
        while (len > 1 && (baseName as string).charCodeAt(len - 1) >= CharacterCodes._0 && (baseName as string).charCodeAt(len - 1) <= CharacterCodes._9) len--;
        const s = (baseName as string).slice(0, len);
        for (let index = 1; true; index++) {
            const augmentedName = s + index as __String;
            if (!hasTypeParameterByName(typeParameters, augmentedName)) {
                return augmentedName;
            }
        }
    }

    function getReturnTypeOfSingleNonGenericCallSignature(funcType: Type) {
        const signature = getSingleCallSignature(funcType);
        if (signature && !signature.typeParameters) {
            return getReturnTypeOfSignature(signature);
        }
    }

    function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr: CallChain) {
        const funcType = checkExpression(expr.expression);
        const nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
        const returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
        return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType);
    }

    /**
     * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
     * with computing the type and may not fully check all contained sub-expressions for errors.
     */
    function getTypeOfExpression(node: Expression) {
        // Don't bother caching types that require no flow analysis and are quick to compute.
        const quickType = getQuickTypeOfExpression(node);
        if (quickType) {
            return quickType;
        }
        // If a type has been cached for the node, return it.
        if (node.flags & NodeFlags.TypeCached && flowTypeCache) {
            const cachedType = flowTypeCache[getNodeId(node)];
            if (cachedType) {
                return cachedType;
            }
        }
        const startInvocationCount = flowInvocationCount;
        const type = checkExpression(node, CheckMode.TypeOnly);
        // If control flow analysis was required to determine the type, it is worth caching.
        if (flowInvocationCount !== startInvocationCount) {
            const cache = flowTypeCache || (flowTypeCache = []);
            cache[getNodeId(node)] = type;
            setNodeFlags(node, node.flags | NodeFlags.TypeCached);
        }
        return type;
    }

    function getQuickTypeOfExpression(node: Expression): Type | undefined {
        let expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        if (isJSDocTypeAssertion(expr)) {
            const type = getJSDocTypeAssertionType(expr);
            if (!isConstTypeReference(type)) {
                return getTypeFromTypeNode(type);
            }
        }
        expr = skipParentheses(node);
        if (isAwaitExpression(expr)) {
            const type = getQuickTypeOfExpression(expr.expression);
            return type ? getAwaitedType(type) : undefined;
        }
        // Optimize for the common case of a call to a function with a single non-generic call
        // signature where we can just fetch the return type without checking the arguments.
        if (isCallExpression(expr) && expr.expression.kind !== SyntaxKind.SuperKeyword && !isRequireCall(expr, /*requireStringLiteralLikeArgument*/ true) && !isSymbolOrSymbolForCall(expr) && !isImportCall(expr)) {
            return isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :
                getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression));
        }
        else if (isAssertionExpression(expr) && !isConstTypeReference(expr.type)) {
            return getTypeFromTypeNode((expr as TypeAssertion).type);
        }
        else if (isLiteralExpression(node) || isBooleanLiteral(node)) {
            return checkExpression(node);
        }
        return undefined;
    }

    /**
     * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
     * with computing the type and may not fully check all contained sub-expressions for errors.
     * It is intended for uses where you know there is no contextual type,
     * and requesting the contextual type might cause a circularity or other bad behaviour.
     * It sets the contextual type of the node to any before calling getTypeOfExpression.
     */
    function getContextFreeTypeOfExpression(node: Expression) {
        const links = getNodeLinks(node);
        if (links.contextFreeType) {
            return links.contextFreeType;
        }
        pushContextualType(node, anyType, /*isCache*/ false);
        const type = links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive);
        popContextualType();
        return type;
    }

    function checkExpression(node: Expression | QualifiedName, checkMode?: CheckMode, forceTuple?: boolean): Type {
        tracing?.push(tracing.Phase.Check, "checkExpression", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath });
        const saveCurrentNode = currentNode;
        currentNode = node;
        instantiationCount = 0;
        const uninstantiatedType = checkExpressionWorker(node, checkMode, forceTuple);
        const type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        if (isConstEnumObjectType(type)) {
            checkConstEnumAccess(node, type);
        }
        currentNode = saveCurrentNode;
        tracing?.pop();
        return type;
    }

    function checkConstEnumAccess(node: Expression | QualifiedName, type: Type) {
        // enum object type for const enums are only permitted in:
        // - 'left' in property access
        // - 'object' in indexed access
        // - target in rhs of import statement
        const ok = (node.parent.kind === SyntaxKind.PropertyAccessExpression && (node.parent as PropertyAccessExpression).expression === node) ||
            (node.parent.kind === SyntaxKind.ElementAccessExpression && (node.parent as ElementAccessExpression).expression === node) ||
            ((node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.QualifiedName) && isInRightSideOfImportOrExportAssignment(node as Identifier) ||
                (node.parent.kind === SyntaxKind.TypeQuery && (node.parent as TypeQueryNode).exprName === node)) ||
            (node.parent.kind === SyntaxKind.ExportSpecifier); // We allow reexporting const enums

        if (!ok) {
            error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query);
        }

        // --verbatimModuleSyntax only gets checked here when the enum usage does not
        // resolve to an import, because imports of ambient const enums get checked
        // separately in `checkAliasSymbol`.
        if (
            compilerOptions.isolatedModules
            || compilerOptions.verbatimModuleSyntax
                && ok
                && !resolveName(
                    node,
                    getFirstIdentifier(node as EntityNameOrEntityNameExpression),
                    SymbolFlags.Alias,
                    /*nameNotFoundMessage*/ undefined,
                    /*isUse*/ false,
                    /*excludeGlobals*/ true,
                )
        ) {
            Debug.assert(!!(type.symbol.flags & SymbolFlags.ConstEnum));
            const constEnumDeclaration = type.symbol.valueDeclaration as EnumDeclaration;
            const redirect = host.getRedirectFromOutput(getSourceFileOfNode(constEnumDeclaration).resolvedPath)?.resolvedRef;
            if (constEnumDeclaration.flags & NodeFlags.Ambient && !isValidTypeOnlyAliasUseSite(node) && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options))) {
                error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName);
            }
        }
    }

    function checkParenthesizedExpression(node: ParenthesizedExpression, checkMode?: CheckMode): Type {
        if (hasJSDocNodes(node)) {
            if (isJSDocSatisfiesExpression(node)) {
                return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode);
            }
            if (isJSDocTypeAssertion(node)) {
                return checkAssertionWorker(node, checkMode);
            }
        }
        return checkExpression(node.expression, checkMode);
    }

    function checkExpressionWorker(node: Expression | QualifiedName, checkMode: CheckMode | undefined, forceTuple?: boolean): Type {
        const kind = node.kind;
        if (cancellationToken) {
            // Only bother checking on a few construct kinds.  We don't want to be excessively
            // hitting the cancellation token on every node we check.
            switch (kind) {
                case SyntaxKind.ClassExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.ArrowFunction:
                    cancellationToken.throwIfCancellationRequested();
            }
        }
        switch (kind) {
            case SyntaxKind.Identifier:
                return checkIdentifier(node as Identifier, checkMode);
            case SyntaxKind.PrivateIdentifier:
                return checkPrivateIdentifierExpression(node as PrivateIdentifier);
            case SyntaxKind.ThisKeyword:
                return checkThisExpression(node);
            case SyntaxKind.SuperKeyword:
                return checkSuperExpression(node);
            case SyntaxKind.NullKeyword:
                return nullWideningType;
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.StringLiteral:
                return hasSkipDirectInferenceFlag(node) ?
                    blockedStringType :
                    getFreshTypeOfLiteralType(getStringLiteralType((node as StringLiteralLike).text));
            case SyntaxKind.NumericLiteral:
                checkGrammarNumericLiteral(node as NumericLiteral);
                return getFreshTypeOfLiteralType(getNumberLiteralType(+(node as NumericLiteral).text));
            case SyntaxKind.BigIntLiteral:
                checkGrammarBigIntLiteral(node as BigIntLiteral);
                return getFreshTypeOfLiteralType(getBigIntLiteralType({
                    negative: false,
                    base10Value: parsePseudoBigInt((node as BigIntLiteral).text),
                }));
            case SyntaxKind.TrueKeyword:
                return trueType;
            case SyntaxKind.FalseKeyword:
                return falseType;
            case SyntaxKind.TemplateExpression:
                return checkTemplateExpression(node as TemplateExpression);
            case SyntaxKind.RegularExpressionLiteral:
                return checkRegularExpressionLiteral(node as RegularExpressionLiteral);
            case SyntaxKind.ArrayLiteralExpression:
                return checkArrayLiteral(node as ArrayLiteralExpression, checkMode, forceTuple);
            case SyntaxKind.ObjectLiteralExpression:
                return checkObjectLiteral(node as ObjectLiteralExpression, checkMode);
            case SyntaxKind.PropertyAccessExpression:
                return checkPropertyAccessExpression(node as PropertyAccessExpression, checkMode);
            case SyntaxKind.QualifiedName:
                return checkQualifiedName(node as QualifiedName, checkMode);
            case SyntaxKind.ElementAccessExpression:
                return checkIndexedAccess(node as ElementAccessExpression, checkMode);
            case SyntaxKind.CallExpression:
                if (isImportCall(node)) {
                    return checkImportCallExpression(node);
                }
                // falls through
            case SyntaxKind.NewExpression:
                return checkCallExpression(node as CallExpression, checkMode);
            case SyntaxKind.TaggedTemplateExpression:
                return checkTaggedTemplateExpression(node as TaggedTemplateExpression);
            case SyntaxKind.ParenthesizedExpression:
                return checkParenthesizedExpression(node as ParenthesizedExpression, checkMode);
            case SyntaxKind.ClassExpression:
                return checkClassExpression(node as ClassExpression);
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
                return checkFunctionExpressionOrObjectLiteralMethod(node as FunctionExpression | ArrowFunction, checkMode);
            case SyntaxKind.TypeOfExpression:
                return checkTypeOfExpression(node as TypeOfExpression);
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.AsExpression:
                return checkAssertion(node as AssertionExpression, checkMode);
            case SyntaxKind.NonNullExpression:
                return checkNonNullAssertion(node as NonNullExpression);
            case SyntaxKind.ExpressionWithTypeArguments:
                return checkExpressionWithTypeArguments(node as ExpressionWithTypeArguments);
            case SyntaxKind.SatisfiesExpression:
                return checkSatisfiesExpression(node as SatisfiesExpression);
            case SyntaxKind.MetaProperty:
                return checkMetaProperty(node as MetaProperty);
            case SyntaxKind.DeleteExpression:
                return checkDeleteExpression(node as DeleteExpression);
            case SyntaxKind.VoidExpression:
                return checkVoidExpression(node as VoidExpression);
            case SyntaxKind.AwaitExpression:
                return checkAwaitExpression(node as AwaitExpression);
            case SyntaxKind.PrefixUnaryExpression:
                return checkPrefixUnaryExpression(node as PrefixUnaryExpression);
            case SyntaxKind.PostfixUnaryExpression:
                return checkPostfixUnaryExpression(node as PostfixUnaryExpression);
            case SyntaxKind.BinaryExpression:
                return checkBinaryExpression(node as BinaryExpression, checkMode);
            case SyntaxKind.ConditionalExpression:
                return checkConditionalExpression(node as ConditionalExpression, checkMode);
            case SyntaxKind.SpreadElement:
                return checkSpreadExpression(node as SpreadElement, checkMode);
            case SyntaxKind.OmittedExpression:
                return undefinedWideningType;
            case SyntaxKind.YieldExpression:
                return checkYieldExpression(node as YieldExpression);
            case SyntaxKind.SyntheticExpression:
                return checkSyntheticExpression(node as SyntheticExpression);
            case SyntaxKind.JsxExpression:
                return checkJsxExpression(node as JsxExpression, checkMode);
            case SyntaxKind.JsxElement:
                return checkJsxElement(node as JsxElement, checkMode);
            case SyntaxKind.JsxSelfClosingElement:
                return checkJsxSelfClosingElement(node as JsxSelfClosingElement, checkMode);
            case SyntaxKind.JsxFragment:
                return checkJsxFragment(node as JsxFragment);
            case SyntaxKind.JsxAttributes:
                return checkJsxAttributes(node as JsxAttributes, checkMode);
            case SyntaxKind.JsxOpeningElement:
                Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
        }
        return errorType;
    }

    // DECLARATION AND STATEMENT TYPE CHECKING

    function checkTypeParameter(node: TypeParameterDeclaration) {
        // Grammar Checking
        checkGrammarModifiers(node);
        if (node.expression) {
            grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected);
        }

        checkSourceElement(node.constraint);
        checkSourceElement(node.default);
        const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
        // Resolve base constraint to reveal circularity errors
        getBaseConstraintOfType(typeParameter);
        if (!hasNonCircularTypeParameterDefault(typeParameter)) {
            error(node.default, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
        }
        const constraintType = getConstraintOfTypeParameter(typeParameter);
        const defaultType = getDefaultFromTypeParameter(typeParameter);
        if (constraintType && defaultType) {
            checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default, Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
        }
        checkNodeDeferred(node);
        addLazyDiagnostic(() => checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0));
    }

    function checkTypeParameterDeferred(node: TypeParameterDeclaration) {
        if (isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent)) {
            const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
            const modifiers = getTypeParameterModifiers(typeParameter) & (ModifierFlags.In | ModifierFlags.Out);
            if (modifiers) {
                const symbol = getSymbolOfDeclaration(node.parent);
                if (isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlags.Anonymous | ObjectFlags.Mapped))) {
                    error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types);
                }
                else if (modifiers === ModifierFlags.In || modifiers === ModifierFlags.Out) {
                    tracing?.push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred", { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) });
                    const source = createMarkerType(symbol, typeParameter, modifiers === ModifierFlags.Out ? markerSubTypeForCheck : markerSuperTypeForCheck);
                    const target = createMarkerType(symbol, typeParameter, modifiers === ModifierFlags.Out ? markerSuperTypeForCheck : markerSubTypeForCheck);
                    const saveVarianceTypeParameter = typeParameter;
                    varianceTypeParameter = typeParameter;
                    checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation);
                    varianceTypeParameter = saveVarianceTypeParameter;
                    tracing?.pop();
                }
            }
        }
    }

    function checkParameter(node: ParameterDeclaration) {
        // Grammar checking
        // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
        // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
        // or if its FunctionBody is strict code(11.1.5).
        checkGrammarModifiers(node);

        checkVariableLikeDeclaration(node);
        const func = getContainingFunction(node)!;
        if (hasSyntacticModifier(node, ModifierFlags.ParameterPropertyModifier)) {
            if (compilerOptions.erasableSyntaxOnly) {
                error(node, Diagnostics.This_syntax_is_not_allowed_when_erasableSyntaxOnly_is_enabled);
            }
            if (!(func.kind === SyntaxKind.Constructor && nodeIsPresent(func.body))) {
                error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
            }
            if (func.kind === SyntaxKind.Constructor && isIdentifier(node.name) && node.name.escapedText === "constructor") {
                error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name);
            }
        }
        if (!node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && (func as FunctionLikeDeclaration).body) {
            error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
        }
        if (node.name && isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new")) {
            if (func.parameters.indexOf(node) !== 0) {
                error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText as string);
            }
            if (func.kind === SyntaxKind.Constructor || func.kind === SyntaxKind.ConstructSignature || func.kind === SyntaxKind.ConstructorType) {
                error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter);
            }
            if (func.kind === SyntaxKind.ArrowFunction) {
                error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter);
            }
            if (func.kind === SyntaxKind.GetAccessor || func.kind === SyntaxKind.SetAccessor) {
                error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters);
            }
        }

        // Only check rest parameter type if it's not a binding pattern. Since binding patterns are
        // not allowed in a rest parameter, we already have an error from checkGrammarParameterList.
        if (node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType)) {
            error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type);
        }
    }

    function checkTypePredicate(node: TypePredicateNode): void {
        const parent = getTypePredicateParent(node);
        if (!parent) {
            // The parent must not be valid.
            error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
            return;
        }

        const signature = getSignatureFromDeclaration(parent);
        const typePredicate = getTypePredicateOfSignature(signature);
        if (!typePredicate) {
            return;
        }

        checkSourceElement(node.type);

        const { parameterName } = node;
        if (typePredicate.kind !== TypePredicateKind.This && typePredicate.kind !== TypePredicateKind.AssertsThis) {
            if (typePredicate.parameterIndex >= 0) {
                if (signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1) {
                    error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
                }
                else {
                    if (typePredicate.type) {
                        const leadingError = () => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type);
                        checkTypeAssignableTo(typePredicate.type, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type, /*headMessage*/ undefined, leadingError);
                    }
                }
            }
            else if (parameterName) {
                let hasReportedError = false;
                for (const { name } of parent.parameters) {
                    if (
                        isBindingPattern(name) &&
                        checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)
                    ) {
                        hasReportedError = true;
                        break;
                    }
                }
                if (!hasReportedError) {
                    error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
                }
            }
        }
    }

    function getTypePredicateParent(node: Node): SignatureDeclaration | undefined {
        switch (node.parent.kind) {
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.CallSignature:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.FunctionType:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.MethodSignature:
                const parent = node.parent as SignatureDeclaration;
                if (node === parent.type) {
                    return parent;
                }
        }
    }

    function checkIfTypePredicateVariableIsDeclaredInBindingPattern(
        pattern: BindingPattern,
        predicateVariableNode: Node,
        predicateVariableName: string,
    ) {
        for (const element of pattern.elements) {
            if (isOmittedExpression(element)) {
                continue;
            }

            const name = element.name;
            if (name.kind === SyntaxKind.Identifier && name.escapedText === predicateVariableName) {
                error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
                return true;
            }
            else if (name.kind === SyntaxKind.ArrayBindingPattern || name.kind === SyntaxKind.ObjectBindingPattern) {
                if (
                    checkIfTypePredicateVariableIsDeclaredInBindingPattern(
                        name,
                        predicateVariableNode,
                        predicateVariableName,
                    )
                ) {
                    return true;
                }
            }
        }
    }

    function checkSignatureDeclaration(node: SignatureDeclaration) {
        // Grammar checking
        if (node.kind === SyntaxKind.IndexSignature) {
            checkGrammarIndexSignature(node);
        }
        // TODO (yuisu): Remove this check in else-if when SyntaxKind.Construct is moved and ambient context is handled
        else if (
            node.kind === SyntaxKind.FunctionType || node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.ConstructorType ||
            node.kind === SyntaxKind.CallSignature || node.kind === SyntaxKind.Constructor ||
            node.kind === SyntaxKind.ConstructSignature
        ) {
            checkGrammarFunctionLikeDeclaration(node as FunctionLikeDeclaration);
        }

        const functionFlags = getFunctionFlags(node as FunctionLikeDeclaration);
        if (!(functionFlags & FunctionFlags.Invalid)) {
            // Async generators prior to ES2018 require the __await and __asyncGenerator helpers
            if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.AsyncGenerator && languageVersion < LanguageFeatureMinimumTarget.AsyncGenerators) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.AsyncGeneratorIncludes);
            }

            // Async functions prior to ES2017 require the __awaiter helper
            if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async && languageVersion < LanguageFeatureMinimumTarget.AsyncFunctions) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.Awaiter);
            }

            // Generator functions, Async functions, and Async Generator functions prior to
            // ES2015 require the __generator helper
            if ((functionFlags & FunctionFlags.AsyncGenerator) !== FunctionFlags.Normal && languageVersion < LanguageFeatureMinimumTarget.Generators) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.Generator);
            }
        }

        checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
        checkUnmatchedJSDocParameters(node);

        forEach(node.parameters, checkParameter);

        // TODO(rbuckton): Should we start checking JSDoc types?
        if (node.type) {
            checkSourceElement(node.type);
        }

        addLazyDiagnostic(checkSignatureDeclarationDiagnostics);

        function checkSignatureDeclarationDiagnostics() {
            checkCollisionWithArgumentsInGeneratedCode(node);

            let returnTypeNode = getEffectiveReturnTypeNode(node);
            let returnTypeErrorLocation = returnTypeNode;

            if (isInJSFile(node)) {
                const typeTag = getJSDocTypeTag(node);
                if (typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type)) {
                    const signature = getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
                    if (signature && signature.declaration) {
                        returnTypeNode = getEffectiveReturnTypeNode(signature.declaration);
                        returnTypeErrorLocation = typeTag.typeExpression.type;
                    }
                }
            }

            if (noImplicitAny && !returnTypeNode) {
                switch (node.kind) {
                    case SyntaxKind.ConstructSignature:
                        error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                        break;
                    case SyntaxKind.CallSignature:
                        error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                        break;
                }
            }

            if (returnTypeNode && returnTypeErrorLocation) {
                const functionFlags = getFunctionFlags(node as FunctionDeclaration);
                if ((functionFlags & (FunctionFlags.Invalid | FunctionFlags.Generator)) === FunctionFlags.Generator) {
                    const returnType = getTypeFromTypeNode(returnTypeNode);
                    if (returnType === voidType) {
                        error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation);
                    }
                    else {
                        checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation);
                    }
                }
                else if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async) {
                    checkAsyncFunctionReturnType(node as FunctionLikeDeclaration, returnTypeNode, returnTypeErrorLocation);
                }
            }
            if (node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.JSDocFunctionType) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
    }

    function checkGeneratorInstantiationAssignabilityToReturnType(returnType: Type, functionFlags: FunctionFlags, errorNode?: TypeNode) {
        // Naively, one could check that Generator<any, any, any> is assignable to the return type annotation.
        // However, that would not catch the error in the following case.
        //
        //    interface BadGenerator extends Iterable<number>, Iterator<string> { }
        //    function* g(): BadGenerator { } // Iterable and Iterator have different types!
        //
        const generatorYieldType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Yield, returnType, (functionFlags & FunctionFlags.Async) !== 0) || anyType;
        const generatorReturnType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, returnType, (functionFlags & FunctionFlags.Async) !== 0) || generatorYieldType;
        const generatorNextType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Next, returnType, (functionFlags & FunctionFlags.Async) !== 0) || unknownType;
        const generatorInstantiation = createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & FunctionFlags.Async));

        return checkTypeAssignableTo(generatorInstantiation, returnType, errorNode);
    }

    function checkClassForDuplicateDeclarations(node: ClassLikeDeclaration) {
        const instanceNames = new Map<__String, DeclarationMeaning>();
        const staticNames = new Map<__String, DeclarationMeaning>();
        // instance and static private identifiers share the same scope
        const privateIdentifiers = new Map<__String, DeclarationMeaning>();
        for (const member of node.members) {
            if (member.kind === SyntaxKind.Constructor) {
                for (const param of (member as ConstructorDeclaration).parameters) {
                    if (isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name)) {
                        addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaning.GetOrSetAccessor);
                    }
                }
            }
            else {
                const isStaticMember = isStatic(member);
                const name = member.name;
                if (!name) {
                    continue;
                }
                const isPrivate = isPrivateIdentifier(name);
                const privateStaticFlags = isPrivate && isStaticMember ? DeclarationMeaning.PrivateStatic : 0;
                const names = isPrivate ? privateIdentifiers :
                    isStaticMember ? staticNames :
                    instanceNames;

                const memberName = name && getEffectivePropertyNameForPropertyNameNode(name);
                if (memberName) {
                    switch (member.kind) {
                        case SyntaxKind.GetAccessor:
                            addName(names, name, memberName, DeclarationMeaning.GetAccessor | privateStaticFlags);
                            break;

                        case SyntaxKind.SetAccessor:
                            addName(names, name, memberName, DeclarationMeaning.SetAccessor | privateStaticFlags);
                            break;

                        case SyntaxKind.PropertyDeclaration:
                            addName(names, name, memberName, DeclarationMeaning.GetOrSetAccessor | privateStaticFlags);
                            break;

                        case SyntaxKind.MethodDeclaration:
                            addName(names, name, memberName, DeclarationMeaning.Method | privateStaticFlags);
                            break;
                    }
                }
            }
        }

        function addName(names: Map<__String, DeclarationMeaning>, location: Node, name: __String, meaning: DeclarationMeaning) {
            const prev = names.get(name);
            if (prev) {
                // For private identifiers, do not allow mixing of static and instance members with the same name
                if ((prev & DeclarationMeaning.PrivateStatic) !== (meaning & DeclarationMeaning.PrivateStatic)) {
                    error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location));
                }
                else {
                    const prevIsMethod = !!(prev & DeclarationMeaning.Method);
                    const isMethod = !!(meaning & DeclarationMeaning.Method);
                    if (prevIsMethod || isMethod) {
                        if (prevIsMethod !== isMethod) {
                            error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
                        }
                        // If this is a method/method duplication is might be an overload, so this will be handled when overloads are considered
                    }
                    else if (prev & meaning & ~DeclarationMeaning.PrivateStatic) {
                        error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
                    }
                    else {
                        names.set(name, prev | meaning);
                    }
                }
            }
            else {
                names.set(name, meaning);
            }
        }
    }

    /**
     * Static members being set on a constructor function may conflict with built-in properties
     * of Function. Esp. in ECMAScript 5 there are non-configurable and non-writable
     * built-in properties. This check issues a transpile error when a class has a static
     * member with the same name as a non-writable built-in property.
     *
     * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3
     * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.5
     * @see http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-function-constructor
     * @see http://www.ecma-international.org/ecma-262/6.0/#sec-function-instances
     */
    function checkClassForStaticPropertyNameConflicts(node: ClassLikeDeclaration) {
        for (const member of node.members) {
            const memberNameNode = member.name;
            const isStaticMember = isStatic(member);
            if (isStaticMember && memberNameNode) {
                const memberName = getEffectivePropertyNameForPropertyNameNode(memberNameNode);
                switch (memberName) {
                    case "name":
                    case "length":
                    case "caller":
                    case "arguments":
                        if (useDefineForClassFields) {
                            break;
                        }
                        // fall through
                    case "prototype":
                        const message = Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
                        const className = getNameOfSymbolAsWritten(getSymbolOfDeclaration(node));
                        error(memberNameNode, message, memberName, className);
                        break;
                }
            }
        }
    }

    function checkObjectTypeForDuplicateDeclarations(node: TypeLiteralNode | InterfaceDeclaration) {
        const names = new Map<string, boolean>();
        for (const member of node.members) {
            if (member.kind === SyntaxKind.PropertySignature) {
                let memberName: string;
                const name = member.name!;
                switch (name.kind) {
                    case SyntaxKind.StringLiteral:
                    case SyntaxKind.NumericLiteral:
                        memberName = name.text;
                        break;
                    case SyntaxKind.Identifier:
                        memberName = idText(name);
                        break;
                    default:
                        continue;
                }

                if (names.get(memberName)) {
                    error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName);
                    error(member.name, Diagnostics.Duplicate_identifier_0, memberName);
                }
                else {
                    names.set(memberName, true);
                }
            }
        }
    }

    function checkTypeForDuplicateIndexSignatures(node: ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode) {
        if (node.kind === SyntaxKind.InterfaceDeclaration) {
            const nodeSymbol = getSymbolOfDeclaration(node);
            // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
            // to prevent this run check only for the first declaration of a given kind
            if (nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                return;
            }
        }

        // TypeScript 1.0 spec (April 2014)
        // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
        // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
        const indexSymbol = getIndexSymbol(getSymbolOfDeclaration(node));
        if (indexSymbol?.declarations) {
            const indexSignatureMap = new Map<TypeId, { type: Type; declarations: IndexSignatureDeclaration[]; }>();
            for (const declaration of indexSymbol.declarations) {
                if (isIndexSignatureDeclaration(declaration)) {
                    if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
                        forEachType(getTypeFromTypeNode(declaration.parameters[0].type), type => {
                            const entry = indexSignatureMap.get(getTypeId(type));
                            if (entry) {
                                entry.declarations.push(declaration);
                            }
                            else {
                                indexSignatureMap.set(getTypeId(type), { type, declarations: [declaration] });
                            }
                        });
                    }
                }
                // Do nothing for late-bound index signatures: allow these to duplicate one another and explicit indexes
            }
            indexSignatureMap.forEach(entry => {
                if (entry.declarations.length > 1) {
                    for (const declaration of entry.declarations) {
                        error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type));
                    }
                }
            });
        }
    }

    function checkPropertyDeclaration(node: PropertyDeclaration | PropertySignature) {
        // Grammar checking
        if (!checkGrammarModifiers(node) && !checkGrammarProperty(node)) checkGrammarComputedPropertyName(node.name);
        checkVariableLikeDeclaration(node);

        setNodeLinksForPrivateIdentifierScope(node);

        // property signatures already report "initializer not allowed in ambient context" elsewhere
        if (hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === SyntaxKind.PropertyDeclaration && node.initializer) {
            error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name));
        }
    }

    function checkPropertySignature(node: PropertySignature) {
        if (isPrivateIdentifier(node.name)) {
            error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
        }
        return checkPropertyDeclaration(node);
    }

    function checkMethodDeclaration(node: MethodDeclaration | MethodSignature) {
        // Grammar checking
        if (!checkGrammarMethod(node)) checkGrammarComputedPropertyName(node.name);

        if (isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) === "constructor") {
            error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator);
        }

        // Grammar checking for modifiers is done inside the function checkGrammarFunctionLikeDeclaration
        checkFunctionOrMethodDeclaration(node);

        // method signatures already report "implementation not allowed in ambient context" elsewhere
        if (hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === SyntaxKind.MethodDeclaration && node.body) {
            error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name));
        }

        // Private named methods are only allowed in class declarations
        if (isPrivateIdentifier(node.name) && !getContainingClass(node)) {
            error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
        }

        setNodeLinksForPrivateIdentifierScope(node);
    }

    function setNodeLinksForPrivateIdentifierScope(node: PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration) {
        if (isPrivateIdentifier(node.name)) {
            if (
                languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||
                languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators ||
                !useDefineForClassFields
            ) {
                for (let lexicalScope = getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)) {
                    getNodeLinks(lexicalScope).flags |= NodeCheckFlags.ContainsClassWithPrivateIdentifiers;
                }

                // If this is a private element in a class expression inside the body of a loop,
                // then we must use a block-scoped binding to store the additional variables required
                // to transform private elements.
                if (isClassExpression(node.parent)) {
                    const enclosingIterationStatement = getEnclosingIterationStatement(node.parent);
                    if (enclosingIterationStatement) {
                        getNodeLinks(node.name).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
                        getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
                    }
                }
            }
        }
    }

    function checkClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration) {
        checkGrammarModifiers(node);

        forEachChild(node, checkSourceElement);
    }

    function checkConstructorDeclaration(node: ConstructorDeclaration) {
        // Grammar check on signature of constructor and modifier of the constructor is done in checkSignatureDeclaration function.
        checkSignatureDeclaration(node);
        // Grammar check for checking only related to constructorDeclaration
        if (!checkGrammarConstructorTypeParameters(node)) checkGrammarConstructorTypeAnnotation(node);

        checkSourceElement(node.body);

        const symbol = getSymbolOfDeclaration(node);
        const firstDeclaration = getDeclarationOfKind(symbol, node.kind);

        // Only type check the symbol once
        if (node === firstDeclaration) {
            checkFunctionOrConstructorSymbol(symbol);
        }

        // exit early in the case of signature - super checks are not relevant to them
        if (nodeIsMissing(node.body)) {
            return;
        }

        addLazyDiagnostic(checkConstructorDeclarationDiagnostics);

        return;

        function isInstancePropertyWithInitializerOrPrivateIdentifierProperty(n: Node): boolean {
            if (isPrivateIdentifierClassElementDeclaration(n)) {
                return true;
            }
            return n.kind === SyntaxKind.PropertyDeclaration &&
                !isStatic(n) &&
                !!(n as PropertyDeclaration).initializer;
        }

        function checkConstructorDeclarationDiagnostics() {
            // TS 1.0 spec (April 2014): 8.3.2
            // Constructors of classes with no extends clause may not contain super calls, whereas
            // constructors of derived classes must contain at least one super call somewhere in their function body.
            const containingClassDecl = node.parent;
            if (getClassExtendsHeritageElement(containingClassDecl)) {
                captureLexicalThis(node.parent, containingClassDecl);
                const classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
                const superCall = findFirstSuperCall(node.body!);
                if (superCall) {
                    if (classExtendsNull) {
                        error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
                    }

                    // A super call must be root-level in a constructor if both of the following are true:
                    // - The containing class is a derived class.
                    // - The constructor declares parameter properties
                    //   or the containing class declares instance member variables with initializers.

                    const superCallShouldBeRootLevel = !emitStandardClassFields &&
                        (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) ||
                            some(node.parameters, p => hasSyntacticModifier(p, ModifierFlags.ParameterPropertyModifier)));

                    if (superCallShouldBeRootLevel) {
                        // Until we have better flow analysis, it is an error to place the super call within any kind of block or conditional
                        // See GH #8277
                        if (!superCallIsRootLevelInConstructor(superCall, node.body!)) {
                            error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers);
                        }
                        // Skip past any prologue directives to check statements for referring to 'super' or 'this' before a super call
                        else {
                            let superCallStatement: ExpressionStatement | undefined;

                            for (const statement of node.body!.statements) {
                                if (isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression))) {
                                    superCallStatement = statement;
                                    break;
                                }
                                if (nodeImmediatelyReferencesSuperOrThis(statement)) {
                                    break;
                                }
                            }

                            // Until we have better flow analysis, it is an error to place the super call within any kind of block or conditional
                            // See GH #8277
                            if (superCallStatement === undefined) {
                                error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers);
                            }
                        }
                    }
                }
                else if (!classExtendsNull) {
                    error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
    }

    function superCallIsRootLevelInConstructor(superCall: Node, body: Block) {
        const superCallParent = walkUpParenthesizedExpressions(superCall.parent);
        return isExpressionStatement(superCallParent) && superCallParent.parent === body;
    }

    function nodeImmediatelyReferencesSuperOrThis(node: Node): boolean {
        if (node.kind === SyntaxKind.SuperKeyword || node.kind === SyntaxKind.ThisKeyword) {
            return true;
        }

        if (isThisContainerOrFunctionBlock(node)) {
            return false;
        }

        return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis);
    }

    function checkAccessorDeclaration(node: AccessorDeclaration) {
        if (isIdentifier(node.name) && idText(node.name) === "constructor" && isClassLike(node.parent)) {
            error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor);
        }
        addLazyDiagnostic(checkAccessorDeclarationDiagnostics);
        checkSourceElement(node.body);
        setNodeLinksForPrivateIdentifierScope(node);

        function checkAccessorDeclarationDiagnostics() {
            // Grammar checking accessors
            if (!checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node)) checkGrammarComputedPropertyName(node.name);

            checkDecorators(node);
            checkSignatureDeclaration(node);
            if (node.kind === SyntaxKind.GetAccessor) {
                if (!(node.flags & NodeFlags.Ambient) && nodeIsPresent(node.body) && (node.flags & NodeFlags.HasImplicitReturn)) {
                    if (!(node.flags & NodeFlags.HasExplicitReturn)) {
                        error(node.name, Diagnostics.A_get_accessor_must_return_a_value);
                    }
                }
            }
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.name.kind === SyntaxKind.ComputedPropertyName) {
                checkComputedPropertyName(node.name);
            }

            if (hasBindableName(node)) {
                // TypeScript 1.0 spec (April 2014): 8.4.3
                // Accessors for the same member name must specify the same accessibility.
                const symbol = getSymbolOfDeclaration(node);
                const getter = getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.GetAccessor);
                const setter = getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor);
                if (getter && setter && !(getNodeCheckFlags(getter) & NodeCheckFlags.TypeChecked)) {
                    getNodeLinks(getter).flags |= NodeCheckFlags.TypeChecked;
                    const getterFlags = getEffectiveModifierFlags(getter);
                    const setterFlags = getEffectiveModifierFlags(setter);
                    if ((getterFlags & ModifierFlags.Abstract) !== (setterFlags & ModifierFlags.Abstract)) {
                        error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                        error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                    }
                    if (
                        ((getterFlags & ModifierFlags.Protected) && !(setterFlags & (ModifierFlags.Protected | ModifierFlags.Private))) ||
                        ((getterFlags & ModifierFlags.Private) && !(setterFlags & ModifierFlags.Private))
                    ) {
                        error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
                        error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
                    }
                }
            }
            const returnType = getTypeOfAccessors(getSymbolOfDeclaration(node));
            if (node.kind === SyntaxKind.GetAccessor) {
                checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
            }
        }
    }

    function checkMissingDeclaration(node: Node) {
        checkDecorators(node);
    }

    function getEffectiveTypeArgumentAtIndex(node: TypeReferenceNode | ExpressionWithTypeArguments, typeParameters: readonly TypeParameter[], index: number): Type {
        if (node.typeArguments && index < node.typeArguments.length) {
            return getTypeFromTypeNode(node.typeArguments[index]);
        }
        return getEffectiveTypeArguments(node, typeParameters)[index];
    }

    function getEffectiveTypeArguments(node: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments, typeParameters: readonly TypeParameter[]): Type[] {
        return fillMissingTypeArguments(map(node.typeArguments!, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node));
    }

    function checkTypeArgumentConstraints(node: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments, typeParameters: readonly TypeParameter[]): boolean {
        let typeArguments: Type[] | undefined;
        let mapper: TypeMapper | undefined;
        let result = true;
        for (let i = 0; i < typeParameters.length; i++) {
            const constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (constraint) {
                if (!typeArguments) {
                    typeArguments = getEffectiveTypeArguments(node, typeParameters);
                    mapper = createTypeMapper(typeParameters, typeArguments);
                }
                result = result && checkTypeAssignableTo(
                    typeArguments[i],
                    instantiateType(constraint, mapper),
                    node.typeArguments![i],
                    Diagnostics.Type_0_does_not_satisfy_the_constraint_1,
                );
            }
        }
        return result;
    }

    function getTypeParametersForTypeAndSymbol(type: Type, symbol: Symbol) {
        if (!isErrorType(type)) {
            return symbol.flags & SymbolFlags.TypeAlias && getSymbolLinks(symbol).typeParameters ||
                (getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target.localTypeParameters : undefined);
        }
        return undefined;
    }

    function getTypeParametersForTypeReferenceOrImport(node: TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode) {
        const type = getTypeFromTypeNode(node);
        if (!isErrorType(type)) {
            const symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                return getTypeParametersForTypeAndSymbol(type, symbol);
            }
        }
        return undefined;
    }

    function checkTypeReferenceNode(node: TypeReferenceNode | ExpressionWithTypeArguments) {
        checkGrammarTypeArguments(node, node.typeArguments);
        if (node.kind === SyntaxKind.TypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end !== node.typeArguments.pos) {
            // If there was a token between the type name and the type arguments, check if it was a DotToken
            const sourceFile = getSourceFileOfNode(node);
            if (scanTokenAtPosition(sourceFile, node.typeName.end) === SyntaxKind.DotToken) {
                grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
        }
        forEach(node.typeArguments, checkSourceElement);
        checkTypeReferenceOrImport(node);
    }

    function checkTypeReferenceOrImport(node: TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode) {
        const type = getTypeFromTypeNode(node);
        if (!isErrorType(type)) {
            if (node.typeArguments) {
                addLazyDiagnostic(() => {
                    const typeParameters = getTypeParametersForTypeReferenceOrImport(node);
                    if (typeParameters) {
                        checkTypeArgumentConstraints(node, typeParameters);
                    }
                });
            }
            const symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                if (some(symbol.declarations, d => isTypeDeclaration(d) && !!(d.flags & NodeFlags.Deprecated))) {
                    addDeprecatedSuggestion(
                        getDeprecatedSuggestionNode(node),
                        symbol.declarations!,
                        symbol.escapedName as string,
                    );
                }
            }
        }
    }

    function getTypeArgumentConstraint(node: TypeNode): Type | undefined {
        const typeReferenceNode = tryCast(node.parent, isTypeReferenceType);
        if (!typeReferenceNode) return undefined;
        const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReferenceNode);
        if (!typeParameters) return undefined;
        const constraint = getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments!.indexOf(node)]);
        return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)));
    }

    function checkTypeQuery(node: TypeQueryNode) {
        getTypeFromTypeQueryNode(node);
    }

    function checkTypeLiteral(node: TypeLiteralNode) {
        forEach(node.members, checkSourceElement);
        addLazyDiagnostic(checkTypeLiteralDiagnostics);

        function checkTypeLiteralDiagnostics() {
            const type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
            checkIndexConstraints(type, type.symbol);
            checkTypeForDuplicateIndexSignatures(node);
            checkObjectTypeForDuplicateDeclarations(node);
        }
    }

    function checkArrayType(node: ArrayTypeNode) {
        checkSourceElement(node.elementType);
    }

    function checkTupleType(node: TupleTypeNode) {
        let seenOptionalElement = false;
        let seenRestElement = false;
        for (const e of node.elements) {
            let flags = getTupleElementFlags(e);
            if (flags & ElementFlags.Variadic) {
                const type = getTypeFromTypeNode((e as RestTypeNode | NamedTupleMember).type);
                if (!isArrayLikeType(type)) {
                    error(e, Diagnostics.A_rest_element_type_must_be_an_array_type);
                    break;
                }
                if (isArrayType(type) || isTupleType(type) && type.target.combinedFlags & ElementFlags.Rest) {
                    flags |= ElementFlags.Rest;
                }
            }
            if (flags & ElementFlags.Rest) {
                if (seenRestElement) {
                    grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element);
                    break;
                }
                seenRestElement = true;
            }
            else if (flags & ElementFlags.Optional) {
                if (seenRestElement) {
                    grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element);
                    break;
                }
                seenOptionalElement = true;
            }
            else if (flags & ElementFlags.Required && seenOptionalElement) {
                grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element);
                break;
            }
        }
        forEach(node.elements, checkSourceElement);
        getTypeFromTypeNode(node);
    }

    function checkUnionOrIntersectionType(node: UnionOrIntersectionTypeNode) {
        forEach(node.types, checkSourceElement);
        getTypeFromTypeNode(node);
    }

    function checkIndexedAccessIndexType(type: Type, accessNode: IndexedAccessTypeNode | ElementAccessExpression) {
        if (!(type.flags & TypeFlags.IndexedAccess)) {
            return type;
        }
        // Check if the index type is assignable to 'keyof T' for the object type.
        const objectType = (type as IndexedAccessType).objectType;
        const indexType = (type as IndexedAccessType).indexType;
        // skip index type deferral on remapping mapped types
        const objectIndexType = isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === MappedTypeNameTypeKind.Remapping
            ? getIndexTypeForMappedType(objectType, IndexFlags.None)
            : getIndexType(objectType, IndexFlags.None);
        const hasNumberIndexInfo = !!getIndexInfoOfType(objectType, numberType);
        if (everyType(indexType, t => isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType))) {
            if (
                accessNode.kind === SyntaxKind.ElementAccessExpression && isAssignmentTarget(accessNode) &&
                getObjectFlags(objectType) & ObjectFlags.Mapped && getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.IncludeReadonly
            ) {
                error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
            }
            return type;
        }
        if (isGenericObjectType(objectType)) {
            const propertyName = getPropertyNameFromIndex(indexType, accessNode);
            if (propertyName) {
                const propertySymbol = forEachType(getApparentType(objectType), t => getPropertyOfType(t, propertyName));
                if (propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol) & ModifierFlags.NonPublicAccessibilityModifier) {
                    error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName));
                    return errorType;
                }
            }
        }
        error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
        return errorType;
    }

    function checkIndexedAccessType(node: IndexedAccessTypeNode) {
        checkSourceElement(node.objectType);
        checkSourceElement(node.indexType);
        checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
    }

    function checkMappedType(node: MappedTypeNode) {
        checkGrammarMappedType(node);
        checkSourceElement(node.typeParameter);
        checkSourceElement(node.nameType);
        checkSourceElement(node.type);

        if (!node.type) {
            reportImplicitAny(node, anyType);
        }

        const type = getTypeFromMappedTypeNode(node) as MappedType;
        const nameType = getNameTypeFromMappedType(type);
        if (nameType) {
            checkTypeAssignableTo(nameType, stringNumberSymbolType, node.nameType);
        }
        else {
            const constraintType = getConstraintTypeFromMappedType(type);
            checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter));
        }
    }

    function checkGrammarMappedType(node: MappedTypeNode) {
        if (node.members?.length) {
            return grammarErrorOnNode(node.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
        }
    }

    function checkThisType(node: ThisTypeNode) {
        getTypeFromThisTypeNode(node);
    }

    function checkTypeOperator(node: TypeOperatorNode) {
        checkGrammarTypeOperatorNode(node);
        checkSourceElement(node.type);
    }

    function checkConditionalType(node: ConditionalTypeNode) {
        forEachChild(node, checkSourceElement);
    }

    function checkInferType(node: InferTypeNode) {
        if (!findAncestor(node, n => n.parent && n.parent.kind === SyntaxKind.ConditionalType && (n.parent as ConditionalTypeNode).extendsType === n)) {
            grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type);
        }
        checkSourceElement(node.typeParameter);
        const symbol = getSymbolOfDeclaration(node.typeParameter);
        if (symbol.declarations && symbol.declarations.length > 1) {
            const links = getSymbolLinks(symbol);
            if (!links.typeParametersChecked) {
                links.typeParametersChecked = true;
                const typeParameter = getDeclaredTypeOfTypeParameter(symbol);
                const declarations: TypeParameterDeclaration[] = getDeclarationsOfKind(symbol, SyntaxKind.TypeParameter);
                if (!areTypeParametersIdentical(declarations, [typeParameter], decl => [decl])) {
                    // Report an error on every conflicting declaration.
                    const name = symbolToString(symbol);
                    for (const declaration of declarations) {
                        error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name);
                    }
                }
            }
        }
        registerForUnusedIdentifiersCheck(node);
    }

    function checkTemplateLiteralType(node: TemplateLiteralTypeNode) {
        for (const span of node.templateSpans) {
            checkSourceElement(span.type);
            const type = getTypeFromTypeNode(span.type);
            checkTypeAssignableTo(type, templateConstraintType, span.type);
        }
        getTypeFromTypeNode(node);
    }

    function checkImportType(node: ImportTypeNode) {
        checkSourceElement(node.argument);

        if (node.attributes) {
            getResolutionModeOverride(node.attributes, grammarErrorOnNode);
        }
        checkTypeReferenceOrImport(node);
    }

    function checkNamedTupleMember(node: NamedTupleMember) {
        if (node.dotDotDotToken && node.questionToken) {
            grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest);
        }
        if (node.type.kind === SyntaxKind.OptionalType) {
            grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type);
        }
        if (node.type.kind === SyntaxKind.RestType) {
            grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type);
        }
        checkSourceElement(node.type);
        getTypeFromTypeNode(node);
    }

    function isPrivateWithinAmbient(node: Node): boolean {
        return (hasEffectiveModifier(node, ModifierFlags.Private) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & NodeFlags.Ambient);
    }

    function getEffectiveDeclarationFlags(n: Declaration, flagsToCheck: ModifierFlags): ModifierFlags {
        let flags = getCombinedModifierFlagsCached(n);

        // children of classes (even ambient classes) should not be marked as ambient or export
        // because those flags have no useful semantics there.
        if (
            n.parent.kind !== SyntaxKind.InterfaceDeclaration &&
            n.parent.kind !== SyntaxKind.ClassDeclaration &&
            n.parent.kind !== SyntaxKind.ClassExpression &&
            n.flags & NodeFlags.Ambient
        ) {
            const container = getEnclosingContainer(n);
            if ((container && container.flags & NodeFlags.ExportContext) && !(flags & ModifierFlags.Ambient) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent))) {
                // It is nested in an ambient export context, which means it is automatically exported
                flags |= ModifierFlags.Export;
            }
            flags |= ModifierFlags.Ambient;
        }

        return flags & flagsToCheck;
    }

    function checkFunctionOrConstructorSymbol(symbol: Symbol): void {
        addLazyDiagnostic(() => checkFunctionOrConstructorSymbolWorker(symbol));
    }

    function checkFunctionOrConstructorSymbolWorker(symbol: Symbol): void {
        function getCanonicalOverload(overloads: readonly Declaration[], implementation: FunctionLikeDeclaration | undefined): Declaration {
            // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
            // Error on all deviations from this canonical set of flags
            // The caveat is that if some overloads are defined in lib.d.ts, we don't want to
            // report the errors on those. To achieve this, we will say that the implementation is
            // the canonical signature only if it is in the same container as the first overload
            const implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
            return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
        }

        function checkFlagAgreementBetweenOverloads(overloads: Declaration[], implementation: FunctionLikeDeclaration | undefined, flagsToCheck: ModifierFlags, someOverloadFlags: ModifierFlags, allOverloadFlags: ModifierFlags): void {
            // Error if some overloads have a flag that is not shared by all overloads. To find the
            // deviations, we XOR someOverloadFlags with allOverloadFlags
            const someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
            if (someButNotAllOverloadFlags !== 0) {
                const canonicalFlags = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);
                group(overloads, o => getSourceFileOfNode(o).fileName).forEach(overloadsInFile => {
                    const canonicalFlagsForFile = getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck);
                    for (const o of overloadsInFile) {
                        const deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;
                        const deviationInFile = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile;
                        if (deviationInFile & ModifierFlags.Export) {
                            // Overloads in different files need not all have export modifiers. This is ok:
                            //   // lib.d.ts
                            //   declare function foo(s: number): string;
                            //   declare function foo(s: string): number;
                            //   export { foo };
                            //
                            //   // app.ts
                            //   declare module "lib" {
                            //     export function foo(s: boolean): boolean;
                            //   }
                            error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
                        }
                        else if (deviationInFile & ModifierFlags.Ambient) {
                            // Though rare, a module augmentation (necessarily ambient) is allowed to add overloads
                            // to a non-ambient function in an implementation file.
                            error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                        }
                        else if (deviation & (ModifierFlags.Private | ModifierFlags.Protected)) {
                            error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                        }
                        else if (deviation & ModifierFlags.Abstract) {
                            error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
                        }
                    }
                });
            }
        }

        function checkQuestionTokenAgreementBetweenOverloads(overloads: Declaration[], implementation: FunctionLikeDeclaration | undefined, someHaveQuestionToken: boolean, allHaveQuestionToken: boolean): void {
            if (someHaveQuestionToken !== allHaveQuestionToken) {
                const canonicalHasQuestionToken = hasQuestionToken(getCanonicalOverload(overloads, implementation));
                forEach(overloads, o => {
                    const deviation = hasQuestionToken(o) !== canonicalHasQuestionToken;
                    if (deviation) {
                        error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                    }
                });
            }
        }

        const flagsToCheck: ModifierFlags = ModifierFlags.Export | ModifierFlags.Ambient | ModifierFlags.Private | ModifierFlags.Protected | ModifierFlags.Abstract;
        let someNodeFlags: ModifierFlags = ModifierFlags.None;
        let allNodeFlags = flagsToCheck;
        let someHaveQuestionToken = false;
        let allHaveQuestionToken = true;
        let hasOverloads = false;
        let bodyDeclaration: FunctionLikeDeclaration | undefined;
        let lastSeenNonAmbientDeclaration: FunctionLikeDeclaration | undefined;
        let previousDeclaration: SignatureDeclaration | undefined;

        const declarations = symbol.declarations;
        const isConstructor = (symbol.flags & SymbolFlags.Constructor) !== 0;

        function reportImplementationExpectedError(node: SignatureDeclaration): void {
            if (node.name && nodeIsMissing(node.name)) {
                return;
            }

            let seen = false;
            const subsequentNode = forEachChild(node.parent, c => {
                if (seen) {
                    return c;
                }
                else {
                    seen = c === node;
                }
            });
            // We may be here because of some extra nodes between overloads that could not be parsed into a valid node.
            // In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.
            if (subsequentNode && subsequentNode.pos === node.end) {
                if (subsequentNode.kind === node.kind) {
                    const errorNode: Node = (subsequentNode as FunctionLikeDeclaration).name || subsequentNode;
                    const subsequentName = (subsequentNode as FunctionLikeDeclaration).name;
                    if (
                        node.name && subsequentName && (
                            // both are private identifiers
                            isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText === subsequentName.escapedText ||
                            // Both are computed property names
                            isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) ||
                            // Both are literal property names that are the same.
                            isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) &&
                                getEscapedTextOfIdentifierOrLiteral(node.name) === getEscapedTextOfIdentifierOrLiteral(subsequentName)
                        )
                    ) {
                        const reportError = (node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature) &&
                            isStatic(node) !== isStatic(subsequentNode);
                        // we can get here in two cases
                        // 1. mixed static and instance class members
                        // 2. something with the same name was defined before the set of overloads that prevents them from merging
                        // here we'll report error only for the first case since for second we should already report error in binder
                        if (reportError) {
                            const diagnostic = isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static;
                            error(errorNode, diagnostic);
                        }
                        return;
                    }
                    if (nodeIsPresent((subsequentNode as FunctionLikeDeclaration).body)) {
                        error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name));
                        return;
                    }
                }
            }
            const errorNode: Node = node.name || node;
            if (isConstructor) {
                error(errorNode, Diagnostics.Constructor_implementation_is_missing);
            }
            else {
                // Report different errors regarding non-consecutive blocks of declarations depending on whether
                // the node in question is abstract.
                if (hasSyntacticModifier(node, ModifierFlags.Abstract)) {
                    error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
                }
                else {
                    error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                }
            }
        }

        let duplicateFunctionDeclaration = false;
        let multipleConstructorImplementation = false;
        let hasNonAmbientClass = false;
        const functionDeclarations = [] as Declaration[];
        if (declarations) {
            for (const current of declarations) {
                const node = current as SignatureDeclaration | ClassDeclaration | ClassExpression;
                const inAmbientContext = node.flags & NodeFlags.Ambient;
                const inAmbientContextOrInterface = node.parent && (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    // check if declarations are consecutive only if they are non-ambient
                    // 1. ambient declarations can be interleaved
                    // i.e. this is legal
                    //     declare function foo();
                    //     declare function bar();
                    //     declare function foo();
                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                    previousDeclaration = undefined;
                }

                if ((node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression) && !inAmbientContext) {
                    hasNonAmbientClass = true;
                }

                if (node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature || node.kind === SyntaxKind.Constructor) {
                    functionDeclarations.push(node);
                    const currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node);
                    allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node);
                    const bodyIsPresent = nodeIsPresent((node as FunctionLikeDeclaration).body);

                    if (bodyIsPresent && bodyDeclaration) {
                        if (isConstructor) {
                            multipleConstructorImplementation = true;
                        }
                        else {
                            duplicateFunctionDeclaration = true;
                        }
                    }
                    else if (previousDeclaration?.parent === node.parent && previousDeclaration.end !== node.pos) {
                        reportImplementationExpectedError(previousDeclaration);
                    }

                    if (bodyIsPresent) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node as FunctionLikeDeclaration;
                        }
                    }
                    else {
                        hasOverloads = true;
                    }

                    previousDeclaration = node;

                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node as FunctionLikeDeclaration;
                    }
                }
                if (isInJSFile(current) && isFunctionLike(current) && current.jsDoc) {
                    hasOverloads = length(getJSDocOverloadTags(current)) > 0;
                }
            }
        }

        if (multipleConstructorImplementation) {
            forEach(functionDeclarations, declaration => {
                error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed);
            });
        }

        if (duplicateFunctionDeclaration) {
            forEach(functionDeclarations, declaration => {
                error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation);
            });
        }

        if (hasNonAmbientClass && !isConstructor && symbol.flags & SymbolFlags.Function && declarations) {
            const relatedDiagnostics = filter(declarations, d => d.kind === SyntaxKind.ClassDeclaration)
                .map(d => createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class));

            forEach(declarations, declaration => {
                const diagnostic = declaration.kind === SyntaxKind.ClassDeclaration
                    ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0
                    : declaration.kind === SyntaxKind.FunctionDeclaration
                    ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient
                    : undefined;
                if (diagnostic) {
                    addRelatedInfo(
                        error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)),
                        ...relatedDiagnostics,
                    );
                }
            });
        }

        // Abstract methods can't have an implementation -- in particular, they don't need one.
        if (
            lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body &&
            !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlags.Abstract) && !lastSeenNonAmbientDeclaration.questionToken
        ) {
            reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
        }

        if (hasOverloads) {
            if (declarations) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
            }

            if (bodyDeclaration) {
                const signatures = getSignaturesOfSymbol(symbol);
                const bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                for (const signature of signatures) {
                    if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
                        const errorNode = signature.declaration && isJSDocSignature(signature.declaration)
                            ? (signature.declaration.parent as JSDocOverloadTag | JSDocCallbackTag).tagName
                            : signature.declaration;
                        addRelatedInfo(
                            error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature),
                            createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here),
                        );
                        break;
                    }
                }
            }
        }
    }

    function checkExportsOnMergedDeclarations(node: Declaration): void {
        addLazyDiagnostic(() => checkExportsOnMergedDeclarationsWorker(node));
    }

    function checkExportsOnMergedDeclarationsWorker(node: Declaration): void {
        // if localSymbol is defined on node then node itself is exported - check is required
        let symbol = node.localSymbol;
        if (!symbol) {
            // local symbol is undefined => this declaration is non-exported.
            // however symbol might contain other declarations that are exported
            symbol = getSymbolOfDeclaration(node)!;
            if (!symbol.exportSymbol) {
                // this is a pure local symbol (all declarations are non-exported) - no need to check anything
                return;
            }
        }

        // run the check only for the first declaration in the list
        if (getDeclarationOfKind(symbol, node.kind) !== node) {
            return;
        }

        let exportedDeclarationSpaces = DeclarationSpaces.None;
        let nonExportedDeclarationSpaces = DeclarationSpaces.None;
        let defaultExportedDeclarationSpaces = DeclarationSpaces.None;
        for (const d of symbol.declarations!) {
            const declarationSpaces = getDeclarationSpaces(d);
            const effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, ModifierFlags.Export | ModifierFlags.Default);

            if (effectiveDeclarationFlags & ModifierFlags.Export) {
                if (effectiveDeclarationFlags & ModifierFlags.Default) {
                    defaultExportedDeclarationSpaces |= declarationSpaces;
                }
                else {
                    exportedDeclarationSpaces |= declarationSpaces;
                }
            }
            else {
                nonExportedDeclarationSpaces |= declarationSpaces;
            }
        }

        // Spaces for anything not declared a 'default export'.
        const nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;

        const commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
        const commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;

        if (commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault) {
            // declaration spaces for exported and non-exported declarations intersect
            for (const d of symbol.declarations!) {
                const declarationSpaces = getDeclarationSpaces(d);

                const name = getNameOfDeclaration(d);
                // Only error on the declarations that contributed to the intersecting spaces.
                if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) {
                    error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name));
                }
                else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {
                    error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name));
                }
            }
        }

        function getDeclarationSpaces(decl: Declaration): DeclarationSpaces {
            let d = decl as Node;
            switch (d.kind) {
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.TypeAliasDeclaration:

                // A jsdoc typedef and callback are, by definition, type aliases.
                // falls through
                case SyntaxKind.JSDocTypedefTag:
                case SyntaxKind.JSDocCallbackTag:
                case SyntaxKind.JSDocEnumTag:
                    return DeclarationSpaces.ExportType;
                case SyntaxKind.ModuleDeclaration:
                    return isAmbientModule(d as ModuleDeclaration) || getModuleInstanceState(d as ModuleDeclaration) !== ModuleInstanceState.NonInstantiated
                        ? DeclarationSpaces.ExportNamespace | DeclarationSpaces.ExportValue
                        : DeclarationSpaces.ExportNamespace;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.EnumMember:
                    return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue;
                case SyntaxKind.SourceFile:
                    return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue | DeclarationSpaces.ExportNamespace;
                case SyntaxKind.ExportAssignment:
                case SyntaxKind.BinaryExpression:
                    const node = d as ExportAssignment | BinaryExpression;
                    const expression = isExportAssignment(node) ? node.expression : node.right;
                    // Export assigned entity name expressions act as aliases and should fall through, otherwise they export values
                    if (!isEntityNameExpression(expression)) {
                        return DeclarationSpaces.ExportValue;
                    }
                    d = expression;

                // The below options all declare an Alias, which is allowed to merge with other values within the importing module.
                // falls through
                case SyntaxKind.ImportEqualsDeclaration:
                case SyntaxKind.NamespaceImport:
                case SyntaxKind.ImportClause:
                    let result = DeclarationSpaces.None;
                    const target = resolveAlias(getSymbolOfDeclaration(d as ImportEqualsDeclaration | NamespaceImport | ImportClause | ExportAssignment | BinaryExpression));
                    forEach(target.declarations, d => {
                        result |= getDeclarationSpaces(d);
                    });
                    return result;
                case SyntaxKind.VariableDeclaration:
                case SyntaxKind.BindingElement:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.ImportSpecifier: // https://github.com/Microsoft/TypeScript/pull/7591
                case SyntaxKind.Identifier: // https://github.com/microsoft/TypeScript/issues/36098
                    // Identifiers are used as declarations of assignment declarations whose parents may be
                    // SyntaxKind.CallExpression - `Object.defineProperty(thing, "aField", {value: 42});`
                    // SyntaxKind.ElementAccessExpression - `thing["aField"] = 42;` or `thing["aField"];` (with a doc comment on it)
                    // or SyntaxKind.PropertyAccessExpression - `thing.aField = 42;`
                    // all of which are pretty much always values, or at least imply a value meaning.
                    // It may be apprpriate to treat these as aliases in the future.
                    return DeclarationSpaces.ExportValue;
                case SyntaxKind.MethodSignature:
                case SyntaxKind.PropertySignature:
                    return DeclarationSpaces.ExportType;
                default:
                    return Debug.failBadSyntaxKind(d);
            }
        }
    }

    function getAwaitedTypeOfPromise(type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, ...args: DiagnosticArguments): Type | undefined {
        const promisedType = getPromisedTypeOfPromise(type, errorNode);
        return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, ...args);
    }

    /**
     * Gets the "promised type" of a promise.
     * @param type The type of the promise.
     * @remarks The "promised type" of a type is the type of the "value" parameter of the "onfulfilled" callback.
     */
    function getPromisedTypeOfPromise(type: Type, errorNode?: Node, thisTypeForErrorOut?: { value?: Type; }): Type | undefined {
        //
        //  { // type
        //      then( // thenFunction
        //          onfulfilled: ( // onfulfilledParameterType
        //              value: T // valueParameterType
        //          ) => any
        //      ): any;
        //  }
        //

        if (isTypeAny(type)) {
            return undefined;
        }

        const typeAsPromise = type as PromiseOrAwaitableType;
        if (typeAsPromise.promisedTypeOfPromise) {
            return typeAsPromise.promisedTypeOfPromise;
        }

        if (isReferenceToType(type, getGlobalPromiseType(/*reportErrors*/ false))) {
            return typeAsPromise.promisedTypeOfPromise = getTypeArguments(type as GenericType)[0];
        }

        // primitives with a `{ then() }` won't be unwrapped/adopted.
        if (allTypesAssignableToKind(getBaseConstraintOrType(type), TypeFlags.Primitive | TypeFlags.Never)) {
            return undefined;
        }

        const thenFunction = getTypeOfPropertyOfType(type, "then" as __String)!; // TODO: GH#18217
        if (isTypeAny(thenFunction)) {
            return undefined;
        }

        const thenSignatures = thenFunction ? getSignaturesOfType(thenFunction, SignatureKind.Call) : emptyArray;
        if (thenSignatures.length === 0) {
            if (errorNode) {
                error(errorNode, Diagnostics.A_promise_must_have_a_then_method);
            }
            return undefined;
        }

        let thisTypeForError: Type | undefined;
        let candidates: Signature[] | undefined;
        for (const thenSignature of thenSignatures) {
            const thisType = getThisTypeOfSignature(thenSignature);
            if (thisType && thisType !== voidType && !isTypeRelatedTo(type, thisType, subtypeRelation)) {
                thisTypeForError = thisType;
            }
            else {
                candidates = append(candidates, thenSignature);
            }
        }

        if (!candidates) {
            Debug.assertIsDefined(thisTypeForError);
            if (thisTypeForErrorOut) {
                thisTypeForErrorOut.value = thisTypeForError;
            }
            if (errorNode) {
                error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForError));
            }
            return undefined;
        }

        const onfulfilledParameterType = getTypeWithFacts(getUnionType(map(candidates, getTypeOfFirstParameterOfSignature)), TypeFacts.NEUndefinedOrNull);
        if (isTypeAny(onfulfilledParameterType)) {
            return undefined;
        }

        const onfulfilledParameterSignatures = getSignaturesOfType(onfulfilledParameterType, SignatureKind.Call);
        if (onfulfilledParameterSignatures.length === 0) {
            if (errorNode) {
                error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback);
            }
            return undefined;
        }

        return typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReduction.Subtype);
    }

    /**
     * Gets the "awaited type" of a type.
     * @param type The type to await.
     * @param withAlias When `true`, wraps the "awaited type" in `Awaited<T>` if needed.
     * @remarks The "awaited type" of an expression is its "promised type" if the expression is a
     * Promise-like type; otherwise, it is the type of the expression. This is used to reflect
     * The runtime behavior of the `await` keyword.
     */
    function checkAwaitedType(type: Type, withAlias: boolean, errorNode: Node, diagnosticMessage: DiagnosticMessage, ...args: DiagnosticArguments): Type {
        const awaitedType = withAlias ?
            getAwaitedType(type, errorNode, diagnosticMessage, ...args) :
            getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args);
        return awaitedType || errorType;
    }

    /**
     * Determines whether a type is an object with a callable `then` member.
     */
    function isThenableType(type: Type): boolean {
        if (allTypesAssignableToKind(getBaseConstraintOrType(type), TypeFlags.Primitive | TypeFlags.Never)) {
            // primitive types cannot be considered "thenable" since they are not objects.
            return false;
        }

        const thenFunction = getTypeOfPropertyOfType(type, "then" as __String);
        return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFacts.NEUndefinedOrNull), SignatureKind.Call).length > 0;
    }

    interface AwaitedTypeInstantiation extends Type {
        _awaitedTypeBrand: never;
        aliasSymbol: Symbol;
        aliasTypeArguments: readonly Type[];
    }

    function isAwaitedTypeInstantiation(type: Type): type is AwaitedTypeInstantiation {
        if (type.flags & TypeFlags.Conditional) {
            const awaitedSymbol = getGlobalAwaitedSymbol(/*reportErrors*/ false);
            return !!awaitedSymbol && type.aliasSymbol === awaitedSymbol && type.aliasTypeArguments?.length === 1;
        }
        return false;
    }

    /**
     * For a generic `Awaited<T>`, gets `T`.
     */
    function unwrapAwaitedType(type: Type) {
        return type.flags & TypeFlags.Union ? mapType(type, unwrapAwaitedType) :
            isAwaitedTypeInstantiation(type) ? type.aliasTypeArguments[0] :
            type;
    }

    function isAwaitedTypeNeeded(type: Type) {
        // If this is already an `Awaited<T>`, we shouldn't wrap it. This helps to avoid `Awaited<Awaited<T>>` in higher-order.
        if (isTypeAny(type) || isAwaitedTypeInstantiation(type)) {
            return false;
        }

        // We only need `Awaited<T>` if `T` contains possibly non-primitive types.
        if (isGenericObjectType(type)) {
            const baseConstraint = getBaseConstraintOfType(type);
            // We only need `Awaited<T>` if `T` is a type variable that has no base constraint, or the base constraint of `T` is `any`, `unknown`, `{}`, `object`,
            // or is promise-like.
            if (
                baseConstraint ?
                    baseConstraint.flags & TypeFlags.AnyOrUnknown || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) :
                    maybeTypeOfKind(type, TypeFlags.TypeVariable)
            ) {
                return true;
            }
        }

        return false;
    }

    function tryCreateAwaitedType(type: Type): Type | undefined {
        // Nothing to do if `Awaited<T>` doesn't exist
        const awaitedSymbol = getGlobalAwaitedSymbol(/*reportErrors*/ true);
        if (awaitedSymbol) {
            // Unwrap unions that may contain `Awaited<T>`, otherwise its possible to manufacture an `Awaited<Awaited<T> | U>` where
            // an `Awaited<T | U>` would suffice.
            return getTypeAliasInstantiation(awaitedSymbol, [unwrapAwaitedType(type)]);
        }

        return undefined;
    }

    function createAwaitedTypeIfNeeded(type: Type): Type {
        // We wrap type `T` in `Awaited<T>` based on the following conditions:
        // - `T` is not already an `Awaited<U>`, and
        // - `T` is generic, and
        // - One of the following applies:
        //   - `T` has no base constraint, or
        //   - The base constraint of `T` is `any`, `unknown`, `object`, or `{}`, or
        //   - The base constraint of `T` is an object type with a callable `then` method.

        if (isAwaitedTypeNeeded(type)) {
            return tryCreateAwaitedType(type) ?? type;
        }

        Debug.assert(isAwaitedTypeInstantiation(type) || getPromisedTypeOfPromise(type) === undefined, "type provided should not be a non-generic 'promise'-like.");
        return type;
    }

    /**
     * Gets the "awaited type" of a type.
     *
     * The "awaited type" of an expression is its "promised type" if the expression is a
     * Promise-like type; otherwise, it is the type of the expression. If the "promised
     * type" is itself a Promise-like, the "promised type" is recursively unwrapped until a
     * non-promise type is found.
     *
     * This is used to reflect the runtime behavior of the `await` keyword.
     */
    function getAwaitedType(type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, ...args: DiagnosticArguments): Type | undefined {
        const awaitedType = getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args);
        return awaitedType && createAwaitedTypeIfNeeded(awaitedType);
    }

    /**
     * Gets the "awaited type" of a type without introducing an `Awaited<T>` wrapper.
     *
     * @see {@link getAwaitedType}
     */
    function getAwaitedTypeNoAlias(type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, ...args: DiagnosticArguments): Type | undefined {
        if (isTypeAny(type)) {
            return type;
        }

        // If this is already an `Awaited<T>`, just return it. This avoids `Awaited<Awaited<T>>` in higher-order
        if (isAwaitedTypeInstantiation(type)) {
            return type;
        }

        // If we've already cached an awaited type, return a possible `Awaited<T>` for it.
        const typeAsAwaitable = type as PromiseOrAwaitableType;
        if (typeAsAwaitable.awaitedTypeOfType) {
            return typeAsAwaitable.awaitedTypeOfType;
        }

        // For a union, get a union of the awaited types of each constituent.
        if (type.flags & TypeFlags.Union) {
            if (awaitedTypeStack.lastIndexOf(type.id) >= 0) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
                }
                return undefined;
            }

            const mapper = errorNode ? (constituentType: Type) => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias;

            awaitedTypeStack.push(type.id);
            const mapped = mapType(type, mapper);
            awaitedTypeStack.pop();

            return typeAsAwaitable.awaitedTypeOfType = mapped;
        }

        // If `type` is generic and should be wrapped in `Awaited<T>`, return it.
        if (isAwaitedTypeNeeded(type)) {
            return typeAsAwaitable.awaitedTypeOfType = type;
        }

        const thisTypeForErrorOut: { value: Type | undefined; } = { value: undefined };
        const promisedType = getPromisedTypeOfPromise(type, /*errorNode*/ undefined, thisTypeForErrorOut);
        if (promisedType) {
            if (type.id === promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0) {
                // Verify that we don't have a bad actor in the form of a promise whose
                // promised type is the same as the promise type, or a mutually recursive
                // promise. If so, we return undefined as we cannot guess the shape. If this
                // were the actual case in the JavaScript, this Promise would never resolve.
                //
                // An example of a bad actor with a singly-recursive promise type might
                // be:
                //
                //  interface BadPromise {
                //      then(
                //          onfulfilled: (value: BadPromise) => any,
                //          onrejected: (error: any) => any): BadPromise;
                //  }
                //
                // The above interface will pass the PromiseLike check, and return a
                // promised type of `BadPromise`. Since this is a self reference, we
                // don't want to keep recursing ad infinitum.
                //
                // An example of a bad actor in the form of a mutually-recursive
                // promise type might be:
                //
                //  interface BadPromiseA {
                //      then(
                //          onfulfilled: (value: BadPromiseB) => any,
                //          onrejected: (error: any) => any): BadPromiseB;
                //  }
                //
                //  interface BadPromiseB {
                //      then(
                //          onfulfilled: (value: BadPromiseA) => any,
                //          onrejected: (error: any) => any): BadPromiseA;
                //  }
                //
                if (errorNode) {
                    error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
                }
                return undefined;
            }

            // Keep track of the type we're about to unwrap to avoid bad recursive promise types.
            // See the comments above for more information.
            awaitedTypeStack.push(type.id);
            const awaitedType = getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage, ...args);
            awaitedTypeStack.pop();

            if (!awaitedType) {
                return undefined;
            }

            return typeAsAwaitable.awaitedTypeOfType = awaitedType;
        }

        // The type was not a promise, so it could not be unwrapped any further.
        // As long as the type does not have a callable "then" property, it is
        // safe to return the type; otherwise, an error is reported and we return
        // undefined.
        //
        // An example of a non-promise "thenable" might be:
        //
        //  await { then(): void {} }
        //
        // The "thenable" does not match the minimal definition for a promise. When
        // a Promise/A+-compatible or ES6 promise tries to adopt this value, the promise
        // will never settle. We treat this as an error to help flag an early indicator
        // of a runtime problem. If the user wants to return this value from an async
        // function, they would need to wrap it in some other value. If they want it to
        // be treated as a promise, they can cast to <any>.
        if (isThenableType(type)) {
            if (errorNode) {
                Debug.assertIsDefined(diagnosticMessage);
                let chain: DiagnosticMessageChain | undefined;
                if (thisTypeForErrorOut.value) {
                    chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForErrorOut.value));
                }
                chain = chainDiagnosticMessages(chain, diagnosticMessage, ...args);
                diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain));
            }
            return undefined;
        }

        return typeAsAwaitable.awaitedTypeOfType = type;
    }

    /**
     * Checks the return type of an async function to ensure it is a compatible
     * Promise implementation.
     *
     * This checks that an async function has a valid Promise-compatible return type.
     * An async function has a valid Promise-compatible return type if the resolved value
     * of the return type has a construct signature that takes in an `initializer` function
     * that in turn supplies a `resolve` function as one of its arguments and results in an
     * object with a callable `then` signature.
     *
     * @param node The signature to check
     */
    function checkAsyncFunctionReturnType(node: FunctionLikeDeclaration | MethodSignature, returnTypeNode: TypeNode, returnTypeErrorLocation: TypeNode) {
        // As part of our emit for an async function, we will need to emit the entity name of
        // the return type annotation as an expression. To meet the necessary runtime semantics
        // for __awaiter, we must also check that the type of the declaration (e.g. the static
        // side or "constructor" of the promise type) is compatible `PromiseConstructorLike`.
        //
        // An example might be (from lib.es6.d.ts):
        //
        //  interface Promise<T> { ... }
        //  interface PromiseConstructor {
        //      new <T>(...): Promise<T>;
        //  }
        //  declare var Promise: PromiseConstructor;
        //
        // When an async function declares a return type annotation of `Promise<T>`, we
        // need to get the type of the `Promise` variable declaration above, which would
        // be `PromiseConstructor`.
        //
        // The same case applies to a class:
        //
        //  declare class Promise<T> {
        //      constructor(...);
        //      then<U>(...): Promise<U>;
        //  }
        //
        const returnType = getTypeFromTypeNode(returnTypeNode);
        if (languageVersion >= ScriptTarget.ES2015) {
            if (isErrorType(returnType)) {
                return;
            }
            const globalPromiseType = getGlobalPromiseType(/*reportErrors*/ true);
            if (globalPromiseType !== emptyGenericType && !isReferenceToType(returnType, globalPromiseType)) {
                // The promise type was not a valid type reference to the global promise type, so we
                // report an error and return the unknown type.
                reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType));
                return;
            }
        }
        else {
            // Always mark the type node as referenced if it points to a value
            markLinkedReferences(node, ReferenceHint.AsyncFunction);
            if (isErrorType(returnType)) {
                return;
            }

            const promiseConstructorName = getEntityNameFromTypeNode(returnTypeNode);
            if (promiseConstructorName === undefined) {
                reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, typeToString(returnType));
                return;
            }

            const promiseConstructorSymbol = resolveEntityName(promiseConstructorName, SymbolFlags.Value, /*ignoreErrors*/ true);
            const promiseConstructorType = promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType;
            if (isErrorType(promiseConstructorType)) {
                if (promiseConstructorName.kind === SyntaxKind.Identifier && promiseConstructorName.escapedText === "Promise" && getTargetType(returnType) === getGlobalPromiseType(/*reportErrors*/ false)) {
                    error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
                }
                else {
                    reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName));
                }
                return;
            }

            const globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType(/*reportErrors*/ true);
            if (globalPromiseConstructorLikeType === emptyObjectType) {
                // If we couldn't resolve the global PromiseConstructorLike type we cannot verify
                // compatibility with __awaiter.
                reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName));
                return;
            }

            const headMessage = Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value;
            const errorInfo = () => returnTypeNode === returnTypeErrorLocation ? undefined : chainDiagnosticMessages(/*details*/ undefined, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type);
            if (!checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo)) {
                return;
            }

            // Verify there is no local declaration that could collide with the promise constructor.
            const rootName = promiseConstructorName && getFirstIdentifier(promiseConstructorName);
            const collidingSymbol = getSymbol(node.locals!, rootName.escapedText, SymbolFlags.Value);
            if (collidingSymbol) {
                error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName));
                return;
            }
        }

        checkAwaitedType(returnType, /*withAlias*/ false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);

        function reportErrorForInvalidReturnType(message: DiagnosticMessage, returnTypeNode: TypeNode, returnTypeErrorLocation: TypeNode, typeName: string) {
            if (returnTypeNode === returnTypeErrorLocation) {
                error(returnTypeErrorLocation, message, typeName);
            }
            else {
                const diag = error(returnTypeErrorLocation, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type);
                addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName));
            }
        }
    }

    function checkGrammarDecorator(decorator: Decorator): boolean {
        const sourceFile = getSourceFileOfNode(decorator);
        if (!hasParseDiagnostics(sourceFile)) {
            let node: Expression = decorator.expression;

            // DecoratorParenthesizedExpression :
            //   `(` Expression `)`

            if (isParenthesizedExpression(node)) {
                return false;
            }

            let canHaveCallExpression = true;
            let errorNode: Node | undefined;
            while (true) {
                // Allow TS syntax such as non-null assertions and instantiation expressions
                if (isExpressionWithTypeArguments(node) || isNonNullExpression(node)) {
                    node = node.expression;
                    continue;
                }

                // DecoratorCallExpression :
                //   DecoratorMemberExpression Arguments

                if (isCallExpression(node)) {
                    if (!canHaveCallExpression) {
                        errorNode = node;
                    }
                    if (node.questionDotToken) {
                        // Even if we already have an error node, error at the `?.` token since it appears earlier.
                        errorNode = node.questionDotToken;
                    }
                    node = node.expression;
                    canHaveCallExpression = false;
                    continue;
                }

                // DecoratorMemberExpression :
                //   IdentifierReference
                //   DecoratorMemberExpression `.` IdentifierName
                //   DecoratorMemberExpression `.` PrivateIdentifier

                if (isPropertyAccessExpression(node)) {
                    if (node.questionDotToken) {
                        // Even if we already have an error node, error at the `?.` token since it appears earlier.
                        errorNode = node.questionDotToken;
                    }
                    node = node.expression;
                    canHaveCallExpression = false;
                    continue;
                }

                if (!isIdentifier(node)) {
                    // Even if we already have an error node, error at this node since it appears earlier.
                    errorNode = node;
                }

                break;
            }

            if (errorNode) {
                addRelatedInfo(
                    error(decorator.expression, Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator),
                    createDiagnosticForNode(errorNode, Diagnostics.Invalid_syntax_in_decorator),
                );
                return true;
            }
        }

        return false;
    }

    /** Check a decorator */
    function checkDecorator(node: Decorator): void {
        checkGrammarDecorator(node);

        const signature = getResolvedSignature(node);
        checkDeprecatedSignature(signature, node);
        const returnType = getReturnTypeOfSignature(signature);
        if (returnType.flags & TypeFlags.Any) {
            return;
        }

        // if we fail to get a signature and return type here, we will have already reported a grammar error in `checkDecorators`.
        const decoratorSignature = getDecoratorCallSignature(node);
        if (!decoratorSignature?.resolvedReturnType) return;

        let headMessage: DiagnosticMessage;
        const expectedReturnType = decoratorSignature.resolvedReturnType;
        switch (node.parent.kind) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
                break;

            case SyntaxKind.PropertyDeclaration:
                if (!legacyDecorators) {
                    headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
                    break;
                }
                // falls through

            case SyntaxKind.Parameter:
                headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any;
                break;

            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
                headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
                break;

            default:
                return Debug.failBadSyntaxKind(node.parent);
        }

        checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage);
    }

    /**
     * Creates a synthetic `Signature` corresponding to a call signature.
     */
    function createCallSignature(
        typeParameters: readonly TypeParameter[] | undefined,
        thisParameter: Symbol | undefined,
        parameters: readonly Symbol[],
        returnType: Type,
        typePredicate?: TypePredicate,
        minArgumentCount: number = parameters.length,
        flags: SignatureFlags = SignatureFlags.None,
    ) {
        const decl = factory.createFunctionTypeNode(/*typeParameters*/ undefined, emptyArray, factory.createKeywordTypeNode(SyntaxKind.AnyKeyword));
        return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags);
    }

    /**
     * Creates a synthetic `FunctionType`
     */
    function createFunctionType(
        typeParameters: readonly TypeParameter[] | undefined,
        thisParameter: Symbol | undefined,
        parameters: readonly Symbol[],
        returnType: Type,
        typePredicate?: TypePredicate,
        minArgumentCount?: number,
        flags?: SignatureFlags,
    ) {
        const signature = createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags);
        return getOrCreateTypeFromSignature(signature);
    }

    function createGetterFunctionType(type: Type) {
        return createFunctionType(/*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, type);
    }

    function createSetterFunctionType(type: Type) {
        const valueParam = createParameter("value" as __String, type);
        return createFunctionType(/*typeParameters*/ undefined, /*thisParameter*/ undefined, [valueParam], voidType);
    }

    function getEntityNameForDecoratorMetadata(node: TypeNode | undefined): EntityName | undefined {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.IntersectionType:
                case SyntaxKind.UnionType:
                    return getEntityNameForDecoratorMetadataFromTypeList((node as UnionOrIntersectionTypeNode).types);

                case SyntaxKind.ConditionalType:
                    return getEntityNameForDecoratorMetadataFromTypeList([(node as ConditionalTypeNode).trueType, (node as ConditionalTypeNode).falseType]);

                case SyntaxKind.ParenthesizedType:
                case SyntaxKind.NamedTupleMember:
                    return getEntityNameForDecoratorMetadata((node as ParenthesizedTypeNode).type);

                case SyntaxKind.TypeReference:
                    return (node as TypeReferenceNode).typeName;
            }
        }
    }

    function getEntityNameForDecoratorMetadataFromTypeList(types: readonly TypeNode[]): EntityName | undefined {
        let commonEntityName: EntityName | undefined;
        for (let typeNode of types) {
            while (typeNode.kind === SyntaxKind.ParenthesizedType || typeNode.kind === SyntaxKind.NamedTupleMember) {
                typeNode = (typeNode as ParenthesizedTypeNode | NamedTupleMember).type; // Skip parens if need be
            }
            if (typeNode.kind === SyntaxKind.NeverKeyword) {
                continue; // Always elide `never` from the union/intersection if possible
            }
            if (!strictNullChecks && (typeNode.kind === SyntaxKind.LiteralType && (typeNode as LiteralTypeNode).literal.kind === SyntaxKind.NullKeyword || typeNode.kind === SyntaxKind.UndefinedKeyword)) {
                continue; // Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks
            }
            const individualEntityName = getEntityNameForDecoratorMetadata(typeNode);
            if (!individualEntityName) {
                // Individual is something like string number
                // So it would be serialized to either that type or object
                // Safe to return here
                return undefined;
            }

            if (commonEntityName) {
                // Note this is in sync with the transformation that happens for type node.
                // Keep this in sync with serializeUnionOrIntersectionType
                // Verify if they refer to same entity and is identifier
                // return undefined if they dont match because we would emit object
                if (
                    !isIdentifier(commonEntityName) ||
                    !isIdentifier(individualEntityName) ||
                    commonEntityName.escapedText !== individualEntityName.escapedText
                ) {
                    return undefined;
                }
            }
            else {
                commonEntityName = individualEntityName;
            }
        }
        return commonEntityName;
    }

    function getParameterTypeNodeForDecoratorCheck(node: ParameterDeclaration): TypeNode | undefined {
        const typeNode = getEffectiveTypeAnnotationNode(node);
        return isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode;
    }

    /** Check the decorators of a node */
    function checkDecorators(node: Node): void {
        // skip this check for nodes that cannot have decorators. These should have already had an error reported by
        // checkGrammarModifiers.
        if (!canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent)) {
            return;
        }

        const firstDecorator = find(node.modifiers, isDecorator);
        if (!firstDecorator) {
            return;
        }

        if (legacyDecorators) {
            checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Decorate);
            if (node.kind === SyntaxKind.Parameter) {
                checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Param);
            }
        }
        else if (languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators) {
            checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.ESDecorateAndRunInitializers);
            if (isClassDeclaration(node)) {
                if (!node.name) {
                    checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.SetFunctionName);
                }
                else {
                    const member = getFirstTransformableStaticClassElement(node);
                    if (member) {
                        checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.SetFunctionName);
                    }
                }
            }
            else if (!isClassExpression(node)) {
                if (isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node))) {
                    checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.SetFunctionName);
                }
                if (isComputedPropertyName(node.name)) {
                    checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.PropKey);
                }
            }
        }

        markLinkedReferences(node, ReferenceHint.Decorator);

        for (const modifier of node.modifiers) {
            if (isDecorator(modifier)) {
                checkDecorator(modifier);
            }
        }
    }

    function checkFunctionDeclaration(node: FunctionDeclaration): void {
        addLazyDiagnostic(checkFunctionDeclarationDiagnostics);

        function checkFunctionDeclarationDiagnostics() {
            checkFunctionOrMethodDeclaration(node);
            checkGrammarForGenerator(node);
            checkCollisionsForDeclarationName(node, node.name);
        }
    }

    function checkJSDocTypeAliasTag(node: JSDocTypedefTag | JSDocCallbackTag) {
        if (!node.typeExpression) {
            // If the node had `@property` tags, `typeExpression` would have been set to the first property tag.
            error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags);
        }

        if (node.name) {
            checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
        }
        checkSourceElement(node.typeExpression);
        checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
    }

    function checkJSDocTemplateTag(node: JSDocTemplateTag): void {
        checkSourceElement(node.constraint);
        for (const tp of node.typeParameters) {
            checkSourceElement(tp);
        }
    }

    function checkJSDocTypeTag(node: JSDocTypeTag) {
        checkSourceElement(node.typeExpression);
    }

    function checkJSDocSatisfiesTag(node: JSDocSatisfiesTag) {
        checkSourceElement(node.typeExpression);
        const host = getEffectiveJSDocHost(node);
        if (host) {
            const tags = getAllJSDocTags(host, isJSDocSatisfiesTag);
            if (length(tags) > 1) {
                for (let i = 1; i < length(tags); i++) {
                    const tagName = tags[i].tagName;
                    error(tagName, Diagnostics._0_tag_already_specified, idText(tagName));
                }
            }
        }
    }

    function checkJSDocLinkLikeTag(node: JSDocLink | JSDocLinkCode | JSDocLinkPlain) {
        if (node.name) {
            resolveJSDocMemberName(node.name, /*ignoreErrors*/ true);
        }
    }

    function checkJSDocParameterTag(node: JSDocParameterTag) {
        checkSourceElement(node.typeExpression);
    }

    function checkJSDocPropertyTag(node: JSDocPropertyTag) {
        checkSourceElement(node.typeExpression);
    }

    function checkJSDocFunctionType(node: JSDocFunctionType): void {
        addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny);
        checkSignatureDeclaration(node);

        function checkJSDocFunctionTypeImplicitAny() {
            if (!node.type && !isJSDocConstructSignature(node)) {
                reportImplicitAny(node, anyType);
            }
        }
    }

    function checkJSDocThisTag(node: JSDocThisTag) {
        const host = getEffectiveJSDocHost(node);
        if (host && isArrowFunction(host)) {
            error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter);
        }
    }

    function checkJSDocImportTag(node: JSDocImportTag) {
        checkImportAttributes(node);
    }

    function checkJSDocImplementsTag(node: JSDocImplementsTag): void {
        const classLike = getEffectiveJSDocHost(node);
        if (!classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike)) {
            error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
        }
    }

    function checkJSDocAugmentsTag(node: JSDocAugmentsTag): void {
        const classLike = getEffectiveJSDocHost(node);
        if (!classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike)) {
            error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
            return;
        }

        const augmentsTags = getJSDocTags(classLike).filter(isJSDocAugmentsTag);
        Debug.assert(augmentsTags.length > 0);
        if (augmentsTags.length > 1) {
            error(augmentsTags[1], Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag);
        }

        const name = getIdentifierFromEntityNameExpression(node.class.expression);
        const extend = getClassExtendsHeritageElement(classLike);
        if (extend) {
            const className = getIdentifierFromEntityNameExpression(extend.expression);
            if (className && name.escapedText !== className.escapedText) {
                error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className));
            }
        }
    }

    function checkJSDocAccessibilityModifiers(node: JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag): void {
        const host = getJSDocHost(node);
        if (host && isPrivateIdentifierClassElementDeclaration(host)) {
            error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
        }
    }

    function getIdentifierFromEntityNameExpression(node: Identifier | PropertyAccessExpression): Identifier | PrivateIdentifier;
    function getIdentifierFromEntityNameExpression(node: Expression): Identifier | PrivateIdentifier | undefined;
    function getIdentifierFromEntityNameExpression(node: Expression): Identifier | PrivateIdentifier | undefined {
        switch (node.kind) {
            case SyntaxKind.Identifier:
                return node as Identifier;
            case SyntaxKind.PropertyAccessExpression:
                return (node as PropertyAccessExpression).name;
            default:
                return undefined;
        }
    }

    function checkFunctionOrMethodDeclaration(node: FunctionDeclaration | MethodDeclaration | MethodSignature): void {
        checkDecorators(node);
        checkSignatureDeclaration(node);
        const functionFlags = getFunctionFlags(node);

        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name && node.name.kind === SyntaxKind.ComputedPropertyName) {
            // This check will account for methods in class/interface declarations,
            // as well as accessors in classes/object literals
            checkComputedPropertyName(node.name);
        }

        if (hasBindableName(node)) {
            // first we want to check the local symbol that contain this declaration
            // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
            // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
            const symbol = getSymbolOfDeclaration(node);
            const localSymbol = node.localSymbol || symbol;

            // Since the javascript won't do semantic analysis like typescript,
            // if the javascript file comes before the typescript file and both contain same name functions,
            // checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
            const firstDeclaration = localSymbol.declarations?.find(
                // Get first non javascript function declaration
                declaration => declaration.kind === node.kind && !(declaration.flags & NodeFlags.JavaScriptFile),
            );

            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(localSymbol);
            }

            if (symbol.parent) {
                // run check on export symbol to check that modifiers agree across all exported declarations
                checkFunctionOrConstructorSymbol(symbol);
            }
        }

        const body = node.kind === SyntaxKind.MethodSignature ? undefined : node.body;
        checkSourceElement(body);
        checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node));

        addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics);

        // A js function declaration can have a @type tag instead of a return type node, but that type must have a call signature
        if (isInJSFile(node)) {
            const typeTag = getJSDocTypeTag(node);
            if (typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node)) {
                error(typeTag.typeExpression.type, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature);
            }
        }

        function checkFunctionOrMethodDeclarationDiagnostics() {
            if (!getEffectiveReturnTypeNode(node)) {
                // Report an implicit any error if there is no body, no explicit return type, and node is not a private method
                // in an ambient context
                if (nodeIsMissing(body) && !isPrivateWithinAmbient(node)) {
                    reportImplicitAny(node, anyType);
                }

                if (functionFlags & FunctionFlags.Generator && nodeIsPresent(body)) {
                    // A generator with a body and no type annotation can still cause errors. It can error if the
                    // yielded values have no common supertype, or it can give an implicit any error if it has no
                    // yielded values. The only way to trigger these errors is to try checking its return type.
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
            }
        }
    }

    function registerForUnusedIdentifiersCheck(node: PotentiallyUnusedIdentifier): void {
        addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics);

        function registerForUnusedIdentifiersCheckDiagnostics() {
            // May be in a call such as getTypeOfNode that happened to call this. But potentiallyUnusedIdentifiers is only defined in the scope of `checkSourceFile`.
            const sourceFile = getSourceFileOfNode(node);
            let potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(sourceFile.path);
            if (!potentiallyUnusedIdentifiers) {
                potentiallyUnusedIdentifiers = [];
                allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers);
            }
            // TODO: GH#22580
            // Debug.assert(addToSeen(seenPotentiallyUnusedIdentifiers, getNodeId(node)), "Adding potentially-unused identifier twice");
            potentiallyUnusedIdentifiers.push(node);
        }
    }

    type PotentiallyUnusedIdentifier = SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode;

    function checkUnusedIdentifiers(potentiallyUnusedIdentifiers: readonly PotentiallyUnusedIdentifier[], addDiagnostic: AddUnusedDiagnostic) {
        for (const node of potentiallyUnusedIdentifiers) {
            switch (node.kind) {
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                    checkUnusedClassMembers(node, addDiagnostic);
                    checkUnusedTypeParameters(node, addDiagnostic);
                    break;
                case SyntaxKind.SourceFile:
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.Block:
                case SyntaxKind.CaseBlock:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.ForOfStatement:
                    checkUnusedLocalsAndParameters(node, addDiagnostic);
                    break;
                case SyntaxKind.Constructor:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.ArrowFunction:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    // Only report unused parameters on the implementation, not overloads.
                    if (node.body) {
                        checkUnusedLocalsAndParameters(node, addDiagnostic);
                    }
                    checkUnusedTypeParameters(node, addDiagnostic);
                    break;
                case SyntaxKind.MethodSignature:
                case SyntaxKind.CallSignature:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.FunctionType:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                    checkUnusedTypeParameters(node, addDiagnostic);
                    break;
                case SyntaxKind.InferType:
                    checkUnusedInferTypeParameter(node, addDiagnostic);
                    break;
                default:
                    Debug.assertNever(node, "Node should not have been registered for unused identifiers check");
            }
        }
    }

    function errorUnusedLocal(declaration: Declaration, name: string, addDiagnostic: AddUnusedDiagnostic) {
        const node = getNameOfDeclaration(declaration) || declaration;
        const message = isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read;
        addDiagnostic(declaration, UnusedKind.Local, createDiagnosticForNode(node, message, name));
    }

    function isIdentifierThatStartsWithUnderscore(node: Node) {
        return isIdentifier(node) && idText(node).charCodeAt(0) === CharacterCodes._;
    }

    function checkUnusedClassMembers(node: ClassDeclaration | ClassExpression, addDiagnostic: AddUnusedDiagnostic): void {
        for (const member of node.members) {
            switch (member.kind) {
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    if (member.kind === SyntaxKind.SetAccessor && member.symbol.flags & SymbolFlags.GetAccessor) {
                        // Already would have reported an error on the getter.
                        break;
                    }
                    const symbol = getSymbolOfDeclaration(member);
                    if (
                        !symbol.isReferenced
                        && (hasEffectiveModifier(member, ModifierFlags.Private) || isNamedDeclaration(member) && isPrivateIdentifier(member.name))
                        && !(member.flags & NodeFlags.Ambient)
                    ) {
                        addDiagnostic(member, UnusedKind.Local, createDiagnosticForNode(member.name!, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));
                    }
                    break;
                case SyntaxKind.Constructor:
                    for (const parameter of (member as ConstructorDeclaration).parameters) {
                        if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlags.Private)) {
                            addDiagnostic(parameter, UnusedKind.Local, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)));
                        }
                    }
                    break;
                case SyntaxKind.IndexSignature:
                case SyntaxKind.SemicolonClassElement:
                case SyntaxKind.ClassStaticBlockDeclaration:
                    // Can't be private
                    break;
                default:
                    Debug.fail("Unexpected class member");
            }
        }
    }

    function checkUnusedInferTypeParameter(node: InferTypeNode, addDiagnostic: AddUnusedDiagnostic): void {
        const { typeParameter } = node;
        if (isTypeParameterUnused(typeParameter)) {
            addDiagnostic(node, UnusedKind.Parameter, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)));
        }
    }

    function checkUnusedTypeParameters(node: ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration, addDiagnostic: AddUnusedDiagnostic): void {
        // Only report errors on the last declaration for the type parameter container;
        // this ensures that all uses have been accounted for.
        const declarations = getSymbolOfDeclaration(node).declarations;
        if (!declarations || last(declarations) !== node) return;

        const typeParameters = getEffectiveTypeParameterDeclarations(node);
        const seenParentsWithEveryUnused = new Set<DeclarationWithTypeParameterChildren>();

        for (const typeParameter of typeParameters) {
            if (!isTypeParameterUnused(typeParameter)) continue;

            const name = idText(typeParameter.name);
            const { parent } = typeParameter;
            if (parent.kind !== SyntaxKind.InferType && parent.typeParameters!.every(isTypeParameterUnused)) {
                if (tryAddToSet(seenParentsWithEveryUnused, parent)) {
                    const sourceFile = getSourceFileOfNode(parent);
                    const range = isJSDocTemplateTag(parent)
                        // Whole @template tag
                        ? rangeOfNode(parent)
                        // Include the `<>` in the error message
                        : rangeOfTypeParameters(sourceFile, parent.typeParameters!);
                    const only = parent.typeParameters!.length === 1;
                    // TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                    const messageAndArg: DiagnosticAndArguments = only
                        ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name]
                        : [Diagnostics.All_type_parameters_are_unused];
                    addDiagnostic(typeParameter, UnusedKind.Parameter, createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, ...messageAndArg));
                }
            }
            else {
                // TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                addDiagnostic(typeParameter, UnusedKind.Parameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name));
            }
        }
    }
    function isTypeParameterUnused(typeParameter: TypeParameterDeclaration): boolean {
        return !(getMergedSymbol(typeParameter.symbol).isReferenced! & SymbolFlags.TypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name);
    }

    function addToGroup<K, V>(map: Map<string, [K, V[]]>, key: K, value: V, getKey: (key: K) => number | string): void {
        const keyString = String(getKey(key));
        const group = map.get(keyString);
        if (group) {
            group[1].push(value);
        }
        else {
            map.set(keyString, [key, [value]]);
        }
    }

    function tryGetRootParameterDeclaration(node: Node): ParameterDeclaration | undefined {
        return tryCast(getRootDeclaration(node), isParameter);
    }

    function isValidUnusedLocalDeclaration(declaration: Declaration): boolean {
        if (isBindingElement(declaration)) {
            if (isObjectBindingPattern(declaration.parent)) {
                /**
                 * ignore starts with underscore names _
                 * const { a: _a } = { a: 1 }
                 */
                return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name));
            }
            return isIdentifierThatStartsWithUnderscore(declaration.name);
        }
        return isAmbientModule(declaration) ||
            (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name!);
    }

    function checkUnusedLocalsAndParameters(nodeWithLocals: HasLocals, addDiagnostic: AddUnusedDiagnostic): void {
        // Ideally we could use the ImportClause directly as a key, but must wait until we have full ES6 maps. So must store key along with value.
        const unusedImports = new Map<string, [ImportClause, ImportedDeclaration[]]>();
        const unusedDestructures = new Map<string, [BindingPattern, BindingElement[]]>();
        const unusedVariables = new Map<string, [VariableDeclarationList, VariableDeclaration[]]>();
        nodeWithLocals.locals!.forEach(local => {
            // If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.
            // If it's a type parameter merged with a parameter, check if the parameter-side is used.
            if (local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol) {
                return;
            }

            if (local.declarations) {
                for (const declaration of local.declarations) {
                    if (isValidUnusedLocalDeclaration(declaration)) {
                        continue;
                    }

                    if (isImportedDeclaration(declaration)) {
                        addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);
                    }
                    else if (isBindingElement(declaration) && isObjectBindingPattern(declaration.parent)) {
                        // In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.
                        const lastElement = last(declaration.parent.elements);
                        if (declaration === lastElement || !last(declaration.parent.elements).dotDotDotToken) {
                            addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                        }
                    }
                    else if (isVariableDeclaration(declaration)) {
                        const blockScopeKind = getCombinedNodeFlagsCached(declaration) & NodeFlags.BlockScoped;
                        const name = getNameOfDeclaration(declaration);
                        if (blockScopeKind !== NodeFlags.Using && blockScopeKind !== NodeFlags.AwaitUsing || !name || !isIdentifierThatStartsWithUnderscore(name)) {
                            addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);
                        }
                    }
                    else {
                        const parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);
                        const name = local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration);
                        if (parameter && name) {
                            if (!isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name)) {
                                if (isBindingElement(declaration) && isArrayBindingPattern(declaration.parent)) {
                                    addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                                }
                                else {
                                    addDiagnostic(parameter, UnusedKind.Parameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)));
                                }
                            }
                        }
                        else {
                            errorUnusedLocal(declaration, symbolName(local), addDiagnostic);
                        }
                    }
                }
            }
        });
        unusedImports.forEach(([importClause, unuseds]) => {
            const importDecl = importClause.parent;
            const nDeclarations = (importClause.name ? 1 : 0) +
                (importClause.namedBindings ?
                    (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length)
                    : 0);
            if (nDeclarations === unuseds.length) {
                addDiagnostic(
                    importDecl,
                    UnusedKind.Local,
                    unuseds.length === 1
                        ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!))
                        : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused),
                );
            }
            else {
                for (const unused of unuseds) errorUnusedLocal(unused, idText(unused.name!), addDiagnostic);
            }
        });
        unusedDestructures.forEach(([bindingPattern, bindingElements]) => {
            const kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? UnusedKind.Parameter : UnusedKind.Local;
            if (bindingPattern.elements.length === bindingElements.length) {
                if (bindingElements.length === 1 && bindingPattern.parent.kind === SyntaxKind.VariableDeclaration && bindingPattern.parent.parent.kind === SyntaxKind.VariableDeclarationList) {
                    addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);
                }
                else {
                    addDiagnostic(
                        bindingPattern,
                        kind,
                        bindingElements.length === 1
                            ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name))
                            : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused),
                    );
                }
            }
            else {
                for (const e of bindingElements) {
                    addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));
                }
            }
        });
        unusedVariables.forEach(([declarationList, declarations]) => {
            if (declarationList.declarations.length === declarations.length) {
                addDiagnostic(
                    declarationList,
                    UnusedKind.Local,
                    declarations.length === 1
                        ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name))
                        : createDiagnosticForNode(declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused),
                );
            }
            else {
                for (const decl of declarations) {
                    addDiagnostic(decl, UnusedKind.Local, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));
                }
            }
        });
    }

    function checkPotentialUncheckedRenamedBindingElementsInTypes() {
        for (const node of potentialUnusedRenamedBindingElementsInTypes) {
            if (!getSymbolOfDeclaration(node)?.isReferenced) {
                const wrappingDeclaration = walkUpBindingElementsAndPatterns(node);
                Debug.assert(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here");
                const diagnostic = createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName));
                if (!wrappingDeclaration.type) {
                    // entire parameter does not have type annotation, suggest adding an annotation
                    addRelatedInfo(
                        diagnostic,
                        createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 0, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)),
                    );
                }
                diagnostics.add(diagnostic);
            }
        }
    }

    function bindingNameText(name: BindingName): string {
        switch (name.kind) {
            case SyntaxKind.Identifier:
                return idText(name);
            case SyntaxKind.ArrayBindingPattern:
            case SyntaxKind.ObjectBindingPattern:
                return bindingNameText(cast(first(name.elements), isBindingElement).name);
            default:
                return Debug.assertNever(name);
        }
    }

    type ImportedDeclaration = ImportClause | ImportSpecifier | NamespaceImport;
    function isImportedDeclaration(node: Node): node is ImportedDeclaration {
        return node.kind === SyntaxKind.ImportClause || node.kind === SyntaxKind.ImportSpecifier || node.kind === SyntaxKind.NamespaceImport;
    }
    function importClauseFromImported(decl: ImportedDeclaration): ImportClause {
        return decl.kind === SyntaxKind.ImportClause ? decl : decl.kind === SyntaxKind.NamespaceImport ? decl.parent : decl.parent.parent;
    }

    function checkBlock(node: Block) {
        // Grammar checking for SyntaxKind.Block
        if (node.kind === SyntaxKind.Block) {
            checkGrammarStatementInAmbientContext(node);
        }
        if (isFunctionOrModuleBlock(node)) {
            const saveFlowAnalysisDisabled = flowAnalysisDisabled;
            forEach(node.statements, checkSourceElement);
            flowAnalysisDisabled = saveFlowAnalysisDisabled;
        }
        else {
            forEach(node.statements, checkSourceElement);
        }
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }

    function checkCollisionWithArgumentsInGeneratedCode(node: SignatureDeclaration) {
        // no rest parameters \ declaration context \ overload - no codegen impact
        if (languageVersion >= ScriptTarget.ES2015 || !hasRestParameter(node) || node.flags & NodeFlags.Ambient || nodeIsMissing((node as FunctionLikeDeclaration).body)) {
            return;
        }

        forEach(node.parameters, p => {
            if (p.name && !isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {
                errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
            }
        });
    }

    /**
     * Checks whether an {@link Identifier}, in the context of another {@link Node}, would collide with a runtime value
     * of {@link name} in an outer scope. This is used to check for collisions for downlevel transformations that
     * require names like `Object`, `Promise`, `Reflect`, `require`, `exports`, etc.
     */
    function needCollisionCheckForIdentifier(node: Node, identifier: Identifier | undefined, name: string): boolean {
        if (identifier?.escapedText !== name) {
            return false;
        }

        if (
            node.kind === SyntaxKind.PropertyDeclaration ||
            node.kind === SyntaxKind.PropertySignature ||
            node.kind === SyntaxKind.MethodDeclaration ||
            node.kind === SyntaxKind.MethodSignature ||
            node.kind === SyntaxKind.GetAccessor ||
            node.kind === SyntaxKind.SetAccessor ||
            node.kind === SyntaxKind.PropertyAssignment
        ) {
            // it is ok to have member named '_super', '_this', `Promise`, etc. - member access is always qualified
            return false;
        }

        if (node.flags & NodeFlags.Ambient) {
            // ambient context - no codegen impact
            return false;
        }

        if (isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node)) {
            // type-only imports do not require collision checks against runtime values.
            if (isTypeOnlyImportOrExportDeclaration(node)) {
                return false;
            }
        }

        const root = getRootDeclaration(node);
        if (isParameter(root) && nodeIsMissing((root.parent as FunctionLikeDeclaration).body)) {
            // just an overload - no codegen impact
            return false;
        }

        return true;
    }

    // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
    function checkIfThisIsCapturedInEnclosingScope(node: Node): void {
        findAncestor(node, current => {
            if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureThis) {
                const isDeclaration = node.kind !== SyntaxKind.Identifier;
                if (isDeclaration) {
                    error(getNameOfDeclaration(node as Declaration), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                }
                else {
                    error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                }
                return true;
            }
            return false;
        });
    }

    function checkIfNewTargetIsCapturedInEnclosingScope(node: Node): void {
        findAncestor(node, current => {
            if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureNewTarget) {
                const isDeclaration = node.kind !== SyntaxKind.Identifier;
                if (isDeclaration) {
                    error(getNameOfDeclaration(node as Declaration), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
                }
                else {
                    error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
                }
                return true;
            }
            return false;
        });
    }

    function checkCollisionWithRequireExportsInGeneratedCode(node: Node, name: Identifier | undefined) {
        // No need to check for require or exports for ES6 modules and later
        if (host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) >= ModuleKind.ES2015) {
            return;
        }

        if (!name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
            return;
        }

        // Uninstantiated modules shouldnt do this check
        if (isModuleDeclaration(node) && getModuleInstanceState(node) !== ModuleInstanceState.Instantiated) {
            return;
        }

        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
        const parent = getDeclarationContainer(node);
        if (parent.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(parent as SourceFile)) {
            // If the declaration happens to be in external module, report error that require and exports are reserved keywords
            errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name));
        }
    }

    function checkCollisionWithGlobalPromiseInGeneratedCode(node: Node, name: Identifier | undefined): void {
        if (!name || languageVersion >= ScriptTarget.ES2017 || !needCollisionCheckForIdentifier(node, name, "Promise")) {
            return;
        }

        // Uninstantiated modules shouldnt do this check
        if (isModuleDeclaration(node) && getModuleInstanceState(node) !== ModuleInstanceState.Instantiated) {
            return;
        }

        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
        const parent = getDeclarationContainer(node);
        if (parent.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(parent as SourceFile) && parent.flags & NodeFlags.HasAsyncFunctions) {
            // If the declaration happens to be in external module, report error that Promise is a reserved identifier.
            errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name));
        }
    }

    function recordPotentialCollisionWithWeakMapSetInGeneratedCode(node: Node, name: Identifier): void {
        if (
            languageVersion <= ScriptTarget.ES2021
            && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet"))
        ) {
            potentialWeakMapSetCollisions.push(node);
        }
    }

    function checkWeakMapSetCollision(node: Node) {
        const enclosingBlockScope = getEnclosingBlockScopeContainer(node);
        if (getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlags.ContainsClassWithPrivateIdentifiers) {
            Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && typeof node.name.escapedText === "string", "The target of a WeakMap/WeakSet collision check should be an identifier");
            errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText);
        }
    }

    function recordPotentialCollisionWithReflectInGeneratedCode(node: Node, name: Identifier | undefined): void {
        if (
            name && languageVersion >= ScriptTarget.ES2015 && languageVersion <= ScriptTarget.ES2021
            && needCollisionCheckForIdentifier(node, name, "Reflect")
        ) {
            potentialReflectCollisions.push(node);
        }
    }

    function checkReflectCollision(node: Node) {
        let hasCollision = false;
        if (isClassExpression(node)) {
            // ClassExpression names don't contribute to their containers, but do matter for any of their block-scoped members.
            for (const member of node.members) {
                if (getNodeCheckFlags(member) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer) {
                    hasCollision = true;
                    break;
                }
            }
        }
        else if (isFunctionExpression(node)) {
            // FunctionExpression names don't contribute to their containers, but do matter for their contents
            if (getNodeCheckFlags(node) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer) {
                hasCollision = true;
            }
        }
        else {
            const container = getEnclosingBlockScopeContainer(node);
            if (container && getNodeCheckFlags(container) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer) {
                hasCollision = true;
            }
        }
        if (hasCollision) {
            Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier");
            errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect");
        }
    }

    function checkCollisionsForDeclarationName(node: Node, name: Identifier | undefined) {
        if (!name) return;
        checkCollisionWithRequireExportsInGeneratedCode(node, name);
        checkCollisionWithGlobalPromiseInGeneratedCode(node, name);
        recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
        recordPotentialCollisionWithReflectInGeneratedCode(node, name);
        if (isClassLike(node)) {
            checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0);
            if (!(node.flags & NodeFlags.Ambient)) {
                checkClassNameCollisionWithObject(name);
            }
        }
        else if (isEnumDeclaration(node)) {
            checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0);
        }
    }

    function checkVarDeclaredNamesNotShadowed(node: VariableDeclaration | BindingElement) {
        // - ScriptBody : StatementList
        // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
        // also occurs in the VarDeclaredNames of StatementList.

        // - Block : { StatementList }
        // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
        // also occurs in the VarDeclaredNames of StatementList.

        // Variable declarations are hoisted to the top of their function scope. They can shadow
        // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
        // by the binder as the declaration scope is different.
        // A non-initialized declaration is a no-op as the block declaration will resolve before the var
        // declaration. the problem is if the declaration has an initializer. this will act as a write to the
        // block declared value. this is fine for let, but not const.
        // Only consider declarations with initializers, uninitialized const declarations will not
        // step on a let/const variable.
        // Do not consider const and const declarations, as duplicate block-scoped declarations
        // are handled by the binder.
        // We are only looking for const declarations that step on let\const declarations from a
        // different scope. e.g.:
        //      {
        //          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
        //          const x = 0; // symbol for this declaration will be 'symbol'
        //      }

        // skip block-scoped variables and parameters
        if ((getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped) !== 0 || isPartOfParameterDeclaration(node)) {
            return;
        }

        // NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
        // so we'll always treat binding elements as initialized

        const symbol = getSymbolOfDeclaration(node);
        if (symbol.flags & SymbolFlags.FunctionScopedVariable) {
            if (!isIdentifier(node.name)) return Debug.fail();
            const localDeclarationSymbol = resolveName(node, node.name.escapedText, SymbolFlags.Variable, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
            if (
                localDeclarationSymbol &&
                localDeclarationSymbol !== symbol &&
                localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable
            ) {
                if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped) {
                    const varDeclList = getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKind.VariableDeclarationList)!;
                    const container = varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent
                        ? varDeclList.parent.parent
                        : undefined;

                    // names of block-scoped and function scoped variables can collide only
                    // if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
                    const namesShareScope = container &&
                        (container.kind === SyntaxKind.Block && isFunctionLike(container.parent) ||
                            container.kind === SyntaxKind.ModuleBlock ||
                            container.kind === SyntaxKind.ModuleDeclaration ||
                            container.kind === SyntaxKind.SourceFile);

                    // here we know that function scoped variable is "shadowed" by block scoped one
                    // a var declatation can't hoist past a lexical declaration and it results in a SyntaxError at runtime
                    if (!namesShareScope) {
                        const name = symbolToString(localDeclarationSymbol);
                        error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                    }
                }
            }
        }
    }

    function convertAutoToAny(type: Type) {
        return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
    }

    // Check variable, parameter, or property declaration
    function checkVariableLikeDeclaration(node: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement) {
        checkDecorators(node);
        if (!isBindingElement(node)) {
            checkSourceElement(node.type);
        }

        // JSDoc `function(string, string): string` syntax results in parameters with no name
        if (!node.name) {
            return;
        }

        // For a computed property, just check the initializer and exit
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name.kind === SyntaxKind.ComputedPropertyName) {
            checkComputedPropertyName(node.name);
            if (hasOnlyExpressionInitializer(node) && node.initializer) {
                checkExpressionCached(node.initializer);
            }
        }

        if (isBindingElement(node)) {
            if (
                node.propertyName &&
                isIdentifier(node.name) &&
                isPartOfParameterDeclaration(node) &&
                nodeIsMissing((getContainingFunction(node) as FunctionLikeDeclaration).body)
            ) {
                // type F = ({a: string}) => void;
                //               ^^^^^^
                // variable renaming in function type notation is confusing,
                // so we forbid it even if noUnusedLocals is not enabled
                potentialUnusedRenamedBindingElementsInTypes.push(node);
                return;
            }

            if (isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < LanguageFeatureMinimumTarget.ObjectSpreadRest) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.Rest);
            }
            // check computed properties inside property names of binding elements
            if (node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName) {
                checkComputedPropertyName(node.propertyName);
            }

            // check private/protected variable access
            const parent = node.parent.parent;
            const parentCheckMode = node.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal;
            const parentType = getTypeForBindingElementParent(parent, parentCheckMode);
            const name = node.propertyName || node.name;
            if (parentType && !isBindingPattern(name)) {
                const exprType = getLiteralTypeFromPropertyName(name);
                if (isTypeUsableAsPropertyName(exprType)) {
                    const nameText = getPropertyNameFromType(exprType);
                    const property = getPropertyOfType(parentType, nameText);
                    if (property) {
                        markPropertyAsReferenced(property, /*nodeForCheckWriteOnly*/ undefined, /*isSelfTypeAccess*/ false); // A destructuring is never a write-only reference.
                        checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind === SyntaxKind.SuperKeyword, /*writing*/ false, parentType, property);
                    }
                }
            }
        }

        // For a binding pattern, check contained binding elements
        if (isBindingPattern(node.name)) {
            if (node.name.kind === SyntaxKind.ArrayBindingPattern && languageVersion < LanguageFeatureMinimumTarget.BindingPatterns && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.Read);
            }

            forEach(node.name.elements, checkSourceElement);
        }
        // For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
        if (node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) as FunctionLikeDeclaration).body)) {
            error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
            return;
        }
        // For a binding pattern, validate the initializer and exit
        if (isBindingPattern(node.name)) {
            if (isInAmbientOrTypeNode(node)) {
                return;
            }
            const needCheckInitializer = hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind !== SyntaxKind.ForInStatement;
            const needCheckWidenedType = !some(node.name.elements, not(isOmittedExpression));
            if (needCheckInitializer || needCheckWidenedType) {
                // Don't validate for-in initializer as it is already an error
                const widenedType = getWidenedTypeForVariableLikeDeclaration(node);
                if (needCheckInitializer) {
                    const initializerType = checkExpressionCached(node.initializer);
                    if (strictNullChecks && needCheckWidenedType) {
                        checkNonNullNonVoidType(initializerType, node);
                    }
                    else {
                        checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer);
                    }
                }
                // check the binding pattern with empty elements
                if (needCheckWidenedType) {
                    if (isArrayBindingPattern(node.name)) {
                        checkIteratedTypeOrElementType(IterationUse.Destructuring, widenedType, undefinedType, node);
                    }
                    else if (strictNullChecks) {
                        checkNonNullNonVoidType(widenedType, node);
                    }
                }
            }
            return;
        }
        // For a commonjs `const x = require`, validate the alias and exit
        const symbol = getSymbolOfDeclaration(node);
        if (symbol.flags & SymbolFlags.Alias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node))) {
            checkAliasSymbol(node);
            return;
        }

        if (node.name.kind === SyntaxKind.BigIntLiteral) {
            error(node.name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name);
        }

        const type = convertAutoToAny(getTypeOfSymbol(symbol));
        if (node === symbol.valueDeclaration) {
            // Node is the primary declaration of the symbol, just validate the initializer
            // Don't validate for-in initializer as it is already an error
            const initializer = hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node);
            if (initializer) {
                const isJSObjectLiteralInitializer = isInJSFile(node) &&
                    isObjectLiteralExpression(initializer) &&
                    (initializer.properties.length === 0 || isPrototypeAccess(node.name)) &&
                    !!symbol.exports?.size;
                if (!isJSObjectLiteralInitializer && node.parent.parent.kind !== SyntaxKind.ForInStatement) {
                    const initializerType = checkExpressionCached(initializer);
                    checkTypeAssignableToAndOptionallyElaborate(initializerType, type, node, initializer, /*headMessage*/ undefined);
                    const blockScopeKind = getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped;
                    if (blockScopeKind === NodeFlags.AwaitUsing) {
                        const globalAsyncDisposableType = getGlobalAsyncDisposableType(/*reportErrors*/ true);
                        const globalDisposableType = getGlobalDisposableType(/*reportErrors*/ true);
                        if (globalAsyncDisposableType !== emptyObjectType && globalDisposableType !== emptyObjectType) {
                            const optionalDisposableType = getUnionType([globalAsyncDisposableType, globalDisposableType, nullType, undefinedType]);
                            checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined);
                        }
                    }
                    else if (blockScopeKind === NodeFlags.Using) {
                        const globalDisposableType = getGlobalDisposableType(/*reportErrors*/ true);
                        if (globalDisposableType !== emptyObjectType) {
                            const optionalDisposableType = getUnionType([globalDisposableType, nullType, undefinedType]);
                            checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined);
                        }
                    }
                }
            }
            if (symbol.declarations && symbol.declarations.length > 1) {
                if (some(symbol.declarations, d => d !== node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node))) {
                    error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
                }
            }
        }
        else {
            // Node is a secondary declaration, check that type is identical to primary declaration and check that
            // initializer is consistent with type associated with the node
            const declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));

            if (
                !isErrorType(type) && !isErrorType(declarationType) &&
                !isTypeIdenticalTo(type, declarationType) &&
                !(symbol.flags & SymbolFlags.Assignment)
            ) {
                errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType);
            }
            if (hasOnlyExpressionInitializer(node) && node.initializer) {
                checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, /*headMessage*/ undefined);
            }
            if (symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
                error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
            }
        }
        if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature) {
            // We know we don't have a binding pattern or computed name here
            checkExportsOnMergedDeclarations(node);
            if (node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement) {
                checkVarDeclaredNamesNotShadowed(node);
            }
            checkCollisionsForDeclarationName(node, node.name);
        }
    }

    function errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration: Declaration | undefined, firstType: Type, nextDeclaration: Declaration, nextType: Type): void {
        const nextDeclarationName = getNameOfDeclaration(nextDeclaration);
        const message = nextDeclaration.kind === SyntaxKind.PropertyDeclaration || nextDeclaration.kind === SyntaxKind.PropertySignature
            ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2
            : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
        const declName = declarationNameToString(nextDeclarationName);
        const err = error(
            nextDeclarationName,
            message,
            declName,
            typeToString(firstType),
            typeToString(nextType),
        );
        if (firstDeclaration) {
            addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName));
        }
    }

    function areDeclarationFlagsIdentical(left: Declaration, right: Declaration) {
        if (
            (left.kind === SyntaxKind.Parameter && right.kind === SyntaxKind.VariableDeclaration) ||
            (left.kind === SyntaxKind.VariableDeclaration && right.kind === SyntaxKind.Parameter)
        ) {
            // Differences in optionality between parameters and variables are allowed.
            return true;
        }

        if (hasQuestionToken(left) !== hasQuestionToken(right)) {
            return false;
        }

        const interestingFlags = ModifierFlags.Private |
            ModifierFlags.Protected |
            ModifierFlags.Async |
            ModifierFlags.Abstract |
            ModifierFlags.Readonly |
            ModifierFlags.Static;

        return getSelectedEffectiveModifierFlags(left, interestingFlags) === getSelectedEffectiveModifierFlags(right, interestingFlags);
    }

    function checkVariableDeclaration(node: VariableDeclaration) {
        tracing?.push(tracing.Phase.Check, "checkVariableDeclaration", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath });
        checkGrammarVariableDeclaration(node);
        checkVariableLikeDeclaration(node);
        tracing?.pop();
    }

    function checkBindingElement(node: BindingElement) {
        checkGrammarBindingElement(node);
        return checkVariableLikeDeclaration(node);
    }

    function checkVariableDeclarationList(node: VariableDeclarationList) {
        const blockScopeKind = getCombinedNodeFlags(node) & NodeFlags.BlockScoped;
        if ((blockScopeKind === NodeFlags.Using || blockScopeKind === NodeFlags.AwaitUsing) && languageVersion < LanguageFeatureMinimumTarget.UsingAndAwaitUsing) {
            checkExternalEmitHelpers(node, ExternalEmitHelpers.AddDisposableResourceAndDisposeResources);
        }

        forEach(node.declarations, checkSourceElement);
    }

    function checkVariableStatement(node: VariableStatement) {
        // Grammar checking
        if (!checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList)) checkGrammarForDisallowedBlockScopedVariableStatement(node);
        checkVariableDeclarationList(node.declarationList);
    }

    function checkExpressionStatement(node: ExpressionStatement) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);

        checkExpression(node.expression);
    }

    function checkIfStatement(node: IfStatement) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);
        const type = checkTruthinessExpression(node.expression);
        checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type, node.thenStatement);
        checkSourceElement(node.thenStatement);

        if (node.thenStatement.kind === SyntaxKind.EmptyStatement) {
            error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
        }

        checkSourceElement(node.elseStatement);
    }

    function checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(condExpr: Expression, condType: Type, body?: Statement | Expression) {
        if (!strictNullChecks) return;
        bothHelper(condExpr, body);

        function bothHelper(condExpr: Expression, body: Expression | Statement | undefined) {
            condExpr = skipParentheses(condExpr);

            helper(condExpr, body);

            while (isBinaryExpression(condExpr) && (condExpr.operatorToken.kind === SyntaxKind.BarBarToken || condExpr.operatorToken.kind === SyntaxKind.QuestionQuestionToken)) {
                condExpr = skipParentheses(condExpr.left);
                helper(condExpr, body);
            }
        }

        function helper(condExpr: Expression, body: Expression | Statement | undefined) {
            const location = isLogicalOrCoalescingBinaryExpression(condExpr) ? skipParentheses(condExpr.right) : condExpr;
            if (isModuleExportsAccessExpression(location)) {
                return;
            }
            if (isLogicalOrCoalescingBinaryExpression(location)) {
                bothHelper(location, body);
                return;
            }
            const type = location === condExpr ? condType : checkExpression(location);
            if (type.flags & TypeFlags.EnumLiteral && isPropertyAccessExpression(location) && (getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol).flags & SymbolFlags.Enum) {
                // EnumLiteral type at condition with known value is always truthy or always falsy, likely an error
                error(location, Diagnostics.This_condition_will_always_return_0, !!(type as LiteralType).value ? "true" : "false");
                return;
            }
            const isPropertyExpressionCast = isPropertyAccessExpression(location) && isTypeAssertion(location.expression);
            if (!hasTypeFacts(type, TypeFacts.Truthy) || isPropertyExpressionCast) return;

            // While it technically should be invalid for any known-truthy value
            // to be tested, we de-scope to functions and Promises unreferenced in
            // the block as a heuristic to identify the most common bugs. There
            // are too many false positives for values sourced from type
            // definitions without strictNullChecks otherwise.
            const callSignatures = getSignaturesOfType(type, SignatureKind.Call);
            const isPromise = !!getAwaitedTypeOfPromise(type);
            if (callSignatures.length === 0 && !isPromise) {
                return;
            }

            const testedNode = isIdentifier(location) ? location
                : isPropertyAccessExpression(location) ? location.name
                : undefined;
            const testedSymbol = testedNode && getSymbolAtLocation(testedNode);
            if (!testedSymbol && !isPromise) {
                return;
            }

            const isUsed = testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol)
                || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol);
            if (!isUsed) {
                if (isPromise) {
                    errorAndMaybeSuggestAwait(
                        location,
                        /*maybeMissingAwait*/ true,
                        Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined,
                        getTypeNameForErrorDisplay(type),
                    );
                }
                else {
                    error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead);
                }
            }
        }
    }

    function isSymbolUsedInConditionBody(expr: Expression, body: Statement | Expression, testedNode: Node, testedSymbol: Symbol): boolean {
        return !!forEachChild(body, function check(childNode): boolean | undefined {
            if (isIdentifier(childNode)) {
                const childSymbol = getSymbolAtLocation(childNode);
                if (childSymbol && childSymbol === testedSymbol) {
                    // If the test was a simple identifier, the above check is sufficient
                    if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {
                        return true;
                    }
                    // Otherwise we need to ensure the symbol is called on the same target
                    let testedExpression = testedNode.parent;
                    let childExpression = childNode.parent;
                    while (testedExpression && childExpression) {
                        if (
                            isIdentifier(testedExpression) && isIdentifier(childExpression) ||
                            testedExpression.kind === SyntaxKind.ThisKeyword && childExpression.kind === SyntaxKind.ThisKeyword
                        ) {
                            return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);
                        }
                        else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {
                            if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {
                                return false;
                            }
                            childExpression = childExpression.expression;
                            testedExpression = testedExpression.expression;
                        }
                        else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {
                            childExpression = childExpression.expression;
                            testedExpression = testedExpression.expression;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            return forEachChild(childNode, check);
        });
    }

    function isSymbolUsedInBinaryExpressionChain(node: Node, testedSymbol: Symbol): boolean {
        while (isBinaryExpression(node) && node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {
            const isUsed = forEachChild(node.right, function visit(child): boolean | undefined {
                if (isIdentifier(child)) {
                    const symbol = getSymbolAtLocation(child);
                    if (symbol && symbol === testedSymbol) {
                        return true;
                    }
                }
                return forEachChild(child, visit);
            });
            if (isUsed) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }

    function checkDoStatement(node: DoStatement) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);

        checkSourceElement(node.statement);
        checkTruthinessExpression(node.expression);
    }

    function checkWhileStatement(node: WhileStatement) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);

        checkTruthinessExpression(node.expression);
        checkSourceElement(node.statement);
    }

    function checkTruthinessOfType(type: Type, node: Node) {
        if (type.flags & TypeFlags.Void) {
            error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness);
        }
        else {
            const semantics = getSyntacticTruthySemantics(node);
            if (semantics !== PredicateSemantics.Sometimes) {
                error(
                    node,
                    semantics === PredicateSemantics.Always ?
                        Diagnostics.This_kind_of_expression_is_always_truthy :
                        Diagnostics.This_kind_of_expression_is_always_falsy,
                );
            }
        }

        return type;
    }

    function getSyntacticTruthySemantics(node: Node): PredicateSemantics {
        node = skipOuterExpressions(node);
        switch (node.kind) {
            case SyntaxKind.NumericLiteral:
                // Allow `while(0)` or `while(1)`
                if ((node as NumericLiteral).text === "0" || (node as NumericLiteral).text === "1") {
                    return PredicateSemantics.Sometimes;
                }
                return PredicateSemantics.Always;
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.BigIntLiteral:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.RegularExpressionLiteral:
                return PredicateSemantics.Always;
            case SyntaxKind.VoidExpression:
            case SyntaxKind.NullKeyword:
                return PredicateSemantics.Never;
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.StringLiteral:
                return !!(node as StringLiteral | NoSubstitutionTemplateLiteral).text ? PredicateSemantics.Always : PredicateSemantics.Never;
            case SyntaxKind.ConditionalExpression:
                return getSyntacticTruthySemantics((node as ConditionalExpression).whenTrue) | getSyntacticTruthySemantics((node as ConditionalExpression).whenFalse);
            case SyntaxKind.Identifier:
                if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {
                    return PredicateSemantics.Never;
                }
                return PredicateSemantics.Sometimes;
        }
        return PredicateSemantics.Sometimes;
    }

    function checkTruthinessExpression(node: Expression, checkMode?: CheckMode) {
        return checkTruthinessOfType(checkExpression(node, checkMode), node);
    }

    function checkForStatement(node: ForStatement) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (node.initializer && node.initializer.kind === SyntaxKind.VariableDeclarationList) {
                checkGrammarVariableDeclarationList(node.initializer as VariableDeclarationList);
            }
        }

        if (node.initializer) {
            if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
                checkVariableDeclarationList(node.initializer as VariableDeclarationList);
            }
            else {
                checkExpression(node.initializer);
            }
        }

        if (node.condition) checkTruthinessExpression(node.condition);
        if (node.incrementor) checkExpression(node.incrementor);
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }

    function checkForOfStatement(node: ForOfStatement): void {
        checkGrammarForInOrForOfStatement(node);

        const container = getContainingFunctionOrClassStaticBlock(node);
        if (node.awaitModifier) {
            if (container && isClassStaticBlockDeclaration(container)) {
                grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block);
            }
            else {
                const functionFlags = getFunctionFlags(container);
                if ((functionFlags & (FunctionFlags.Invalid | FunctionFlags.Async)) === FunctionFlags.Async && languageVersion < LanguageFeatureMinimumTarget.ForAwaitOf) {
                    // for..await..of in an async function or async generator function prior to ESNext requires the __asyncValues helper
                    checkExternalEmitHelpers(node, ExternalEmitHelpers.ForAwaitOfIncludes);
                }
            }
        }
        else if (compilerOptions.downlevelIteration && languageVersion < LanguageFeatureMinimumTarget.ForOf) {
            // for..of prior to ES2015 requires the __values helper when downlevelIteration is enabled
            checkExternalEmitHelpers(node, ExternalEmitHelpers.ForOfIncludes);
        }

        // Check the LHS and RHS
        // If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
        // via checkRightHandSideOfForOf.
        // If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
        // Then check that the RHS is assignable to it.
        if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
            checkVariableDeclarationList(node.initializer as VariableDeclarationList);
        }
        else {
            const varExpr = node.initializer;
            const iteratedType = checkRightHandSideOfForOf(node);

            // There may be a destructuring assignment on the left side
            if (varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression) {
                // iteratedType may be undefined. In this case, we still want to check the structure of
                // varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
                // to short circuit the type relation checking as much as possible, so we pass the unknownType.
                checkDestructuringAssignment(varExpr, iteratedType || errorType);
            }
            else {
                const leftType = checkExpression(varExpr);
                checkReferenceExpression(
                    varExpr,
                    Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access,
                    Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access,
                );

                // iteratedType will be undefined if the rightType was missing properties/signatures
                // required to get its iteratedType (like [Symbol.iterator] or next). This may be
                // because we accessed properties from anyType, or it may have led to an error inside
                // getElementTypeOfIterable.
                if (iteratedType) {
                    checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression);
                }
            }
        }

        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }

    function checkForInStatement(node: ForInStatement) {
        // Grammar checking
        checkGrammarForInOrForOfStatement(node);

        const rightType = getNonNullableTypeIfNeeded(checkExpression(node.expression));
        // TypeScript 1.0 spec (April 2014): 5.4
        // In a 'for-in' statement of the form
        // for (let VarDecl in Expr) Statement
        //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
        //   and Expr must be an expression of type Any, an object type, or a type parameter type.
        if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
            const variable = (node.initializer as VariableDeclarationList).declarations[0];
            if (variable && isBindingPattern(variable.name)) {
                error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
            }
            checkVariableDeclarationList(node.initializer as VariableDeclarationList);
        }
        else {
            // In a 'for-in' statement of the form
            // for (Var in Expr) Statement
            //   Var must be an expression classified as a reference of type Any or the String primitive type,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            const varExpr = node.initializer;
            const leftType = checkExpression(varExpr);
            if (varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression) {
                error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
            }
            else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
            }
            else {
                // run check only former check succeeded to avoid cascading errors
                checkReferenceExpression(
                    varExpr,
                    Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access,
                    Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access,
                );
            }
        }

        // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
        // in this case error about missing name is already reported - do not report extra one
        if (rightType === neverType || !isTypeAssignableToKind(rightType, TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive)) {
            error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType));
        }

        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }

    function checkRightHandSideOfForOf(statement: ForOfStatement): Type {
        const use = statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf;
        return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
    }

    function checkIteratedTypeOrElementType(use: IterationUse, inputType: Type, sentType: Type, errorNode: Node | undefined): Type {
        if (isTypeAny(inputType)) {
            return inputType;
        }
        return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, /*checkAssignability*/ true) || anyType;
    }

    /**
     * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
     * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
     * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
     */
    function getIteratedTypeOrElementType(use: IterationUse, inputType: Type, sentType: Type, errorNode: Node | undefined, checkAssignability: boolean): Type | undefined {
        const allowAsyncIterables = (use & IterationUse.AllowsAsyncIterablesFlag) !== 0;
        if (inputType === neverType) {
            if (errorNode) {
                reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables);
            }
            return undefined;
        }

        const uplevelIteration = languageVersion >= ScriptTarget.ES2015;
        const downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
        const possibleOutOfBounds = compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUse.PossiblyOutOfBounds);

        // Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
        // or higher, when inside of an async generator or for-await-if, or when
        // downlevelIteration is requested.
        if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
            // We only report errors for an invalid iterable type in ES2015 or higher.
            const iterationTypes = getIterationTypesOfIterable(inputType, use, uplevelIteration ? errorNode : undefined);
            if (checkAssignability) {
                if (iterationTypes) {
                    const diagnostic = use & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :
                        use & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :
                        use & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :
                        use & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :
                        undefined;
                    if (diagnostic) {
                        checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
                    }
                }
            }
            if (iterationTypes || uplevelIteration) {
                return possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType);
            }
        }

        let arrayType = inputType;
        let hasStringConstituent = false;

        // If strings are permitted, remove any string-like constituents from the array type.
        // This allows us to find other non-string element types from an array unioned with
        // a string.
        if (use & IterationUse.AllowsStringInputFlag) {
            if (arrayType.flags & TypeFlags.Union) {
                // After we remove all types that are StringLike, we will know if there was a string constituent
                // based on whether the result of filter is a new array.
                const arrayTypes = (inputType as UnionType).types;
                const filteredTypes = filter(arrayTypes, t => !(t.flags & TypeFlags.StringLike));
                if (filteredTypes !== arrayTypes) {
                    arrayType = getUnionType(filteredTypes, UnionReduction.Subtype);
                }
            }
            else if (arrayType.flags & TypeFlags.StringLike) {
                arrayType = neverType;
            }

            hasStringConstituent = arrayType !== inputType;
            if (hasStringConstituent) {
                // Now that we've removed all the StringLike types, if no constituents remain, then the entire
                // arrayOrStringType was a string.
                if (arrayType.flags & TypeFlags.Never) {
                    return possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType;
                }
            }
        }

        if (!isArrayLikeType(arrayType)) {
            if (errorNode) {
                // Which error we report depends on whether we allow strings or if there was a
                // string constituent. For example, if the input type is number | string, we
                // want to say that number is not an array type. But if the input was just
                // number and string input is allowed, we want to say that number is not an
                // array type or a string type.
                const allowsStrings = !!(use & IterationUse.AllowsStringInputFlag) && !hasStringConstituent;
                const [defaultDiagnostic, maybeMissingAwait] = getIterationDiagnosticDetails(allowsStrings, downlevelIteration);
                errorAndMaybeSuggestAwait(
                    errorNode,
                    maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType),
                    defaultDiagnostic,
                    typeToString(arrayType),
                );
            }
            return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined;
        }

        const arrayElementType = getIndexTypeOfType(arrayType, numberType);
        if (hasStringConstituent && arrayElementType) {
            // This is just an optimization for the case where arrayOrStringType is string | string[]
            if (arrayElementType.flags & TypeFlags.StringLike && !compilerOptions.noUncheckedIndexedAccess) {
                return stringType;
            }

            return getUnionType(possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType], UnionReduction.Subtype);
        }

        return (use & IterationUse.PossiblyOutOfBounds) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType;

        function getIterationDiagnosticDetails(allowsStrings: boolean, downlevelIteration: boolean | undefined): [error: DiagnosticMessage, maybeMissingAwait: boolean] {
            if (downlevelIteration) {
                return allowsStrings
                    ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]
                    : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true];
            }

            const yieldType = getIterationTypeOfIterable(use, IterationTypeKind.Yield, inputType, /*errorNode*/ undefined);

            if (yieldType) {
                return [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false];
            }

            if (isES2015OrLaterIterable(inputType.symbol?.escapedName)) {
                return [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true];
            }

            return allowsStrings
                ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]
                : [Diagnostics.Type_0_is_not_an_array_type, true];
        }
    }

    function isES2015OrLaterIterable(n: __String) {
        switch (n) {
            case "Float32Array":
            case "Float64Array":
            case "Int16Array":
            case "Int32Array":
            case "Int8Array":
            case "NodeList":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8Array":
            case "Uint8ClampedArray":
                return true;
        }
        return false;
    }

    /**
     * Gets the requested "iteration type" from an `Iterable`-like or `AsyncIterable`-like type.
     */
    function getIterationTypeOfIterable(use: IterationUse, typeKind: IterationTypeKind, inputType: Type, errorNode: Node | undefined): Type | undefined {
        if (isTypeAny(inputType)) {
            return undefined;
        }

        const iterationTypes = getIterationTypesOfIterable(inputType, use, errorNode);
        return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)];
    }

    function createIterationTypes(yieldType: Type = neverType, returnType: Type = neverType, nextType: Type = unknownType): IterationTypes {
        // `yieldType` and `returnType` are defaulted to `neverType` they each will be combined
        // via `getUnionType` when merging iteration types. `nextType` is defined as `unknownType`
        // as it is combined via `getIntersectionType` when merging iteration types.

        // Use the cache only for intrinsic types to keep it small as they are likely to be
        // more frequently created (i.e. `Iterator<number, void, unknown>`). Iteration types
        // are also cached on the type they are requested for, so we shouldn't need to maintain
        // the cache for less-frequently used types.
        if (
            yieldType.flags & TypeFlags.Intrinsic &&
            returnType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined) &&
            nextType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined)
        ) {
            const id = getTypeListId([yieldType, returnType, nextType]);
            let iterationTypes = iterationTypesCache.get(id);
            if (!iterationTypes) {
                iterationTypes = { yieldType, returnType, nextType };
                iterationTypesCache.set(id, iterationTypes);
            }
            return iterationTypes;
        }
        return { yieldType, returnType, nextType };
    }

    /**
     * Combines multiple `IterationTypes` records.
     *
     * If `array` is empty or all elements are missing or are references to `noIterationTypes`,
     * then `noIterationTypes` is returned. Otherwise, an `IterationTypes` record is returned
     * for the combined iteration types.
     */
    function combineIterationTypes(array: (IterationTypes | undefined)[]) {
        let yieldTypes: Type[] | undefined;
        let returnTypes: Type[] | undefined;
        let nextTypes: Type[] | undefined;
        for (const iterationTypes of array) {
            if (iterationTypes === undefined || iterationTypes === noIterationTypes) {
                continue;
            }
            if (iterationTypes === anyIterationTypes) {
                return anyIterationTypes;
            }
            yieldTypes = append(yieldTypes, iterationTypes.yieldType);
            returnTypes = append(returnTypes, iterationTypes.returnType);
            nextTypes = append(nextTypes, iterationTypes.nextType);
        }
        if (yieldTypes || returnTypes || nextTypes) {
            return createIterationTypes(
                yieldTypes && getUnionType(yieldTypes),
                returnTypes && getUnionType(returnTypes),
                nextTypes && getIntersectionType(nextTypes),
            );
        }
        return noIterationTypes;
    }

    function getCachedIterationTypes(type: Type, cacheKey: MatchingKeys<IterableOrIteratorType, IterationTypes | undefined>) {
        return (type as IterableOrIteratorType)[cacheKey];
    }

    function setCachedIterationTypes(type: Type, cacheKey: MatchingKeys<IterableOrIteratorType, IterationTypes | undefined>, cachedTypes: IterationTypes) {
        return (type as IterableOrIteratorType)[cacheKey] = cachedTypes;
    }

    /**
     * Gets the *yield*, *return*, and *next* types from an `Iterable`-like or `AsyncIterable`-like type.
     *
     * At every level that involves analyzing return types of signatures, we union the return types of all the signatures.
     *
     * Another thing to note is that at any step of this process, we could run into a dead end,
     * meaning either the property is missing, or we run into the anyType. If either of these things
     * happens, we return `undefined` to signal that we could not find the iteration type. If a property
     * is missing, and the previous step did not result in `any`, then we also give an error if the
     * caller requested it. Then the caller can decide what to do in the case where there is no iterated
     * type.
     *
     * For a **for-of** statement, `yield*` (in a normal generator), spread, array
     * destructuring, or normal generator we will only ever look for a `[Symbol.iterator]()`
     * method.
     *
     * For an async generator we will only ever look at the `[Symbol.asyncIterator]()` method.
     *
     * For a **for-await-of** statement or a `yield*` in an async generator we will look for
     * the `[Symbol.asyncIterator]()` method first, and then the `[Symbol.iterator]()` method.
     */
    function getIterationTypesOfIterable(type: Type, use: IterationUse, errorNode: Node | undefined) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }

        if (!(type.flags & TypeFlags.Union)) {
            const errorOutputContainer: ErrorOutputContainer | undefined = errorNode ? { errors: undefined, skipLogging: true } : undefined;
            const iterationTypes = getIterationTypesOfIterableWorker(type, use, errorNode, errorOutputContainer);
            if (iterationTypes === noIterationTypes) {
                if (errorNode) {
                    const rootDiag = reportTypeNotIterableError(errorNode, type, !!(use & IterationUse.AllowsAsyncIterablesFlag));
                    if (errorOutputContainer?.errors) {
                        addRelatedInfo(rootDiag, ...errorOutputContainer.errors);
                    }
                }
                return undefined;
            }
            else if (errorOutputContainer?.errors?.length) {
                for (const diag of errorOutputContainer.errors) {
                    diagnostics.add(diag);
                }
            }
            return iterationTypes;
        }

        const cacheKey = use & IterationUse.AllowsAsyncIterablesFlag ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable";
        const cachedTypes = getCachedIterationTypes(type, cacheKey);
        if (cachedTypes) return cachedTypes === noIterationTypes ? undefined : cachedTypes;

        let allIterationTypes: IterationTypes[] | undefined;
        for (const constituent of (type as UnionType).types) {
            const errorOutputContainer: ErrorOutputContainer | undefined = errorNode ? { errors: undefined } : undefined;
            const iterationTypes = getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer);
            if (iterationTypes === noIterationTypes) {
                if (errorNode) {
                    const rootDiag = reportTypeNotIterableError(errorNode, type, !!(use & IterationUse.AllowsAsyncIterablesFlag));
                    if (errorOutputContainer?.errors) {
                        addRelatedInfo(rootDiag, ...errorOutputContainer.errors);
                    }
                }
                setCachedIterationTypes(type, cacheKey, noIterationTypes);
                return undefined;
            }
            else if (errorOutputContainer?.errors?.length) {
                for (const diag of errorOutputContainer.errors) {
                    diagnostics.add(diag);
                }
            }

            allIterationTypes = append(allIterationTypes, iterationTypes);
        }

        const iterationTypes = allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes;
        setCachedIterationTypes(type, cacheKey, iterationTypes);
        return iterationTypes === noIterationTypes ? undefined : iterationTypes;
    }

    function getAsyncFromSyncIterationTypes(iterationTypes: IterationTypes, errorNode: Node | undefined) {
        if (iterationTypes === noIterationTypes) return noIterationTypes;
        if (iterationTypes === anyIterationTypes) return anyIterationTypes;
        const { yieldType, returnType, nextType } = iterationTypes;
        // if we're requesting diagnostics, report errors for a missing `Awaited<T>`.
        if (errorNode) {
            getGlobalAwaitedSymbol(/*reportErrors*/ true);
        }
        return createIterationTypes(
            getAwaitedType(yieldType, errorNode) || anyType,
            getAwaitedType(returnType, errorNode) || anyType,
            nextType,
        );
    }

    /**
     * Gets the *yield*, *return*, and *next* types from a non-union type.
     *
     * If we are unable to find the *yield*, *return*, and *next* types, `noIterationTypes` is
     * returned to indicate to the caller that it should report an error. Otherwise, an
     * `IterationTypes` record is returned.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterable` instead.
     */
    function getIterationTypesOfIterableWorker(type: Type, use: IterationUse, errorNode: Node | undefined, errorOutputContainer: ErrorOutputContainer | undefined) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }

        // If we are reporting errors and encounter a cached `noIterationTypes`, we should ignore the cached value and continue as if nothing was cached.
        // In addition, we should not cache any new results for this call.
        let noCache = false;

        if (use & IterationUse.AllowsAsyncIterablesFlag) {
            const iterationTypes = getIterationTypesOfIterableCached(type, asyncIterationTypesResolver) ||
                getIterationTypesOfIterableFast(type, asyncIterationTypesResolver);
            if (iterationTypes) {
                if (iterationTypes === noIterationTypes && errorNode) {
                    // ignore the cached value
                    noCache = true;
                }
                else {
                    return use & IterationUse.ForOfFlag ?
                        getAsyncFromSyncIterationTypes(iterationTypes, errorNode) :
                        iterationTypes;
                }
            }
        }

        if (use & IterationUse.AllowsSyncIterablesFlag) {
            let iterationTypes = getIterationTypesOfIterableCached(type, syncIterationTypesResolver) ||
                getIterationTypesOfIterableFast(type, syncIterationTypesResolver);
            if (iterationTypes) {
                if (iterationTypes === noIterationTypes && errorNode) {
                    // ignore the cached value
                    noCache = true;
                }
                else {
                    if (use & IterationUse.AllowsAsyncIterablesFlag) {
                        // for a sync iterable in an async context, only use the cached types if they are valid.
                        if (iterationTypes !== noIterationTypes) {
                            iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode);
                            return noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes);
                        }
                    }
                    else {
                        return iterationTypes;
                    }
                }
            }
        }

        if (use & IterationUse.AllowsAsyncIterablesFlag) {
            const iterationTypes = getIterationTypesOfIterableSlow(type, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache);
            if (iterationTypes !== noIterationTypes) {
                return iterationTypes;
            }
        }

        if (use & IterationUse.AllowsSyncIterablesFlag) {
            let iterationTypes = getIterationTypesOfIterableSlow(type, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache);
            if (iterationTypes !== noIterationTypes) {
                if (use & IterationUse.AllowsAsyncIterablesFlag) {
                    iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode);
                    return noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes);
                }
                else {
                    return iterationTypes;
                }
            }
        }

        return noIterationTypes;
    }

    /**
     * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or
     * `AsyncIterable`-like type from the cache.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterable` instead.
     */
    function getIterationTypesOfIterableCached(type: Type, resolver: IterationTypesResolver) {
        return getCachedIterationTypes(type, resolver.iterableCacheKey);
    }

    /**
     * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
     * type from from common heuristics.
     *
     * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
     * returned. If we found iteration types, an `IterationTypes` record is returned.
     * Otherwise, we return `undefined` to indicate to the caller it should perform a more
     * exhaustive analysis.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterable` instead.
     */
    function getIterationTypesOfIterableFast(type: Type, resolver: IterationTypesResolver) {
        // As an optimization, if the type is an instantiation of the following global type, then
        // just grab its related type arguments:
        // - `Iterable<T, TReturn, TNext>` or `AsyncIterable<T, TReturn, TNext>`
        // - `IteratorObject<T, TReturn, TNext>` or `AsyncIteratorObject<T, TReturn, TNext>`
        // - `IterableIterator<T, TReturn, TNext>` or `AsyncIterableIterator<T, TReturn, TNext>`
        // - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
        if (
            isReferenceToType(type, resolver.getGlobalIterableType(/*reportErrors*/ false)) ||
            isReferenceToType(type, resolver.getGlobalIteratorObjectType(/*reportErrors*/ false)) ||
            isReferenceToType(type, resolver.getGlobalIterableIteratorType(/*reportErrors*/ false)) ||
            isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors*/ false))
        ) {
            const [yieldType, returnType, nextType] = getTypeArguments(type as GenericType);
            return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || yieldType, resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || returnType, nextType));
        }

        // As an optimization, if the type is an instantiation of one of the following global types, then
        // just grab the related type argument:
        // - `ArrayIterator<T>`
        // - `MapIterator<T>`
        // - `SetIterator<T>`
        // - `StringIterator<T>`
        // - `ReadableStreamAsyncIterator<T>`
        if (isReferenceToSomeType(type, resolver.getGlobalBuiltinIteratorTypes())) {
            const [yieldType] = getTypeArguments(type as GenericType);
            const returnType = getBuiltinIteratorReturnType();
            const nextType = unknownType;
            return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || yieldType, resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || returnType, nextType));
        }
    }

    function getPropertyNameForKnownSymbolName(symbolName: string): __String {
        const ctorType = getGlobalESSymbolConstructorSymbol(/*reportErrors*/ false);
        const uniqueType = ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName));
        return uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : `__@${symbolName}` as __String;
    }

    /**
     * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
     * type from its members.
     *
     * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
     * record is returned. Otherwise, `noIterationTypes` is returned.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterable` instead.
     */
    function getIterationTypesOfIterableSlow(type: Type, resolver: IterationTypesResolver, errorNode: Node | undefined, errorOutputContainer: ErrorOutputContainer | undefined, noCache: boolean) {
        const method = getPropertyOfType(type, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName));
        const methodType = method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(method) : undefined;
        if (isTypeAny(methodType)) {
            return noCache ? anyIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes);
        }

        const allSignatures = methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : undefined;
        const validSignatures = filter(allSignatures, sig => getMinArgumentCount(sig) === 0);
        if (!some(validSignatures)) {
            if (errorNode && some(allSignatures)) {
                checkTypeAssignableTo(type, resolver.getGlobalIterableType(/*reportErrors*/ true), errorNode, /*headMessage*/ undefined, /*containingMessageChain*/ undefined, errorOutputContainer);
            }
            return noCache ? noIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes);
        }

        const iteratorType = getIntersectionType(map(validSignatures, getReturnTypeOfSignature));
        const iterationTypes = getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes;
        return noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes);
    }

    function reportTypeNotIterableError(errorNode: Node, type: Type, allowAsyncIterables: boolean): Diagnostic {
        const message = allowAsyncIterables
            ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator
            : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator;
        const suggestAwait =
            // for (const x of Promise<...>) or [...Promise<...>]
            !!getAwaitedTypeOfPromise(type)
            // for (const x of AsyncIterable<...>)
            || (
                !allowAsyncIterables &&
                isForOfStatement(errorNode.parent) &&
                errorNode.parent.expression === errorNode &&
                getGlobalAsyncIterableType(/*reportErrors*/ false) !== emptyGenericType &&
                isTypeAssignableTo(type, createTypeFromGenericGlobalType(getGlobalAsyncIterableType(/*reportErrors*/ false), [anyType, anyType, anyType]))
            );
        return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type));
    }

    /**
     * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
     *
     * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
     * record is returned. Otherwise, `undefined` is returned.
     */
    function getIterationTypesOfIterator(type: Type, resolver: IterationTypesResolver, errorNode: Node | undefined, errorOutputContainer: ErrorOutputContainer | undefined) {
        return getIterationTypesOfIteratorWorker(type, resolver, errorNode, errorOutputContainer, /*noCache*/ false);
    }

    /**
     * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
     *
     * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
     * record is returned. Otherwise, `undefined` is returned.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterator` instead.
     */
    function getIterationTypesOfIteratorWorker(type: Type, resolver: IterationTypesResolver, errorNode: Node | undefined, errorOutputContainer: ErrorOutputContainer | undefined, noCache: boolean) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }

        let iterationTypes = getIterationTypesOfIteratorCached(type, resolver) ||
            getIterationTypesOfIteratorFast(type, resolver);

        if (iterationTypes === noIterationTypes && errorNode) {
            iterationTypes = undefined;
            noCache = true;
        }

        iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache);
        return iterationTypes === noIterationTypes ? undefined : iterationTypes;
    }

    /**
     * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
     * cache.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterator` instead.
     */
    function getIterationTypesOfIteratorCached(type: Type, resolver: IterationTypesResolver) {
        return getCachedIterationTypes(type, resolver.iteratorCacheKey);
    }

    /**
     * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
     * cache or from common heuristics.
     *
     * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
     * returned. If we found iteration types, an `IterationTypes` record is returned.
     * Otherwise, we return `undefined` to indicate to the caller it should perform a more
     * exhaustive analysis.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterator` instead.
     */
    function getIterationTypesOfIteratorFast(type: Type, resolver: IterationTypesResolver) {
        // As an optimization, if the type is an instantiation of one of the following global types,
        // then just grab its related type arguments:
        // - `IterableIterator<T, TReturn, TNext>` or `AsyncIterableIterator<T, TReturn, TNext>`
        // - `IteratorObject<T, TReturn, TNext>` or `AsyncIteratorObject<T, TReturn, TNext>`
        // - `Iterator<T, TReturn, TNext>` or `AsyncIterator<T, TReturn, TNext>`
        // - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
        if (
            isReferenceToType(type, resolver.getGlobalIterableIteratorType(/*reportErrors*/ false)) ||
            isReferenceToType(type, resolver.getGlobalIteratorType(/*reportErrors*/ false)) ||
            isReferenceToType(type, resolver.getGlobalIteratorObjectType(/*reportErrors*/ false)) ||
            isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors*/ false))
        ) {
            const [yieldType, returnType, nextType] = getTypeArguments(type as GenericType);
            return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
        }

        // As an optimization, if the type is an instantiation of one of the following global types, then
        // just grab the related type argument:
        // - `ArrayIterator<T>`
        // - `MapIterator<T>`
        // - `SetIterator<T>`
        // - `StringIterator<T>`
        // - `ReadableStreamAsyncIterator<T>`
        if (isReferenceToSomeType(type, resolver.getGlobalBuiltinIteratorTypes())) {
            const [yieldType] = getTypeArguments(type as GenericType);
            const returnType = getBuiltinIteratorReturnType();
            const nextType = unknownType;
            return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
        }
    }

    function isIteratorResult(type: Type, kind: IterationTypeKind.Yield | IterationTypeKind.Return) {
        // From https://tc39.github.io/ecma262/#sec-iteratorresult-interface:
        // > [done] is the result status of an iterator `next` method call. If the end of the iterator was reached `done` is `true`.
        // > If the end was not reached `done` is `false` and a value is available.
        // > If a `done` property (either own or inherited) does not exist, it is consider to have the value `false`.
        const doneType = getTypeOfPropertyOfType(type, "done" as __String) || falseType;
        return isTypeAssignableTo(kind === IterationTypeKind.Yield ? falseType : trueType, doneType);
    }

    function isYieldIteratorResult(type: Type) {
        return isIteratorResult(type, IterationTypeKind.Yield);
    }

    function isReturnIteratorResult(type: Type) {
        return isIteratorResult(type, IterationTypeKind.Return);
    }

    /**
     * Gets the *yield* and *return* types of an `IteratorResult`-like type.
     *
     * If we are unable to determine a *yield* or a *return* type, `noIterationTypes` is
     * returned to indicate to the caller that it should handle the error. Otherwise, an
     * `IterationTypes` record is returned.
     */
    function getIterationTypesOfIteratorResult(type: Type) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }

        const cachedTypes = getCachedIterationTypes(type, "iterationTypesOfIteratorResult");
        if (cachedTypes) {
            return cachedTypes;
        }

        // As an optimization, if the type is an instantiation of one of the global `IteratorYieldResult<T>`
        // or `IteratorReturnResult<TReturn>` types, then just grab its type argument.
        if (isReferenceToType(type, getGlobalIteratorYieldResultType(/*reportErrors*/ false))) {
            const yieldType = getTypeArguments(type as GenericType)[0];
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, /*returnType*/ undefined, /*nextType*/ undefined));
        }
        if (isReferenceToType(type, getGlobalIteratorReturnResultType(/*reportErrors*/ false))) {
            const returnType = getTypeArguments(type as GenericType)[0];
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(/*yieldType*/ undefined, returnType, /*nextType*/ undefined));
        }

        // Choose any constituents that can produce the requested iteration type.
        const yieldIteratorResult = filterType(type, isYieldIteratorResult);
        const yieldType = yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value" as __String) : undefined;

        const returnIteratorResult = filterType(type, isReturnIteratorResult);
        const returnType = returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value" as __String) : undefined;

        if (!yieldType && !returnType) {
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", noIterationTypes);
        }

        // From https://tc39.github.io/ecma262/#sec-iteratorresult-interface
        // > ... If the iterator does not have a return value, `value` is `undefined`. In that case, the
        // > `value` property may be absent from the conforming object if it does not inherit an explicit
        // > `value` property.
        return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, /*nextType*/ undefined));
    }

    /**
     * Gets the *yield*, *return*, and *next* types of a the `next()`, `return()`, or
     * `throw()` method of an `Iterator`-like or `AsyncIterator`-like type.
     *
     * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
     * record is returned. Otherwise, we return `undefined`.
     */
    function getIterationTypesOfMethod(type: Type, resolver: IterationTypesResolver, methodName: "next" | "return" | "throw", errorNode: Node | undefined, errorOutputContainer: ErrorOutputContainer | undefined): IterationTypes | undefined {
        const method = getPropertyOfType(type, methodName as __String);

        // Ignore 'return' or 'throw' if they are missing.
        if (!method && methodName !== "next") {
            return undefined;
        }

        const methodType = method && !(methodName === "next" && (method.flags & SymbolFlags.Optional))
            ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), TypeFacts.NEUndefinedOrNull)
            : undefined;

        if (isTypeAny(methodType)) {
            return anyIterationTypes;
        }

        // Both async and non-async iterators *must* have a `next` method.
        const methodSignatures = methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : emptyArray;
        if (methodSignatures.length === 0) {
            if (errorNode) {
                const diagnostic = methodName === "next"
                    ? resolver.mustHaveANextMethodDiagnostic
                    : resolver.mustBeAMethodDiagnostic;
                if (errorOutputContainer) {
                    errorOutputContainer.errors ??= [];
                    errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName));
                }
                else {
                    error(errorNode, diagnostic, methodName);
                }
            }
            return methodName === "next" ? noIterationTypes : undefined;
        }

        // If the method signature comes exclusively from the global iterator or generator type,
        // create iteration types from its type arguments like `getIterationTypesOfIteratorFast`
        // does (so as to remove `undefined` from the next and return types). We arrive here when
        // a contextual type for a generator was not a direct reference to one of those global types,
        // but looking up `methodType` referred to one of them (and nothing else). E.g., in
        // `interface SpecialIterator extends Iterator<number> {}`, `SpecialIterator` is not a
        // reference to `Iterator`, but its `next` member derives exclusively from `Iterator`.
        if (methodType?.symbol && methodSignatures.length === 1) {
            const globalGeneratorType = resolver.getGlobalGeneratorType(/*reportErrors*/ false);
            const globalIteratorType = resolver.getGlobalIteratorType(/*reportErrors*/ false);
            const isGeneratorMethod = globalGeneratorType.symbol?.members?.get(methodName as __String) === methodType.symbol;
            const isIteratorMethod = !isGeneratorMethod && globalIteratorType.symbol?.members?.get(methodName as __String) === methodType.symbol;
            if (isGeneratorMethod || isIteratorMethod) {
                const globalType = isGeneratorMethod ? globalGeneratorType : globalIteratorType;
                const { mapper } = methodType as AnonymousType;
                return createIterationTypes(
                    getMappedType(globalType.typeParameters![0], mapper!),
                    getMappedType(globalType.typeParameters![1], mapper!),
                    methodName === "next" ? getMappedType(globalType.typeParameters![2], mapper!) : undefined,
                );
            }
        }

        // Extract the first parameter and return type of each signature.
        let methodParameterTypes: Type[] | undefined;
        let methodReturnTypes: Type[] | undefined;
        for (const signature of methodSignatures) {
            if (methodName !== "throw" && some(signature.parameters)) {
                methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0));
            }
            methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature));
        }

        // Resolve the *next* or *return* type from the first parameter of a `next()` or
        // `return()` method, respectively.
        let returnTypes: Type[] | undefined;
        let nextType: Type | undefined;
        if (methodName !== "throw") {
            const methodParameterType = methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType;
            if (methodName === "next") {
                // The value of `next(value)` is *not* awaited by async generators
                nextType = methodParameterType;
            }
            else if (methodName === "return") {
                // The value of `return(value)` *is* awaited by async generators
                const resolvedMethodParameterType = resolver.resolveIterationType(methodParameterType, errorNode) || anyType;
                returnTypes = append(returnTypes, resolvedMethodParameterType);
            }
        }

        // Resolve the *yield* and *return* types from the return type of the method (i.e. `IteratorResult`)
        let yieldType: Type;
        const methodReturnType = methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType;
        const resolvedMethodReturnType = resolver.resolveIterationType(methodReturnType, errorNode) || anyType;
        const iterationTypes = getIterationTypesOfIteratorResult(resolvedMethodReturnType);
        if (iterationTypes === noIterationTypes) {
            if (errorNode) {
                if (errorOutputContainer) {
                    errorOutputContainer.errors ??= [];
                    errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName));
                }
                else {
                    error(errorNode, resolver.mustHaveAValueDiagnostic, methodName);
                }
            }
            yieldType = anyType;
            returnTypes = append(returnTypes, anyType);
        }
        else {
            yieldType = iterationTypes.yieldType;
            returnTypes = append(returnTypes, iterationTypes.returnType);
        }

        return createIterationTypes(yieldType, getUnionType(returnTypes), nextType);
    }

    /**
     * Gets the *yield*, *return*, and *next* types of an `Iterator`-like or `AsyncIterator`-like
     * type from its members.
     *
     * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
     * record is returned. Otherwise, `noIterationTypes` is returned.
     *
     * NOTE: You probably don't want to call this directly and should be calling
     * `getIterationTypesOfIterator` instead.
     */
    function getIterationTypesOfIteratorSlow(type: Type, resolver: IterationTypesResolver, errorNode: Node | undefined, errorOutputContainer: ErrorOutputContainer | undefined, noCache: boolean) {
        const iterationTypes = combineIterationTypes([
            getIterationTypesOfMethod(type, resolver, "next", errorNode, errorOutputContainer),
            getIterationTypesOfMethod(type, resolver, "return", errorNode, errorOutputContainer),
            getIterationTypesOfMethod(type, resolver, "throw", errorNode, errorOutputContainer),
        ]);
        return noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes);
    }

    /**
     * Gets the requested "iteration type" from a type that is either `Iterable`-like, `Iterator`-like,
     * `IterableIterator`-like, or `Generator`-like (for a non-async generator); or `AsyncIterable`-like,
     * `AsyncIterator`-like, `AsyncIterableIterator`-like, or `AsyncGenerator`-like (for an async generator).
     */
    function getIterationTypeOfGeneratorFunctionReturnType(kind: IterationTypeKind, returnType: Type, isAsyncGenerator: boolean): Type | undefined {
        if (isTypeAny(returnType)) {
            return undefined;
        }

        const iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator);
        return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)];
    }

    function getIterationTypesOfGeneratorFunctionReturnType(type: Type, isAsyncGenerator: boolean) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }

        const use = isAsyncGenerator ? IterationUse.AsyncGeneratorReturnType : IterationUse.GeneratorReturnType;
        const resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
        return getIterationTypesOfIterable(type, use, /*errorNode*/ undefined) ||
            getIterationTypesOfIterator(type, resolver, /*errorNode*/ undefined, /*errorOutputContainer*/ undefined);
    }

    function checkBreakOrContinueStatement(node: BreakOrContinueStatement) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) checkGrammarBreakOrContinueStatement(node);

        // TODO: Check that target label is valid
    }

    function unwrapReturnType(returnType: Type, functionFlags: FunctionFlags) {
        const isGenerator = !!(functionFlags & FunctionFlags.Generator);
        const isAsync = !!(functionFlags & FunctionFlags.Async);
        if (isGenerator) {
            const returnIterationType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, returnType, isAsync);
            if (!returnIterationType) {
                return errorType;
            }
            return isAsync ? getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType)) : returnIterationType;
        }
        return isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType;
    }

    function isUnwrappedReturnTypeUndefinedVoidOrAny(func: SignatureDeclaration, returnType: Type): boolean {
        const type = unwrapReturnType(returnType, getFunctionFlags(func));
        return !!(type && (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined)));
    }

    function checkReturnStatement(node: ReturnStatement) {
        // Grammar checking
        if (checkGrammarStatementInAmbientContext(node)) {
            return;
        }

        const container = getContainingFunctionOrClassStaticBlock(node);
        if (container && isClassStaticBlockDeclaration(container)) {
            grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block);
            return;
        }

        if (!container) {
            grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
            return;
        }

        const signature = getSignatureFromDeclaration(container);
        const returnType = getReturnTypeOfSignature(signature);
        if (strictNullChecks || node.expression || returnType.flags & TypeFlags.Never) {
            const exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
            if (container.kind === SyntaxKind.SetAccessor) {
                if (node.expression) {
                    error(node, Diagnostics.Setters_cannot_return_a_value);
                }
            }
            else if (container.kind === SyntaxKind.Constructor) {
                const exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
                if (node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression)) {
                    error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                }
            }
            else if (getReturnTypeFromAnnotation(container)) {
                const unwrappedReturnType = unwrapReturnType(returnType, getFunctionFlags(container)) ?? returnType;
                checkReturnExpression(container, unwrappedReturnType, node, node.expression, exprType);
            }
        }
        else if (container.kind !== SyntaxKind.Constructor && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType)) {
            // The function has a return type, but the return statement doesn't have an expression.
            error(node, Diagnostics.Not_all_code_paths_return_a_value);
        }
    }

    // When checking an arrow expression such as `(x) => exp`, then `node` is the expression `exp`.
    // Otherwise, `node` is a return statement.
    function checkReturnExpression(
        container: SignatureDeclaration,
        unwrappedReturnType: Type,
        node: ReturnStatement | Expression,
        expr: Expression | undefined,
        exprType: Type,
        inConditionalExpression = false,
    ): void {
        const excludeJSDocTypeAssertions = isInJSFile(node);
        const functionFlags = getFunctionFlags(container);
        if (expr) {
            const unwrappedExpr = skipParentheses(expr, excludeJSDocTypeAssertions);
            if (isConditionalExpression(unwrappedExpr)) {
                checkReturnExpression(container, unwrappedReturnType, node, unwrappedExpr.whenTrue, checkExpression(unwrappedExpr.whenTrue), /*inConditionalExpression*/ true);
                checkReturnExpression(container, unwrappedReturnType, node, unwrappedExpr.whenFalse, checkExpression(unwrappedExpr.whenFalse), /*inConditionalExpression*/ true);
                return;
            }
        }

        const inReturnStatement = node.kind === SyntaxKind.ReturnStatement;
        const unwrappedExprType = functionFlags & FunctionFlags.Async
            ? checkAwaitedType(
                exprType,
                /*withAlias*/ false,
                node,
                Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
            )
            : exprType;

        const effectiveExpr = expr && getEffectiveCheckNode(expr); // The effective expression for diagnostics purposes.
        const errorNode = inReturnStatement && !inConditionalExpression ? node : effectiveExpr;

        checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, errorNode, effectiveExpr);
    }

    function checkWithStatement(node: WithStatement) {
        // Grammar checking for withStatement
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (node.flags & NodeFlags.AwaitContext) {
                grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block);
            }
        }

        checkExpression(node.expression);

        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            const start = getSpanOfTokenAtPosition(sourceFile, node.pos).start;
            const end = node.statement.pos;
            grammarErrorAtPos(sourceFile, start, end - start, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
        }
    }

    function checkSwitchStatement(node: SwitchStatement) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);

        let firstDefaultClause: CaseOrDefaultClause;
        let hasDuplicateDefaultClause = false;

        const expressionType = checkExpression(node.expression);

        forEach(node.caseBlock.clauses, clause => {
            // Grammar check for duplicate default clauses, skip if we already report duplicate default clause
            if (clause.kind === SyntaxKind.DefaultClause && !hasDuplicateDefaultClause) {
                if (firstDefaultClause === undefined) {
                    firstDefaultClause = clause;
                }
                else {
                    grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                    hasDuplicateDefaultClause = true;
                }
            }

            if (clause.kind === SyntaxKind.CaseClause) {
                addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause));
            }
            forEach(clause.statements, checkSourceElement);
            if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {
                error(clause, Diagnostics.Fallthrough_case_in_switch);
            }

            function createLazyCaseClauseDiagnostics(clause: CaseClause) {
                return () => {
                    // TypeScript 1.0 spec (April 2014): 5.9
                    // In a 'switch' statement, each 'case' expression must be of a type that is comparable
                    // to or from the type of the 'switch' expression.
                    const caseType = checkExpression(clause.expression);

                    if (!isTypeEqualityComparableTo(expressionType, caseType)) {
                        // expressionType is not comparable to caseType, try the reversed check and report errors if it fails
                        checkTypeComparableTo(caseType, expressionType, clause.expression, /*headMessage*/ undefined);
                    }
                };
            }
        });
        if (node.caseBlock.locals) {
            registerForUnusedIdentifiersCheck(node.caseBlock);
        }
    }

    function checkLabeledStatement(node: LabeledStatement) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) {
            findAncestor(node.parent, current => {
                if (isFunctionLike(current)) {
                    return "quit";
                }
                if (current.kind === SyntaxKind.LabeledStatement && (current as LabeledStatement).label.escapedText === node.label.escapedText) {
                    grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label));
                    return true;
                }
                return false;
            });
        }

        // ensure that label is unique
        checkSourceElement(node.statement);
    }

    function checkThrowStatement(node: ThrowStatement) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (isIdentifier(node.expression) && !node.expression.escapedText) {
                grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here);
            }
        }

        if (node.expression) {
            checkExpression(node.expression);
        }
    }

    function checkTryStatement(node: TryStatement) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);

        checkBlock(node.tryBlock);
        const catchClause = node.catchClause;
        if (catchClause) {
            // Grammar checking
            if (catchClause.variableDeclaration) {
                const declaration = catchClause.variableDeclaration;
                checkVariableLikeDeclaration(declaration);
                const typeNode = getEffectiveTypeAnnotationNode(declaration);
                if (typeNode) {
                    const type = getTypeFromTypeNode(typeNode);
                    if (type && !(type.flags & TypeFlags.AnyOrUnknown)) {
                        grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified);
                    }
                }
                else if (declaration.initializer) {
                    grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer);
                }
                else {
                    const blockLocals = catchClause.block.locals;
                    if (blockLocals) {
                        forEachKey(catchClause.locals!, caughtName => {
                            const blockLocal = blockLocals.get(caughtName);
                            if (blockLocal?.valueDeclaration && (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0) {
                                grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName));
                            }
                        });
                    }
                }
            }

            checkBlock(catchClause.block);
        }

        if (node.finallyBlock) {
            checkBlock(node.finallyBlock);
        }
    }

    function checkIndexConstraints(type: Type, symbol: Symbol, isStaticIndex?: boolean) {
        const indexInfos = getIndexInfosOfType(type);
        if (indexInfos.length === 0) {
            return;
        }
        for (const prop of getPropertiesOfObjectType(type)) {
            if (!(isStaticIndex && prop.flags & SymbolFlags.Prototype)) {
                checkIndexConstraintForProperty(type, prop, getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique, /*includeNonPublic*/ true), getNonMissingTypeOfSymbol(prop));
            }
        }
        const typeDeclaration = symbol.valueDeclaration;
        if (typeDeclaration && isClassLike(typeDeclaration)) {
            for (const member of typeDeclaration.members) {
                // Only process instance properties against instance index signatures and static properties against static index signatures
                if (
                    (
                        (!isStaticIndex && !isStatic(member)) ||
                        (isStaticIndex && isStatic(member))
                    ) && !hasBindableName(member)
                ) {
                    const symbol = getSymbolOfDeclaration(member);
                    checkIndexConstraintForProperty(type, symbol, getTypeOfExpression((member as DynamicNamedDeclaration).name.expression), getNonMissingTypeOfSymbol(symbol));
                }
            }
        }
        if (indexInfos.length > 1) {
            for (const info of indexInfos) {
                checkIndexConstraintForIndexSignature(type, info);
            }
        }
    }

    function checkIndexConstraintForProperty(type: Type, prop: Symbol, propNameType: Type, propType: Type) {
        const declaration = prop.valueDeclaration;
        const name = getNameOfDeclaration(declaration);
        if (name && isPrivateIdentifier(name)) {
            return;
        }
        const indexInfos = getApplicableIndexInfos(type, propNameType);
        const interfaceDeclaration = getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined;
        const propDeclaration = declaration && declaration.kind === SyntaxKind.BinaryExpression ||
                name && name.kind === SyntaxKind.ComputedPropertyName ? declaration : undefined;
        const localPropDeclaration = getParentOfSymbol(prop) === type.symbol ? declaration : undefined;
        for (const info of indexInfos) {
            const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined;
            // We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared
            // in the containing type, or (c) the containing type is an interface and no base interface contains both the property and
            // the index signature (i.e. property and index signature are declared in separate inherited interfaces).
            const errorNode = localPropDeclaration || localIndexDeclaration ||
                (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined);
            if (errorNode && !isTypeAssignableTo(propType, info.type)) {
                const diagnostic = createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type));
                if (propDeclaration && errorNode !== propDeclaration) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)));
                }
                diagnostics.add(diagnostic);
            }
        }
    }

    function checkIndexConstraintForIndexSignature(type: Type, checkInfo: IndexInfo) {
        const declaration = checkInfo.declaration;
        const indexInfos = getApplicableIndexInfos(type, checkInfo.keyType);
        const interfaceDeclaration = getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined;
        const localCheckDeclaration = declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : undefined;
        for (const info of indexInfos) {
            if (info === checkInfo) continue;
            const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined;
            // We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index
            // signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains
            // both index signatures (i.e. the index signatures are declared in separate inherited interfaces).
            const errorNode = localCheckDeclaration || localIndexDeclaration ||
                (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined);
            if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {
                error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type), typeToString(info.keyType), typeToString(info.type));
            }
        }
    }

    function checkTypeNameIsReserved(name: Identifier, message: DiagnosticMessage): void {
        // TS 1.0 spec (April 2014): 3.6.1
        // The predefined type keywords are reserved and cannot be used as names of user defined types.
        switch (name.escapedText) {
            case "any":
            case "unknown":
            case "never":
            case "number":
            case "bigint":
            case "boolean":
            case "string":
            case "symbol":
            case "void":
            case "object":
            case "undefined":
                error(name, message, name.escapedText as string);
        }
    }

    /**
     * The name cannot be used as 'Object' of user defined types with special target.
     */
    function checkClassNameCollisionWithObject(name: Identifier): void {
        if (
            languageVersion >= ScriptTarget.ES5 && name.escapedText === "Object"
            && host.getEmitModuleFormatOfFile(getSourceFileOfNode(name)) < ModuleKind.ES2015
        ) {
            error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ModuleKind[moduleKind]); // https://github.com/Microsoft/TypeScript/issues/17494
        }
    }

    function checkUnmatchedJSDocParameters(node: SignatureDeclaration) {
        const jsdocParameters = filter(getJSDocTags(node), isJSDocParameterTag);
        if (!length(jsdocParameters)) return;

        const isJs = isInJSFile(node);
        const parameters = new Set<__String>();
        const excludedParameters = new Set<number>();
        forEach(node.parameters, ({ name }, index) => {
            if (isIdentifier(name)) {
                parameters.add(name.escapedText);
            }
            if (isBindingPattern(name)) {
                excludedParameters.add(index);
            }
        });

        const containsArguments = containsArgumentsReference(node);
        if (containsArguments) {
            const lastJSDocParamIndex = jsdocParameters.length - 1;
            const lastJSDocParam = jsdocParameters[lastJSDocParamIndex];
            if (
                isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression &&
                lastJSDocParam.typeExpression.type && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type))
            ) {
                error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name));
            }
        }
        else {
            forEach(jsdocParameters, ({ name, isNameFirst }, index) => {
                if (excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText)) {
                    return;
                }
                if (isQualifiedName(name)) {
                    if (isJs) {
                        error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left));
                    }
                }
                else {
                    if (!isNameFirst) {
                        errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name));
                    }
                }
            });
        }
    }

    /**
     * Check each type parameter and check that type parameters have no duplicate type parameter declarations
     */
    function checkTypeParameters(typeParameterDeclarations: readonly TypeParameterDeclaration[] | undefined) {
        let seenDefault = false;
        if (typeParameterDeclarations) {
            for (let i = 0; i < typeParameterDeclarations.length; i++) {
                const node = typeParameterDeclarations[i];
                checkTypeParameter(node);

                addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));
            }
        }

        function createCheckTypeParameterDiagnostic(node: TypeParameterDeclaration, i: number) {
            return () => {
                if (node.default) {
                    seenDefault = true;
                    checkTypeParametersNotReferenced(node.default, typeParameterDeclarations!, i);
                }
                else if (seenDefault) {
                    error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
                }
                for (let j = 0; j < i; j++) {
                    if (typeParameterDeclarations![j].symbol === node.symbol) {
                        error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));
                    }
                }
            };
        }
    }

    /** Check that type parameter defaults only reference previously declared type parameters */
    function checkTypeParametersNotReferenced(root: TypeNode, typeParameters: readonly TypeParameterDeclaration[], index: number) {
        visit(root);
        function visit(node: Node) {
            if (node.kind === SyntaxKind.TypeReference) {
                const type = getTypeFromTypeReference(node as TypeReferenceNode);
                if (type.flags & TypeFlags.TypeParameter) {
                    for (let i = index; i < typeParameters.length; i++) {
                        if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {
                            error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);
                        }
                    }
                }
            }
            forEachChild(node, visit);
        }
    }

    /** Check that type parameter lists are identical across multiple declarations */
    function checkTypeParameterListsIdentical(symbol: Symbol) {
        if (symbol.declarations && symbol.declarations.length === 1) {
            return;
        }

        const links = getSymbolLinks(symbol);
        if (!links.typeParametersChecked) {
            links.typeParametersChecked = true;
            const declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
            if (!declarations || declarations.length <= 1) {
                return;
            }

            const type = getDeclaredTypeOfSymbol(symbol) as InterfaceType;
            if (!areTypeParametersIdentical(declarations, type.localTypeParameters!, getEffectiveTypeParameterDeclarations)) {
                // Report an error on every conflicting declaration.
                const name = symbolToString(symbol);
                for (const declaration of declarations) {
                    error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);
                }
            }
        }
    }

    function areTypeParametersIdentical<T extends DeclarationWithTypeParameters | TypeParameterDeclaration>(declarations: readonly T[], targetParameters: TypeParameter[], getTypeParameterDeclarations: (node: T) => readonly TypeParameterDeclaration[]) {
        const maxTypeArgumentCount = length(targetParameters);
        const minTypeArgumentCount = getMinTypeArgumentCount(targetParameters);

        for (const declaration of declarations) {
            // If this declaration has too few or too many type parameters, we report an error
            const sourceParameters = getTypeParameterDeclarations(declaration);
            const numTypeParameters = sourceParameters.length;
            if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {
                return false;
            }

            for (let i = 0; i < numTypeParameters; i++) {
                const source = sourceParameters[i];
                const target = targetParameters[i];

                // If the type parameter node does not have the same as the resolved type
                // parameter at this position, we report an error.
                if (source.name.escapedText !== target.symbol.escapedName) {
                    return false;
                }

                // If the type parameter node does not have an identical constraint as the resolved
                // type parameter at this position, we report an error.
                const constraint = getEffectiveConstraintOfTypeParameter(source);
                const sourceConstraint = constraint && getTypeFromTypeNode(constraint);
                const targetConstraint = getConstraintOfTypeParameter(target);
                // relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with
                // a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)
                if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {
                    return false;
                }

                // If the type parameter node has a default and it is not identical to the default
                // for the type parameter at this position, we report an error.
                const sourceDefault = source.default && getTypeFromTypeNode(source.default);
                const targetDefault = getDefaultFromTypeParameter(target);
                if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {
                    return false;
                }
            }
        }

        return true;
    }

    function getFirstTransformableStaticClassElement(node: ClassLikeDeclaration) {
        const willTransformStaticElementsOfDecoratedClass = !legacyDecorators && languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators &&
            classOrConstructorParameterIsDecorated(/*useLegacyDecorators*/ false, node);
        const willTransformPrivateElementsOrClassStaticBlocks = languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||
            languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators;
        const willTransformInitializers = !emitStandardClassFields;
        if (willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks) {
            for (const member of node.members) {
                if (willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(/*useLegacyDecorators*/ false, member, node)) {
                    return firstOrUndefined(getDecorators(node)) ?? node;
                }
                else if (willTransformPrivateElementsOrClassStaticBlocks) {
                    if (isClassStaticBlockDeclaration(member)) {
                        return member;
                    }
                    else if (isStatic(member)) {
                        if (
                            isPrivateIdentifierClassElementDeclaration(member) ||
                            willTransformInitializers && isInitializedProperty(member)
                        ) {
                            return member;
                        }
                    }
                }
            }
        }
    }

    function checkClassExpressionExternalHelpers(node: ClassExpression) {
        if (node.name) return;

        const parent = walkUpOuterExpressions(node);
        if (!isNamedEvaluationSource(parent)) return;

        const willTransformESDecorators = !legacyDecorators && languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators;
        let location: Node | undefined;
        if (willTransformESDecorators && classOrConstructorParameterIsDecorated(/*useLegacyDecorators*/ false, node)) {
            location = firstOrUndefined(getDecorators(node)) ?? node;
        }
        else {
            location = getFirstTransformableStaticClassElement(node);
        }

        if (location) {
            checkExternalEmitHelpers(location, ExternalEmitHelpers.SetFunctionName);
            if ((isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name)) {
                checkExternalEmitHelpers(location, ExternalEmitHelpers.PropKey);
            }
        }
    }

    function checkClassExpression(node: ClassExpression): Type {
        checkClassLikeDeclaration(node);
        checkNodeDeferred(node);
        checkClassExpressionExternalHelpers(node);
        return getTypeOfSymbol(getSymbolOfDeclaration(node));
    }

    function checkClassExpressionDeferred(node: ClassExpression) {
        forEach(node.members, checkSourceElement);
        registerForUnusedIdentifiersCheck(node);
    }

    function checkClassDeclaration(node: ClassDeclaration) {
        const firstDecorator = find(node.modifiers, isDecorator);
        if (legacyDecorators && firstDecorator && some(node.members, p => hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p))) {
            grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator);
        }
        if (!node.name && !hasSyntacticModifier(node, ModifierFlags.Default)) {
            grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name);
        }
        checkClassLikeDeclaration(node);
        forEach(node.members, checkSourceElement);

        registerForUnusedIdentifiersCheck(node);
    }

    function checkClassLikeDeclaration(node: ClassLikeDeclaration) {
        checkGrammarClassLikeDeclaration(node);
        checkDecorators(node);
        checkCollisionsForDeclarationName(node, node.name);
        checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
        checkExportsOnMergedDeclarations(node);
        const symbol = getSymbolOfDeclaration(node);
        const type = getDeclaredTypeOfSymbol(symbol) as InterfaceType;
        const typeWithThis = getTypeWithThisArgument(type);
        const staticType = getTypeOfSymbol(symbol) as ObjectType;
        checkTypeParameterListsIdentical(symbol);
        checkFunctionOrConstructorSymbol(symbol);
        checkClassForDuplicateDeclarations(node);

        // Only check for reserved static identifiers on non-ambient context.
        const nodeInAmbientContext = !!(node.flags & NodeFlags.Ambient);
        if (!nodeInAmbientContext) {
            checkClassForStaticPropertyNameConflicts(node);
        }

        const baseTypeNode = getEffectiveBaseTypeNode(node);
        if (baseTypeNode) {
            forEach(baseTypeNode.typeArguments, checkSourceElement);
            if (languageVersion < LanguageFeatureMinimumTarget.Classes) {
                checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpers.Extends);
            }
            // check both @extends and extends if both are specified.
            const extendsNode = getClassExtendsHeritageElement(node);
            if (extendsNode && extendsNode !== baseTypeNode) {
                checkExpression(extendsNode.expression);
            }

            const baseTypes = getBaseTypes(type);
            if (baseTypes.length) {
                addLazyDiagnostic(() => {
                    const baseType = baseTypes[0];
                    const baseConstructorType = getBaseConstructorTypeOfClass(type);
                    const staticBaseType = getApparentType(baseConstructorType);
                    checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
                    checkSourceElement(baseTypeNode.expression);
                    if (some(baseTypeNode.typeArguments)) {
                        forEach(baseTypeNode.typeArguments, checkSourceElement);
                        for (const constructor of getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)) {
                            if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters!)) {
                                break;
                            }
                        }
                    }
                    const baseWithThis = getTypeWithThisArgument(baseType, type.thisType);
                    if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
                        issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1);
                    }
                    else {
                        // Report static side error only when instance type is assignable
                        checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                    }
                    if (baseConstructorType.flags & TypeFlags.TypeVariable) {
                        if (!isMixinConstructorType(staticType)) {
                            error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
                        }
                        else {
                            const constructSignatures = getSignaturesOfType(baseConstructorType, SignatureKind.Construct);
                            if (constructSignatures.some(signature => signature.flags & SignatureFlags.Abstract) && !hasSyntacticModifier(node, ModifierFlags.Abstract)) {
                                error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);
                            }
                        }
                    }

                    if (!(staticBaseType.symbol && staticBaseType.symbol.flags & SymbolFlags.Class) && !(baseConstructorType.flags & TypeFlags.TypeVariable)) {
                        // When the static base type is a "class-like" constructor function (but not actually a class), we verify
                        // that all instantiated base constructor signatures return the same type.
                        const constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
                        if (forEach(constructors, sig => !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType))) {
                            error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);
                        }
                    }
                    checkKindsOfPropertyMemberOverrides(type, baseType);
                });
            }
        }

        checkMembersForOverrideModifier(node, type, typeWithThis, staticType);

        const implementedTypeNodes = getEffectiveImplementsTypeNodes(node);
        if (implementedTypeNodes) {
            for (const typeRefNode of implementedTypeNodes) {
                if (!isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression)) {
                    error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
                }
                checkTypeReferenceNode(typeRefNode);
                addLazyDiagnostic(createImplementsDiagnostics(typeRefNode));
            }
        }

        addLazyDiagnostic(() => {
            checkIndexConstraints(type, symbol);
            checkIndexConstraints(staticType, symbol, /*isStaticIndex*/ true);
            checkTypeForDuplicateIndexSignatures(node);
            checkPropertyInitialization(node);
        });

        function createImplementsDiagnostics(typeRefNode: ExpressionWithTypeArguments) {
            return () => {
                const t = getReducedType(getTypeFromTypeNode(typeRefNode));
                if (!isErrorType(t)) {
                    if (isValidBaseType(t)) {
                        const genericDiag = t.symbol && t.symbol.flags & SymbolFlags.Class ?
                            Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :
                            Diagnostics.Class_0_incorrectly_implements_interface_1;
                        const baseWithThis = getTypeWithThisArgument(t, type.thisType);
                        if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
                            issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);
                        }
                    }
                    else {
                        error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                    }
                }
            };
        }
    }

    function checkMembersForOverrideModifier(node: ClassLikeDeclaration, type: InterfaceType, typeWithThis: Type, staticType: ObjectType) {
        const baseTypeNode = getEffectiveBaseTypeNode(node);
        const baseTypes = baseTypeNode && getBaseTypes(type);
        const baseWithThis = baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined;
        const baseStaticType = getBaseConstructorTypeOfClass(type);

        for (const member of node.members) {
            if (hasAmbientModifier(member)) {
                continue;
            }

            if (isConstructorDeclaration(member)) {
                forEach(member.parameters, param => {
                    if (isParameterPropertyDeclaration(param, member)) {
                        checkExistingMemberForOverrideModifier(
                            node,
                            staticType,
                            baseStaticType,
                            baseWithThis,
                            type,
                            typeWithThis,
                            param,
                            /*memberIsParameterProperty*/ true,
                        );
                    }
                });
            }
            checkExistingMemberForOverrideModifier(
                node,
                staticType,
                baseStaticType,
                baseWithThis,
                type,
                typeWithThis,
                member,
                /*memberIsParameterProperty*/ false,
            );
        }
    }

    /**
     * @param member Existing member node to be checked.
     * Note: `member` cannot be a synthetic node.
     */
    function checkExistingMemberForOverrideModifier(
        node: ClassLikeDeclaration,
        staticType: ObjectType,
        baseStaticType: Type,
        baseWithThis: Type | undefined,
        type: InterfaceType,
        typeWithThis: Type,
        member: ClassElement | ParameterPropertyDeclaration,
        memberIsParameterProperty: boolean,
        reportErrors = true,
    ): MemberOverrideStatus {
        const declaredProp = member.name
                && getSymbolAtLocation(member.name)
            || getSymbolAtLocation(member);
        if (!declaredProp) {
            return MemberOverrideStatus.Ok;
        }

        return checkMemberForOverrideModifier(
            node,
            staticType,
            baseStaticType,
            baseWithThis,
            type,
            typeWithThis,
            hasOverrideModifier(member),
            hasAbstractModifier(member),
            isStatic(member),
            memberIsParameterProperty,
            declaredProp,
            reportErrors ? member : undefined,
        );
    }

    /**
     * Checks a class member declaration for either a missing or an invalid `override` modifier.
     * Note: this function can be used for speculative checking,
     * i.e. checking a member that does not yet exist in the program.
     * An example of that would be to call this function in a completions scenario,
     * when offering a method declaration as completion.
     * @param errorNode The node where we should report an error, or undefined if we should not report errors.
     */
    function checkMemberForOverrideModifier(
        node: ClassLikeDeclaration,
        staticType: ObjectType,
        baseStaticType: Type,
        baseWithThis: Type | undefined,
        type: InterfaceType,
        typeWithThis: Type,
        memberHasOverrideModifier: boolean,
        memberHasAbstractModifier: boolean,
        memberIsStatic: boolean,
        memberIsParameterProperty: boolean,
        member: Symbol,
        errorNode?: Node,
    ): MemberOverrideStatus {
        const isJs = isInJSFile(node);
        const nodeInAmbientContext = !!(node.flags & NodeFlags.Ambient);
        if (memberHasOverrideModifier && member?.valueDeclaration && isClassElement(member.valueDeclaration) && member.valueDeclaration.name && isNonBindableDynamicName(member.valueDeclaration.name)) {
            error(
                errorNode,
                isJs ?
                    Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_name_is_dynamic :
                    Diagnostics.This_member_cannot_have_an_override_modifier_because_its_name_is_dynamic,
            );
            return MemberOverrideStatus.HasInvalidOverride;
        }
        if (baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride)) {
            const thisType = memberIsStatic ? staticType : typeWithThis;
            const baseType = memberIsStatic ? baseStaticType : baseWithThis;
            const prop = getPropertyOfType(thisType, member.escapedName);
            const baseProp = getPropertyOfType(baseType, member.escapedName);

            const baseClassName = typeToString(baseWithThis);
            if (prop && !baseProp && memberHasOverrideModifier) {
                if (errorNode) {
                    const suggestion = getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType); // Again, using symbol name: note that's different from `symbol.escapedName`
                    suggestion ?
                        error(
                            errorNode,
                            isJs ?
                                Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 :
                                Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1,
                            baseClassName,
                            symbolToString(suggestion),
                        ) :
                        error(
                            errorNode,
                            isJs ?
                                Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 :
                                Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,
                            baseClassName,
                        );
                }
                return MemberOverrideStatus.HasInvalidOverride;
            }
            else if (prop && baseProp?.declarations && compilerOptions.noImplicitOverride && !nodeInAmbientContext) {
                const baseHasAbstract = some(baseProp.declarations, hasAbstractModifier);
                if (memberHasOverrideModifier) {
                    return MemberOverrideStatus.Ok;
                }

                if (!baseHasAbstract) {
                    if (errorNode) {
                        const diag = memberIsParameterProperty ?
                            isJs ?
                                Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :
                                Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 :
                            isJs ?
                            Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :
                            Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0;
                        error(errorNode, diag, baseClassName);
                    }
                    return MemberOverrideStatus.NeedsOverride;
                }
                else if (memberHasAbstractModifier && baseHasAbstract) {
                    if (errorNode) {
                        error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName);
                    }
                    return MemberOverrideStatus.NeedsOverride;
                }
            }
        }
        else if (memberHasOverrideModifier) {
            if (errorNode) {
                const className = typeToString(type);
                error(
                    errorNode,
                    isJs ?
                        Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class :
                        Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class,
                    className,
                );
            }
            return MemberOverrideStatus.HasInvalidOverride;
        }

        return MemberOverrideStatus.Ok;
    }

    function issueMemberSpecificError(node: ClassLikeDeclaration, typeWithThis: Type, baseWithThis: Type, broadDiag: DiagnosticMessage) {
        // iterate over all implemented properties and issue errors on each one which isn't compatible, rather than the class as a whole, if possible
        let issuedMemberError = false;
        for (const member of node.members) {
            if (isStatic(member)) {
                continue;
            }
            const declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
            if (declaredProp) {
                const prop = getPropertyOfType(typeWithThis, declaredProp.escapedName);
                const baseProp = getPropertyOfType(baseWithThis, declaredProp.escapedName);
                if (prop && baseProp) {
                    const rootChain = () =>
                        chainDiagnosticMessages(
                            /*details*/ undefined,
                            Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,
                            symbolToString(declaredProp),
                            typeToString(typeWithThis),
                            typeToString(baseWithThis),
                        );
                    if (!checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, /*headMessage*/ undefined, rootChain)) {
                        issuedMemberError = true;
                    }
                }
            }
        }
        if (!issuedMemberError) {
            // check again with diagnostics to generate a less-specific error
            checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag);
        }
    }

    function checkBaseTypeAccessibility(type: Type, node: ExpressionWithTypeArguments) {
        const signatures = getSignaturesOfType(type, SignatureKind.Construct);
        if (signatures.length) {
            const declaration = signatures[0].declaration;
            if (declaration && hasEffectiveModifier(declaration, ModifierFlags.Private)) {
                const typeClassDeclaration = getClassLikeDeclarationOfSymbol(type.symbol)!;
                if (!isNodeWithinClass(node, typeClassDeclaration)) {
                    error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
                }
            }
        }
    }

    /**
     * Checks a member declaration node to see if has a missing or invalid `override` modifier.
     * @param node Class-like node where the member is declared.
     * @param member Member declaration node.
     * @param memberSymbol Member symbol.
     * Note: `member` can be a synthetic node without a parent.
     */
    function getMemberOverrideModifierStatus(node: ClassLikeDeclaration, member: ClassElement, memberSymbol: Symbol): MemberOverrideStatus {
        if (!member.name) {
            return MemberOverrideStatus.Ok;
        }

        const classSymbol = getSymbolOfDeclaration(node);
        const type = getDeclaredTypeOfSymbol(classSymbol) as InterfaceType;
        const typeWithThis = getTypeWithThisArgument(type);
        const staticType = getTypeOfSymbol(classSymbol) as ObjectType;

        const baseTypeNode = getEffectiveBaseTypeNode(node);
        const baseTypes = baseTypeNode && getBaseTypes(type);
        const baseWithThis = baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined;
        const baseStaticType = getBaseConstructorTypeOfClass(type);

        const memberHasOverrideModifier = member.parent
            ? hasOverrideModifier(member)
            : hasSyntacticModifier(member, ModifierFlags.Override);

        return checkMemberForOverrideModifier(
            node,
            staticType,
            baseStaticType,
            baseWithThis,
            type,
            typeWithThis,
            memberHasOverrideModifier,
            hasAbstractModifier(member),
            isStatic(member),
            /*memberIsParameterProperty*/ false,
            memberSymbol,
        );
    }

    function getTargetSymbol(s: Symbol) {
        // if symbol is instantiated its flags are not copied from the 'target'
        // so we'll need to get back original 'target' symbol to work with correct set of flags
        // NOTE: cast to TransientSymbol should be safe because only TransientSymbols have CheckFlags.Instantiated
        return getCheckFlags(s) & CheckFlags.Instantiated ? (s as TransientSymbol).links.target! : s;
    }

    function getClassOrInterfaceDeclarationsOfSymbol(symbol: Symbol) {
        return filter(symbol.declarations, (d: Declaration): d is ClassDeclaration | InterfaceDeclaration => d.kind === SyntaxKind.ClassDeclaration || d.kind === SyntaxKind.InterfaceDeclaration);
    }

    function checkKindsOfPropertyMemberOverrides(type: InterfaceType, baseType: BaseType): void {
        // TypeScript 1.0 spec (April 2014): 8.2.3
        // A derived class inherits all members from its base class it doesn't override.
        // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
        // Both public and private property members are inherited, but only public property members can be overridden.
        // A property member in a derived class is said to override a property member in a base class
        // when the derived class property member has the same name and kind(instance or static)
        // as the base class property member.
        // The type of an overriding property member must be assignable(section 3.8.4)
        // to the type of the overridden property member, or otherwise a compile - time error occurs.
        // Base class instance member functions can be overridden by derived class instance member functions,
        // but not by other kinds of members.
        // Base class instance member variables and accessors can be overridden by
        // derived class instance member variables and accessors, but not by other kinds of members.

        // NOTE: assignability is checked in checkClassDeclaration
        const baseProperties = getPropertiesOfType(baseType);

        interface MemberInfo {
            missedProperties: string[];
            baseTypeName: string;
            typeName: string;
        }
        const notImplementedInfo = new Map<ClassLikeDeclaration, MemberInfo>();

        basePropertyCheck: for (const baseProperty of baseProperties) {
            const base = getTargetSymbol(baseProperty);

            if (base.flags & SymbolFlags.Prototype) {
                continue;
            }
            const baseSymbol = getPropertyOfObjectType(type, base.escapedName);
            if (!baseSymbol) {
                continue;
            }
            const derived = getTargetSymbol(baseSymbol);
            const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);

            Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");

            // In order to resolve whether the inherited method was overridden in the base class or not,
            // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*
            // type declaration, derived and base resolve to the same symbol even in the case of generic classes.
            if (derived === base) {
                // derived class inherits base without override/redeclaration
                const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol)!;

                // It is an error to inherit an abstract member without implementing it or being declared abstract.
                // If there is no declaration for the derived class (as in the case of class expressions),
                // then the class cannot be declared abstract.
                if (baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlags.Abstract))) {
                    // Searches other base types for a declaration that would satisfy the inherited abstract member.
                    // (The class may have more than one base type via declaration merging with an interface with the
                    // same name.)
                    for (const otherBaseType of getBaseTypes(type)) {
                        if (otherBaseType === baseType) continue;
                        const baseSymbol = getPropertyOfObjectType(otherBaseType, base.escapedName);
                        const derivedElsewhere = baseSymbol && getTargetSymbol(baseSymbol);
                        if (derivedElsewhere && derivedElsewhere !== base) {
                            continue basePropertyCheck;
                        }
                    }
                    const baseTypeName = typeToString(baseType);
                    const typeName = typeToString(type);
                    const basePropertyName = symbolToString(baseProperty);
                    const missedProperties = append(notImplementedInfo.get(derivedClassDecl)?.missedProperties, basePropertyName);
                    notImplementedInfo.set(derivedClassDecl, { baseTypeName, typeName, missedProperties });
                }
            }
            else {
                // derived overrides base.
                const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);
                if (baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private) {
                    // either base or derived property is private - not override, skip it
                    continue;
                }

                let errorMessage: DiagnosticMessage;
                const basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor;
                const derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor;
                if (basePropertyFlags && derivedPropertyFlags) {
                    // property/accessor is overridden with property/accessor
                    if (
                        (getCheckFlags(base) & CheckFlags.Synthetic
                            ? base.declarations?.some(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags))
                            : base.declarations?.every(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags)))
                        || getCheckFlags(base) & CheckFlags.Mapped
                        || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration)
                    ) {
                        // when the base property is abstract or from an interface, base/derived flags don't need to match
                        // for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all*
                        // same when the derived property is from an assignment
                        continue;
                    }

                    const overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property;
                    const overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property;
                    if (overriddenInstanceProperty || overriddenInstanceAccessor) {
                        const errorMessage = overriddenInstanceProperty ?
                            Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property :
                            Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;
                        error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType), typeToString(type));
                    }
                    else if (useDefineForClassFields) {
                        const uninitialized = derived.declarations?.find(d => d.kind === SyntaxKind.PropertyDeclaration && !(d as PropertyDeclaration).initializer);
                        if (
                            uninitialized
                            && !(derived.flags & SymbolFlags.Transient)
                            && !(baseDeclarationFlags & ModifierFlags.Abstract)
                            && !(derivedDeclarationFlags & ModifierFlags.Abstract)
                            && !derived.declarations?.some(d => !!(d.flags & NodeFlags.Ambient))
                        ) {
                            const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol)!);
                            const propName = (uninitialized as PropertyDeclaration).name;
                            if (
                                (uninitialized as PropertyDeclaration).exclamationToken
                                || !constructor
                                || !isIdentifier(propName)
                                || !strictNullChecks
                                || !isPropertyInitializedInConstructor(propName, type, constructor)
                            ) {
                                const errorMessage = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;
                                error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType));
                            }
                        }
                    }

                    // correct case
                    continue;
                }
                else if (isPrototypeProperty(base)) {
                    if (isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property) {
                        // method is overridden with method or property -- correct case
                        continue;
                    }
                    else {
                        Debug.assert(!!(derived.flags & SymbolFlags.Accessor));
                        errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                    }
                }
                else if (base.flags & SymbolFlags.Accessor) {
                    errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
                else {
                    errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                }

                error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
            }
        }

        for (const [errorNode, memberInfo] of notImplementedInfo) {
            if (length(memberInfo.missedProperties) === 1) {
                if (isClassExpression(errorNode)) {
                    error(errorNode, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, first(memberInfo.missedProperties), memberInfo.baseTypeName);
                }
                else {
                    error(errorNode, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, memberInfo.typeName, first(memberInfo.missedProperties), memberInfo.baseTypeName);
                }
            }
            else if (length(memberInfo.missedProperties) > 5) {
                const missedProperties = map(memberInfo.missedProperties.slice(0, 4), prop => `'${prop}'`).join(", ");
                const remainingMissedProperties = length(memberInfo.missedProperties) - 4;
                if (isClassExpression(errorNode)) {
                    error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more, memberInfo.baseTypeName, missedProperties, remainingMissedProperties);
                }
                else {
                    error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more, memberInfo.typeName, memberInfo.baseTypeName, missedProperties, remainingMissedProperties);
                }
            }
            else {
                const missedProperties = map(memberInfo.missedProperties, prop => `'${prop}'`).join(", ");
                if (isClassExpression(errorNode)) {
                    error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1, memberInfo.baseTypeName, missedProperties);
                }
                else {
                    error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2, memberInfo.typeName, memberInfo.baseTypeName, missedProperties);
                }
            }
        }
    }

    function isPropertyAbstractOrInterface(declaration: Declaration, baseDeclarationFlags: ModifierFlags) {
        return baseDeclarationFlags & ModifierFlags.Abstract && (!isPropertyDeclaration(declaration) || !declaration.initializer)
            || isInterfaceDeclaration(declaration.parent);
    }

    function getNonInheritedProperties(type: InterfaceType, baseTypes: BaseType[], properties: Symbol[]) {
        if (!length(baseTypes)) {
            return properties;
        }
        const seen = new Map<__String, Symbol>();
        forEach(properties, p => {
            seen.set(p.escapedName, p);
        });

        for (const base of baseTypes) {
            const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
            for (const prop of properties) {
                const existing = seen.get(prop.escapedName);
                if (existing && prop.parent === existing.parent) {
                    seen.delete(prop.escapedName);
                }
            }
        }

        return arrayFrom(seen.values());
    }

    function checkInheritedPropertiesAreIdentical(type: InterfaceType, typeNode: Node): boolean {
        const baseTypes = getBaseTypes(type);
        if (baseTypes.length < 2) {
            return true;
        }

        interface InheritanceInfoMap {
            prop: Symbol;
            containingType: Type;
        }
        const seen = new Map<__String, InheritanceInfoMap>();
        forEach(resolveDeclaredMembers(type).declaredProperties, p => {
            seen.set(p.escapedName, { prop: p, containingType: type });
        });
        let ok = true;

        for (const base of baseTypes) {
            const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
            for (const prop of properties) {
                const existing = seen.get(prop.escapedName);
                if (!existing) {
                    seen.set(prop.escapedName, { prop, containingType: base });
                }
                else {
                    const isInheritedProperty = existing.containingType !== type;
                    if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                        ok = false;

                        const typeName1 = typeToString(existing.containingType);
                        const typeName2 = typeToString(base);

                        let errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2);
                        errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
                        diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo));
                    }
                }
            }
        }

        return ok;
    }

    function checkPropertyInitialization(node: ClassLikeDeclaration) {
        if (!strictNullChecks || !strictPropertyInitialization || node.flags & NodeFlags.Ambient) {
            return;
        }
        const constructor = findConstructorDeclaration(node);
        for (const member of node.members) {
            if (getEffectiveModifierFlags(member) & ModifierFlags.Ambient) {
                continue;
            }
            if (!isStatic(member) && isPropertyWithoutInitializer(member)) {
                const propName = (member as PropertyDeclaration).name;
                if (isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName)) {
                    const type = getTypeOfSymbol(getSymbolOfDeclaration(member));
                    if (!(type.flags & TypeFlags.AnyOrUnknown || containsUndefinedType(type))) {
                        if (!constructor || !isPropertyInitializedInConstructor(propName, type, constructor)) {
                            error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName));
                        }
                    }
                }
            }
        }
    }

    function isPropertyWithoutInitializer(node: Node) {
        return node.kind === SyntaxKind.PropertyDeclaration &&
            !hasAbstractModifier(node) &&
            !(node as PropertyDeclaration).exclamationToken &&
            !(node as PropertyDeclaration).initializer;
    }

    function isPropertyInitializedInStaticBlocks(propName: Identifier | PrivateIdentifier, propType: Type, staticBlocks: readonly ClassStaticBlockDeclaration[], startPos: number, endPos: number) {
        for (const staticBlock of staticBlocks) {
            // static block must be within the provided range as they are evaluated in document order (unlike constructors)
            if (staticBlock.pos >= startPos && staticBlock.pos <= endPos) {
                const reference = factory.createPropertyAccessExpression(factory.createThis(), propName);
                setParent(reference.expression, reference);
                setParent(reference, staticBlock);
                reference.flowNode = staticBlock.returnFlowNode;
                const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
                if (!containsUndefinedType(flowType)) {
                    return true;
                }
            }
        }
        return false;
    }

    function isPropertyInitializedInConstructor(propName: Identifier | PrivateIdentifier | ComputedPropertyName, propType: Type, constructor: ConstructorDeclaration) {
        const reference = isComputedPropertyName(propName)
            ? factory.createElementAccessExpression(factory.createThis(), propName.expression)
            : factory.createPropertyAccessExpression(factory.createThis(), propName);
        setParent(reference.expression, reference);
        setParent(reference, constructor);
        reference.flowNode = constructor.returnFlowNode;
        const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
        return !containsUndefinedType(flowType);
    }

    function checkInterfaceDeclaration(node: InterfaceDeclaration) {
        // Grammar checking
        if (!checkGrammarModifiers(node)) checkGrammarInterfaceDeclaration(node);
        if (!allowBlockDeclarations(node.parent)) {
            grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, "interface");
        }

        checkTypeParameters(node.typeParameters);
        addLazyDiagnostic(() => {
            checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0);

            checkExportsOnMergedDeclarations(node);
            const symbol = getSymbolOfDeclaration(node);
            checkTypeParameterListsIdentical(symbol);

            // Only check this symbol once
            const firstInterfaceDecl = getDeclarationOfKind<InterfaceDeclaration>(symbol, SyntaxKind.InterfaceDeclaration);
            if (node === firstInterfaceDecl) {
                const type = getDeclaredTypeOfSymbol(symbol) as InterfaceType;
                const typeWithThis = getTypeWithThisArgument(type);
                // run subsequent checks only if first set succeeded
                if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                    for (const baseType of getBaseTypes(type)) {
                        checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1);
                    }
                    checkIndexConstraints(type, symbol);
                }
            }
            checkObjectTypeForDuplicateDeclarations(node);
        });
        forEach(getInterfaceBaseTypeNodes(node), heritageElement => {
            if (!isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression)) {
                error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
            }
            checkTypeReferenceNode(heritageElement);
        });

        forEach(node.members, checkSourceElement);

        addLazyDiagnostic(() => {
            checkTypeForDuplicateIndexSignatures(node);
            registerForUnusedIdentifiersCheck(node);
        });
    }

    function checkTypeAliasDeclaration(node: TypeAliasDeclaration) {
        // Grammar checking
        checkGrammarModifiers(node);
        checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
        if (!allowBlockDeclarations(node.parent)) {
            grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, "type");
        }
        checkExportsOnMergedDeclarations(node);
        checkTypeParameters(node.typeParameters);
        if (node.type.kind === SyntaxKind.IntrinsicKeyword) {
            const typeParameterCount = length(node.typeParameters);
            const valid = typeParameterCount === 0 ? node.name.escapedText === "BuiltinIteratorReturn" :
                typeParameterCount === 1 && intrinsicTypeKinds.has(node.name.escapedText as string);
            if (!valid) {
                error(node.type, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types);
            }
        }
        else {
            checkSourceElement(node.type);
            registerForUnusedIdentifiersCheck(node);
        }
    }

    function computeEnumMemberValues(node: EnumDeclaration) {
        const nodeLinks = getNodeLinks(node);
        if (!(nodeLinks.flags & NodeCheckFlags.EnumValuesComputed)) {
            nodeLinks.flags |= NodeCheckFlags.EnumValuesComputed;
            let autoValue: number | undefined = 0;
            let previous: EnumMember | undefined;
            for (const member of node.members) {
                const result = computeEnumMemberValue(member, autoValue, previous);
                getNodeLinks(member).enumMemberValue = result;
                autoValue = typeof result.value === "number" ? result.value + 1 : undefined;
                previous = member;
            }
        }
    }

    function computeEnumMemberValue(member: EnumMember, autoValue: number | undefined, previous: EnumMember | undefined): EvaluatorResult {
        if (isComputedNonLiteralName(member.name)) {
            error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums);
        }
        else if (isBigIntLiteral(member.name)) {
            error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name);
        }
        else {
            const text = getTextOfPropertyName(member.name);
            if (isNumericLiteralName(text) && !isInfinityOrNaNString(text)) {
                error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name);
            }
        }
        if (member.initializer) {
            return computeConstantEnumMemberValue(member);
        }
        // In ambient non-const numeric enum declarations, enum members without initializers are
        // considered computed members (as opposed to having auto-incremented values).
        if (member.parent.flags & NodeFlags.Ambient && !isEnumConst(member.parent)) {
            return evaluatorResult(/*value*/ undefined);
        }
        // If the member declaration specifies no value, the member is considered a constant enum member.
        // If the member is the first member in the enum declaration, it is assigned the value zero.
        // Otherwise, it is assigned the value of the immediately preceding member plus one, and an error
        // occurs if the immediately preceding member is not a constant enum member.
        if (autoValue === undefined) {
            error(member.name, Diagnostics.Enum_member_must_have_initializer);
            return evaluatorResult(/*value*/ undefined);
        }
        if (getIsolatedModules(compilerOptions) && previous?.initializer) {
            const prevValue = getEnumMemberValue(previous);
            if (!(typeof prevValue.value === "number" && !prevValue.resolvedOtherFiles)) {
                error(
                    member.name,
                    Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled,
                );
            }
        }
        return evaluatorResult(autoValue);
    }

    function computeConstantEnumMemberValue(member: EnumMember): EvaluatorResult {
        const isConstEnum = isEnumConst(member.parent);
        const initializer = member.initializer!;
        const result = evaluate(initializer, member);
        if (result.value !== undefined) {
            if (isConstEnum && typeof result.value === "number" && !isFinite(result.value)) {
                error(
                    initializer,
                    isNaN(result.value) ?
                        Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN :
                        Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value,
                );
            }
            else if (getIsolatedModules(compilerOptions) && typeof result.value === "string" && !result.isSyntacticallyString) {
                error(
                    initializer,
                    Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled,
                    `${idText(member.parent.name)}.${getTextOfPropertyName(member.name)}`,
                );
            }
        }
        else if (isConstEnum) {
            error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions);
        }
        else if (member.parent.flags & NodeFlags.Ambient) {
            error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
        }
        else {
            checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values);
        }
        return result;
    }

    function evaluateEntityNameExpression(expr: EntityNameExpression, location?: Declaration) {
        const symbol = resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors*/ true);
        if (!symbol) return evaluatorResult(/*value*/ undefined);

        if (expr.kind === SyntaxKind.Identifier) {
            const identifier = expr;
            if (isInfinityOrNaNString(identifier.escapedText) && (symbol === getGlobalSymbol(identifier.escapedText, SymbolFlags.Value, /*diagnostic*/ undefined))) {
                // Technically we resolved a global lib file here, but the decision to treat this as numeric
                // is more predicated on the fact that the single-file resolution *didn't* resolve to a
                // different meaning of `Infinity` or `NaN`. Transpilers handle this no problem.
                return evaluatorResult(+(identifier.escapedText), /*isSyntacticallyString*/ false);
            }
        }

        if (symbol.flags & SymbolFlags.EnumMember) {
            return location ? evaluateEnumMember(expr, symbol, location) : getEnumMemberValue(symbol.valueDeclaration as EnumMember);
        }
        if (isConstantVariable(symbol)) {
            const declaration = symbol.valueDeclaration;
            if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && (!location || declaration !== location && isBlockScopedNameDeclaredBeforeUse(declaration, location))) {
                const result = evaluate(declaration.initializer, declaration);
                if (location && getSourceFileOfNode(location) !== getSourceFileOfNode(declaration)) {
                    return evaluatorResult(
                        result.value,
                        /*isSyntacticallyString*/ false,
                        /*resolvedOtherFiles*/ true,
                        /*hasExternalReferences*/ true,
                    );
                }
                return evaluatorResult(result.value, result.isSyntacticallyString, result.resolvedOtherFiles, /*hasExternalReferences*/ true);
            }
        }
        return evaluatorResult(/*value*/ undefined);
    }

    function evaluateElementAccessExpression(expr: ElementAccessExpression, location?: Declaration) {
        const root = expr.expression;
        if (isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression)) {
            const rootSymbol = resolveEntityName(root, SymbolFlags.Value, /*ignoreErrors*/ true);
            if (rootSymbol && rootSymbol.flags & SymbolFlags.Enum) {
                const name = escapeLeadingUnderscores(expr.argumentExpression.text);
                const member = rootSymbol.exports!.get(name);
                if (member) {
                    Debug.assert(getSourceFileOfNode(member.valueDeclaration) === getSourceFileOfNode(rootSymbol.valueDeclaration));
                    return location ? evaluateEnumMember(expr, member, location) : getEnumMemberValue(member.valueDeclaration as EnumMember);
                }
            }
        }
        return evaluatorResult(/*value*/ undefined);
    }

    function evaluateEnumMember(expr: Expression, symbol: Symbol, location: Declaration) {
        const declaration = symbol.valueDeclaration;
        if (!declaration || declaration === location) {
            error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol));
            return evaluatorResult(/*value*/ undefined);
        }
        if (!isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
            error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
            return evaluatorResult(/*value*/ 0);
        }
        const value = getEnumMemberValue(declaration as EnumMember);
        if (location.parent !== declaration.parent) {
            return evaluatorResult(value.value, value.isSyntacticallyString, value.resolvedOtherFiles, /*hasExternalReferences*/ true);
        }
        return value;
    }

    function checkEnumDeclaration(node: EnumDeclaration) {
        addLazyDiagnostic(() => checkEnumDeclarationWorker(node));
    }

    function checkEnumDeclarationWorker(node: EnumDeclaration) {
        // Grammar checking
        checkGrammarModifiers(node);

        checkCollisionsForDeclarationName(node, node.name);
        checkExportsOnMergedDeclarations(node);
        node.members.forEach(checkSourceElement);

        if (compilerOptions.erasableSyntaxOnly && !(node.flags & NodeFlags.Ambient)) {
            error(node, Diagnostics.This_syntax_is_not_allowed_when_erasableSyntaxOnly_is_enabled);
        }

        computeEnumMemberValues(node);

        // Spec 2014 - Section 9.3:
        // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
        // and when an enum type has multiple declarations, only one declaration is permitted to omit a value
        // for the first member.
        //
        // Only perform this check once per symbol
        const enumSymbol = getSymbolOfDeclaration(node);
        const firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
        if (node === firstDeclaration) {
            if (enumSymbol.declarations && enumSymbol.declarations.length > 1) {
                const enumIsConst = isEnumConst(node);
                // check that const is placed\omitted on all enum declarations
                forEach(enumSymbol.declarations, decl => {
                    if (isEnumDeclaration(decl) && isEnumConst(decl) !== enumIsConst) {
                        error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const);
                    }
                });
            }

            let seenEnumMissingInitialInitializer = false;
            forEach(enumSymbol.declarations, declaration => {
                // return true if we hit a violation of the rule, false otherwise
                if (declaration.kind !== SyntaxKind.EnumDeclaration) {
                    return false;
                }

                const enumDeclaration = declaration as EnumDeclaration;
                if (!enumDeclaration.members.length) {
                    return false;
                }

                const firstEnumMember = enumDeclaration.members[0];
                if (!firstEnumMember.initializer) {
                    if (seenEnumMissingInitialInitializer) {
                        error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                    }
                    else {
                        seenEnumMissingInitialInitializer = true;
                    }
                }
            });
        }
    }

    function checkEnumMember(node: EnumMember) {
        if (isPrivateIdentifier(node.name)) {
            error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier);
        }
        if (node.initializer) {
            checkExpression(node.initializer);
        }
    }

    function getFirstNonAmbientClassOrFunctionDeclaration(symbol: Symbol): Declaration | undefined {
        const declarations = symbol.declarations;
        if (declarations) {
            for (const declaration of declarations) {
                if (
                    (declaration.kind === SyntaxKind.ClassDeclaration ||
                        (declaration.kind === SyntaxKind.FunctionDeclaration && nodeIsPresent((declaration as FunctionLikeDeclaration).body))) &&
                    !(declaration.flags & NodeFlags.Ambient)
                ) {
                    return declaration;
                }
            }
        }
        return undefined;
    }

    function inSameLexicalScope(node1: Node, node2: Node) {
        const container1 = getEnclosingBlockScopeContainer(node1);
        const container2 = getEnclosingBlockScopeContainer(node2);
        if (isGlobalSourceFile(container1)) {
            return isGlobalSourceFile(container2);
        }
        else if (isGlobalSourceFile(container2)) {
            return false;
        }
        else {
            return container1 === container2;
        }
    }

    function checkModuleDeclaration(node: ModuleDeclaration) {
        if (node.body) {
            checkSourceElement(node.body);
            if (!isGlobalScopeAugmentation(node)) {
                registerForUnusedIdentifiersCheck(node);
            }
        }

        addLazyDiagnostic(checkModuleDeclarationDiagnostics);

        function checkModuleDeclarationDiagnostics() {
            // Grammar checking
            const isGlobalAugmentation = isGlobalScopeAugmentation(node);
            const inAmbientContext = node.flags & NodeFlags.Ambient;
            if (isGlobalAugmentation && !inAmbientContext) {
                error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);
            }

            const isAmbientExternalModule: boolean = isAmbientModule(node);
            const contextErrorMessage = isAmbientExternalModule
                ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
                : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module;
            if (checkGrammarModuleElementContext(node, contextErrorMessage)) {
                // If we hit a module declaration in an illegal context, just bail out to avoid cascading errors.
                return;
            }

            if (!checkGrammarModifiers(node)) {
                if (!inAmbientContext && node.name.kind === SyntaxKind.StringLiteral) {
                    grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names);
                }
            }

            if (isIdentifier(node.name)) {
                checkCollisionsForDeclarationName(node, node.name);
                if (!(node.flags & (NodeFlags.Namespace | NodeFlags.GlobalAugmentation))) {
                    const sourceFile = getSourceFileOfNode(node);
                    const pos = getNonModifierTokenPosOfNode(node);
                    const span = getSpanOfTokenAtPosition(sourceFile, pos);
                    suggestionDiagnostics.add(
                        createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead),
                    );
                }
            }

            checkExportsOnMergedDeclarations(node);
            const symbol = getSymbolOfDeclaration(node);

            // The following checks only apply on a non-ambient instantiated module declaration.
            if (
                symbol.flags & SymbolFlags.ValueModule
                && !inAmbientContext
                && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions))
            ) {
                if (compilerOptions.erasableSyntaxOnly) {
                    error(node.name, Diagnostics.This_syntax_is_not_allowed_when_erasableSyntaxOnly_is_enabled);
                }

                if (getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator) {
                    // This could be loosened a little if needed. The only problem we are trying to avoid is unqualified
                    // references to namespace members declared in other files. But use of namespaces is discouraged anyway,
                    // so for now we will just not allow them in scripts, which is the only place they can merge cross-file.
                    error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName);
                }
                if (symbol.declarations?.length! > 1) {
                    const firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                    if (firstNonAmbientClassOrFunc) {
                        if (getSourceFileOfNode(node) !== getSourceFileOfNode(firstNonAmbientClassOrFunc)) {
                            error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                        }
                        else if (node.pos < firstNonAmbientClassOrFunc.pos) {
                            error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                        }
                    }

                    // if the module merges with a class declaration in the same lexical scope,
                    // we need to track this to ensure the correct emit.
                    const mergedClass = getDeclarationOfKind(symbol, SyntaxKind.ClassDeclaration);
                    if (
                        mergedClass &&
                        inSameLexicalScope(node, mergedClass)
                    ) {
                        getNodeLinks(node).flags |= NodeCheckFlags.LexicalModuleMergesWithClass;
                    }
                }
                if (
                    compilerOptions.verbatimModuleSyntax &&
                    node.parent.kind === SyntaxKind.SourceFile &&
                    host.getEmitModuleFormatOfFile(node.parent) === ModuleKind.CommonJS
                ) {
                    const exportModifier = node.modifiers?.find(m => m.kind === SyntaxKind.ExportKeyword);
                    if (exportModifier) {
                        error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
                    }
                }
            }

            if (isAmbientExternalModule) {
                if (isExternalModuleAugmentation(node)) {
                    // body of the augmentation should be checked for consistency only if augmentation was applied to its target (either global scope or module)
                    // otherwise we'll be swamped in cascading errors.
                    // We can detect if augmentation was applied using following rules:
                    // - augmentation for a global scope is always applied
                    // - augmentation for some external module is applied if symbol for augmentation is merged (it was combined with target module).
                    const checkBody = isGlobalAugmentation || (getSymbolOfDeclaration(node).flags & SymbolFlags.Transient);
                    if (checkBody && node.body) {
                        for (const statement of node.body.statements) {
                            checkModuleAugmentationElement(statement, isGlobalAugmentation);
                        }
                    }
                }
                else if (isGlobalSourceFile(node.parent)) {
                    if (isGlobalAugmentation) {
                        error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                    }
                    else if (isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name))) {
                        error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name);
                    }
                }
                else {
                    if (isGlobalAugmentation) {
                        error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                    }
                    else {
                        // Node is not an augmentation and is not located on the script level.
                        // This means that this is declaration of ambient module that is located in other module or namespace which is prohibited.
                        error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
                    }
                }
            }
        }
    }

    function checkModuleAugmentationElement(node: Node, isGlobalAugmentation: boolean): void {
        switch (node.kind) {
            case SyntaxKind.VariableStatement:
                // error each individual name in variable statement instead of marking the entire variable statement
                for (const decl of (node as VariableStatement).declarationList.declarations) {
                    checkModuleAugmentationElement(decl, isGlobalAugmentation);
                }
                break;
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
                grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);
                break;
            case SyntaxKind.ImportEqualsDeclaration:
                // import a = e.x; in module augmentation is ok, but not import a = require('fs)
                if (isInternalModuleImportEqualsDeclaration(node)) break;
                // falls through
            case SyntaxKind.ImportDeclaration:
                grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);
                break;
            case SyntaxKind.BindingElement:
            case SyntaxKind.VariableDeclaration:
                const name = (node as VariableDeclaration | BindingElement).name;
                if (isBindingPattern(name)) {
                    for (const el of name.elements) {
                        // mark individual names in binding pattern
                        checkModuleAugmentationElement(el, isGlobalAugmentation);
                    }
                    break;
                }
                // falls through
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
                if (isGlobalAugmentation) {
                    return;
                }
                break;
        }
    }

    function getFirstNonModuleExportsIdentifier(node: EntityNameOrEntityNameExpression): Identifier {
        switch (node.kind) {
            case SyntaxKind.Identifier:
                return node;
            case SyntaxKind.QualifiedName:
                do {
                    node = node.left;
                }
                while (node.kind !== SyntaxKind.Identifier);
                return node;
            case SyntaxKind.PropertyAccessExpression:
                do {
                    if (isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name)) {
                        return node.name;
                    }
                    node = node.expression;
                }
                while (node.kind !== SyntaxKind.Identifier);
                return node;
        }
    }

    function checkExternalImportOrExportDeclaration(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration): boolean {
        const moduleName = getExternalModuleName(node);
        if (!moduleName || nodeIsMissing(moduleName)) {
            // Should be a parse error.
            return false;
        }
        if (!isStringLiteral(moduleName)) {
            error(moduleName, Diagnostics.String_literal_expected);
            return false;
        }
        const inAmbientExternalModule = node.parent.kind === SyntaxKind.ModuleBlock && isAmbientModule(node.parent.parent);
        if (node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule) {
            error(
                moduleName,
                node.kind === SyntaxKind.ExportDeclaration ?
                    Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :
                    Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module,
            );
            return false;
        }
        if (inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text)) {
            // we have already reported errors on top level imports/exports in external module augmentations in checkModuleDeclaration
            // no need to do this again.
            if (!isTopLevelInExternalModuleAugmentation(node)) {
                // TypeScript 1.0 spec (April 2013): 12.1.6
                // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
                // other external modules only through top - level external module names.
                // Relative external module names are not permitted.
                error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
                return false;
            }
        }
        if (!isImportEqualsDeclaration(node) && node.attributes) {
            const diagnostic = node.attributes.token === SyntaxKind.WithKeyword ? Diagnostics.Import_attribute_values_must_be_string_literal_expressions : Diagnostics.Import_assertion_values_must_be_string_literal_expressions;
            let hasError = false;
            for (const attr of node.attributes.elements) {
                if (!isStringLiteral(attr.value)) {
                    hasError = true;
                    error(attr.value, diagnostic);
                }
            }
            return !hasError;
        }
        return true;
    }

    function checkModuleExportName(name: ModuleExportName | undefined, allowStringLiteral = true) {
        if (name === undefined || name.kind !== SyntaxKind.StringLiteral) {
            return;
        }
        if (!allowStringLiteral) {
            grammarErrorOnNode(name, Diagnostics.Identifier_expected);
        }
        else if (moduleKind === ModuleKind.ES2015 || moduleKind === ModuleKind.ES2020) {
            grammarErrorOnNode(name, Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020);
        }
    }

    function checkAliasSymbol(node: AliasDeclarationNode) {
        let symbol = getSymbolOfDeclaration(node);
        const target = resolveAlias(symbol);

        if (target !== unknownSymbol) {
            // For external modules, `symbol` represents the local symbol for an alias.
            // This local symbol will merge any other local declarations (excluding other aliases)
            // and symbol.flags will contains combined representation for all merged declaration.
            // Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,
            // otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export*
            // in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names).
            symbol = getMergedSymbol(symbol.exportSymbol || symbol);

            // A type-only import/export will already have a grammar error in a JS file, so no need to issue more errors within
            if (isInJSFile(node) && !(target.flags & SymbolFlags.Value) && !isTypeOnlyImportOrExportDeclaration(node)) {
                const errorNode = isImportOrExportSpecifier(node) ? node.propertyName || node.name :
                    isNamedDeclaration(node) ? node.name :
                    node;

                Debug.assert(node.kind !== SyntaxKind.NamespaceExport);
                if (node.kind === SyntaxKind.ExportSpecifier) {
                    const diag = error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files);
                    const alreadyExportedSymbol = getSourceFileOfNode(node).symbol?.exports?.get(moduleExportNameTextEscaped(node.propertyName || node.name));
                    if (alreadyExportedSymbol === target) {
                        const exportingDeclaration = alreadyExportedSymbol.declarations?.find(isJSDocNode);
                        if (exportingDeclaration) {
                            addRelatedInfo(
                                diag,
                                createDiagnosticForNode(
                                    exportingDeclaration,
                                    Diagnostics._0_is_automatically_exported_here,
                                    unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName),
                                ),
                            );
                        }
                    }
                }
                else {
                    Debug.assert(node.kind !== SyntaxKind.VariableDeclaration);
                    const importDeclaration = findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration));
                    const moduleSpecifier = (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "...";
                    const importedIdentifier = unescapeLeadingUnderscores(isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName);
                    error(
                        errorNode,
                        Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation,
                        importedIdentifier,
                        `import("${moduleSpecifier}").${importedIdentifier}`,
                    );
                }
                return;
            }

            const targetFlags = getSymbolFlags(target);
            const excludedMeanings = (symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0) |
                (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) |
                (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0);
            if (targetFlags & excludedMeanings) {
                const message = node.kind === SyntaxKind.ExportSpecifier ?
                    Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :
                    Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
                error(node, message, symbolToString(symbol));
            }
            else if (node.kind !== SyntaxKind.ExportSpecifier) {
                // Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
                // here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
                const appearsValueyToTranspiler = compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration);
                if (appearsValueyToTranspiler && symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue)) {
                    error(
                        node,
                        Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled,
                        symbolToString(symbol),
                        isolatedModulesLikeFlagName,
                    );
                }
            }

            if (
                getIsolatedModules(compilerOptions)
                && !isTypeOnlyImportOrExportDeclaration(node)
                && !(node.flags & NodeFlags.Ambient)
            ) {
                const typeOnlyAlias = getTypeOnlyAliasDeclaration(symbol);
                const isType = !(targetFlags & SymbolFlags.Value);
                if (isType || typeOnlyAlias) {
                    switch (node.kind) {
                        case SyntaxKind.ImportClause:
                        case SyntaxKind.ImportSpecifier:
                        case SyntaxKind.ImportEqualsDeclaration: {
                            if (compilerOptions.verbatimModuleSyntax) {
                                Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");
                                const message = compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node)
                                    ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled
                                    : isType
                                    ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled
                                    : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled;
                                const name = moduleExportNameTextUnescaped(node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name);
                                addTypeOnlyDeclarationRelatedInfo(
                                    error(node, message, name),
                                    isType ? undefined : typeOnlyAlias,
                                    name,
                                );
                            }
                            if (isType && node.kind === SyntaxKind.ImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlags.Export)) {
                                error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName);
                            }
                            break;
                        }
                        case SyntaxKind.ExportSpecifier: {
                            // Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.
                            // The exception is that `import type { A } from './a'; export { A }` is allowed
                            // because single-file analysis can determine that the export should be dropped.
                            if (compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(node)) {
                                const name = moduleExportNameTextUnescaped(node.propertyName || node.name);
                                const diagnostic = isType
                                    ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName)
                                    : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName);
                                addTypeOnlyDeclarationRelatedInfo(diagnostic, isType ? undefined : typeOnlyAlias, name);
                                break;
                            }
                        }
                    }
                }

                if (
                    compilerOptions.verbatimModuleSyntax &&
                    node.kind !== SyntaxKind.ImportEqualsDeclaration &&
                    !isInJSFile(node) &&
                    host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS
                ) {
                    error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
                }
                else if (
                    moduleKind === ModuleKind.Preserve &&
                    node.kind !== SyntaxKind.ImportEqualsDeclaration &&
                    node.kind !== SyntaxKind.VariableDeclaration &&
                    host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS
                ) {
                    // In `--module preserve`, ESM input syntax emits ESM output syntax, but there will be times
                    // when we look at the `impliedNodeFormat` of this file and decide it's CommonJS (i.e., currently,
                    // only if the file extension is .cjs/.cts). To avoid that inconsistency, we disallow ESM syntax
                    // in files that are unambiguously CommonJS in this mode.
                    error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve);
                }

                if (
                    compilerOptions.verbatimModuleSyntax &&
                    !isTypeOnlyImportOrExportDeclaration(node) &&
                    !(node.flags & NodeFlags.Ambient) &&
                    targetFlags & SymbolFlags.ConstEnum
                ) {
                    const constEnumDeclaration = target.valueDeclaration as EnumDeclaration;
                    const redirect = host.getRedirectFromOutput(getSourceFileOfNode(constEnumDeclaration).resolvedPath)?.resolvedRef;
                    if (constEnumDeclaration.flags & NodeFlags.Ambient && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options))) {
                        error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName);
                    }
                }
            }

            if (isImportSpecifier(node)) {
                const targetSymbol = resolveAliasWithDeprecationCheck(symbol, node);
                if (isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations) {
                    addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName as string);
                }
            }
        }
    }

    function resolveAliasWithDeprecationCheck(symbol: Symbol, location: Node) {
        if (!(symbol.flags & SymbolFlags.Alias) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol)) {
            return symbol;
        }

        const targetSymbol = resolveAlias(symbol);
        if (targetSymbol === unknownSymbol) return targetSymbol;

        while (symbol.flags & SymbolFlags.Alias) {
            const target = getImmediateAliasedSymbol(symbol);
            if (target) {
                if (target === targetSymbol) break;
                if (target.declarations && length(target.declarations)) {
                    if (isDeprecatedSymbol(target)) {
                        addDeprecatedSuggestion(location, target.declarations, target.escapedName as string);
                        break;
                    }
                    else {
                        if (symbol === targetSymbol) break;
                        symbol = target;
                    }
                }
            }
            else {
                break;
            }
        }
        return targetSymbol;
    }

    function checkImportBinding(node: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier) {
        checkCollisionsForDeclarationName(node, node.name);
        checkAliasSymbol(node);
        if (node.kind === SyntaxKind.ImportSpecifier) {
            checkModuleExportName(node.propertyName);
            if (
                moduleExportNameIsDefault(node.propertyName || node.name) &&
                getESModuleInterop(compilerOptions) &&
                host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System
            ) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportDefault);
            }
        }
    }

    function checkImportAttributes(declaration: ImportDeclaration | ExportDeclaration | JSDocImportTag) {
        const node = declaration.attributes;
        if (node) {
            const importAttributesType = getGlobalImportAttributesType(/*reportErrors*/ true);
            if (importAttributesType !== emptyObjectType) {
                checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType, TypeFlags.Undefined), node);
            }

            const validForTypeAttributes = isExclusivelyTypeOnlyImportOrExport(declaration);
            const override = getResolutionModeOverride(node, validForTypeAttributes ? grammarErrorOnNode : undefined);
            const isImportAttributes = declaration.attributes.token === SyntaxKind.WithKeyword;
            if (validForTypeAttributes && override) {
                return; // Other grammar checks do not apply to type-only imports with resolution mode assertions
            }

            if (!moduleSupportsImportAttributes(moduleKind)) {
                return grammarErrorOnNode(
                    node,
                    isImportAttributes
                        ? Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_node18_node20_nodenext_or_preserve
                        : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_node18_node20_nodenext_or_preserve,
                );
            }

            if (ModuleKind.Node20 <= moduleKind && moduleKind <= ModuleKind.NodeNext && !isImportAttributes) {
                return grammarErrorOnFirstToken(node, Diagnostics.Import_assertions_have_been_replaced_by_import_attributes_Use_with_instead_of_assert);
            }

            if (declaration.moduleSpecifier && getEmitSyntaxForModuleSpecifierExpression(declaration.moduleSpecifier) === ModuleKind.CommonJS) {
                return grammarErrorOnNode(
                    node,
                    isImportAttributes
                        ? Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls
                        : Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls,
                );
            }

            const isTypeOnly = isJSDocImportTag(declaration) || (isImportDeclaration(declaration) ? declaration.importClause?.isTypeOnly : declaration.isTypeOnly);
            if (isTypeOnly) {
                return grammarErrorOnNode(node, isImportAttributes ? Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports : Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports);
            }

            if (override) {
                return grammarErrorOnNode(node, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports);
            }
        }
    }

    function checkImportAttribute(node: ImportAttribute) {
        return getRegularTypeOfLiteralType(checkExpressionCached(node.value));
    }

    function checkImportDeclaration(node: ImportDeclaration) {
        if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
            // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
            return;
        }
        if (!checkGrammarModifiers(node) && node.modifiers) {
            grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers);
        }
        if (checkExternalImportOrExportDeclaration(node)) {
            let resolvedModule;
            const importClause = node.importClause;
            if (importClause && !checkGrammarImportClause(importClause)) {
                if (importClause.name) {
                    checkImportBinding(importClause);
                }
                if (importClause.namedBindings) {
                    if (importClause.namedBindings.kind === SyntaxKind.NamespaceImport) {
                        checkImportBinding(importClause.namedBindings);
                        if (host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System && getESModuleInterop(compilerOptions)) {
                            // import * as ns from "foo";
                            checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportStar);
                        }
                    }
                    else {
                        resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                        if (resolvedModule) {
                            forEach(importClause.namedBindings.elements, checkImportBinding);
                        }
                    }
                }

                if (!importClause.isTypeOnly && ModuleKind.Node18 <= moduleKind && moduleKind <= ModuleKind.NodeNext && isOnlyImportableAsDefault(node.moduleSpecifier, resolvedModule) && !hasTypeJsonImportAttribute(node)) {
                    // Import attributes/assertions are not allowed in --module node16, so don't suggest adding one
                    error(node.moduleSpecifier, Diagnostics.Importing_a_JSON_file_into_an_ECMAScript_module_requires_a_type_Colon_json_import_attribute_when_module_is_set_to_0, ModuleKind[moduleKind]);
                }
            }
            else if (noUncheckedSideEffectImports && !importClause) {
                void resolveExternalModuleName(node, node.moduleSpecifier);
            }
        }
        checkImportAttributes(node);
    }

    function hasTypeJsonImportAttribute(node: ImportDeclaration) {
        return !!node.attributes && node.attributes.elements.some(attr => getTextOfIdentifierOrLiteral(attr.name) === "type" && tryCast(attr.value, isStringLiteralLike)?.text === "json");
    }

    function checkImportEqualsDeclaration(node: ImportEqualsDeclaration) {
        if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
            // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
            return;
        }

        checkGrammarModifiers(node);
        if (compilerOptions.erasableSyntaxOnly && !(node.flags & NodeFlags.Ambient)) {
            error(node, Diagnostics.This_syntax_is_not_allowed_when_erasableSyntaxOnly_is_enabled);
        }
        if (isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node)) {
            checkImportBinding(node);
            markLinkedReferences(node, ReferenceHint.ExportImportEquals);
            if (node.moduleReference.kind !== SyntaxKind.ExternalModuleReference) {
                const target = resolveAlias(getSymbolOfDeclaration(node));
                if (target !== unknownSymbol) {
                    const targetFlags = getSymbolFlags(target);
                    if (targetFlags & SymbolFlags.Value) {
                        // Target is a value symbol, check that it is not hidden by a local declaration with the same name
                        const moduleName = getFirstIdentifier(node.moduleReference);
                        if (!(resolveEntityName(moduleName, SymbolFlags.Value | SymbolFlags.Namespace)!.flags & SymbolFlags.Namespace)) {
                            error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName));
                        }
                    }
                    if (targetFlags & SymbolFlags.Type) {
                        checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0);
                    }
                }
                if (node.isTypeOnly) {
                    grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type);
                }
            }
            else {
                if (ModuleKind.ES2015 <= moduleKind && moduleKind <= ModuleKind.ESNext && !node.isTypeOnly && !(node.flags & NodeFlags.Ambient)) {
                    // Import equals declaration cannot be emitted as ESM
                    grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead);
                }
            }
        }
    }

    function checkExportDeclaration(node: ExportDeclaration) {
        if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
            // If we hit an export in an illegal context, just bail out to avoid cascading errors.
            return;
        }

        if (!checkGrammarModifiers(node) && hasSyntacticModifiers(node)) {
            grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers);
        }

        checkGrammarExportDeclaration(node);
        if (!node.moduleSpecifier || checkExternalImportOrExportDeclaration(node)) {
            if (node.exportClause && !isNamespaceExport(node.exportClause)) {
                // export { x, y }
                // export { x, y } from "foo"
                forEach(node.exportClause.elements, checkExportSpecifier);
                const inAmbientExternalModule = node.parent.kind === SyntaxKind.ModuleBlock && isAmbientModule(node.parent.parent);
                const inAmbientNamespaceDeclaration = !inAmbientExternalModule && node.parent.kind === SyntaxKind.ModuleBlock &&
                    !node.moduleSpecifier && node.flags & NodeFlags.Ambient;
                if (node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration) {
                    error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace);
                }
            }
            else {
                // export * from "foo"
                // export * as ns from "foo";
                const moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier!);
                if (moduleSymbol && hasExportAssignmentSymbol(moduleSymbol)) {
                    error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol));
                }
                else if (node.exportClause) {
                    checkAliasSymbol(node.exportClause);
                    checkModuleExportName(node.exportClause.name);
                }
                if (host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System) {
                    if (node.exportClause) {
                        // export * as ns from "foo";
                        // For ES2015 modules, we emit it as a pair of `import * as a_1 ...; export { a_1 as ns }` and don't need the helper.
                        // We only use the helper here when in esModuleInterop
                        if (getESModuleInterop(compilerOptions)) {
                            checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportStar);
                        }
                    }
                    else {
                        // export * from "foo"
                        checkExternalEmitHelpers(node, ExternalEmitHelpers.ExportStar);
                    }
                }
            }
        }
        checkImportAttributes(node);
    }

    function checkGrammarExportDeclaration(node: ExportDeclaration): boolean {
        if (node.isTypeOnly && node.exportClause?.kind === SyntaxKind.NamedExports) {
            return checkGrammarNamedImportsOrExports(node.exportClause);
        }
        return false;
    }

    function checkGrammarModuleElementContext(node: Statement, errorMessage: DiagnosticMessage): boolean {
        const isInAppropriateContext = node.parent.kind === SyntaxKind.SourceFile || node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.ModuleDeclaration;
        if (!isInAppropriateContext) {
            grammarErrorOnFirstToken(node, errorMessage);
        }
        return !isInAppropriateContext;
    }

    function checkExportSpecifier(node: ExportSpecifier) {
        checkAliasSymbol(node);
        const hasModuleSpecifier = node.parent.parent.moduleSpecifier !== undefined;
        checkModuleExportName(node.propertyName, hasModuleSpecifier);
        checkModuleExportName(node.name);
        if (getEmitDeclarations(compilerOptions)) {
            collectLinkedAliases(node.propertyName || node.name, /*setVisibility*/ true);
        }
        if (!hasModuleSpecifier) {
            const exportedName = node.propertyName || node.name;
            if (exportedName.kind === SyntaxKind.StringLiteral) {
                return; // Skip for invalid syntax like this: export { "x" }
            }
            // find immediate value referenced by exported name (SymbolFlags.Alias is set so we don't chase down aliases)
            const symbol = resolveName(exportedName, exportedName.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
            if (symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0])))) {
                error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName));
            }
            else {
                markLinkedReferences(node, ReferenceHint.ExportSpecifier);
            }
        }
        else {
            if (
                getESModuleInterop(compilerOptions) &&
                host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System &&
                moduleExportNameIsDefault(node.propertyName || node.name)
            ) {
                checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportDefault);
            }
        }
    }

    function checkExportAssignment(node: ExportAssignment) {
        const illegalContextMessage = node.isExportEquals
            ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration
            : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration;
        if (checkGrammarModuleElementContext(node, illegalContextMessage)) {
            // If we hit an export assignment in an illegal context, just bail out to avoid cascading errors.
            return;
        }

        if (compilerOptions.erasableSyntaxOnly && node.isExportEquals && !(node.flags & NodeFlags.Ambient)) {
            error(node, Diagnostics.This_syntax_is_not_allowed_when_erasableSyntaxOnly_is_enabled);
        }
        const container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent as ModuleDeclaration;
        if (container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(container)) {
            if (node.isExportEquals) {
                error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace);
            }
            else {
                error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
            }

            return;
        }
        // Grammar checking
        if (!checkGrammarModifiers(node) && hasEffectiveModifiers(node)) {
            grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers);
        }

        const typeAnnotationNode = getEffectiveTypeAnnotationNode(node);
        if (typeAnnotationNode) {
            checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression);
        }

        const isIllegalExportDefaultInCJS = !node.isExportEquals &&
            !(node.flags & NodeFlags.Ambient) &&
            compilerOptions.verbatimModuleSyntax &&
            host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS;

        if (node.expression.kind === SyntaxKind.Identifier) {
            const id = node.expression as Identifier;
            const sym = getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlags.All, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, node));
            if (sym) {
                markLinkedReferences(node, ReferenceHint.ExportAssignment);
                const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(sym, SymbolFlags.Value);
                // If not a value, we're interpreting the identifier as a type export, along the lines of (`export { Id as default }`)
                if (getSymbolFlags(sym) & SymbolFlags.Value) {
                    // However if it is a value, we need to check it's being used correctly
                    checkExpressionCached(id);
                    if (!isIllegalExportDefaultInCJS && !(node.flags & NodeFlags.Ambient) && compilerOptions.verbatimModuleSyntax && typeOnlyDeclaration) {
                        error(
                            id,
                            node.isExportEquals
                                ? Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration
                                : Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration,
                            idText(id),
                        );
                    }
                }
                else if (!isIllegalExportDefaultInCJS && !(node.flags & NodeFlags.Ambient) && compilerOptions.verbatimModuleSyntax) {
                    error(
                        id,
                        node.isExportEquals
                            ? Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type
                            : Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type,
                        idText(id),
                    );
                }

                if (!isIllegalExportDefaultInCJS && !(node.flags & NodeFlags.Ambient) && getIsolatedModules(compilerOptions) && !(sym.flags & SymbolFlags.Value)) {
                    const nonLocalMeanings = getSymbolFlags(sym, /*excludeTypeOnlyMeanings*/ false, /*excludeLocalMeanings*/ true);
                    if (
                        sym.flags & SymbolFlags.Alias
                        && nonLocalMeanings & SymbolFlags.Type
                        && !(nonLocalMeanings & SymbolFlags.Value)
                        && (!typeOnlyDeclaration || getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node))
                    ) {
                        // import { SomeType } from "./someModule";
                        // export default SomeType; OR
                        // export = SomeType;
                        error(
                            id,
                            node.isExportEquals ?
                                Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported
                                : Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default,
                            idText(id),
                            isolatedModulesLikeFlagName,
                        );
                    }
                    else if (typeOnlyDeclaration && getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node)) {
                        // import { SomeTypeOnlyValue } from "./someModule";
                        // export default SomeTypeOnlyValue; OR
                        // export = SomeTypeOnlyValue;
                        addTypeOnlyDeclarationRelatedInfo(
                            error(
                                id,
                                node.isExportEquals ?
                                    Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported
                                    : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default,
                                idText(id),
                                isolatedModulesLikeFlagName,
                            ),
                            typeOnlyDeclaration,
                            idText(id),
                        );
                    }
                }
            }
            else {
                checkExpressionCached(id); // doesn't resolve, check as expression to mark as error
            }

            if (getEmitDeclarations(compilerOptions)) {
                collectLinkedAliases(id, /*setVisibility*/ true);
            }
        }
        else {
            checkExpressionCached(node.expression);
        }

        if (isIllegalExportDefaultInCJS) {
            error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
        }

        checkExternalModuleExports(container);

        if ((node.flags & NodeFlags.Ambient) && !isEntityNameExpression(node.expression)) {
            grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context);
        }

        if (node.isExportEquals) {
            // Forbid export= in esm implementation files, and esm mode declaration files
            if (
                moduleKind >= ModuleKind.ES2015 &&
                moduleKind !== ModuleKind.Preserve &&
                ((node.flags & NodeFlags.Ambient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) === ModuleKind.ESNext) ||
                    (!(node.flags & NodeFlags.Ambient) && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) !== ModuleKind.CommonJS))
            ) {
                // export assignment is not supported in es6 modules
                grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead);
            }
            else if (moduleKind === ModuleKind.System && !(node.flags & NodeFlags.Ambient)) {
                // system modules does not support export assignment
                grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system);
            }
        }
    }

    function hasExportedMembers(moduleSymbol: Symbol) {
        return forEachEntry(moduleSymbol.exports!, (_, id) => id !== "export=");
    }

    function checkExternalModuleExports(node: SourceFile | ModuleDeclaration) {
        const moduleSymbol = getSymbolOfDeclaration(node);
        const links = getSymbolLinks(moduleSymbol);
        if (!links.exportsChecked) {
            const exportEqualsSymbol = moduleSymbol.exports!.get("export=" as __String);
            if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {
                const declaration = getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration;
                if (declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration)) {
                    error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                }
            }
            // Checks for export * conflicts
            const exports = getExportsOfModule(moduleSymbol);
            if (exports) {
                exports.forEach(({ declarations, flags }, id) => {
                    if (id === "__export") {
                        return;
                    }
                    // ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.
                    // (TS Exceptions: namespaces, function overloads, enums, and interfaces)
                    if (flags & (SymbolFlags.Namespace | SymbolFlags.Enum)) {
                        return;
                    }
                    const exportedDeclarationsCount = countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)));
                    if (flags & SymbolFlags.TypeAlias && exportedDeclarationsCount <= 2) {
                        // it is legal to merge type alias with other values
                        // so count should be either 1 (just type alias) or 2 (type alias + merged value)
                        return;
                    }
                    if (exportedDeclarationsCount > 1) {
                        if (!isDuplicatedCommonJSExport(declarations)) {
                            for (const declaration of declarations!) {
                                if (isNotOverload(declaration)) {
                                    diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)));
                                }
                            }
                        }
                    }
                });
            }
            links.exportsChecked = true;
        }
    }

    function isDuplicatedCommonJSExport(declarations: Declaration[] | undefined) {
        return declarations
            && declarations.length > 1
            && declarations.every(d => isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression)));
    }

    function checkSourceElement(node: Node | undefined): void {
        if (node) {
            const saveCurrentNode = currentNode;
            currentNode = node;
            instantiationCount = 0;
            checkSourceElementWorker(node);
            currentNode = saveCurrentNode;
        }
    }

    function checkSourceElementWorker(node: Node): void {
        if (getNodeCheckFlags(node) & NodeCheckFlags.PartiallyTypeChecked) {
            return;
        }

        if (canHaveJSDoc(node)) {
            forEach(node.jsDoc, ({ comment, tags }) => {
                checkJSDocCommentWorker(comment);
                forEach(tags, tag => {
                    checkJSDocCommentWorker(tag.comment);
                    if (isInJSFile(node)) {
                        checkSourceElement(tag);
                    }
                });
            });
        }

        const kind = node.kind;
        if (cancellationToken) {
            // Only bother checking on a few construct kinds.  We don't want to be excessively
            // hitting the cancellation token on every node we check.
            switch (kind) {
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.FunctionDeclaration:
                    cancellationToken.throwIfCancellationRequested();
            }
        }
        if (kind >= SyntaxKind.FirstStatement && kind <= SyntaxKind.LastStatement && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode)) {
            errorOrSuggestion(compilerOptions.allowUnreachableCode === false, node, Diagnostics.Unreachable_code_detected);
        }

        // If editing this, keep `isSourceElement` in utilities up to date.
        switch (kind) {
            case SyntaxKind.TypeParameter:
                return checkTypeParameter(node as TypeParameterDeclaration);
            case SyntaxKind.Parameter:
                return checkParameter(node as ParameterDeclaration);
            case SyntaxKind.PropertyDeclaration:
                return checkPropertyDeclaration(node as PropertyDeclaration);
            case SyntaxKind.PropertySignature:
                return checkPropertySignature(node as PropertySignature);
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
                return checkSignatureDeclaration(node as SignatureDeclaration);
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.MethodSignature:
                return checkMethodDeclaration(node as MethodDeclaration | MethodSignature);
            case SyntaxKind.ClassStaticBlockDeclaration:
                return checkClassStaticBlockDeclaration(node as ClassStaticBlockDeclaration);
            case SyntaxKind.Constructor:
                return checkConstructorDeclaration(node as ConstructorDeclaration);
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
                return checkAccessorDeclaration(node as AccessorDeclaration);
            case SyntaxKind.TypeReference:
                return checkTypeReferenceNode(node as TypeReferenceNode);
            case SyntaxKind.TypePredicate:
                return checkTypePredicate(node as TypePredicateNode);
            case SyntaxKind.TypeQuery:
                return checkTypeQuery(node as TypeQueryNode);
            case SyntaxKind.TypeLiteral:
                return checkTypeLiteral(node as TypeLiteralNode);
            case SyntaxKind.ArrayType:
                return checkArrayType(node as ArrayTypeNode);
            case SyntaxKind.TupleType:
                return checkTupleType(node as TupleTypeNode);
            case SyntaxKind.UnionType:
            case SyntaxKind.IntersectionType:
                return checkUnionOrIntersectionType(node as UnionOrIntersectionTypeNode);
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.OptionalType:
            case SyntaxKind.RestType:
                return checkSourceElement((node as ParenthesizedTypeNode | OptionalTypeNode | RestTypeNode).type);
            case SyntaxKind.ThisType:
                return checkThisType(node as ThisTypeNode);
            case SyntaxKind.TypeOperator:
                return checkTypeOperator(node as TypeOperatorNode);
            case SyntaxKind.ConditionalType:
                return checkConditionalType(node as ConditionalTypeNode);
            case SyntaxKind.InferType:
                return checkInferType(node as InferTypeNode);
            case SyntaxKind.TemplateLiteralType:
                return checkTemplateLiteralType(node as TemplateLiteralTypeNode);
            case SyntaxKind.ImportType:
                return checkImportType(node as ImportTypeNode);
            case SyntaxKind.NamedTupleMember:
                return checkNamedTupleMember(node as NamedTupleMember);
            case SyntaxKind.JSDocAugmentsTag:
                return checkJSDocAugmentsTag(node as JSDocAugmentsTag);
            case SyntaxKind.JSDocImplementsTag:
                return checkJSDocImplementsTag(node as JSDocImplementsTag);
            case SyntaxKind.JSDocTypedefTag:
            case SyntaxKind.JSDocCallbackTag:
            case SyntaxKind.JSDocEnumTag:
                return checkJSDocTypeAliasTag(node as JSDocTypedefTag);
            case SyntaxKind.JSDocTemplateTag:
                return checkJSDocTemplateTag(node as JSDocTemplateTag);
            case SyntaxKind.JSDocTypeTag:
                return checkJSDocTypeTag(node as JSDocTypeTag);
            case SyntaxKind.JSDocLink:
            case SyntaxKind.JSDocLinkCode:
            case SyntaxKind.JSDocLinkPlain:
                return checkJSDocLinkLikeTag(node as JSDocLink | JSDocLinkCode | JSDocLinkPlain);
            case SyntaxKind.JSDocParameterTag:
                return checkJSDocParameterTag(node as JSDocParameterTag);
            case SyntaxKind.JSDocPropertyTag:
                return checkJSDocPropertyTag(node as JSDocPropertyTag);
            case SyntaxKind.JSDocFunctionType:
                checkJSDocFunctionType(node as JSDocFunctionType);
                // falls through
            case SyntaxKind.JSDocNonNullableType:
            case SyntaxKind.JSDocNullableType:
            case SyntaxKind.JSDocAllType:
            case SyntaxKind.JSDocUnknownType:
            case SyntaxKind.JSDocTypeLiteral:
                checkJSDocTypeIsInJsFile(node);
                forEachChild(node, checkSourceElement);
                return;
            case SyntaxKind.JSDocVariadicType:
                checkJSDocVariadicType(node as JSDocVariadicType);
                return;
            case SyntaxKind.JSDocTypeExpression:
                return checkSourceElement((node as JSDocTypeExpression).type);
            case SyntaxKind.JSDocPublicTag:
            case SyntaxKind.JSDocProtectedTag:
            case SyntaxKind.JSDocPrivateTag:
                return checkJSDocAccessibilityModifiers(node as JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag);
            case SyntaxKind.JSDocSatisfiesTag:
                return checkJSDocSatisfiesTag(node as JSDocSatisfiesTag);
            case SyntaxKind.JSDocThisTag:
                return checkJSDocThisTag(node as JSDocThisTag);
            case SyntaxKind.JSDocImportTag:
                return checkJSDocImportTag(node as JSDocImportTag);
            case SyntaxKind.IndexedAccessType:
                return checkIndexedAccessType(node as IndexedAccessTypeNode);
            case SyntaxKind.MappedType:
                return checkMappedType(node as MappedTypeNode);
            case SyntaxKind.FunctionDeclaration:
                return checkFunctionDeclaration(node as FunctionDeclaration);
            case SyntaxKind.Block:
            case SyntaxKind.ModuleBlock:
                return checkBlock(node as Block);
            case SyntaxKind.VariableStatement:
                return checkVariableStatement(node as VariableStatement);
            case SyntaxKind.ExpressionStatement:
                return checkExpressionStatement(node as ExpressionStatement);
            case SyntaxKind.IfStatement:
                return checkIfStatement(node as IfStatement);
            case SyntaxKind.DoStatement:
                return checkDoStatement(node as DoStatement);
            case SyntaxKind.WhileStatement:
                return checkWhileStatement(node as WhileStatement);
            case SyntaxKind.ForStatement:
                return checkForStatement(node as ForStatement);
            case SyntaxKind.ForInStatement:
                return checkForInStatement(node as ForInStatement);
            case SyntaxKind.ForOfStatement:
                return checkForOfStatement(node as ForOfStatement);
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.BreakStatement:
                return checkBreakOrContinueStatement(node as BreakOrContinueStatement);
            case SyntaxKind.ReturnStatement:
                return checkReturnStatement(node as ReturnStatement);
            case SyntaxKind.WithStatement:
                return checkWithStatement(node as WithStatement);
            case SyntaxKind.SwitchStatement:
                return checkSwitchStatement(node as SwitchStatement);
            case SyntaxKind.LabeledStatement:
                return checkLabeledStatement(node as LabeledStatement);
            case SyntaxKind.ThrowStatement:
                return checkThrowStatement(node as ThrowStatement);
            case SyntaxKind.TryStatement:
                return checkTryStatement(node as TryStatement);
            case SyntaxKind.VariableDeclaration:
                return checkVariableDeclaration(node as VariableDeclaration);
            case SyntaxKind.BindingElement:
                return checkBindingElement(node as BindingElement);
            case SyntaxKind.ClassDeclaration:
                return checkClassDeclaration(node as ClassDeclaration);
            case SyntaxKind.InterfaceDeclaration:
                return checkInterfaceDeclaration(node as InterfaceDeclaration);
            case SyntaxKind.TypeAliasDeclaration:
                return checkTypeAliasDeclaration(node as TypeAliasDeclaration);
            case SyntaxKind.EnumDeclaration:
                return checkEnumDeclaration(node as EnumDeclaration);
            case SyntaxKind.EnumMember:
                return checkEnumMember(node as EnumMember);
            case SyntaxKind.ModuleDeclaration:
                return checkModuleDeclaration(node as ModuleDeclaration);
            case SyntaxKind.ImportDeclaration:
                return checkImportDeclaration(node as ImportDeclaration);
            case SyntaxKind.ImportEqualsDeclaration:
                return checkImportEqualsDeclaration(node as ImportEqualsDeclaration);
            case SyntaxKind.ExportDeclaration:
                return checkExportDeclaration(node as ExportDeclaration);
            case SyntaxKind.ExportAssignment:
                return checkExportAssignment(node as ExportAssignment);
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.DebuggerStatement:
                checkGrammarStatementInAmbientContext(node);
                return;
            case SyntaxKind.MissingDeclaration:
                return checkMissingDeclaration(node);
        }
    }

    function checkJSDocCommentWorker(node: string | readonly JSDocComment[] | undefined) {
        if (isArray(node)) {
            forEach(node, tag => {
                if (isJSDocLinkLike(tag)) {
                    checkSourceElement(tag);
                }
            });
        }
    }

    function checkJSDocTypeIsInJsFile(node: Node): void {
        if (!isInJSFile(node)) {
            if (isJSDocNonNullableType(node) || isJSDocNullableType(node)) {
                const token = tokenToString(isJSDocNonNullableType(node) ? SyntaxKind.ExclamationToken : SyntaxKind.QuestionToken);
                const diagnostic = node.postfix
                    ? Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1
                    : Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1;
                const typeNode = node.type;
                const type = getTypeFromTypeNode(typeNode);
                grammarErrorOnNode(
                    node,
                    diagnostic,
                    token,
                    typeToString(
                        isJSDocNullableType(node) && !(type === neverType || type === voidType)
                            ? getUnionType(append([type, undefinedType], node.postfix ? undefined : nullType)) : type,
                    ),
                );
            }
            else {
                grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
        }
    }

    function checkJSDocVariadicType(node: JSDocVariadicType): void {
        checkJSDocTypeIsInJsFile(node);
        checkSourceElement(node.type);

        // Only legal location is in the *last* parameter tag or last parameter of a JSDoc function.
        const { parent } = node;
        if (isParameter(parent) && isJSDocFunctionType(parent.parent)) {
            if (last(parent.parent.parameters) !== parent) {
                error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
            }
            return;
        }

        if (!isJSDocTypeExpression(parent)) {
            error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
        }

        const paramTag = node.parent.parent;
        if (!isJSDocParameterTag(paramTag)) {
            error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
            return;
        }

        const param = getParameterSymbolFromJSDoc(paramTag);
        if (!param) {
            // We will error in `checkJSDocParameterTag`.
            return;
        }

        const host = getHostSignatureFromJSDoc(paramTag);
        if (!host || last(host.parameters).symbol !== param) {
            error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
        }
    }

    function getTypeFromJSDocVariadicType(node: JSDocVariadicType): Type {
        const type = getTypeFromTypeNode(node.type);
        const { parent } = node;
        const paramTag = node.parent.parent;
        if (isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag)) {
            // Else we will add a diagnostic, see `checkJSDocVariadicType`.
            const host = getHostSignatureFromJSDoc(paramTag);
            const isCallbackTag = isJSDocCallbackTag(paramTag.parent.parent);
            if (host || isCallbackTag) {
                /*
                Only return an array type if the corresponding parameter is marked as a rest parameter, or if there are no parameters.
                So in the following situation we will not create an array type:
                    /** @param {...number} a * /
                    function f(a) {}
                Because `a` will just be of type `number | undefined`. A synthetic `...args` will also be added, which *will* get an array type.
                */
                const lastParamDeclaration = isCallbackTag
                    ? lastOrUndefined((paramTag.parent.parent as unknown as JSDocCallbackTag).typeExpression.parameters)
                    : lastOrUndefined(host!.parameters);
                const symbol = getParameterSymbolFromJSDoc(paramTag);
                if (
                    !lastParamDeclaration ||
                    symbol && lastParamDeclaration.symbol === symbol && isRestParameter(lastParamDeclaration)
                ) {
                    return createArrayType(type);
                }
            }
        }
        if (isParameter(parent) && isJSDocFunctionType(parent.parent)) {
            return createArrayType(type);
        }
        return addOptionality(type);
    }

    // Function and class expression bodies are checked after all statements in the enclosing body. This is
    // to ensure constructs like the following are permitted:
    //     const foo = function () {
    //        const s = foo();
    //        return "hello";
    //     }
    // Here, performing a full type check of the body of the function expression whilst in the process of
    // determining the type of foo would cause foo to be given type any because of the recursive reference.
    // Delaying the type check of the body ensures foo has been assigned a type.
    function checkNodeDeferred(node: Node) {
        const enclosingFile = getSourceFileOfNode(node);
        const links = getNodeLinks(enclosingFile);
        if (!(links.flags & NodeCheckFlags.TypeChecked)) {
            links.deferredNodes ||= new Set();
            links.deferredNodes.add(node);
        }
        else {
            Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.");
        }
    }

    function checkDeferredNodes(context: SourceFile) {
        const links = getNodeLinks(context);
        if (links.deferredNodes) {
            links.deferredNodes.forEach(checkDeferredNode);
        }
        links.deferredNodes = undefined;
    }

    function checkDeferredNode(node: Node) {
        tracing?.push(tracing.Phase.Check, "checkDeferredNode", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath });
        const saveCurrentNode = currentNode;
        currentNode = node;
        instantiationCount = 0;
        switch (node.kind) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.Decorator:
            case SyntaxKind.JsxOpeningElement:
                // These node kinds are deferred checked when overload resolution fails
                // To save on work, we ensure the arguments are checked just once, in
                // a deferred way
                resolveUntypedCall(node as CallLikeExpression);
                break;
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.MethodSignature:
                checkFunctionExpressionOrObjectLiteralMethodDeferred(node as FunctionExpression);
                break;
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
                checkAccessorDeclaration(node as AccessorDeclaration);
                break;
            case SyntaxKind.ClassExpression:
                checkClassExpressionDeferred(node as ClassExpression);
                break;
            case SyntaxKind.TypeParameter:
                checkTypeParameterDeferred(node as TypeParameterDeclaration);
                break;
            case SyntaxKind.JsxSelfClosingElement:
                checkJsxSelfClosingElementDeferred(node as JsxSelfClosingElement);
                break;
            case SyntaxKind.JsxElement:
                checkJsxElementDeferred(node as JsxElement);
                break;
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.AsExpression:
            case SyntaxKind.ParenthesizedExpression:
                checkAssertionDeferred(node as AssertionExpression | JSDocTypeAssertion);
                break;
            case SyntaxKind.VoidExpression:
                checkExpression((node as VoidExpression).expression);
                break;
            case SyntaxKind.BinaryExpression:
                if (isInstanceOfExpression(node)) {
                    resolveUntypedCall(node);
                }
                break;
        }
        currentNode = saveCurrentNode;
        tracing?.pop();
    }

    function checkSourceFile(node: SourceFile, nodesToCheck: Node[] | undefined) {
        tracing?.push(tracing.Phase.Check, nodesToCheck ? "checkSourceFileNodes" : "checkSourceFile", { path: node.path }, /*separateBeginAndEnd*/ true);
        const beforeMark = nodesToCheck ? "beforeCheckNodes" : "beforeCheck";
        const afterMark = nodesToCheck ? "afterCheckNodes" : "afterCheck";
        performance.mark(beforeMark);
        nodesToCheck ? checkSourceFileNodesWorker(node, nodesToCheck) : checkSourceFileWorker(node);
        performance.mark(afterMark);
        performance.measure("Check", beforeMark, afterMark);
        tracing?.pop();
    }

    function unusedIsError(kind: UnusedKind, isAmbient: boolean): boolean {
        if (isAmbient) {
            return false;
        }
        switch (kind) {
            case UnusedKind.Local:
                return !!compilerOptions.noUnusedLocals;
            case UnusedKind.Parameter:
                return !!compilerOptions.noUnusedParameters;
            default:
                return Debug.assertNever(kind);
        }
    }

    function getPotentiallyUnusedIdentifiers(sourceFile: SourceFile): readonly PotentiallyUnusedIdentifier[] {
        return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray;
    }

    // Fully type check a source file and collect the relevant diagnostics.
    function checkSourceFileWorker(node: SourceFile) {
        const links = getNodeLinks(node);
        if (!(links.flags & NodeCheckFlags.TypeChecked)) {
            if (skipTypeChecking(node, compilerOptions, host)) {
                return;
            }

            // Grammar checking
            checkGrammarSourceFile(node);

            clear(potentialThisCollisions);
            clear(potentialNewTargetCollisions);
            clear(potentialWeakMapSetCollisions);
            clear(potentialReflectCollisions);
            clear(potentialUnusedRenamedBindingElementsInTypes);

            if (links.flags & NodeCheckFlags.PartiallyTypeChecked) {
                potentialThisCollisions = links.potentialThisCollisions!;
                potentialNewTargetCollisions = links.potentialNewTargetCollisions!;
                potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions!;
                potentialReflectCollisions = links.potentialReflectCollisions!;
                potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes!;
            }

            forEach(node.statements, checkSourceElement);
            checkSourceElement(node.endOfFileToken);

            checkDeferredNodes(node);

            if (isExternalOrCommonJsModule(node)) {
                registerForUnusedIdentifiersCheck(node);
            }

            addLazyDiagnostic(() => {
                // This relies on the results of other lazy diagnostics, so must be computed after them
                if (!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)) {
                    checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), (containingNode, kind, diag) => {
                        if (!containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {
                            diagnostics.add(diag);
                        }
                    });
                }
                if (!node.isDeclarationFile) {
                    checkPotentialUncheckedRenamedBindingElementsInTypes();
                }
            });

            if (isExternalOrCommonJsModule(node)) {
                checkExternalModuleExports(node);
            }

            if (potentialThisCollisions.length) {
                forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                clear(potentialThisCollisions);
            }

            if (potentialNewTargetCollisions.length) {
                forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope);
                clear(potentialNewTargetCollisions);
            }

            if (potentialWeakMapSetCollisions.length) {
                forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision);
                clear(potentialWeakMapSetCollisions);
            }

            if (potentialReflectCollisions.length) {
                forEach(potentialReflectCollisions, checkReflectCollision);
                clear(potentialReflectCollisions);
            }

            links.flags |= NodeCheckFlags.TypeChecked;
        }
    }

    function checkSourceFileNodesWorker(file: SourceFile, nodes: readonly Node[]) {
        const links = getNodeLinks(file);
        if (!(links.flags & NodeCheckFlags.TypeChecked)) {
            if (skipTypeChecking(file, compilerOptions, host)) {
                return;
            }

            // Grammar checking
            checkGrammarSourceFile(file);

            clear(potentialThisCollisions);
            clear(potentialNewTargetCollisions);
            clear(potentialWeakMapSetCollisions);
            clear(potentialReflectCollisions);
            clear(potentialUnusedRenamedBindingElementsInTypes);

            forEach(nodes, checkSourceElement);

            checkDeferredNodes(file);

            (links.potentialThisCollisions || (links.potentialThisCollisions = [])).push(...potentialThisCollisions);
            (links.potentialNewTargetCollisions || (links.potentialNewTargetCollisions = [])).push(...potentialNewTargetCollisions);
            (links.potentialWeakMapSetCollisions || (links.potentialWeakMapSetCollisions = [])).push(...potentialWeakMapSetCollisions);
            (links.potentialReflectCollisions || (links.potentialReflectCollisions = [])).push(...potentialReflectCollisions);
            (links.potentialUnusedRenamedBindingElementsInTypes || (links.potentialUnusedRenamedBindingElementsInTypes = [])).push(
                ...potentialUnusedRenamedBindingElementsInTypes,
            );

            links.flags |= NodeCheckFlags.PartiallyTypeChecked;
            for (const node of nodes) {
                const nodeLinks = getNodeLinks(node);
                nodeLinks.flags |= NodeCheckFlags.PartiallyTypeChecked;
            }
        }
    }

    function getDiagnostics(sourceFile: SourceFile, ct: CancellationToken, nodesToCheck?: Node[]): Diagnostic[] {
        try {
            // Record the cancellation token so it can be checked later on during checkSourceElement.
            // Do this in a finally block so we can ensure that it gets reset back to nothing after
            // this call is done.
            cancellationToken = ct;
            return getDiagnosticsWorker(sourceFile, nodesToCheck);
        }
        finally {
            cancellationToken = undefined;
        }
    }

    function ensurePendingDiagnosticWorkComplete() {
        // Invoke any existing lazy diagnostics to add them, clear the backlog of diagnostics
        for (const cb of deferredDiagnosticsCallbacks) {
            cb();
        }
        deferredDiagnosticsCallbacks = [];
    }

    function checkSourceFileWithEagerDiagnostics(sourceFile: SourceFile, nodesToCheck?: Node[]) {
        ensurePendingDiagnosticWorkComplete();
        // then setup diagnostics for immediate invocation (as we are about to collect them, and
        // this avoids the overhead of longer-lived callbacks we don't need to allocate)
        // This also serves to make the shift to possibly lazy diagnostics transparent to serial command-line scenarios
        // (as in those cases, all the diagnostics will still be computed as the appropriate place in the tree,
        // thus much more likely retaining the same union ordering as before we had lazy diagnostics)
        const oldAddLazyDiagnostics = addLazyDiagnostic;
        addLazyDiagnostic = cb => cb();
        checkSourceFile(sourceFile, nodesToCheck);
        addLazyDiagnostic = oldAddLazyDiagnostics;
    }

    function getDiagnosticsWorker(sourceFile: SourceFile, nodesToCheck: Node[] | undefined): Diagnostic[] {
        if (sourceFile) {
            ensurePendingDiagnosticWorkComplete();
            // Some global diagnostics are deferred until they are needed and
            // may not be reported in the first call to getGlobalDiagnostics.
            // We should catch these changes and report them.
            const previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            const previousGlobalDiagnosticsSize = previousGlobalDiagnostics.length;

            checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck);
            const semanticDiagnostics = diagnostics.getDiagnostics(sourceFile.fileName);
            if (nodesToCheck) {
                // No need to get global diagnostics.
                return semanticDiagnostics;
            }
            const currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
                // If the arrays are not the same reference, new diagnostics were added.
                const deferredGlobalDiagnostics = relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics);
                return concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
            }
            else if (previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0) {
                // If the arrays are the same reference, but the length has changed, a single
                // new diagnostic was added as DiagnosticCollection attempts to reuse the
                // same array.
                return concatenate(currentGlobalDiagnostics, semanticDiagnostics);
            }

            return semanticDiagnostics;
        }

        // Global diagnostics are always added when a file is not provided to
        // getDiagnostics
        forEach(host.getSourceFiles(), file => checkSourceFileWithEagerDiagnostics(file));
        return diagnostics.getDiagnostics();
    }

    function getGlobalDiagnostics(): Diagnostic[] {
        ensurePendingDiagnosticWorkComplete();
        return diagnostics.getGlobalDiagnostics();
    }

    // Language service support

    function getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[] {
        if (location.flags & NodeFlags.InWithStatement) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return [];
        }

        const symbols = createSymbolTable();
        let isStaticSymbol = false;

        populateSymbols();

        symbols.delete(InternalSymbolName.This); // Not a symbol, a keyword
        return symbolsToArray(symbols);

        function populateSymbols() {
            while (location) {
                if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {
                    copySymbols(location.locals, meaning);
                }

                switch (location.kind) {
                    case SyntaxKind.SourceFile:
                        if (!isExternalModule(location as SourceFile)) break;
                        // falls through
                    case SyntaxKind.ModuleDeclaration:
                        copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location as ModuleDeclaration | SourceFile).exports!, meaning & SymbolFlags.ModuleMember);
                        break;
                    case SyntaxKind.EnumDeclaration:
                        copySymbols(getSymbolOfDeclaration(location as EnumDeclaration).exports!, meaning & SymbolFlags.EnumMember);
                        break;
                    case SyntaxKind.ClassExpression:
                        const className = (location as ClassExpression).name;
                        if (className) {
                            copySymbol((location as ClassExpression).symbol, meaning);
                        }

                    // this fall-through is necessary because we would like to handle
                    // type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration.
                    // falls through
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.InterfaceDeclaration:
                        // If we didn't come from static member of class or interface,
                        // add the type parameters into the symbol table
                        // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.
                        // Note: that the memberFlags come from previous iteration.
                        if (!isStaticSymbol) {
                            copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location as ClassDeclaration | InterfaceDeclaration)), meaning & SymbolFlags.Type);
                        }
                        break;
                    case SyntaxKind.FunctionExpression:
                        const funcName = (location as FunctionExpression).name;
                        if (funcName) {
                            copySymbol((location as FunctionExpression).symbol, meaning);
                        }
                        break;
                }

                if (introducesArgumentsExoticObject(location)) {
                    copySymbol(argumentsSymbol, meaning);
                }

                isStaticSymbol = isStatic(location);
                location = location.parent;
            }

            copySymbols(globals, meaning);
        }

        /**
         * Copy the given symbol into symbol tables if the symbol has the given meaning
         * and it doesn't already existed in the symbol table
         * @param key a key for storing in symbol table; if undefined, use symbol.name
         * @param symbol the symbol to be added into symbol table
         * @param meaning meaning of symbol to filter by before adding to symbol table
         */
        function copySymbol(symbol: Symbol, meaning: SymbolFlags): void {
            if (getCombinedLocalAndExportSymbolFlags(symbol) & meaning) {
                const id = symbol.escapedName;
                // We will copy all symbol regardless of its reserved name because
                // symbolsToArray will check whether the key is a reserved name and
                // it will not copy symbol with reserved name to the array
                if (!symbols.has(id)) {
                    symbols.set(id, symbol);
                }
            }
        }

        function copySymbols(source: SymbolTable, meaning: SymbolFlags): void {
            if (meaning) {
                source.forEach(symbol => {
                    copySymbol(symbol, meaning);
                });
            }
        }

        function copyLocallyVisibleExportSymbols(source: SymbolTable, meaning: SymbolFlags): void {
            if (meaning) {
                source.forEach(symbol => {
                    // Similar condition as in `resolveNameHelper`
                    if (!getDeclarationOfKind(symbol, SyntaxKind.ExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKind.NamespaceExport) && symbol.escapedName !== InternalSymbolName.Default) {
                        copySymbol(symbol, meaning);
                    }
                });
            }
        }
    }

    function isTypeDeclarationName(name: Node): boolean {
        return name.kind === SyntaxKind.Identifier &&
            isTypeDeclaration(name.parent) &&
            getNameOfDeclaration(name.parent) === name;
    }

    // True if the given identifier is part of a type reference
    function isTypeReferenceIdentifier(node: EntityName): boolean {
        while (node.parent.kind === SyntaxKind.QualifiedName) {
            node = node.parent as QualifiedName;
        }

        return node.parent.kind === SyntaxKind.TypeReference;
    }

    function isInNameOfExpressionWithTypeArguments(node: Node): boolean {
        while (node.parent.kind === SyntaxKind.PropertyAccessExpression) {
            node = node.parent;
        }

        return node.parent.kind === SyntaxKind.ExpressionWithTypeArguments;
    }

    function forEachEnclosingClass<T>(node: Node, callback: (node: ClassLikeDeclaration) => T | undefined): T | undefined {
        let result: T | undefined;
        let containingClass = getContainingClass(node);
        while (containingClass) {
            if (result = callback(containingClass)) break;
            containingClass = getContainingClass(containingClass);
        }

        return result;
    }

    function isNodeUsedDuringClassInitialization(node: Node) {
        return !!findAncestor(node, element => {
            if (isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element)) {
                return true;
            }
            else if (isClassLike(element) || isFunctionLikeDeclaration(element)) {
                return "quit";
            }

            return false;
        });
    }

    function isNodeWithinClass(node: Node, classDeclaration: ClassLikeDeclaration) {
        return !!forEachEnclosingClass(node, n => n === classDeclaration);
    }

    function getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide: EntityName): ImportEqualsDeclaration | ExportAssignment | undefined {
        while (nodeOnRightSide.parent.kind === SyntaxKind.QualifiedName) {
            nodeOnRightSide = nodeOnRightSide.parent as QualifiedName;
        }

        if (nodeOnRightSide.parent.kind === SyntaxKind.ImportEqualsDeclaration) {
            return (nodeOnRightSide.parent as ImportEqualsDeclaration).moduleReference === nodeOnRightSide ? nodeOnRightSide.parent as ImportEqualsDeclaration : undefined;
        }

        if (nodeOnRightSide.parent.kind === SyntaxKind.ExportAssignment) {
            return (nodeOnRightSide.parent as ExportAssignment).expression === nodeOnRightSide as Node ? nodeOnRightSide.parent as ExportAssignment : undefined;
        }

        return undefined;
    }

    function isInRightSideOfImportOrExportAssignment(node: EntityName) {
        return getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined;
    }

    function getSpecialPropertyAssignmentSymbolFromEntityName(entityName: EntityName | PropertyAccessExpression) {
        const specialPropertyAssignmentKind = getAssignmentDeclarationKind(entityName.parent.parent as BinaryExpression);
        switch (specialPropertyAssignmentKind) {
            case AssignmentDeclarationKind.ExportsProperty:
            case AssignmentDeclarationKind.PrototypeProperty:
                return getSymbolOfNode(entityName.parent);
            case AssignmentDeclarationKind.Property:
                if (isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) === entityName) {
                    return undefined;
                }
                // falls through
            case AssignmentDeclarationKind.ThisProperty:
            case AssignmentDeclarationKind.ModuleExports:
                return getSymbolOfDeclaration(entityName.parent.parent as BinaryExpression);
        }
    }

    function isImportTypeQualifierPart(node: EntityName): ImportTypeNode | undefined {
        let parent = node.parent;
        while (isQualifiedName(parent)) {
            node = parent;
            parent = parent.parent;
        }
        if (parent && parent.kind === SyntaxKind.ImportType && (parent as ImportTypeNode).qualifier === node) {
            return parent as ImportTypeNode;
        }
        return undefined;
    }

    function isThisPropertyAndThisTyped(node: PropertyAccessExpression) {
        if (node.expression.kind === SyntaxKind.ThisKeyword) {
            const container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
            if (isFunctionLike(container)) {
                const containingLiteral = getContainingObjectLiteral(container);
                if (containingLiteral) {
                    const contextualType = getApparentTypeOfContextualType(containingLiteral, /*contextFlags*/ undefined);
                    const type = getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType);
                    return type && !isTypeAny(type);
                }
            }
        }
    }

    function getSymbolOfNameOrPropertyAccessExpression(name: EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName): Symbol | undefined {
        if (isDeclarationName(name)) {
            return getSymbolOfNode(name.parent);
        }

        if (
            isInJSFile(name) &&
            name.parent.kind === SyntaxKind.PropertyAccessExpression &&
            name.parent === (name.parent.parent as BinaryExpression).left
        ) {
            // Check if this is a special property assignment
            if (!isPrivateIdentifier(name) && !isJSDocMemberName(name) && !isThisPropertyAndThisTyped(name.parent as PropertyAccessExpression)) {
                const specialPropertyAssignmentSymbol = getSpecialPropertyAssignmentSymbolFromEntityName(name);
                if (specialPropertyAssignmentSymbol) {
                    return specialPropertyAssignmentSymbol;
                }
            }
        }

        if (name.parent.kind === SyntaxKind.ExportAssignment && isEntityNameExpression(name)) {
            // Even an entity name expression that doesn't resolve as an entityname may still typecheck as a property access expression
            const success = resolveEntityName(name, /*all meanings*/ SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*ignoreErrors*/ true);
            if (success && success !== unknownSymbol) {
                return success;
            }
        }
        else if (isEntityName(name) && isInRightSideOfImportOrExportAssignment(name)) {
            // Since we already checked for ExportAssignment, this really could only be an Import
            const importEqualsDeclaration = getAncestor(name, SyntaxKind.ImportEqualsDeclaration);
            Debug.assert(importEqualsDeclaration !== undefined);
            return getSymbolOfPartOfRightHandSideOfImportEquals(name, /*dontResolveAlias*/ true);
        }

        if (isEntityName(name)) {
            const possibleImportNode = isImportTypeQualifierPart(name);
            if (possibleImportNode) {
                getTypeFromTypeNode(possibleImportNode);
                const sym = getNodeLinks(name).resolvedSymbol;
                return sym === unknownSymbol ? undefined : sym;
            }
        }

        while (isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {
            name = name.parent as QualifiedName | PropertyAccessEntityNameExpression | JSDocMemberName;
        }

        if (isInNameOfExpressionWithTypeArguments(name)) {
            let meaning = SymbolFlags.None;
            if (name.parent.kind === SyntaxKind.ExpressionWithTypeArguments) {
                // An 'ExpressionWithTypeArguments' may appear in type space (interface Foo extends Bar<T>),
                // value space (return foo<T>), or both(class Foo extends Bar<T>); ensure the meaning matches.
                meaning = isPartOfTypeNode(name) ? SymbolFlags.Type : SymbolFlags.Value;

                // In a class 'extends' clause we are also looking for a value.
                if (isExpressionWithTypeArgumentsInClassExtendsClause(name.parent)) {
                    meaning |= SymbolFlags.Value;
                }
            }
            else {
                meaning = SymbolFlags.Namespace;
            }

            meaning |= SymbolFlags.Alias;
            const entityNameSymbol = isEntityNameExpression(name) ? resolveEntityName(name, meaning, /*ignoreErrors*/ true) : undefined;
            if (entityNameSymbol) {
                return entityNameSymbol;
            }
        }

        if (name.parent.kind === SyntaxKind.JSDocParameterTag) {
            return getParameterSymbolFromJSDoc(name.parent as JSDocParameterTag);
        }

        if (name.parent.kind === SyntaxKind.TypeParameter && name.parent.parent.kind === SyntaxKind.JSDocTemplateTag) {
            Debug.assert(!isInJSFile(name)); // Otherwise `isDeclarationName` would have been true.
            const typeParameter = getTypeParameterFromJsDoc(name.parent as TypeParameterDeclaration & { parent: JSDocTemplateTag; });
            return typeParameter && typeParameter.symbol;
        }

        if (isExpressionNode(name)) {
            if (nodeIsMissing(name)) {
                // Missing entity name.
                return undefined;
            }

            const isJSDoc = findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName));
            const meaning = isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : SymbolFlags.Value;
            if (name.kind === SyntaxKind.Identifier) {
                if (isJSXTagName(name) && isJsxIntrinsicTagName(name)) {
                    const symbol = getIntrinsicTagSymbol(name.parent as JsxOpeningLikeElement);
                    return symbol === unknownSymbol ? undefined : symbol;
                }
                const result = resolveEntityName(name, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, getHostSignatureFromJSDoc(name));
                if (!result && isJSDoc) {
                    const container = findAncestor(name, or(isClassLike, isInterfaceDeclaration));
                    if (container) {
                        return resolveJSDocMemberName(name, /*ignoreErrors*/ true, getSymbolOfDeclaration(container));
                    }
                }
                if (result && isJSDoc) {
                    const container = getJSDocHost(name);
                    if (container && isEnumMember(container) && container === result.valueDeclaration) {
                        return resolveEntityName(name, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, getSourceFileOfNode(container)) || result;
                    }
                }
                return result;
            }
            else if (isPrivateIdentifier(name)) {
                return getSymbolForPrivateIdentifierExpression(name);
            }
            else if (name.kind === SyntaxKind.PropertyAccessExpression || name.kind === SyntaxKind.QualifiedName) {
                const links = getNodeLinks(name);
                if (links.resolvedSymbol) {
                    return links.resolvedSymbol;
                }

                if (name.kind === SyntaxKind.PropertyAccessExpression) {
                    checkPropertyAccessExpression(name, CheckMode.Normal);
                    if (!links.resolvedSymbol) {
                        links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression), getLiteralTypeFromPropertyName(name.name));
                    }
                }
                else {
                    checkQualifiedName(name, CheckMode.Normal);
                }
                if (!links.resolvedSymbol && isJSDoc && isQualifiedName(name)) {
                    return resolveJSDocMemberName(name);
                }
                return links.resolvedSymbol;
            }
            else if (isJSDocMemberName(name)) {
                return resolveJSDocMemberName(name);
            }
        }
        else if (isEntityName(name) && isTypeReferenceIdentifier(name)) {
            const meaning = name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace;
            const symbol = resolveEntityName(name, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true);
            return symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name);
        }
        if (name.parent.kind === SyntaxKind.TypePredicate) {
            return resolveEntityName(name as Identifier, /*meaning*/ SymbolFlags.FunctionScopedVariable, /*ignoreErrors*/ true);
        }
        return undefined;
    }

    function getApplicableIndexSymbol(type: Type, keyType: Type) {
        const infos = getApplicableIndexInfos(type, keyType);
        if (infos.length && (type as ObjectType).members) {
            const symbol = getIndexSymbolFromSymbolTable(resolveStructuredTypeMembers(type as ObjectType).members);
            if (infos === getIndexInfosOfType(type)) {
                return symbol;
            }
            else if (symbol) {
                const symbolLinks = getSymbolLinks(symbol);
                const declarationList = mapDefined(infos, i => i.declaration);
                const nodeListId = map(declarationList, getNodeId).join(",");
                if (!symbolLinks.filteredIndexSymbolCache) {
                    symbolLinks.filteredIndexSymbolCache = new Map();
                }
                if (symbolLinks.filteredIndexSymbolCache.has(nodeListId)) {
                    return symbolLinks.filteredIndexSymbolCache.get(nodeListId)!;
                }
                else {
                    const copy = createSymbol(SymbolFlags.Signature, InternalSymbolName.Index);
                    copy.declarations = mapDefined(infos, i => i.declaration);
                    copy.parent = type.aliasSymbol ? type.aliasSymbol : type.symbol ? type.symbol : getSymbolAtLocation(copy.declarations[0].parent);
                    symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy);
                    return copy;
                }
            }
        }
    }

    /**
     * Recursively resolve entity names and jsdoc instance references:
     * 1. K#m as K.prototype.m for a class (or other value) K
     * 2. K.m as K.prototype.m
     * 3. I.m as I.m for a type I, or any other I.m that fails to resolve in (1) or (2)
     *
     * For unqualified names, a container K may be provided as a second argument.
     */
    function resolveJSDocMemberName(name: EntityName | JSDocMemberName, ignoreErrors?: boolean, container?: Symbol): Symbol | undefined {
        if (isEntityName(name)) {
            // resolve static values first
            const meaning = SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value;
            let symbol = resolveEntityName(name, meaning, ignoreErrors, /*dontResolveAlias*/ true, getHostSignatureFromJSDoc(name));
            if (!symbol && isIdentifier(name) && container) {
                symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning));
            }
            if (symbol) {
                return symbol;
            }
        }
        const left = isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container);
        const right = isIdentifier(name) ? name.escapedText : name.right.escapedText;
        if (left) {
            const proto = left.flags & SymbolFlags.Value && getPropertyOfType(getTypeOfSymbol(left), "prototype" as __String);
            const t = proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left);
            return getPropertyOfType(t, right);
        }
    }

    function getSymbolAtLocation(node: Node, ignoreErrors?: boolean): Symbol | undefined {
        if (isSourceFile(node)) {
            return isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined;
        }
        const { parent } = node;
        const grandParent = parent.parent;

        if (node.flags & NodeFlags.InWithStatement) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return undefined;
        }

        if (isDeclarationNameOrImportPropertyName(node)) {
            // This is a declaration, call getSymbolOfNode
            const parentSymbol = getSymbolOfDeclaration(parent as Declaration);
            return isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node
                ? getImmediateAliasedSymbol(parentSymbol)
                : parentSymbol;
        }
        else if (isLiteralComputedPropertyDeclarationName(node)) {
            return getSymbolOfDeclaration(parent.parent as Declaration);
        }

        if (node.kind === SyntaxKind.Identifier) {
            if (isInRightSideOfImportOrExportAssignment(node as Identifier)) {
                return getSymbolOfNameOrPropertyAccessExpression(node as Identifier);
            }
            else if (
                parent.kind === SyntaxKind.BindingElement &&
                grandParent.kind === SyntaxKind.ObjectBindingPattern &&
                node === (parent as BindingElement).propertyName
            ) {
                const typeOfPattern = getTypeOfNode(grandParent);
                const propertyDeclaration = getPropertyOfType(typeOfPattern, (node as Identifier).escapedText);

                if (propertyDeclaration) {
                    return propertyDeclaration;
                }
            }
            else if (isMetaProperty(parent) && parent.name === node) {
                if (parent.keywordToken === SyntaxKind.NewKeyword && idText(node as Identifier) === "target") {
                    // `target` in `new.target`
                    return checkNewTargetMetaProperty(parent).symbol;
                }
                // The `meta` in `import.meta` could be given `getTypeOfNode(parent).symbol` (the `ImportMeta` interface symbol), but
                // we have a fake expression type made for other reasons already, whose transient `meta`
                // member should more exactly be the kind of (declarationless) symbol we want.
                // (See #44364 and #45031 for relevant implementation PRs)
                if (parent.keywordToken === SyntaxKind.ImportKeyword && idText(node as Identifier) === "meta") {
                    return getGlobalImportMetaExpressionType().members!.get("meta" as __String);
                }
                // no other meta properties are valid syntax, thus no others should have symbols
                return undefined;
            }
        }

        switch (node.kind) {
            case SyntaxKind.Identifier:
            case SyntaxKind.PrivateIdentifier:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.QualifiedName:
                if (!isThisInTypeQuery(node)) {
                    return getSymbolOfNameOrPropertyAccessExpression(node as EntityName | PrivateIdentifier | PropertyAccessExpression);
                }
                // falls through

            case SyntaxKind.ThisKeyword:
                const container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
                if (isFunctionLike(container)) {
                    const sig = getSignatureFromDeclaration(container);
                    if (sig.thisParameter) {
                        return sig.thisParameter;
                    }
                }
                if (isInExpressionContext(node)) {
                    return checkExpression(node as Expression).symbol;
                }
                // falls through

            case SyntaxKind.ThisType:
                return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode).symbol;

            case SyntaxKind.SuperKeyword:
                return checkExpression(node as Expression).symbol;

            case SyntaxKind.ConstructorKeyword:
                // constructor keyword for an overload, should take us to the definition if it exist
                const constructorDeclaration = node.parent;
                if (constructorDeclaration && constructorDeclaration.kind === SyntaxKind.Constructor) {
                    return (constructorDeclaration.parent as ClassDeclaration).symbol;
                }
                return undefined;

            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
                // 1). import x = require("./mo/*gotToDefinitionHere*/d")
                // 2). External module name in an import declaration
                // 3). Dynamic import call or require in javascript
                // 4). type A = import("./f/*gotToDefinitionHere*/oo")
                if (
                    (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||
                    ((node.parent.kind === SyntaxKind.ImportDeclaration || node.parent.kind === SyntaxKind.ExportDeclaration) && (node.parent as ImportDeclaration).moduleSpecifier === node) ||
                    (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier === node) ||
                    ((isInJSFile(node) && isRequireCall(node.parent, /*requireStringLiteralLikeArgument*/ false)) || isImportCall(node.parent)) ||
                    (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent)
                ) {
                    return resolveExternalModuleName(node, node as LiteralExpression, ignoreErrors);
                }
                if (isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] === node) {
                    return getSymbolOfDeclaration(parent);
                }
                // falls through

            case SyntaxKind.NumericLiteral:
                // index access
                const objectType = isElementAccessExpression(parent)
                    ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined
                    : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent)
                    ? getTypeFromTypeNode(grandParent.objectType)
                    : undefined;
                return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores((node as StringLiteral | NumericLiteral).text));

            case SyntaxKind.DefaultKeyword:
            case SyntaxKind.FunctionKeyword:
            case SyntaxKind.EqualsGreaterThanToken:
            case SyntaxKind.ClassKeyword:
                return getSymbolOfNode(node.parent);
            case SyntaxKind.ImportType:
                return isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined;

            case SyntaxKind.ExportKeyword:
                return isExportAssignment(node.parent) ? Debug.checkDefined(node.parent.symbol) : undefined;

            case SyntaxKind.ImportKeyword:
                if (isMetaProperty(node.parent) && node.parent.name.escapedText === "defer") {
                    return undefined;
                }
                // falls through
            case SyntaxKind.NewKeyword:
                return isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : undefined;
            case SyntaxKind.InstanceOfKeyword:
                if (isBinaryExpression(node.parent)) {
                    const type = getTypeOfExpression(node.parent.right);
                    const hasInstanceMethodType = getSymbolHasInstanceMethodOfObjectType(type);
                    return hasInstanceMethodType?.symbol ?? type.symbol;
                }
                return undefined;
            case SyntaxKind.MetaProperty:
                return checkExpression(node as Expression).symbol;
            case SyntaxKind.JsxNamespacedName:
                if (isJSXTagName(node) && isJsxIntrinsicTagName(node)) {
                    const symbol = getIntrinsicTagSymbol(node.parent as JsxOpeningLikeElement);
                    return symbol === unknownSymbol ? undefined : symbol;
                }
                // falls through

            default:
                return undefined;
        }
    }

    function getIndexInfosAtLocation(node: Node): readonly IndexInfo[] | undefined {
        if (isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name === node) {
            const keyType = getLiteralTypeFromPropertyName(node);
            const objectType = getTypeOfExpression(node.parent.expression);
            const objectTypes = objectType.flags & TypeFlags.Union ? (objectType as UnionType).types : [objectType];
            return flatMap(objectTypes, t => filter(getIndexInfosOfType(t), info => isApplicableIndexType(keyType, info.keyType)));
        }
        return undefined;
    }

    function getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined {
        if (location && location.kind === SyntaxKind.ShorthandPropertyAssignment) {
            return resolveEntityName((location as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Alias, /*ignoreErrors*/ true);
        }
        return undefined;
    }

    /** Returns the target of an export specifier without following aliases */
    function getExportSpecifierLocalTargetSymbol(node: ExportSpecifier | Identifier): Symbol | undefined {
        if (isExportSpecifier(node)) {
            const name = node.propertyName || node.name;
            return node.parent.parent.moduleSpecifier ?
                getExternalModuleMember(node.parent.parent, node) :
                name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }
                resolveEntityName(name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*ignoreErrors*/ true);
        }
        else {
            return resolveEntityName(node, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*ignoreErrors*/ true);
        }
    }

    function getTypeOfNode(node: Node): Type {
        if (isSourceFile(node) && !isExternalModule(node)) {
            return errorType;
        }

        if (node.flags & NodeFlags.InWithStatement) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return errorType;
        }

        const classDecl = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
        const classType = classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class));
        if (isPartOfTypeNode(node)) {
            const typeFromTypeNode = getTypeFromTypeNode(node as TypeNode);
            return classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode;
        }

        if (isExpressionNode(node)) {
            return getRegularTypeOfExpression(node as Expression);
        }

        if (classType && !classDecl.isImplements) {
            // A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
            // extends clause of a class. We handle that case here.
            const baseType = firstOrUndefined(getBaseTypes(classType));
            return baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType;
        }

        if (isTypeDeclaration(node)) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            const symbol = getSymbolOfDeclaration(node);
            return getDeclaredTypeOfSymbol(symbol);
        }

        if (isTypeDeclarationName(node)) {
            const symbol = getSymbolAtLocation(node);
            return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
        }

        if (isBindingElement(node)) {
            return getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ true, CheckMode.Normal) || errorType;
        }

        if (isDeclaration(node)) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            const symbol = getSymbolOfDeclaration(node);
            return symbol ? getTypeOfSymbol(symbol) : errorType;
        }

        if (isDeclarationNameOrImportPropertyName(node)) {
            const symbol = getSymbolAtLocation(node);
            if (symbol) {
                return getTypeOfSymbol(symbol);
            }
            return errorType;
        }

        if (isBindingPattern(node)) {
            return getTypeForVariableLikeDeclaration(node.parent, /*includeOptionality*/ true, CheckMode.Normal) || errorType;
        }

        if (isInRightSideOfImportOrExportAssignment(node as Identifier)) {
            const symbol = getSymbolAtLocation(node);
            if (symbol) {
                const declaredType = getDeclaredTypeOfSymbol(symbol);
                return !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol);
            }
        }

        if (isMetaProperty(node.parent) && node.parent.keywordToken === node.kind) {
            return checkMetaPropertyKeyword(node.parent);
        }

        if (isImportAttributes(node)) {
            return getGlobalImportAttributesType(/*reportErrors*/ false);
        }

        return errorType;
    }

    // Gets the type of object literal or array literal of destructuring assignment.
    // { a } from
    //     for ( { a } of elems) {
    //     }
    // [ a ] from
    //     [a] = [ some array ...]
    function getTypeOfAssignmentPattern(expr: AssignmentPattern): Type | undefined {
        Debug.assert(expr.kind === SyntaxKind.ObjectLiteralExpression || expr.kind === SyntaxKind.ArrayLiteralExpression);
        // If this is from "for of"
        //     for ( { a } of elems) {
        //     }
        if (expr.parent.kind === SyntaxKind.ForOfStatement) {
            const iteratedType = checkRightHandSideOfForOf(expr.parent as ForOfStatement);
            return checkDestructuringAssignment(expr, iteratedType || errorType);
        }
        // If this is from "for" initializer
        //     for ({a } = elems[0];.....) { }
        if (expr.parent.kind === SyntaxKind.BinaryExpression) {
            const iteratedType = getTypeOfExpression((expr.parent as BinaryExpression).right);
            return checkDestructuringAssignment(expr, iteratedType || errorType);
        }
        // If this is from nested object binding pattern
        //     for ({ skills: { primary, secondary } } = multiRobot, i = 0; i < 1; i++) {
        if (expr.parent.kind === SyntaxKind.PropertyAssignment) {
            const node = cast(expr.parent.parent, isObjectLiteralExpression);
            const typeOfParentObjectLiteral = getTypeOfAssignmentPattern(node) || errorType;
            const propertyIndex = indexOfNode(node.properties, expr.parent);
            return checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex);
        }
        // Array literal assignment - array destructuring pattern
        const node = cast(expr.parent, isArrayLiteralExpression);
        //    [{ property1: p1, property2 }] = elems;
        const typeOfArrayLiteral = getTypeOfAssignmentPattern(node) || errorType;
        const elementType = checkIteratedTypeOrElementType(IterationUse.Destructuring, typeOfArrayLiteral, undefinedType, expr.parent) || errorType;
        return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType);
    }

    // Gets the property symbol corresponding to the property in destructuring assignment
    // 'property1' from
    //     for ( { property1: a } of elems) {
    //     }
    // 'property1' at location 'a' from:
    //     [a] = [ property1, property2 ]
    function getPropertySymbolOfDestructuringAssignment(location: Identifier) {
        // Get the type of the object or array literal and then look for property of given name in the type
        const typeOfObjectLiteral = getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern));
        return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText);
    }

    function getRegularTypeOfExpression(expr: Expression): Type {
        if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
            expr = expr.parent as Expression;
        }
        return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
    }

    /**
     * Gets either the static or instance type of a class element, based on
     * whether the element is declared as "static".
     */
    function getParentTypeOfClassElement(node: ClassElement) {
        const classSymbol = getSymbolOfNode(node.parent)!;
        return isStatic(node)
            ? getTypeOfSymbol(classSymbol)
            : getDeclaredTypeOfSymbol(classSymbol);
    }

    function getClassElementPropertyKeyType(element: ClassElement) {
        const name = element.name!;
        switch (name.kind) {
            case SyntaxKind.Identifier:
                return getStringLiteralType(idText(name));
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.StringLiteral:
                return getStringLiteralType(name.text);
            case SyntaxKind.ComputedPropertyName:
                const nameType = checkComputedPropertyName(name);
                return isTypeAssignableToKind(nameType, TypeFlags.ESSymbolLike) ? nameType : stringType;
            default:
                return Debug.fail("Unsupported property name.");
        }
    }

    // Return the list of properties of the given type, augmented with properties from Function
    // if the type has call or construct signatures
    function getAugmentedPropertiesOfType(type: Type): Symbol[] {
        type = getApparentType(type);
        const propsByName = createSymbolTable(getPropertiesOfType(type));
        const functionType = getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType :
            getSignaturesOfType(type, SignatureKind.Construct).length ? globalNewableFunctionType :
            undefined;
        if (functionType) {
            forEach(getPropertiesOfType(functionType), p => {
                if (!propsByName.has(p.escapedName)) {
                    propsByName.set(p.escapedName, p);
                }
            });
        }
        return getNamedMembers(propsByName);
    }

    function typeHasCallOrConstructSignatures(type: Type): boolean {
        return getSignaturesOfType(type, SignatureKind.Call).length !== 0 || getSignaturesOfType(type, SignatureKind.Construct).length !== 0;
    }

    function getRootSymbols(symbol: Symbol): readonly Symbol[] {
        const roots = getImmediateRootSymbols(symbol);
        return roots ? flatMap(roots, getRootSymbols) : [symbol];
    }
    function getImmediateRootSymbols(symbol: Symbol): readonly Symbol[] | undefined {
        if (getCheckFlags(symbol) & CheckFlags.Synthetic) {
            return mapDefined(getSymbolLinks(symbol).containingType!.types, type => getPropertyOfType(type, symbol.escapedName));
        }
        else if (symbol.flags & SymbolFlags.Transient) {
            const { links: { leftSpread, rightSpread, syntheticOrigin } } = symbol as TransientSymbol;
            return leftSpread ? [leftSpread, rightSpread!]
                : syntheticOrigin ? [syntheticOrigin]
                : singleElementArray(tryGetTarget(symbol));
        }
        return undefined;
    }
    function tryGetTarget(symbol: Symbol): Symbol | undefined {
        let target: Symbol | undefined;
        let next: Symbol | undefined = symbol;
        while (next = getSymbolLinks(next).target) {
            target = next;
        }
        return target;
    }

    // Emitter support

    function isArgumentsLocalBinding(nodeIn: Identifier): boolean {
        // Note: does not handle isShorthandPropertyAssignment (and probably a few more)
        if (isGeneratedIdentifier(nodeIn)) return false;
        const node = getParseTreeNode(nodeIn, isIdentifier);
        if (!node) return false;
        const parent = node.parent;
        if (!parent) return false;
        const isPropertyName = (isPropertyAccessExpression(parent)
            || isPropertyAssignment(parent))
            && parent.name === node;
        return !isPropertyName && getReferencedValueSymbol(node) === argumentsSymbol;
    }

    function isNameOfModuleOrEnumDeclaration(node: Identifier) {
        return isModuleOrEnumDeclaration(node.parent) && node === node.parent.name;
    }

    // When resolved as an expression identifier, if the given node references an exported entity, return the declaration
    // node of the exported entity's container. Otherwise, return undefined.
    function getReferencedExportContainer(nodeIn: Identifier, prefixLocals?: boolean): SourceFile | ModuleDeclaration | EnumDeclaration | undefined {
        const node = getParseTreeNode(nodeIn, isIdentifier);
        if (node) {
            // When resolving the export container for the name of a module or enum
            // declaration, we need to start resolution at the declaration's container.
            // Otherwise, we could incorrectly resolve the export container as the
            // declaration if it contains an exported member with the same name.
            let symbol = getReferencedValueSymbol(node, /*startInDeclarationContainer*/ isNameOfModuleOrEnumDeclaration(node));
            if (symbol) {
                if (symbol.flags & SymbolFlags.ExportValue) {
                    // If we reference an exported entity within the same module declaration, then whether
                    // we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
                    // kinds that we do NOT prefix.
                    const exportSymbol = getMergedSymbol(symbol.exportSymbol!);
                    if (!prefixLocals && exportSymbol.flags & SymbolFlags.ExportHasLocal && !(exportSymbol.flags & SymbolFlags.Variable)) {
                        return undefined;
                    }
                    symbol = exportSymbol;
                }
                const parentSymbol = getParentOfSymbol(symbol);
                if (parentSymbol) {
                    if (parentSymbol.flags & SymbolFlags.ValueModule && parentSymbol.valueDeclaration?.kind === SyntaxKind.SourceFile) {
                        const symbolFile = parentSymbol.valueDeclaration as SourceFile;
                        const referenceFile = getSourceFileOfNode(node);
                        // If `node` accesses an export and that export isn't in the same file, then symbol is a namespace export, so return undefined.
                        const symbolIsUmdExport = symbolFile !== referenceFile;
                        return symbolIsUmdExport ? undefined : symbolFile;
                    }
                    return findAncestor(node.parent, (n): n is ModuleDeclaration | EnumDeclaration => isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) === parentSymbol);
                }
            }
        }
    }

    // When resolved as an expression identifier, if the given node references an import, return the declaration of
    // that import. Otherwise, return undefined.
    function getReferencedImportDeclaration(nodeIn: Identifier): Declaration | undefined {
        const specifier = getIdentifierGeneratedImportReference(nodeIn);
        if (specifier) {
            return specifier;
        }
        const node = getParseTreeNode(nodeIn, isIdentifier);
        if (node) {
            const symbol = getReferencedValueOrAliasSymbol(node);

            // We should only get the declaration of an alias if there isn't a local value
            // declaration for the symbol
            if (isNonLocalAlias(symbol, /*excludes*/ SymbolFlags.Value) && !getTypeOnlyAliasDeclaration(symbol, SymbolFlags.Value)) {
                return getDeclarationOfAliasSymbol(symbol);
            }
        }

        return undefined;
    }

    function isSymbolOfDestructuredElementOfCatchBinding(symbol: Symbol) {
        return symbol.valueDeclaration
            && isBindingElement(symbol.valueDeclaration)
            && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind === SyntaxKind.CatchClause;
    }

    function isSymbolOfDeclarationWithCollidingName(symbol: Symbol): boolean {
        if (symbol.flags & SymbolFlags.BlockScoped && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration)) {
            const links = getSymbolLinks(symbol);
            if (links.isDeclarationWithCollidingName === undefined) {
                const container = getEnclosingBlockScopeContainer(symbol.valueDeclaration);
                if (isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol)) {
                    if (resolveName(container.parent, symbol.escapedName, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false)) {
                        // redeclaration - always should be renamed
                        links.isDeclarationWithCollidingName = true;
                    }
                    else if (hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlags.CapturedBlockScopedBinding)) {
                        // binding is captured in the function
                        // should be renamed if:
                        // - binding is not top level - top level bindings never collide with anything
                        // AND
                        //   - binding is not declared in loop, should be renamed to avoid name reuse across siblings
                        //     let a, b
                        //     { let x = 1; a = () => x; }
                        //     { let x = 100; b = () => x; }
                        //     console.log(a()); // should print '1'
                        //     console.log(b()); // should print '100'
                        //     OR
                        //   - binding is declared inside loop but not in inside initializer of iteration statement or directly inside loop body
                        //     * variables from initializer are passed to rewritten loop body as parameters so they are not captured directly
                        //     * variables that are declared immediately in loop body will become top level variable after loop is rewritten and thus
                        //       they will not collide with anything
                        const isDeclaredInLoop = hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlags.BlockScopedBindingInLoop);
                        const inLoopInitializer = isIterationStatement(container, /*lookInLabeledStatements*/ false);
                        const inLoopBodyBlock = container.kind === SyntaxKind.Block && isIterationStatement(container.parent, /*lookInLabeledStatements*/ false);

                        links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock));
                    }
                    else {
                        links.isDeclarationWithCollidingName = false;
                    }
                }
            }
            return links.isDeclarationWithCollidingName!;
        }
        return false;
    }

    // When resolved as an expression identifier, if the given node references a nested block scoped entity with
    // a name that either hides an existing name or might hide it when compiled downlevel,
    // return the declaration of that entity. Otherwise, return undefined.
    function getReferencedDeclarationWithCollidingName(nodeIn: Identifier): Declaration | undefined {
        if (!isGeneratedIdentifier(nodeIn)) {
            const node = getParseTreeNode(nodeIn, isIdentifier);
            if (node) {
                const symbol = getReferencedValueSymbol(node);
                if (symbol && isSymbolOfDeclarationWithCollidingName(symbol)) {
                    return symbol.valueDeclaration;
                }
            }
        }

        return undefined;
    }

    // Return true if the given node is a declaration of a nested block scoped entity with a name that either hides an
    // existing name or might hide a name when compiled downlevel
    function isDeclarationWithCollidingName(nodeIn: Declaration): boolean {
        const node = getParseTreeNode(nodeIn, isDeclaration);
        if (node) {
            const symbol = getSymbolOfDeclaration(node);
            if (symbol) {
                return isSymbolOfDeclarationWithCollidingName(symbol);
            }
        }

        return false;
    }

    function isValueAliasDeclaration(node: Node): boolean {
        Debug.assert(canCollectSymbolAliasAccessabilityData);
        switch (node.kind) {
            case SyntaxKind.ImportEqualsDeclaration:
                return isAliasResolvedToValue(getSymbolOfDeclaration(node as ImportEqualsDeclaration));
            case SyntaxKind.ImportClause:
            case SyntaxKind.NamespaceImport:
            case SyntaxKind.ImportSpecifier:
            case SyntaxKind.ExportSpecifier:
                const symbol = getSymbolOfDeclaration(node as ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier);
                return !!symbol && isAliasResolvedToValue(symbol, /*excludeTypeOnlyValues*/ true);
            case SyntaxKind.ExportDeclaration:
                const exportClause = (node as ExportDeclaration).exportClause;
                return !!exportClause && (
                    isNamespaceExport(exportClause) ||
                    some(exportClause.elements, isValueAliasDeclaration)
                );
            case SyntaxKind.ExportAssignment:
                return (node as ExportAssignment).expression && (node as ExportAssignment).expression.kind === SyntaxKind.Identifier ?
                    isAliasResolvedToValue(getSymbolOfDeclaration(node as ExportAssignment), /*excludeTypeOnlyValues*/ true) :
                    true;
        }
        return false;
    }

    function isTopLevelValueImportEqualsWithEntityName(nodeIn: ImportEqualsDeclaration): boolean {
        const node = getParseTreeNode(nodeIn, isImportEqualsDeclaration);
        if (node === undefined || node.parent.kind !== SyntaxKind.SourceFile || !isInternalModuleImportEqualsDeclaration(node)) {
            // parent is not source file or it is not reference to internal module
            return false;
        }

        const isValue = isAliasResolvedToValue(getSymbolOfDeclaration(node));
        return isValue && node.moduleReference && !nodeIsMissing(node.moduleReference);
    }

    function isAliasResolvedToValue(symbol: Symbol | undefined, excludeTypeOnlyValues?: boolean): boolean {
        if (!symbol) {
            return false;
        }
        const container = getSourceFileOfNode(symbol.valueDeclaration);
        const fileSymbol = container && getSymbolOfDeclaration(container);
        // Ensures cjs export assignment is setup, since this symbol may point at, and merge with, the file itself.
        // If we don't, the merge may not have yet occured, and the flags check below will be missing flags that
        // are added as a result of the merge.
        void resolveExternalModuleSymbol(fileSymbol);
        const target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));
        if (target === unknownSymbol) {
            return !excludeTypeOnlyValues || !getTypeOnlyAliasDeclaration(symbol);
        }
        // const enums and modules that contain only const enums are not considered values from the emit perspective
        // unless 'preserveConstEnums' option is set to true
        return !!(getSymbolFlags(symbol, excludeTypeOnlyValues, /*excludeLocalMeanings*/ true) & SymbolFlags.Value) &&
            (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target));
    }

    function isConstEnumOrConstEnumOnlyModule(s: Symbol): boolean {
        return isConstEnumSymbol(s) || !!s.constEnumOnlyModule;
    }

    function isReferencedAliasDeclaration(node: Node, checkChildren?: boolean): boolean {
        Debug.assert(canCollectSymbolAliasAccessabilityData);
        if (isAliasSymbolDeclaration(node)) {
            const symbol = getSymbolOfDeclaration(node as Declaration);
            const links = symbol && getSymbolLinks(symbol);
            if (links?.referenced) {
                return true;
            }
            const target = getSymbolLinks(symbol).aliasTarget;
            if (
                target && getEffectiveModifierFlags(node) & ModifierFlags.Export &&
                getSymbolFlags(target) & SymbolFlags.Value &&
                (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target))
            ) {
                // An `export import ... =` of a value symbol is always considered referenced
                return true;
            }
        }

        if (checkChildren) {
            return !!forEachChild(node, node => isReferencedAliasDeclaration(node, checkChildren));
        }
        return false;
    }

    function isImplementationOfOverload(node: SignatureDeclaration) {
        if (nodeIsPresent((node as FunctionLikeDeclaration).body)) {
            if (isGetAccessor(node) || isSetAccessor(node)) return false; // Get or set accessors can never be overload implementations, but can have up to 2 signatures
            const symbol = getSymbolOfDeclaration(node);
            const signaturesOfSymbol = getSignaturesOfSymbol(symbol);
            // If this function body corresponds to function with multiple signature, it is implementation of overload
            // e.g.: function foo(a: string): string;
            //       function foo(a: number): number;
            //       function foo(a: any) { // This is implementation of the overloads
            //           return a;
            //       }
            return signaturesOfSymbol.length > 1 ||
                // If there is single signature for the symbol, it is overload if that signature isn't coming from the node
                // e.g.: function foo(a: string): string;
                //       function foo(a: any) { // This is implementation of the overloads
                //           return a;
                //       }
                (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
        }
        return false;
    }

    function declaredParameterTypeContainsUndefined(parameter: ParameterDeclaration | JSDocParameterTag) {
        const typeNode = getNonlocalEffectiveTypeAnnotationNode(parameter);
        if (!typeNode) return false;
        const type = getTypeFromTypeNode(typeNode);
        // allow error type here to avoid confusing errors that the annotation has to contain undefined when it does in cases like this:
        //
        // export function fn(x?: Unresolved | undefined): void {}
        return isErrorType(type) || containsUndefinedType(type);
    }

    function requiresAddingImplicitUndefined(parameter: ParameterDeclaration | JSDocParameterTag, enclosingDeclaration: Node | undefined) {
        return (isRequiredInitializedParameter(parameter, enclosingDeclaration) || isOptionalUninitializedParameterProperty(parameter)) && !declaredParameterTypeContainsUndefined(parameter);
    }

    function isRequiredInitializedParameter(parameter: ParameterDeclaration | JSDocParameterTag, enclosingDeclaration: Node | undefined): boolean {
        if (!strictNullChecks || isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || !parameter.initializer) {
            return false;
        }
        if (hasSyntacticModifier(parameter, ModifierFlags.ParameterPropertyModifier)) {
            return !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration);
        }
        return true;
    }

    function isOptionalUninitializedParameterProperty(parameter: ParameterDeclaration | JSDocParameterTag) {
        return strictNullChecks &&
            isOptionalParameter(parameter) &&
            (isJSDocParameterTag(parameter) || !parameter.initializer) &&
            hasSyntacticModifier(parameter, ModifierFlags.ParameterPropertyModifier);
    }

    function isExpandoFunctionDeclaration(node: Declaration): boolean {
        const declaration = getParseTreeNode(node, (n): n is FunctionDeclaration | VariableDeclaration => isFunctionDeclaration(n) || isVariableDeclaration(n));
        if (!declaration) {
            return false;
        }
        let symbol: Symbol | undefined;
        if (isVariableDeclaration(declaration)) {
            if (declaration.type || (!isInJSFile(declaration) && !isVarConstLike(declaration))) {
                return false;
            }
            const initializer = getDeclaredExpandoInitializer(declaration);
            if (!initializer || !canHaveSymbol(initializer)) {
                return false;
            }
            symbol = getSymbolOfDeclaration(initializer);
        }
        else {
            symbol = getSymbolOfDeclaration(declaration);
        }
        if (!symbol || !(symbol.flags & SymbolFlags.Function | SymbolFlags.Variable)) {
            return false;
        }
        return !!forEachEntry(getExportsOfSymbol(symbol), p => p.flags & SymbolFlags.Value && isExpandoPropertyDeclaration(p.valueDeclaration));
    }

    function getPropertiesOfContainerFunction(node: Declaration): Symbol[] {
        const declaration = getParseTreeNode(node, isFunctionDeclaration);
        if (!declaration) {
            return emptyArray;
        }
        const symbol = getSymbolOfDeclaration(declaration);
        return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray;
    }

    function getNodeCheckFlags(node: Node): NodeCheckFlags {
        const nodeId = node.id || 0;
        if (nodeId < 0 || nodeId >= nodeLinks.length) return 0;
        return nodeLinks[nodeId]?.flags || 0;
    }

    function hasNodeCheckFlag(node: Node, flag: LazyNodeCheckFlags) {
        calculateNodeCheckFlagWorker(node, flag);
        return !!(getNodeCheckFlags(node) & flag);
    }

    function calculateNodeCheckFlagWorker(node: Node, flag: LazyNodeCheckFlags) {
        if (!compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions)) {
            // Unless noCheck is passed, assume calculation of node check flags has been done eagerly.
            // This saves needing to mark up where in the eager traversal certain results are "done",
            // just to reconcile the eager and lazy results. This wouldn't be hard if an eager typecheck
            // was actually an in-order traversal, but it isn't - some nodes are deferred, and so don't
            // have these node check flags calculated until that deferral is completed. As an example,
            // in concept, we could consider a class that we've called `checkSourceElement` on as having had
            // these flags calculated, but since the method bodies are deferred, we actually can't set the
            // flags as having been calculated until that deferral is completed.
            // The downside to this either/or approach to eager or lazy calculation is that we can't combine
            // a partial eager traversal and lazy calculation for the missing bits, and there's a bit of
            // overlap in functionality. This isn't a huge loss for any usecases today, but would be nice
            // alongside language service partial file checking and editor-triggered emit.
            return;
        }
        const links = getNodeLinks(node);
        if (links.calculatedFlags & flag) {
            return;
        }
        // This is only the set of `NodeCheckFlags` our emitter actually looks for, not all of them
        switch (flag) {
            case NodeCheckFlags.SuperInstance:
            case NodeCheckFlags.SuperStatic:
                return checkSingleSuperExpression(node);
            case NodeCheckFlags.MethodWithSuperPropertyAccessInAsync:
            case NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync:
            case NodeCheckFlags.ContainsSuperPropertyInStaticInitializer:
                return checkChildSuperExpressions(node);
            case NodeCheckFlags.CaptureArguments:
            case NodeCheckFlags.ContainsCapturedBlockScopeBinding:
            case NodeCheckFlags.NeedsLoopOutParameter:
            case NodeCheckFlags.ContainsConstructorReference:
                return checkChildIdentifiers(node);
            case NodeCheckFlags.ConstructorReference:
                return checkSingleIdentifier(node);
            case NodeCheckFlags.LoopWithCapturedBlockScopedBinding:
            case NodeCheckFlags.BlockScopedBindingInLoop:
            case NodeCheckFlags.CapturedBlockScopedBinding:
                return checkContainingBlockScopeBindingUses(node);
            default:
                return Debug.assertNever(flag, `Unhandled node check flag calculation: ${Debug.formatNodeCheckFlags(flag)}`);
        }

        function forEachNodeRecursively<T>(root: Node, cb: (node: Node, parent: Node) => T | "skip" | undefined): T | undefined {
            const rootResult = cb(root, root.parent);
            if (rootResult === "skip") return undefined;
            if (rootResult) return rootResult;
            return forEachChildRecursively(root, cb);
        }

        function checkSuperExpressions(node: Node) {
            const links = getNodeLinks(node);
            if (links.calculatedFlags & flag) return "skip";
            links.calculatedFlags |= NodeCheckFlags.MethodWithSuperPropertyAccessInAsync | NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync | NodeCheckFlags.ContainsSuperPropertyInStaticInitializer;
            checkSingleSuperExpression(node);
            return undefined;
        }

        function checkChildSuperExpressions(node: Node) {
            forEachNodeRecursively(node, checkSuperExpressions);
        }

        function checkSingleSuperExpression(node: Node) {
            const nodeLinks = getNodeLinks(node); // This is called on sub-nodes of the original input, make sure we set `calculatedFlags` on the correct node
            nodeLinks.calculatedFlags |= NodeCheckFlags.SuperInstance | NodeCheckFlags.SuperStatic; // Yes, we set this on non-applicable nodes, so we can entirely skip the traversal on future calls
            if (node.kind === SyntaxKind.SuperKeyword) {
                checkSuperExpression(node);
            }
        }

        function checkIdentifiers(node: Node) {
            const links = getNodeLinks(node);
            if (links.calculatedFlags & flag) return "skip";
            links.calculatedFlags |= NodeCheckFlags.CaptureArguments | NodeCheckFlags.ContainsCapturedBlockScopeBinding | NodeCheckFlags.NeedsLoopOutParameter | NodeCheckFlags.ContainsConstructorReference;
            checkSingleIdentifier(node);
            return undefined;
        }

        function checkChildIdentifiers(node: Node) {
            forEachNodeRecursively(node, checkIdentifiers);
        }

        function isExpressionNodeOrShorthandPropertyAssignmentName(node: Identifier) {
            // TODO(jakebailey): Just use isExpressionNode once that considers these identifiers to be expressions.
            return isExpressionNode(node)
                || isShorthandPropertyAssignment(node.parent) && (node.parent.objectAssignmentInitializer ?? node.parent.name) === node;
        }

        function checkSingleIdentifier(node: Node) {
            const nodeLinks = getNodeLinks(node);
            nodeLinks.calculatedFlags |= NodeCheckFlags.ConstructorReference;
            if (isIdentifier(node)) {
                nodeLinks.calculatedFlags |= NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.CapturedBlockScopedBinding; // Can't set on all arbitrary nodes (these nodes have this flag set by `checkSingleBlockScopeBinding` only)
                if (isExpressionNodeOrShorthandPropertyAssignmentName(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name === node)) {
                    const s = getResolvedSymbol(node);
                    if (s && s !== unknownSymbol) {
                        checkIdentifierCalculateNodeCheckFlags(node, s);
                    }
                }
            }
        }

        function checkBlockScopeBindings(node: Node) {
            const links = getNodeLinks(node);
            if (links.calculatedFlags & flag) return "skip";
            links.calculatedFlags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding | NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.CapturedBlockScopedBinding;
            checkSingleBlockScopeBinding(node);
            return undefined;
        }

        function checkContainingBlockScopeBindingUses(node: Node) {
            const scope = getEnclosingBlockScopeContainer(isDeclarationName(node) ? node.parent : node);
            forEachNodeRecursively(scope, checkBlockScopeBindings);
        }

        function checkSingleBlockScopeBinding(node: Node) {
            checkSingleIdentifier(node);
            if (isComputedPropertyName(node)) {
                checkComputedPropertyName(node);
            }
            if (isPrivateIdentifier(node) && isClassElement(node.parent)) {
                setNodeLinksForPrivateIdentifierScope(node.parent as PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration);
            }
        }
    }

    function getEnumMemberValue(node: EnumMember): EvaluatorResult {
        computeEnumMemberValues(node.parent);
        return getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value*/ undefined);
    }

    function canHaveConstantValue(node: Node): node is EnumMember | AccessExpression {
        switch (node.kind) {
            case SyntaxKind.EnumMember:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                return true;
        }
        return false;
    }

    function getConstantValue(node: EnumMember | AccessExpression): string | number | undefined {
        if (node.kind === SyntaxKind.EnumMember) {
            return getEnumMemberValue(node).value;
        }

        if (!getNodeLinks(node).resolvedSymbol) {
            void checkExpressionCached(node); // ensure cached resolved symbol is set
        }
        const symbol = getNodeLinks(node).resolvedSymbol || (isEntityNameExpression(node) ? resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors*/ true) : undefined);
        if (symbol && (symbol.flags & SymbolFlags.EnumMember)) {
            // inline property\index accesses only for const enums
            const member = symbol.valueDeclaration as EnumMember;
            if (isEnumConst(member.parent)) {
                return getEnumMemberValue(member).value;
            }
        }

        return undefined;
    }

    function isFunctionType(type: Type): boolean {
        return !!(type.flags & TypeFlags.Object) && getSignaturesOfType(type, SignatureKind.Call).length > 0;
    }

    function getTypeReferenceSerializationKind(typeNameIn: EntityName, location?: Node): TypeReferenceSerializationKind {
        // ensure both `typeName` and `location` are parse tree nodes.
        const typeName = getParseTreeNode(typeNameIn, isEntityName);
        if (!typeName) return TypeReferenceSerializationKind.Unknown;

        if (location) {
            location = getParseTreeNode(location);
            if (!location) return TypeReferenceSerializationKind.Unknown;
        }

        // Resolve the symbol as a value to ensure the type can be reached at runtime during emit.
        let isTypeOnly = false;
        if (isQualifiedName(typeName)) {
            const rootValueSymbol = resolveEntityName(getFirstIdentifier(typeName), SymbolFlags.Value, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, location);
            isTypeOnly = !!rootValueSymbol?.declarations?.every(isTypeOnlyImportOrExportDeclaration);
        }
        const valueSymbol = resolveEntityName(typeName, SymbolFlags.Value, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, location);
        const resolvedValueSymbol = valueSymbol && valueSymbol.flags & SymbolFlags.Alias ? resolveAlias(valueSymbol) : valueSymbol;
        isTypeOnly ||= !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlags.Value));

        // Resolve the symbol as a type so that we can provide a more useful hint for the type serializer.
        const typeSymbol = resolveEntityName(typeName, SymbolFlags.Type, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, location);
        const resolvedTypeSymbol = typeSymbol && typeSymbol.flags & SymbolFlags.Alias ? resolveAlias(typeSymbol) : typeSymbol;

        // In case the value symbol can't be resolved (e.g. because of missing declarations), use type symbol for reachability check.
        if (!valueSymbol) {
            isTypeOnly ||= !!(typeSymbol && getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlags.Type));
        }

        if (resolvedValueSymbol && resolvedValueSymbol === resolvedTypeSymbol) {
            const globalPromiseSymbol = getGlobalPromiseConstructorSymbol(/*reportErrors*/ false);
            if (globalPromiseSymbol && resolvedValueSymbol === globalPromiseSymbol) {
                return TypeReferenceSerializationKind.Promise;
            }

            const constructorType = getTypeOfSymbol(resolvedValueSymbol);
            if (constructorType && isConstructorType(constructorType)) {
                return isTypeOnly ? TypeReferenceSerializationKind.TypeWithCallSignature : TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue;
            }
        }

        // We might not be able to resolve type symbol so use unknown type in that case (eg error case)
        if (!resolvedTypeSymbol) {
            return isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown;
        }
        const type = getDeclaredTypeOfSymbol(resolvedTypeSymbol);
        if (isErrorType(type)) {
            return isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown;
        }
        else if (type.flags & TypeFlags.AnyOrUnknown) {
            return TypeReferenceSerializationKind.ObjectType;
        }
        else if (isTypeAssignableToKind(type, TypeFlags.Void | TypeFlags.Nullable | TypeFlags.Never)) {
            return TypeReferenceSerializationKind.VoidNullableOrNeverType;
        }
        else if (isTypeAssignableToKind(type, TypeFlags.BooleanLike)) {
            return TypeReferenceSerializationKind.BooleanType;
        }
        else if (isTypeAssignableToKind(type, TypeFlags.NumberLike)) {
            return TypeReferenceSerializationKind.NumberLikeType;
        }
        else if (isTypeAssignableToKind(type, TypeFlags.BigIntLike)) {
            return TypeReferenceSerializationKind.BigIntLikeType;
        }
        else if (isTypeAssignableToKind(type, TypeFlags.StringLike)) {
            return TypeReferenceSerializationKind.StringLikeType;
        }
        else if (isTupleType(type)) {
            return TypeReferenceSerializationKind.ArrayLikeType;
        }
        else if (isTypeAssignableToKind(type, TypeFlags.ESSymbolLike)) {
            return TypeReferenceSerializationKind.ESSymbolType;
        }
        else if (isFunctionType(type)) {
            return TypeReferenceSerializationKind.TypeWithCallSignature;
        }
        else if (isArrayType(type)) {
            return TypeReferenceSerializationKind.ArrayLikeType;
        }
        else {
            return TypeReferenceSerializationKind.ObjectType;
        }
    }

    function createTypeOfDeclaration(declarationIn: HasInferredType, enclosingDeclaration: Node, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker) {
        const declaration = getParseTreeNode(declarationIn, hasInferredType);
        if (!declaration) {
            return factory.createToken(SyntaxKind.AnyKeyword) as KeywordTypeNode;
        }
        // Get type of the symbol if this is the valid symbol otherwise get type at location
        const symbol = getSymbolOfDeclaration(declaration);
        return nodeBuilder.serializeTypeForDeclaration(declaration, symbol, enclosingDeclaration, flags | NodeBuilderFlags.MultilineObjectLiterals, internalFlags, tracker);
    }

    function getAllAccessorDeclarationsForDeclaration(accessor: AccessorDeclaration): AllAccessorDeclarations {
        accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)!; // TODO: GH#18217
        const otherKind = accessor.kind === SyntaxKind.SetAccessor ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor;
        const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(accessor), otherKind);
        const firstAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor;
        const secondAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor;
        const setAccessor = accessor.kind === SyntaxKind.SetAccessor ? accessor : otherAccessor as SetAccessorDeclaration;
        const getAccessor = accessor.kind === SyntaxKind.GetAccessor ? accessor : otherAccessor as GetAccessorDeclaration;
        return {
            firstAccessor,
            secondAccessor,
            setAccessor,
            getAccessor,
        };
    }
    function createReturnTypeOfSignatureDeclaration(signatureDeclarationIn: SignatureDeclaration, enclosingDeclaration: Node, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker) {
        const signatureDeclaration = getParseTreeNode(signatureDeclarationIn, isFunctionLike);
        if (!signatureDeclaration) {
            return factory.createToken(SyntaxKind.AnyKeyword) as KeywordTypeNode;
        }
        return nodeBuilder.serializeReturnTypeForSignature(signatureDeclaration, enclosingDeclaration, flags | NodeBuilderFlags.MultilineObjectLiterals, internalFlags, tracker);
    }

    function createTypeOfExpression(exprIn: Expression, enclosingDeclaration: Node, flags: NodeBuilderFlags, internalFlags: InternalNodeBuilderFlags, tracker: SymbolTracker) {
        const expr = getParseTreeNode(exprIn, isExpression);
        if (!expr) {
            return factory.createToken(SyntaxKind.AnyKeyword) as KeywordTypeNode;
        }
        return nodeBuilder.serializeTypeForExpression(expr, enclosingDeclaration, flags | NodeBuilderFlags.MultilineObjectLiterals, internalFlags, tracker);
    }

    function hasGlobalName(name: string): boolean {
        return globals.has(escapeLeadingUnderscores(name));
    }

    function getReferencedValueSymbol(reference: Identifier, startInDeclarationContainer?: boolean): Symbol | undefined {
        const resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
        if (resolvedSymbol) {
            return resolvedSymbol;
        }

        let location: Node = reference;
        if (startInDeclarationContainer) {
            // When resolving the name of a declaration as a value, we need to start resolution
            // at a point outside of the declaration.
            const parent = reference.parent;
            if (isDeclaration(parent) && reference === parent.name) {
                location = getDeclarationContainer(parent);
            }
        }

        return resolveName(location, reference.escapedText, SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
    }

    /**
     * Get either a value-meaning symbol or an alias symbol.
     * Unlike `getReferencedValueSymbol`, if the cached resolved symbol is the unknown symbol,
     * we call `resolveName` to find a symbol.
     * This is because when caching the resolved symbol, we only consider value symbols, but here
     * we want to also get an alias symbol if one exists.
     */
    function getReferencedValueOrAliasSymbol(reference: Identifier): Symbol | undefined {
        const resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
        if (resolvedSymbol && resolvedSymbol !== unknownSymbol) {
            return resolvedSymbol;
        }

        return resolveName(
            reference,
            reference.escapedText,
            SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias,
            /*nameNotFoundMessage*/ undefined,
            /*isUse*/ true,
            /*excludeGlobals*/ undefined,
        );
    }

    function getReferencedValueDeclaration(referenceIn: Identifier): Declaration | undefined {
        if (!isGeneratedIdentifier(referenceIn)) {
            const reference = getParseTreeNode(referenceIn, isIdentifier);
            if (reference) {
                const symbol = getReferencedValueSymbol(reference);
                if (symbol) {
                    return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
                }
            }
        }

        return undefined;
    }

    function getReferencedValueDeclarations(referenceIn: Identifier): Declaration[] | undefined {
        if (!isGeneratedIdentifier(referenceIn)) {
            const reference = getParseTreeNode(referenceIn, isIdentifier);
            if (reference) {
                const symbol = getReferencedValueSymbol(reference);
                if (symbol) {
                    return filter(getExportSymbolOfValueSymbolIfExported(symbol).declarations, declaration => {
                        switch (declaration.kind) {
                            case SyntaxKind.VariableDeclaration:
                            case SyntaxKind.Parameter:
                            case SyntaxKind.BindingElement:
                            case SyntaxKind.PropertyDeclaration:
                            case SyntaxKind.PropertyAssignment:
                            case SyntaxKind.ShorthandPropertyAssignment:
                            case SyntaxKind.EnumMember:
                            case SyntaxKind.ObjectLiteralExpression:
                            case SyntaxKind.FunctionDeclaration:
                            case SyntaxKind.FunctionExpression:
                            case SyntaxKind.ArrowFunction:
                            case SyntaxKind.ClassDeclaration:
                            case SyntaxKind.ClassExpression:
                            case SyntaxKind.EnumDeclaration:
                            case SyntaxKind.MethodDeclaration:
                            case SyntaxKind.GetAccessor:
                            case SyntaxKind.SetAccessor:
                            case SyntaxKind.ModuleDeclaration:
                                return true;
                        }
                        return false;
                    });
                }
            }
        }

        return undefined;
    }

    function isLiteralConstDeclaration(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration): boolean {
        if (isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConstLike(node)) {
            return isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)));
        }
        return false;
    }

    function literalTypeToNode(type: FreshableType, enclosing: Node, tracker: SymbolTracker): Expression {
        const enumResult = type.flags & TypeFlags.EnumLike ? nodeBuilder.symbolToExpression(type.symbol, SymbolFlags.Value, enclosing, /*flags*/ undefined, /*internalFlags*/ undefined, tracker)
            : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse();
        if (enumResult) return enumResult;
        const literalValue = (type as LiteralType).value;
        return typeof literalValue === "object" ? factory.createBigIntLiteral(literalValue) :
            typeof literalValue === "string" ? factory.createStringLiteral(literalValue) :
            literalValue < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-literalValue)) :
            factory.createNumericLiteral(literalValue);
    }

    function createLiteralConstValue(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration, tracker: SymbolTracker) {
        const type = getTypeOfSymbol(getSymbolOfDeclaration(node));
        return literalTypeToNode(type as FreshableType, node, tracker);
    }

    function getJsxFactoryEntity(location: Node): EntityName | undefined {
        return location ? (getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity;
    }

    function getJsxFragmentFactoryEntity(location: Node): EntityName | undefined {
        if (location) {
            const file = getSourceFileOfNode(location);
            if (file) {
                if (file.localJsxFragmentFactory) {
                    return file.localJsxFragmentFactory;
                }
                const jsxFragPragmas = file.pragmas.get("jsxfrag");
                const jsxFragPragma = isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas;
                if (jsxFragPragma) {
                    file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion);
                    return file.localJsxFragmentFactory;
                }
            }
        }

        if (compilerOptions.jsxFragmentFactory) {
            return parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion);
        }
    }

    function getNonlocalEffectiveTypeAnnotationNode(node: Node) {
        const direct = getEffectiveTypeAnnotationNode(node);
        if (direct) {
            return direct;
        }
        if (node.kind === SyntaxKind.Parameter && node.parent.kind === SyntaxKind.SetAccessor) {
            const other = getAllAccessorDeclarationsForDeclaration(node.parent as SetAccessorDeclaration).getAccessor;
            if (other) {
                return getEffectiveReturnTypeNode(other);
            }
        }
        return undefined;
    }

    function createResolver(): EmitResolver {
        return {
            getReferencedExportContainer,
            getReferencedImportDeclaration,
            getReferencedDeclarationWithCollidingName,
            isDeclarationWithCollidingName,
            isValueAliasDeclaration: nodeIn => {
                const node = getParseTreeNode(nodeIn);
                // Synthesized nodes are always treated like values.
                return node && canCollectSymbolAliasAccessabilityData ? isValueAliasDeclaration(node) : true;
            },
            hasGlobalName,
            isReferencedAliasDeclaration: (nodeIn, checkChildren?) => {
                const node = getParseTreeNode(nodeIn);
                // Synthesized nodes are always treated as referenced.
                return node && canCollectSymbolAliasAccessabilityData ? isReferencedAliasDeclaration(node, checkChildren) : true;
            },
            hasNodeCheckFlag: (nodeIn, flag) => {
                const node = getParseTreeNode(nodeIn);
                if (!node) return false;
                return hasNodeCheckFlag(node, flag);
            },
            isTopLevelValueImportEqualsWithEntityName,
            isDeclarationVisible,
            isImplementationOfOverload,
            requiresAddingImplicitUndefined,
            isExpandoFunctionDeclaration,
            getPropertiesOfContainerFunction,
            createTypeOfDeclaration,
            createReturnTypeOfSignatureDeclaration,
            createTypeOfExpression,
            createLiteralConstValue,
            isSymbolAccessible,
            isEntityNameVisible,
            getConstantValue: nodeIn => {
                const node = getParseTreeNode(nodeIn, canHaveConstantValue);
                return node ? getConstantValue(node) : undefined;
            },
            getEnumMemberValue: nodeIn => {
                const node = getParseTreeNode(nodeIn, isEnumMember);
                return node ? getEnumMemberValue(node) : undefined;
            },
            collectLinkedAliases,
            markLinkedReferences: nodeIn => {
                const node = getParseTreeNode(nodeIn);
                return node && markLinkedReferences(node, ReferenceHint.Unspecified);
            },
            getReferencedValueDeclaration,
            getReferencedValueDeclarations,
            getTypeReferenceSerializationKind,
            isOptionalParameter,
            isArgumentsLocalBinding,
            getExternalModuleFileFromDeclaration: nodeIn => {
                const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference);
                return node && getExternalModuleFileFromDeclaration(node);
            },
            isLiteralConstDeclaration,
            isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => {
                const node = getParseTreeNode(nodeIn, isDeclaration);
                const symbol = node && getSymbolOfDeclaration(node);
                return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late);
            },
            getJsxFactoryEntity,
            getJsxFragmentFactoryEntity,
            isBindingCapturedByNode: (node, decl) => {
                const parseNode = getParseTreeNode(node);
                const parseDecl = getParseTreeNode(decl);
                return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);
            },
            getDeclarationStatementsForSourceFile: (node, flags, internalFlags, tracker) => {
                const n = getParseTreeNode(node) as SourceFile;
                Debug.assert(n && n.kind === SyntaxKind.SourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile");
                const sym = getSymbolOfDeclaration(node);
                if (!sym) {
                    return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker);
                }
                resolveExternalModuleSymbol(sym); // ensures cjs export assignment is setup
                return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker);
            },
            isImportRequiredByAugmentation,
            isDefinitelyReferenceToGlobalSymbolObject,
            createLateBoundIndexSignatures: (cls, enclosing, flags, internalFlags, tracker) => {
                const sym = cls.symbol;
                const staticInfos = getIndexInfosOfType(getTypeOfSymbol(sym));
                const instanceIndexSymbol = getIndexSymbol(sym);
                const instanceInfos = instanceIndexSymbol && getIndexInfosOfIndexSymbol(instanceIndexSymbol, arrayFrom(getMembersOfSymbol(sym).values()));
                let result;
                for (const infoList of [staticInfos, instanceInfos]) {
                    if (!length(infoList)) continue;
                    result ||= [];
                    for (const info of infoList!) {
                        if (info.declaration) continue;
                        if (info === anyBaseTypeIndexInfo) continue; // inherited, but looks like a late-bound signature because it has no declarations
                        if (info.components) {
                            const allComponentComputedNamesSerializable = every(info.components, e => {
                                return !!(e.name && isComputedPropertyName(e.name) && isEntityNameExpression(e.name.expression) && enclosing && isEntityNameVisible(e.name.expression, enclosing, /*shouldComputeAliasToMakeVisible*/ false)?.accessibility === SymbolAccessibility.Accessible);
                            });
                            if (allComponentComputedNamesSerializable) {
                                const newComponents = filter(info.components, e => {
                                    // skip late bound props that contribute to the index signature - they'll be preserved via other means
                                    return !hasLateBindableName(e);
                                });
                                result.push(...map(newComponents, e => {
                                    trackComputedName(e.name.expression as EntityNameExpression);
                                    const mods = infoList === staticInfos ? [factory.createModifier(SyntaxKind.StaticKeyword)] as Modifier[] : undefined;
                                    return factory.createPropertyDeclaration(
                                        append(mods, info.isReadonly ? factory.createModifier(SyntaxKind.ReadonlyKeyword) : undefined),
                                        e.name,
                                        (isPropertySignature(e) || isPropertyDeclaration(e) || isMethodSignature(e) || isMethodDeclaration(e) || isGetAccessor(e) || isSetAccessor(e)) && e.questionToken ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                                        nodeBuilder.typeToTypeNode(getTypeOfSymbol(e.symbol), enclosing, flags, internalFlags, tracker),
                                        /*initializer*/ undefined,
                                    );
                                }));
                                continue;
                            }
                        }
                        const node = nodeBuilder.indexInfoToIndexSignatureDeclaration(info, enclosing, flags, internalFlags, tracker);
                        if (node && infoList === staticInfos) {
                            (((node as Mutable<typeof node>).modifiers ||= factory.createNodeArray()) as MutableNodeArray<Modifier>).unshift(factory.createModifier(SyntaxKind.StaticKeyword));
                        }
                        if (node) {
                            result.push(node);
                        }
                    }
                }
                return result;

                function trackComputedName(accessExpression: EntityNameOrEntityNameExpression) {
                    if (!tracker.trackSymbol) return;
                    // get symbol of the first identifier of the entityName
                    const firstIdentifier = getFirstIdentifier(accessExpression);
                    const name = resolveName(firstIdentifier, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.ExportValue, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
                    if (name) {
                        tracker.trackSymbol(name, enclosing, SymbolFlags.Value);
                    }
                }
            },
            symbolToDeclarations: (symbol, meaning, flags, maximumLength, verbosityLevel, out) => {
                return nodeBuilder.symbolToDeclarations(symbol, meaning, flags, maximumLength, verbosityLevel, out);
            },
        };

        function isImportRequiredByAugmentation(node: ImportDeclaration) {
            const file = getSourceFileOfNode(node);
            if (!file.symbol) return false;
            const importTarget = getExternalModuleFileFromDeclaration(node);
            if (!importTarget) return false;
            if (importTarget === file) return false;
            const exports = getExportsOfModule(file.symbol);
            for (const s of arrayFrom(exports.values())) {
                if (s.mergeId) {
                    const merged = getMergedSymbol(s);
                    if (merged.declarations) {
                        for (const d of merged.declarations) {
                            const declFile = getSourceFileOfNode(d);
                            if (declFile === importTarget) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
    }

    function getExternalModuleFileFromDeclaration(declaration: AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall): SourceFile | undefined {
        const specifier = declaration.kind === SyntaxKind.ModuleDeclaration ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration);
        const moduleSymbol = resolveExternalModuleNameWorker(specifier!, specifier!, /*moduleNotFoundError*/ undefined); // TODO: GH#18217
        if (!moduleSymbol) {
            return undefined;
        }
        return getDeclarationOfKind(moduleSymbol, SyntaxKind.SourceFile);
    }

    function initializeTypeChecker() {
        // Bind all source files and propagate errors
        for (const file of host.getSourceFiles()) {
            bindSourceFile(file, compilerOptions);
        }

        amalgamatedDuplicates = new Map();

        // Initialize global symbol table
        let augmentations: (readonly (StringLiteral | Identifier)[])[] | undefined;
        for (const file of host.getSourceFiles()) {
            if (file.redirectInfo) {
                continue;
            }
            if (!isExternalOrCommonJsModule(file)) {
                // It is an error for a non-external-module (i.e. script) to declare its own `globalThis`.
                const fileGlobalThisSymbol = file.locals!.get("globalThis" as __String);
                if (fileGlobalThisSymbol?.declarations) {
                    for (const declaration of fileGlobalThisSymbol.declarations) {
                        diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"));
                    }
                }
                mergeSymbolTable(globals, file.locals!);
            }
            if (file.jsGlobalAugmentations) {
                mergeSymbolTable(globals, file.jsGlobalAugmentations);
            }
            if (file.patternAmbientModules && file.patternAmbientModules.length) {
                patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules);
            }
            if (file.moduleAugmentations.length) {
                (augmentations || (augmentations = [])).push(file.moduleAugmentations);
            }
            if (file.symbol && file.symbol.globalExports) {
                // Merge in UMD exports with first-in-wins semantics (see #9771)
                const source = file.symbol.globalExports;
                source.forEach((sourceSymbol, id) => {
                    if (!globals.has(id)) {
                        globals.set(id, sourceSymbol);
                    }
                });
            }
        }

        // We do global augmentations separately from module augmentations (and before creating global types) because they
        //  1. Affect global types. We won't have the correct global types until global augmentations are merged. Also,
        //  2. Module augmentation instantiation requires creating the type of a module, which, in turn, can require
        //       checking for an export or property on the module (if export=) which, in turn, can fall back to the
        //       apparent type of the module - either globalObjectType or globalFunctionType - which wouldn't exist if we
        //       did module augmentations prior to finalizing the global types.
        if (augmentations) {
            // merge _global_ module augmentations.
            // this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
            for (const list of augmentations) {
                for (const augmentation of list) {
                    if (!isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;
                    mergeModuleAugmentation(augmentation);
                }
            }
        }

        addUndefinedToGlobalsOrErrorOnRedeclaration();

        getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
        getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments" as __String, /*arity*/ 0, /*reportErrors*/ true);
        getSymbolLinks(unknownSymbol).type = errorType;
        getSymbolLinks(globalThisSymbol).type = createObjectType(ObjectFlags.Anonymous, globalThisSymbol);

        // Initialize special types
        globalArrayType = getGlobalType("Array" as __String, /*arity*/ 1, /*reportErrors*/ true);
        globalObjectType = getGlobalType("Object" as __String, /*arity*/ 0, /*reportErrors*/ true);
        globalFunctionType = getGlobalType("Function" as __String, /*arity*/ 0, /*reportErrors*/ true);
        globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction" as __String, /*arity*/ 0, /*reportErrors*/ true) || globalFunctionType;
        globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction" as __String, /*arity*/ 0, /*reportErrors*/ true) || globalFunctionType;
        globalStringType = getGlobalType("String" as __String, /*arity*/ 0, /*reportErrors*/ true);
        globalNumberType = getGlobalType("Number" as __String, /*arity*/ 0, /*reportErrors*/ true);
        globalBooleanType = getGlobalType("Boolean" as __String, /*arity*/ 0, /*reportErrors*/ true);
        globalRegExpType = getGlobalType("RegExp" as __String, /*arity*/ 0, /*reportErrors*/ true);
        anyArrayType = createArrayType(anyType);

        autoArrayType = createArrayType(autoType);
        if (autoArrayType === emptyObjectType) {
            // autoArrayType is used as a marker, so even if global Array type is not defined, it needs to be a unique type
            autoArrayType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
        }

        globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray" as __String, /*arity*/ 1) as GenericType || globalArrayType;
        anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
        globalThisType = getGlobalTypeOrUndefined("ThisType" as __String, /*arity*/ 1) as GenericType;

        if (augmentations) {
            // merge _nonglobal_ module augmentations.
            // this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
            for (const list of augmentations) {
                for (const augmentation of list) {
                    if (isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;
                    mergeModuleAugmentation(augmentation);
                }
            }
        }

        amalgamatedDuplicates.forEach(({ firstFile, secondFile, conflictingSymbols }) => {
            // If not many things conflict, issue individual errors
            if (conflictingSymbols.size < 8) {
                conflictingSymbols.forEach(({ isBlockScoped, firstFileLocations, secondFileLocations }, symbolName) => {
                    const message = isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;
                    for (const node of firstFileLocations) {
                        addDuplicateDeclarationError(node, message, symbolName, secondFileLocations);
                    }
                    for (const node of secondFileLocations) {
                        addDuplicateDeclarationError(node, message, symbolName, firstFileLocations);
                    }
                });
            }
            else {
                // Otherwise issue top-level error since the files appear very identical in terms of what they contain
                const list = arrayFrom(conflictingSymbols.keys()).join(", ");
                diagnostics.add(addRelatedInfo(
                    createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),
                    createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file),
                ));
                diagnostics.add(addRelatedInfo(
                    createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),
                    createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file),
                ));
            }
        });
        amalgamatedDuplicates = undefined;
    }

    function checkExternalEmitHelpers(location: Node, helpers: ExternalEmitHelpers) {
        if (compilerOptions.importHelpers) {
            const sourceFile = getSourceFileOfNode(location);
            if (isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlags.Ambient)) {
                const helpersModule = resolveHelpersModule(sourceFile, location);
                if (helpersModule !== unknownSymbol) {
                    const links = getSymbolLinks(helpersModule);
                    links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers;
                    if ((links.requestedExternalEmitHelpers & helpers) !== helpers) {
                        const uncheckedHelpers = helpers & ~links.requestedExternalEmitHelpers;
                        for (let helper = ExternalEmitHelpers.FirstEmitHelper; helper <= ExternalEmitHelpers.LastEmitHelper; helper <<= 1) {
                            if (uncheckedHelpers & helper) {
                                for (const name of getHelperNames(helper)) {
                                    const symbol = resolveSymbol(getSymbol(getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlags.Value));
                                    if (!symbol) {
                                        error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name);
                                    }
                                    else if (helper & ExternalEmitHelpers.ClassPrivateFieldGet) {
                                        if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 3)) {
                                            error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4);
                                        }
                                    }
                                    else if (helper & ExternalEmitHelpers.ClassPrivateFieldSet) {
                                        if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 4)) {
                                            error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5);
                                        }
                                    }
                                    else if (helper & ExternalEmitHelpers.SpreadArray) {
                                        if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 2)) {
                                            error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    links.requestedExternalEmitHelpers |= helpers;
                }
            }
        }
    }

    function getHelperNames(helper: ExternalEmitHelpers) {
        switch (helper) {
            case ExternalEmitHelpers.Extends:
                return ["__extends"];
            case ExternalEmitHelpers.Assign:
                return ["__assign"];
            case ExternalEmitHelpers.Rest:
                return ["__rest"];
            case ExternalEmitHelpers.Decorate:
                return legacyDecorators ? ["__decorate"] : ["__esDecorate", "__runInitializers"];
            case ExternalEmitHelpers.Metadata:
                return ["__metadata"];
            case ExternalEmitHelpers.Param:
                return ["__param"];
            case ExternalEmitHelpers.Awaiter:
                return ["__awaiter"];
            case ExternalEmitHelpers.Generator:
                return ["__generator"];
            case ExternalEmitHelpers.Values:
                return ["__values"];
            case ExternalEmitHelpers.Read:
                return ["__read"];
            case ExternalEmitHelpers.SpreadArray:
                return ["__spreadArray"];
            case ExternalEmitHelpers.Await:
                return ["__await"];
            case ExternalEmitHelpers.AsyncGenerator:
                return ["__asyncGenerator"];
            case ExternalEmitHelpers.AsyncDelegator:
                return ["__asyncDelegator"];
            case ExternalEmitHelpers.AsyncValues:
                return ["__asyncValues"];
            case ExternalEmitHelpers.ExportStar:
                return ["__exportStar"];
            case ExternalEmitHelpers.ImportStar:
                return ["__importStar"];
            case ExternalEmitHelpers.ImportDefault:
                return ["__importDefault"];
            case ExternalEmitHelpers.MakeTemplateObject:
                return ["__makeTemplateObject"];
            case ExternalEmitHelpers.ClassPrivateFieldGet:
                return ["__classPrivateFieldGet"];
            case ExternalEmitHelpers.ClassPrivateFieldSet:
                return ["__classPrivateFieldSet"];
            case ExternalEmitHelpers.ClassPrivateFieldIn:
                return ["__classPrivateFieldIn"];
            case ExternalEmitHelpers.SetFunctionName:
                return ["__setFunctionName"];
            case ExternalEmitHelpers.PropKey:
                return ["__propKey"];
            case ExternalEmitHelpers.AddDisposableResourceAndDisposeResources:
                return ["__addDisposableResource", "__disposeResources"];
            case ExternalEmitHelpers.RewriteRelativeImportExtension:
                return ["__rewriteRelativeImportExtension"];
            default:
                return Debug.fail("Unrecognized helper");
        }
    }

    function resolveHelpersModule(file: SourceFile, errorNode: Node) {
        const links = getNodeLinks(file);
        if (!links.externalHelpersModule) {
            links.externalHelpersModule = resolveExternalModule(getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol;
        }
        return links.externalHelpersModule;
    }

    // GRAMMAR CHECKING

    function checkGrammarModifiers(node: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators): boolean {
        const quickResult = reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node);
        if (quickResult !== undefined) {
            return quickResult;
        }

        if (isParameter(node) && parameterIsThisKeyword(node)) {
            return grammarErrorOnFirstToken(node, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters);
        }

        const blockScopeKind = isVariableStatement(node) ? node.declarationList.flags & NodeFlags.BlockScoped : NodeFlags.None;
        let lastStatic: Node | undefined, lastDeclare: Node | undefined, lastAsync: Node | undefined, lastOverride: Node | undefined, firstDecorator: Decorator | undefined;
        let flags = ModifierFlags.None;
        let sawExportBeforeDecorators = false;
        // We parse decorators and modifiers in four contiguous chunks:
        // [...leadingDecorators, ...leadingModifiers, ...trailingDecorators, ...trailingModifiers]. It is an error to
        // have both leading and trailing decorators.
        let hasLeadingDecorators = false;
        for (const modifier of (node as HasModifiers).modifiers!) {
            if (isDecorator(modifier)) {
                if (!nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent)) {
                    if (node.kind === SyntaxKind.MethodDeclaration && !nodeIsPresent(node.body)) {
                        return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);
                    }
                    else {
                        return grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here);
                    }
                }
                else if (legacyDecorators && (node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor)) {
                    const accessors = getAllAccessorDeclarationsForDeclaration(node as AccessorDeclaration);
                    if (hasDecorators(accessors.firstAccessor) && node === accessors.secondAccessor) {
                        return grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
                    }
                }

                // if we've seen any modifiers aside from `export`, `default`, or another decorator, then this is an invalid position
                if (flags & ~(ModifierFlags.ExportDefault | ModifierFlags.Decorator)) {
                    return grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here);
                }

                // if we've already seen leading decorators and leading modifiers, then trailing decorators are an invalid position
                if (hasLeadingDecorators && flags & ModifierFlags.Modifier) {
                    Debug.assertIsDefined(firstDecorator);
                    const sourceFile = getSourceFileOfNode(modifier);
                    if (!hasParseDiagnostics(sourceFile)) {
                        addRelatedInfo(
                            error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export),
                            createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here),
                        );
                        return true;
                    }
                    return false;
                }

                flags |= ModifierFlags.Decorator;

                // if we have not yet seen a modifier, then these are leading decorators
                if (!(flags & ModifierFlags.Modifier)) {
                    hasLeadingDecorators = true;
                }
                else if (flags & ModifierFlags.Export) {
                    sawExportBeforeDecorators = true;
                }

                firstDecorator ??= modifier;
            }
            else {
                if (modifier.kind !== SyntaxKind.ReadonlyKeyword) {
                    if (node.kind === SyntaxKind.PropertySignature || node.kind === SyntaxKind.MethodSignature) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind));
                    }
                    if (node.kind === SyntaxKind.IndexSignature && (modifier.kind !== SyntaxKind.StaticKeyword || !isClassLike(node.parent))) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind));
                    }
                }
                if (modifier.kind !== SyntaxKind.InKeyword && modifier.kind !== SyntaxKind.OutKeyword && modifier.kind !== SyntaxKind.ConstKeyword) {
                    if (node.kind === SyntaxKind.TypeParameter) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind));
                    }
                }
                switch (modifier.kind) {
                    case SyntaxKind.ConstKeyword: {
                        if (node.kind !== SyntaxKind.EnumDeclaration && node.kind !== SyntaxKind.TypeParameter) {
                            return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKind.ConstKeyword));
                        }
                        const parent = (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent;
                        if (
                            node.kind === SyntaxKind.TypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) ||
                                isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent))
                        ) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind));
                        }
                        break;
                    }
                    case SyntaxKind.OverrideKeyword:
                        // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
                        if (flags & ModifierFlags.Override) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override");
                        }
                        else if (flags & ModifierFlags.Ambient) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare");
                        }
                        else if (flags & ModifierFlags.Readonly) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly");
                        }
                        else if (flags & ModifierFlags.Accessor) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor");
                        }
                        else if (flags & ModifierFlags.Async) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async");
                        }
                        flags |= ModifierFlags.Override;
                        lastOverride = modifier;
                        break;

                    case SyntaxKind.PublicKeyword:
                    case SyntaxKind.ProtectedKeyword:
                    case SyntaxKind.PrivateKeyword:
                        const text = visibilityToString(modifierToFlag(modifier.kind));

                        if (flags & ModifierFlags.AccessibilityModifier) {
                            return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & ModifierFlags.Override) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override");
                        }
                        else if (flags & ModifierFlags.Static) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static");
                        }
                        else if (flags & ModifierFlags.Accessor) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor");
                        }
                        else if (flags & ModifierFlags.Readonly) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");
                        }
                        else if (flags & ModifierFlags.Async) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async");
                        }
                        else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);
                        }
                        else if (flags & ModifierFlags.Abstract) {
                            if (modifier.kind === SyntaxKind.PrivateKeyword) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");
                            }
                            else {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");
                            }
                        }
                        else if (isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
                        }
                        flags |= modifierToFlag(modifier.kind);
                        break;

                    case SyntaxKind.StaticKeyword:
                        if (flags & ModifierFlags.Static) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static");
                        }
                        else if (flags & ModifierFlags.Readonly) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");
                        }
                        else if (flags & ModifierFlags.Async) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");
                        }
                        else if (flags & ModifierFlags.Accessor) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor");
                        }
                        else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");
                        }
                        else if (node.kind === SyntaxKind.Parameter) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        else if (flags & ModifierFlags.Abstract) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                        }
                        else if (flags & ModifierFlags.Override) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override");
                        }
                        flags |= ModifierFlags.Static;
                        lastStatic = modifier;
                        break;

                    case SyntaxKind.AccessorKeyword:
                        if (flags & ModifierFlags.Accessor) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor");
                        }
                        else if (flags & ModifierFlags.Readonly) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly");
                        }
                        else if (flags & ModifierFlags.Ambient) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare");
                        }
                        else if (node.kind !== SyntaxKind.PropertyDeclaration) {
                            return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration);
                        }

                        flags |= ModifierFlags.Accessor;
                        break;

                    case SyntaxKind.ReadonlyKeyword:
                        if (flags & ModifierFlags.Readonly) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly");
                        }
                        else if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature && node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.Parameter) {
                            // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
                            return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);
                        }
                        else if (flags & ModifierFlags.Accessor) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor");
                        }
                        flags |= ModifierFlags.Readonly;
                        break;

                    case SyntaxKind.ExportKeyword:
                        if (
                            compilerOptions.verbatimModuleSyntax &&
                            !(node.flags & NodeFlags.Ambient) &&
                            node.kind !== SyntaxKind.TypeAliasDeclaration &&
                            node.kind !== SyntaxKind.InterfaceDeclaration &&
                            // ModuleDeclaration needs to be checked that it is uninstantiated later
                            node.kind !== SyntaxKind.ModuleDeclaration &&
                            node.parent.kind === SyntaxKind.SourceFile &&
                            host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS
                        ) {
                            return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
                        }
                        if (flags & ModifierFlags.Export) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export");
                        }
                        else if (flags & ModifierFlags.Ambient) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        }
                        else if (flags & ModifierFlags.Abstract) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");
                        }
                        else if (flags & ModifierFlags.Async) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");
                        }
                        else if (isClassLike(node.parent)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export");
                        }
                        else if (node.kind === SyntaxKind.Parameter) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        else if (blockScopeKind === NodeFlags.Using) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export");
                        }
                        else if (blockScopeKind === NodeFlags.AwaitUsing) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export");
                        }
                        flags |= ModifierFlags.Export;
                        break;
                    case SyntaxKind.DefaultKeyword:
                        const container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;
                        if (container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(container)) {
                            return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
                        }
                        else if (blockScopeKind === NodeFlags.Using) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default");
                        }
                        else if (blockScopeKind === NodeFlags.AwaitUsing) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default");
                        }
                        else if (!(flags & ModifierFlags.Export)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default");
                        }
                        else if (sawExportBeforeDecorators) {
                            return grammarErrorOnNode(firstDecorator!, Diagnostics.Decorators_are_not_valid_here);
                        }

                        flags |= ModifierFlags.Default;
                        break;
                    case SyntaxKind.DeclareKeyword:
                        if (flags & ModifierFlags.Ambient) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare");
                        }
                        else if (flags & ModifierFlags.Async) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (flags & ModifierFlags.Override) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override");
                        }
                        else if (isClassLike(node.parent) && !isPropertyDeclaration(node)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare");
                        }
                        else if (node.kind === SyntaxKind.Parameter) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if (blockScopeKind === NodeFlags.Using) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare");
                        }
                        else if (blockScopeKind === NodeFlags.AwaitUsing) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare");
                        }
                        else if ((node.parent.flags & NodeFlags.Ambient) && node.parent.kind === SyntaxKind.ModuleBlock) {
                            return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }
                        else if (isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare");
                        }
                        else if (flags & ModifierFlags.Accessor) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor");
                        }
                        flags |= ModifierFlags.Ambient;
                        lastDeclare = modifier;
                        break;

                    case SyntaxKind.AbstractKeyword:
                        if (flags & ModifierFlags.Abstract) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract");
                        }
                        if (
                            node.kind !== SyntaxKind.ClassDeclaration &&
                            node.kind !== SyntaxKind.ConstructorType
                        ) {
                            if (
                                node.kind !== SyntaxKind.MethodDeclaration &&
                                node.kind !== SyntaxKind.PropertyDeclaration &&
                                node.kind !== SyntaxKind.GetAccessor &&
                                node.kind !== SyntaxKind.SetAccessor
                            ) {
                                return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);
                            }
                            if (!(node.parent.kind === SyntaxKind.ClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlags.Abstract))) {
                                const message = node.kind === SyntaxKind.PropertyDeclaration
                                    ? Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class
                                    : Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class;
                                return grammarErrorOnNode(modifier, message);
                            }
                            if (flags & ModifierFlags.Static) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                            }
                            if (flags & ModifierFlags.Private) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");
                            }
                            if (flags & ModifierFlags.Async && lastAsync) {
                                return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                            }
                            if (flags & ModifierFlags.Override) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override");
                            }
                            if (flags & ModifierFlags.Accessor) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor");
                            }
                        }
                        if (isNamedDeclaration(node) && node.name.kind === SyntaxKind.PrivateIdentifier) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract");
                        }

                        flags |= ModifierFlags.Abstract;
                        break;

                    case SyntaxKind.AsyncKeyword:
                        if (flags & ModifierFlags.Async) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async");
                        }
                        else if (flags & ModifierFlags.Ambient || node.parent.flags & NodeFlags.Ambient) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (node.kind === SyntaxKind.Parameter) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");
                        }
                        if (flags & ModifierFlags.Abstract) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                        }
                        flags |= ModifierFlags.Async;
                        lastAsync = modifier;
                        break;

                    case SyntaxKind.InKeyword:
                    case SyntaxKind.OutKeyword: {
                        const inOutFlag = modifier.kind === SyntaxKind.InKeyword ? ModifierFlags.In : ModifierFlags.Out;
                        const inOutText = modifier.kind === SyntaxKind.InKeyword ? "in" : "out";
                        const parent = isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent)?.tags, isJSDocTypedefTag)) || node.parent;
                        if (node.kind !== SyntaxKind.TypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent))) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText);
                        }
                        if (flags & inOutFlag) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText);
                        }
                        if (inOutFlag & ModifierFlags.In && flags & ModifierFlags.Out) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out");
                        }
                        flags |= inOutFlag;
                        break;
                    }
                }
            }
        }

        if (node.kind === SyntaxKind.Constructor) {
            if (flags & ModifierFlags.Static) {
                return grammarErrorOnNode(lastStatic!, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
            }
            if (flags & ModifierFlags.Override) {
                return grammarErrorOnNode(lastOverride!, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override"); // TODO: GH#18217
            }
            if (flags & ModifierFlags.Async) {
                return grammarErrorOnNode(lastAsync!, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async");
            }
            return false;
        }
        else if ((node.kind === SyntaxKind.ImportDeclaration || node.kind === SyntaxKind.ImportEqualsDeclaration) && flags & ModifierFlags.Ambient) {
            return grammarErrorOnNode(lastDeclare!, Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare");
        }
        else if (node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && isBindingPattern(node.name)) {
            return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
        }
        else if (node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && node.dotDotDotToken) {
            return grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
        }
        if (flags & ModifierFlags.Async) {
            return checkGrammarAsyncModifier(node, lastAsync!);
        }
        return false;
    }

    /**
     * true | false: Early return this value from checkGrammarModifiers.
     * undefined: Need to do full checking on the modifiers.
     */
    function reportObviousModifierErrors(node: HasModifiers | HasIllegalModifiers): boolean | undefined {
        if (!node.modifiers) return false;

        const modifier = findFirstIllegalModifier(node);
        return modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here);
    }

    function findFirstModifierExcept(node: HasModifiers, allowedModifier: SyntaxKind): Modifier | undefined {
        const modifier = find(node.modifiers, isModifier);
        return modifier && modifier.kind !== allowedModifier ? modifier : undefined;
    }

    function findFirstIllegalModifier(node: HasModifiers | HasIllegalModifiers): Modifier | undefined {
        switch (node.kind) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Constructor:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.Parameter:
            case SyntaxKind.TypeParameter:
                return undefined;
            case SyntaxKind.ClassStaticBlockDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
            case SyntaxKind.NamespaceExportDeclaration:
            case SyntaxKind.MissingDeclaration:
                return find(node.modifiers, isModifier);
            default:
                if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {
                    return undefined;
                }
                switch (node.kind) {
                    case SyntaxKind.FunctionDeclaration:
                        return findFirstModifierExcept(node, SyntaxKind.AsyncKeyword);
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ConstructorType:
                        return findFirstModifierExcept(node, SyntaxKind.AbstractKeyword);
                    case SyntaxKind.ClassExpression:
                    case SyntaxKind.InterfaceDeclaration:
                    case SyntaxKind.TypeAliasDeclaration:
                        return find(node.modifiers, isModifier);
                    case SyntaxKind.VariableStatement:
                        return node.declarationList.flags & NodeFlags.Using ?
                            findFirstModifierExcept(node, SyntaxKind.AwaitKeyword) :
                            find(node.modifiers, isModifier);
                    case SyntaxKind.EnumDeclaration:
                        return findFirstModifierExcept(node, SyntaxKind.ConstKeyword);
                    default:
                        Debug.assertNever(node);
                }
        }
    }

    function reportObviousDecoratorErrors(node: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators) {
        const decorator = findFirstIllegalDecorator(node);
        return decorator && grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here);
    }

    function findFirstIllegalDecorator(node: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators): Decorator | undefined {
        return canHaveIllegalDecorators(node) ? find(node.modifiers, isDecorator) : undefined;
    }

    function checkGrammarAsyncModifier(node: Node, asyncModifier: Node): boolean {
        switch (node.kind) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
                return false;
        }

        return grammarErrorOnNode(asyncModifier, Diagnostics._0_modifier_cannot_be_used_here, "async");
    }

    function checkGrammarForDisallowedTrailingComma(list: NodeArray<Node> | undefined, diag = Diagnostics.Trailing_comma_not_allowed): boolean {
        if (list && list.hasTrailingComma) {
            return grammarErrorAtPos(list[0], list.end - ",".length, ",".length, diag);
        }
        return false;
    }

    function checkGrammarTypeParameterList(typeParameters: NodeArray<TypeParameterDeclaration> | undefined, file: SourceFile): boolean {
        if (typeParameters && typeParameters.length === 0) {
            const start = typeParameters.pos - "<".length;
            const end = skipTrivia(file.text, typeParameters.end) + ">".length;
            return grammarErrorAtPos(file, start, end - start, Diagnostics.Type_parameter_list_cannot_be_empty);
        }
        return false;
    }

    function checkGrammarParameterList(parameters: NodeArray<ParameterDeclaration>) {
        let seenOptionalParameter = false;
        const parameterCount = parameters.length;

        for (let i = 0; i < parameterCount; i++) {
            const parameter = parameters[i];
            if (parameter.dotDotDotToken) {
                if (i !== (parameterCount - 1)) {
                    return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                }
                if (!(parameter.flags & NodeFlags.Ambient)) { // Allow `...foo,` in ambient declarations; see GH#23070
                    checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                }

                if (parameter.questionToken) {
                    return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional);
                }

                if (parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                }
            }
            else if (hasEffectiveQuestionToken(parameter)) {
                seenOptionalParameter = true;
                if (parameter.questionToken && parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                }
            }
            else if (seenOptionalParameter && !parameter.initializer) {
                return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
            }
        }
    }

    function getNonSimpleParameters(parameters: readonly ParameterDeclaration[]): readonly ParameterDeclaration[] {
        return filter(parameters, parameter => !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter));
    }

    function checkGrammarForUseStrictSimpleParameterList(node: FunctionLikeDeclaration): boolean {
        if (languageVersion >= ScriptTarget.ES2016) {
            const useStrictDirective = node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements);
            if (useStrictDirective) {
                const nonSimpleParameters = getNonSimpleParameters(node.parameters);
                if (length(nonSimpleParameters)) {
                    forEach(nonSimpleParameters, parameter => {
                        addRelatedInfo(
                            error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive),
                            createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here),
                        );
                    });

                    const diagnostics = nonSimpleParameters.map((parameter, index) => (
                        index === 0 ? createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, Diagnostics.and_here)
                    )) as [DiagnosticWithLocation, ...DiagnosticWithLocation[]];
                    addRelatedInfo(error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list), ...diagnostics);
                    return true;
                }
            }
        }
        return false;
    }

    function checkGrammarFunctionLikeDeclaration(node: FunctionLikeDeclaration | MethodSignature): boolean {
        // Prevent cascading error by short-circuit
        const file = getSourceFileOfNode(node);
        return checkGrammarModifiers(node) ||
            checkGrammarTypeParameterList(node.typeParameters, file) ||
            checkGrammarParameterList(node.parameters) ||
            checkGrammarArrowFunction(node, file) ||
            (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node));
    }

    function checkGrammarClassLikeDeclaration(node: ClassLikeDeclaration): boolean {
        const file = getSourceFileOfNode(node);
        return checkGrammarClassDeclarationHeritageClauses(node) ||
            checkGrammarTypeParameterList(node.typeParameters, file);
    }

    function checkGrammarArrowFunction(node: Node, file: SourceFile): boolean {
        if (!isArrowFunction(node)) {
            return false;
        }

        if (node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint)) {
            if (file && fileExtensionIsOneOf(file.fileName, [Extension.Mts, Extension.Cts])) {
                grammarErrorOnNode(node.typeParameters[0], Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint);
            }
        }

        const { equalsGreaterThanToken } = node;
        const startLine = getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line;
        const endLine = getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line;
        return startLine !== endLine && grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow);
    }

    function checkGrammarIndexSignatureParameters(node: SignatureDeclaration): boolean {
        const parameter = node.parameters[0];
        if (node.parameters.length !== 1) {
            if (parameter) {
                return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter);
            }
            else {
                return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter);
            }
        }
        checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma);
        if (parameter.dotDotDotToken) {
            return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
        }
        if (hasEffectiveModifiers(parameter)) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
        }
        if (parameter.questionToken) {
            return grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
        }
        if (parameter.initializer) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
        }
        if (!parameter.type) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
        }
        const type = getTypeFromTypeNode(parameter.type);
        if (someType(type, t => !!(t.flags & TypeFlags.StringOrNumberLiteralOrUnique)) || isGenericType(type)) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead);
        }
        if (!everyType(type, isValidIndexKeyType)) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type);
        }
        if (!node.type) {
            return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation);
        }
        return false;
    }

    function checkGrammarIndexSignature(node: IndexSignatureDeclaration) {
        // Prevent cascading error by short-circuit
        return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node);
    }

    function checkGrammarForAtLeastOneTypeArgument(node: Node, typeArguments: NodeArray<TypeNode> | undefined): boolean {
        if (typeArguments && typeArguments.length === 0) {
            const sourceFile = getSourceFileOfNode(node);
            const start = typeArguments.pos - "<".length;
            const end = skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
            return grammarErrorAtPos(sourceFile, start, end - start, Diagnostics.Type_argument_list_cannot_be_empty);
        }
        return false;
    }

    function checkGrammarTypeArguments(node: Node, typeArguments: NodeArray<TypeNode> | undefined): boolean {
        return checkGrammarForDisallowedTrailingComma(typeArguments) ||
            checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
    }

    function checkGrammarTaggedTemplateChain(node: TaggedTemplateExpression): boolean {
        if (node.questionDotToken || node.flags & NodeFlags.OptionalChain) {
            return grammarErrorOnNode(node.template, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain);
        }
        return false;
    }

    function checkGrammarHeritageClause(node: HeritageClause): boolean {
        const types = node.types;
        if (checkGrammarForDisallowedTrailingComma(types)) {
            return true;
        }
        if (types && types.length === 0) {
            const listType = tokenToString(node.token);
            return grammarErrorAtPos(node, types.pos, 0, Diagnostics._0_list_cannot_be_empty, listType);
        }
        return some(types, checkGrammarExpressionWithTypeArguments);
    }

    function checkGrammarExpressionWithTypeArguments(node: ExpressionWithTypeArguments | TypeQueryNode) {
        if (isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments) {
            return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments);
        }
        return checkGrammarTypeArguments(node, node.typeArguments);
    }

    function checkGrammarClassDeclarationHeritageClauses(node: ClassLikeDeclaration) {
        let seenExtendsClause = false;
        let seenImplementsClause = false;

        if (!checkGrammarModifiers(node) && node.heritageClauses) {
            for (const heritageClause of node.heritageClauses) {
                if (heritageClause.token === SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen);
                    }

                    if (seenImplementsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause);
                    }

                    if (heritageClause.types.length > 1) {
                        return grammarErrorOnFirstToken(heritageClause.types[1], Diagnostics.Classes_can_only_extend_a_single_class);
                    }

                    seenExtendsClause = true;
                }
                else {
                    Debug.assert(heritageClause.token === SyntaxKind.ImplementsKeyword);
                    if (seenImplementsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen);
                    }

                    seenImplementsClause = true;
                }

                // Grammar checking heritageClause inside class declaration
                checkGrammarHeritageClause(heritageClause);
            }
        }
    }

    function checkGrammarInterfaceDeclaration(node: InterfaceDeclaration) {
        let seenExtendsClause = false;

        if (node.heritageClauses) {
            for (const heritageClause of node.heritageClauses) {
                if (heritageClause.token === SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen);
                    }

                    seenExtendsClause = true;
                }
                else {
                    Debug.assert(heritageClause.token === SyntaxKind.ImplementsKeyword);
                    return grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause);
                }

                // Grammar checking heritageClause inside class declaration
                checkGrammarHeritageClause(heritageClause);
            }
        }
        return false;
    }

    function checkGrammarComputedPropertyName(node: Node): boolean {
        // If node is not a computedPropertyName, just skip the grammar checking
        if (node.kind !== SyntaxKind.ComputedPropertyName) {
            return false;
        }

        const computedPropertyName = node as ComputedPropertyName;
        if (computedPropertyName.expression.kind === SyntaxKind.BinaryExpression && (computedPropertyName.expression as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken) {
            return grammarErrorOnNode(computedPropertyName.expression, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name);
        }
        return false;
    }

    function checkGrammarForGenerator(node: FunctionLikeDeclaration) {
        if (node.asteriskToken) {
            Debug.assert(
                node.kind === SyntaxKind.FunctionDeclaration ||
                    node.kind === SyntaxKind.FunctionExpression ||
                    node.kind === SyntaxKind.MethodDeclaration,
            );
            if (node.flags & NodeFlags.Ambient) {
                return grammarErrorOnNode(node.asteriskToken, Diagnostics.Generators_are_not_allowed_in_an_ambient_context);
            }
            if (!node.body) {
                return grammarErrorOnNode(node.asteriskToken, Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator);
            }
        }
    }

    function checkGrammarForInvalidQuestionMark(questionToken: QuestionToken | undefined, message: DiagnosticMessage): boolean {
        return !!questionToken && grammarErrorOnNode(questionToken, message);
    }

    function checkGrammarForInvalidExclamationToken(exclamationToken: ExclamationToken | undefined, message: DiagnosticMessage): boolean {
        return !!exclamationToken && grammarErrorOnNode(exclamationToken, message);
    }

    function checkGrammarObjectLiteralExpression(node: ObjectLiteralExpression, inDestructuring: boolean) {
        const seen = new Map<__String, DeclarationMeaning>();

        for (const prop of node.properties) {
            if (prop.kind === SyntaxKind.SpreadAssignment) {
                if (inDestructuring) {
                    // a rest property cannot be destructured any further
                    const expression = skipParentheses(prop.expression);
                    if (isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression)) {
                        return grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
                    }
                }
                continue;
            }
            const name = prop.name;
            if (name.kind === SyntaxKind.ComputedPropertyName) {
                // If the name is not a ComputedPropertyName, the grammar checking will skip it
                checkGrammarComputedPropertyName(name);
            }

            if (prop.kind === SyntaxKind.ShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer) {
                // having objectAssignmentInitializer is only valid in ObjectAssignmentPattern
                // outside of destructuring it is a syntax error
                grammarErrorOnNode(prop.equalsToken!, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern);
            }

            if (name.kind === SyntaxKind.PrivateIdentifier) {
                grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
            }

            // Modifiers are never allowed on properties except for 'async' on a method declaration
            if (canHaveModifiers(prop) && prop.modifiers) {
                for (const mod of prop.modifiers) {
                    if (isModifier(mod) && (mod.kind !== SyntaxKind.AsyncKeyword || prop.kind !== SyntaxKind.MethodDeclaration)) {
                        grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod));
                    }
                }
            }
            else if (canHaveIllegalModifiers(prop) && prop.modifiers) {
                for (const mod of prop.modifiers) {
                    if (isModifier(mod)) {
                        grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod));
                    }
                }
            }

            // ECMA-262 11.1.5 Object Initializer
            // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
            // a.This production is contained in strict code and IsDataDescriptor(previous) is true and
            // IsDataDescriptor(propId.descriptor) is true.
            //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
            //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
            //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
            // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
            let currentKind: DeclarationMeaning;
            switch (prop.kind) {
                case SyntaxKind.ShorthandPropertyAssignment:
                case SyntaxKind.PropertyAssignment:
                    // Grammar checking for computedPropertyName and shorthandPropertyAssignment
                    checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context);
                    checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional);
                    if (name.kind === SyntaxKind.NumericLiteral) {
                        checkGrammarNumericLiteral(name);
                    }
                    if (name.kind === SyntaxKind.BigIntLiteral) {
                        addErrorOrSuggestion(/*isError*/ true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name));
                    }
                    currentKind = DeclarationMeaning.PropertyAssignment;
                    break;
                case SyntaxKind.MethodDeclaration:
                    currentKind = DeclarationMeaning.Method;
                    break;
                case SyntaxKind.GetAccessor:
                    currentKind = DeclarationMeaning.GetAccessor;
                    break;
                case SyntaxKind.SetAccessor:
                    currentKind = DeclarationMeaning.SetAccessor;
                    break;
                default:
                    Debug.assertNever(prop, "Unexpected syntax kind:" + (prop as Node).kind);
            }

            if (!inDestructuring) {
                const effectiveName = getEffectivePropertyNameForPropertyNameNode(name);
                if (effectiveName === undefined) {
                    continue;
                }

                const existingKind = seen.get(effectiveName);
                if (!existingKind) {
                    seen.set(effectiveName, currentKind);
                }
                else {
                    if ((currentKind & DeclarationMeaning.Method) && (existingKind & DeclarationMeaning.Method)) {
                        grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name));
                    }
                    else if ((currentKind & DeclarationMeaning.PropertyAssignment) && (existingKind & DeclarationMeaning.PropertyAssignment)) {
                        grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name));
                    }
                    else if ((currentKind & DeclarationMeaning.GetOrSetAccessor) && (existingKind & DeclarationMeaning.GetOrSetAccessor)) {
                        if (existingKind !== DeclarationMeaning.GetOrSetAccessor && currentKind !== existingKind) {
                            seen.set(effectiveName, currentKind | existingKind);
                        }
                        else {
                            return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                        }
                    }
                    else {
                        return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                    }
                }
            }
        }
    }

    function checkGrammarJsxElement(node: JsxOpeningLikeElement) {
        checkGrammarJsxName(node.tagName);
        checkGrammarTypeArguments(node, node.typeArguments);
        const seen = new Map<__String, boolean>();

        for (const attr of node.attributes.properties) {
            if (attr.kind === SyntaxKind.JsxSpreadAttribute) {
                continue;
            }

            const { name, initializer } = attr;
            const escapedText = getEscapedTextOfJsxAttributeName(name);
            if (!seen.get(escapedText)) {
                seen.set(escapedText, true);
            }
            else {
                return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);
            }

            if (initializer && initializer.kind === SyntaxKind.JsxExpression && !initializer.expression) {
                return grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression);
            }
        }
    }

    function checkGrammarJsxName(node: JsxTagNameExpression) {
        if (isPropertyAccessExpression(node) && isJsxNamespacedName(node.expression)) {
            return grammarErrorOnNode(node.expression, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names);
        }
        if (isJsxNamespacedName(node) && getJSXTransformEnabled(compilerOptions) && !isIntrinsicJsxName(node.namespace.escapedText)) {
            return grammarErrorOnNode(node, Diagnostics.React_components_cannot_include_JSX_namespace_names);
        }
    }

    function checkGrammarJsxExpression(node: JsxExpression) {
        if (node.expression && isCommaSequence(node.expression)) {
            return grammarErrorOnNode(node.expression, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array);
        }
    }

    function checkGrammarForInOrForOfStatement(forInOrOfStatement: ForInOrOfStatement): boolean {
        if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) {
            return true;
        }

        if (forInOrOfStatement.kind === SyntaxKind.ForOfStatement && forInOrOfStatement.awaitModifier) {
            if (!(forInOrOfStatement.flags & NodeFlags.AwaitContext)) {
                const sourceFile = getSourceFileOfNode(forInOrOfStatement);
                if (isInTopLevelContext(forInOrOfStatement)) {
                    if (!hasParseDiagnostics(sourceFile)) {
                        if (!isEffectiveExternalModule(sourceFile, compilerOptions)) {
                            diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module));
                        }
                        switch (moduleKind) {
                            case ModuleKind.Node16:
                            case ModuleKind.Node18:
                            case ModuleKind.Node20:
                            case ModuleKind.NodeNext:
                                if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {
                                    diagnostics.add(
                                        createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),
                                    );
                                    break;
                                }
                                // fallthrough
                            case ModuleKind.ES2022:
                            case ModuleKind.ESNext:
                            case ModuleKind.Preserve:
                            case ModuleKind.System:
                                if (languageVersion >= ScriptTarget.ES2017) {
                                    break;
                                }
                                // fallthrough
                            default:
                                diagnostics.add(
                                    createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_node18_node20_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher),
                                );
                                break;
                        }
                    }
                }
                else {
                    // use of 'for-await-of' in non-async function
                    if (!hasParseDiagnostics(sourceFile)) {
                        const diagnostic = createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
                        const func = getContainingFunction(forInOrOfStatement);
                        if (func && func.kind !== SyntaxKind.Constructor) {
                            Debug.assert((getFunctionFlags(func) & FunctionFlags.Async) === 0, "Enclosing function should never be an async function.");
                            const relatedInfo = createDiagnosticForNode(func, Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                            addRelatedInfo(diagnostic, relatedInfo);
                        }
                        diagnostics.add(diagnostic);
                        return true;
                    }
                }
            }
        }

        if (
            isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlags.AwaitContext) &&
            isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText === "async"
        ) {
            grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async);
            return false;
        }

        if (forInOrOfStatement.initializer.kind === SyntaxKind.VariableDeclarationList) {
            const variableList = forInOrOfStatement.initializer as VariableDeclarationList;
            if (!checkGrammarVariableDeclarationList(variableList)) {
                const declarations = variableList.declarations;

                // declarations.length can be zero if there is an error in variable declaration in for-of or for-in
                // See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
                // For example:
                //      var let = 10;
                //      for (let of [1,2,3]) {} // this is invalid ES6 syntax
                //      for (let in [1,2,3]) {} // this is invalid ES6 syntax
                // We will then want to skip on grammar checking on variableList declaration
                if (!declarations.length) {
                    return false;
                }

                if (declarations.length > 1) {
                    const diagnostic = forInOrOfStatement.kind === SyntaxKind.ForInStatement
                        ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
                        : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
                    return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic);
                }
                const firstDeclaration = declarations[0];

                if (firstDeclaration.initializer) {
                    const diagnostic = forInOrOfStatement.kind === SyntaxKind.ForInStatement
                        ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
                        : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
                    return grammarErrorOnNode(firstDeclaration.name, diagnostic);
                }
                if (firstDeclaration.type) {
                    const diagnostic = forInOrOfStatement.kind === SyntaxKind.ForInStatement
                        ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
                        : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
                    return grammarErrorOnNode(firstDeclaration, diagnostic);
                }
            }
        }

        return false;
    }

    function checkGrammarAccessor(accessor: AccessorDeclaration): boolean {
        if (!(accessor.flags & NodeFlags.Ambient) && (accessor.parent.kind !== SyntaxKind.TypeLiteral) && (accessor.parent.kind !== SyntaxKind.InterfaceDeclaration)) {
            if (languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(accessor.name)) {
                return grammarErrorOnNode(accessor.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            }
            if (accessor.body === undefined && !hasSyntacticModifier(accessor, ModifierFlags.Abstract)) {
                return grammarErrorAtPos(accessor, accessor.end - 1, ";".length, Diagnostics._0_expected, "{");
            }
        }
        if (accessor.body) {
            if (hasSyntacticModifier(accessor, ModifierFlags.Abstract)) {
                return grammarErrorOnNode(accessor, Diagnostics.An_abstract_accessor_cannot_have_an_implementation);
            }
            if (accessor.parent.kind === SyntaxKind.TypeLiteral || accessor.parent.kind === SyntaxKind.InterfaceDeclaration) {
                return grammarErrorOnNode(accessor.body, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
            }
        }
        if (accessor.typeParameters) {
            return grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters);
        }
        if (!doesAccessorHaveCorrectParameterCount(accessor)) {
            return grammarErrorOnNode(
                accessor.name,
                accessor.kind === SyntaxKind.GetAccessor ?
                    Diagnostics.A_get_accessor_cannot_have_parameters :
                    Diagnostics.A_set_accessor_must_have_exactly_one_parameter,
            );
        }
        if (accessor.kind === SyntaxKind.SetAccessor) {
            if (accessor.type) {
                return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
            }
            const parameter = Debug.checkDefined(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.");
            if (parameter.dotDotDotToken) {
                return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_set_accessor_cannot_have_rest_parameter);
            }
            if (parameter.questionToken) {
                return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
            }
            if (parameter.initializer) {
                return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
            }
        }
        return false;
    }

    /** Does the accessor have the right number of parameters?
     * A get accessor has no parameters or a single `this` parameter.
     * A set accessor has one parameter or a `this` parameter and one more parameter.
     */
    function doesAccessorHaveCorrectParameterCount(accessor: AccessorDeclaration) {
        return getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === SyntaxKind.GetAccessor ? 0 : 1);
    }

    function getAccessorThisParameter(accessor: AccessorDeclaration): ParameterDeclaration | undefined {
        if (accessor.parameters.length === (accessor.kind === SyntaxKind.GetAccessor ? 1 : 2)) {
            return getThisParameter(accessor);
        }
    }

    function checkGrammarTypeOperatorNode(node: TypeOperatorNode) {
        if (node.operator === SyntaxKind.UniqueKeyword) {
            if (node.type.kind !== SyntaxKind.SymbolKeyword) {
                return grammarErrorOnNode(node.type, Diagnostics._0_expected, tokenToString(SyntaxKind.SymbolKeyword));
            }
            let parent = walkUpParenthesizedTypes(node.parent);
            if (isInJSFile(parent) && isJSDocTypeExpression(parent)) {
                const host = getJSDocHost(parent);
                if (host) {
                    parent = getSingleVariableOfVariableStatement(host) || host;
                }
            }
            switch (parent.kind) {
                case SyntaxKind.VariableDeclaration:
                    const decl = parent as VariableDeclaration;
                    if (decl.name.kind !== SyntaxKind.Identifier) {
                        return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);
                    }
                    if (!isVariableDeclarationInVariableStatement(decl)) {
                        return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);
                    }
                    if (!(decl.parent.flags & NodeFlags.Const)) {
                        return grammarErrorOnNode((parent as VariableDeclaration).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);
                    }
                    break;

                case SyntaxKind.PropertyDeclaration:
                    if (
                        !isStatic(parent) ||
                        !hasEffectiveReadonlyModifier(parent)
                    ) {
                        return grammarErrorOnNode((parent as PropertyDeclaration).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);
                    }
                    break;

                case SyntaxKind.PropertySignature:
                    if (!hasSyntacticModifier(parent, ModifierFlags.Readonly)) {
                        return grammarErrorOnNode((parent as PropertySignature).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);
                    }
                    break;

                default:
                    return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here);
            }
        }
        else if (node.operator === SyntaxKind.ReadonlyKeyword) {
            if (node.type.kind !== SyntaxKind.ArrayType && node.type.kind !== SyntaxKind.TupleType) {
                return grammarErrorOnFirstToken(node, Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, tokenToString(SyntaxKind.SymbolKeyword));
            }
        }
    }

    function checkGrammarForInvalidDynamicName(node: DeclarationName, message: DiagnosticMessage) {
        // Even non-bindable names are allowed as late-bound implied index signatures so long as the name is a simple `a.b.c` type name expression
        if (isNonBindableDynamicName(node) && !isEntityNameExpression(isElementAccessExpression(node) ? skipParentheses(node.argumentExpression) : (node as ComputedPropertyName).expression)) {
            return grammarErrorOnNode(node, message);
        }
    }

    function checkGrammarMethod(node: MethodDeclaration | MethodSignature) {
        if (checkGrammarFunctionLikeDeclaration(node)) {
            return true;
        }

        if (node.kind === SyntaxKind.MethodDeclaration) {
            if (node.parent.kind === SyntaxKind.ObjectLiteralExpression) {
                // We only disallow modifier on a method declaration if it is a property of object-literal-expression
                if (node.modifiers && !(node.modifiers.length === 1 && first(node.modifiers).kind === SyntaxKind.AsyncKeyword)) {
                    return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here);
                }
                else if (checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional)) {
                    return true;
                }
                else if (checkGrammarForInvalidExclamationToken(node.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)) {
                    return true;
                }
                else if (node.body === undefined) {
                    return grammarErrorAtPos(node, node.end - 1, ";".length, Diagnostics._0_expected, "{");
                }
            }
            if (checkGrammarForGenerator(node)) {
                return true;
            }
        }

        if (isClassLike(node.parent)) {
            if (languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(node.name)) {
                return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            }
            // Technically, computed properties in ambient contexts is disallowed
            // for property declarations and accessors too, not just methods.
            // However, property declarations disallow computed names in general,
            // and accessors are not allowed in ambient contexts in general,
            // so this error only really matters for methods.
            if (node.flags & NodeFlags.Ambient) {
                return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            }
            else if (node.kind === SyntaxKind.MethodDeclaration && !node.body) {
                return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            }
        }
        else if (node.parent.kind === SyntaxKind.InterfaceDeclaration) {
            return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
        }
        else if (node.parent.kind === SyntaxKind.TypeLiteral) {
            return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
        }
    }

    function checkGrammarBreakOrContinueStatement(node: BreakOrContinueStatement): boolean {
        let current: Node = node;
        while (current) {
            if (isFunctionLikeOrClassStaticBlockDeclaration(current)) {
                return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);
            }

            switch (current.kind) {
                case SyntaxKind.LabeledStatement:
                    if (node.label && (current as LabeledStatement).label.escapedText === node.label.escapedText) {
                        // found matching label - verify that label usage is correct
                        // continue can only target labels that are on iteration statements
                        const isMisplacedContinueLabel = node.kind === SyntaxKind.ContinueStatement
                            && !isIterationStatement((current as LabeledStatement).statement, /*lookInLabeledStatements*/ true);

                        if (isMisplacedContinueLabel) {
                            return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                        }

                        return false;
                    }
                    break;
                case SyntaxKind.SwitchStatement:
                    if (node.kind === SyntaxKind.BreakStatement && !node.label) {
                        // unlabeled break within switch statement - ok
                        return false;
                    }
                    break;
                default:
                    if (isIterationStatement(current, /*lookInLabeledStatements*/ false) && !node.label) {
                        // unlabeled break or continue within iteration statement - ok
                        return false;
                    }
                    break;
            }

            current = current.parent;
        }

        if (node.label) {
            const message = node.kind === SyntaxKind.BreakStatement
                ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
                : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;

            return grammarErrorOnNode(node, message);
        }
        else {
            const message = node.kind === SyntaxKind.BreakStatement
                ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
                : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
            return grammarErrorOnNode(node, message);
        }
    }

    function checkGrammarBindingElement(node: BindingElement) {
        if (node.dotDotDotToken) {
            const elements = node.parent.elements;
            if (node !== last(elements)) {
                return grammarErrorOnNode(node, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
            }
            checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);

            if (node.propertyName) {
                return grammarErrorOnNode(node.name, Diagnostics.A_rest_element_cannot_have_a_property_name);
            }
        }

        if (node.dotDotDotToken && node.initializer) {
            // Error on equals token which immediately precedes the initializer
            return grammarErrorAtPos(node, node.initializer.pos - 1, 1, Diagnostics.A_rest_element_cannot_have_an_initializer);
        }
    }

    function isStringOrNumberLiteralExpression(expr: Expression) {
        return isStringOrNumericLiteralLike(expr) ||
            expr.kind === SyntaxKind.PrefixUnaryExpression && (expr as PrefixUnaryExpression).operator === SyntaxKind.MinusToken &&
                (expr as PrefixUnaryExpression).operand.kind === SyntaxKind.NumericLiteral;
    }

    function isBigIntLiteralExpression(expr: Expression) {
        return expr.kind === SyntaxKind.BigIntLiteral ||
            expr.kind === SyntaxKind.PrefixUnaryExpression && (expr as PrefixUnaryExpression).operator === SyntaxKind.MinusToken &&
                (expr as PrefixUnaryExpression).operand.kind === SyntaxKind.BigIntLiteral;
    }

    function isSimpleLiteralEnumReference(expr: Expression) {
        if (
            (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) &&
            isEntityNameExpression(expr.expression)
        ) {
            return !!(checkExpressionCached(expr).flags & TypeFlags.EnumLike);
        }
    }

    function checkAmbientInitializer(node: VariableDeclaration | PropertyDeclaration | PropertySignature) {
        const initializer = node.initializer;
        if (initializer) {
            const isInvalidInitializer = !(
                isStringOrNumberLiteralExpression(initializer) ||
                isSimpleLiteralEnumReference(initializer) ||
                initializer.kind === SyntaxKind.TrueKeyword || initializer.kind === SyntaxKind.FalseKeyword ||
                isBigIntLiteralExpression(initializer)
            );
            const isConstOrReadonly = isDeclarationReadonly(node) || isVariableDeclaration(node) && (isVarConstLike(node));
            if (isConstOrReadonly && !node.type) {
                if (isInvalidInitializer) {
                    return grammarErrorOnNode(initializer, Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference);
                }
            }
            else {
                return grammarErrorOnNode(initializer, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
            }
        }
    }

    function checkGrammarVariableDeclaration(node: VariableDeclaration) {
        const nodeFlags = getCombinedNodeFlagsCached(node);
        const blockScopeKind = nodeFlags & NodeFlags.BlockScoped;
        if (isBindingPattern(node.name)) {
            switch (blockScopeKind) {
                case NodeFlags.AwaitUsing:
                    return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using");
                case NodeFlags.Using:
                    return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using");
            }
        }

        if (node.parent.parent.kind !== SyntaxKind.ForInStatement && node.parent.parent.kind !== SyntaxKind.ForOfStatement) {
            if (nodeFlags & NodeFlags.Ambient) {
                checkAmbientInitializer(node);
            }
            else if (!node.initializer) {
                if (isBindingPattern(node.name) && !isBindingPattern(node.parent)) {
                    return grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer);
                }
                switch (blockScopeKind) {
                    case NodeFlags.AwaitUsing:
                        return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using");
                    case NodeFlags.Using:
                        return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using");
                    case NodeFlags.Const:
                        return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const");
                }
            }
        }

        if (node.exclamationToken && (node.parent.parent.kind !== SyntaxKind.VariableStatement || !node.type || node.initializer || nodeFlags & NodeFlags.Ambient)) {
            const message = node.initializer
                ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
                : !node.type
                ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
                : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
            return grammarErrorOnNode(node.exclamationToken, message);
        }

        if (
            host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System &&
            !(node.parent.parent.flags & NodeFlags.Ambient) && hasSyntacticModifier(node.parent.parent, ModifierFlags.Export)
        ) {
            checkESModuleMarker(node.name);
        }

        // 1. LexicalDeclaration : LetOrConst BindingList ;
        // It is a Syntax Error if the BoundNames of BindingList contains "let".
        // 2. ForDeclaration: ForDeclaration : LetOrConst ForBinding
        // It is a Syntax Error if the BoundNames of ForDeclaration contains "let".

        // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
        // and its Identifier is eval or arguments
        return !!blockScopeKind && checkGrammarNameInLetOrConstDeclarations(node.name);
    }

    function checkESModuleMarker(name: Identifier | BindingPattern): boolean {
        if (name.kind === SyntaxKind.Identifier) {
            if (idText(name) === "__esModule") {
                return grammarErrorOnNodeSkippedOn("noEmit", name, Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules);
            }
        }
        else {
            const elements = name.elements;
            for (const element of elements) {
                if (!isOmittedExpression(element)) {
                    return checkESModuleMarker(element.name);
                }
            }
        }
        return false;
    }

    function checkGrammarNameInLetOrConstDeclarations(name: Identifier | BindingPattern): boolean {
        if (name.kind === SyntaxKind.Identifier) {
            if (name.escapedText === "let") {
                return grammarErrorOnNode(name, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
            }
        }
        else {
            const elements = name.elements;
            for (const element of elements) {
                if (!isOmittedExpression(element)) {
                    checkGrammarNameInLetOrConstDeclarations(element.name);
                }
            }
        }
        return false;
    }

    function checkGrammarVariableDeclarationList(declarationList: VariableDeclarationList): boolean {
        const declarations = declarationList.declarations;
        if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) {
            return true;
        }

        if (!declarationList.declarations.length) {
            return grammarErrorAtPos(declarationList, declarations.pos, declarations.end - declarations.pos, Diagnostics.Variable_declaration_list_cannot_be_empty);
        }

        const blockScopeFlags = declarationList.flags & NodeFlags.BlockScoped;
        if (blockScopeFlags === NodeFlags.Using || blockScopeFlags === NodeFlags.AwaitUsing) {
            if (isForInStatement(declarationList.parent)) {
                return grammarErrorOnNode(
                    declarationList,
                    blockScopeFlags === NodeFlags.Using ?
                        Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration :
                        Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration,
                );
            }

            if (declarationList.flags & NodeFlags.Ambient) {
                return grammarErrorOnNode(
                    declarationList,
                    blockScopeFlags === NodeFlags.Using ?
                        Diagnostics.using_declarations_are_not_allowed_in_ambient_contexts :
                        Diagnostics.await_using_declarations_are_not_allowed_in_ambient_contexts,
                );
            }

            if (blockScopeFlags === NodeFlags.AwaitUsing) {
                return checkAwaitGrammar(declarationList);
            }
        }

        return false;
    }

    function allowBlockDeclarations(parent: Node): boolean {
        switch (parent.kind) {
            case SyntaxKind.IfStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
                return false;
            case SyntaxKind.LabeledStatement:
                return allowBlockDeclarations(parent.parent);
        }

        return true;
    }

    function checkGrammarForDisallowedBlockScopedVariableStatement(node: VariableStatement) {
        if (!allowBlockDeclarations(node.parent)) {
            const blockScopeKind = getCombinedNodeFlagsCached(node.declarationList) & NodeFlags.BlockScoped;
            if (blockScopeKind) {
                const keyword = blockScopeKind === NodeFlags.Let ? "let" :
                    blockScopeKind === NodeFlags.Const ? "const" :
                    blockScopeKind === NodeFlags.Using ? "using" :
                    blockScopeKind === NodeFlags.AwaitUsing ? "await using" :
                    Debug.fail("Unknown BlockScope flag");
                error(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, keyword);
            }
        }
    }

    function checkGrammarMetaProperty(node: MetaProperty) {
        const escapedText = node.name.escapedText;
        switch (node.keywordToken) {
            case SyntaxKind.NewKeyword:
                if (escapedText !== "target") {
                    return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target");
                }
                break;
            case SyntaxKind.ImportKeyword:
                if (escapedText !== "meta") {
                    const isCallee = isCallExpression(node.parent) && node.parent.expression === node;
                    if (escapedText === "defer") {
                        if (!isCallee) {
                            return grammarErrorAtPos(node, node.end, 0, Diagnostics._0_expected, "(");
                        }
                    }
                    else {
                        if (isCallee) {
                            return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_import_Did_you_mean_meta_or_defer, unescapeLeadingUnderscores(node.name.escapedText));
                        }
                        return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta");
                    }
                }
                break;
        }
    }

    function hasParseDiagnostics(sourceFile: SourceFile): boolean {
        return sourceFile.parseDiagnostics.length > 0;
    }

    function grammarErrorOnFirstToken(node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            const span = getSpanOfTokenAtPosition(sourceFile, node.pos);
            diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message, ...args));
            return true;
        }
        return false;
    }

    function grammarErrorAtPos(nodeForSourceFile: Node, start: number, length: number, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const sourceFile = getSourceFileOfNode(nodeForSourceFile);
        if (!hasParseDiagnostics(sourceFile)) {
            diagnostics.add(createFileDiagnostic(sourceFile, start, length, message, ...args));
            return true;
        }
        return false;
    }

    function grammarErrorOnNodeSkippedOn(key: keyof CompilerOptions, node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            errorSkippedOn(key, node, message, ...args);
            return true;
        }
        return false;
    }

    function grammarErrorOnNode(node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            error(node, message, ...args);
            return true;
        }
        return false;
    }

    function checkGrammarConstructorTypeParameters(node: ConstructorDeclaration) {
        const jsdocTypeParameters = isInJSFile(node) ? getJSDocTypeParameterDeclarations(node) : undefined;
        const range = node.typeParameters || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters);
        if (range) {
            const pos = range.pos === range.end ? range.pos : skipTrivia(getSourceFileOfNode(node).text, range.pos);
            return grammarErrorAtPos(node, pos, range.end - pos, Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
        }
    }

    function checkGrammarConstructorTypeAnnotation(node: ConstructorDeclaration) {
        const type = node.type || getEffectiveReturnTypeNode(node);
        if (type) {
            return grammarErrorOnNode(type, Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
        }
    }

    function checkGrammarProperty(node: PropertyDeclaration | PropertySignature) {
        if (isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind === SyntaxKind.InKeyword) {
            return grammarErrorOnNode(node.parent.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
        }
        if (isClassLike(node.parent)) {
            if (isStringLiteral(node.name) && node.name.text === "constructor") {
                return grammarErrorOnNode(node.name, Diagnostics.Classes_may_not_have_a_field_named_constructor);
            }
            if (checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type)) {
                return true;
            }
            if (languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(node.name)) {
                return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            }
            if (languageVersion < ScriptTarget.ES2015 && isAutoAccessorPropertyDeclaration(node) && !(node.flags & NodeFlags.Ambient)) {
                return grammarErrorOnNode(node.name, Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            }
            if (isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional)) {
                return true;
            }
        }
        else if (node.parent.kind === SyntaxKind.InterfaceDeclaration) {
            if (checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
                return true;
            }

            // Interfaces cannot contain property declarations
            Debug.assertNode(node, isPropertySignature);
            if (node.initializer) {
                return grammarErrorOnNode(node.initializer, Diagnostics.An_interface_property_cannot_have_an_initializer);
            }
        }
        else if (isTypeLiteralNode(node.parent)) {
            if (checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
                return true;
            }
            // Type literals cannot contain property declarations
            Debug.assertNode(node, isPropertySignature);
            if (node.initializer) {
                return grammarErrorOnNode(node.initializer, Diagnostics.A_type_literal_property_cannot_have_an_initializer);
            }
        }

        if (node.flags & NodeFlags.Ambient) {
            checkAmbientInitializer(node);
        }

        if (
            isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(node.parent) || !node.type || node.initializer ||
                node.flags & NodeFlags.Ambient || isStatic(node) || hasAbstractModifier(node))
        ) {
            const message = node.initializer
                ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
                : !node.type
                ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
                : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
            return grammarErrorOnNode(node.exclamationToken, message);
        }
    }

    function checkGrammarTopLevelElementForRequiredDeclareModifier(node: Node): boolean {
        // A declare modifier is required for any top level .d.ts declaration except export=, export default, export as namespace
        // interfaces and imports categories:
        //
        //  DeclarationElement:
        //     ExportAssignment
        //     export_opt   InterfaceDeclaration
        //     export_opt   TypeAliasDeclaration
        //     export_opt   ImportDeclaration
        //     export_opt   ExternalImportDeclaration
        //     export_opt   AmbientDeclaration
        //
        // TODO: The spec needs to be amended to reflect this grammar.
        if (
            node.kind === SyntaxKind.InterfaceDeclaration ||
            node.kind === SyntaxKind.TypeAliasDeclaration ||
            node.kind === SyntaxKind.ImportDeclaration ||
            node.kind === SyntaxKind.ImportEqualsDeclaration ||
            node.kind === SyntaxKind.ExportDeclaration ||
            node.kind === SyntaxKind.ExportAssignment ||
            node.kind === SyntaxKind.NamespaceExportDeclaration ||
            hasSyntacticModifier(node, ModifierFlags.Ambient | ModifierFlags.Export | ModifierFlags.Default)
        ) {
            return false;
        }

        return grammarErrorOnFirstToken(node, Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier);
    }

    function checkGrammarTopLevelElementsForRequiredDeclareModifier(file: SourceFile): boolean {
        for (const decl of file.statements) {
            if (isDeclaration(decl) || decl.kind === SyntaxKind.VariableStatement) {
                if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {
                    return true;
                }
            }
        }
        return false;
    }

    function checkGrammarSourceFile(node: SourceFile): boolean {
        return !!(node.flags & NodeFlags.Ambient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node);
    }

    function checkGrammarStatementInAmbientContext(node: Node): boolean {
        if (node.flags & NodeFlags.Ambient) {
            // Find containing block which is either Block, ModuleBlock, SourceFile
            const links = getNodeLinks(node);
            if (!links.hasReportedStatementInAmbientContext && (isFunctionLike(node.parent) || isAccessor(node.parent))) {
                return getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
            }

            // We are either parented by another statement, or some sort of block.
            // If we're in a block, we only want to really report an error once
            // to prevent noisiness.  So use a bit on the block to indicate if
            // this has already been reported, and don't report if it has.
            //
            if (node.parent.kind === SyntaxKind.Block || node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {
                const links = getNodeLinks(node.parent);
                // Check if the containing block ever report this error
                if (!links.hasReportedStatementInAmbientContext) {
                    return links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
                }
            }
            else {
                // We must be parented by a statement.  If so, there's no need
                // to report the error as our parent will have already done it.
                // Debug.assert(isStatement(node.parent));
            }
        }
        return false;
    }

    function checkGrammarNumericLiteral(node: NumericLiteral) {
        // Realism (size) checking
        // We should test against `getTextOfNode(node)` rather than `node.text`, because `node.text` for large numeric literals can contain "."
        // e.g. `node.text` for numeric literal `1100000000000000000000` is `1.1e21`.
        const isFractional = getTextOfNode(node).includes(".");
        const isScientific = node.numericLiteralFlags & TokenFlags.Scientific;

        // Scientific notation (e.g. 2e54 and 1e00000000010) can't be converted to bigint
        // Fractional numbers (e.g. 9000000000000000.001) are inherently imprecise anyway
        if (isFractional || isScientific) {
            return;
        }

        // Here `node` is guaranteed to be a numeric literal representing an integer.
        // We need to judge whether the integer `node` represents is <= 2 ** 53 - 1, which can be accomplished by comparing to `value` defined below because:
        // 1) when `node` represents an integer <= 2 ** 53 - 1, `node.text` is its exact string representation and thus `value` precisely represents the integer.
        // 2) otherwise, although `node.text` may be imprecise string representation, its mathematical value and consequently `value` cannot be less than 2 ** 53,
        //    thus the result of the predicate won't be affected.
        const value = +node.text;
        if (value <= 2 ** 53 - 1) {
            return;
        }

        addErrorOrSuggestion(/*isError*/ false, createDiagnosticForNode(node, Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers));
    }

    function checkGrammarBigIntLiteral(node: BigIntLiteral): boolean {
        const literalType = isLiteralTypeNode(node.parent) ||
            isPrefixUnaryExpression(node.parent) && isLiteralTypeNode(node.parent.parent);
        if (!literalType) {
            if (languageVersion < ScriptTarget.ES2020) {
                if (grammarErrorOnNode(node, Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020)) {
                    return true;
                }
            }
        }
        return false;
    }

    function grammarErrorAfterFirstToken(node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            const span = getSpanOfTokenAtPosition(sourceFile, node.pos);
            diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span), /*length*/ 0, message, ...args));
            return true;
        }
        return false;
    }

    function getAmbientModules(): Symbol[] {
        if (!ambientModulesCache) {
            ambientModulesCache = [];
            globals.forEach((global, sym) => {
                // No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.
                if (ambientModuleSymbolRegex.test(sym as string)) {
                    ambientModulesCache!.push(global);
                }
            });
        }
        return ambientModulesCache;
    }

    function checkGrammarImportClause(node: ImportClause): boolean {
        if (node.phaseModifier === SyntaxKind.TypeKeyword) {
            if (node.name && node.namedBindings) {
                return grammarErrorOnNode(node, Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both);
            }
            if (node.namedBindings?.kind === SyntaxKind.NamedImports) {
                return checkGrammarNamedImportsOrExports(node.namedBindings);
            }
        }
        else if (node.phaseModifier === SyntaxKind.DeferKeyword) {
            if (node.name) {
                return grammarErrorOnNode(node, Diagnostics.Default_imports_are_not_allowed_in_a_deferred_import);
            }
            if (node.namedBindings?.kind === SyntaxKind.NamedImports) {
                return grammarErrorOnNode(node, Diagnostics.Named_imports_are_not_allowed_in_a_deferred_import);
            }
            if (moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.Preserve) {
                return grammarErrorOnNode(node, Diagnostics.Deferred_imports_are_only_supported_when_the_module_flag_is_set_to_esnext_or_preserve);
            }
        }
        return false;
    }

    function checkGrammarNamedImportsOrExports(namedBindings: NamedImportsOrExports): boolean {
        return !!forEach<ImportSpecifier | ExportSpecifier, boolean>(namedBindings.elements, specifier => {
            if (specifier.isTypeOnly) {
                return grammarErrorOnFirstToken(
                    specifier,
                    specifier.kind === SyntaxKind.ImportSpecifier
                        ? Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement
                        : Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement,
                );
            }
        });
    }

    function checkGrammarImportCallExpression(node: ImportCall): boolean {
        if (compilerOptions.verbatimModuleSyntax && moduleKind === ModuleKind.CommonJS) {
            return grammarErrorOnNode(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
        }

        if (node.expression.kind === SyntaxKind.MetaProperty) {
            if (moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.Preserve) {
                return grammarErrorOnNode(node, Diagnostics.Deferred_imports_are_only_supported_when_the_module_flag_is_set_to_esnext_or_preserve);
            }
        }
        else if (moduleKind === ModuleKind.ES2015) {
            return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_node18_node20_or_nodenext);
        }

        if (node.typeArguments) {
            return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments);
        }

        const nodeArguments = node.arguments;
        if (!(ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext) && moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.Preserve) {
            // We are allowed trailing comma after proposal-import-assertions.
            checkGrammarForDisallowedTrailingComma(nodeArguments);

            if (nodeArguments.length > 1) {
                const importAttributesArgument = nodeArguments[1];
                return grammarErrorOnNode(importAttributesArgument, Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_node18_node20_nodenext_or_preserve);
            }
        }

        if (nodeArguments.length === 0 || nodeArguments.length > 2) {
            return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments);
        }

        // see: parseArgumentOrArrayLiteralElement...we use this function which parse arguments of callExpression to parse specifier for dynamic import.
        // parseArgumentOrArrayLiteralElement allows spread element to be in an argument list which is not allowed as specifier in dynamic import.
        const spreadElement = find(nodeArguments, isSpreadElement);
        if (spreadElement) {
            return grammarErrorOnNode(spreadElement, Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element);
        }
        return false;
    }

    function findMatchingTypeReferenceOrTypeAliasReference(source: Type, unionTarget: UnionOrIntersectionType) {
        const sourceObjectFlags = getObjectFlags(source);
        if (sourceObjectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous) && unionTarget.flags & TypeFlags.Union) {
            return find(unionTarget.types, target => {
                if (target.flags & TypeFlags.Object) {
                    const overlapObjFlags = sourceObjectFlags & getObjectFlags(target);
                    if (overlapObjFlags & ObjectFlags.Reference) {
                        return (source as TypeReference).target === (target as TypeReference).target;
                    }
                    if (overlapObjFlags & ObjectFlags.Anonymous) {
                        return !!(source as AnonymousType).aliasSymbol && (source as AnonymousType).aliasSymbol === (target as AnonymousType).aliasSymbol;
                    }
                }
                return false;
            });
        }
    }

    function findBestTypeForObjectLiteral(source: Type, unionTarget: UnionOrIntersectionType) {
        if (getObjectFlags(source) & ObjectFlags.ObjectLiteral && someType(unionTarget, isArrayLikeType)) {
            return find(unionTarget.types, t => !isArrayLikeType(t));
        }
    }

    function findBestTypeForInvokable(source: Type, unionTarget: UnionOrIntersectionType) {
        let signatureKind = SignatureKind.Call;
        const hasSignatures = getSignaturesOfType(source, signatureKind).length > 0 ||
            (signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0);
        if (hasSignatures) {
            return find(unionTarget.types, t => getSignaturesOfType(t, signatureKind).length > 0);
        }
    }

    function findMostOverlappyType(source: Type, unionTarget: UnionOrIntersectionType) {
        let bestMatch: Type | undefined;
        if (!(source.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive))) {
            let matchingCount = 0;
            for (const target of unionTarget.types) {
                if (!(target.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive))) {
                    const overlap = getIntersectionType([getIndexType(source), getIndexType(target)]);
                    if (overlap.flags & TypeFlags.Index) {
                        // perfect overlap of keys
                        return target;
                    }
                    else if (isUnitType(overlap) || overlap.flags & TypeFlags.Union) {
                        // We only want to account for literal types otherwise.
                        // If we have a union of index types, it seems likely that we
                        // needed to elaborate between two generic mapped types anyway.
                        const len = overlap.flags & TypeFlags.Union ? countWhere((overlap as UnionType).types, isUnitType) : 1;
                        if (len >= matchingCount) {
                            bestMatch = target;
                            matchingCount = len;
                        }
                    }
                }
            }
        }
        return bestMatch;
    }

    function filterPrimitivesIfContainsNonPrimitive(type: UnionType) {
        if (maybeTypeOfKind(type, TypeFlags.NonPrimitive)) {
            const result = filterType(type, t => !(t.flags & TypeFlags.Primitive));
            if (!(result.flags & TypeFlags.Never)) {
                return result;
            }
        }
        return type;
    }

    // Keep this up-to-date with the same logic within `getApparentTypeOfContextualType`, since they should behave similarly
    function findMatchingDiscriminantType(source: Type, target: Type, isRelatedTo: (source: Type, target: Type) => Ternary) {
        if (target.flags & TypeFlags.Union && source.flags & (TypeFlags.Intersection | TypeFlags.Object)) {
            const match = getMatchingUnionConstituentForType(target as UnionType, source);
            if (match) {
                return match;
            }
            const sourceProperties = getPropertiesOfType(source);
            if (sourceProperties) {
                const sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
                if (sourcePropertiesFiltered) {
                    const discriminated = discriminateTypeByDiscriminableItems(target as UnionType, map(sourcePropertiesFiltered, p => ([() => getTypeOfSymbol(p), p.escapedName] as [() => Type, __String])), isRelatedTo);
                    if (discriminated !== target) {
                        return discriminated;
                    }
                }
            }
        }
        return undefined;
    }

    function getEffectivePropertyNameForPropertyNameNode(node: PropertyName) {
        const name = getPropertyNameForPropertyNameNode(node);
        return name ? name :
            isComputedPropertyName(node) ? tryGetNameFromType(getTypeOfExpression(node.expression)) : undefined;
    }

    function getCombinedModifierFlagsCached(node: Declaration) {
        // we hold onto the last node and result to speed up repeated lookups against the same node.
        if (lastGetCombinedModifierFlagsNode === node) {
            return lastGetCombinedModifierFlagsResult;
        }

        lastGetCombinedModifierFlagsNode = node;
        lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node);
        return lastGetCombinedModifierFlagsResult;
    }

    function getCombinedNodeFlagsCached(node: Node) {
        // we hold onto the last node and result to speed up repeated lookups against the same node.
        if (lastGetCombinedNodeFlagsNode === node) {
            return lastGetCombinedNodeFlagsResult;
        }
        lastGetCombinedNodeFlagsNode = node;
        lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node);
        return lastGetCombinedNodeFlagsResult;
    }

    function isVarConstLike(node: VariableDeclaration | VariableDeclarationList) {
        const blockScopeKind = getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped;
        return blockScopeKind === NodeFlags.Const ||
            blockScopeKind === NodeFlags.Using ||
            blockScopeKind === NodeFlags.AwaitUsing;
    }

    function getJSXRuntimeImportSpecifier(file: SourceFile | undefined, specifierText: string) {
        // Synthesized JSX import is either first or after tslib
        const jsxImportIndex = compilerOptions.importHelpers ? 1 : 0;
        const specifier = file?.imports[jsxImportIndex];
        if (specifier) {
            Debug.assert(nodeIsSynthesized(specifier) && specifier.text === specifierText, `Expected sourceFile.imports[${jsxImportIndex}] to be the synthesized JSX runtime import`);
        }
        return specifier;
    }

    function getImportHelpersImportSpecifier(file: SourceFile) {
        Debug.assert(compilerOptions.importHelpers, "Expected importHelpers to be enabled");
        const specifier = file.imports[0];
        Debug.assert(specifier && nodeIsSynthesized(specifier) && specifier.text === "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`);
        return specifier;
    }
}

function isNotAccessor(declaration: Declaration): boolean {
    // Accessors check for their own matching duplicates, and in contexts where they are valid, there are already duplicate identifier checks
    return !isAccessor(declaration);
}

function isNotOverload(declaration: Declaration): boolean {
    return (declaration.kind !== SyntaxKind.FunctionDeclaration && declaration.kind !== SyntaxKind.MethodDeclaration) ||
        !!(declaration as FunctionDeclaration).body;
}

/** Like 'isDeclarationName', but returns true for LHS of `import { x as y }` or `export { x as y }`. */
function isDeclarationNameOrImportPropertyName(name: Node): boolean {
    switch (name.parent.kind) {
        case SyntaxKind.ImportSpecifier:
        case SyntaxKind.ExportSpecifier:
            return isIdentifier(name) || name.kind === SyntaxKind.StringLiteral;
        default:
            return isDeclarationName(name);
    }
}

namespace JsxNames {
    export const JSX = "JSX" as __String;
    export const IntrinsicElements = "IntrinsicElements" as __String;
    export const ElementClass = "ElementClass" as __String;
    export const ElementAttributesPropertyNameContainer = "ElementAttributesProperty" as __String; // TODO: Deprecate and remove support
    export const ElementChildrenAttributeNameContainer = "ElementChildrenAttribute" as __String;
    export const Element = "Element" as __String;
    export const ElementType = "ElementType" as __String;
    export const IntrinsicAttributes = "IntrinsicAttributes" as __String;
    export const IntrinsicClassAttributes = "IntrinsicClassAttributes" as __String;
    export const LibraryManagedAttributes = "LibraryManagedAttributes" as __String;
}

namespace ReactNames {
    export const Fragment = "Fragment" as __String;
}

function getIterationTypesKeyFromIterationTypeKind(typeKind: IterationTypeKind) {
    switch (typeKind) {
        case IterationTypeKind.Yield:
            return "yieldType";
        case IterationTypeKind.Return:
            return "returnType";
        case IterationTypeKind.Next:
            return "nextType";
    }
}

/** @internal */
export function signatureHasRestParameter(s: Signature): boolean {
    return !!(s.flags & SignatureFlags.HasRestParameter);
}

function signatureHasLiteralTypes(s: Signature) {
    return !!(s.flags & SignatureFlags.HasLiteralTypes);
}

function createBasicNodeBuilderModuleSpecifierResolutionHost(host: TypeCheckerHost): ModuleSpecifierResolutionHost {
    return {
        getCommonSourceDirectory: !!(host as Program).getCommonSourceDirectory ? () => (host as Program).getCommonSourceDirectory() : () => "",
        getCurrentDirectory: () => host.getCurrentDirectory(),
        getSymlinkCache: maybeBind(host, host.getSymlinkCache),
        getPackageJsonInfoCache: () => host.getPackageJsonInfoCache?.(),
        useCaseSensitiveFileNames: () => host.useCaseSensitiveFileNames(),
        redirectTargetsMap: host.redirectTargetsMap,
        getRedirectFromSourceFile: fileName => host.getRedirectFromSourceFile(fileName),
        isSourceOfProjectReferenceRedirect: fileName => host.isSourceOfProjectReferenceRedirect(fileName),
        fileExists: fileName => host.fileExists(fileName),
        getFileIncludeReasons: () => host.getFileIncludeReasons(),
        readFile: host.readFile ? (fileName => host.readFile!(fileName)) : undefined,
        getDefaultResolutionModeForFile: file => host.getDefaultResolutionModeForFile(file),
        getModeForResolutionAtIndex: (file, index) => host.getModeForResolutionAtIndex(file, index),
        getGlobalTypingsCacheLocation: maybeBind(host, host.getGlobalTypingsCacheLocation),
    };
}

interface NodeBuilderContext extends SyntacticTypeNodeBuilderContext {
    enclosingDeclaration: Node | undefined;
    /**
     * `enclosingFile` is generated from the initial `enclosingDeclaration` and
     * is used to ensure text ranges for generated nodes are not set based on nodes from outside
     * the original input's containing file. Checking the `enclosingDeclaration` at the time of
     * `setTextRange` is not sufficient, as the `enclosingDeclaration` is modified by the node builder
     * as it decends into some types as a shortcut to making certain scopes visible, and may be modified
     * into a declaration in a different file from the original input `enclosingDeclaration`!
     */
    enclosingFile: SourceFile | undefined;
    flags: NodeBuilderFlags;
    internalFlags: InternalNodeBuilderFlags;
    tracker: SymbolTrackerImpl;
    /* Maximum depth we're allowed to expand names. */
    readonly maxExpansionDepth: number;
    /* Maximum length before we truncate the output. */
    readonly maxTruncationLength: number;

    // State
    encounteredError: boolean;
    reportedDiagnostic: boolean;
    trackedSymbols: TrackedSymbol[] | undefined;
    visitedTypes: Set<number> | undefined;
    symbolDepth: Map<string, number> | undefined;
    inferTypeParameters: TypeParameter[] | undefined;
    approximateLength: number;
    truncating: boolean;
    mustCreateTypeParameterSymbolList: boolean;
    typeParameterSymbolList: Set<number> | undefined;
    mustCreateTypeParametersNamesLookups: boolean;
    typeParameterNames: Map<TypeId, Identifier> | undefined;
    typeParameterNamesByText: Set<string> | undefined;
    typeParameterNamesByTextNextNameCount: Map<string, number> | undefined;
    usedSymbolNames: Set<string> | undefined;
    remappedSymbolNames: Map<SymbolId, string> | undefined;
    remappedSymbolReferences: Map<SymbolId, Symbol> | undefined;
    enclosingSymbolTypes: Map<SymbolId, Type>;
    reverseMappedStack: ReverseMappedSymbol[] | undefined;
    bundled: boolean;
    mapper: TypeMapper | undefined;
    /* How many levels of nested names we have expanded so far. */
    depth: number;
    suppressReportInferenceFallback: boolean;
    typeStack: number[];

    // Output
    out: WriterContextOut;
}

class SymbolTrackerImpl implements SymbolTracker {
    moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined;
    context: NodeBuilderContext;

    readonly inner: SymbolTracker | undefined = undefined;
    readonly canTrackSymbol: boolean;
    disableTrackSymbol = false;

    constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) {
        while (tracker instanceof SymbolTrackerImpl) {
            tracker = tracker.inner;
        }

        this.inner = tracker;
        this.moduleResolverHost = moduleResolverHost;
        this.context = context;
        this.canTrackSymbol = !!this.inner?.trackSymbol;
    }

    trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean {
        if (this.inner?.trackSymbol && !this.disableTrackSymbol) {
            if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) {
                this.onDiagnosticReported();
                return true;
            }
            // Skip recording type parameters as they dont contribute to late painted statements
            if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]);
        }
        return false;
    }

    reportInaccessibleThisError(): void {
        if (this.inner?.reportInaccessibleThisError) {
            this.onDiagnosticReported();
            this.inner.reportInaccessibleThisError();
        }
    }

    reportPrivateInBaseOfClassExpression(propertyName: string): void {
        if (this.inner?.reportPrivateInBaseOfClassExpression) {
            this.onDiagnosticReported();
            this.inner.reportPrivateInBaseOfClassExpression(propertyName);
        }
    }

    reportInaccessibleUniqueSymbolError(): void {
        if (this.inner?.reportInaccessibleUniqueSymbolError) {
            this.onDiagnosticReported();
            this.inner.reportInaccessibleUniqueSymbolError();
        }
    }

    reportCyclicStructureError(): void {
        if (this.inner?.reportCyclicStructureError) {
            this.onDiagnosticReported();
            this.inner.reportCyclicStructureError();
        }
    }

    reportLikelyUnsafeImportRequiredError(specifier: string): void {
        if (this.inner?.reportLikelyUnsafeImportRequiredError) {
            this.onDiagnosticReported();
            this.inner.reportLikelyUnsafeImportRequiredError(specifier);
        }
    }

    reportTruncationError(): void {
        if (this.inner?.reportTruncationError) {
            this.onDiagnosticReported();
            this.inner.reportTruncationError();
        }
    }

    reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void {
        if (this.inner?.reportNonlocalAugmentation) {
            this.onDiagnosticReported();
            this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);
        }
    }

    reportNonSerializableProperty(propertyName: string): void {
        if (this.inner?.reportNonSerializableProperty) {
            this.onDiagnosticReported();
            this.inner.reportNonSerializableProperty(propertyName);
        }
    }

    private onDiagnosticReported() {
        this.context.reportedDiagnostic = true;
    }

    reportInferenceFallback(node: Node): void {
        if (this.inner?.reportInferenceFallback && !this.context.suppressReportInferenceFallback) {
            this.onDiagnosticReported();
            this.inner.reportInferenceFallback(node);
        }
    }

    pushErrorFallbackNode(node: Declaration | undefined): void {
        return this.inner?.pushErrorFallbackNode?.(node);
    }

    popErrorFallbackNode(): void {
        return this.inner?.popErrorFallbackNode?.();
    }
}
