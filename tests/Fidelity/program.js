if (!String.prototype.trim) {
    String.prototype.trim = function () {
        return this.replace(/^\s+|\s+$/g, '');
    };
}

if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement, fromIndex) {
        "use strict";
        if (this == null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
            return -1;
        }
        var n = 0;
        if (arguments.length > 0) {
            n = Number(arguments[1]);
            if (n != n) {
                n = 0;
            } else if (n != 0 && n != Infinity && n != -Infinity) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }
        if (n >= len) {
            return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }
        return -1;
    };
}

if (!Array.prototype.filter) {
    Array.prototype.filter = function (fun, thisp) {
        "use strict";

        if (this == null)
            throw new TypeError();

        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun != "function")
            throw new TypeError();

        var res = [];
        for (var i = 0; i < len; i++) {
            if (i in t) {
                var val = t[i];
                if (fun.call(thisp, val, i, t))
                    res.push(val);
            }
        }

        return res;
    };
}

if (!Array.prototype.map) {
    Array.prototype.map = function (callback, thisArg) {
        var T = undefined, A, k;

        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }

        var O = Object(this);

        var len = O.length >>> 0;

        if ({}.toString.call(callback) != "[object Function]") {
            throw new TypeError(callback + " is not a function");
        }

        if (thisArg) {
            T = thisArg;
        }

        A = new Array(len);

        k = 0;

        while (k < len) {
            var kValue, mappedValue;

            if (k in O) {
                kValue = O[k];

                mappedValue = callback.call(T, kValue, k, O);

                A[k] = mappedValue;
            }

            k++;
        }

        return A;
    };
}

if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(accumulator) {
        if (this === null || this === undefined)
            throw new TypeError("Object is null or undefined");
        var i = 0, l = this.length >> 0, curr;

        if (typeof accumulator !== "function")
            throw new TypeError("First argument is not callable");

        if (arguments.length < 2) {
            if (l === 0)
                throw new TypeError("Array length is 0 and no second argument");
            curr = this[0];
            i = 1;
        } else
            curr = arguments[1];

        while (i < l) {
            if (i in this)
                curr = accumulator.call(undefined, curr, this[i], i, this);
            ++i;
        }

        return curr;
    };
}

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;

        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }

        var O = Object(this);

        var len = O.length >>> 0;

        if ({}.toString.call(callback) != "[object Function]") {
            throw new TypeError(callback + " is not a function");
        }

        if (thisArg) {
            T = thisArg;
        } else {
            T = undefined;
        }

        k = 0;

        while (k < len) {
            var kValue;

            if (k in O) {
                kValue = O[k];

                callback.call(T, kValue, k, O);
            }

            k++;
        }
    };
}

if (!Date.now) {
    Date.now = function () {
        return (new Date()).getTime();
    };
}

if (!Array.prototype.some) {
    Array.prototype.some = function (fun) {
        "use strict";

        if (this == null)
            throw new TypeError();

        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun != "function")
            throw new TypeError();

        var thisp = arguments[1];
        for (var i = 0; i < len; i++) {
            var idx = i.toString();
            if (idx in t && fun.call(thisp, t[i], i, t))
                return true;
        }

        return false;
    };
}
var TypeScript;
(function (TypeScript) {
    TypeScript.DiagnosticCode = {
        error_TS_0_1: "error TS{0}: {1}",
        warning_TS_0_1: "warning TS{0}: {1}",
        Unrecognized_escape_sequence: "Unrecognized escape sequence.",
        Unexpected_character_0: "Unexpected character {0}.",
        Missing_close_quote_character: "Missing close quote character.",
        Identifier_expected: "Identifier expected.",
        _0_keyword_expected: "'{0}' keyword expected.",
        _0_expected: "'{0}' expected.",
        Identifier_expected_0_is_a_keyword: "Identifier expected; '{0}' is a keyword.",
        Automatic_semicolon_insertion_not_allowed: "Automatic semicolon insertion not allowed.",
        Unexpected_token_0_expected: "Unexpected token; '{0}' expected.",
        Trailing_comma_not_allowed: "Trailing comma not allowed.",
        AsteriskSlash_expected: "'*/' expected.",
        public_or_private_modifier_must_precede_static: "'public' or 'private' modifier must precede 'static'.",
        Unexpected_token: "Unexpected token.",
        Catch_clause_parameter_cannot_have_a_type_annotation: "Catch clause parameter cannot have a type annotation.",
        A_rest_parameter_must_be_last_in_a_parameter_list: "A rest parameter must be last in a parameter list.",
        Parameter_cannot_have_question_mark_and_initializer: "Parameter cannot have question mark and initializer.",
        A_required_parameter_cannot_follow_an_optional_parameter: "A required parameter cannot follow an optional parameter.",
        Index_signatures_cannot_have_rest_parameters: "Index signatures cannot have rest parameters.",
        Index_signature_parameter_cannot_have_accessibility_modifiers: "Index signature parameter cannot have accessibility modifiers.",
        Index_signature_parameter_cannot_have_a_question_mark: "Index signature parameter cannot have a question mark.",
        Index_signature_parameter_cannot_have_an_initializer: "Index signature parameter cannot have an initializer.",
        Index_signature_must_have_a_type_annotation: "Index signature must have a type annotation.",
        Index_signature_parameter_must_have_a_type_annotation: "Index signature parameter must have a type annotation.",
        Index_signature_parameter_type_must_be_string_or_number: "Index signature parameter type must be 'string' or 'number'.",
        extends_clause_already_seen: "'extends' clause already seen.",
        extends_clause_must_precede_implements_clause: "'extends' clause must precede 'implements' clause.",
        Classes_can_only_extend_a_single_class: "Classes can only extend a single class.",
        implements_clause_already_seen: "'implements' clause already seen.",
        Accessibility_modifier_already_seen: "Accessibility modifier already seen.",
        _0_modifier_must_precede_1_modifier: "'{0}' modifier must precede '{1}' modifier.",
        _0_modifier_already_seen: "'{0}' modifier already seen.",
        _0_modifier_cannot_appear_on_a_class_element: "'{0}' modifier cannot appear on a class element.",
        Interface_declaration_cannot_have_implements_clause: "Interface declaration cannot have 'implements' clause.",
        super_invocation_cannot_have_type_arguments: "'super' invocation cannot have type arguments.",
        Only_ambient_modules_can_use_quoted_names: "Only ambient modules can use quoted names.",
        Statements_are_not_allowed_in_ambient_contexts: "Statements are not allowed in ambient contexts.",
        A_function_implementation_cannot_be_declared_in_an_ambient_context: "A function implementation cannot be declared in an ambient context.",
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: "A 'declare' modifier cannot be used in an already ambient context.",
        Initializers_are_not_allowed_in_ambient_contexts: "Initializers are not allowed in ambient contexts.",
        _0_modifier_cannot_appear_on_a_module_element: "'{0}' modifier cannot appear on a module element.",
        A_declare_modifier_cannot_be_used_with_an_interface_declaration: "A 'declare' modifier cannot be used with an interface declaration.",
        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: "A 'declare' modifier is required for a top level declaration in a .d.ts file.",
        A_rest_parameter_cannot_be_optional: "A rest parameter cannot be optional.",
        A_rest_parameter_cannot_have_an_initializer: "A rest parameter cannot have an initializer.",
        set_accessor_must_have_exactly_one_parameter: "'set' accessor must have exactly one parameter.",
        set_accessor_parameter_cannot_be_optional: "'set' accessor parameter cannot be optional.",
        set_accessor_parameter_cannot_have_an_initializer: "'set' accessor parameter cannot have an initializer.",
        set_accessor_cannot_have_rest_parameter: "'set' accessor cannot have rest parameter.",
        get_accessor_cannot_have_parameters: "'get' accessor cannot have parameters.",
        Modifiers_cannot_appear_here: "Modifiers cannot appear here.",
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: "Accessors are only available when targeting ECMAScript 5 and higher.",
        Enum_member_must_have_initializer: "Enum member must have initializer.",
        Export_assignment_cannot_be_used_in_internal_modules: "Export assignment cannot be used in internal modules.",
        Ambient_enum_elements_can_only_have_integer_literal_initializers: "Ambient enum elements can only have integer literal initializers.",
        module_class_interface_enum_import_or_statement: "module, class, interface, enum, import or statement",
        constructor_function_accessor_or_variable: "constructor, function, accessor or variable",
        statement: "statement",
        case_or_default_clause: "case or default clause",
        identifier: "identifier",
        call_construct_index_property_or_function_signature: "call, construct, index, property or function signature",
        expression: "expression",
        type_name: "type name",
        property_or_accessor: "property or accessor",
        parameter: "parameter",
        type: "type",
        type_parameter: "type parameter",
        A_declare_modifier_cannot_be_used_with_an_import_declaration: "A 'declare' modifier cannot be used with an import declaration.",
        Invalid_reference_directive_syntax: "Invalid 'reference' directive syntax.",
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: "Octal literals are not available when targeting ECMAScript 5 and higher.",
        Accessors_are_not_allowed_in_ambient_contexts: "Accessors are not allowed in ambient contexts.",
        _0_modifier_cannot_appear_on_a_constructor_declaration: "'{0}' modifier cannot appear on a constructor declaration.",
        _0_modifier_cannot_appear_on_a_parameter: "'{0}' modifier cannot appear on a parameter.",
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: "Only a single variable declaration is allowed in a 'for...in' statement.",
        Type_parameters_cannot_appear_on_a_constructor_declaration: "Type parameters cannot appear on a constructor declaration.",
        Type_annotation_cannot_appear_on_a_constructor_declaration: "Type annotation cannot appear on a constructor declaration.",
        Type_parameters_cannot_appear_on_an_accessor: "Type parameters cannot appear on an accessor.",
        Type_annotation_cannot_appear_on_a_set_accessor: "Type annotation cannot appear on a 'set' accessor.",
        Index_signature_must_have_exactly_one_parameter: "Index signature must have exactly one parameter.",
        _0_list_cannot_be_empty: "'{0}' list cannot be empty.",
        variable_declaration: "variable declaration",
        type_argument: "type argument",
        Invalid_use_of_0_in_strict_mode: "Invalid use of '{0}' in strict mode.",
        with_statements_are_not_allowed_in_strict_mode: "'with' statements are not allowed in strict mode.",
        delete_cannot_be_called_on_an_identifier_in_strict_mode: "'delete' cannot be called on an identifier in strict mode.",
        Invalid_left_hand_side_in_for_in_statement: "Invalid left-hand side in 'for...in' statement.",
        continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: "'continue' statement can only be used within an enclosing iteration statement.",
        break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: "'break' statement can only be used within an enclosing iteration or switch statement.",
        Jump_target_not_found: "Jump target not found.",
        Jump_target_cannot_cross_function_boundary: "Jump target cannot cross function boundary.",
        return_statement_must_be_contained_within_a_function_body: "'return' statement must be contained within a function body.",
        Expression_expected: "Expression expected.",
        Type_expected: "Type expected.",
        Duplicate_identifier_0: "Duplicate identifier '{0}'.",
        The_name_0_does_not_exist_in_the_current_scope: "The name '{0}' does not exist in the current scope.",
        The_name_0_does_not_refer_to_a_value: "The name '{0}' does not refer to a value.",
        super_can_only_be_used_inside_a_class_instance_method: "'super' can only be used inside a class instance method.",
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: "The left-hand side of an assignment expression must be a variable, property or indexer.",
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
        Value_of_type_0_is_not_callable: "Value of type '{0}' is not callable.",
        Value_of_type_0_is_not_newable: "Value of type '{0}' is not newable.",
        An_index_expression_argument_must_be_string_number_or_any: "An index expression argument must be 'string', 'number', or 'any'.",
        Operator_0_cannot_be_applied_to_types_1_and_2: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
        Type_0_is_not_assignable_to_type_1: "Type '{0}' is not assignable to type '{1}'.",
        Type_0_is_not_assignable_to_type_1_NL_2: "Type '{0}' is not assignable to type '{1}':{NL}{2}",
        Expected_var_class_interface_or_module: "Expected var, class, interface, or module.",
        Getter_0_already_declared: "Getter '{0}' already declared.",
        Setter_0_already_declared: "Setter '{0}' already declared.",
        Exported_class_0_extends_private_class_1: "Exported class '{0}' extends private class '{1}'.",
        Exported_class_0_implements_private_interface_1: "Exported class '{0}' implements private interface '{1}'.",
        Exported_interface_0_extends_private_interface_1: "Exported interface '{0}' extends private interface '{1}'.",
        Exported_class_0_extends_class_from_inaccessible_module_1: "Exported class '{0}' extends class from inaccessible module {1}.",
        Exported_class_0_implements_interface_from_inaccessible_module_1: "Exported class '{0}' implements interface from inaccessible module {1}.",
        Exported_interface_0_extends_interface_from_inaccessible_module_1: "Exported interface '{0}' extends interface from inaccessible module {1}.",
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: "Public static property '{0}' of exported class has or is using private type '{1}'.",
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: "Public property '{0}' of exported class has or is using private type '{1}'.",
        Property_0_of_exported_interface_has_or_is_using_private_type_1: "Property '{0}' of exported interface has or is using private type '{1}'.",
        Exported_variable_0_has_or_is_using_private_type_1: "Exported variable '{0}' has or is using private type '{1}'.",
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: "Public static property '{0}' of exported class is using inaccessible module {1}.",
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: "Public property '{0}' of exported class is using inaccessible module {1}.",
        Property_0_of_exported_interface_is_using_inaccessible_module_1: "Property '{0}' of exported interface is using inaccessible module {1}.",
        Exported_variable_0_is_using_inaccessible_module_1: "Exported variable '{0}' is using inaccessible module {1}.",
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: "Parameter '{0}' of exported function has or is using private type '{1}'.",
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: "Parameter '{0}' of exported function is using inaccessible module {1}.",
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public static property getter from exported class has or is using private type '{0}'.",
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public property getter from exported class has or is using private type '{0}'.",
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of call signature from exported interface has or is using private type '{0}'.",
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of index signature from exported interface has or is using private type '{0}'.",
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public static method from exported class has or is using private type '{0}'.",
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public method from exported class has or is using private type '{0}'.",
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: "Return type of method from exported interface has or is using private type '{0}'.",
        Return_type_of_exported_function_has_or_is_using_private_type_0: "Return type of exported function has or is using private type '{0}'.",
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public static property getter from exported class is using inaccessible module {0}.",
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public property getter from exported class is using inaccessible module {0}.",
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of call signature from exported interface is using inaccessible module {0}.",
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of index signature from exported interface is using inaccessible module {0}.",
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public static method from exported class is using inaccessible module {0}.",
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public method from exported class is using inaccessible module {0}.",
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: "Return type of method from exported interface is using inaccessible module {0}.",
        Return_type_of_exported_function_is_using_inaccessible_module_0: "Return type of exported function is using inaccessible module {0}.",
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: "A parameter list must follow a generic type argument list. '(' expected.",
        Multiple_constructor_implementations_are_not_allowed: "Multiple constructor implementations are not allowed.",
        Cannot_find_external_module_0: "Cannot find external module '{0}'.",
        Module_cannot_be_aliased_to_a_non_module_type: "Module cannot be aliased to a non-module type.",
        A_class_may_only_extend_another_class: "A class may only extend another class.",
        A_class_may_only_implement_another_class_or_interface: "A class may only implement another class or interface.",
        An_interface_may_only_extend_a_class_or_another_interface: "An interface may only extend a class or another interface.",
        Unable_to_resolve_type: "Unable to resolve type.",
        Unable_to_resolve_type_of_0: "Unable to resolve type of '{0}'.",
        Unable_to_resolve_type_parameter_constraint: "Unable to resolve type parameter constraint.",
        Type_parameter_constraint_cannot_be_a_primitive_type: "Type parameter constraint cannot be a primitive type.",
        Supplied_parameters_do_not_match_any_signature_of_call_target: "Supplied parameters do not match any signature of call target.",
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: "Supplied parameters do not match any signature of call target:{NL}{0}",
        Cannot_use_new_with_an_expression_whose_type_lacks_a_signature: "Cannot use 'new' with an expression whose type lacks a signature.",
        Only_a_void_function_can_be_called_with_the_new_keyword: "Only a void function can be called with the 'new' keyword.",
        Could_not_select_overload_for_new_expression: "Could not select overload for 'new' expression.",
        Type_0_does_not_satisfy_the_constraint_1: "Type '{0}' does not satisfy the constraint '{1}'.",
        Could_not_select_overload_for_call_expression: "Could not select overload for 'call' expression.",
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: "Cannot invoke an expression whose type lacks a call signature.",
        Calls_to_super_are_only_valid_inside_a_class: "Calls to 'super' are only valid inside a class.",
        Generic_type_0_requires_1_type_argument_s: "Generic type '{0}' requires {1} type argument(s).",
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
        Could_not_find_enclosing_symbol_for_dotted_name_0: "Could not find enclosing symbol for dotted name '{0}'.",
        Property_0_does_not_exist_on_value_of_type_1: "Property '{0}' does not exist on value of type '{1}'.",
        Cannot_find_name_0: "Cannot find name '{0}'.",
        get_and_set_accessor_must_have_the_same_type: "'get' and 'set' accessor must have the same type.",
        this_cannot_be_referenced_in_current_location: "'this' cannot be referenced in current location.",
        Static_members_cannot_reference_class_type_parameters: "Static members cannot reference class type parameters.",
        Type_0_recursively_references_itself_as_a_base_type: "Type '{0}' recursively references itself as a base type.",
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.",
        super_can_only_be_referenced_in_a_derived_class: "'super' can only be referenced in a derived class.",
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
        Constructors_for_derived_classes_must_contain_a_super_call: "Constructors for derived classes must contain a 'super' call.",
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: "Super calls are not permitted outside constructors or in nested functions inside constructors.",
        _0_1_is_inaccessible: "'{0}.{1}' is inaccessible.",
        this_cannot_be_referenced_in_a_module_body: "'this' cannot be referenced in a module body.",
        Invalid_expression_types_not_known_to_support_the_addition_operator: "Invalid '+' expression - types not known to support the addition operator.",
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: "An arithmetic operand must be of type 'any', 'number' or an enum type.",
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: "Variable declarations of a 'for' statement cannot use a type annotation.",
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: "Variable declarations of a 'for' statement must be of types 'string' or 'any'.",
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.",
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.",
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.",
        Setters_cannot_return_a_value: "Setters cannot return a value.",
        Tried_to_query_type_of_uninitialized_module_0: "Tried to query type of uninitialized module '{0}'.",
        Tried_to_set_variable_type_to_uninitialized_module_type_0: "Tried to set variable type to uninitialized module type '{0}'.",
        Type_0_is_not_generic: "Type '{0}' is not generic.",
        Getters_must_return_a_value: "Getters must return a value.",
        Getter_and_setter_accessors_do_not_agree_in_visibility: "Getter and setter accessors do not agree in visibility.",
        Invalid_left_hand_side_of_assignment_expression: "Invalid left-hand side of assignment expression.",
        Function_declared_a_non_void_return_type_but_has_no_return_expression: "Function declared a non-void return type, but has no return expression.",
        Cannot_resolve_return_type_reference: "Cannot resolve return type reference.",
        Constructors_cannot_have_a_return_type_of_void: "Constructors cannot have a return type of 'void'.",
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.",
        All_symbols_within_a_with_block_will_be_resolved_to_any: "All symbols within a with block will be resolved to 'any'.",
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: "Import declarations in an internal module cannot reference an external module.",
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}",
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: "The operand of an increment or decrement operator must be a variable, property or indexer.",
        this_cannot_be_referenced_in_a_static_property_initializer: "'this' cannot be referenced in a static property initializer.",
        Class_0_cannot_extend_class_1_NL_2: "Class '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_class_1_NL_2: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_interface_1_NL_2: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
        Overload_signature_is_not_compatible_with_function_definition: "Overload signature is not compatible with function definition.",
        Overload_signature_is_not_compatible_with_function_definition_NL_0: "Overload signature is not compatible with function definition:{NL}{0}",
        Overload_signatures_must_all_be_public_or_private: "Overload signatures must all be public or private.",
        Overload_signatures_must_all_be_exported_or_not_exported: "Overload signatures must all be exported or not exported.",
        Overload_signatures_must_all_be_ambient_or_non_ambient: "Overload signatures must all be ambient or non-ambient.",
        Overload_signatures_must_all_be_optional_or_required: "Overload signatures must all be optional or required.",
        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: "Specialized overload signature is not assignable to any non-specialized signature.",
        this_cannot_be_referenced_in_constructor_arguments: "'this' cannot be referenced in constructor arguments.",
        Instance_member_cannot_be_accessed_off_a_class: "Instance member cannot be accessed off a class.",
        Untyped_function_calls_may_not_accept_type_arguments: "Untyped function calls may not accept type arguments.",
        Non_generic_functions_may_not_accept_type_arguments: "Non-generic functions may not accept type arguments.",
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: "A generic type may not reference itself with a wrapped form of its own type parameters.",
        A_rest_parameter_must_be_of_an_array_type: "A rest parameter must be of an array type.",
        Overload_signature_implementation_cannot_use_specialized_type: "Overload signature implementation cannot use specialized type.",
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: "Export assignments may only be used at the top-level of external modules.",
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: "Only public methods of the base class are accessible via the 'super' keyword.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1_NL_2: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0: "All numerically named properties must be assignable to numeric indexer type '{0}'.",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0_NL_1: "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}",
        All_named_properties_must_be_assignable_to_string_indexer_type_0: "All named properties must be assignable to string indexer type '{0}'.",
        All_named_properties_must_be_assignable_to_string_indexer_type_0_NL_1: "All named properties must be assignable to string indexer type '{0}':{NL}{1}",
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: "A parameter initializer is only allowed in a function or constructor implementation.",
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: "Function expression declared a non-void return type, but has no return expression.",
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Module_0_has_no_exported_member_1: "Module '{0}' has no exported member '{1}'.",
        Unable_to_resolve_module_reference_0: "Unable to resolve module reference '{0}'.",
        Could_not_find_module_0_in_module_1: "Could not find module '{0}' in module '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.",
        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_1: "Type name '{0}' in extends clause does not reference constructor function for '{1}'.",
        Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1: "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.",
        Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2: "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.",
        Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}",
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.",
        Ambient_external_module_declaration_cannot_be_reopened: "Ambient external module declaration cannot be reopened.",
        All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported: "All declarations of merged declaration '{0}' must be exported or not exported.",
        super_cannot_be_referenced_in_constructor_arguments: "'super' cannot be referenced in constructor arguments.",
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: "Return type of constructor signature must be assignable to the instance type of the class.",
        Ambient_external_module_declaration_must_be_defined_in_global_context: "Ambient external module declaration must be defined in global context.",
        Ambient_external_module_declaration_cannot_specify_relative_module_name: "Ambient external module declaration cannot specify relative module name.",
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.",
        No_best_common_type_exists_among_return_expressions: "No best common type exists among return expressions.",
        Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set: "Import declaration cannot refer to external module reference when --noResolve option is set.",
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.",
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.",
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.",
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: "Expression resolves to '_super' that compiler uses to capture base class reference.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_function_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported function has or is using private type '{1}'.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_exported_function_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported function is using inaccessible module {1}.",
        TypeParameter_0_of_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported class has or is using private type '{1}'.",
        TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported class is using inaccessible module {1}.",
        TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported interface is using inaccessible module {1}.",
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.",
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.",
        No_best_common_type_exists_between_0_and_1: "No best common type exists between '{0}' and '{1}'.",
        No_best_common_type_exists_between_0_1_and_2: "No best common type exists between '{0}', '{1}', and '{2}'.",
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.",
        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.",
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.",
        Parameter_0_cannot_be_referenced_in_its_initializer: "Parameter '{0}' cannot be referenced in its initializer.",
        Duplicate_string_index_signature: "Duplicate string index signature.",
        Duplicate_number_index_signature: "Duplicate number index signature.",
        All_declarations_of_an_interface_must_have_identical_type_parameters: "All declarations of an interface must have identical type parameters.",
        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.",
        Neither_type_0_nor_type_1_is_assignable_to_the_other: "Neither type '{0}' nor type '{1}' is assignable to the other.",
        Neither_type_0_nor_type_1_is_assignable_to_the_other_NL_2: "Neither type '{0}' nor type '{1}' is assignable to the other:{NL}{2}",
        Duplicate_function_implementation: "Duplicate function implementation.",
        Function_implementation_expected: "Function implementation expected.",
        Function_overload_name_must_be_0: "Function overload name must be '{0}'.",
        Constructor_implementation_expected: "Constructor implementation expected.",
        Class_name_cannot_be_0: "Class name cannot be '{0}'.",
        Interface_name_cannot_be_0: "Interface name cannot be '{0}'.",
        Enum_name_cannot_be_0: "Enum name cannot be '{0}'.",
        A_module_cannot_have_multiple_export_assignments: "A module cannot have multiple export assignments.",
        Export_assignment_not_allowed_in_module_with_exported_element: "Export assignment not allowed in module with exported element.",
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: "A parameter property is only allowed in a constructor implementation.",
        Function_overload_must_be_static: "Function overload must be static.",
        Function_overload_must_not_be_static: "Function overload must not be static.",
        Type_0_is_missing_property_1_from_type_2: "Type '{0}' is missing property '{1}' from type '{2}'.",
        Types_of_property_0_of_types_1_and_2_are_incompatible: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_property_2_as_private: "Types '{0}' and '{1}' define property '{2}' as private.",
        Call_signatures_of_types_0_and_1_are_incompatible: "Call signatures of types '{0}' and '{1}' are incompatible.",
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_call_signature_but_type_1_lacks_one: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
        Construct_signatures_of_types_0_and_1_are_incompatible: "Construct signatures of types '{0}' and '{1}' are incompatible.",
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
        Index_signatures_of_types_0_and_1_are_incompatible: "Index signatures of types '{0}' and '{1}' are incompatible.",
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Call_signature_expects_0_or_fewer_parameters: "Call signature expects {0} or fewer parameters.",
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: "Could not apply type '{0}' to argument {1} which is of type '{2}'.",
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
        Type_reference_cannot_refer_to_container_0: "Type reference cannot refer to container '{0}'.",
        Type_reference_must_refer_to_type: "Type reference must refer to type.",
        In_enums_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_the_first_enum_element: "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.",
        _0_overload_s: " (+ {0} overload(s))",
        Variable_declaration_cannot_have_the_same_name_as_an_import_declaration: "Variable declaration cannot have the same name as an import declaration.",
        Signature_expected_0_type_arguments_got_1_instead: "Signature expected {0} type arguments, got {1} instead.",
        Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2: "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_do_not_refer_to_same_named_type: "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}",
        Named_properties_0_of_types_1_and_2_are_not_identical: "Named properties '{0}' of types '{1}' and '{2}' are not identical.",
        Types_of_string_indexer_of_types_0_and_1_are_not_identical: "Types of string indexer of types '{0}' and '{1}' are not identical.",
        Types_of_number_indexer_of_types_0_and_1_are_not_identical: "Types of number indexer of types '{0}' and '{1}' are not identical.",
        Type_of_number_indexer_in_type_0_is_not_assignable_to_string_indexer_type_in_type_1_NL_2: "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}",
        Type_of_property_0_in_type_1_is_not_assignable_to_string_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}",
        Type_of_property_0_in_type_1_is_not_assignable_to_number_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}",
        Static_property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Static_property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_static_property_2_as_private: "Types '{0}' and '{1}' define static property '{2}' as private.",
        Current_host_does_not_support_0_option: "Current host does not support '{0}' option.",
        ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2: "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'",
        Argument_for_0_option_must_be_1_or_2: "Argument for '{0}' option must be '{1}' or '{2}'",
        Could_not_find_file_0: "Could not find file: '{0}'.",
        A_file_cannot_have_a_reference_to_itself: "A file cannot have a reference to itself.",
        Cannot_resolve_referenced_file_0: "Cannot resolve referenced file: '{0}'.",
        Cannot_find_the_common_subdirectory_path_for_the_input_files: "Cannot find the common subdirectory path for the input files.",
        Emit_Error_0: "Emit Error: {0}.",
        Cannot_read_file_0_1: "Cannot read file '{0}': {1}",
        Unsupported_file_encoding: "Unsupported file encoding.",
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.",
        Unsupported_locale_0: "Unsupported locale: '{0}'.",
        Execution_Failed_NL: "Execution Failed.{NL}",
        Invalid_call_to_up: "Invalid call to 'up'",
        Invalid_call_to_down: "Invalid call to 'down'",
        Base64_value_0_finished_with_a_continuation_bit: "Base64 value '{0}' finished with a continuation bit.",
        Unknown_compiler_option_0: "Unknown compiler option '{0}'",
        Expected_0_arguments_to_message_got_1_instead: "Expected {0} arguments to message, got {1} instead.",
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: "Expected the message '{0}' to have {1} arguments, but it had {2}",
        Could_not_delete_file_0: "Could not delete file '{0}'",
        Could_not_create_directory_0: "Could not create directory '{0}'",
        Error_while_executing_file_0: "Error while executing file '{0}': ",
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: "Cannot compile external modules unless the '--module' flag is provided.",
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option mapRoot cannot be specified without specifying sourcemap option.",
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option sourceRoot cannot be specified without specifying sourcemap option.",
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.",
        Option_0_specified_without_1: "Option '{0}' specified without '{1}'",
        codepage_option_not_supported_on_current_platform: "'codepage' option not supported on current platform.",
        Concatenate_and_emit_output_to_single_file: "Concatenate and emit output to single file.",
        Generates_corresponding_0_file: "Generates corresponding {0} file.",
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: "Specifies the location where debugger should locate map files instead of generated locations.",
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: "Specifies the location where debugger should locate TypeScript files instead of source locations.",
        Watch_input_files: "Watch input files.",
        Redirect_output_structure_to_the_directory: "Redirect output structure to the directory.",
        Do_not_emit_comments_to_output: "Do not emit comments to output.",
        Skip_resolution_and_preprocessing: "Skip resolution and preprocessing.",
        Specify_ECMAScript_target_version_0_default_or_1: "Specify ECMAScript target version: '{0}' (default), or '{1}'",
        Specify_module_code_generation_0_or_1: "Specify module code generation: '{0}' or '{1}'",
        Print_this_message: "Print this message.",
        Print_the_compiler_s_version_0: "Print the compiler's version: {0}",
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: "Allow use of deprecated '{0}' keyword when referencing an external module.",
        Specify_locale_for_errors_and_messages_For_example_0_or_1: "Specify locale for errors and messages. For example '{0}' or '{1}'",
        Syntax_0: "Syntax:   {0}",
        options: "options",
        file1: "file",
        Examples: "Examples:",
        Options: "Options:",
        Insert_command_line_options_and_files_from_a_file: "Insert command line options and files from a file.",
        Version_0: "Version {0}",
        Use_the_0_flag_to_see_options: "Use the '{0}' flag to see options.",
        NL_Recompiling_0: "{NL}Recompiling ({0}):",
        STRING: "STRING",
        KIND: "KIND",
        file2: "FILE",
        VERSION: "VERSION",
        LOCATION: "LOCATION",
        DIRECTORY: "DIRECTORY",
        NUMBER: "NUMBER",
        Specify_the_codepage_to_use_when_opening_source_files: "Specify the codepage to use when opening source files.",
        Additional_locations: "Additional locations:",
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: "This version of the Javascript runtime does not support the '{0}' function.",
        Unknown_rule: "Unknown rule.",
        Invalid_line_number_0: "Invalid line number ({0})",
        Warn_on_expressions_and_declarations_with_an_implied_any_type: "Warn on expressions and declarations with an implied 'any' type.",
        Variable_0_implicitly_has_an_any_type: "Variable '{0}' implicitly has an 'any' type.",
        Parameter_0_of_1_implicitly_has_an_any_type: "Parameter '{0}' of '{1}' implicitly has an 'any' type.",
        Parameter_0_of_function_type_implicitly_has_an_any_type: "Parameter '{0}' of function type implicitly has an 'any' type.",
        Member_0_of_object_type_implicitly_has_an_any_type: "Member '{0}' of object type implicitly has an 'any' type.",
        new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.",
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.",
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: "Parameter '{0}' of lambda function implicitly has an 'any' type.",
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.",
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.",
        Array_Literal_implicitly_has_an_any_type_from_widening: "Array Literal implicitly has an 'any' type from widening.",
        _0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type: "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.",
        Index_signature_of_object_type_implicitly_has_an_any_type: "Index signature of object type implicitly has an 'any' type.",
        Object_literal_s_property_0_implicitly_has_an_any_type_from_widening: "Object literal's property '{0}' implicitly has an 'any' type from widening."
    };
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
        DiagnosticCategory[DiagnosticCategory["NoPrefix"] = 3] = "NoPrefix";
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.diagnosticInformationMap = {
        "error TS{0}: {1}": { "code": 0, "category": 3 /* NoPrefix */ },
        "warning TS{0}: {1}": { "code": 1, "category": 3 /* NoPrefix */ },
        "Unrecognized escape sequence.": { "code": 1000, "category": 1 /* Error */ },
        "Unexpected character {0}.": { "code": 1001, "category": 1 /* Error */ },
        "Missing close quote character.": { "code": 1002, "category": 1 /* Error */ },
        "Identifier expected.": { "code": 1003, "category": 1 /* Error */ },
        "'{0}' keyword expected.": { "code": 1004, "category": 1 /* Error */ },
        "'{0}' expected.": { "code": 1005, "category": 1 /* Error */ },
        "Identifier expected; '{0}' is a keyword.": { "code": 1006, "category": 1 /* Error */ },
        "Automatic semicolon insertion not allowed.": { "code": 1007, "category": 1 /* Error */ },
        "Unexpected token; '{0}' expected.": { "code": 1008, "category": 1 /* Error */ },
        "Trailing comma not allowed.": { "code": 1009, "category": 1 /* Error */ },
        "'*/' expected.": { "code": 1010, "category": 1 /* Error */ },
        "'public' or 'private' modifier must precede 'static'.": { "code": 1011, "category": 1 /* Error */ },
        "Unexpected token.": { "code": 1012, "category": 1 /* Error */ },
        "Catch clause parameter cannot have a type annotation.": { "code": 1013, "category": 1 /* Error */ },
        "A rest parameter must be last in a parameter list.": { "code": 1014, "category": 1 /* Error */ },
        "Parameter cannot have question mark and initializer.": { "code": 1015, "category": 1 /* Error */ },
        "A required parameter cannot follow an optional parameter.": { "code": 1016, "category": 1 /* Error */ },
        "Index signatures cannot have rest parameters.": { "code": 1017, "category": 1 /* Error */ },
        "Index signature parameter cannot have accessibility modifiers.": { "code": 1018, "category": 1 /* Error */ },
        "Index signature parameter cannot have a question mark.": { "code": 1019, "category": 1 /* Error */ },
        "Index signature parameter cannot have an initializer.": { "code": 1020, "category": 1 /* Error */ },
        "Index signature must have a type annotation.": { "code": 1021, "category": 1 /* Error */ },
        "Index signature parameter must have a type annotation.": { "code": 1022, "category": 1 /* Error */ },
        "Index signature parameter type must be 'string' or 'number'.": { "code": 1023, "category": 1 /* Error */ },
        "'extends' clause already seen.": { "code": 1024, "category": 1 /* Error */ },
        "'extends' clause must precede 'implements' clause.": { "code": 1025, "category": 1 /* Error */ },
        "Classes can only extend a single class.": { "code": 1026, "category": 1 /* Error */ },
        "'implements' clause already seen.": { "code": 1027, "category": 1 /* Error */ },
        "Accessibility modifier already seen.": { "code": 1028, "category": 1 /* Error */ },
        "'{0}' modifier must precede '{1}' modifier.": { "code": 1029, "category": 1 /* Error */ },
        "'{0}' modifier already seen.": { "code": 1030, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a class element.": { "code": 1031, "category": 1 /* Error */ },
        "Interface declaration cannot have 'implements' clause.": { "code": 1032, "category": 1 /* Error */ },
        "'super' invocation cannot have type arguments.": { "code": 1034, "category": 1 /* Error */ },
        "Only ambient modules can use quoted names.": { "code": 1035, "category": 1 /* Error */ },
        "Statements are not allowed in ambient contexts.": { "code": 1036, "category": 1 /* Error */ },
        "A function implementation cannot be declared in an ambient context.": { "code": 1037, "category": 1 /* Error */ },
        "A 'declare' modifier cannot be used in an already ambient context.": { "code": 1038, "category": 1 /* Error */ },
        "Initializers are not allowed in ambient contexts.": { "code": 1039, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a module element.": { "code": 1044, "category": 1 /* Error */ },
        "A 'declare' modifier cannot be used with an interface declaration.": { "code": 1045, "category": 1 /* Error */ },
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": { "code": 1046, "category": 1 /* Error */ },
        "A rest parameter cannot be optional.": { "code": 1047, "category": 1 /* Error */ },
        "A rest parameter cannot have an initializer.": { "code": 1048, "category": 1 /* Error */ },
        "'set' accessor must have exactly one parameter.": { "code": 1049, "category": 1 /* Error */ },
        "'set' accessor parameter cannot be optional.": { "code": 1051, "category": 1 /* Error */ },
        "'set' accessor parameter cannot have an initializer.": { "code": 1052, "category": 1 /* Error */ },
        "'set' accessor cannot have rest parameter.": { "code": 1053, "category": 1 /* Error */ },
        "'get' accessor cannot have parameters.": { "code": 1054, "category": 1 /* Error */ },
        "Modifiers cannot appear here.": { "code": 1055, "category": 1 /* Error */ },
        "Accessors are only available when targeting ECMAScript 5 and higher.": { "code": 1056, "category": 1 /* Error */ },
        "Enum member must have initializer.": { "code": 1061, "category": 1 /* Error */ },
        "Export assignment cannot be used in internal modules.": { "code": 1063, "category": 1 /* Error */ },
        "Ambient enum elements can only have integer literal initializers.": { "code": 1066, "category": 1 /* Error */ },
        "module, class, interface, enum, import or statement": { "code": 1067, "category": 3 /* NoPrefix */ },
        "constructor, function, accessor or variable": { "code": 1068, "category": 3 /* NoPrefix */ },
        "statement": { "code": 1069, "category": 3 /* NoPrefix */ },
        "case or default clause": { "code": 1070, "category": 3 /* NoPrefix */ },
        "identifier": { "code": 1071, "category": 3 /* NoPrefix */ },
        "call, construct, index, property or function signature": { "code": 1072, "category": 3 /* NoPrefix */ },
        "expression": { "code": 1073, "category": 3 /* NoPrefix */ },
        "type name": { "code": 1074, "category": 3 /* NoPrefix */ },
        "property or accessor": { "code": 1075, "category": 3 /* NoPrefix */ },
        "parameter": { "code": 1076, "category": 3 /* NoPrefix */ },
        "type": { "code": 1077, "category": 3 /* NoPrefix */ },
        "type parameter": { "code": 1078, "category": 3 /* NoPrefix */ },
        "A 'declare' modifier cannot be used with an import declaration.": { "code": 1079, "category": 1 /* Error */ },
        "Invalid 'reference' directive syntax.": { "code": 1084, "category": 1 /* Error */ },
        "Octal literals are not available when targeting ECMAScript 5 and higher.": { "code": 1085, "category": 1 /* Error */ },
        "Accessors are not allowed in ambient contexts.": { "code": 1086, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a constructor declaration.": { "code": 1089, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a parameter.": { "code": 1090, "category": 1 /* Error */ },
        "Only a single variable declaration is allowed in a 'for...in' statement.": { "code": 1091, "category": 1 /* Error */ },
        "Type parameters cannot appear on a constructor declaration.": { "code": 1092, "category": 1 /* Error */ },
        "Type annotation cannot appear on a constructor declaration.": { "code": 1093, "category": 1 /* Error */ },
        "Type parameters cannot appear on an accessor.": { "code": 1094, "category": 1 /* Error */ },
        "Type annotation cannot appear on a 'set' accessor.": { "code": 1095, "category": 1 /* Error */ },
        "Index signature must have exactly one parameter.": { "code": 1096, "category": 1 /* Error */ },
        "'{0}' list cannot be empty.": { "code": 1097, "category": 1 /* Error */ },
        "variable declaration": { "code": 1098, "category": 3 /* NoPrefix */ },
        "type argument": { "code": 1099, "category": 3 /* NoPrefix */ },
        "Invalid use of '{0}' in strict mode.": { "code": 1100, "category": 1 /* Error */ },
        "'with' statements are not allowed in strict mode.": { "code": 1101, "category": 1 /* Error */ },
        "'delete' cannot be called on an identifier in strict mode.": { "code": 1102, "category": 1 /* Error */ },
        "Invalid left-hand side in 'for...in' statement.": { "code": 1103, "category": 1 /* Error */ },
        "'continue' statement can only be used within an enclosing iteration statement.": { "code": 1104, "category": 1 /* Error */ },
        "'break' statement can only be used within an enclosing iteration or switch statement.": { "code": 1105, "category": 1 /* Error */ },
        "Jump target not found.": { "code": 1106, "category": 1 /* Error */ },
        "Jump target cannot cross function boundary.": { "code": 1107, "category": 1 /* Error */ },
        "'return' statement must be contained within a function body.": { "code": 1108, "category": 1 /* Error */ },
        "Expression expected.": { "code": 1109, "category": 1 /* Error */ },
        "Type expected.": { "code": 1110, "category": 1 /* Error */ },
        "Duplicate identifier '{0}'.": { "code": 2000, "category": 1 /* Error */ },
        "The name '{0}' does not exist in the current scope.": { "code": 2001, "category": 1 /* Error */ },
        "The name '{0}' does not refer to a value.": { "code": 2002, "category": 1 /* Error */ },
        "'super' can only be used inside a class instance method.": { "code": 2003, "category": 1 /* Error */ },
        "The left-hand side of an assignment expression must be a variable, property or indexer.": { "code": 2004, "category": 1 /* Error */ },
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": { "code": 2161, "category": 1 /* Error */ },
        "Value of type '{0}' is not callable.": { "code": 2006, "category": 1 /* Error */ },
        "Value of type '{0}' is not newable.": { "code": 2007, "category": 1 /* Error */ },
        "An index expression argument must be 'string', 'number', or 'any'.": { "code": 2008, "category": 1 /* Error */ },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": { "code": 2009, "category": 1 /* Error */ },
        "Type '{0}' is not assignable to type '{1}'.": { "code": 2011, "category": 1 /* Error */ },
        "Type '{0}' is not assignable to type '{1}':{NL}{2}": { "code": 2012, "category": 1 /* Error */ },
        "Expected var, class, interface, or module.": { "code": 2013, "category": 1 /* Error */ },
        "Getter '{0}' already declared.": { "code": 2015, "category": 1 /* Error */ },
        "Setter '{0}' already declared.": { "code": 2016, "category": 1 /* Error */ },
        "Exported class '{0}' extends private class '{1}'.": { "code": 2018, "category": 1 /* Error */ },
        "Exported class '{0}' implements private interface '{1}'.": { "code": 2019, "category": 1 /* Error */ },
        "Exported interface '{0}' extends private interface '{1}'.": { "code": 2020, "category": 1 /* Error */ },
        "Exported class '{0}' extends class from inaccessible module {1}.": { "code": 2021, "category": 1 /* Error */ },
        "Exported class '{0}' implements interface from inaccessible module {1}.": { "code": 2022, "category": 1 /* Error */ },
        "Exported interface '{0}' extends interface from inaccessible module {1}.": { "code": 2023, "category": 1 /* Error */ },
        "Public static property '{0}' of exported class has or is using private type '{1}'.": { "code": 2024, "category": 1 /* Error */ },
        "Public property '{0}' of exported class has or is using private type '{1}'.": { "code": 2025, "category": 1 /* Error */ },
        "Property '{0}' of exported interface has or is using private type '{1}'.": { "code": 2026, "category": 1 /* Error */ },
        "Exported variable '{0}' has or is using private type '{1}'.": { "code": 2027, "category": 1 /* Error */ },
        "Public static property '{0}' of exported class is using inaccessible module {1}.": { "code": 2028, "category": 1 /* Error */ },
        "Public property '{0}' of exported class is using inaccessible module {1}.": { "code": 2029, "category": 1 /* Error */ },
        "Property '{0}' of exported interface is using inaccessible module {1}.": { "code": 2030, "category": 1 /* Error */ },
        "Exported variable '{0}' is using inaccessible module {1}.": { "code": 2031, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": { "code": 2032, "category": 1 /* Error */ },
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": { "code": 2033, "category": 1 /* Error */ },
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": { "code": 2034, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2035, "category": 1 /* Error */ },
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2036, "category": 1 /* Error */ },
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2037, "category": 1 /* Error */ },
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2038, "category": 1 /* Error */ },
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2039, "category": 1 /* Error */ },
        "Parameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2040, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": { "code": 2041, "category": 1 /* Error */ },
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": { "code": 2042, "category": 1 /* Error */ },
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": { "code": 2043, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2044, "category": 1 /* Error */ },
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2045, "category": 1 /* Error */ },
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2046, "category": 1 /* Error */ },
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2047, "category": 1 /* Error */ },
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2048, "category": 1 /* Error */ },
        "Parameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2049, "category": 1 /* Error */ },
        "Return type of public static property getter from exported class has or is using private type '{0}'.": { "code": 2050, "category": 1 /* Error */ },
        "Return type of public property getter from exported class has or is using private type '{0}'.": { "code": 2051, "category": 1 /* Error */ },
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": { "code": 2052, "category": 1 /* Error */ },
        "Return type of call signature from exported interface has or is using private type '{0}'.": { "code": 2053, "category": 1 /* Error */ },
        "Return type of index signature from exported interface has or is using private type '{0}'.": { "code": 2054, "category": 1 /* Error */ },
        "Return type of public static method from exported class has or is using private type '{0}'.": { "code": 2055, "category": 1 /* Error */ },
        "Return type of public method from exported class has or is using private type '{0}'.": { "code": 2056, "category": 1 /* Error */ },
        "Return type of method from exported interface has or is using private type '{0}'.": { "code": 2057, "category": 1 /* Error */ },
        "Return type of exported function has or is using private type '{0}'.": { "code": 2058, "category": 1 /* Error */ },
        "Return type of public static property getter from exported class is using inaccessible module {0}.": { "code": 2059, "category": 1 /* Error */ },
        "Return type of public property getter from exported class is using inaccessible module {0}.": { "code": 2060, "category": 1 /* Error */ },
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": { "code": 2061, "category": 1 /* Error */ },
        "Return type of call signature from exported interface is using inaccessible module {0}.": { "code": 2062, "category": 1 /* Error */ },
        "Return type of index signature from exported interface is using inaccessible module {0}.": { "code": 2063, "category": 1 /* Error */ },
        "Return type of public static method from exported class is using inaccessible module {0}.": { "code": 2064, "category": 1 /* Error */ },
        "Return type of public method from exported class is using inaccessible module {0}.": { "code": 2065, "category": 1 /* Error */ },
        "Return type of method from exported interface is using inaccessible module {0}.": { "code": 2066, "category": 1 /* Error */ },
        "Return type of exported function is using inaccessible module {0}.": { "code": 2067, "category": 1 /* Error */ },
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": { "code": 2068, "category": 1 /* Error */ },
        "A parameter list must follow a generic type argument list. '(' expected.": { "code": 2069, "category": 1 /* Error */ },
        "Multiple constructor implementations are not allowed.": { "code": 2070, "category": 1 /* Error */ },
        "Cannot find external module '{0}'.": { "code": 2071, "category": 1 /* Error */ },
        "Module cannot be aliased to a non-module type.": { "code": 2072, "category": 1 /* Error */ },
        "A class may only extend another class.": { "code": 2073, "category": 1 /* Error */ },
        "A class may only implement another class or interface.": { "code": 2074, "category": 1 /* Error */ },
        "An interface may only extend a class or another interface.": { "code": 2075, "category": 1 /* Error */ },
        "Unable to resolve type.": { "code": 2077, "category": 1 /* Error */ },
        "Unable to resolve type of '{0}'.": { "code": 2078, "category": 1 /* Error */ },
        "Unable to resolve type parameter constraint.": { "code": 2079, "category": 1 /* Error */ },
        "Type parameter constraint cannot be a primitive type.": { "code": 2080, "category": 1 /* Error */ },
        "Supplied parameters do not match any signature of call target.": { "code": 2081, "category": 1 /* Error */ },
        "Supplied parameters do not match any signature of call target:{NL}{0}": { "code": 2082, "category": 1 /* Error */ },
        "Cannot use 'new' with an expression whose type lacks a signature.": { "code": 2083, "category": 1 /* Error */ },
        "Only a void function can be called with the 'new' keyword.": { "code": 2084, "category": 1 /* Error */ },
        "Could not select overload for 'new' expression.": { "code": 2085, "category": 1 /* Error */ },
        "Type '{0}' does not satisfy the constraint '{1}'.": { "code": 2086, "category": 1 /* Error */ },
        "Could not select overload for 'call' expression.": { "code": 2087, "category": 1 /* Error */ },
        "Cannot invoke an expression whose type lacks a call signature.": { "code": 2088, "category": 1 /* Error */ },
        "Calls to 'super' are only valid inside a class.": { "code": 2089, "category": 1 /* Error */ },
        "Generic type '{0}' requires {1} type argument(s).": { "code": 2090, "category": 1 /* Error */ },
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": { "code": 2092, "category": 1 /* Error */ },
        "Could not find enclosing symbol for dotted name '{0}'.": { "code": 2093, "category": 1 /* Error */ },
        "Property '{0}' does not exist on value of type '{1}'.": { "code": 2094, "category": 1 /* Error */ },
        "Cannot find name '{0}'.": { "code": 2095, "category": 1 /* Error */ },
        "'get' and 'set' accessor must have the same type.": { "code": 2096, "category": 1 /* Error */ },
        "'this' cannot be referenced in current location.": { "code": 2097, "category": 1 /* Error */ },
        "Static members cannot reference class type parameters.": { "code": 2099, "category": 1 /* Error */ },
        "Type '{0}' recursively references itself as a base type.": { "code": 2100, "category": 1 /* Error */ },
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": { "code": 2102, "category": 1 /* Error */ },
        "'super' can only be referenced in a derived class.": { "code": 2103, "category": 1 /* Error */ },
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": { "code": 2104, "category": 1 /* Error */ },
        "Constructors for derived classes must contain a 'super' call.": { "code": 2105, "category": 1 /* Error */ },
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": { "code": 2106, "category": 1 /* Error */ },
        "'{0}.{1}' is inaccessible.": { "code": 2107, "category": 1 /* Error */ },
        "'this' cannot be referenced in a module body.": { "code": 2108, "category": 1 /* Error */ },
        "Invalid '+' expression - types not known to support the addition operator.": { "code": 2111, "category": 1 /* Error */ },
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2112, "category": 1 /* Error */ },
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2113, "category": 1 /* Error */ },
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": { "code": 2114, "category": 1 /* Error */ },
        "Variable declarations of a 'for' statement cannot use a type annotation.": { "code": 2115, "category": 1 /* Error */ },
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": { "code": 2116, "category": 1 /* Error */ },
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": { "code": 2117, "category": 1 /* Error */ },
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": { "code": 2118, "category": 1 /* Error */ },
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": { "code": 2119, "category": 1 /* Error */ },
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": { "code": 2120, "category": 1 /* Error */ },
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": { "code": 2121, "category": 1 /* Error */ },
        "Setters cannot return a value.": { "code": 2122, "category": 1 /* Error */ },
        "Tried to query type of uninitialized module '{0}'.": { "code": 2123, "category": 1 /* Error */ },
        "Tried to set variable type to uninitialized module type '{0}'.": { "code": 2124, "category": 1 /* Error */ },
        "Type '{0}' is not generic.": { "code": 2125, "category": 1 /* Error */ },
        "Getters must return a value.": { "code": 2126, "category": 1 /* Error */ },
        "Getter and setter accessors do not agree in visibility.": { "code": 2127, "category": 1 /* Error */ },
        "Invalid left-hand side of assignment expression.": { "code": 2130, "category": 1 /* Error */ },
        "Function declared a non-void return type, but has no return expression.": { "code": 2131, "category": 1 /* Error */ },
        "Cannot resolve return type reference.": { "code": 2132, "category": 1 /* Error */ },
        "Constructors cannot have a return type of 'void'.": { "code": 2133, "category": 1 /* Error */ },
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": { "code": 2134, "category": 1 /* Error */ },
        "All symbols within a with block will be resolved to 'any'.": { "code": 2135, "category": 1 /* Error */ },
        "Import declarations in an internal module cannot reference an external module.": { "code": 2136, "category": 1 /* Error */ },
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": { "code": 2137, "category": 1 /* Error */ },
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": { "code": 2138, "category": 1 /* Error */ },
        "The operand of an increment or decrement operator must be a variable, property or indexer.": { "code": 2139, "category": 1 /* Error */ },
        "'this' cannot be referenced in a static property initializer.": { "code": 2140, "category": 1 /* Error */ },
        "Class '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2141, "category": 1 /* Error */ },
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2142, "category": 1 /* Error */ },
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": { "code": 2143, "category": 1 /* Error */ },
        "Overload signature is not compatible with function definition.": { "code": 2148, "category": 1 /* Error */ },
        "Overload signature is not compatible with function definition:{NL}{0}": { "code": 2149, "category": 1 /* Error */ },
        "Overload signatures must all be public or private.": { "code": 2150, "category": 1 /* Error */ },
        "Overload signatures must all be exported or not exported.": { "code": 2151, "category": 1 /* Error */ },
        "Overload signatures must all be ambient or non-ambient.": { "code": 2152, "category": 1 /* Error */ },
        "Overload signatures must all be optional or required.": { "code": 2153, "category": 1 /* Error */ },
        "Specialized overload signature is not assignable to any non-specialized signature.": { "code": 2154, "category": 1 /* Error */ },
        "'this' cannot be referenced in constructor arguments.": { "code": 2155, "category": 1 /* Error */ },
        "Instance member cannot be accessed off a class.": { "code": 2157, "category": 1 /* Error */ },
        "Untyped function calls may not accept type arguments.": { "code": 2158, "category": 1 /* Error */ },
        "Non-generic functions may not accept type arguments.": { "code": 2159, "category": 1 /* Error */ },
        "A generic type may not reference itself with a wrapped form of its own type parameters.": { "code": 2160, "category": 1 /* Error */ },
        "A rest parameter must be of an array type.": { "code": 2162, "category": 1 /* Error */ },
        "Overload signature implementation cannot use specialized type.": { "code": 2163, "category": 1 /* Error */ },
        "Export assignments may only be used at the top-level of external modules.": { "code": 2164, "category": 1 /* Error */ },
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2165, "category": 1 /* Error */ },
        "Only public methods of the base class are accessible via the 'super' keyword.": { "code": 2166, "category": 1 /* Error */ },
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": { "code": 2167, "category": 1 /* Error */ },
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": { "code": 2168, "category": 1 /* Error */ },
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": { "code": 2169, "category": 1 /* Error */ },
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": { "code": 2170, "category": 1 /* Error */ },
        "All named properties must be assignable to string indexer type '{0}'.": { "code": 2171, "category": 1 /* Error */ },
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": { "code": 2172, "category": 1 /* Error */ },
        "A parameter initializer is only allowed in a function or constructor implementation.": { "code": 2174, "category": 1 /* Error */ },
        "Function expression declared a non-void return type, but has no return expression.": { "code": 2176, "category": 1 /* Error */ },
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2177, "category": 1 /* Error */ },
        "Module '{0}' has no exported member '{1}'.": { "code": 2178, "category": 1 /* Error */ },
        "Unable to resolve module reference '{0}'.": { "code": 2179, "category": 1 /* Error */ },
        "Could not find module '{0}' in module '{1}'.": { "code": 2180, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": { "code": 2181, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": { "code": 2182, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": { "code": 2183, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": { "code": 2184, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": { "code": 2185, "category": 1 /* Error */ },
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": { "code": 2186, "category": 1 /* Error */ },
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": { "code": 2187, "category": 1 /* Error */ },
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": { "code": 2188, "category": 1 /* Error */ },
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": { "code": 2189, "category": 1 /* Error */ },
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": { "code": 2190, "category": 1 /* Error */ },
        "Ambient external module declaration cannot be reopened.": { "code": 2191, "category": 1 /* Error */ },
        "All declarations of merged declaration '{0}' must be exported or not exported.": { "code": 2192, "category": 1 /* Error */ },
        "'super' cannot be referenced in constructor arguments.": { "code": 2193, "category": 1 /* Error */ },
        "Return type of constructor signature must be assignable to the instance type of the class.": { "code": 2194, "category": 1 /* Error */ },
        "Ambient external module declaration must be defined in global context.": { "code": 2195, "category": 1 /* Error */ },
        "Ambient external module declaration cannot specify relative module name.": { "code": 2196, "category": 1 /* Error */ },
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": { "code": 2197, "category": 1 /* Error */ },
        "No best common type exists among return expressions.": { "code": 2198, "category": 1 /* Error */ },
        "Import declaration cannot refer to external module reference when --noResolve option is set.": { "code": 2199, "category": 1 /* Error */ },
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": { "code": 2200, "category": 1 /* Error */ },
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": { "code": 2205, "category": 1 /* Error */ },
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": { "code": 2206, "category": 1 /* Error */ },
        "Expression resolves to '_super' that compiler uses to capture base class reference.": { "code": 2207, "category": 1 /* Error */ },
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2208, "category": 1 /* Error */ },
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2209, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2210, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2211, "category": 1 /* Error */ },
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2212, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2213, "category": 1 /* Error */ },
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2214, "category": 1 /* Error */ },
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2215, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2216, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2217, "category": 1 /* Error */ },
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2218, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2219, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": { "code": 2220, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": { "code": 2221, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": { "code": 2222, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": { "code": 2223, "category": 1 /* Error */ },
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": { "code": 2224, "category": 1 /* Error */ },
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": { "code": 2225, "category": 1 /* Error */ },
        "No best common type exists between '{0}' and '{1}'.": { "code": 2226, "category": 1 /* Error */ },
        "No best common type exists between '{0}', '{1}', and '{2}'.": { "code": 2227, "category": 1 /* Error */ },
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": { "code": 2228, "category": 1 /* Error */ },
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": { "code": 2229, "category": 1 /* Error */ },
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": { "code": 2230, "category": 1 /* Error */ },
        "Parameter '{0}' cannot be referenced in its initializer.": { "code": 2231, "category": 1 /* Error */ },
        "Duplicate string index signature.": { "code": 2232, "category": 1 /* Error */ },
        "Duplicate number index signature.": { "code": 2233, "category": 1 /* Error */ },
        "All declarations of an interface must have identical type parameters.": { "code": 2234, "category": 1 /* Error */ },
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": { "code": 2235, "category": 1 /* Error */ },
        "Neither type '{0}' nor type '{1}' is assignable to the other.": { "code": 2236, "category": 1 /* Error */ },
        "Neither type '{0}' nor type '{1}' is assignable to the other:{NL}{2}": { "code": 2237, "category": 1 /* Error */ },
        "Duplicate function implementation.": { "code": 2237, "category": 1 /* Error */ },
        "Function implementation expected.": { "code": 2238, "category": 1 /* Error */ },
        "Function overload name must be '{0}'.": { "code": 2239, "category": 1 /* Error */ },
        "Constructor implementation expected.": { "code": 2240, "category": 1 /* Error */ },
        "Class name cannot be '{0}'.": { "code": 2241, "category": 1 /* Error */ },
        "Interface name cannot be '{0}'.": { "code": 2242, "category": 1 /* Error */ },
        "Enum name cannot be '{0}'.": { "code": 2243, "category": 1 /* Error */ },
        "A module cannot have multiple export assignments.": { "code": 2244, "category": 1 /* Error */ },
        "Export assignment not allowed in module with exported element.": { "code": 2245, "category": 1 /* Error */ },
        "A parameter property is only allowed in a constructor implementation.": { "code": 2246, "category": 1 /* Error */ },
        "Function overload must be static.": { "code": 2247, "category": 1 /* Error */ },
        "Function overload must not be static.": { "code": 2248, "category": 1 /* Error */ },
        "Type '{0}' is missing property '{1}' from type '{2}'.": { "code": 4000, "category": 3 /* NoPrefix */ },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": { "code": 4001, "category": 3 /* NoPrefix */ },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": { "code": 4002, "category": 3 /* NoPrefix */ },
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4003, "category": 3 /* NoPrefix */ },
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4004, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' define property '{2}' as private.": { "code": 4005, "category": 3 /* NoPrefix */ },
        "Call signatures of types '{0}' and '{1}' are incompatible.": { "code": 4006, "category": 3 /* NoPrefix */ },
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4007, "category": 3 /* NoPrefix */ },
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": { "code": 4008, "category": 3 /* NoPrefix */ },
        "Construct signatures of types '{0}' and '{1}' are incompatible.": { "code": 4009, "category": 3 /* NoPrefix */ },
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4010, "category": 3 /* NoPrefix */ },
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": { "code": 4011, "category": 3 /* NoPrefix */ },
        "Index signatures of types '{0}' and '{1}' are incompatible.": { "code": 4012, "category": 3 /* NoPrefix */ },
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4013, "category": 3 /* NoPrefix */ },
        "Call signature expects {0} or fewer parameters.": { "code": 4014, "category": 3 /* NoPrefix */ },
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": { "code": 4015, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4016, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4017, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": { "code": 4018, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": { "code": 4019, "category": 3 /* NoPrefix */ },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": { "code": 4020, "category": 3 /* NoPrefix */ },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": { "code": 4021, "category": 3 /* NoPrefix */ },
        "Type reference cannot refer to container '{0}'.": { "code": 4022, "category": 1 /* Error */ },
        "Type reference must refer to type.": { "code": 4023, "category": 1 /* Error */ },
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": { "code": 4024, "category": 1 /* Error */ },
        " (+ {0} overload(s))": { "code": 4025, "category": 2 /* Message */ },
        "Variable declaration cannot have the same name as an import declaration.": { "code": 4026, "category": 1 /* Error */ },
        "Signature expected {0} type arguments, got {1} instead.": { "code": 4027, "category": 1 /* Error */ },
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": { "code": 4028, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": { "code": 4029, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": { "code": 4030, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": { "code": 4031, "category": 3 /* NoPrefix */ },
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": { "code": 4032, "category": 3 /* NoPrefix */ },
        "Types of string indexer of types '{0}' and '{1}' are not identical.": { "code": 4033, "category": 3 /* NoPrefix */ },
        "Types of number indexer of types '{0}' and '{1}' are not identical.": { "code": 4034, "category": 3 /* NoPrefix */ },
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": { "code": 4035, "category": 3 /* NoPrefix */ },
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": { "code": 4036, "category": 3 /* NoPrefix */ },
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": { "code": 4037, "category": 3 /* NoPrefix */ },
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4038, "category": 3 /* NoPrefix */ },
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4039, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' define static property '{2}' as private.": { "code": 4040, "category": 3 /* NoPrefix */ },
        "Current host does not support '{0}' option.": { "code": 5001, "category": 1 /* Error */ },
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": { "code": 5002, "category": 1 /* Error */ },
        "Argument for '{0}' option must be '{1}' or '{2}'": { "code": 5003, "category": 1 /* Error */ },
        "Could not find file: '{0}'.": { "code": 5004, "category": 1 /* Error */ },
        "A file cannot have a reference to itself.": { "code": 5006, "category": 1 /* Error */ },
        "Cannot resolve referenced file: '{0}'.": { "code": 5007, "category": 1 /* Error */ },
        "Cannot find the common subdirectory path for the input files.": { "code": 5009, "category": 1 /* Error */ },
        "Emit Error: {0}.": { "code": 5011, "category": 1 /* Error */ },
        "Cannot read file '{0}': {1}": { "code": 5012, "category": 1 /* Error */ },
        "Unsupported file encoding.": { "code": 5013, "category": 3 /* NoPrefix */ },
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": { "code": 5014, "category": 1 /* Error */ },
        "Unsupported locale: '{0}'.": { "code": 5015, "category": 1 /* Error */ },
        "Execution Failed.{NL}": { "code": 5016, "category": 1 /* Error */ },
        "Invalid call to 'up'": { "code": 5019, "category": 1 /* Error */ },
        "Invalid call to 'down'": { "code": 5020, "category": 1 /* Error */ },
        "Base64 value '{0}' finished with a continuation bit.": { "code": 5021, "category": 1 /* Error */ },
        "Unknown compiler option '{0}'": { "code": 5023, "category": 1 /* Error */ },
        "Expected {0} arguments to message, got {1} instead.": { "code": 5024, "category": 1 /* Error */ },
        "Expected the message '{0}' to have {1} arguments, but it had {2}": { "code": 5025, "category": 1 /* Error */ },
        "Could not delete file '{0}'": { "code": 5034, "category": 1 /* Error */ },
        "Could not create directory '{0}'": { "code": 5035, "category": 1 /* Error */ },
        "Error while executing file '{0}': ": { "code": 5036, "category": 1 /* Error */ },
        "Cannot compile external modules unless the '--module' flag is provided.": { "code": 5037, "category": 1 /* Error */ },
        "Option mapRoot cannot be specified without specifying sourcemap option.": { "code": 5038, "category": 1 /* Error */ },
        "Option sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5039, "category": 1 /* Error */ },
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5040, "category": 1 /* Error */ },
        "Option '{0}' specified without '{1}'": { "code": 5041, "category": 1 /* Error */ },
        "'codepage' option not supported on current platform.": { "code": 5042, "category": 1 /* Error */ },
        "Concatenate and emit output to single file.": { "code": 6001, "category": 2 /* Message */ },
        "Generates corresponding {0} file.": { "code": 6002, "category": 2 /* Message */ },
        "Specifies the location where debugger should locate map files instead of generated locations.": { "code": 6003, "category": 2 /* Message */ },
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": { "code": 6004, "category": 2 /* Message */ },
        "Watch input files.": { "code": 6005, "category": 2 /* Message */ },
        "Redirect output structure to the directory.": { "code": 6006, "category": 2 /* Message */ },
        "Do not emit comments to output.": { "code": 6009, "category": 2 /* Message */ },
        "Skip resolution and preprocessing.": { "code": 6010, "category": 2 /* Message */ },
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": { "code": 6015, "category": 2 /* Message */ },
        "Specify module code generation: '{0}' or '{1}'": { "code": 6016, "category": 2 /* Message */ },
        "Print this message.": { "code": 6017, "category": 2 /* Message */ },
        "Print the compiler's version: {0}": { "code": 6019, "category": 2 /* Message */ },
        "Allow use of deprecated '{0}' keyword when referencing an external module.": { "code": 6021, "category": 2 /* Message */ },
        "Specify locale for errors and messages. For example '{0}' or '{1}'": { "code": 6022, "category": 2 /* Message */ },
        "Syntax:   {0}": { "code": 6023, "category": 2 /* Message */ },
        "options": { "code": 6024, "category": 2 /* Message */ },
        "file1": { "code": 6025, "category": 2 /* Message */ },
        "Examples:": { "code": 6026, "category": 2 /* Message */ },
        "Options:": { "code": 6027, "category": 2 /* Message */ },
        "Insert command line options and files from a file.": { "code": 6030, "category": 2 /* Message */ },
        "Version {0}": { "code": 6029, "category": 2 /* Message */ },
        "Use the '{0}' flag to see options.": { "code": 6031, "category": 2 /* Message */ },
        "{NL}Recompiling ({0}):": { "code": 6032, "category": 2 /* Message */ },
        "STRING": { "code": 6033, "category": 2 /* Message */ },
        "KIND": { "code": 6034, "category": 2 /* Message */ },
        "file2": { "code": 6035, "category": 2 /* Message */ },
        "VERSION": { "code": 6036, "category": 2 /* Message */ },
        "LOCATION": { "code": 6037, "category": 2 /* Message */ },
        "DIRECTORY": { "code": 6038, "category": 2 /* Message */ },
        "NUMBER": { "code": 6039, "category": 2 /* Message */ },
        "Specify the codepage to use when opening source files.": { "code": 6040, "category": 2 /* Message */ },
        "Additional locations:": { "code": 6041, "category": 2 /* Message */ },
        "This version of the Javascript runtime does not support the '{0}' function.": { "code": 7000, "category": 1 /* Error */ },
        "Unknown rule.": { "code": 7002, "category": 1 /* Error */ },
        "Invalid line number ({0})": { "code": 7003, "category": 1 /* Error */ },
        "Warn on expressions and declarations with an implied 'any' type.": { "code": 7004, "category": 2 /* Message */ },
        "Variable '{0}' implicitly has an 'any' type.": { "code": 7005, "category": 1 /* Error */ },
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": { "code": 7006, "category": 1 /* Error */ },
        "Parameter '{0}' of function type implicitly has an 'any' type.": { "code": 7007, "category": 1 /* Error */ },
        "Member '{0}' of object type implicitly has an 'any' type.": { "code": 7008, "category": 1 /* Error */ },
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": { "code": 7009, "category": 1 /* Error */ },
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7010, "category": 1 /* Error */ },
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7011, "category": 1 /* Error */ },
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": { "code": 7012, "category": 1 /* Error */ },
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7013, "category": 1 /* Error */ },
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7014, "category": 1 /* Error */ },
        "Array Literal implicitly has an 'any' type from widening.": { "code": 7015, "category": 1 /* Error */ },
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": { "code": 7016, "category": 1 /* Error */ },
        "Index signature of object type implicitly has an 'any' type.": { "code": 7017, "category": 1 /* Error */ },
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": { "code": 7018, "category": 1 /* Error */ }
    };
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() {
        }
        ArrayUtilities.sequenceEquals = function (array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }

            if (array1 === null || array2 === null) {
                return false;
            }

            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.contains = function (array, value) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.distinct = function (array, equalsFn) {
            var result = [];

            for (var i = 0, n = array.length; i < n; i++) {
                var current = array[i];
                for (var j = 0; j < result.length; j++) {
                    if (equalsFn(result[j], current)) {
                        break;
                    }
                }

                if (j === result.length) {
                    result.push(current);
                }
            }

            return result;
        };

        ArrayUtilities.last = function (array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }

            return array[array.length - 1];
        };

        ArrayUtilities.lastOrDefault = function (array, predicate) {
            for (var i = array.length - 1; i >= 0; i--) {
                var v = array[i];
                if (predicate(v, i)) {
                    return v;
                }
            }

            return null;
        };

        ArrayUtilities.firstOrDefault = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value, i)) {
                    return value;
                }
            }

            return null;
        };

        ArrayUtilities.first = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (!func || func(value, i)) {
                    return value;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        };

        ArrayUtilities.sum = function (array, func) {
            var result = 0;

            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }

            return result;
        };

        ArrayUtilities.select = function (values, func) {
            var result = new Array(values.length);

            for (var i = 0; i < values.length; i++) {
                result[i] = func(values[i]);
            }

            return result;
        };

        ArrayUtilities.where = function (values, func) {
            var result = new Array();

            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }

            return result;
        };

        ArrayUtilities.any = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.all = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.binarySearch = function (array, value) {
            var low = 0;
            var high = array.length - 1;

            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];

                if (midValue === value) {
                    return middle;
                } else if (midValue > value) {
                    high = middle - 1;
                } else {
                    low = middle + 1;
                }
            }

            return ~low;
        };

        ArrayUtilities.createArray = function (length, defaultValue) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = defaultValue;
            }

            return result;
        };

        ArrayUtilities.grow = function (array, length, defaultValue) {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };

        ArrayUtilities.copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };

        ArrayUtilities.indexOf = function (array, predicate) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (predicate(array[i])) {
                    return i;
                }
            }

            return -1;
        };
        return ArrayUtilities;
    })();
    TypeScript.ArrayUtilities = ArrayUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (BitVector) {
        var pool = [];
        var Constants;
        (function (Constants) {
            Constants[Constants["MaxBitsPerEncodedNumber"] = 30] = "MaxBitsPerEncodedNumber";
            Constants[Constants["BitsPerEncodedBiStateValue"] = 1] = "BitsPerEncodedBiStateValue";

            Constants[Constants["BitsPerEncodedTriStateValue"] = 2] = "BitsPerEncodedTriStateValue";

            Constants[Constants["BiStateEncodedTrue"] = 1] = "BiStateEncodedTrue";
            Constants[Constants["BiStateClearBitsMask"] = 1] = "BiStateClearBitsMask";

            Constants[Constants["TriStateEncodedFalse"] = 1] = "TriStateEncodedFalse";
            Constants[Constants["TriStateEncodedTrue"] = 2] = "TriStateEncodedTrue";
            Constants[Constants["TriStateClearBitsMask"] = 3] = "TriStateClearBitsMask";
        })(Constants || (Constants = {}));

        var BitVectorImpl = (function () {
            function BitVectorImpl(allowUndefinedValues) {
                this.allowUndefinedValues = allowUndefinedValues;
                this.isReleased = false;
                this.bits = [];
            }
            BitVectorImpl.prototype.computeTriStateArrayIndex = function (index) {
                var encodedValuesPerNumber = 30 /* MaxBitsPerEncodedNumber */ / 2 /* BitsPerEncodedTriStateValue */;

                return (index / encodedValuesPerNumber) >>> 0;
            };

            BitVectorImpl.prototype.computeBiStateArrayIndex = function (index) {
                var encodedValuesPerNumber = 30 /* MaxBitsPerEncodedNumber */ / 1 /* BitsPerEncodedBiStateValue */;

                return (index / encodedValuesPerNumber) >>> 0;
            };

            BitVectorImpl.prototype.computeTriStateEncodedValueIndex = function (index) {
                var encodedValuesPerNumber = 30 /* MaxBitsPerEncodedNumber */ / 2 /* BitsPerEncodedTriStateValue */;

                return (index % encodedValuesPerNumber) * 2 /* BitsPerEncodedTriStateValue */;
            };

            BitVectorImpl.prototype.computeBiStateEncodedValueIndex = function (index) {
                var encodedValuesPerNumber = 30 /* MaxBitsPerEncodedNumber */ / 1 /* BitsPerEncodedBiStateValue */;

                return (index % encodedValuesPerNumber) * 1 /* BitsPerEncodedBiStateValue */;
            };

            BitVectorImpl.prototype.valueAt = function (index) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                if (this.allowUndefinedValues) {
                    var arrayIndex = this.computeTriStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        return undefined;
                    }

                    var bitIndex = this.computeTriStateEncodedValueIndex(index);
                    if (encoded & (2 /* TriStateEncodedTrue */ << bitIndex)) {
                        return true;
                    } else if (encoded & (1 /* TriStateEncodedFalse */ << bitIndex)) {
                        return false;
                    } else {
                        return undefined;
                    }
                } else {
                    var arrayIndex = this.computeBiStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        return false;
                    }

                    var bitIndex = this.computeBiStateEncodedValueIndex(index);
                    if (encoded & (1 /* BiStateEncodedTrue */ << bitIndex)) {
                        return true;
                    } else {
                        return false;
                    }
                }
            };

            BitVectorImpl.prototype.setValueAt = function (index, value) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                if (this.allowUndefinedValues) {
                    TypeScript.Debug.assert(value === true || value === false || value === undefined, "value must only be true, false or undefined.");

                    var arrayIndex = this.computeTriStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        if (value === undefined) {
                            return;
                        }

                        encoded = 0;
                    }

                    var bitIndex = this.computeTriStateEncodedValueIndex(index);

                    var clearMask = ~(3 /* TriStateClearBitsMask */ << bitIndex);
                    encoded = encoded & clearMask;

                    if (value === true) {
                        encoded = encoded | (2 /* TriStateEncodedTrue */ << bitIndex);
                    } else if (value === false) {
                        encoded = encoded | (1 /* TriStateEncodedFalse */ << bitIndex);
                    }

                    this.bits[arrayIndex] = encoded;
                } else {
                    TypeScript.Debug.assert(value === true || value === false, "value must only be true or false.");

                    var arrayIndex = this.computeBiStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        if (value === false) {
                            return;
                        }

                        encoded = 0;
                    }

                    var bitIndex = this.computeBiStateEncodedValueIndex(index);

                    encoded = encoded & ~(1 /* BiStateClearBitsMask */ << bitIndex);

                    if (value) {
                        encoded = encoded | (1 /* BiStateEncodedTrue */ << bitIndex);
                    }

                    this.bits[arrayIndex] = encoded;
                }
            };

            BitVectorImpl.prototype.release = function () {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                this.isReleased = true;
                this.bits.length = 0;
                pool.push(this);
            };
            return BitVectorImpl;
        })();

        function getBitVector(allowUndefinedValues) {
            if (pool.length === 0) {
                return new BitVectorImpl(allowUndefinedValues);
            }

            var vector = pool.pop();
            vector.isReleased = false;
            vector.allowUndefinedValues = allowUndefinedValues;

            return vector;
        }
        BitVector.getBitVector = getBitVector;
    })(TypeScript.BitVector || (TypeScript.BitVector = {}));
    var BitVector = TypeScript.BitVector;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (BitMatrix) {
        var pool = [];

        var BitMatrixImpl = (function () {
            function BitMatrixImpl(allowUndefinedValues) {
                this.allowUndefinedValues = allowUndefinedValues;
                this.isReleased = false;
                this.vectors = [];
            }
            BitMatrixImpl.prototype.valueAt = function (x, y) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                var vector = this.vectors[x];
                if (!vector) {
                    return this.allowUndefinedValues ? undefined : false;
                }

                return vector.valueAt(y);
            };

            BitMatrixImpl.prototype.setValueAt = function (x, y, value) {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                var vector = this.vectors[x];
                if (!vector) {
                    if (value === undefined) {
                        return;
                    }

                    vector = TypeScript.BitVector.getBitVector(this.allowUndefinedValues);
                    this.vectors[x] = vector;
                }

                vector.setValueAt(y, value);
            };

            BitMatrixImpl.prototype.release = function () {
                TypeScript.Debug.assert(!this.isReleased, "Should not use a released bitvector");
                this.isReleased = true;

                for (var name in this.vectors) {
                    if (this.vectors.hasOwnProperty(name)) {
                        var vector = this.vectors[name];
                        vector.release();
                    }
                }

                this.vectors.length = 0;
                pool.push(this);
            };
            return BitMatrixImpl;
        })();

        function getBitMatrix(allowUndefinedValues) {
            if (pool.length === 0) {
                return new BitMatrixImpl(allowUndefinedValues);
            }

            var matrix = pool.pop();
            matrix.isReleased = false;
            matrix.allowUndefinedValues = allowUndefinedValues;

            return matrix;
        }
        BitMatrix.getBitMatrix = getBitMatrix;
    })(TypeScript.BitMatrix || (TypeScript.BitMatrix = {}));
    var BitMatrix = TypeScript.BitMatrix;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Constants) {
        Constants[Constants["Max31BitInteger"] = 1073741823] = "Max31BitInteger";
        Constants[Constants["Min31BitInteger"] = -1073741824] = "Min31BitInteger";
    })(TypeScript.Constants || (TypeScript.Constants = {}));
    var Constants = TypeScript.Constants;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (AssertionLevel) {
        AssertionLevel[AssertionLevel["None"] = 0] = "None";
        AssertionLevel[AssertionLevel["Normal"] = 1] = "Normal";
        AssertionLevel[AssertionLevel["Aggressive"] = 2] = "Aggressive";
        AssertionLevel[AssertionLevel["VeryAggressive"] = 3] = "VeryAggressive";
    })(TypeScript.AssertionLevel || (TypeScript.AssertionLevel = {}));
    var AssertionLevel = TypeScript.AssertionLevel;

    var Debug = (function () {
        function Debug() {
        }
        Debug.shouldAssert = function (level) {
            return this.currentAssertionLevel >= level;
        };

        Debug.assert = function (expression, message, verboseDebugInfo) {
            if (typeof message === "undefined") { message = ""; }
            if (typeof verboseDebugInfo === "undefined") { verboseDebugInfo = null; }
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information:" + verboseDebugInfo();
                }

                throw new Error("Debug Failure. False expression: " + message + verboseDebugString);
            }
        };

        Debug.fail = function (message) {
            Debug.assert(false, message);
        };
        Debug.currentAssertionLevel = 0 /* None */;
        return Debug;
    })();
    TypeScript.Debug = Debug;
})(TypeScript || (TypeScript = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    TypeScript.LocalizedDiagnosticMessages = null;

    var Location = (function () {
        function Location(fileName, lineMap, start, length) {
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._start = start;
            this._length = length;
        }
        Location.prototype.fileName = function () {
            return this._fileName;
        };

        Location.prototype.lineMap = function () {
            return this._lineMap;
        };

        Location.prototype.line = function () {
            return this._lineMap ? this._lineMap.getLineNumberFromPosition(this.start()) : 0;
        };

        Location.prototype.character = function () {
            return this._lineMap ? this._lineMap.getLineAndCharacterFromPosition(this.start()).character() : 0;
        };

        Location.prototype.start = function () {
            return this._start;
        };

        Location.prototype.length = function () {
            return this._length;
        };

        Location.equals = function (location1, location2) {
            return location1._fileName === location2._fileName && location1._start === location2._start && location1._length === location2._length;
        };
        return Location;
    })();
    TypeScript.Location = Location;

    var Diagnostic = (function (_super) {
        __extends(Diagnostic, _super);
        function Diagnostic(fileName, lineMap, start, length, diagnosticKey, _arguments, additionalLocations) {
            if (typeof _arguments === "undefined") { _arguments = null; }
            if (typeof additionalLocations === "undefined") { additionalLocations = null; }
            _super.call(this, fileName, lineMap, start, length);
            this._diagnosticKey = diagnosticKey;
            this._arguments = (_arguments && _arguments.length > 0) ? _arguments : null;
            this._additionalLocations = (additionalLocations && additionalLocations.length > 0) ? additionalLocations : null;
        }
        Diagnostic.prototype.toJSON = function (key) {
            var result = {};
            result.start = this.start();
            result.length = this.length();

            result.diagnosticCode = this._diagnosticKey;

            var _arguments = this.arguments();
            if (_arguments && _arguments.length > 0) {
                result.arguments = _arguments;
            }

            return result;
        };

        Diagnostic.prototype.diagnosticKey = function () {
            return this._diagnosticKey;
        };

        Diagnostic.prototype.arguments = function () {
            return this._arguments;
        };

        Diagnostic.prototype.text = function () {
            return TypeScript.getLocalizedText(this._diagnosticKey, this._arguments);
        };

        Diagnostic.prototype.message = function () {
            return TypeScript.getDiagnosticMessage(this._diagnosticKey, this._arguments);
        };

        Diagnostic.prototype.additionalLocations = function () {
            return this._additionalLocations || [];
        };

        Diagnostic.equals = function (diagnostic1, diagnostic2) {
            return Location.equals(diagnostic1, diagnostic2) && diagnostic1._diagnosticKey === diagnostic2._diagnosticKey && TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) {
                return v1 === v2;
            });
        };

        Diagnostic.prototype.info = function () {
            return getDiagnosticInfoFromKey(this.diagnosticKey());
        };
        return Diagnostic;
    })(Location);
    TypeScript.Diagnostic = Diagnostic;

    function newLine() {
        return TypeScript.Environment ? TypeScript.Environment.newLine : "\r\n";
    }
    TypeScript.newLine = newLine;

    function getLargestIndex(diagnostic) {
        var largest = -1;
        var regex = /\{(\d+)\}/g;

        var match;
        while (match = regex.exec(diagnostic)) {
            var val = parseInt(match[1]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }

        return largest;
    }

    function getDiagnosticInfoFromKey(diagnosticKey) {
        var result = TypeScript.diagnosticInformationMap[diagnosticKey];
        TypeScript.Debug.assert(result);
        return result;
    }

    function getLocalizedText(diagnosticKey, args) {
        if (TypeScript.LocalizedDiagnosticMessages) {
        }

        var diagnosticMessageText = TypeScript.LocalizedDiagnosticMessages ? TypeScript.LocalizedDiagnosticMessages[diagnosticKey] : diagnosticKey;
        TypeScript.Debug.assert(diagnosticMessageText !== undefined && diagnosticMessageText !== null);

        var actualCount = args ? args.length : 0;

        var expectedCount = 1 + getLargestIndex(diagnosticKey);

        if (expectedCount !== actualCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_0_arguments_to_message_got_1_instead, [expectedCount, actualCount]));
        }

        var valueCount = 1 + getLargestIndex(diagnosticMessageText);
        if (valueCount !== expectedCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_the_message_0_to_have_1_arguments_but_it_had_2, [diagnosticMessageText, expectedCount, valueCount]));
        }

        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });

        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return TypeScript.newLine();
        });

        return diagnosticMessageText;
    }
    TypeScript.getLocalizedText = getLocalizedText;

    function getDiagnosticMessage(diagnosticKey, args) {
        var diagnostic = getDiagnosticInfoFromKey(diagnosticKey);
        var diagnosticMessageText = getLocalizedText(diagnosticKey, args);

        var message;
        if (diagnostic.category === 1 /* Error */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.error_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        } else if (diagnostic.category === 0 /* Warning */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.warning_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        } else {
            message = diagnosticMessageText;
        }

        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() {
        }
        Errors.argument = function (argument, message) {
            return new Error("Invalid argument: " + argument + ". " + message);
        };

        Errors.argumentOutOfRange = function (argument) {
            return new Error("Argument out of range: " + argument);
        };

        Errors.argumentNull = function (argument) {
            return new Error("Argument null: " + argument);
        };

        Errors.abstract = function () {
            return new Error("Operation not implemented properly by subclass.");
        };

        Errors.notYetImplemented = function () {
            return new Error("Not yet implemented.");
        };

        Errors.invalidOperation = function (message) {
            return new Error("Invalid operation: " + message);
        };
        return Errors;
    })();
    TypeScript.Errors = Errors;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Hash = (function () {
        function Hash() {
        }
        Hash.computeFnv1aCharArrayHashCode = function (text, start, len) {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;

            for (var i = start; i < end; i++) {
                hashCode = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(hashCode ^ text[i], Hash.FNV_PRIME);
            }

            return hashCode;
        };

        Hash.computeSimple31BitCharArrayHashCode = function (key, start, len) {
            var hash = 0;

            for (var i = 0; i < len; i++) {
                var ch = key[start + i];

                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeSimple31BitStringHashCode = function (key) {
            var hash = 0;

            var start = 0;
            var len = key.length;

            for (var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);

                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeMurmur2StringHashCode = function (key, seed) {
            var m = 0x5bd1e995;
            var r = 24;

            var numberOfCharsLeft = key.length;
            var h = Math.abs(seed ^ numberOfCharsLeft);

            var index = 0;
            while (numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);

                var k = Math.abs(c1 | (c2 << 16));

                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);
                k ^= k >> r;
                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);

                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            if (numberOfCharsLeft === 1) {
                h ^= key.charCodeAt(index);
                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            }

            h ^= h >> 13;
            h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            h ^= h >> 15;

            return h;
        };

        Hash.combine = function (value, currentHash) {
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        };
        Hash.FNV_BASE = 2166136261;
        Hash.FNV_PRIME = 16777619;
        return Hash;
    })();
    TypeScript.Hash = Hash;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    TypeScript.nodeMakeDirectoryTime = 0;
    TypeScript.nodeCreateBufferTime = 0;
    TypeScript.nodeWriteFileSyncTime = 0;

    (function (ByteOrderMark) {
        ByteOrderMark[ByteOrderMark["None"] = 0] = "None";
        ByteOrderMark[ByteOrderMark["Utf8"] = 1] = "Utf8";
        ByteOrderMark[ByteOrderMark["Utf16BigEndian"] = 2] = "Utf16BigEndian";
        ByteOrderMark[ByteOrderMark["Utf16LittleEndian"] = 3] = "Utf16LittleEndian";
    })(TypeScript.ByteOrderMark || (TypeScript.ByteOrderMark = {}));
    var ByteOrderMark = TypeScript.ByteOrderMark;

    var FileInformation = (function () {
        function FileInformation(contents, byteOrderMark) {
            this.contents = contents;
            this.byteOrderMark = byteOrderMark;
        }
        return FileInformation;
    })();
    TypeScript.FileInformation = FileInformation;

    function throwIOError(message, error) {
        var errorMessage = message;
        if (error && error.message) {
            errorMessage += (" " + error.message);
        }
        throw new Error(errorMessage);
    }

    TypeScript.Environment = (function () {
        function getWindowsScriptHostEnvironment() {
            try  {
                var fso = new ActiveXObject("Scripting.FileSystemObject");
            } catch (e) {
                return null;
            }

            var streamObjectPool = [];

            function getStreamObject() {
                if (streamObjectPool.length > 0) {
                    return streamObjectPool.pop();
                } else {
                    return new ActiveXObject("ADODB.Stream");
                }
            }

            function releaseStreamObject(obj) {
                streamObjectPool.push(obj);
            }

            var args = [];
            for (var i = 0; i < WScript.Arguments.length; i++) {
                args[i] = WScript.Arguments.Item(i);
            }

            return {
                newLine: "\r\n",
                currentDirectory: function () {
                    return WScript.CreateObject("WScript.Shell").CurrentDirectory;
                },
                supportsCodePage: function () {
                    return WScript.ReadFile;
                },
                absolutePath: function (path) {
                    return fso.GetAbsolutePathName(path);
                },
                readFile: function (path, codepage) {
                    try  {
                        if (codepage !== null && this.supportsCodePage()) {
                            try  {
                                var contents = WScript.ReadFile(path, codepage);
                                return new FileInformation(contents, 0 /* None */);
                            } catch (e) {
                            }
                        }

                        var streamObj = getStreamObject();
                        streamObj.Open();
                        streamObj.Type = 2;

                        streamObj.Charset = 'x-ansi';

                        streamObj.LoadFromFile(path);
                        var bomChar = streamObj.ReadText(2);

                        streamObj.Position = 0;

                        var byteOrderMark = 0 /* None */;

                        if (bomChar.charCodeAt(0) === 0xFE && bomChar.charCodeAt(1) === 0xFF) {
                            streamObj.Charset = 'unicode';
                            byteOrderMark = 2 /* Utf16BigEndian */;
                        } else if (bomChar.charCodeAt(0) === 0xFF && bomChar.charCodeAt(1) === 0xFE) {
                            streamObj.Charset = 'unicode';
                            byteOrderMark = 3 /* Utf16LittleEndian */;
                        } else if (bomChar.charCodeAt(0) === 0xEF && bomChar.charCodeAt(1) === 0xBB) {
                            streamObj.Charset = 'utf-8';
                            byteOrderMark = 1 /* Utf8 */;
                        } else {
                            streamObj.Charset = 'utf-8';
                        }

                        var contents = streamObj.ReadText(-1);
                        streamObj.Close();
                        releaseStreamObject(streamObj);
                        return new FileInformation(contents, byteOrderMark);
                    } catch (err) {
                        var message;
                        if (err.number === -2147024809) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unsupported_file_encoding, null);
                        } else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_read_file_0_1, [path, err.message]);
                        }

                        throw new Error(message);
                    }
                },
                writeFile: function (path, contents, writeByteOrderMark) {
                    var textStream = getStreamObject();
                    textStream.Charset = 'utf-8';
                    textStream.Open();
                    textStream.WriteText(contents, 0);

                    if (!writeByteOrderMark) {
                        textStream.Position = 3;
                    } else {
                        textStream.Position = 0;
                    }

                    var fileStream = getStreamObject();
                    fileStream.Type = 1;
                    fileStream.Open();

                    textStream.CopyTo(fileStream);

                    fileStream.Flush();
                    fileStream.SaveToFile(path, 2);
                    fileStream.Close();

                    textStream.Flush();
                    textStream.Close();
                },
                fileExists: function (path) {
                    return fso.FileExists(path);
                },
                deleteFile: function (path) {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true);
                    }
                },
                directoryExists: function (path) {
                    return fso.FolderExists(path);
                },
                directoryName: function (path) {
                    return fso.GetParentFolderName(path);
                },
                createDirectory: function (path) {
                    try  {
                        if (!this.directoryExists(path)) {
                            fso.CreateFolder(path);
                        }
                    } catch (e) {
                        throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_create_directory_0, [path]), e);
                    }
                },
                listFiles: function (path, spec, options) {
                    options = options || {};
                    function filesInFolder(folder, root) {
                        var paths = [];
                        var fc;

                        if (options.recursive) {
                            fc = new Enumerator(folder.subfolders);

                            for (; !fc.atEnd(); fc.moveNext()) {
                                paths = paths.concat(filesInFolder(fc.item(), root + "\\" + fc.item().Name));
                            }
                        }

                        fc = new Enumerator(folder.files);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            if (!spec || fc.item().Name.match(spec)) {
                                paths.push(root + "\\" + fc.item().Name);
                            }
                        }

                        return paths;
                    }

                    var folder = fso.GetFolder(path);
                    var paths = [];

                    return filesInFolder(folder, path);
                },
                arguments: args,
                standardOut: WScript.StdOut,
                standardError: WScript.StdErr,
                executingFilePath: function () {
                    return WScript.ScriptFullName;
                },
                quit: function (exitCode) {
                    if (typeof exitCode === "undefined") { exitCode = 0; }
                    try  {
                        WScript.Quit(exitCode);
                    } catch (e) {
                    }
                },
                watchFile: null
            };
        }
        ;

        function getNodeEnvironment() {
            var _fs = require('fs');
            var _path = require('path');
            var _module = require('module');
            var _os = require('os');

            return {
                newLine: _os.EOL,
                currentDirectory: function () {
                    return process.cwd();
                },
                supportsCodePage: function () {
                    return false;
                },
                absolutePath: function (path) {
                    return _path.resolve(path);
                },
                readFile: function (file, codepage) {
                    if (codepage !== null) {
                        throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.codepage_option_not_supported_on_current_platform, null));
                    }

                    var buffer = _fs.readFileSync(file);
                    switch (buffer[0]) {
                        case 0xFE:
                            if (buffer[1] === 0xFF) {
                                var i = 0;
                                while ((i + 1) < buffer.length) {
                                    var temp = buffer[i];
                                    buffer[i] = buffer[i + 1];
                                    buffer[i + 1] = temp;
                                    i += 2;
                                }
                                return new FileInformation(buffer.toString("ucs2", 2), 2 /* Utf16BigEndian */);
                            }
                            break;
                        case 0xFF:
                            if (buffer[1] === 0xFE) {
                                return new FileInformation(buffer.toString("ucs2", 2), 3 /* Utf16LittleEndian */);
                            }
                            break;
                        case 0xEF:
                            if (buffer[1] === 0xBB) {
                                return new FileInformation(buffer.toString("utf8", 3), 1 /* Utf8 */);
                            }
                    }

                    return new FileInformation(buffer.toString("utf8", 0), 0 /* None */);
                },
                writeFile: function (path, contents, writeByteOrderMark) {
                    function mkdirRecursiveSync(path) {
                        var stats = _fs.statSync(path);
                        if (stats.isFile()) {
                            throw "\"" + path + "\" exists but isn't a directory.";
                        } else if (stats.isDirectory()) {
                            return;
                        } else {
                            mkdirRecursiveSync(_path.dirname(path));
                            _fs.mkdirSync(path, 509);
                        }
                    }
                    var start = new Date().getTime();
                    mkdirRecursiveSync(_path.dirname(path));
                    TypeScript.nodeMakeDirectoryTime += new Date().getTime() - start;

                    if (writeByteOrderMark) {
                        contents = '\uFEFF' + contents;
                    }

                    var start = new Date().getTime();

                    var chunkLength = 4 * 1024;
                    var fileDescriptor = _fs.openSync(path, "w");
                    try  {
                        for (var index = 0; index < contents.length; index += chunkLength) {
                            var bufferStart = new Date().getTime();
                            var buffer = new Buffer(contents.substr(index, chunkLength), "utf8");
                            TypeScript.nodeCreateBufferTime += new Date().getTime() - bufferStart;

                            _fs.writeSync(fileDescriptor, buffer, 0, buffer.length, null);
                        }
                    } finally {
                        _fs.closeSync(fileDescriptor);
                    }

                    TypeScript.nodeWriteFileSyncTime += new Date().getTime() - start;
                },
                fileExists: function (path) {
                    return _fs.existsSync(path);
                },
                deleteFile: function (path) {
                    try  {
                        _fs.unlinkSync(path);
                    } catch (e) {
                    }
                },
                directoryExists: function (path) {
                    return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
                },
                directoryName: function (path) {
                    var dirPath = _path.dirname(path);

                    if (dirPath === path) {
                        dirPath = null;
                    }

                    return dirPath;
                },
                createDirectory: function (path) {
                    try  {
                        if (!this.directoryExists(path)) {
                            _fs.mkdirSync(path);
                        }
                    } catch (e) {
                        throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_create_directory_0, [path]), e);
                    }
                },
                listFiles: function (path, spec, options) {
                    options = options || {};

                    function filesInFolder(folder) {
                        var paths = [];

                        var files = _fs.readdirSync(folder);
                        for (var i = 0; i < files.length; i++) {
                            var pathToFile = _path.join(folder, files[i]);
                            var stat = _fs.statSync(pathToFile);
                            if (options.recursive && stat.isDirectory()) {
                                paths = paths.concat(filesInFolder(pathToFile));
                            } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                                paths.push(pathToFile);
                            }
                        }

                        return paths;
                    }

                    return filesInFolder(path);
                },
                arguments: process.argv.slice(2),
                standardOut: {
                    Write: function (str) {
                        return process.stdout.write(str);
                    },
                    WriteLine: function (str) {
                        return process.stdout.write(str + '\n');
                    },
                    Close: function () {
                    }
                },
                standardError: {
                    Write: function (str) {
                        return process.stderr.write(str);
                    },
                    WriteLine: function (str) {
                        return process.stderr.write(str + '\n');
                    },
                    Close: function () {
                    }
                },
                executingFilePath: function () {
                    return process.mainModule.filename;
                },
                quit: function (code) {
                    var stderrFlushed = process.stderr.write('');
                    var stdoutFlushed = process.stdout.write('');
                    process.stderr.on('drain', function () {
                        stderrFlushed = true;
                        if (stdoutFlushed) {
                            process.exit(code);
                        }
                    });
                    process.stdout.on('drain', function () {
                        stdoutFlushed = true;
                        if (stderrFlushed) {
                            process.exit(code);
                        }
                    });
                    setTimeout(function () {
                        process.exit(code);
                    }, 5);
                },
                watchFile: function (fileName, callback) {
                    var firstRun = true;
                    var processingChange = false;

                    var fileChanged = function (curr, prev) {
                        if (!firstRun) {
                            if (curr.mtime < prev.mtime) {
                                return;
                            }

                            _fs.unwatchFile(fileName, fileChanged);
                            if (!processingChange) {
                                processingChange = true;
                                callback(fileName);
                                setTimeout(function () {
                                    processingChange = false;
                                }, 100);
                            }
                        }
                        firstRun = false;
                        _fs.watchFile(fileName, { persistent: true, interval: 500 }, fileChanged);
                    };

                    fileChanged();
                    return {
                        fileName: fileName,
                        close: function () {
                            _fs.unwatchFile(fileName, fileChanged);
                        }
                    };
                }
            };
        }
        ;

        if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
            return getWindowsScriptHostEnvironment();
        } else if (typeof module !== 'undefined' && module.exports) {
            return getNodeEnvironment();
        } else {
            return null;
        }
    })();
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (IntegerUtilities) {
        function integerDivide(numerator, denominator) {
            return (numerator / denominator) >> 0;
        }
        IntegerUtilities.integerDivide = integerDivide;

        function integerMultiplyLow32Bits(n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        }
        IntegerUtilities.integerMultiplyLow32Bits = integerMultiplyLow32Bits;

        function isInteger(text) {
            return /^[0-9]+$/.test(text);
        }
        IntegerUtilities.isInteger = isInteger;

        function isHexInteger(text) {
            return /^0(x|X)[0-9a-fA-F]+$/.test(text);
        }
        IntegerUtilities.isHexInteger = isHexInteger;
    })(TypeScript.IntegerUtilities || (TypeScript.IntegerUtilities = {}));
    var IntegerUtilities = TypeScript.IntegerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_computeLineStarts, length) {
            this._computeLineStarts = _computeLineStarts;
            this.length = length;
            this._lineStarts = null;
        }
        LineMap.prototype.toJSON = function (key) {
            return { lineStarts: this.lineStarts(), length: this.length };
        };

        LineMap.prototype.equals = function (other) {
            return this.length === other.length && TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) {
                return v1 === v2;
            });
        };

        LineMap.prototype.lineStarts = function () {
            if (this._lineStarts === null) {
                this._lineStarts = this._computeLineStarts();
            }

            return this._lineStarts;
        };

        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };

        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };

        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            if (position === this.length) {
                return this.lineCount() - 1;
            }

            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        };

        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };

        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };

        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };
        LineMap.empty = new LineMap(function () {
            return [0];
        }, 0);
        return LineMap;
    })();
    TypeScript.LineMap = LineMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }

            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }

            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };

        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        return LineAndCharacter;
    })();
    TypeScript.LineAndCharacter = LineAndCharacter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() {
        }
        StringUtilities.isString = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object String]';
        };

        StringUtilities.endsWith = function (string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };

        StringUtilities.startsWith = function (string, value) {
            return string.substr(0, value.length) === value;
        };

        StringUtilities.repeat = function (value, count) {
            return Array(count + 1).join(value);
        };
        return StringUtilities;
    })();
    TypeScript.StringUtilities = StringUtilities;
})(TypeScript || (TypeScript = {}));
var global = Function("return this").call(null);

var TypeScript;
(function (TypeScript) {
    var Clock;
    (function (Clock) {
        Clock.now;
        Clock.resolution;

        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            global['WScript'].InitializeProjection();

            Clock.now = function () {
                return TestUtilities.QueryPerformanceCounter();
            };

            Clock.resolution = TestUtilities.QueryPerformanceFrequency();
        } else {
            Clock.now = function () {
                return Date.now();
            };

            Clock.resolution = 1000;
        }
    })(Clock || (Clock = {}));

    var Timer = (function () {
        function Timer() {
            this.time = 0;
        }
        Timer.prototype.start = function () {
            this.time = 0;
            this.startTime = Clock.now();
        };

        Timer.prototype.end = function () {
            this.time = (Clock.now() - this.startTime);
        };
        return Timer;
    })();
    TypeScript.Timer = Timer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";

        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";

        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";

        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";

        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";

        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";

        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";

        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";

        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";

        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
    var CharacterCodes = TypeScript.CharacterCodes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    

    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
                this._lineStartPositions = null;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };

            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };

            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                if (!this._lineStartPositions) {
                    this._lineStartPositions = TypeScript.TextUtilities.parseLineStarts(this.text);
                }

                return this._lineStartPositions;
            };

            StringScriptSnapshot.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        })();

        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
    var ScriptSnapshot = TypeScript.ScriptSnapshot;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (LineMap1) {
        function fromSimpleText(text) {
            return new TypeScript.LineMap(function () {
                return TypeScript.TextUtilities.parseLineStarts({ charCodeAt: function (index) {
                        return text.charCodeAt(index);
                    }, length: text.length() });
            }, text.length());
        }
        LineMap1.fromSimpleText = fromSimpleText;

        function fromScriptSnapshot(scriptSnapshot) {
            return new TypeScript.LineMap(function () {
                return scriptSnapshot.getLineStartPositions();
            }, scriptSnapshot.getLength());
        }
        LineMap1.fromScriptSnapshot = fromScriptSnapshot;

        function fromString(text) {
            return new TypeScript.LineMap(function () {
                return TypeScript.TextUtilities.parseLineStarts(text);
            }, text.length);
        }
        LineMap1.fromString = fromString;
    })(TypeScript.LineMap1 || (TypeScript.LineMap1 = {}));
    var LineMap1 = TypeScript.LineMap1;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SimpleText) {
        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
                this._lineMap = null;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };

            SimpleStringText.prototype.substr = function (start, length) {
                return this.value.substr(start, length);
            };

            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };

            SimpleStringText.prototype.lineMap = function () {
                if (!this._lineMap) {
                    this._lineMap = TypeScript.LineMap1.fromString(this.value);
                }

                return this._lineMap;
            };
            return SimpleStringText;
        })();

        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
                this._lineMap = null;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };

            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };

            SimpleScriptSnapshotText.prototype.substr = function (start, length) {
                return this.scriptSnapshot.getText(start, start + length);
            };

            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var _this = this;
                if (this._lineMap === null) {
                    this._lineMap = new TypeScript.LineMap(function () {
                        return _this.scriptSnapshot.getLineStartPositions();
                    }, this.length());
                }

                return this._lineMap;
            };
            return SimpleScriptSnapshotText;
        })();

        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;

        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(TypeScript.SimpleText || (TypeScript.SimpleText = {}));
    var SimpleText = TypeScript.SimpleText;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length;

            if (0 === length) {
                var result = new Array();
                result.push(0);
                return result;
            }

            var position = 0;
            var index = 0;
            var arrayBuilder = new Array();
            var lineNumber = 0;

            while (index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;

                if (c > 13 /* carriageReturn */ && c <= 127) {
                    index++;
                    continue;
                } else if (c === 13 /* carriageReturn */ && index + 1 < length && text.charCodeAt(index + 1) === 10 /* lineFeed */) {
                    lineBreakLength = 2;
                } else if (c === 10 /* lineFeed */) {
                    lineBreakLength = 1;
                } else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }

                if (0 === lineBreakLength) {
                    index++;
                } else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }

            arrayBuilder.push(position);

            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;

        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === 13 /* carriageReturn */) {
                var next = index + 1;
                return (next < text.length) && 10 /* lineFeed */ === text.charCodeAt(next) ? 2 : 1;
            } else if (isAnyLineBreakCharacter(c)) {
                return 1;
            } else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;

        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);

            if (c > 13 /* carriageReturn */ && c <= 127) {
                return 0;
            }

            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;

        function isAnyLineBreakCharacter(c) {
            return c === 10 /* lineFeed */ || c === 13 /* carriageReturn */ || c === 133 /* nextLine */ || c === 8232 /* lineSeparator */ || c === 8233 /* paragraphSeparator */;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
    var TextUtilities = TypeScript.TextUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }

            if (length < 0) {
                TypeScript.Errors.argument("length");
            }

            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.start = function () {
            return this._start;
        };

        TextSpan.prototype.length = function () {
            return this._length;
        };

        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };

        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };

        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };

        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };

        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = Math.max(this._start, span._start);
            var overlapEnd = Math.min(this.end(), span.end());

            return overlapStart < overlapEnd;
        };

        TextSpan.prototype.overlap = function (span) {
            var overlapStart = Math.max(this._start, span._start);
            var overlapEnd = Math.min(this.end(), span.end());

            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }

            return null;
        };

        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };

        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };

        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };

        TextSpan.prototype.intersection = function (span) {
            var intersectStart = Math.max(this._start, span._start);
            var intersectEnd = Math.min(this.end(), span.end());

            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }

            return null;
        };

        TextSpan.fromBounds = function (start, end) {
            TypeScript.Debug.assert(start >= 0);
            TypeScript.Debug.assert(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    })();
    TypeScript.TextSpan = TextSpan;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }

            this._span = span;
            this._newLength = newLength;
        }
        TextChangeRange.prototype.span = function () {
            return this._span;
        };

        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };

        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };

        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };

        TextChangeRange.collapseChangesAcrossMultipleVersions = function (changes) {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }

            if (changes.length === 1) {
                return changes[0];
            }

            var change0 = changes[0];

            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();

            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];

                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;

                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();

                oldStartN = Math.min(oldStart1, oldStart2);
                oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }

            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        return TextChangeRange;
    })();
    TypeScript.TextChangeRange = TextChangeRange;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CharacterInfo) {
        function isDecimalDigit(c) {
            return c >= 48 /* _0 */ && c <= 57 /* _9 */;
        }
        CharacterInfo.isDecimalDigit = isDecimalDigit;

        function isOctalDigit(c) {
            return c >= 48 /* _0 */ && c <= 55 /* _7 */;
        }
        CharacterInfo.isOctalDigit = isOctalDigit;

        function isHexDigit(c) {
            return CharacterInfo.isDecimalDigit(c) || (c >= 65 /* A */ && c <= 70 /* F */) || (c >= 97 /* a */ && c <= 102 /* f */);
        }
        CharacterInfo.isHexDigit = isHexDigit;

        function hexValue(c) {
            return CharacterInfo.isDecimalDigit(c) ? (c - 48 /* _0 */) : (c >= 65 /* A */ && c <= 70 /* F */) ? c - 65 /* A */ + 10 : c - 97 /* a */ + 10;
        }
        CharacterInfo.hexValue = hexValue;

        function isWhitespace(ch) {
            switch (ch) {
                case 32 /* space */:
                case 160 /* nonBreakingSpace */:
                case 8192 /* enQuad */:
                case 8193 /* emQuad */:
                case 8194 /* enSpace */:
                case 8195 /* emSpace */:
                case 8196 /* threePerEmSpace */:
                case 8197 /* fourPerEmSpace */:
                case 8198 /* sixPerEmSpace */:
                case 8199 /* figureSpace */:
                case 8200 /* punctuationSpace */:
                case 8201 /* thinSpace */:
                case 8202 /* hairSpace */:
                case 8203 /* zeroWidthSpace */:
                case 8239 /* narrowNoBreakSpace */:
                case 12288 /* ideographicSpace */:

                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 65279 /* byteOrderMark */:
                    return true;
            }

            return false;
        }
        CharacterInfo.isWhitespace = isWhitespace;

        function isLineTerminator(ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
            }

            return false;
        }
        CharacterInfo.isLineTerminator = isLineTerminator;
    })(TypeScript.CharacterInfo || (TypeScript.CharacterInfo = {}));
    var CharacterInfo = TypeScript.CharacterInfo;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxConstants) {
        SyntaxConstants[SyntaxConstants["None"] = 0] = "None";

        SyntaxConstants[SyntaxConstants["NodeDataComputed"] = 0x00000001] = "NodeDataComputed";
        SyntaxConstants[SyntaxConstants["NodeIncrementallyUnusableMask"] = 0x00000002] = "NodeIncrementallyUnusableMask";
        SyntaxConstants[SyntaxConstants["NodeParsedInStrictModeMask"] = 0x00000004] = "NodeParsedInStrictModeMask";
        SyntaxConstants[SyntaxConstants["NodeFullWidthShift"] = 3] = "NodeFullWidthShift";
    })(TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
    var SyntaxConstants = TypeScript.SyntaxConstants;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var FormattingOptions = (function () {
        function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
            this.useTabs = useTabs;
            this.spacesPerTab = spacesPerTab;
            this.indentSpaces = indentSpaces;
            this.newLineCharacter = newLineCharacter;
        }
        FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
        return FormattingOptions;
    })();
    TypeScript.FormattingOptions = FormattingOptions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (LanguageVersion) {
        LanguageVersion[LanguageVersion["EcmaScript3"] = 0] = "EcmaScript3";
        LanguageVersion[LanguageVersion["EcmaScript5"] = 1] = "EcmaScript5";
    })(TypeScript.LanguageVersion || (TypeScript.LanguageVersion = {}));
    var LanguageVersion = TypeScript.LanguageVersion;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["None"] = 0] = "None";
        SyntaxKind[SyntaxKind["List"] = 1] = "List";
        SyntaxKind[SyntaxKind["SeparatedList"] = 2] = "SeparatedList";
        SyntaxKind[SyntaxKind["TriviaList"] = 3] = "TriviaList";

        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 4] = "WhitespaceTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 5] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 6] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 7] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["SkippedTokenTrivia"] = 8] = "SkippedTokenTrivia";

        SyntaxKind[SyntaxKind["ErrorToken"] = 9] = "ErrorToken";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 10] = "EndOfFileToken";

        SyntaxKind[SyntaxKind["IdentifierName"] = 11] = "IdentifierName";

        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 12] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 13] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 14] = "StringLiteral";

        SyntaxKind[SyntaxKind["BreakKeyword"] = 15] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 16] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 17] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 18] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 19] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 20] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 21] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 22] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 23] = "ElseKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 24] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 25] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 26] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 27] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 28] = "IfKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 29] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 30] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 31] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 32] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 33] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 34] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 35] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 36] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 37] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 38] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 39] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 40] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 41] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 42] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 43] = "WithKeyword";

        SyntaxKind[SyntaxKind["ClassKeyword"] = 44] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 45] = "ConstKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 46] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 47] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 48] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 49] = "ImportKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 50] = "SuperKeyword";

        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 51] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 52] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 53] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 54] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 55] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 56] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 57] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 58] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 59] = "YieldKeyword";

        SyntaxKind[SyntaxKind["AnyKeyword"] = 60] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 61] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 62] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 63] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 64] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 65] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 66] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 67] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 68] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 69] = "StringKeyword";

        SyntaxKind[SyntaxKind["OpenBraceToken"] = 70] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 71] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 72] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 73] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 74] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 75] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 76] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 77] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 78] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 79] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 80] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 81] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 82] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 83] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 84] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 85] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 86] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 87] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 88] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 89] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 90] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 91] = "AsteriskToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 92] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 93] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 94] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 95] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 96] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 97] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 98] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 99] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 100] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 101] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 102] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 103] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 104] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 105] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 106] = "ColonToken";
        SyntaxKind[SyntaxKind["EqualsToken"] = 107] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 108] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 109] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 110] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 111] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 112] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 113] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 114] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 115] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 116] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 117] = "CaretEqualsToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 118] = "SlashToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 119] = "SlashEqualsToken";

        SyntaxKind[SyntaxKind["SourceUnit"] = 120] = "SourceUnit";

        SyntaxKind[SyntaxKind["QualifiedName"] = 121] = "QualifiedName";

        SyntaxKind[SyntaxKind["ObjectType"] = 122] = "ObjectType";
        SyntaxKind[SyntaxKind["FunctionType"] = 123] = "FunctionType";
        SyntaxKind[SyntaxKind["ArrayType"] = 124] = "ArrayType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 125] = "ConstructorType";
        SyntaxKind[SyntaxKind["GenericType"] = 126] = "GenericType";
        SyntaxKind[SyntaxKind["TypeQuery"] = 127] = "TypeQuery";
        SyntaxKind[SyntaxKind["TupleType"] = 128] = "TupleType";

        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 129] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 130] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 131] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 132] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 133] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 134] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 135] = "ExportAssignment";

        SyntaxKind[SyntaxKind["MemberFunctionDeclaration"] = 136] = "MemberFunctionDeclaration";
        SyntaxKind[SyntaxKind["MemberVariableDeclaration"] = 137] = "MemberVariableDeclaration";
        SyntaxKind[SyntaxKind["ConstructorDeclaration"] = 138] = "ConstructorDeclaration";
        SyntaxKind[SyntaxKind["IndexMemberDeclaration"] = 139] = "IndexMemberDeclaration";

        SyntaxKind[SyntaxKind["GetAccessor"] = 140] = "GetAccessor";
        SyntaxKind[SyntaxKind["SetAccessor"] = 141] = "SetAccessor";

        SyntaxKind[SyntaxKind["PropertySignature"] = 142] = "PropertySignature";
        SyntaxKind[SyntaxKind["CallSignature"] = 143] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 144] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 145] = "IndexSignature";
        SyntaxKind[SyntaxKind["MethodSignature"] = 146] = "MethodSignature";

        SyntaxKind[SyntaxKind["Block"] = 147] = "Block";
        SyntaxKind[SyntaxKind["IfStatement"] = 148] = "IfStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 149] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 150] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 151] = "ReturnStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 152] = "SwitchStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 153] = "BreakStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 154] = "ContinueStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 155] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 156] = "ForInStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 157] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 158] = "ThrowStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 159] = "WhileStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 160] = "TryStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 161] = "LabeledStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 162] = "DoStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 163] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 164] = "WithStatement";

        SyntaxKind[SyntaxKind["PlusExpression"] = 165] = "PlusExpression";
        SyntaxKind[SyntaxKind["NegateExpression"] = 166] = "NegateExpression";
        SyntaxKind[SyntaxKind["BitwiseNotExpression"] = 167] = "BitwiseNotExpression";
        SyntaxKind[SyntaxKind["LogicalNotExpression"] = 168] = "LogicalNotExpression";
        SyntaxKind[SyntaxKind["PreIncrementExpression"] = 169] = "PreIncrementExpression";
        SyntaxKind[SyntaxKind["PreDecrementExpression"] = 170] = "PreDecrementExpression";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 171] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 172] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 173] = "VoidExpression";
        SyntaxKind[SyntaxKind["CommaExpression"] = 174] = "CommaExpression";
        SyntaxKind[SyntaxKind["AssignmentExpression"] = 175] = "AssignmentExpression";
        SyntaxKind[SyntaxKind["AddAssignmentExpression"] = 176] = "AddAssignmentExpression";
        SyntaxKind[SyntaxKind["SubtractAssignmentExpression"] = 177] = "SubtractAssignmentExpression";
        SyntaxKind[SyntaxKind["MultiplyAssignmentExpression"] = 178] = "MultiplyAssignmentExpression";
        SyntaxKind[SyntaxKind["DivideAssignmentExpression"] = 179] = "DivideAssignmentExpression";
        SyntaxKind[SyntaxKind["ModuloAssignmentExpression"] = 180] = "ModuloAssignmentExpression";
        SyntaxKind[SyntaxKind["AndAssignmentExpression"] = 181] = "AndAssignmentExpression";
        SyntaxKind[SyntaxKind["ExclusiveOrAssignmentExpression"] = 182] = "ExclusiveOrAssignmentExpression";
        SyntaxKind[SyntaxKind["OrAssignmentExpression"] = 183] = "OrAssignmentExpression";
        SyntaxKind[SyntaxKind["LeftShiftAssignmentExpression"] = 184] = "LeftShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftAssignmentExpression"] = 185] = "SignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftAssignmentExpression"] = 186] = "UnsignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 187] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["LogicalOrExpression"] = 188] = "LogicalOrExpression";
        SyntaxKind[SyntaxKind["LogicalAndExpression"] = 189] = "LogicalAndExpression";
        SyntaxKind[SyntaxKind["BitwiseOrExpression"] = 190] = "BitwiseOrExpression";
        SyntaxKind[SyntaxKind["BitwiseExclusiveOrExpression"] = 191] = "BitwiseExclusiveOrExpression";
        SyntaxKind[SyntaxKind["BitwiseAndExpression"] = 192] = "BitwiseAndExpression";
        SyntaxKind[SyntaxKind["EqualsWithTypeConversionExpression"] = 193] = "EqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["NotEqualsWithTypeConversionExpression"] = 194] = "NotEqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["EqualsExpression"] = 195] = "EqualsExpression";
        SyntaxKind[SyntaxKind["NotEqualsExpression"] = 196] = "NotEqualsExpression";
        SyntaxKind[SyntaxKind["LessThanExpression"] = 197] = "LessThanExpression";
        SyntaxKind[SyntaxKind["GreaterThanExpression"] = 198] = "GreaterThanExpression";
        SyntaxKind[SyntaxKind["LessThanOrEqualExpression"] = 199] = "LessThanOrEqualExpression";
        SyntaxKind[SyntaxKind["GreaterThanOrEqualExpression"] = 200] = "GreaterThanOrEqualExpression";
        SyntaxKind[SyntaxKind["InstanceOfExpression"] = 201] = "InstanceOfExpression";
        SyntaxKind[SyntaxKind["InExpression"] = 202] = "InExpression";
        SyntaxKind[SyntaxKind["LeftShiftExpression"] = 203] = "LeftShiftExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftExpression"] = 204] = "SignedRightShiftExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftExpression"] = 205] = "UnsignedRightShiftExpression";
        SyntaxKind[SyntaxKind["MultiplyExpression"] = 206] = "MultiplyExpression";
        SyntaxKind[SyntaxKind["DivideExpression"] = 207] = "DivideExpression";
        SyntaxKind[SyntaxKind["ModuloExpression"] = 208] = "ModuloExpression";
        SyntaxKind[SyntaxKind["AddExpression"] = 209] = "AddExpression";
        SyntaxKind[SyntaxKind["SubtractExpression"] = 210] = "SubtractExpression";
        SyntaxKind[SyntaxKind["PostIncrementExpression"] = 211] = "PostIncrementExpression";
        SyntaxKind[SyntaxKind["PostDecrementExpression"] = 212] = "PostDecrementExpression";
        SyntaxKind[SyntaxKind["MemberAccessExpression"] = 213] = "MemberAccessExpression";
        SyntaxKind[SyntaxKind["InvocationExpression"] = 214] = "InvocationExpression";
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 215] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 216] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectCreationExpression"] = 217] = "ObjectCreationExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 218] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["ParenthesizedArrowFunctionExpression"] = 219] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind[SyntaxKind["SimpleArrowFunctionExpression"] = 220] = "SimpleArrowFunctionExpression";
        SyntaxKind[SyntaxKind["CastExpression"] = 221] = "CastExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 222] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 223] = "FunctionExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 224] = "OmittedExpression";

        SyntaxKind[SyntaxKind["VariableDeclaration"] = 225] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarator"] = 226] = "VariableDeclarator";

        SyntaxKind[SyntaxKind["ArgumentList"] = 227] = "ArgumentList";
        SyntaxKind[SyntaxKind["ParameterList"] = 228] = "ParameterList";
        SyntaxKind[SyntaxKind["TypeArgumentList"] = 229] = "TypeArgumentList";
        SyntaxKind[SyntaxKind["TypeParameterList"] = 230] = "TypeParameterList";

        SyntaxKind[SyntaxKind["ExtendsHeritageClause"] = 231] = "ExtendsHeritageClause";
        SyntaxKind[SyntaxKind["ImplementsHeritageClause"] = 232] = "ImplementsHeritageClause";
        SyntaxKind[SyntaxKind["EqualsValueClause"] = 233] = "EqualsValueClause";
        SyntaxKind[SyntaxKind["CaseSwitchClause"] = 234] = "CaseSwitchClause";
        SyntaxKind[SyntaxKind["DefaultSwitchClause"] = 235] = "DefaultSwitchClause";
        SyntaxKind[SyntaxKind["ElseClause"] = 236] = "ElseClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 237] = "CatchClause";
        SyntaxKind[SyntaxKind["FinallyClause"] = 238] = "FinallyClause";

        SyntaxKind[SyntaxKind["TypeParameter"] = 239] = "TypeParameter";
        SyntaxKind[SyntaxKind["Constraint"] = 240] = "Constraint";

        SyntaxKind[SyntaxKind["SimplePropertyAssignment"] = 241] = "SimplePropertyAssignment";

        SyntaxKind[SyntaxKind["FunctionPropertyAssignment"] = 242] = "FunctionPropertyAssignment";

        SyntaxKind[SyntaxKind["Parameter"] = 243] = "Parameter";
        SyntaxKind[SyntaxKind["EnumElement"] = 244] = "EnumElement";
        SyntaxKind[SyntaxKind["TypeAnnotation"] = 245] = "TypeAnnotation";
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 246] = "ExternalModuleReference";
        SyntaxKind[SyntaxKind["ModuleNameModuleReference"] = 247] = "ModuleNameModuleReference";

        SyntaxKind[SyntaxKind["FirstStandardKeyword"] = SyntaxKind.BreakKeyword] = "FirstStandardKeyword";
        SyntaxKind[SyntaxKind["LastStandardKeyword"] = SyntaxKind.WithKeyword] = "LastStandardKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedKeyword"] = SyntaxKind.ClassKeyword] = "FirstFutureReservedKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedKeyword"] = SyntaxKind.SuperKeyword] = "LastFutureReservedKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedStrictKeyword"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedStrictKeyword"] = SyntaxKind.YieldKeyword] = "LastFutureReservedStrictKeyword";

        SyntaxKind[SyntaxKind["FirstTypeScriptKeyword"] = SyntaxKind.AnyKeyword] = "FirstTypeScriptKeyword";
        SyntaxKind[SyntaxKind["LastTypeScriptKeyword"] = SyntaxKind.StringKeyword] = "LastTypeScriptKeyword";

        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.FirstStandardKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.LastTypeScriptKeyword] = "LastKeyword";

        SyntaxKind[SyntaxKind["FirstToken"] = SyntaxKind.ErrorToken] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = SyntaxKind.SlashEqualsToken] = "LastToken";

        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.SlashEqualsToken] = "LastPunctuation";

        SyntaxKind[SyntaxKind["FirstFixedWidth"] = SyntaxKind.FirstKeyword] = "FirstFixedWidth";
        SyntaxKind[SyntaxKind["LastFixedWidth"] = SyntaxKind.LastPunctuation] = "LastFixedWidth";

        SyntaxKind[SyntaxKind["FirstTrivia"] = SyntaxKind.WhitespaceTrivia] = "FirstTrivia";
        SyntaxKind[SyntaxKind["LastTrivia"] = SyntaxKind.SkippedTokenTrivia] = "LastTrivia";

        SyntaxKind[SyntaxKind["FirstNode"] = SyntaxKind.SourceUnit] = "FirstNode";
        SyntaxKind[SyntaxKind["LastNode"] = SyntaxKind.ModuleNameModuleReference] = "LastNode";
    })(TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
    var SyntaxKind = TypeScript.SyntaxKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": 60 /* AnyKeyword */,
            "boolean": 61 /* BooleanKeyword */,
            "break": 15 /* BreakKeyword */,
            "case": 16 /* CaseKeyword */,
            "catch": 17 /* CatchKeyword */,
            "class": 44 /* ClassKeyword */,
            "continue": 18 /* ContinueKeyword */,
            "const": 45 /* ConstKeyword */,
            "constructor": 62 /* ConstructorKeyword */,
            "debugger": 19 /* DebuggerKeyword */,
            "declare": 63 /* DeclareKeyword */,
            "default": 20 /* DefaultKeyword */,
            "delete": 21 /* DeleteKeyword */,
            "do": 22 /* DoKeyword */,
            "else": 23 /* ElseKeyword */,
            "enum": 46 /* EnumKeyword */,
            "export": 47 /* ExportKeyword */,
            "extends": 48 /* ExtendsKeyword */,
            "false": 24 /* FalseKeyword */,
            "finally": 25 /* FinallyKeyword */,
            "for": 26 /* ForKeyword */,
            "function": 27 /* FunctionKeyword */,
            "get": 64 /* GetKeyword */,
            "if": 28 /* IfKeyword */,
            "implements": 51 /* ImplementsKeyword */,
            "import": 49 /* ImportKeyword */,
            "in": 29 /* InKeyword */,
            "instanceof": 30 /* InstanceOfKeyword */,
            "interface": 52 /* InterfaceKeyword */,
            "let": 53 /* LetKeyword */,
            "module": 65 /* ModuleKeyword */,
            "new": 31 /* NewKeyword */,
            "null": 32 /* NullKeyword */,
            "number": 67 /* NumberKeyword */,
            "package": 54 /* PackageKeyword */,
            "private": 55 /* PrivateKeyword */,
            "protected": 56 /* ProtectedKeyword */,
            "public": 57 /* PublicKeyword */,
            "require": 66 /* RequireKeyword */,
            "return": 33 /* ReturnKeyword */,
            "set": 68 /* SetKeyword */,
            "static": 58 /* StaticKeyword */,
            "string": 69 /* StringKeyword */,
            "super": 50 /* SuperKeyword */,
            "switch": 34 /* SwitchKeyword */,
            "this": 35 /* ThisKeyword */,
            "throw": 36 /* ThrowKeyword */,
            "true": 37 /* TrueKeyword */,
            "try": 38 /* TryKeyword */,
            "typeof": 39 /* TypeOfKeyword */,
            "var": 40 /* VarKeyword */,
            "void": 41 /* VoidKeyword */,
            "while": 42 /* WhileKeyword */,
            "with": 43 /* WithKeyword */,
            "yield": 59 /* YieldKeyword */,
            "{": 70 /* OpenBraceToken */,
            "}": 71 /* CloseBraceToken */,
            "(": 72 /* OpenParenToken */,
            ")": 73 /* CloseParenToken */,
            "[": 74 /* OpenBracketToken */,
            "]": 75 /* CloseBracketToken */,
            ".": 76 /* DotToken */,
            "...": 77 /* DotDotDotToken */,
            ";": 78 /* SemicolonToken */,
            ",": 79 /* CommaToken */,
            "<": 80 /* LessThanToken */,
            ">": 81 /* GreaterThanToken */,
            "<=": 82 /* LessThanEqualsToken */,
            ">=": 83 /* GreaterThanEqualsToken */,
            "==": 84 /* EqualsEqualsToken */,
            "=>": 85 /* EqualsGreaterThanToken */,
            "!=": 86 /* ExclamationEqualsToken */,
            "===": 87 /* EqualsEqualsEqualsToken */,
            "!==": 88 /* ExclamationEqualsEqualsToken */,
            "+": 89 /* PlusToken */,
            "-": 90 /* MinusToken */,
            "*": 91 /* AsteriskToken */,
            "%": 92 /* PercentToken */,
            "++": 93 /* PlusPlusToken */,
            "--": 94 /* MinusMinusToken */,
            "<<": 95 /* LessThanLessThanToken */,
            ">>": 96 /* GreaterThanGreaterThanToken */,
            ">>>": 97 /* GreaterThanGreaterThanGreaterThanToken */,
            "&": 98 /* AmpersandToken */,
            "|": 99 /* BarToken */,
            "^": 100 /* CaretToken */,
            "!": 101 /* ExclamationToken */,
            "~": 102 /* TildeToken */,
            "&&": 103 /* AmpersandAmpersandToken */,
            "||": 104 /* BarBarToken */,
            "?": 105 /* QuestionToken */,
            ":": 106 /* ColonToken */,
            "=": 107 /* EqualsToken */,
            "+=": 108 /* PlusEqualsToken */,
            "-=": 109 /* MinusEqualsToken */,
            "*=": 110 /* AsteriskEqualsToken */,
            "%=": 111 /* PercentEqualsToken */,
            "<<=": 112 /* LessThanLessThanEqualsToken */,
            ">>=": 113 /* GreaterThanGreaterThanEqualsToken */,
            ">>>=": 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
            "&=": 115 /* AmpersandEqualsToken */,
            "|=": 116 /* BarEqualsToken */,
            "^=": 117 /* CaretEqualsToken */,
            "/": 118 /* SlashToken */,
            "/=": 119 /* SlashEqualsToken */
        };

        var kindToText = new Array();

        for (var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                kindToText[textToKeywordKind[name]] = name;
            }
        }

        kindToText[62 /* ConstructorKeyword */] = "constructor";

        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }

            return 0 /* None */;
        }
        SyntaxFacts.getTokenKind = getTokenKind;

        function getText(kind) {
            var result = kindToText[kind];
            return result !== undefined ? result : null;
        }
        SyntaxFacts.getText = getText;

        function isAnyKeyword(kind) {
            return kind >= 15 /* FirstKeyword */ && kind <= 69 /* LastKeyword */;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;

        function isAnyPunctuation(kind) {
            return kind >= 70 /* FirstPunctuation */ && kind <= 119 /* LastPunctuation */;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;

        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;

        function isBinaryExpressionOperatorToken(tokenKind) {
            return getBinaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;

        function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 89 /* PlusToken */: return 165 /* PlusExpression */;
                case 90 /* MinusToken */: return 166 /* NegateExpression */;
                case 102 /* TildeToken */: return 167 /* BitwiseNotExpression */;
                case 101 /* ExclamationToken */: return 168 /* LogicalNotExpression */;
                case 93 /* PlusPlusToken */: return 169 /* PreIncrementExpression */;
                case 94 /* MinusMinusToken */: return 170 /* PreDecrementExpression */;
                default: return 0 /* None */;
            }
        }
        SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;

        function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 93 /* PlusPlusToken */: return 211 /* PostIncrementExpression */;
                case 94 /* MinusMinusToken */: return 212 /* PostDecrementExpression */;
                default: return 0 /* None */;
            }
        }
        SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;

        function getBinaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 91 /* AsteriskToken */: return 206 /* MultiplyExpression */;
                case 118 /* SlashToken */: return 207 /* DivideExpression */;
                case 92 /* PercentToken */: return 208 /* ModuloExpression */;
                case 89 /* PlusToken */: return 209 /* AddExpression */;
                case 90 /* MinusToken */: return 210 /* SubtractExpression */;
                case 95 /* LessThanLessThanToken */: return 203 /* LeftShiftExpression */;
                case 96 /* GreaterThanGreaterThanToken */: return 204 /* SignedRightShiftExpression */;
                case 97 /* GreaterThanGreaterThanGreaterThanToken */: return 205 /* UnsignedRightShiftExpression */;
                case 80 /* LessThanToken */: return 197 /* LessThanExpression */;
                case 81 /* GreaterThanToken */: return 198 /* GreaterThanExpression */;
                case 82 /* LessThanEqualsToken */: return 199 /* LessThanOrEqualExpression */;
                case 83 /* GreaterThanEqualsToken */: return 200 /* GreaterThanOrEqualExpression */;
                case 30 /* InstanceOfKeyword */: return 201 /* InstanceOfExpression */;
                case 29 /* InKeyword */: return 202 /* InExpression */;
                case 84 /* EqualsEqualsToken */: return 193 /* EqualsWithTypeConversionExpression */;
                case 86 /* ExclamationEqualsToken */: return 194 /* NotEqualsWithTypeConversionExpression */;
                case 87 /* EqualsEqualsEqualsToken */: return 195 /* EqualsExpression */;
                case 88 /* ExclamationEqualsEqualsToken */: return 196 /* NotEqualsExpression */;
                case 98 /* AmpersandToken */: return 192 /* BitwiseAndExpression */;
                case 100 /* CaretToken */: return 191 /* BitwiseExclusiveOrExpression */;
                case 99 /* BarToken */: return 190 /* BitwiseOrExpression */;
                case 103 /* AmpersandAmpersandToken */: return 189 /* LogicalAndExpression */;
                case 104 /* BarBarToken */: return 188 /* LogicalOrExpression */;
                case 116 /* BarEqualsToken */: return 183 /* OrAssignmentExpression */;
                case 115 /* AmpersandEqualsToken */: return 181 /* AndAssignmentExpression */;
                case 117 /* CaretEqualsToken */: return 182 /* ExclusiveOrAssignmentExpression */;
                case 112 /* LessThanLessThanEqualsToken */: return 184 /* LeftShiftAssignmentExpression */;
                case 113 /* GreaterThanGreaterThanEqualsToken */: return 185 /* SignedRightShiftAssignmentExpression */;
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */: return 186 /* UnsignedRightShiftAssignmentExpression */;
                case 108 /* PlusEqualsToken */: return 176 /* AddAssignmentExpression */;
                case 109 /* MinusEqualsToken */: return 177 /* SubtractAssignmentExpression */;
                case 110 /* AsteriskEqualsToken */: return 178 /* MultiplyAssignmentExpression */;
                case 119 /* SlashEqualsToken */: return 179 /* DivideAssignmentExpression */;
                case 111 /* PercentEqualsToken */: return 180 /* ModuloAssignmentExpression */;
                case 107 /* EqualsToken */: return 175 /* AssignmentExpression */;
                case 79 /* CommaToken */: return 174 /* CommaExpression */;
                default: return 0 /* None */;
            }
        }
        SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;

        function getOperatorTokenFromBinaryExpression(tokenKind) {
            switch (tokenKind) {
                case 206 /* MultiplyExpression */: return 91 /* AsteriskToken */;
                case 207 /* DivideExpression */: return 118 /* SlashToken */;
                case 208 /* ModuloExpression */: return 92 /* PercentToken */;
                case 209 /* AddExpression */: return 89 /* PlusToken */;
                case 210 /* SubtractExpression */: return 90 /* MinusToken */;
                case 203 /* LeftShiftExpression */: return 95 /* LessThanLessThanToken */;
                case 204 /* SignedRightShiftExpression */: return 96 /* GreaterThanGreaterThanToken */;
                case 205 /* UnsignedRightShiftExpression */: return 97 /* GreaterThanGreaterThanGreaterThanToken */;
                case 197 /* LessThanExpression */: return 80 /* LessThanToken */;
                case 198 /* GreaterThanExpression */: return 81 /* GreaterThanToken */;
                case 199 /* LessThanOrEqualExpression */: return 82 /* LessThanEqualsToken */;
                case 200 /* GreaterThanOrEqualExpression */: return 83 /* GreaterThanEqualsToken */;
                case 201 /* InstanceOfExpression */: return 30 /* InstanceOfKeyword */;
                case 202 /* InExpression */: return 29 /* InKeyword */;
                case 193 /* EqualsWithTypeConversionExpression */: return 84 /* EqualsEqualsToken */;
                case 194 /* NotEqualsWithTypeConversionExpression */: return 86 /* ExclamationEqualsToken */;
                case 195 /* EqualsExpression */: return 87 /* EqualsEqualsEqualsToken */;
                case 196 /* NotEqualsExpression */: return 88 /* ExclamationEqualsEqualsToken */;
                case 192 /* BitwiseAndExpression */: return 98 /* AmpersandToken */;
                case 191 /* BitwiseExclusiveOrExpression */: return 100 /* CaretToken */;
                case 190 /* BitwiseOrExpression */: return 99 /* BarToken */;
                case 189 /* LogicalAndExpression */: return 103 /* AmpersandAmpersandToken */;
                case 188 /* LogicalOrExpression */: return 104 /* BarBarToken */;
                case 183 /* OrAssignmentExpression */: return 116 /* BarEqualsToken */;
                case 181 /* AndAssignmentExpression */: return 115 /* AmpersandEqualsToken */;
                case 182 /* ExclusiveOrAssignmentExpression */: return 117 /* CaretEqualsToken */;
                case 184 /* LeftShiftAssignmentExpression */: return 112 /* LessThanLessThanEqualsToken */;
                case 185 /* SignedRightShiftAssignmentExpression */: return 113 /* GreaterThanGreaterThanEqualsToken */;
                case 186 /* UnsignedRightShiftAssignmentExpression */: return 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                case 176 /* AddAssignmentExpression */: return 108 /* PlusEqualsToken */;
                case 177 /* SubtractAssignmentExpression */: return 109 /* MinusEqualsToken */;
                case 178 /* MultiplyAssignmentExpression */: return 110 /* AsteriskEqualsToken */;
                case 179 /* DivideAssignmentExpression */: return 119 /* SlashEqualsToken */;
                case 180 /* ModuloAssignmentExpression */: return 111 /* PercentEqualsToken */;
                case 175 /* AssignmentExpression */: return 107 /* EqualsToken */;
                case 174 /* CommaExpression */: return 79 /* CommaToken */;
                default: return 0 /* None */;
            }
        }
        SyntaxFacts.getOperatorTokenFromBinaryExpression = getOperatorTokenFromBinaryExpression;

        function isAssignmentOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 116 /* BarEqualsToken */:
                case 115 /* AmpersandEqualsToken */:
                case 117 /* CaretEqualsToken */:
                case 112 /* LessThanLessThanEqualsToken */:
                case 113 /* GreaterThanGreaterThanEqualsToken */:
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 108 /* PlusEqualsToken */:
                case 109 /* MinusEqualsToken */:
                case 110 /* AsteriskEqualsToken */:
                case 119 /* SlashEqualsToken */:
                case 111 /* PercentEqualsToken */:
                case 107 /* EqualsToken */:
                    return true;

                default:
                    return false;
            }
        }
        SyntaxFacts.isAssignmentOperatorToken = isAssignmentOperatorToken;

        function isType(kind) {
            switch (kind) {
                case 124 /* ArrayType */:
                case 60 /* AnyKeyword */:
                case 67 /* NumberKeyword */:
                case 61 /* BooleanKeyword */:
                case 69 /* StringKeyword */:
                case 41 /* VoidKeyword */:
                case 123 /* FunctionType */:
                case 122 /* ObjectType */:
                case 125 /* ConstructorType */:
                case 127 /* TypeQuery */:
                case 126 /* GenericType */:
                case 121 /* QualifiedName */:
                case 11 /* IdentifierName */:
                    return true;
            }

            return false;
        }
        SyntaxFacts.isType = isType;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Scanner) {
        TypeScript.Debug.assert(119 /* LastToken */ <= 127);

        var ScannerConstants;
        (function (ScannerConstants) {
            ScannerConstants[ScannerConstants["LargeTokenFullStartShift"] = 4] = "LargeTokenFullStartShift";
            ScannerConstants[ScannerConstants["LargeTokenFullWidthShift"] = 7] = "LargeTokenFullWidthShift";
            ScannerConstants[ScannerConstants["LargeTokenLeadingTriviaBitMask"] = 0x01] = "LargeTokenLeadingTriviaBitMask";
            ScannerConstants[ScannerConstants["LargeTokenLeadingCommentBitMask"] = 0x02] = "LargeTokenLeadingCommentBitMask";
            ScannerConstants[ScannerConstants["LargeTokenTrailingTriviaBitMask"] = 0x04] = "LargeTokenTrailingTriviaBitMask";
            ScannerConstants[ScannerConstants["LargeTokenTrailingCommentBitMask"] = 0x08] = "LargeTokenTrailingCommentBitMask";
            ScannerConstants[ScannerConstants["LargeTokenTriviaBitMask"] = 0x0F] = "LargeTokenTriviaBitMask";

            ScannerConstants[ScannerConstants["FixedWidthTokenFullStartShift"] = 7] = "FixedWidthTokenFullStartShift";
            ScannerConstants[ScannerConstants["FixedWidthTokenMaxFullStart"] = 0x7FFFFF] = "FixedWidthTokenMaxFullStart";

            ScannerConstants[ScannerConstants["SmallTokenFullWidthShift"] = 7] = "SmallTokenFullWidthShift";
            ScannerConstants[ScannerConstants["SmallTokenFullStartShift"] = 12] = "SmallTokenFullStartShift";
            ScannerConstants[ScannerConstants["SmallTokenMaxFullStart"] = 0x3FFFF] = "SmallTokenMaxFullStart";
            ScannerConstants[ScannerConstants["SmallTokenMaxFullWidth"] = 0x1F] = "SmallTokenMaxFullWidth";
            ScannerConstants[ScannerConstants["SmallTokenFullWidthMask"] = 0x1F] = "SmallTokenFullWidthMask";

            ScannerConstants[ScannerConstants["KindMask"] = 0x7F] = "KindMask";
            ScannerConstants[ScannerConstants["IsVariableWidthMask"] = 0x80] = "IsVariableWidthMask";
        })(ScannerConstants || (ScannerConstants = {}));

        TypeScript.Debug.assert(largeTokenUnpackFullStart(largeTokenPackFullStartAndInfo(1 << 26, 3)) === (1 << 26));
        TypeScript.Debug.assert(largeTokenUnpackFullStart(largeTokenPackFullStartAndInfo(3 << 25, 1)) === (3 << 25));
        TypeScript.Debug.assert(largeTokenUnpackFullStart(largeTokenPackFullStartAndInfo(10 << 23, 2)) === (10 << 23));

        function fixedWidthTokenPackData(fullStart, kind) {
            return (fullStart << 7 /* FixedWidthTokenFullStartShift */) | kind;
        }

        function fixedWidthTokenUnpackFullStart(packedData) {
            return packedData >> 7 /* FixedWidthTokenFullStartShift */;
        }

        function smallTokenPackData(fullStart, fullWidth, kind) {
            return (fullStart << 12 /* SmallTokenFullStartShift */) | (fullWidth << 7 /* SmallTokenFullWidthShift */) | kind;
        }

        function smallTokenUnpackFullWidth(packedData) {
            return (packedData >> 7 /* SmallTokenFullWidthShift */) & 31 /* SmallTokenFullWidthMask */;
        }

        function smallTokenUnpackFullStart(packedData) {
            return packedData >> 12 /* SmallTokenFullStartShift */;
        }

        function largeTokenPackFullStartAndInfo(fullStart, triviaInfo) {
            return (fullStart << 4 /* LargeTokenFullStartShift */) | triviaInfo;
        }

        function largeTokenUnpackFullWidth(packedFullWidthAndKind) {
            return packedFullWidthAndKind >> 7 /* LargeTokenFullWidthShift */;
        }

        function largeTokenUnpackFullStart(packedFullStartAndInfo) {
            return packedFullStartAndInfo >> 4 /* LargeTokenFullStartShift */;
        }

        function largeTokenUnpackHasLeadingTrivia(packed) {
            return (packed & 1 /* LargeTokenLeadingTriviaBitMask */) !== 0;
        }

        function largeTokenUnpackHasTrailingTrivia(packed) {
            return (packed & 4 /* LargeTokenTrailingTriviaBitMask */) !== 0;
        }

        function largeTokenUnpackHasLeadingComment(packed) {
            return (packed & 2 /* LargeTokenLeadingCommentBitMask */) !== 0;
        }

        function largeTokenUnpackHasTrailingComment(packed) {
            return (packed & 8 /* LargeTokenTrailingCommentBitMask */) !== 0;
        }

        function largeTokenUnpackTriviaInfo(packed) {
            return packed & 15 /* LargeTokenTriviaBitMask */;
        }

        var isKeywordStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, 0);
        var isIdentifierStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
        var isIdentifierPartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);

        for (var character = 0; character < 127 /* maxAsciiCharacter */; character++) {
            if ((character >= 97 /* a */ && character <= 122 /* z */) || (character >= 65 /* A */ && character <= 90 /* Z */) || character === 95 /* _ */ || character === 36 /* $ */) {
                isIdentifierStartCharacter[character] = true;
                isIdentifierPartCharacter[character] = true;
            } else if (character >= 48 /* _0 */ && character <= 57 /* _9 */) {
                isIdentifierPartCharacter[character] = true;
            }
        }

        for (var keywordKind = 15 /* FirstKeyword */; keywordKind <= 69 /* LastKeyword */; keywordKind++) {
            var keyword = TypeScript.SyntaxFacts.getText(keywordKind);
            isKeywordStartCharacter[keyword.charCodeAt(0)] = 1;
        }

        function isContextualToken(token) {
            switch (token.kind()) {
                case 12 /* RegularExpressionLiteral */:

                case 96 /* GreaterThanGreaterThanToken */:
                case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                case 83 /* GreaterThanEqualsToken */:
                case 113 /* GreaterThanGreaterThanEqualsToken */:
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return true;

                default:
                    return token.isKeywordConvertedToIdentifier();
            }
        }
        Scanner.isContextualToken = isContextualToken;

        var lastTokenInfo = { leadingTriviaWidth: -1, width: -1 };
        var lastTokenInfoTokenID = -1;

        var triviaScanner = createScannerInternal(1 /* EcmaScript5 */, TypeScript.SimpleText.fromString(""), function () {
        });

        function fillSizeInfo(token, text) {
            if (lastTokenInfoTokenID !== TypeScript.syntaxID(token)) {
                triviaScanner.fillTokenInfo(token, text, lastTokenInfo);
                lastTokenInfoTokenID = TypeScript.syntaxID(token);
            }
        }

        function fullText(token, text) {
            return text.substr(token.fullStart(), token.fullWidth());
        }

        function leadingTrivia(token, text) {
            if (!token.hasLeadingTrivia()) {
                return TypeScript.Syntax.emptyTriviaList;
            }

            return triviaScanner.scanTrivia(token, text, false);
        }

        function trailingTrivia(token, text) {
            if (!token.hasTrailingTrivia()) {
                return TypeScript.Syntax.emptyTriviaList;
            }

            return triviaScanner.scanTrivia(token, text, true);
        }

        function leadingTriviaWidth(token, text) {
            if (!token.hasLeadingTrivia()) {
                return 0;
            }

            fillSizeInfo(token, text);
            return lastTokenInfo.leadingTriviaWidth;
        }

        function trailingTriviaWidth(token, text) {
            if (!token.hasTrailingTrivia()) {
                return 0;
            }

            fillSizeInfo(token, text);
            return token.fullWidth() - lastTokenInfo.leadingTriviaWidth - lastTokenInfo.width;
        }

        function tokenIsIncrementallyUnusable(token) {
            return false;
        }

        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(_packedData) {
                this._packedData = _packedData;
            }
            FixedWidthTokenWithNoTrivia.prototype.setFullStart = function (fullStart) {
                this._packedData = fixedWidthTokenPackData(fullStart, this.kind());
            };

            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
                return TypeScript.SyntaxFacts.getText(this.kind());
            };
            FixedWidthTokenWithNoTrivia.prototype.text = function () {
                return this.fullText();
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };

            FixedWidthTokenWithNoTrivia.prototype.kind = function () {
                return this._packedData & 127 /* KindMask */;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullStart = function () {
                return fixedWidthTokenUnpackFullStart(this._packedData);
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this._packedData);
            };
            return FixedWidthTokenWithNoTrivia;
        })();

        var LargeScannerToken = (function () {
            function LargeScannerToken(_packedFullStartAndInfo, _packedFullWidthAndKind, cachedText) {
                this._packedFullStartAndInfo = _packedFullStartAndInfo;
                this._packedFullWidthAndKind = _packedFullWidthAndKind;
                if (cachedText !== undefined) {
                    this.cachedText = cachedText;
                }
            }
            LargeScannerToken.prototype.setFullStart = function (fullStart) {
                this._packedFullStartAndInfo = largeTokenPackFullStartAndInfo(fullStart, largeTokenUnpackTriviaInfo(this._packedFullStartAndInfo));
            };

            LargeScannerToken.prototype.syntaxTreeText = function (text) {
                var result = text || TypeScript.syntaxTree(this).text;
                TypeScript.Debug.assert(result);
                return result;
            };

            LargeScannerToken.prototype.isIncrementallyUnusable = function () {
                return tokenIsIncrementallyUnusable(this);
            };
            LargeScannerToken.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            LargeScannerToken.prototype.hasSkippedToken = function () {
                return false;
            };

            LargeScannerToken.prototype.fullText = function (text) {
                return fullText(this, this.syntaxTreeText(text));
            };

            LargeScannerToken.prototype.text = function () {
                var cachedText = this.cachedText;
                return cachedText !== undefined ? cachedText : TypeScript.SyntaxFacts.getText(this.kind());
            };

            LargeScannerToken.prototype.leadingTrivia = function (text) {
                return leadingTrivia(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.trailingTrivia = function (text) {
                return trailingTrivia(this, this.syntaxTreeText(text));
            };

            LargeScannerToken.prototype.leadingTriviaWidth = function (text) {
                return leadingTriviaWidth(this, this.syntaxTreeText(text));
            };

            LargeScannerToken.prototype.trailingTriviaWidth = function (text) {
                return trailingTriviaWidth(this, this.syntaxTreeText(text));
            };

            LargeScannerToken.prototype.kind = function () {
                return this._packedFullWidthAndKind & 127 /* KindMask */;
            };
            LargeScannerToken.prototype.fullWidth = function () {
                return largeTokenUnpackFullWidth(this._packedFullWidthAndKind);
            };
            LargeScannerToken.prototype.fullStart = function () {
                return largeTokenUnpackFullStart(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasLeadingTrivia = function () {
                return largeTokenUnpackHasLeadingTrivia(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasTrailingTrivia = function () {
                return largeTokenUnpackHasTrailingTrivia(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasLeadingComment = function () {
                return largeTokenUnpackHasLeadingComment(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasTrailingComment = function () {
                return largeTokenUnpackHasTrailingComment(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.clone = function () {
                return new LargeScannerToken(this._packedFullStartAndInfo, this._packedFullWidthAndKind, this.cachedText);
            };
            return LargeScannerToken;
        })();

        function createScanner(languageVersion, text, reportDiagnostic) {
            var scanner = createScannerInternal(languageVersion, text, reportDiagnostic);
            return {
                setIndex: scanner.setIndex,
                scan: scanner.scan
            };
        }
        Scanner.createScanner = createScanner;

        function createScannerInternal(languageVersion, text, reportDiagnostic) {
            var str;
            var index;
            var start;
            var end;

            function setIndex(_index) {
                index = _index;
            }

            function reset(_text, _start, _end) {
                TypeScript.Debug.assert(_start <= _text.length());
                TypeScript.Debug.assert(_end <= _text.length());

                if (!str || text !== _text) {
                    text = _text;
                    str = _text.substr(0, _text.length());
                }

                start = _start;
                end = _end;
                index = _start;
            }

            function scan(allowContextualToken) {
                var fullStart = index;
                var leadingTriviaInfo = scanTriviaInfo(false);

                var start = index;
                var kindAndIsVariableWidth = scanSyntaxKind(allowContextualToken);

                var end = index;
                var trailingTriviaInfo = scanTriviaInfo(true);

                var fullWidth = index - fullStart;

                var kind = kindAndIsVariableWidth & 127 /* KindMask */;
                var isFixedWidth = kind >= 15 /* FirstFixedWidth */ && kind <= 119 /* LastFixedWidth */ && ((kindAndIsVariableWidth & 128 /* IsVariableWidthMask */) === 0);

                if (isFixedWidth && leadingTriviaInfo === 0 && trailingTriviaInfo === 0 && fullStart <= 8388607 /* FixedWidthTokenMaxFullStart */ && (kindAndIsVariableWidth & 128 /* IsVariableWidthMask */) === 0) {
                    return new FixedWidthTokenWithNoTrivia((fullStart << 7 /* FixedWidthTokenFullStartShift */) | kind);
                } else {
                    var packedFullStartAndTriviaInfo = (fullStart << 4 /* LargeTokenFullStartShift */) | leadingTriviaInfo | (trailingTriviaInfo << 2);

                    var packedFullWidthAndKind = (fullWidth << 7 /* LargeTokenFullWidthShift */) | kind;
                    var cachedText = isFixedWidth ? undefined : text.substr(start, end - start);
                    return new LargeScannerToken(packedFullStartAndTriviaInfo, packedFullWidthAndKind, cachedText);
                }
            }

            function scanTrivia(parent, text, isTrailing) {
                var tokenFullStart = parent.fullStart();
                var tokenStart = tokenFullStart + leadingTriviaWidth(parent, text);

                if (isTrailing) {
                    reset(text, tokenStart + parent.text().length, tokenFullStart + parent.fullWidth());
                } else {
                    reset(text, tokenFullStart, tokenStart);
                }

                var trivia = [];

                while (true) {
                    if (index < end) {
                        var ch = str.charCodeAt(index);
                        switch (ch) {
                            case 32 /* space */:
                            case 160 /* nonBreakingSpace */:
                            case 8192 /* enQuad */:
                            case 8193 /* emQuad */:
                            case 8194 /* enSpace */:
                            case 8195 /* emSpace */:
                            case 8196 /* threePerEmSpace */:
                            case 8197 /* fourPerEmSpace */:
                            case 8198 /* sixPerEmSpace */:
                            case 8199 /* figureSpace */:
                            case 8200 /* punctuationSpace */:
                            case 8201 /* thinSpace */:
                            case 8202 /* hairSpace */:
                            case 8203 /* zeroWidthSpace */:
                            case 8239 /* narrowNoBreakSpace */:
                            case 12288 /* ideographicSpace */:

                            case 9 /* tab */:
                            case 11 /* verticalTab */:
                            case 12 /* formFeed */:
                            case 65279 /* byteOrderMark */:
                                trivia.push(scanWhitespaceTrivia());
                                continue;

                            case 47 /* slash */:
                                var ch2 = str.charCodeAt(index + 1);
                                if (ch2 === 47 /* slash */) {
                                    trivia.push(scanSingleLineCommentTrivia());
                                    continue;
                                }

                                if (ch2 === 42 /* asterisk */) {
                                    trivia.push(scanMultiLineCommentTrivia());
                                    continue;
                                }

                                throw TypeScript.Errors.invalidOperation();

                            case 13 /* carriageReturn */:
                            case 10 /* lineFeed */:
                            case 8233 /* paragraphSeparator */:
                            case 8232 /* lineSeparator */:
                                trivia.push(scanLineTerminatorSequenceTrivia(ch));

                                if (!isTrailing) {
                                    continue;
                                }

                                break;

                            default:
                                throw TypeScript.Errors.invalidOperation();
                        }
                    }

                    var triviaList = TypeScript.Syntax.triviaList(trivia);
                    triviaList.parent = parent;

                    return triviaList;
                }
            }

            function scanTriviaInfo(isTrailing) {
                var result = 0;
                var _end = end;

                while (index < _end) {
                    var ch = str.charCodeAt(index);

                    switch (ch) {
                        case 9 /* tab */:
                        case 32 /* space */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                            index++;

                            result |= 1;
                            continue;

                        case 13 /* carriageReturn */:
                            if ((index + 1) < end && str.charCodeAt(index + 1) === 10 /* lineFeed */) {
                                index++;
                            }

                        case 10 /* lineFeed */:
                            index++;

                            result |= 1;

                            if (isTrailing) {
                                return result;
                            }

                            continue;

                        case 47 /* slash */:
                            if ((index + 1) < _end) {
                                var ch2 = str.charCodeAt(index + 1);
                                if (ch2 === 47 /* slash */) {
                                    result |= 3;
                                    skipSingleLineCommentTrivia();
                                    continue;
                                }

                                if (ch2 === 42 /* asterisk */) {
                                    result |= 3;
                                    skipMultiLineCommentTrivia();
                                    continue;
                                }
                            }

                            return result;

                        default:
                            if (ch > 127 /* maxAsciiCharacter */ && slowScanTriviaInfo(ch)) {
                                result |= 1;
                                continue;
                            }

                            return result;
                    }
                }

                return result;
            }

            function slowScanTriviaInfo(ch) {
                switch (ch) {
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:
                    case 65279 /* byteOrderMark */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        index++;
                        return true;

                    default:
                        return false;
                }
            }

            function isNewLineCharacter(ch) {
                switch (ch) {
                    case 13 /* carriageReturn */:
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        return true;
                    default:
                        return false;
                }
            }

            function scanWhitespaceTrivia() {
                var absoluteStartIndex = index;

                while (true) {
                    var ch = str.charCodeAt(index);

                    switch (ch) {
                        case 32 /* space */:
                        case 160 /* nonBreakingSpace */:
                        case 8192 /* enQuad */:
                        case 8193 /* emQuad */:
                        case 8194 /* enSpace */:
                        case 8195 /* emSpace */:
                        case 8196 /* threePerEmSpace */:
                        case 8197 /* fourPerEmSpace */:
                        case 8198 /* sixPerEmSpace */:
                        case 8199 /* figureSpace */:
                        case 8200 /* punctuationSpace */:
                        case 8201 /* thinSpace */:
                        case 8202 /* hairSpace */:
                        case 8203 /* zeroWidthSpace */:
                        case 8239 /* narrowNoBreakSpace */:
                        case 12288 /* ideographicSpace */:

                        case 9 /* tab */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                        case 65279 /* byteOrderMark */:
                            index++;
                            continue;
                    }

                    break;
                }

                return createTrivia(4 /* WhitespaceTrivia */, absoluteStartIndex);
            }

            function createTrivia(kind, absoluteStartIndex) {
                var fullWidth = index - absoluteStartIndex;
                return TypeScript.Syntax.deferredTrivia(kind, text, absoluteStartIndex, fullWidth);
            }

            function scanSingleLineCommentTrivia() {
                var absoluteStartIndex = index;
                skipSingleLineCommentTrivia();

                return createTrivia(7 /* SingleLineCommentTrivia */, absoluteStartIndex);
            }

            function skipSingleLineCommentTrivia() {
                index += 2;

                while (index < end) {
                    if (isNewLineCharacter(str.charCodeAt(index))) {
                        return;
                    }

                    index++;
                }
            }

            function scanMultiLineCommentTrivia() {
                var absoluteStartIndex = index;
                skipMultiLineCommentTrivia();

                return createTrivia(6 /* MultiLineCommentTrivia */, absoluteStartIndex);
            }

            function skipMultiLineCommentTrivia() {
                index += 2;

                while (true) {
                    if (index === end) {
                        reportDiagnostic(end, 0, TypeScript.DiagnosticCode.AsteriskSlash_expected, null);
                        return;
                    }

                    if ((index + 1) < end && str.charCodeAt(index) === 42 /* asterisk */ && str.charCodeAt(index + 1) === 47 /* slash */) {
                        index += 2;
                        return;
                    }

                    index++;
                }
            }

            function scanLineTerminatorSequenceTrivia(ch) {
                var absoluteStartIndex = index;
                skipLineTerminatorSequence(ch);

                return createTrivia(5 /* NewLineTrivia */, absoluteStartIndex);
            }

            function skipLineTerminatorSequence(ch) {
                index++;

                if (ch === 13 /* carriageReturn */ && str.charCodeAt(index) === 10 /* lineFeed */) {
                    index++;
                }
            }

            function scanSyntaxKind(allowContextualToken) {
                if (index >= end) {
                    return 10 /* EndOfFileToken */;
                }

                var character = str.charCodeAt(index);
                index++;

                switch (character) {
                    case 33 /* exclamation */: return scanExclamationToken();
                    case 34 /* doubleQuote */: return scanStringLiteral(character);
                    case 37 /* percent */: return scanPercentToken();
                    case 38 /* ampersand */: return scanAmpersandToken();
                    case 39 /* singleQuote */: return scanStringLiteral(character);
                    case 40 /* openParen */: return 72 /* OpenParenToken */;
                    case 41 /* closeParen */: return 73 /* CloseParenToken */;
                    case 42 /* asterisk */: return scanAsteriskToken();
                    case 43 /* plus */: return scanPlusToken();
                    case 44 /* comma */: return 79 /* CommaToken */;
                    case 45 /* minus */: return scanMinusToken();
                    case 46 /* dot */: return scanDotToken();
                    case 47 /* slash */: return scanSlashToken(allowContextualToken);

                    case 48 /* _0 */:
                    case 49 /* _1 */:
                    case 50 /* _2 */:
                    case 51 /* _3 */:
                    case 52 /* _4 */:
                    case 53 /* _5 */:
                    case 54 /* _6 */:
                    case 55 /* _7 */:
                    case 56 /* _8 */:
                    case 57 /* _9 */:
                        return scanNumericLiteral(character);

                    case 58 /* colon */: return 106 /* ColonToken */;
                    case 59 /* semicolon */: return 78 /* SemicolonToken */;
                    case 60 /* lessThan */: return scanLessThanToken();
                    case 61 /* equals */: return scanEqualsToken();
                    case 62 /* greaterThan */: return scanGreaterThanToken(allowContextualToken);
                    case 63 /* question */: return 105 /* QuestionToken */;

                    case 91 /* openBracket */: return 74 /* OpenBracketToken */;
                    case 93 /* closeBracket */: return 75 /* CloseBracketToken */;
                    case 94 /* caret */: return scanCaretToken();

                    case 123 /* openBrace */: return 70 /* OpenBraceToken */;
                    case 124 /* bar */: return scanBarToken();
                    case 125 /* closeBrace */: return 71 /* CloseBraceToken */;
                    case 126 /* tilde */: return 102 /* TildeToken */;
                }

                if (isIdentifierStartCharacter[character]) {
                    var result = tryFastScanIdentifierOrKeyword(character);
                    if (result !== 0 /* None */) {
                        return result;
                    }
                }

                index--;
                if (isIdentifierStart(peekCharOrUnicodeEscape())) {
                    return slowScanIdentifierOrKeyword();
                }

                var text = String.fromCharCode(character);
                var messageText = getErrorMessageText(text);
                reportDiagnostic(index, 1, TypeScript.DiagnosticCode.Unexpected_character_0, [messageText]);

                index++;

                return 9 /* ErrorToken */;
            }

            function isIdentifierStart(interpretedChar) {
                if (isIdentifierStartCharacter[interpretedChar]) {
                    return true;
                }

                return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierStart(interpretedChar, languageVersion);
            }

            function isIdentifierPart(interpretedChar) {
                if (isIdentifierPartCharacter[interpretedChar]) {
                    return true;
                }

                return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierPart(interpretedChar, languageVersion);
            }

            function tryFastScanIdentifierOrKeyword(firstCharacter) {
                var startIndex = index;
                var character = firstCharacter;

                while (index < end) {
                    character = str.charCodeAt(index);
                    if (!isIdentifierPartCharacter[character]) {
                        break;
                    }

                    index++;
                }

                if (index < end && (character === 92 /* backslash */ || character > 127 /* maxAsciiCharacter */)) {
                    index = startIndex;
                    return 0 /* None */;
                } else {
                    if (isKeywordStartCharacter[firstCharacter]) {
                        return TypeScript.ScannerUtilities.identifierKind(str, startIndex - 1, index - startIndex + 1);
                    } else {
                        return 11 /* IdentifierName */;
                    }
                }
            }

            function slowScanIdentifierOrKeyword() {
                var startIndex = index;

                do {
                    scanCharOrUnicodeEscape();
                } while(isIdentifierPart(peekCharOrUnicodeEscape()));

                var length = index - startIndex;
                var text = str.substr(startIndex, length);
                var valueText = TypeScript.massageEscapes(text);

                var keywordKind = TypeScript.SyntaxFacts.getTokenKind(valueText);
                if (keywordKind >= 15 /* FirstKeyword */ && keywordKind <= 69 /* LastKeyword */) {
                    return keywordKind | 128 /* IsVariableWidthMask */;
                }

                return 11 /* IdentifierName */;
            }

            function scanNumericLiteral(ch) {
                if (isHexNumericLiteral(ch)) {
                    scanHexNumericLiteral();
                } else if (isOctalNumericLiteral(ch)) {
                    scanOctalNumericLiteral();
                } else {
                    scanDecimalNumericLiteral();
                }

                return 13 /* NumericLiteral */;
            }

            function isOctalNumericLiteral(ch) {
                return ch === 48 /* _0 */ && TypeScript.CharacterInfo.isOctalDigit(str.charCodeAt(index));
            }

            function scanOctalNumericLiteral() {
                var start = index - 1;

                while (TypeScript.CharacterInfo.isOctalDigit(str.charCodeAt(index))) {
                    index++;
                }

                if (languageVersion >= 1 /* EcmaScript5 */) {
                    reportDiagnostic(start, index - start, TypeScript.DiagnosticCode.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher, null);
                }
            }

            function scanDecimalDigits() {
                while (TypeScript.CharacterInfo.isDecimalDigit(str.charCodeAt(index))) {
                    index++;
                }
            }

            function scanDecimalNumericLiteral() {
                scanDecimalDigits();

                if (str.charCodeAt(index) === 46 /* dot */) {
                    index++;
                }

                scanDecimalNumericLiteralAfterDot();
            }

            function scanDecimalNumericLiteralAfterDot() {
                scanDecimalDigits();

                var ch = str.charCodeAt(index);
                if (ch === 101 /* e */ || ch === 69 /* E */) {
                    var nextChar1 = str.charCodeAt(index + 1);

                    if (TypeScript.CharacterInfo.isDecimalDigit(nextChar1)) {
                        index++;
                        scanDecimalDigits();
                    } else if (nextChar1 === 45 /* minus */ || nextChar1 === 43 /* plus */) {
                        var nextChar2 = str.charCodeAt(index + 2);
                        if (TypeScript.CharacterInfo.isDecimalDigit(nextChar2)) {
                            index += 2;
                            scanDecimalDigits();
                        }
                    }
                }
            }

            function scanHexNumericLiteral() {
                index++;

                while (TypeScript.CharacterInfo.isHexDigit(str.charCodeAt(index))) {
                    index++;
                }
            }

            function isHexNumericLiteral(ch) {
                if (ch === 48 /* _0 */) {
                    var ch = str.charCodeAt(index);

                    if (ch === 120 /* x */ || ch === 88 /* X */) {
                        return TypeScript.CharacterInfo.isHexDigit(str.charCodeAt(index + 1));
                    }
                }

                return false;
            }

            function scanLessThanToken() {
                var ch0 = str.charCodeAt(index);
                if (ch0 === 61 /* equals */) {
                    index++;
                    return 82 /* LessThanEqualsToken */;
                } else if (ch0 === 60 /* lessThan */) {
                    index++;
                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;
                        return 112 /* LessThanLessThanEqualsToken */;
                    } else {
                        return 95 /* LessThanLessThanToken */;
                    }
                } else {
                    return 80 /* LessThanToken */;
                }
            }

            function scanGreaterThanToken(allowContextualToken) {
                if (allowContextualToken) {
                    var ch0 = str.charCodeAt(index);
                    if (ch0 === 62 /* greaterThan */) {
                        index++;
                        var ch1 = str.charCodeAt(index);
                        if (ch1 === 62 /* greaterThan */) {
                            index++;
                            var ch2 = str.charCodeAt(index);
                            if (ch2 === 61 /* equals */) {
                                index++;
                                return 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                            } else {
                                return 97 /* GreaterThanGreaterThanGreaterThanToken */;
                            }
                        } else if (ch1 === 61 /* equals */) {
                            index++;
                            return 113 /* GreaterThanGreaterThanEqualsToken */;
                        } else {
                            return 96 /* GreaterThanGreaterThanToken */;
                        }
                    } else if (ch0 === 61 /* equals */) {
                        index++;
                        return 83 /* GreaterThanEqualsToken */;
                    }
                }

                return 81 /* GreaterThanToken */;
            }

            function scanBarToken() {
                var ch = str.charCodeAt(index);
                if (ch === 61 /* equals */) {
                    index++;
                    return 116 /* BarEqualsToken */;
                } else if (ch === 124 /* bar */) {
                    index++;
                    return 104 /* BarBarToken */;
                } else {
                    return 99 /* BarToken */;
                }
            }

            function scanCaretToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 117 /* CaretEqualsToken */;
                } else {
                    return 100 /* CaretToken */;
                }
            }

            function scanAmpersandToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 115 /* AmpersandEqualsToken */;
                } else if (character === 38 /* ampersand */) {
                    index++;
                    return 103 /* AmpersandAmpersandToken */;
                } else {
                    return 98 /* AmpersandToken */;
                }
            }

            function scanPercentToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 111 /* PercentEqualsToken */;
                } else {
                    return 92 /* PercentToken */;
                }
            }

            function scanMinusToken() {
                var character = str.charCodeAt(index);

                if (character === 61 /* equals */) {
                    index++;
                    return 109 /* MinusEqualsToken */;
                } else if (character === 45 /* minus */) {
                    index++;
                    return 94 /* MinusMinusToken */;
                } else {
                    return 90 /* MinusToken */;
                }
            }

            function scanPlusToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 108 /* PlusEqualsToken */;
                } else if (character === 43 /* plus */) {
                    index++;
                    return 93 /* PlusPlusToken */;
                } else {
                    return 89 /* PlusToken */;
                }
            }

            function scanAsteriskToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 110 /* AsteriskEqualsToken */;
                } else {
                    return 91 /* AsteriskToken */;
                }
            }

            function scanEqualsToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;

                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;

                        return 87 /* EqualsEqualsEqualsToken */;
                    } else {
                        return 84 /* EqualsEqualsToken */;
                    }
                } else if (character === 62 /* greaterThan */) {
                    index++;
                    return 85 /* EqualsGreaterThanToken */;
                } else {
                    return 107 /* EqualsToken */;
                }
            }

            function scanDotToken() {
                var nextChar = str.charCodeAt(index);
                if (TypeScript.CharacterInfo.isDecimalDigit(nextChar)) {
                    scanDecimalNumericLiteralAfterDot();
                    return 13 /* NumericLiteral */;
                }

                if (nextChar === 46 /* dot */ && str.charCodeAt(index + 1) === 46 /* dot */) {
                    index += 2;
                    return 77 /* DotDotDotToken */;
                } else {
                    return 76 /* DotToken */;
                }
            }

            function scanSlashToken(allowContextualToken) {
                if (allowContextualToken) {
                    var result = tryScanRegularExpressionToken();
                    if (result !== 0 /* None */) {
                        return result;
                    }
                }

                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 119 /* SlashEqualsToken */;
                } else {
                    return 118 /* SlashToken */;
                }
            }

            function tryScanRegularExpressionToken() {
                var startIndex = index;

                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    var ch = str.charCodeAt(index);

                    if (isNaN(ch) || isNewLineCharacter(ch)) {
                        index = startIndex;
                        return 0 /* None */;
                    }

                    index++;
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }

                    switch (ch) {
                        case 92 /* backslash */:
                            inEscape = true;
                            continue;

                        case 91 /* openBracket */:
                            inCharacterClass = true;
                            continue;

                        case 93 /* closeBracket */:
                            inCharacterClass = false;
                            continue;

                        case 47 /* slash */:
                            if (inCharacterClass) {
                                continue;
                            }

                            break;

                        default:
                            continue;
                    }

                    break;
                }

                while (isIdentifierPartCharacter[str.charCodeAt(index)]) {
                    index++;
                }

                return 12 /* RegularExpressionLiteral */;
            }

            function scanExclamationToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;

                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;

                        return 88 /* ExclamationEqualsEqualsToken */;
                    } else {
                        return 86 /* ExclamationEqualsToken */;
                    }
                } else {
                    return 101 /* ExclamationToken */;
                }
            }

            function getErrorMessageText(text) {
                if (text === "\\") {
                    return '"\\"';
                }

                return JSON.stringify(text);
            }

            function skipEscapeSequence() {
                var rewindPoint = index;

                index++;

                var ch = str.charCodeAt(index);
                if (isNaN(ch)) {
                    return;
                }

                index++;
                switch (ch) {
                    case 120 /* x */:
                    case 117 /* u */:
                        index = rewindPoint;
                        var value = scanUnicodeOrHexEscape(true);
                        break;

                    case 13 /* carriageReturn */:
                        if (str.charCodeAt(index) === 10 /* lineFeed */) {
                            index++;
                        }
                        break;

                    default:
                        break;
                }
            }

            function scanStringLiteral(quoteCharacter) {
                while (true) {
                    var ch = str.charCodeAt(index);
                    if (ch === 92 /* backslash */) {
                        skipEscapeSequence();
                    } else if (ch === quoteCharacter) {
                        index++;
                        break;
                    } else if (isNaN(ch) || isNewLineCharacter(ch)) {
                        reportDiagnostic(Math.min(index, end), 1, TypeScript.DiagnosticCode.Missing_close_quote_character, null);
                        break;
                    } else {
                        index++;
                    }
                }

                return 14 /* StringLiteral */;
            }

            function isUnicodeEscape(character) {
                return character === 92 /* backslash */ && str.charCodeAt(index + 1) === 117 /* u */;
            }

            function peekCharOrUnicodeEscape() {
                var character = str.charCodeAt(index);
                if (isUnicodeEscape(character)) {
                    return peekUnicodeOrHexEscape();
                } else {
                    return character;
                }
            }

            function peekUnicodeOrHexEscape() {
                var startIndex = index;

                var ch = scanUnicodeOrHexEscape(false);

                index = startIndex;

                return ch;
            }

            function scanCharOrUnicodeEscape() {
                if (str.charCodeAt(index) === 92 /* backslash */ && str.charCodeAt(index + 1) === 117 /* u */) {
                    scanUnicodeOrHexEscape(true);
                } else {
                    index++;
                }
            }

            function scanUnicodeOrHexEscape(report) {
                var start = index;
                var character = str.charCodeAt(index);

                index++;

                character = str.charCodeAt(index);

                var intChar = 0;
                index++;

                var count = character === 117 /* u */ ? 4 : 2;

                for (var i = 0; i < count; i++) {
                    var ch2 = str.charCodeAt(index);
                    if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                        if (report) {
                            reportDiagnostic(start, index - start, TypeScript.DiagnosticCode.Unrecognized_escape_sequence, null);
                        }

                        break;
                    }

                    intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
                    index++;
                }

                return intChar;
            }

            function fillTokenInfo(token, text, tokenInfo) {
                var fullStart = token.fullStart();
                var fullEnd = fullStart + token.fullWidth();
                reset(text, fullStart, fullEnd);

                scanTriviaInfo(false);

                var start = index;
                scanSyntaxKind(isContextualToken(token));
                var end = index;

                tokenInfo.leadingTriviaWidth = start - fullStart;
                tokenInfo.width = end - start;
            }

            reset(text, 0, text.length());

            return {
                setIndex: setIndex,
                scan: scan,
                fillTokenInfo: fillTokenInfo,
                scanTrivia: scanTrivia
            };
        }

        function isValidIdentifier(text, languageVersion) {
            var hadError = false;
            var scanner = createScanner(languageVersion, text, function () {
                return hadError = true;
            });

            var token = scanner.scan(false);

            return !hadError && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token) && TypeScript.width(token) === text.length();
        }
        Scanner.isValidIdentifier = isValidIdentifier;

        

        function createParserSource(fileName, text, languageVersion) {
            var _absolutePosition = 0;

            var _tokenDiagnostics = [];

            var rewindPointPool = [];
            var rewindPointPoolCount = 0;

            var lastDiagnostic = null;
            var reportDiagnostic = function (position, fullWidth, diagnosticKey, args) {
                lastDiagnostic = new TypeScript.Diagnostic(fileName, text.lineMap(), position, fullWidth, diagnosticKey, args);
            };

            var slidingWindow = new TypeScript.SlidingWindow(fetchNextItem, TypeScript.ArrayUtilities.createArray(1024, null), null);

            var scanner = createScanner(languageVersion, text, reportDiagnostic);

            function release() {
                slidingWindow = null;
                scanner = null;
                _tokenDiagnostics = [];
                rewindPointPool = [];
                lastDiagnostic = null;
                reportDiagnostic = null;
            }

            function currentNode() {
                return null;
            }

            function consumeNode(node) {
                throw TypeScript.Errors.invalidOperation();
            }

            function absolutePosition() {
                return _absolutePosition;
            }

            function tokenDiagnostics() {
                return _tokenDiagnostics;
            }

            function getOrCreateRewindPoint() {
                if (rewindPointPoolCount === 0) {
                    return {};
                }

                rewindPointPoolCount--;
                var result = rewindPointPool[rewindPointPoolCount];
                rewindPointPool[rewindPointPoolCount] = null;
                return result;
            }

            function getRewindPoint() {
                var slidingWindowIndex = slidingWindow.getAndPinAbsoluteIndex();

                var rewindPoint = getOrCreateRewindPoint();

                rewindPoint.slidingWindowIndex = slidingWindowIndex;
                rewindPoint.absolutePosition = _absolutePosition;

                return rewindPoint;
            }

            function rewind(rewindPoint) {
                slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);

                _absolutePosition = rewindPoint.absolutePosition;
            }

            function releaseRewindPoint(rewindPoint) {
                slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint.absoluteIndex);

                rewindPointPool[rewindPointPoolCount] = rewindPoint;
                rewindPointPoolCount++;
            }

            function fetchNextItem(allowContextualToken) {
                var token = scanner.scan(allowContextualToken);

                if (lastDiagnostic === null) {
                    return token;
                }

                _tokenDiagnostics.push(lastDiagnostic);
                lastDiagnostic = null;
                return TypeScript.Syntax.realizeToken(token, text);
            }

            function peekToken(n) {
                return slidingWindow.peekItemN(n);
            }

            function consumeToken(token) {
                _absolutePosition += token.fullWidth();

                slidingWindow.moveToNextItem();
            }

            function currentToken() {
                return slidingWindow.currentItem(false);
            }

            function removeDiagnosticsOnOrAfterPosition(position) {
                var tokenDiagnosticsLength = _tokenDiagnostics.length;
                while (tokenDiagnosticsLength > 0) {
                    var diagnostic = _tokenDiagnostics[tokenDiagnosticsLength - 1];
                    if (diagnostic.start() >= position) {
                        tokenDiagnosticsLength--;
                    } else {
                        break;
                    }
                }

                _tokenDiagnostics.length = tokenDiagnosticsLength;
            }

            function resetToPosition(absolutePosition) {
                _absolutePosition = absolutePosition;

                removeDiagnosticsOnOrAfterPosition(absolutePosition);

                slidingWindow.disgardAllItemsFromCurrentIndexOnwards();

                scanner.setIndex(absolutePosition);
            }

            function currentContextualToken() {
                resetToPosition(_absolutePosition);

                var token = slidingWindow.currentItem(true);

                return token;
            }

            return {
                text: text,
                fileName: fileName,
                languageVersion: languageVersion,
                currentNode: currentNode,
                currentToken: currentToken,
                currentContextualToken: currentContextualToken,
                peekToken: peekToken,
                consumeNode: consumeNode,
                consumeToken: consumeToken,
                getRewindPoint: getRewindPoint,
                rewind: rewind,
                releaseRewindPoint: releaseRewindPoint,
                tokenDiagnostics: tokenDiagnostics,
                release: release,
                absolutePosition: absolutePosition,
                resetToPosition: resetToPosition
            };
        }
        Scanner.createParserSource = createParserSource;
    })(TypeScript.Scanner || (TypeScript.Scanner = {}));
    var Scanner = TypeScript.Scanner;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities = (function () {
        function ScannerUtilities() {
        }
        ScannerUtilities.identifierKind = function (str, start, length) {
            switch (length) {
                case 2:
                    switch (str.charCodeAt(start)) {
                        case 100 /* d */: return (str.charCodeAt(start + 1) === 111 /* o */) ? 22 /* DoKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            switch (str.charCodeAt(start + 1)) {
                                case 102 /* f */: return 28 /* IfKeyword */;
                                case 110 /* n */: return 29 /* InKeyword */;
                                default: return 11 /* IdentifierName */;
                            }
                        default: return 11 /* IdentifierName */;
                    }
                case 3:
                    switch (str.charCodeAt(start)) {
                        case 97 /* a */: return (str.charCodeAt(start + 1) === 110 /* n */ && str.charCodeAt(start + 2) === 121 /* y */) ? 60 /* AnyKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 114 /* r */) ? 26 /* ForKeyword */ : 11 /* IdentifierName */;
                        case 103 /* g */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 64 /* GetKeyword */ : 11 /* IdentifierName */;
                        case 108 /* l */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 53 /* LetKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 119 /* w */) ? 31 /* NewKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 68 /* SetKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */: return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 121 /* y */) ? 38 /* TryKeyword */ : 11 /* IdentifierName */;
                        case 118 /* v */: return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 114 /* r */) ? 40 /* VarKeyword */ : 11 /* IdentifierName */;
                        default: return 11 /* IdentifierName */;
                    }
                case 4:
                    switch (str.charCodeAt(start)) {
                        case 99 /* c */: return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 101 /* e */) ? 16 /* CaseKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            switch (str.charCodeAt(start + 1)) {
                                case 108 /* l */: return (str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 101 /* e */) ? 23 /* ElseKeyword */ : 11 /* IdentifierName */;
                                case 110 /* n */: return (str.charCodeAt(start + 2) === 117 /* u */ && str.charCodeAt(start + 3) === 109 /* m */) ? 46 /* EnumKeyword */ : 11 /* IdentifierName */;
                                default: return 11 /* IdentifierName */;
                            }
                        case 110 /* n */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 108 /* l */) ? 32 /* NullKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            switch (str.charCodeAt(start + 1)) {
                                case 104 /* h */: return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 115 /* s */) ? 35 /* ThisKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */: return (str.charCodeAt(start + 2) === 117 /* u */ && str.charCodeAt(start + 3) === 101 /* e */) ? 37 /* TrueKeyword */ : 11 /* IdentifierName */;
                                default: return 11 /* IdentifierName */;
                            }
                        case 118 /* v */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 100 /* d */) ? 41 /* VoidKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */: return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 104 /* h */) ? 43 /* WithKeyword */ : 11 /* IdentifierName */;
                        default: return 11 /* IdentifierName */;
                    }
                case 5:
                    switch (str.charCodeAt(start)) {
                        case 98 /* b */: return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 101 /* e */ && str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 107 /* k */) ? 15 /* BreakKeyword */ : 11 /* IdentifierName */;
                        case 99 /* c */:
                            switch (str.charCodeAt(start + 1)) {
                                case 97 /* a */: return (str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 99 /* c */ && str.charCodeAt(start + 4) === 104 /* h */) ? 17 /* CatchKeyword */ : 11 /* IdentifierName */;
                                case 108 /* l */: return (str.charCodeAt(start + 2) === 97 /* a */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 115 /* s */) ? 44 /* ClassKeyword */ : 11 /* IdentifierName */;
                                case 111 /* o */: return (str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 116 /* t */) ? 45 /* ConstKeyword */ : 11 /* IdentifierName */;
                                default: return 11 /* IdentifierName */;
                            }
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 101 /* e */) ? 24 /* FalseKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 114 /* r */) ? 50 /* SuperKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */: return (str.charCodeAt(start + 1) === 104 /* h */ && str.charCodeAt(start + 2) === 114 /* r */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 119 /* w */) ? 36 /* ThrowKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */: return (str.charCodeAt(start + 1) === 104 /* h */ && str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */) ? 42 /* WhileKeyword */ : 11 /* IdentifierName */;
                        case 121 /* y */: return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 101 /* e */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 100 /* d */) ? 59 /* YieldKeyword */ : 11 /* IdentifierName */;
                        default: return 11 /* IdentifierName */;
                    }
                case 6:
                    switch (str.charCodeAt(start)) {
                        case 100 /* d */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 101 /* e */) ? 21 /* DeleteKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */: return (str.charCodeAt(start + 1) === 120 /* x */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 116 /* t */) ? 47 /* ExportKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */: return (str.charCodeAt(start + 1) === 109 /* m */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 116 /* t */) ? 49 /* ImportKeyword */ : 11 /* IdentifierName */;
                        case 109 /* m */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 100 /* d */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 108 /* l */ && str.charCodeAt(start + 5) === 101 /* e */) ? 65 /* ModuleKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 109 /* m */ && str.charCodeAt(start + 3) === 98 /* b */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 114 /* r */) ? 67 /* NumberKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 98 /* b */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 99 /* c */) ? 57 /* PublicKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 110 /* n */) ? 33 /* ReturnKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            switch (str.charCodeAt(start + 1)) {
                                case 116 /* t */:
                                    switch (str.charCodeAt(start + 2)) {
                                        case 97 /* a */: return (str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 99 /* c */) ? 58 /* StaticKeyword */ : 11 /* IdentifierName */;
                                        case 114 /* r */: return (str.charCodeAt(start + 3) === 105 /* i */ && str.charCodeAt(start + 4) === 110 /* n */ && str.charCodeAt(start + 5) === 103 /* g */) ? 69 /* StringKeyword */ : 11 /* IdentifierName */;
                                        default: return 11 /* IdentifierName */;
                                    }
                                case 119 /* w */: return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 99 /* c */ && str.charCodeAt(start + 5) === 104 /* h */) ? 34 /* SwitchKeyword */ : 11 /* IdentifierName */;
                                default: return 11 /* IdentifierName */;
                            }
                        case 116 /* t */: return (str.charCodeAt(start + 1) === 121 /* y */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 111 /* o */ && str.charCodeAt(start + 5) === 102 /* f */) ? 39 /* TypeOfKeyword */ : 11 /* IdentifierName */;
                        default: return 11 /* IdentifierName */;
                    }
                case 7:
                    switch (str.charCodeAt(start)) {
                        case 98 /* b */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 111 /* o */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 97 /* a */ && str.charCodeAt(start + 6) === 110 /* n */) ? 61 /* BooleanKeyword */ : 11 /* IdentifierName */;
                        case 100 /* d */:
                            switch (str.charCodeAt(start + 1)) {
                                case 101 /* e */:
                                    switch (str.charCodeAt(start + 2)) {
                                        case 99 /* c */: return (str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 101 /* e */) ? 63 /* DeclareKeyword */ : 11 /* IdentifierName */;
                                        case 102 /* f */: return (str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 117 /* u */ && str.charCodeAt(start + 5) === 108 /* l */ && str.charCodeAt(start + 6) === 116 /* t */) ? 20 /* DefaultKeyword */ : 11 /* IdentifierName */;
                                        default: return 11 /* IdentifierName */;
                                    }
                                default: return 11 /* IdentifierName */;
                            }
                        case 101 /* e */: return (str.charCodeAt(start + 1) === 120 /* x */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 110 /* n */ && str.charCodeAt(start + 5) === 100 /* d */ && str.charCodeAt(start + 6) === 115 /* s */) ? 48 /* ExtendsKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 108 /* l */ && str.charCodeAt(start + 5) === 108 /* l */ && str.charCodeAt(start + 6) === 121 /* y */) ? 25 /* FinallyKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            switch (str.charCodeAt(start + 1)) {
                                case 97 /* a */: return (str.charCodeAt(start + 2) === 99 /* c */ && str.charCodeAt(start + 3) === 107 /* k */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 103 /* g */ && str.charCodeAt(start + 6) === 101 /* e */) ? 54 /* PackageKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */: return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 118 /* v */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 116 /* t */ && str.charCodeAt(start + 6) === 101 /* e */) ? 55 /* PrivateKeyword */ : 11 /* IdentifierName */;
                                default: return 11 /* IdentifierName */;
                            }
                        case 114 /* r */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 113 /* q */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 101 /* e */) ? 66 /* RequireKeyword */ : 11 /* IdentifierName */;
                        default: return 11 /* IdentifierName */;
                    }
                case 8:
                    switch (str.charCodeAt(start)) {
                        case 99 /* c */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 110 /* n */ && str.charCodeAt(start + 6) === 117 /* u */ && str.charCodeAt(start + 7) === 101 /* e */) ? 18 /* ContinueKeyword */ : 11 /* IdentifierName */;
                        case 100 /* d */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 98 /* b */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 103 /* g */ && str.charCodeAt(start + 5) === 103 /* g */ && str.charCodeAt(start + 6) === 101 /* e */ && str.charCodeAt(start + 7) === 114 /* r */) ? 19 /* DebuggerKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 99 /* c */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 105 /* i */ && str.charCodeAt(start + 6) === 111 /* o */ && str.charCodeAt(start + 7) === 110 /* n */) ? 27 /* FunctionKeyword */ : 11 /* IdentifierName */;
                        default: return 11 /* IdentifierName */;
                    }
                case 9:
                    switch (str.charCodeAt(start)) {
                        case 105 /* i */: return (str.charCodeAt(start + 1) === 110 /* n */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 102 /* f */ && str.charCodeAt(start + 6) === 97 /* a */ && str.charCodeAt(start + 7) === 99 /* c */ && str.charCodeAt(start + 8) === 101 /* e */) ? 52 /* InterfaceKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */: return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 111 /* o */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 99 /* c */ && str.charCodeAt(start + 6) === 116 /* t */ && str.charCodeAt(start + 7) === 101 /* e */ && str.charCodeAt(start + 8) === 100 /* d */) ? 56 /* ProtectedKeyword */ : 11 /* IdentifierName */;
                        default: return 11 /* IdentifierName */;
                    }
                case 10:
                    switch (str.charCodeAt(start)) {
                        case 105 /* i */:
                            switch (str.charCodeAt(start + 1)) {
                                case 109 /* m */: return (str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 109 /* m */ && str.charCodeAt(start + 6) === 101 /* e */ && str.charCodeAt(start + 7) === 110 /* n */ && str.charCodeAt(start + 8) === 116 /* t */ && str.charCodeAt(start + 9) === 115 /* s */) ? 51 /* ImplementsKeyword */ : 11 /* IdentifierName */;
                                case 110 /* n */: return (str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 110 /* n */ && str.charCodeAt(start + 6) === 99 /* c */ && str.charCodeAt(start + 7) === 101 /* e */ && str.charCodeAt(start + 8) === 111 /* o */ && str.charCodeAt(start + 9) === 102 /* f */) ? 30 /* InstanceOfKeyword */ : 11 /* IdentifierName */;
                                default: return 11 /* IdentifierName */;
                            }
                        default: return 11 /* IdentifierName */;
                    }
                case 11: return (str.charCodeAt(start) === 99 /* c */ && str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 117 /* u */ && str.charCodeAt(start + 7) === 99 /* c */ && str.charCodeAt(start + 8) === 116 /* t */ && str.charCodeAt(start + 9) === 111 /* o */ && str.charCodeAt(start + 10) === 114 /* r */) ? 62 /* ConstructorKeyword */ : 11 /* IdentifierName */;
                default: return 11 /* IdentifierName */;
            }
        };
        return ScannerUtilities;
    })();
    TypeScript.ScannerUtilities = ScannerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SlidingWindow = (function () {
        function SlidingWindow(fetchNextItem, window, defaultValue, sourceLength) {
            if (typeof sourceLength === "undefined") { sourceLength = -1; }
            this.fetchNextItem = fetchNextItem;
            this.window = window;
            this.defaultValue = defaultValue;
            this.sourceLength = sourceLength;
            this.windowCount = 0;
            this.windowAbsoluteStartIndex = 0;
            this.currentRelativeItemIndex = 0;
            this._pinCount = 0;
            this.firstPinnedAbsoluteIndex = -1;
        }
        SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
            var sourceLength = this.sourceLength;
            if (sourceLength >= 0 && this.absoluteIndex() >= sourceLength) {
                return false;
            }

            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }

            var item = this.fetchNextItem(argument);

            this.window[this.windowCount] = item;

            this.windowCount++;
            return true;
        };

        SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);

            var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;

            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;

                var shiftCount = this.windowCount - shiftStartIndex;

                if (shiftCount > 0) {
                    TypeScript.ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }

                this.windowAbsoluteStartIndex += shiftStartIndex;

                this.windowCount -= shiftStartIndex;

                this.currentRelativeItemIndex -= shiftStartIndex;
            } else {
                TypeScript.ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        };

        SlidingWindow.prototype.absoluteIndex = function () {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        };

        SlidingWindow.prototype.isAtEndOfSource = function () {
            return this.absoluteIndex() >= this.sourceLength;
        };

        SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }

            return absoluteIndex;
        };

        SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
            this._pinCount--;
            if (this._pinCount === 0) {
                this.firstPinnedAbsoluteIndex = -1;
            }
        };

        SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;

            this.currentRelativeItemIndex = relativeIndex;
        };

        SlidingWindow.prototype.currentItem = function (argument) {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex];
        };

        SlidingWindow.prototype.peekItemN = function (n) {
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(null)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex + n];
        };

        SlidingWindow.prototype.moveToNextItem = function () {
            this.currentRelativeItemIndex++;
        };

        SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
            this.windowCount = this.currentRelativeItemIndex;
        };
        return SlidingWindow;
    })();
    TypeScript.SlidingWindow = SlidingWindow;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        Syntax._nextSyntaxID = 1;

        function childIndex(parent, child) {
            for (var i = 0, n = TypeScript.childCount(parent); i < n; i++) {
                var current = TypeScript.childAt(parent, i);
                if (current === child) {
                    return i;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childIndex = childIndex;

        function nodeHasSkippedOrMissingTokens(node) {
            for (var i = 0; i < TypeScript.childCount(node); i++) {
                var child = TypeScript.childAt(node, i);
                if (TypeScript.isToken(child)) {
                    var token = child;

                    if (token.hasSkippedToken() || (TypeScript.width(token) === 0 && token.kind() !== 10 /* EndOfFileToken */)) {
                        return true;
                    }
                }
            }

            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;

        function isUnterminatedStringLiteral(token) {
            if (token && token.kind() === 14 /* StringLiteral */) {
                var text = token.text();
                return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
            }

            return false;
        }
        Syntax.isUnterminatedStringLiteral = isUnterminatedStringLiteral;

        function isUnterminatedMultilineCommentTrivia(trivia) {
            if (trivia && trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                var text = trivia.fullText();
                return text.length < 4 || text.substring(text.length - 2) !== "*/";
            }
            return false;
        }
        Syntax.isUnterminatedMultilineCommentTrivia = isUnterminatedMultilineCommentTrivia;

        function isEntirelyInsideCommentTrivia(trivia, fullStart, position) {
            if (trivia && trivia.isComment() && position > fullStart) {
                var end = fullStart + trivia.fullWidth();
                if (position < end) {
                    return true;
                } else if (position === end) {
                    return trivia.kind() === 7 /* SingleLineCommentTrivia */ || isUnterminatedMultilineCommentTrivia(trivia);
                }
            }

            return false;
        }
        Syntax.isEntirelyInsideCommentTrivia = isEntirelyInsideCommentTrivia;

        function isEntirelyInsideComment(sourceUnit, position) {
            var positionedToken = TypeScript.findToken(sourceUnit, position);
            var fullStart = positionedToken.fullStart();
            var triviaList = null;
            var lastTriviaBeforeToken = null;

            if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                if (positionedToken.hasLeadingTrivia()) {
                    triviaList = positionedToken.leadingTrivia();
                } else {
                    positionedToken = TypeScript.previousToken(positionedToken);
                    if (positionedToken) {
                        if (positionedToken && positionedToken.hasTrailingTrivia()) {
                            triviaList = positionedToken.trailingTrivia();
                            fullStart = TypeScript.end(positionedToken);
                        }
                    }
                }
            } else {
                if (position <= (fullStart + positionedToken.leadingTriviaWidth())) {
                    triviaList = positionedToken.leadingTrivia();
                } else if (position >= (fullStart + TypeScript.width(positionedToken))) {
                    triviaList = positionedToken.trailingTrivia();
                    fullStart = TypeScript.end(positionedToken);
                }
            }

            if (triviaList) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (position <= fullStart) {
                        break;
                    } else if (position <= fullStart + trivia.fullWidth() && trivia.isComment()) {
                        lastTriviaBeforeToken = trivia;
                        break;
                    }

                    fullStart += trivia.fullWidth();
                }
            }

            return lastTriviaBeforeToken && isEntirelyInsideCommentTrivia(lastTriviaBeforeToken, fullStart, position);
        }
        Syntax.isEntirelyInsideComment = isEntirelyInsideComment;

        function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) {
            var positionedToken = TypeScript.findToken(sourceUnit, position);

            if (positionedToken) {
                if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                    positionedToken = TypeScript.previousToken(positionedToken);
                    return positionedToken && positionedToken.trailingTriviaWidth() === 0 && isUnterminatedStringLiteral(positionedToken);
                } else if (position > TypeScript.start(positionedToken)) {
                    return (position < TypeScript.end(positionedToken) && (positionedToken.kind() === 14 /* StringLiteral */ || positionedToken.kind() === 12 /* RegularExpressionLiteral */)) || (position <= TypeScript.end(positionedToken) && isUnterminatedStringLiteral(positionedToken));
                }
            }

            return false;
        }
        Syntax.isEntirelyInStringOrRegularExpressionLiteral = isEntirelyInStringOrRegularExpressionLiteral;

        function findSkippedTokenOnLeftInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullEnd;

            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.leadingTrivia();
                fullEnd = positionedToken.fullStart() + triviaList.fullWidth();
            } else {
                triviaList = positionedToken.trailingTrivia();
                fullEnd = TypeScript.fullEnd(positionedToken);
            }

            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();

                    if (trivia.isSkippedToken() && position >= fullEnd) {
                        return trivia.skippedToken();
                    }

                    fullEnd -= triviaWidth;
                }
            }

            return null;
        }

        function findSkippedTokenOnLeft(positionedToken, position) {
            var positionInLeadingTriviaList = (position < TypeScript.start(positionedToken));
            return findSkippedTokenOnLeftInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenOnLeft = findSkippedTokenOnLeft;

        function getAncestorOfKind(positionedToken, kind) {
            while (positionedToken && positionedToken.parent) {
                if (positionedToken.parent.kind() === kind) {
                    return positionedToken.parent;
                }

                positionedToken = positionedToken.parent;
            }

            return null;
        }
        Syntax.getAncestorOfKind = getAncestorOfKind;

        function hasAncestorOfKind(positionedToken, kind) {
            return getAncestorOfKind(positionedToken, kind) !== null;
        }
        Syntax.hasAncestorOfKind = hasAncestorOfKind;

        function isIntegerLiteral(expression) {
            if (expression) {
                switch (expression.kind()) {
                    case 165 /* PlusExpression */:
                    case 166 /* NegateExpression */:
                        expression = expression.operand;
                        return TypeScript.isToken(expression) && TypeScript.IntegerUtilities.isInteger(expression.text());

                    case 13 /* NumericLiteral */:
                        var text = expression.text();
                        return TypeScript.IntegerUtilities.isInteger(text) || TypeScript.IntegerUtilities.isHexInteger(text);
                }
            }

            return false;
        }
        Syntax.isIntegerLiteral = isIntegerLiteral;

        function containingNode(element) {
            var current = element.parent;

            while (current !== null && !TypeScript.isNode(current)) {
                current = current.parent;
            }

            return current;
        }
        Syntax.containingNode = containingNode;

        function findTokenOnLeft(element, position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = TypeScript.findToken(element, position, false);
            var _start = TypeScript.start(positionedToken);

            if (includeSkippedTokens) {
                positionedToken = findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }

            if (position > _start) {
                return positionedToken;
            }

            if (positionedToken.fullStart() === 0) {
                return null;
            }

            return TypeScript.previousToken(positionedToken, includeSkippedTokens);
        }
        Syntax.findTokenOnLeft = findTokenOnLeft;

        function findCompleteTokenOnLeft(element, position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = TypeScript.findToken(element, position, false);

            if (includeSkippedTokens) {
                positionedToken = findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }

            if (TypeScript.width(positionedToken) > 0 && position >= TypeScript.end(positionedToken)) {
                return positionedToken;
            }

            return TypeScript.previousToken(positionedToken, includeSkippedTokens);
        }
        Syntax.findCompleteTokenOnLeft = findCompleteTokenOnLeft;

        function firstTokenInLineContainingPosition(syntaxTree, position) {
            var current = TypeScript.findToken(syntaxTree.sourceUnit(), position);
            while (true) {
                if (isFirstTokenInLine(current, syntaxTree.lineMap())) {
                    break;
                }

                current = TypeScript.previousToken(current);
            }

            return current;
        }
        Syntax.firstTokenInLineContainingPosition = firstTokenInLineContainingPosition;

        function isFirstTokenInLine(token, lineMap) {
            var _previousToken = TypeScript.previousToken(token);
            if (_previousToken === null) {
                return true;
            }

            return lineMap.getLineNumberFromPosition(TypeScript.end(_previousToken)) !== lineMap.getLineNumberFromPosition(TypeScript.start(token));
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function isShared(element) {
        var kind = element.kind();
        return (kind === 1 /* List */ || kind === 2 /* SeparatedList */) && element.length === 0;
    }
    TypeScript.isShared = isShared;

    function childCount(element) {
        var kind = element.kind();
        if (kind === 1 /* List */) {
            return element.length;
        } else if (kind === 2 /* SeparatedList */) {
            return element.length + element.separators.length;
        } else if (kind >= 9 /* FirstToken */ && kind <= 119 /* LastToken */) {
            return 0;
        } else {
            return TypeScript.nodeMetadata[kind].length;
        }
    }
    TypeScript.childCount = childCount;

    function childAt(element, index) {
        var kind = element.kind();
        if (kind === 1 /* List */) {
            return element[index];
        } else if (kind === 2 /* SeparatedList */) {
            return (index % 2 === 0) ? element[index / 2] : element.separators[(index - 1) / 2];
        } else {
            return element[TypeScript.nodeMetadata[element.kind()][index]];
        }
    }
    TypeScript.childAt = childAt;

    function syntaxTree(element) {
        if (element) {
            TypeScript.Debug.assert(!isShared(element));

            while (element) {
                if (element.kind() === 120 /* SourceUnit */) {
                    return element.syntaxTree;
                }

                element = element.parent;
            }
        }

        return null;
    }
    TypeScript.syntaxTree = syntaxTree;

    function parsedInStrictMode(node) {
        var info = node.data;
        if (info === undefined) {
            return false;
        }

        return (info & 4 /* NodeParsedInStrictModeMask */) !== 0;
    }
    TypeScript.parsedInStrictMode = parsedInStrictMode;

    function previousToken(token, includeSkippedTokens) {
        if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
        if (includeSkippedTokens) {
            var triviaList = token.leadingTrivia();
            if (triviaList && triviaList.hasSkippedToken()) {
                var currentTriviaEndPosition = TypeScript.start(token);
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return trivia.skippedToken();
                    }

                    currentTriviaEndPosition -= trivia.fullWidth();
                }
            }
        }

        var start = token.fullStart();
        if (start === 0) {
            return null;
        }

        return findToken(syntaxTree(token).sourceUnit(), start - 1, includeSkippedTokens);
    }
    TypeScript.previousToken = previousToken;

    function findToken(element, position, includeSkippedTokens) {
        if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
        var endOfFileToken = tryGetEndOfFileAt(element, position);
        if (endOfFileToken !== null) {
            return endOfFileToken;
        }

        if (position < 0 || position >= fullWidth(element)) {
            throw TypeScript.Errors.argumentOutOfRange("position");
        }

        var positionedToken = findTokenWorker(element, position);

        if (includeSkippedTokens) {
            return findSkippedTokenInPositionedToken(positionedToken, position) || positionedToken;
        }

        return positionedToken;
    }
    TypeScript.findToken = findToken;

    function findSkippedTokenInPositionedToken(positionedToken, position) {
        var positionInLeadingTriviaList = (position < start(positionedToken));
        return findSkippedTokenInTriviaList(positionedToken, position, positionInLeadingTriviaList);
    }
    TypeScript.findSkippedTokenInPositionedToken = findSkippedTokenInPositionedToken;

    function findSkippedTokenInLeadingTriviaList(positionedToken, position) {
        return findSkippedTokenInTriviaList(positionedToken, position, true);
    }
    TypeScript.findSkippedTokenInLeadingTriviaList = findSkippedTokenInLeadingTriviaList;

    function findSkippedTokenInTrailingTriviaList(positionedToken, position) {
        return findSkippedTokenInTriviaList(positionedToken, position, false);
    }
    TypeScript.findSkippedTokenInTrailingTriviaList = findSkippedTokenInTrailingTriviaList;

    function findSkippedTokenInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
        var triviaList = null;
        var fullStart;

        if (lookInLeadingTriviaList) {
            triviaList = positionedToken.leadingTrivia();
            fullStart = positionedToken.fullStart();
        } else {
            triviaList = positionedToken.trailingTrivia();
            fullStart = end(positionedToken);
        }

        if (triviaList && triviaList.hasSkippedToken()) {
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var triviaWidth = trivia.fullWidth();

                if (trivia.isSkippedToken() && position >= fullStart && position <= fullStart + triviaWidth) {
                    return trivia.skippedToken();
                }

                fullStart += triviaWidth;
            }
        }

        return null;
    }

    function findTokenWorker(element, position) {
        if (isToken(element)) {
            TypeScript.Debug.assert(fullWidth(element) > 0);
            return element;
        }

        if (isShared(element)) {
            throw TypeScript.Errors.invalidOperation();
        }

        for (var i = 0, n = childCount(element); i < n; i++) {
            var child = childAt(element, i);

            if (child !== null) {
                var childFullWidth = fullWidth(child);
                if (childFullWidth > 0) {
                    var childFullStart = fullStart(child);

                    if (position >= childFullStart) {
                        var childFullEnd = childFullStart + childFullWidth;

                        if (position < childFullEnd) {
                            return findTokenWorker(child, position);
                        }
                    }
                }
            }
        }

        throw TypeScript.Errors.invalidOperation();
    }

    function tryGetEndOfFileAt(element, position) {
        if (element.kind() === 120 /* SourceUnit */ && position === fullWidth(element)) {
            var sourceUnit = element;
            return sourceUnit.endOfFileToken;
        }

        return null;
    }

    function nextToken(token, text, includeSkippedTokens) {
        if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
        if (token.kind() === 10 /* EndOfFileToken */) {
            return null;
        }

        if (includeSkippedTokens) {
            var triviaList = token.trailingTrivia(text);
            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return trivia.skippedToken();
                    }
                }
            }
        }

        return findToken(syntaxTree(token).sourceUnit(), fullEnd(token), includeSkippedTokens);
    }
    TypeScript.nextToken = nextToken;

    function isNode(element) {
        if (element !== null) {
            var kind = element.kind();
            return kind >= 120 /* FirstNode */ && kind <= 247 /* LastNode */;
        }

        return false;
    }
    TypeScript.isNode = isNode;

    function isTokenKind(kind) {
        return kind >= 9 /* FirstToken */ && kind <= 119 /* LastToken */;
    }

    function isToken(element) {
        if (element !== null) {
            return isTokenKind(element.kind());
        }

        return false;
    }
    TypeScript.isToken = isToken;

    function isList(element) {
        return element !== null && element.kind() === 1 /* List */;
    }
    TypeScript.isList = isList;

    function isSeparatedList(element) {
        return element !== null && element.kind() === 2 /* SeparatedList */;
    }
    TypeScript.isSeparatedList = isSeparatedList;

    function syntaxID(element) {
        if (isShared(element)) {
            throw TypeScript.Errors.invalidOperation("Should not use shared syntax element as a key.");
        }

        var obj = element;
        if (obj._syntaxID === undefined) {
            obj._syntaxID = TypeScript.Syntax._nextSyntaxID++;
        }

        return obj._syntaxID;
    }
    TypeScript.syntaxID = syntaxID;

    function collectTextElements(element, elements, text) {
        if (element) {
            if (isToken(element)) {
                elements.push(element.fullText(text));
            } else {
                for (var i = 0, n = childCount(element); i < n; i++) {
                    collectTextElements(childAt(element, i), elements, text);
                }
            }
        }
    }

    function fullText(element, text) {
        if (isToken(element)) {
            return element.fullText(text);
        }

        var elements = [];
        collectTextElements(element, elements, text);

        return elements.join("");
    }
    TypeScript.fullText = fullText;

    function leadingTriviaWidth(element, text) {
        var token = firstToken(element);
        return token ? token.leadingTriviaWidth(text) : 0;
    }
    TypeScript.leadingTriviaWidth = leadingTriviaWidth;

    function trailingTriviaWidth(element, text) {
        var token = lastToken(element);
        return token ? token.trailingTriviaWidth(text) : 0;
    }
    TypeScript.trailingTriviaWidth = trailingTriviaWidth;

    function firstToken(element) {
        if (element) {
            var kind = element.kind();

            if (isTokenKind(kind)) {
                return fullWidth(element) > 0 || element.kind() === 10 /* EndOfFileToken */ ? element : null;
            }

            if (kind === 1 /* List */) {
                var array = element;
                for (var i = 0, n = array.length; i < n; i++) {
                    var token = firstToken(array[i]);
                    if (token) {
                        return token;
                    }
                }
            } else if (kind === 2 /* SeparatedList */) {
                var array = element;
                var separators = array.separators;
                for (var i = 0, n = array.length + separators.length; i < n; i++) {
                    var token = firstToken(i % 2 === 0 ? array[i / 2] : separators[(i - 1) / 2]);
                    if (token) {
                        return token;
                    }
                }
            } else {
                var metadata = TypeScript.nodeMetadata[kind];
                for (var i = 0, n = metadata.length; i < n; i++) {
                    var child = element[metadata[i]];
                    var token = firstToken(child);
                    if (token) {
                        return token;
                    }
                }

                if (element.kind() === 120 /* SourceUnit */) {
                    return element.endOfFileToken;
                }
            }
        }

        return null;
    }
    TypeScript.firstToken = firstToken;

    function lastToken(element) {
        if (isToken(element)) {
            return fullWidth(element) > 0 || element.kind() === 10 /* EndOfFileToken */ ? element : null;
        }

        if (element.kind() === 120 /* SourceUnit */) {
            return element.endOfFileToken;
        }

        for (var i = childCount(element) - 1; i >= 0; i--) {
            var child = childAt(element, i);
            if (child !== null) {
                var token = lastToken(child);
                if (token) {
                    return token;
                }
            }
        }

        return null;
    }
    TypeScript.lastToken = lastToken;

    function fullStart(element) {
        TypeScript.Debug.assert(!isShared(element));
        var token = isToken(element) ? element : firstToken(element);
        return token ? token.fullStart() : -1;
    }
    TypeScript.fullStart = fullStart;

    function fullWidth(element) {
        if (isToken(element)) {
            return element.fullWidth();
        }

        if (isShared(element)) {
            return 0;
        }

        var info = data(element);
        return info >>> 3 /* NodeFullWidthShift */;
    }
    TypeScript.fullWidth = fullWidth;

    function isIncrementallyUnusable(element) {
        if (isToken(element)) {
            return element.isIncrementallyUnusable();
        }

        if (isShared(element)) {
            return false;
        }

        return (data(element) & 2 /* NodeIncrementallyUnusableMask */) !== 0;
    }
    TypeScript.isIncrementallyUnusable = isIncrementallyUnusable;

    function data(element) {
        TypeScript.Debug.assert(isNode(element) || isList(element) || isSeparatedList(element));

        var dataElement = element;

        var info = dataElement.data;
        if (info === undefined) {
            info = 0;
        }

        if ((info & 1 /* NodeDataComputed */) === 0) {
            info |= computeData(element);
            dataElement.data = info;
        }

        return info;
    }

    function computeData(element) {
        var slotCount = childCount(element);

        var fullWidth = 0;

        var isIncrementallyUnusable = slotCount === 0;

        for (var i = 0, n = slotCount; i < n; i++) {
            var child = childAt(element, i);

            if (child) {
                fullWidth += TypeScript.fullWidth(child);

                isIncrementallyUnusable = isIncrementallyUnusable || TypeScript.isIncrementallyUnusable(child);
            }
        }

        return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
    }

    function start(element, text) {
        var token = isToken(element) ? element : firstToken(element);
        return token ? token.fullStart() + token.leadingTriviaWidth(text) : -1;
    }
    TypeScript.start = start;

    function end(element, text) {
        var token = isToken(element) ? element : lastToken(element);
        return token ? fullEnd(token) - token.trailingTriviaWidth(text) : -1;
    }
    TypeScript.end = end;

    function width(element, text) {
        if (isToken(element)) {
            return element.text().length;
        }
        return fullWidth(element) - leadingTriviaWidth(element, text) - trailingTriviaWidth(element, text);
    }
    TypeScript.width = width;

    function fullEnd(element) {
        return fullStart(element) + fullWidth(element);
    }
    TypeScript.fullEnd = fullEnd;

    function existsNewLineBetweenTokens(token1, token2, text) {
        if (token1 === token2) {
            return false;
        }

        if (token1 === null || token2 === null) {
            return true;
        }

        var lineMap = text.lineMap();
        return lineMap.getLineNumberFromPosition(end(token1, text)) !== lineMap.getLineNumberFromPosition(start(token2, text));
    }
    TypeScript.existsNewLineBetweenTokens = existsNewLineBetweenTokens;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            if (node.kind() === 150 /* ExpressionStatement */) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;

                if (expression.kind() === 14 /* StringLiteral */) {
                    return true;
                }
            }

            return false;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;

        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;

            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;

        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.kind();
            return tokenKind === 11 /* IdentifierName */ || SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;

        function isAccessibilityModifier(kind) {
            switch (kind) {
                case 57 /* PublicKeyword */:
                case 55 /* PrivateKeyword */:
                case 56 /* ProtectedKeyword */:
                    return true;
            }

            return false;
        }
        SyntaxFacts.isAccessibilityModifier = isAccessibilityModifier;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var _emptyList = [];

        var _emptySeparatedList = [];
        var _emptySeparators = [];

        _emptySeparatedList.separators = _emptySeparators;

        function assertEmptyLists() {
        }

        Array.prototype.kind = function () {
            return this.separators === undefined ? 1 /* List */ : 2 /* SeparatedList */;
        };

        Array.prototype.separatorCount = function () {
            assertEmptyLists();

            return this.separators.length;
        };

        Array.prototype.separatorAt = function (index) {
            assertEmptyLists();

            return this.separators[index];
        };

        function emptyList() {
            return _emptyList;
        }
        Syntax.emptyList = emptyList;

        function emptySeparatedList() {
            return _emptySeparatedList;
        }
        Syntax.emptySeparatedList = emptySeparatedList;

        function list(nodes) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return emptyList();
            }

            for (var i = 0, n = nodes.length; i < n; i++) {
                nodes[i].parent = nodes;
            }

            return nodes;
        }
        Syntax.list = list;

        function separatedList(nodes, separators) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return emptySeparatedList();
            }

            for (var i = 0, n = nodes.length; i < n; i++) {
                nodes[i].parent = nodes;
            }

            for (var i = 0, n = separators.length; i < n; i++) {
                separators[i].parent = nodes;
            }

            nodes.separators = separators.length === 0 ? _emptySeparators : separators;

            return nodes;
        }
        Syntax.separatedList = separatedList;

        function nonSeparatorIndexOf(list, ast) {
            for (var i = 0, n = list.length; i < n; i++) {
                if (list[i] === ast) {
                    return i;
                }
            }

            return -1;
        }
        Syntax.nonSeparatorIndexOf = nonSeparatorIndexOf;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNode = (function () {
        function SyntaxNode(data) {
            if (data) {
                this.data = data;
            }
        }
        SyntaxNode.prototype.kind = function () {
            return this.__kind;
        };
        return SyntaxNode;
    })();
    TypeScript.SyntaxNode = SyntaxNode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.nodeMetadata = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], ["moduleElements", "endOfFileToken"], ["left", "dotToken", "right"], ["openBraceToken", "typeMembers", "closeBraceToken"], ["typeParameterList", "parameterList", "equalsGreaterThanToken", "type"], ["type", "openBracketToken", "closeBracketToken"], ["newKeyword", "typeParameterList", "parameterList", "equalsGreaterThanToken", "type"], ["name", "typeArgumentList"], ["typeOfKeyword", "name"], ["openBracketToken", "types", "closeBracketToken"], ["modifiers", "interfaceKeyword", "identifier", "typeParameterList", "heritageClauses", "body"], ["modifiers", "functionKeyword", "identifier", "callSignature", "block", "semicolonToken"], ["modifiers", "moduleKeyword", "name", "stringLiteral", "openBraceToken", "moduleElements", "closeBraceToken"], ["modifiers", "classKeyword", "identifier", "typeParameterList", "heritageClauses", "openBraceToken", "classElements", "closeBraceToken"], ["modifiers", "enumKeyword", "identifier", "openBraceToken", "enumElements", "closeBraceToken"], ["modifiers", "importKeyword", "identifier", "equalsToken", "moduleReference", "semicolonToken"], ["exportKeyword", "equalsToken", "identifier", "semicolonToken"], ["modifiers", "propertyName", "callSignature", "block", "semicolonToken"], ["modifiers", "variableDeclarator", "semicolonToken"], ["modifiers", "constructorKeyword", "callSignature", "block", "semicolonToken"], ["modifiers", "indexSignature", "semicolonToken"], ["modifiers", "getKeyword", "propertyName", "callSignature", "block"], ["modifiers", "setKeyword", "propertyName", "callSignature", "block"], ["propertyName", "questionToken", "typeAnnotation"], ["typeParameterList", "parameterList", "typeAnnotation"], ["newKeyword", "callSignature"], ["openBracketToken", "parameters", "closeBracketToken", "typeAnnotation"], ["propertyName", "questionToken", "callSignature"], ["openBraceToken", "statements", "closeBraceToken"], ["ifKeyword", "openParenToken", "condition", "closeParenToken", "statement", "elseClause"], ["modifiers", "variableDeclaration", "semicolonToken"], ["expression", "semicolonToken"], ["returnKeyword", "expression", "semicolonToken"], ["switchKeyword", "openParenToken", "expression", "closeParenToken", "openBraceToken", "switchClauses", "closeBraceToken"], ["breakKeyword", "identifier", "semicolonToken"], ["continueKeyword", "identifier", "semicolonToken"], ["forKeyword", "openParenToken", "variableDeclaration", "initializer", "firstSemicolonToken", "condition", "secondSemicolonToken", "incrementor", "closeParenToken", "statement"], ["forKeyword", "openParenToken", "variableDeclaration", "left", "inKeyword", "expression", "closeParenToken", "statement"], ["semicolonToken"], ["throwKeyword", "expression", "semicolonToken"], ["whileKeyword", "openParenToken", "condition", "closeParenToken", "statement"], ["tryKeyword", "block", "catchClause", "finallyClause"], ["identifier", "colonToken", "statement"], ["doKeyword", "statement", "whileKeyword", "openParenToken", "condition", "closeParenToken", "semicolonToken"], ["debuggerKeyword", "semicolonToken"], ["withKeyword", "openParenToken", "condition", "closeParenToken", "statement"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["deleteKeyword", "expression"], ["typeOfKeyword", "expression"], ["voidKeyword", "expression"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["condition", "questionToken", "whenTrue", "colonToken", "whenFalse"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["operand", "operatorToken"], ["operand", "operatorToken"], ["expression", "dotToken", "name"], ["expression", "argumentList"], ["openBracketToken", "expressions", "closeBracketToken"], ["openBraceToken", "propertyAssignments", "closeBraceToken"], ["newKeyword", "expression", "argumentList"], ["openParenToken", "expression", "closeParenToken"], ["callSignature", "equalsGreaterThanToken", "block", "expression"], ["parameter", "equalsGreaterThanToken", "block", "expression"], ["lessThanToken", "type", "greaterThanToken", "expression"], ["expression", "openBracketToken", "argumentExpression", "closeBracketToken"], ["functionKeyword", "identifier", "callSignature", "block"], [], ["varKeyword", "variableDeclarators"], ["propertyName", "typeAnnotation", "equalsValueClause"], ["typeArgumentList", "openParenToken", "arguments", "closeParenToken"], ["openParenToken", "parameters", "closeParenToken"], ["lessThanToken", "typeArguments", "greaterThanToken"], ["lessThanToken", "typeParameters", "greaterThanToken"], ["extendsOrImplementsKeyword", "typeNames"], ["extendsOrImplementsKeyword", "typeNames"], ["equalsToken", "value"], ["caseKeyword", "expression", "colonToken", "statements"], ["defaultKeyword", "colonToken", "statements"], ["elseKeyword", "statement"], ["catchKeyword", "openParenToken", "identifier", "typeAnnotation", "closeParenToken", "block"], ["finallyKeyword", "block"], ["identifier", "constraint"], ["extendsKeyword", "typeOrExpression"], ["propertyName", "colonToken", "expression"], ["propertyName", "callSignature", "block"], ["dotDotDotToken", "modifiers", "identifier", "questionToken", "typeAnnotation", "equalsValueClause"], ["propertyName", "equalsValueClause"], ["colonToken", "type"], ["requireKeyword", "openParenToken", "stringLiteral", "closeParenToken"], ["moduleName"]];
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    function tokenValue(token) {
        if (token.fullWidth() === 0) {
            return null;
        }

        var kind = token.kind();
        var text = token.text();

        if (kind === 11 /* IdentifierName */) {
            return massageEscapes(text);
        }

        switch (kind) {
            case 37 /* TrueKeyword */:
                return true;
            case 24 /* FalseKeyword */:
                return false;
            case 32 /* NullKeyword */:
                return null;
        }

        if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
            return TypeScript.SyntaxFacts.getText(kind);
        }

        if (kind === 13 /* NumericLiteral */) {
            return TypeScript.IntegerUtilities.isHexInteger(text) ? parseInt(text, 16) : parseFloat(text);
        } else if (kind === 14 /* StringLiteral */) {
            if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                return massageEscapes(text.substr(1, text.length - 2));
            } else {
                return massageEscapes(text.substr(1));
            }
        } else if (kind === 12 /* RegularExpressionLiteral */) {
            return regularExpressionValue(text);
        } else if (kind === 10 /* EndOfFileToken */ || kind === 9 /* ErrorToken */) {
            return null;
        } else {
            throw TypeScript.Errors.invalidOperation();
        }
    }
    TypeScript.tokenValue = tokenValue;

    function tokenValueText(token) {
        var value = tokenValue(token);
        return value === null ? "" : massageDisallowedIdentifiers(value.toString());
    }
    TypeScript.tokenValueText = tokenValueText;

    function massageEscapes(text) {
        return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
    }
    TypeScript.massageEscapes = massageEscapes;

    function regularExpressionValue(text) {
        try  {
            var lastSlash = text.lastIndexOf("/");
            var body = text.substring(1, lastSlash);
            var flags = text.substring(lastSlash + 1);
            return new RegExp(body, flags);
        } catch (e) {
            return null;
        }
    }

    function massageDisallowedIdentifiers(text) {
        if (text.charCodeAt(0) === 95 /* _ */ && text.charCodeAt(1) === 95 /* _ */) {
            return "_" + text;
        }

        return text;
    }

    var characterArray = [];

    function convertEscapes(text) {
        characterArray.length = 0;
        var result = "";

        for (var i = 0, n = text.length; i < n; i++) {
            var ch = text.charCodeAt(i);

            if (ch === 92 /* backslash */) {
                i++;
                if (i < n) {
                    ch = text.charCodeAt(i);
                    switch (ch) {
                        case 48 /* _0 */:
                            characterArray.push(0 /* nullCharacter */);
                            continue;

                        case 98 /* b */:
                            characterArray.push(8 /* backspace */);
                            continue;

                        case 102 /* f */:
                            characterArray.push(12 /* formFeed */);
                            continue;

                        case 110 /* n */:
                            characterArray.push(10 /* lineFeed */);
                            continue;

                        case 114 /* r */:
                            characterArray.push(13 /* carriageReturn */);
                            continue;

                        case 116 /* t */:
                            characterArray.push(9 /* tab */);
                            continue;

                        case 118 /* v */:
                            characterArray.push(11 /* verticalTab */);
                            continue;

                        case 120 /* x */:
                            characterArray.push(hexValue(text, i + 1, 2));
                            i += 2;
                            continue;

                        case 117 /* u */:
                            characterArray.push(hexValue(text, i + 1, 4));
                            i += 4;
                            continue;

                        case 13 /* carriageReturn */:
                            var nextIndex = i + 1;
                            if (nextIndex < text.length && text.charCodeAt(nextIndex) === 10 /* lineFeed */) {
                                i++;
                            }
                            continue;

                        case 10 /* lineFeed */:
                        case 8233 /* paragraphSeparator */:
                        case 8232 /* lineSeparator */:
                            continue;

                        default:
                    }
                }
            }

            characterArray.push(ch);

            if (i && !(i % 1024)) {
                result = result.concat(String.fromCharCode.apply(null, characterArray));
                characterArray.length = 0;
            }
        }

        if (characterArray.length) {
            result = result.concat(String.fromCharCode.apply(null, characterArray));
        }

        return result;
    }

    function hexValue(text, start, length) {
        var intChar = 0;
        for (var i = 0; i < length; i++) {
            var ch2 = text.charCodeAt(start + i);
            if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                break;
            }

            intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
        }

        return intChar;
    }
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function realizeToken(token, text) {
            return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), token.leadingTrivia(text), token.text(), token.trailingTrivia(text));
        }
        Syntax.realizeToken = realizeToken;

        function convertKeywordToIdentifier(token) {
            return new ConvertedKeywordToken(token);
        }
        Syntax.convertKeywordToIdentifier = convertKeywordToIdentifier;

        function withLeadingTrivia(token, leadingTrivia, text) {
            return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), leadingTrivia, token.text(), token.trailingTrivia(text));
        }
        Syntax.withLeadingTrivia = withLeadingTrivia;

        function withTrailingTrivia(token, trailingTrivia, text) {
            return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), token.leadingTrivia(text), token.text(), trailingTrivia);
        }
        Syntax.withTrailingTrivia = withTrailingTrivia;

        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;

        var EmptyToken = (function () {
            function EmptyToken(_kind) {
                this._kind = _kind;
            }
            EmptyToken.prototype.setFullStart = function (fullStart) {
            };

            EmptyToken.prototype.kind = function () {
                return this._kind;
            };

            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.kind());
            };

            EmptyToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            EmptyToken.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };

            EmptyToken.prototype.fullWidth = function () {
                return 0;
            };

            EmptyToken.prototype.position = function () {
                var previousElement = this.previousNonZeroWidthElement();
                return previousElement === null ? 0 : TypeScript.fullStart(previousElement) + TypeScript.fullWidth(previousElement);
            };

            EmptyToken.prototype.previousNonZeroWidthElement = function () {
                var current = this;
                while (true) {
                    var parent = current.parent;
                    if (parent === null) {
                        TypeScript.Debug.assert(current.kind() === 120 /* SourceUnit */, "We had a node without a parent that was not the root node!");

                        return null;
                    }

                    for (var i = 0, n = TypeScript.childCount(parent); i < n; i++) {
                        if (TypeScript.childAt(parent, i) === current) {
                            break;
                        }
                    }

                    TypeScript.Debug.assert(i !== n, "Could not find current element in parent's child list!");

                    for (var j = i - 1; j >= 0; j--) {
                        var sibling = TypeScript.childAt(parent, j);
                        if (sibling && TypeScript.fullWidth(sibling) > 0) {
                            return sibling;
                        }
                    }

                    current = current.parent;
                }
            };

            EmptyToken.prototype.fullStart = function () {
                return this.position();
            };

            EmptyToken.prototype.text = function () {
                return "";
            };
            EmptyToken.prototype.fullText = function () {
                return "";
            };

            EmptyToken.prototype.hasLeadingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasSkippedToken = function () {
                return false;
            };

            EmptyToken.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.trailingTriviaWidth = function () {
                return 0;
            };

            EmptyToken.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.trailingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            return EmptyToken;
        })();

        var RealizedToken = (function () {
            function RealizedToken(fullStart, kind, isKeywordConvertedToIdentifier, leadingTrivia, text, trailingTrivia) {
                this._fullStart = fullStart;
                this._kind = kind;
                this._isKeywordConvertedToIdentifier = isKeywordConvertedToIdentifier;
                this._text = text;

                this._leadingTrivia = leadingTrivia.clone();
                this._trailingTrivia = trailingTrivia.clone();

                if (!this._leadingTrivia.isShared()) {
                    this._leadingTrivia.parent = this;
                }

                if (!this._trailingTrivia.isShared()) {
                    this._trailingTrivia.parent = this;
                }
            }
            RealizedToken.prototype.setFullStart = function (fullStart) {
                this._fullStart = fullStart;
            };

            RealizedToken.prototype.kind = function () {
                return this._kind;
            };

            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this._fullStart, this.kind(), this._isKeywordConvertedToIdentifier, this._leadingTrivia, this._text, this._trailingTrivia);
            };

            RealizedToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            RealizedToken.prototype.isKeywordConvertedToIdentifier = function () {
                return this._isKeywordConvertedToIdentifier;
            };

            RealizedToken.prototype.fullStart = function () {
                return this._fullStart;
            };
            RealizedToken.prototype.fullWidth = function () {
                return this._leadingTrivia.fullWidth() + this._text.length + this._trailingTrivia.fullWidth();
            };

            RealizedToken.prototype.text = function () {
                return this._text;
            };
            RealizedToken.prototype.fullText = function () {
                return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText();
            };

            RealizedToken.prototype.hasLeadingTrivia = function () {
                return this._leadingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasTrailingTrivia = function () {
                return this._trailingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasLeadingComment = function () {
                return this._leadingTrivia.hasComment();
            };
            RealizedToken.prototype.hasTrailingComment = function () {
                return this._trailingTrivia.hasComment();
            };

            RealizedToken.prototype.leadingTriviaWidth = function () {
                return this._leadingTrivia.fullWidth();
            };
            RealizedToken.prototype.trailingTriviaWidth = function () {
                return this._trailingTrivia.fullWidth();
            };

            RealizedToken.prototype.hasSkippedToken = function () {
                return this._leadingTrivia.hasSkippedToken() || this._trailingTrivia.hasSkippedToken();
            };

            RealizedToken.prototype.leadingTrivia = function () {
                return this._leadingTrivia;
            };
            RealizedToken.prototype.trailingTrivia = function () {
                return this._trailingTrivia;
            };
            return RealizedToken;
        })();

        var ConvertedKeywordToken = (function () {
            function ConvertedKeywordToken(underlyingToken) {
                this.underlyingToken = underlyingToken;
            }
            ConvertedKeywordToken.prototype.kind = function () {
                return 11 /* IdentifierName */;
            };

            ConvertedKeywordToken.prototype.setFullStart = function (fullStart) {
                this.underlyingToken.setFullStart(fullStart);
            };

            ConvertedKeywordToken.prototype.fullStart = function () {
                return this.underlyingToken.fullStart();
            };

            ConvertedKeywordToken.prototype.fullWidth = function () {
                return this.underlyingToken.fullWidth();
            };

            ConvertedKeywordToken.prototype.text = function () {
                return this.underlyingToken.text();
            };

            ConvertedKeywordToken.prototype.syntaxTreeText = function (text) {
                var result = text || TypeScript.syntaxTree(this).text;
                TypeScript.Debug.assert(result);
                return result;
            };

            ConvertedKeywordToken.prototype.fullText = function (text) {
                return this.underlyingToken.fullText(this.syntaxTreeText(text));
            };

            ConvertedKeywordToken.prototype.hasLeadingTrivia = function () {
                return this.underlyingToken.hasLeadingTrivia();
            };

            ConvertedKeywordToken.prototype.hasTrailingTrivia = function () {
                return this.underlyingToken.hasTrailingTrivia();
            };

            ConvertedKeywordToken.prototype.hasLeadingComment = function () {
                return this.underlyingToken.hasLeadingComment();
            };

            ConvertedKeywordToken.prototype.hasTrailingComment = function () {
                return this.underlyingToken.hasTrailingComment();
            };

            ConvertedKeywordToken.prototype.hasSkippedToken = function () {
                return this.underlyingToken.hasSkippedToken();
            };

            ConvertedKeywordToken.prototype.leadingTrivia = function (text) {
                var result = this.underlyingToken.leadingTrivia(this.syntaxTreeText(text));
                result.parent = this;
                return result;
            };

            ConvertedKeywordToken.prototype.trailingTrivia = function (text) {
                var result = this.underlyingToken.trailingTrivia(this.syntaxTreeText(text));
                result.parent = this;
                return result;
            };

            ConvertedKeywordToken.prototype.leadingTriviaWidth = function (text) {
                return this.underlyingToken.leadingTriviaWidth(this.syntaxTreeText(text));
            };

            ConvertedKeywordToken.prototype.trailingTriviaWidth = function (text) {
                return this.underlyingToken.trailingTriviaWidth(this.syntaxTreeText(text));
            };

            ConvertedKeywordToken.prototype.isKeywordConvertedToIdentifier = function () {
                return true;
            };

            ConvertedKeywordToken.prototype.isIncrementallyUnusable = function () {
                return this.underlyingToken.isIncrementallyUnusable();
            };

            ConvertedKeywordToken.prototype.clone = function () {
                return new ConvertedKeywordToken(this.underlyingToken);
            };
            return ConvertedKeywordToken;
        })();
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var AbstractTrivia = (function () {
            function AbstractTrivia(_kind) {
                this._kind = _kind;
            }
            AbstractTrivia.prototype.kind = function () {
                return this._kind;
            };

            AbstractTrivia.prototype.clone = function () {
                throw TypeScript.Errors.abstract();
            };

            AbstractTrivia.prototype.fullStart = function () {
                throw TypeScript.Errors.abstract();
            };

            AbstractTrivia.prototype.fullWidth = function () {
                throw TypeScript.Errors.abstract();
            };

            AbstractTrivia.prototype.fullText = function () {
                throw TypeScript.Errors.abstract();
            };

            AbstractTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.abstract();
            };

            AbstractTrivia.prototype.isWhitespace = function () {
                return this.kind() === 4 /* WhitespaceTrivia */;
            };

            AbstractTrivia.prototype.isComment = function () {
                return this.kind() === 7 /* SingleLineCommentTrivia */ || this.kind() === 6 /* MultiLineCommentTrivia */;
            };

            AbstractTrivia.prototype.isNewLine = function () {
                return this.kind() === 5 /* NewLineTrivia */;
            };

            AbstractTrivia.prototype.isSkippedToken = function () {
                return this.kind() === 8 /* SkippedTokenTrivia */;
            };
            return AbstractTrivia;
        })();

        var SkippedTokenTrivia = (function (_super) {
            __extends(SkippedTokenTrivia, _super);
            function SkippedTokenTrivia(_skippedToken, _fullText) {
                _super.call(this, 8 /* SkippedTokenTrivia */);
                this._skippedToken = _skippedToken;
                this._fullText = _fullText;

                _skippedToken.parent = this;
            }
            SkippedTokenTrivia.prototype.clone = function () {
                return new SkippedTokenTrivia(this._skippedToken.clone(), this._fullText);
            };

            SkippedTokenTrivia.prototype.fullStart = function () {
                return this._skippedToken.fullStart();
            };

            SkippedTokenTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };

            SkippedTokenTrivia.prototype.fullText = function () {
                return this._fullText;
            };

            SkippedTokenTrivia.prototype.skippedToken = function () {
                return this._skippedToken;
            };
            return SkippedTokenTrivia;
        })(AbstractTrivia);

        var DeferredTrivia = (function (_super) {
            __extends(DeferredTrivia, _super);
            function DeferredTrivia(kind, _text, _fullStart, _fullWidth) {
                _super.call(this, kind);
                this._text = _text;
                this._fullStart = _fullStart;
                this._fullWidth = _fullWidth;
            }
            DeferredTrivia.prototype.clone = function () {
                return new DeferredTrivia(this.kind(), this._text, this._fullStart, this._fullWidth);
            };

            DeferredTrivia.prototype.fullStart = function () {
                return this._fullStart;
            };

            DeferredTrivia.prototype.fullWidth = function () {
                return this._fullWidth;
            };

            DeferredTrivia.prototype.fullText = function () {
                return this._text.substr(this._fullStart, this._fullWidth);
            };

            DeferredTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.invalidOperation();
            };
            return DeferredTrivia;
        })(AbstractTrivia);

        function deferredTrivia(kind, text, fullStart, fullWidth) {
            return new DeferredTrivia(kind, text, fullStart, fullWidth);
        }
        Syntax.deferredTrivia = deferredTrivia;

        function skippedTokenTrivia(token, text) {
            TypeScript.Debug.assert(!token.hasLeadingTrivia());
            TypeScript.Debug.assert(!token.hasTrailingTrivia());
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return new SkippedTokenTrivia(token, token.fullText(text));
        }
        Syntax.skippedTokenTrivia = skippedTokenTrivia;

        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            var result = [];

            var triviaText = trivia.fullText();
            var currentIndex = 0;

            for (var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);

                var isCarriageReturnLineFeed = false;
                switch (ch) {
                    case 13 /* carriageReturn */:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === 10 /* lineFeed */) {
                            i++;
                        }

                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        result.push(triviaText.substring(currentIndex, i + 1));

                        currentIndex = i + 1;
                        continue;
                }
            }

            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptyTriviaList = (function () {
            function EmptyTriviaList() {
            }
            EmptyTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            EmptyTriviaList.prototype.isShared = function () {
                return true;
            };

            EmptyTriviaList.prototype.count = function () {
                return 0;
            };

            EmptyTriviaList.prototype.syntaxTriviaAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptyTriviaList.prototype.last = function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptyTriviaList.prototype.fullWidth = function () {
                return 0;
            };

            EmptyTriviaList.prototype.fullText = function () {
                return "";
            };

            EmptyTriviaList.prototype.hasComment = function () {
                return false;
            };

            EmptyTriviaList.prototype.hasNewLine = function () {
                return false;
            };

            EmptyTriviaList.prototype.hasSkippedToken = function () {
                return false;
            };

            EmptyTriviaList.prototype.toArray = function () {
                return [];
            };

            EmptyTriviaList.prototype.clone = function () {
                return this;
            };
            return EmptyTriviaList;
        })();
        ;

        Syntax.emptyTriviaList = new EmptyTriviaList();

        function isComment(trivia) {
            return trivia.kind() === 6 /* MultiLineCommentTrivia */ || trivia.kind() === 7 /* SingleLineCommentTrivia */;
        }

        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item.clone();
                this.item.parent = this;
            }
            SingletonSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            SingletonSyntaxTriviaList.prototype.isShared = function () {
                return false;
            };

            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };

            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };

            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind() === 5 /* NewLineTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.hasSkippedToken = function () {
                return this.item.kind() === 8 /* SkippedTokenTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [this.item];
            };

            SingletonSyntaxTriviaList.prototype.clone = function () {
                return new SingletonSyntaxTriviaList(this.item.clone());
            };
            return SingletonSyntaxTriviaList;
        })();

        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                var _this = this;
                this.trivia = trivia.map(function (t) {
                    var cloned = t.clone();
                    cloned.parent = _this;
                    return cloned;
                });
            }
            NormalSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            NormalSyntaxTriviaList.prototype.isShared = function () {
                return false;
            };

            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };

            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.trivia[index];
            };

            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };

            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) {
                    return t.fullWidth();
                });
            };

            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = [];

                for (var i = 0, n = this.trivia.length; i < n; i++) {
                    result.push(this.trivia[i].fullText());
                }

                return result.join("");
            };

            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 5 /* NewLineTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasSkippedToken = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 8 /* SkippedTokenTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };

            NormalSyntaxTriviaList.prototype.clone = function () {
                return new NormalSyntaxTriviaList(this.trivia.map(function (t) {
                    return t.clone();
                }));
            };
            return NormalSyntaxTriviaList;
        })();

        function triviaList(trivia) {
            if (trivia === undefined || trivia === null || trivia.length === 0) {
                return Syntax.emptyTriviaList;
            }

            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }

            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxUtilities = (function () {
        function SyntaxUtilities() {
        }
        SyntaxUtilities.isAnyFunctionExpressionOrDeclaration = function (ast) {
            switch (ast.kind()) {
                case 220 /* SimpleArrowFunctionExpression */:
                case 219 /* ParenthesizedArrowFunctionExpression */:
                case 223 /* FunctionExpression */:
                case 130 /* FunctionDeclaration */:
                case 136 /* MemberFunctionDeclaration */:
                case 242 /* FunctionPropertyAssignment */:
                case 138 /* ConstructorDeclaration */:
                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                    return true;
            }

            return false;
        };

        SyntaxUtilities.isLastTokenOnLine = function (token, text) {
            var _nextToken = TypeScript.nextToken(token, text);
            if (_nextToken === null) {
                return true;
            }

            var lineMap = text.lineMap();
            var tokenLine = lineMap.getLineNumberFromPosition(TypeScript.end(token, text));
            var nextTokenLine = lineMap.getLineNumberFromPosition(TypeScript.start(_nextToken, text));

            return tokenLine !== nextTokenLine;
        };

        SyntaxUtilities.isLeftHandSizeExpression = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 213 /* MemberAccessExpression */:
                    case 222 /* ElementAccessExpression */:
                    case 217 /* ObjectCreationExpression */:
                    case 214 /* InvocationExpression */:
                    case 215 /* ArrayLiteralExpression */:
                    case 218 /* ParenthesizedExpression */:
                    case 216 /* ObjectLiteralExpression */:
                    case 223 /* FunctionExpression */:
                    case 11 /* IdentifierName */:
                    case 12 /* RegularExpressionLiteral */:
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 50 /* SuperKeyword */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.isExpression = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 11 /* IdentifierName */:
                    case 12 /* RegularExpressionLiteral */:
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 50 /* SuperKeyword */:

                    case 165 /* PlusExpression */:
                    case 166 /* NegateExpression */:
                    case 167 /* BitwiseNotExpression */:
                    case 168 /* LogicalNotExpression */:
                    case 169 /* PreIncrementExpression */:
                    case 170 /* PreDecrementExpression */:
                    case 171 /* DeleteExpression */:
                    case 172 /* TypeOfExpression */:
                    case 173 /* VoidExpression */:
                    case 174 /* CommaExpression */:
                    case 175 /* AssignmentExpression */:
                    case 176 /* AddAssignmentExpression */:
                    case 177 /* SubtractAssignmentExpression */:
                    case 178 /* MultiplyAssignmentExpression */:
                    case 179 /* DivideAssignmentExpression */:
                    case 180 /* ModuloAssignmentExpression */:
                    case 181 /* AndAssignmentExpression */:
                    case 182 /* ExclusiveOrAssignmentExpression */:
                    case 183 /* OrAssignmentExpression */:
                    case 184 /* LeftShiftAssignmentExpression */:
                    case 185 /* SignedRightShiftAssignmentExpression */:
                    case 186 /* UnsignedRightShiftAssignmentExpression */:
                    case 187 /* ConditionalExpression */:
                    case 188 /* LogicalOrExpression */:
                    case 189 /* LogicalAndExpression */:
                    case 190 /* BitwiseOrExpression */:
                    case 191 /* BitwiseExclusiveOrExpression */:
                    case 192 /* BitwiseAndExpression */:
                    case 193 /* EqualsWithTypeConversionExpression */:
                    case 194 /* NotEqualsWithTypeConversionExpression */:
                    case 195 /* EqualsExpression */:
                    case 196 /* NotEqualsExpression */:
                    case 197 /* LessThanExpression */:
                    case 198 /* GreaterThanExpression */:
                    case 199 /* LessThanOrEqualExpression */:
                    case 200 /* GreaterThanOrEqualExpression */:
                    case 201 /* InstanceOfExpression */:
                    case 202 /* InExpression */:
                    case 203 /* LeftShiftExpression */:
                    case 204 /* SignedRightShiftExpression */:
                    case 205 /* UnsignedRightShiftExpression */:
                    case 206 /* MultiplyExpression */:
                    case 207 /* DivideExpression */:
                    case 208 /* ModuloExpression */:
                    case 209 /* AddExpression */:
                    case 210 /* SubtractExpression */:
                    case 211 /* PostIncrementExpression */:
                    case 212 /* PostDecrementExpression */:
                    case 213 /* MemberAccessExpression */:
                    case 214 /* InvocationExpression */:
                    case 215 /* ArrayLiteralExpression */:
                    case 216 /* ObjectLiteralExpression */:
                    case 217 /* ObjectCreationExpression */:
                    case 218 /* ParenthesizedExpression */:
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                    case 220 /* SimpleArrowFunctionExpression */:
                    case 221 /* CastExpression */:
                    case 222 /* ElementAccessExpression */:
                    case 223 /* FunctionExpression */:
                    case 224 /* OmittedExpression */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.isSwitchClause = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 234 /* CaseSwitchClause */:
                    case 235 /* DefaultSwitchClause */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.isTypeMember = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 144 /* ConstructSignature */:
                    case 146 /* MethodSignature */:
                    case 145 /* IndexSignature */:
                    case 142 /* PropertySignature */:
                    case 143 /* CallSignature */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.isClassElement = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 138 /* ConstructorDeclaration */:
                    case 139 /* IndexMemberDeclaration */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 137 /* MemberVariableDeclaration */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.isModuleElement = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 134 /* ImportDeclaration */:
                    case 135 /* ExportAssignment */:
                    case 132 /* ClassDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 133 /* EnumDeclaration */:

                    case 130 /* FunctionDeclaration */:
                    case 149 /* VariableStatement */:
                    case 147 /* Block */:
                    case 148 /* IfStatement */:
                    case 150 /* ExpressionStatement */:
                    case 158 /* ThrowStatement */:
                    case 151 /* ReturnStatement */:
                    case 152 /* SwitchStatement */:
                    case 153 /* BreakStatement */:
                    case 154 /* ContinueStatement */:
                    case 156 /* ForInStatement */:
                    case 155 /* ForStatement */:
                    case 159 /* WhileStatement */:
                    case 164 /* WithStatement */:
                    case 157 /* EmptyStatement */:
                    case 160 /* TryStatement */:
                    case 161 /* LabeledStatement */:
                    case 162 /* DoStatement */:
                    case 163 /* DebuggerStatement */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.isStatement = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 130 /* FunctionDeclaration */:
                    case 149 /* VariableStatement */:
                    case 147 /* Block */:
                    case 148 /* IfStatement */:
                    case 150 /* ExpressionStatement */:
                    case 158 /* ThrowStatement */:
                    case 151 /* ReturnStatement */:
                    case 152 /* SwitchStatement */:
                    case 153 /* BreakStatement */:
                    case 154 /* ContinueStatement */:
                    case 156 /* ForInStatement */:
                    case 155 /* ForStatement */:
                    case 159 /* WhileStatement */:
                    case 164 /* WithStatement */:
                    case 157 /* EmptyStatement */:
                    case 160 /* TryStatement */:
                    case 161 /* LabeledStatement */:
                    case 162 /* DoStatement */:
                    case 163 /* DebuggerStatement */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.isAngleBracket = function (positionedElement) {
            var element = positionedElement;
            var parent = positionedElement.parent;
            if (parent !== null && (element.kind() === 80 /* LessThanToken */ || element.kind() === 81 /* GreaterThanToken */)) {
                switch (parent.kind()) {
                    case 229 /* TypeArgumentList */:
                    case 230 /* TypeParameterList */:
                    case 221 /* CastExpression */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.getToken = function (list, kind) {
            for (var i = 0, n = list.length; i < n; i++) {
                var token = list[i];
                if (token.kind() === kind) {
                    return token;
                }
            }

            return null;
        };

        SyntaxUtilities.containsToken = function (list, kind) {
            return SyntaxUtilities.getToken(list, kind) !== null;
        };

        SyntaxUtilities.hasExportKeyword = function (moduleElement) {
            return SyntaxUtilities.getExportKeyword(moduleElement) !== null;
        };

        SyntaxUtilities.getExportKeyword = function (moduleElement) {
            switch (moduleElement.kind()) {
                case 131 /* ModuleDeclaration */:
                case 132 /* ClassDeclaration */:
                case 130 /* FunctionDeclaration */:
                case 149 /* VariableStatement */:
                case 133 /* EnumDeclaration */:
                case 129 /* InterfaceDeclaration */:
                case 134 /* ImportDeclaration */:
                    return SyntaxUtilities.getToken(moduleElement.modifiers, 47 /* ExportKeyword */);
                default:
                    return null;
            }
        };

        SyntaxUtilities.isAmbientDeclarationSyntax = function (positionNode) {
            if (!positionNode) {
                return false;
            }

            var node = positionNode;
            switch (node.kind()) {
                case 131 /* ModuleDeclaration */:
                case 132 /* ClassDeclaration */:
                case 130 /* FunctionDeclaration */:
                case 149 /* VariableStatement */:
                case 133 /* EnumDeclaration */:
                    if (SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                        return true;
                    }

                case 134 /* ImportDeclaration */:
                case 138 /* ConstructorDeclaration */:
                case 136 /* MemberFunctionDeclaration */:
                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                case 137 /* MemberVariableDeclaration */:
                    if (SyntaxUtilities.isClassElement(node) || SyntaxUtilities.isModuleElement(node)) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(positionNode));
                    }

                case 244 /* EnumElement */:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(TypeScript.Syntax.containingNode(positionNode)));

                default:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(positionNode));
            }
        };
        return SyntaxUtilities;
    })();
    TypeScript.SyntaxUtilities = SyntaxUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function visitNodeOrToken(visitor, element) {
        if (element === null) {
            return null;
        }
        if (TypeScript.isToken(element)) {
            return visitor.visitToken(element);
        }
        switch (element.kind()) {
            case 120 /* SourceUnit */: return visitor.visitSourceUnit(element);
            case 121 /* QualifiedName */: return visitor.visitQualifiedName(element);
            case 122 /* ObjectType */: return visitor.visitObjectType(element);
            case 123 /* FunctionType */: return visitor.visitFunctionType(element);
            case 124 /* ArrayType */: return visitor.visitArrayType(element);
            case 125 /* ConstructorType */: return visitor.visitConstructorType(element);
            case 126 /* GenericType */: return visitor.visitGenericType(element);
            case 127 /* TypeQuery */: return visitor.visitTypeQuery(element);
            case 128 /* TupleType */: return visitor.visitTupleType(element);
            case 129 /* InterfaceDeclaration */: return visitor.visitInterfaceDeclaration(element);
            case 130 /* FunctionDeclaration */: return visitor.visitFunctionDeclaration(element);
            case 131 /* ModuleDeclaration */: return visitor.visitModuleDeclaration(element);
            case 132 /* ClassDeclaration */: return visitor.visitClassDeclaration(element);
            case 133 /* EnumDeclaration */: return visitor.visitEnumDeclaration(element);
            case 134 /* ImportDeclaration */: return visitor.visitImportDeclaration(element);
            case 135 /* ExportAssignment */: return visitor.visitExportAssignment(element);
            case 136 /* MemberFunctionDeclaration */: return visitor.visitMemberFunctionDeclaration(element);
            case 137 /* MemberVariableDeclaration */: return visitor.visitMemberVariableDeclaration(element);
            case 138 /* ConstructorDeclaration */: return visitor.visitConstructorDeclaration(element);
            case 139 /* IndexMemberDeclaration */: return visitor.visitIndexMemberDeclaration(element);
            case 140 /* GetAccessor */: return visitor.visitGetAccessor(element);
            case 141 /* SetAccessor */: return visitor.visitSetAccessor(element);
            case 142 /* PropertySignature */: return visitor.visitPropertySignature(element);
            case 143 /* CallSignature */: return visitor.visitCallSignature(element);
            case 144 /* ConstructSignature */: return visitor.visitConstructSignature(element);
            case 145 /* IndexSignature */: return visitor.visitIndexSignature(element);
            case 146 /* MethodSignature */: return visitor.visitMethodSignature(element);
            case 147 /* Block */: return visitor.visitBlock(element);
            case 148 /* IfStatement */: return visitor.visitIfStatement(element);
            case 149 /* VariableStatement */: return visitor.visitVariableStatement(element);
            case 150 /* ExpressionStatement */: return visitor.visitExpressionStatement(element);
            case 151 /* ReturnStatement */: return visitor.visitReturnStatement(element);
            case 152 /* SwitchStatement */: return visitor.visitSwitchStatement(element);
            case 153 /* BreakStatement */: return visitor.visitBreakStatement(element);
            case 154 /* ContinueStatement */: return visitor.visitContinueStatement(element);
            case 155 /* ForStatement */: return visitor.visitForStatement(element);
            case 156 /* ForInStatement */: return visitor.visitForInStatement(element);
            case 157 /* EmptyStatement */: return visitor.visitEmptyStatement(element);
            case 158 /* ThrowStatement */: return visitor.visitThrowStatement(element);
            case 159 /* WhileStatement */: return visitor.visitWhileStatement(element);
            case 160 /* TryStatement */: return visitor.visitTryStatement(element);
            case 161 /* LabeledStatement */: return visitor.visitLabeledStatement(element);
            case 162 /* DoStatement */: return visitor.visitDoStatement(element);
            case 163 /* DebuggerStatement */: return visitor.visitDebuggerStatement(element);
            case 164 /* WithStatement */: return visitor.visitWithStatement(element);
            case 169 /* PreIncrementExpression */:
            case 170 /* PreDecrementExpression */:
            case 165 /* PlusExpression */:
            case 166 /* NegateExpression */:
            case 167 /* BitwiseNotExpression */:
            case 168 /* LogicalNotExpression */:
                return visitor.visitPrefixUnaryExpression(element);
            case 171 /* DeleteExpression */: return visitor.visitDeleteExpression(element);
            case 172 /* TypeOfExpression */: return visitor.visitTypeOfExpression(element);
            case 173 /* VoidExpression */: return visitor.visitVoidExpression(element);
            case 187 /* ConditionalExpression */: return visitor.visitConditionalExpression(element);
            case 206 /* MultiplyExpression */:
            case 207 /* DivideExpression */:
            case 208 /* ModuloExpression */:
            case 209 /* AddExpression */:
            case 210 /* SubtractExpression */:
            case 203 /* LeftShiftExpression */:
            case 204 /* SignedRightShiftExpression */:
            case 205 /* UnsignedRightShiftExpression */:
            case 197 /* LessThanExpression */:
            case 198 /* GreaterThanExpression */:
            case 199 /* LessThanOrEqualExpression */:
            case 200 /* GreaterThanOrEqualExpression */:
            case 201 /* InstanceOfExpression */:
            case 202 /* InExpression */:
            case 193 /* EqualsWithTypeConversionExpression */:
            case 194 /* NotEqualsWithTypeConversionExpression */:
            case 195 /* EqualsExpression */:
            case 196 /* NotEqualsExpression */:
            case 192 /* BitwiseAndExpression */:
            case 191 /* BitwiseExclusiveOrExpression */:
            case 190 /* BitwiseOrExpression */:
            case 189 /* LogicalAndExpression */:
            case 188 /* LogicalOrExpression */:
            case 183 /* OrAssignmentExpression */:
            case 181 /* AndAssignmentExpression */:
            case 182 /* ExclusiveOrAssignmentExpression */:
            case 184 /* LeftShiftAssignmentExpression */:
            case 185 /* SignedRightShiftAssignmentExpression */:
            case 186 /* UnsignedRightShiftAssignmentExpression */:
            case 176 /* AddAssignmentExpression */:
            case 177 /* SubtractAssignmentExpression */:
            case 178 /* MultiplyAssignmentExpression */:
            case 179 /* DivideAssignmentExpression */:
            case 180 /* ModuloAssignmentExpression */:
            case 175 /* AssignmentExpression */:
            case 174 /* CommaExpression */:
                return visitor.visitBinaryExpression(element);
            case 211 /* PostIncrementExpression */:
            case 212 /* PostDecrementExpression */:
                return visitor.visitPostfixUnaryExpression(element);
            case 213 /* MemberAccessExpression */: return visitor.visitMemberAccessExpression(element);
            case 214 /* InvocationExpression */: return visitor.visitInvocationExpression(element);
            case 215 /* ArrayLiteralExpression */: return visitor.visitArrayLiteralExpression(element);
            case 216 /* ObjectLiteralExpression */: return visitor.visitObjectLiteralExpression(element);
            case 217 /* ObjectCreationExpression */: return visitor.visitObjectCreationExpression(element);
            case 218 /* ParenthesizedExpression */: return visitor.visitParenthesizedExpression(element);
            case 219 /* ParenthesizedArrowFunctionExpression */: return visitor.visitParenthesizedArrowFunctionExpression(element);
            case 220 /* SimpleArrowFunctionExpression */: return visitor.visitSimpleArrowFunctionExpression(element);
            case 221 /* CastExpression */: return visitor.visitCastExpression(element);
            case 222 /* ElementAccessExpression */: return visitor.visitElementAccessExpression(element);
            case 223 /* FunctionExpression */: return visitor.visitFunctionExpression(element);
            case 224 /* OmittedExpression */: return visitor.visitOmittedExpression(element);
            case 225 /* VariableDeclaration */: return visitor.visitVariableDeclaration(element);
            case 226 /* VariableDeclarator */: return visitor.visitVariableDeclarator(element);
            case 227 /* ArgumentList */: return visitor.visitArgumentList(element);
            case 228 /* ParameterList */: return visitor.visitParameterList(element);
            case 229 /* TypeArgumentList */: return visitor.visitTypeArgumentList(element);
            case 230 /* TypeParameterList */: return visitor.visitTypeParameterList(element);
            case 231 /* ExtendsHeritageClause */:
            case 232 /* ImplementsHeritageClause */:
                return visitor.visitHeritageClause(element);
            case 233 /* EqualsValueClause */: return visitor.visitEqualsValueClause(element);
            case 234 /* CaseSwitchClause */: return visitor.visitCaseSwitchClause(element);
            case 235 /* DefaultSwitchClause */: return visitor.visitDefaultSwitchClause(element);
            case 236 /* ElseClause */: return visitor.visitElseClause(element);
            case 237 /* CatchClause */: return visitor.visitCatchClause(element);
            case 238 /* FinallyClause */: return visitor.visitFinallyClause(element);
            case 239 /* TypeParameter */: return visitor.visitTypeParameter(element);
            case 240 /* Constraint */: return visitor.visitConstraint(element);
            case 241 /* SimplePropertyAssignment */: return visitor.visitSimplePropertyAssignment(element);
            case 242 /* FunctionPropertyAssignment */: return visitor.visitFunctionPropertyAssignment(element);
            case 243 /* Parameter */: return visitor.visitParameter(element);
            case 244 /* EnumElement */: return visitor.visitEnumElement(element);
            case 245 /* TypeAnnotation */: return visitor.visitTypeAnnotation(element);
            case 246 /* ExternalModuleReference */: return visitor.visitExternalModuleReference(element);
            case 247 /* ModuleNameModuleReference */: return visitor.visitModuleNameModuleReference(element);
        }

        throw TypeScript.Errors.invalidOperation();
    }
    TypeScript.visitNodeOrToken = visitNodeOrToken;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() {
        }
        SyntaxWalker.prototype.visitToken = function (token) {
        };

        SyntaxWalker.prototype.visitNode = function (node) {
            TypeScript.visitNodeOrToken(this, node);
        };

        SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
            if (TypeScript.isToken(nodeOrToken)) {
                this.visitToken(nodeOrToken);
            } else {
                this.visitNode(nodeOrToken);
            }
        };

        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === null) {
                return;
            }

            this.visitToken(token);
        };

        SyntaxWalker.prototype.visitOptionalNode = function (node) {
            if (node === null) {
                return;
            }

            this.visitNode(node);
        };

        SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken === null) {
                return;
            }

            this.visitNodeOrToken(nodeOrToken);
        };

        SyntaxWalker.prototype.visitList = function (list) {
            for (var i = 0, n = list.length; i < n; i++) {
                this.visitNodeOrToken(list[i]);
            }
        };

        SyntaxWalker.prototype.visitSeparatedList = function (list) {
            for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                var item = TypeScript.childAt(list, i);
                this.visitNodeOrToken(item);
            }
        };

        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };

        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };

        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitFunctionType = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitArrayType = function (node) {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitGenericType = function (node) {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        };

        SyntaxWalker.prototype.visitTypeQuery = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.name);
        };

        SyntaxWalker.prototype.visitTupleType = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.types);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        };

        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.name);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.moduleReference);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitIndexMemberDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.indexSignature);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitGetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitSetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitCallSignature = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        };

        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        };

        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        };

        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        };

        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        };

        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        };

        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };

        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.visitNode(node.parameter);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };

        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        };

        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitArgumentList = function (node) {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        };

        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        };

        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        };

        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.typeOrExpression);
        };

        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitList(node.modifiers);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitEnumElement = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.requireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            this.visitNodeOrToken(node.moduleName);
        };
        return SyntaxWalker;
    })();
    TypeScript.SyntaxWalker = SyntaxWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DepthLimitedWalker = (function (_super) {
        __extends(DepthLimitedWalker, _super);
        function DepthLimitedWalker(maximumDepth) {
            _super.call(this);
            this._depth = 0;
            this._maximumDepth = 0;
            this._maximumDepth = maximumDepth;
        }
        DepthLimitedWalker.prototype.visitNode = function (node) {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                _super.prototype.visitNode.call(this, node);
                this._depth--;
            }
        };
        return DepthLimitedWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.DepthLimitedWalker = DepthLimitedWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Parser) {
        Parser.syntaxFactory;

        

        

        var arrayPool = [];
        var arrayPoolCount = 0;

        function getArray() {
            if (arrayPoolCount === 0) {
                return [];
            }

            arrayPoolCount--;
            var result = arrayPool[arrayPoolCount];
            arrayPool[arrayPoolCount] = null;

            return result;
        }

        function returnZeroLengthArray(array) {
            if (array.length === 0) {
                returnArray(array);
            }
        }

        function returnArray(array) {
            array.length = 0;
            arrayPool[arrayPoolCount] = array;
            arrayPoolCount++;
        }

        function createParseSyntaxTree() {
            var fileName;

            var source;

            var languageVersion;

            var listParsingState = 0;

            var isInStrictMode = false;

            var diagnostics = [];

            var parseNodeData = 0;

            function parseSyntaxTree(_source, isDeclaration) {
                fileName = _source.fileName;
                source = _source;
                languageVersion = source.languageVersion;

                var result = parseSyntaxTreeWorker(isDeclaration);

                diagnostics = [];
                parseNodeData = 0 /* None */;
                fileName = null;
                source.release();
                source = null;
                _source = null;

                return result;
            }

            function parseSyntaxTreeWorker(isDeclaration) {
                var sourceUnit = parseSourceUnit();

                var allDiagnostics = source.tokenDiagnostics().concat(diagnostics);
                allDiagnostics.sort(function (a, b) {
                    return a.start() - b.start();
                });

                return new TypeScript.SyntaxTree(Parser.syntaxFactory.isConcrete, sourceUnit, isDeclaration, allDiagnostics, fileName, source.text, languageVersion);
            }

            function getRewindPoint() {
                var rewindPoint = source.getRewindPoint();

                rewindPoint.diagnosticsCount = diagnostics.length;

                rewindPoint.isInStrictMode = isInStrictMode;
                rewindPoint.listParsingState = listParsingState;

                return rewindPoint;
            }

            function rewind(rewindPoint) {
                source.rewind(rewindPoint);

                diagnostics.length = rewindPoint.diagnosticsCount;
            }

            function releaseRewindPoint(rewindPoint) {
                source.releaseRewindPoint(rewindPoint);
            }

            function currentNode() {
                var node = source.currentNode();

                if (node === null || TypeScript.parsedInStrictMode(node) !== isInStrictMode) {
                    return null;
                }

                return node;
            }

            function currentToken() {
                return source.currentToken();
            }

            function currentContextualToken() {
                return source.currentContextualToken();
            }

            function peekToken(n) {
                return source.peekToken(n);
            }

            function consumeToken(token) {
                source.consumeToken(token);
                return token;
            }

            function consumeNode(node) {
                source.consumeNode(node);
            }

            function eatToken(kind) {
                var token = currentToken();
                if (token.kind() === kind) {
                    return consumeToken(token);
                }

                return createMissingToken(kind, token);
            }

            function tryEatToken(kind) {
                var _currentToken = currentToken();
                if (_currentToken.kind() === kind) {
                    return consumeToken(_currentToken);
                }

                return null;
            }

            function isIdentifier(token) {
                var tokenKind = token.kind();

                if (tokenKind === 11 /* IdentifierName */) {
                    return true;
                }

                if (tokenKind >= 51 /* FirstFutureReservedStrictKeyword */) {
                    if (tokenKind <= 59 /* LastFutureReservedStrictKeyword */) {
                        return !isInStrictMode;
                    }

                    return tokenKind <= 69 /* LastTypeScriptKeyword */;
                }

                return false;
            }

            function eatIdentifierNameToken() {
                var token = currentToken();

                var tokenKind = token.kind();
                if (tokenKind === 11 /* IdentifierName */) {
                    return consumeToken(token);
                }

                if (TypeScript.SyntaxFacts.isAnyKeyword(tokenKind)) {
                    return TypeScript.Syntax.convertKeywordToIdentifier(consumeToken(token));
                }

                return createMissingToken(11 /* IdentifierName */, token);
            }

            function eatOptionalIdentifierToken() {
                return isIdentifier(currentToken()) ? eatIdentifierToken() : null;
            }

            function eatIdentifierToken(diagnosticCode) {
                var token = currentToken();
                if (isIdentifier(token)) {
                    consumeToken(token);

                    if (token.kind() === 11 /* IdentifierName */) {
                        return token;
                    }

                    return TypeScript.Syntax.convertKeywordToIdentifier(token);
                }

                return createMissingToken(11 /* IdentifierName */, token, diagnosticCode);
            }

            function previousTokenHasTrailingNewLine(token) {
                var tokenFullStart = token.fullStart();
                if (tokenFullStart === 0) {
                    return false;
                }

                var lineNumber = source.text.lineMap().getLineNumberFromPosition(tokenFullStart);
                var lineStart = source.text.lineMap().getLineStartPosition(lineNumber);

                return lineStart == tokenFullStart;
            }

            function canEatAutomaticSemicolon(allowWithoutNewLine) {
                var token = currentToken();

                var tokenKind = token.kind();
                if (tokenKind === 10 /* EndOfFileToken */) {
                    return true;
                }

                if (tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }

                if (allowWithoutNewLine) {
                    return true;
                }

                if (previousTokenHasTrailingNewLine(token)) {
                    return true;
                }

                return false;
            }

            function canEatExplicitOrAutomaticSemicolon(allowWithoutNewline) {
                var token = currentToken();

                if (token.kind() === 78 /* SemicolonToken */) {
                    return true;
                }

                return canEatAutomaticSemicolon(allowWithoutNewline);
            }

            function eatExplicitOrAutomaticSemicolon(allowWithoutNewline) {
                var token = currentToken();

                if (token.kind() === 78 /* SemicolonToken */) {
                    return consumeToken(token);
                }

                if (canEatAutomaticSemicolon(allowWithoutNewline)) {
                    return null;
                }

                return eatToken(78 /* SemicolonToken */);
            }

            function createMissingToken(expectedKind, actual, diagnosticCode) {
                var diagnostic = getExpectedTokenDiagnostic(expectedKind, actual, diagnosticCode);
                addDiagnostic(diagnostic);

                return TypeScript.Syntax.emptyToken(expectedKind);
            }

            function getExpectedTokenDiagnostic(expectedKind, actual, diagnosticCode) {
                var token = currentToken();

                var args = null;

                if (!diagnosticCode) {
                    if (TypeScript.SyntaxFacts.isAnyKeyword(expectedKind) || TypeScript.SyntaxFacts.isAnyPunctuation(expectedKind)) {
                        diagnosticCode = TypeScript.DiagnosticCode._0_expected;
                        args = [TypeScript.SyntaxFacts.getText(expectedKind)];
                    } else {
                        if (actual !== null && TypeScript.SyntaxFacts.isAnyKeyword(actual.kind())) {
                            diagnosticCode = TypeScript.DiagnosticCode.Identifier_expected_0_is_a_keyword;
                            args = [TypeScript.SyntaxFacts.getText(actual.kind())];
                        } else {
                            diagnosticCode = TypeScript.DiagnosticCode.Identifier_expected;
                        }
                    }
                }

                return new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token, source.text), TypeScript.width(token), diagnosticCode, args);
            }

            function getBinaryExpressionPrecedence(tokenKind) {
                switch (tokenKind) {
                    case 104 /* BarBarToken */: return 2 /* LogicalOrExpressionPrecedence */;
                    case 103 /* AmpersandAmpersandToken */: return 3 /* LogicalAndExpressionPrecedence */;
                    case 99 /* BarToken */: return 4 /* BitwiseOrExpressionPrecedence */;
                    case 100 /* CaretToken */: return 5 /* BitwiseExclusiveOrExpressionPrecedence */;
                    case 98 /* AmpersandToken */: return 6 /* BitwiseAndExpressionPrecedence */;
                    case 84 /* EqualsEqualsToken */:
                    case 86 /* ExclamationEqualsToken */:
                    case 87 /* EqualsEqualsEqualsToken */:
                    case 88 /* ExclamationEqualsEqualsToken */:
                        return 7 /* EqualityExpressionPrecedence */;
                    case 80 /* LessThanToken */:
                    case 81 /* GreaterThanToken */:
                    case 82 /* LessThanEqualsToken */:
                    case 83 /* GreaterThanEqualsToken */:
                    case 30 /* InstanceOfKeyword */:
                    case 29 /* InKeyword */:
                        return 8 /* RelationalExpressionPrecedence */;
                    case 95 /* LessThanLessThanToken */:
                    case 96 /* GreaterThanGreaterThanToken */:
                    case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                        return 9 /* ShiftExpressionPrecdence */;
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                        return 10 /* AdditiveExpressionPrecedence */;
                    case 91 /* AsteriskToken */:
                    case 118 /* SlashToken */:
                    case 92 /* PercentToken */:
                        return 11 /* MultiplicativeExpressionPrecedence */;
                }

                throw TypeScript.Errors.invalidOperation();
            }

            function addSkippedTokenAfterNodeOrToken(nodeOrToken, skippedToken) {
                if (TypeScript.isToken(nodeOrToken)) {
                    return addSkippedTokenAfterToken(nodeOrToken, skippedToken);
                } else if (TypeScript.isNode(nodeOrToken)) {
                    return addSkippedTokenAfterNode(nodeOrToken, skippedToken);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }

            function replaceTokenInParent(node, oldToken, newToken) {
                replaceTokenInParentWorker(oldToken, newToken);

                var parent = oldToken.parent;
                newToken.parent = parent;

                while (true) {
                    TypeScript.Debug.assert(TypeScript.isNode(parent) || TypeScript.isList(parent) || TypeScript.isSeparatedList(parent));
                    var dataElement = parent;
                    if (dataElement.data) {
                        dataElement.data &= 4 /* NodeParsedInStrictModeMask */;
                    }

                    if (parent === node) {
                        break;
                    }

                    parent = parent.parent;
                }
            }

            function replaceTokenInParentWorker(oldToken, newToken) {
                var parent = oldToken.parent;

                if (TypeScript.isNode(parent)) {
                    var node = parent;
                    for (var key in node) {
                        if (node[key] === oldToken) {
                            node[key] = newToken;
                            return;
                        }
                    }
                } else if (TypeScript.isList(parent)) {
                    var list1 = parent;
                    for (var i = 0, n = list1.length; i < n; i++) {
                        if (list1[i] === oldToken) {
                            list1[i] = newToken;
                            return;
                        }
                    }
                } else if (TypeScript.isSeparatedList(parent)) {
                    var list2 = parent;
                    for (var i = 0, n = TypeScript.childCount(list2); i < n; i++) {
                        if (TypeScript.childAt(list2, i) === oldToken) {
                            if (i % 2 === 0) {
                                list2[i / 2] = newToken;
                            } else {
                                list2.separators[(i - 1) / 2] = newToken;
                            }
                            return;
                        }
                    }
                }

                throw TypeScript.Errors.invalidOperation();
            }

            function addSkippedTokenAfterNode(node, skippedToken) {
                var oldToken = TypeScript.lastToken(node);
                var newToken = addSkippedTokenAfterToken(oldToken, skippedToken);

                replaceTokenInParent(node, oldToken, newToken);
                return node;
            }

            function addSkippedTokensBeforeNode(node, skippedTokens) {
                if (skippedTokens.length > 0) {
                    var oldToken = TypeScript.firstToken(node);
                    var newToken = addSkippedTokensBeforeToken(oldToken, skippedTokens);

                    replaceTokenInParent(node, oldToken, newToken);
                }

                return node;
            }

            function addSkippedTokensBeforeToken(token, skippedTokens) {
                var leadingTrivia = [];
                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    var skippedToken = skippedTokens[i];
                    addSkippedTokenToTriviaArray(leadingTrivia, skippedToken);
                }

                addTriviaTo(token.leadingTrivia(source.text), leadingTrivia);

                var updatedToken = TypeScript.Syntax.withLeadingTrivia(token, TypeScript.Syntax.triviaList(leadingTrivia), source.text);

                updatedToken.setFullStart(skippedTokens[0].fullStart());

                returnArray(skippedTokens);

                return updatedToken;
            }

            function addSkippedTokensAfterToken(token, skippedTokens) {
                if (skippedTokens.length === 0) {
                    returnArray(skippedTokens);
                    return token;
                }

                var trailingTrivia = token.trailingTrivia(source.text).toArray();

                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
                }

                returnArray(skippedTokens);
                return TypeScript.Syntax.withTrailingTrivia(token, TypeScript.Syntax.triviaList(trailingTrivia), source.text);
            }

            function addSkippedTokenAfterToken(token, skippedToken) {
                var trailingTrivia = token.trailingTrivia(source.text).toArray();
                addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);

                return TypeScript.Syntax.withTrailingTrivia(token, TypeScript.Syntax.triviaList(trailingTrivia), source.text);
            }

            function addSkippedTokenToTriviaArray(array, skippedToken) {
                addTriviaTo(skippedToken.leadingTrivia(source.text), array);

                var trimmedToken = TypeScript.Syntax.withTrailingTrivia(TypeScript.Syntax.withLeadingTrivia(skippedToken, TypeScript.Syntax.emptyTriviaList, source.text), TypeScript.Syntax.emptyTriviaList, source.text);

                trimmedToken.setFullStart(TypeScript.start(skippedToken, source.text));

                array.push(TypeScript.Syntax.skippedTokenTrivia(trimmedToken, source.text));

                addTriviaTo(skippedToken.trailingTrivia(source.text), array);
            }

            function addTriviaTo(list, array) {
                for (var i = 0, n = list.count(); i < n; i++) {
                    array.push(list.syntaxTriviaAt(i));
                }
            }

            function setStrictMode(_isInStrictMode) {
                isInStrictMode = _isInStrictMode;
                parseNodeData = _isInStrictMode ? 4 /* NodeParsedInStrictModeMask */ : 0;
            }

            function parseSourceUnit() {
                var savedIsInStrictMode = isInStrictMode;

                var skippedTokens = getArray();
                var moduleElements = parseSyntaxList(0 /* SourceUnit_ModuleElements */, skippedTokens, updateStrictModeState);

                setStrictMode(savedIsInStrictMode);

                var sourceUnit = new Parser.syntaxFactory.SourceUnitSyntax(parseNodeData, moduleElements, currentToken());

                sourceUnit = addSkippedTokensBeforeNode(sourceUnit, skippedTokens);

                if (TypeScript.Debug.shouldAssert(2 /* Aggressive */)) {
                    TypeScript.Debug.assert(TypeScript.fullWidth(sourceUnit) === source.text.length());

                    if (TypeScript.Debug.shouldAssert(3 /* VeryAggressive */)) {
                        TypeScript.Debug.assert(TypeScript.fullText(sourceUnit) === source.text.substr(0, source.text.length()));
                    }
                }

                return sourceUnit;
            }

            function updateStrictModeState(items) {
                if (!isInStrictMode) {
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (!TypeScript.SyntaxFacts.isDirectivePrologueElement(item)) {
                            return;
                        }
                    }

                    setStrictMode(TypeScript.SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
                }
            }

            function isModuleElement(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isModuleElement(currentNode())) {
                    return true;
                }

                var _modifierCount = modifierCount();
                return isInterfaceEnumClassModuleImportOrExport(_modifierCount) || isStatement(_modifierCount, inErrorRecovery);
            }

            function tryParseModuleElement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isModuleElement(node)) {
                    consumeNode(node);
                    return node;
                }

                var _currentToken = currentToken();
                var _modifierCount = modifierCount();

                if (_modifierCount) {
                    switch (peekToken(_modifierCount).kind()) {
                        case 49 /* ImportKeyword */: return parseImportDeclaration();
                        case 65 /* ModuleKeyword */: return parseModuleDeclaration();
                        case 52 /* InterfaceKeyword */: return parseInterfaceDeclaration();
                        case 44 /* ClassKeyword */: return parseClassDeclaration();
                        case 46 /* EnumKeyword */: return parseEnumDeclaration();
                    }
                }

                var nextToken = peekToken(1);
                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 65 /* ModuleKeyword */:
                        if (isIdentifier(nextToken) || nextToken.kind() === 14 /* StringLiteral */) {
                            return parseModuleDeclaration();
                        }
                        break;

                    case 49 /* ImportKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseImportDeclaration();
                        }
                        break;

                    case 44 /* ClassKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseClassDeclaration();
                        }
                        break;

                    case 46 /* EnumKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseEnumDeclaration();
                        }
                        break;

                    case 52 /* InterfaceKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseInterfaceDeclaration();
                        }
                        break;

                    case 47 /* ExportKeyword */:
                        if (nextToken.kind() === 107 /* EqualsToken */) {
                            return parseExportAssignment();
                        }
                        break;
                }

                return tryParseStatementWorker(_currentToken, currentTokenKind, _modifierCount, inErrorRecovery);
            }

            function parseImportDeclaration() {
                return new Parser.syntaxFactory.ImportDeclarationSyntax(parseNodeData, parseModifiers(), eatToken(49 /* ImportKeyword */), eatIdentifierToken(), eatToken(107 /* EqualsToken */), parseModuleReference(), eatExplicitOrAutomaticSemicolon(false));
            }

            function parseExportAssignment() {
                return new Parser.syntaxFactory.ExportAssignmentSyntax(parseNodeData, eatToken(47 /* ExportKeyword */), eatToken(107 /* EqualsToken */), eatIdentifierToken(), eatExplicitOrAutomaticSemicolon(false));
            }

            function parseModuleReference() {
                return isExternalModuleReference() ? parseExternalModuleReference() : parseModuleNameModuleReference();
            }

            function isExternalModuleReference() {
                return currentToken().kind() === 66 /* RequireKeyword */ && peekToken(1).kind() === 72 /* OpenParenToken */;
            }

            function parseExternalModuleReference() {
                return new Parser.syntaxFactory.ExternalModuleReferenceSyntax(parseNodeData, eatToken(66 /* RequireKeyword */), eatToken(72 /* OpenParenToken */), eatToken(14 /* StringLiteral */), eatToken(73 /* CloseParenToken */));
            }

            function parseModuleNameModuleReference() {
                return new Parser.syntaxFactory.ModuleNameModuleReferenceSyntax(parseNodeData, parseName(false));
            }

            function tryParseTypeArgumentList(inExpression) {
                var _currentToken = currentToken();
                if (_currentToken.kind() !== 80 /* LessThanToken */) {
                    return null;
                }

                if (!inExpression) {
                    var lessThanToken = consumeToken(_currentToken);

                    var skippedTokens = getArray();
                    var typeArguments = parseSeparatedSyntaxList(19 /* TypeArgumentList_Types */, skippedTokens);
                    lessThanToken = addSkippedTokensAfterToken(lessThanToken, skippedTokens);

                    return new Parser.syntaxFactory.TypeArgumentListSyntax(parseNodeData, lessThanToken, typeArguments, eatToken(81 /* GreaterThanToken */));
                }

                var rewindPoint = getRewindPoint();

                var lessThanToken = consumeToken(_currentToken);

                var skippedTokens = getArray();
                var typeArguments = parseSeparatedSyntaxList(19 /* TypeArgumentList_Types */, skippedTokens);
                var lessThanToken = addSkippedTokensAfterToken(lessThanToken, skippedTokens);

                var greaterThanToken = eatToken(81 /* GreaterThanToken */);

                if (greaterThanToken.fullWidth() === 0 || !canFollowTypeArgumentListInExpression(currentToken().kind())) {
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return null;
                } else {
                    releaseRewindPoint(rewindPoint);
                    return new Parser.syntaxFactory.TypeArgumentListSyntax(parseNodeData, lessThanToken, typeArguments, greaterThanToken);
                }
            }

            function canFollowTypeArgumentListInExpression(kind) {
                switch (kind) {
                    case 72 /* OpenParenToken */:
                    case 76 /* DotToken */:

                    case 73 /* CloseParenToken */:
                    case 75 /* CloseBracketToken */:
                    case 106 /* ColonToken */:
                    case 78 /* SemicolonToken */:
                    case 79 /* CommaToken */:
                    case 105 /* QuestionToken */:
                    case 84 /* EqualsEqualsToken */:
                    case 87 /* EqualsEqualsEqualsToken */:
                    case 86 /* ExclamationEqualsToken */:
                    case 88 /* ExclamationEqualsEqualsToken */:
                    case 103 /* AmpersandAmpersandToken */:
                    case 104 /* BarBarToken */:
                    case 100 /* CaretToken */:
                    case 98 /* AmpersandToken */:
                    case 99 /* BarToken */:
                    case 71 /* CloseBraceToken */:
                    case 10 /* EndOfFileToken */:
                        return true;

                    default:
                        return false;
                }
            }

            function parseName(allowIdentifierName) {
                return tryParseName(allowIdentifierName) || eatIdentifierToken();
            }

            function eatRightSideOfName(allowIdentifierNames) {
                var _currentToken = currentToken();

                if (TypeScript.SyntaxFacts.isAnyKeyword(_currentToken.kind()) && previousTokenHasTrailingNewLine(_currentToken)) {
                    var token1 = peekToken(1);
                    if (!TypeScript.existsNewLineBetweenTokens(_currentToken, token1, source.text) && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                        return createMissingToken(11 /* IdentifierName */, _currentToken);
                    }
                }

                return allowIdentifierNames ? eatIdentifierNameToken() : eatIdentifierToken();
            }

            function tryParseName(allowIdentifierNames) {
                var token0 = currentToken();
                var shouldContinue = isIdentifier(token0);
                if (!shouldContinue) {
                    return null;
                }

                var current = eatIdentifierToken();

                while (shouldContinue && currentToken().kind() === 76 /* DotToken */) {
                    var dotToken = consumeToken(currentToken());
                    var identifierName = eatRightSideOfName(allowIdentifierNames);

                    current = new Parser.syntaxFactory.QualifiedNameSyntax(parseNodeData, current, dotToken, identifierName);
                    shouldContinue = identifierName.fullWidth() > 0;
                }

                return current;
            }

            function parseEnumDeclaration() {
                var modifiers = parseModifiers();
                var enumKeyword = eatToken(46 /* EnumKeyword */);
                var identifier = eatIdentifierToken();

                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var enumElements = TypeScript.Syntax.emptySeparatedList();

                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    enumElements = parseSeparatedSyntaxList(8 /* EnumDeclaration_EnumElements */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }

                return new Parser.syntaxFactory.EnumDeclarationSyntax(parseNodeData, modifiers, enumKeyword, identifier, openBraceToken, enumElements, eatToken(71 /* CloseBraceToken */));
            }

            function isEnumElement(inErrorRecovery) {
                var node = currentNode();
                if (node !== null && node.kind() === 244 /* EnumElement */) {
                    return true;
                }

                return isPropertyName(currentToken(), inErrorRecovery);
            }

            function tryParseEnumElementEqualsValueClause() {
                return isEqualsValueClause(false) ? parseEqualsValueClause(true) : null;
            }

            function tryParseEnumElement(inErrorRecovery) {
                var node = currentNode();
                if (node !== null && node.kind() === 244 /* EnumElement */) {
                    consumeNode(node);
                    return node;
                }

                if (!isPropertyName(currentToken(), inErrorRecovery)) {
                    return null;
                }

                return new Parser.syntaxFactory.EnumElementSyntax(parseNodeData, eatPropertyName(), tryParseEnumElementEqualsValueClause());
            }

            function isModifierKind(kind) {
                switch (kind) {
                    case 47 /* ExportKeyword */:
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 56 /* ProtectedKeyword */:
                    case 58 /* StaticKeyword */:
                    case 63 /* DeclareKeyword */:
                        return true;
                }

                return false;
            }

            function isModifier(token, index) {
                if (isModifierKind(token.kind())) {
                    var nextToken = peekToken(index + 1);
                    var nextTokenKind = nextToken.kind();

                    switch (nextTokenKind) {
                        case 11 /* IdentifierName */:
                        case 74 /* OpenBracketToken */:
                        case 13 /* NumericLiteral */:
                        case 14 /* StringLiteral */:
                            return true;
                        default:
                            return TypeScript.SyntaxFacts.isAnyKeyword(nextTokenKind);
                    }
                }

                return false;
            }

            function modifierCount() {
                var modifierCount = 0;
                while (isModifier(peekToken(modifierCount), modifierCount)) {
                    modifierCount++;
                }

                return modifierCount;
            }

            function parseModifiers() {
                var tokens = getArray();

                while (true) {
                    var token = currentToken();
                    if (isModifier(token, 0)) {
                        tokens.push(consumeToken(token));
                        continue;
                    }

                    break;
                }

                var result = TypeScript.Syntax.list(tokens);

                returnZeroLengthArray(tokens);

                return result;
            }

            function parseHeritageClauses() {
                var heritageClauses = TypeScript.Syntax.emptyList();

                if (isHeritageClause()) {
                    heritageClauses = parseSyntaxList(10 /* ClassOrInterfaceDeclaration_HeritageClauses */, null);
                }

                return heritageClauses;
            }

            function tryParseHeritageClauseTypeName() {
                return isHeritageClauseTypeName() ? tryParseNameOrGenericType() : null;
            }

            function parseClassDeclaration() {
                var modifiers = parseModifiers();
                var classKeyword = eatToken(44 /* ClassKeyword */);
                var identifier = eatIdentifierToken();
                var typeParameterList = tryParseTypeParameterList(false);
                var heritageClauses = parseHeritageClauses();
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var classElements = TypeScript.Syntax.emptyList();

                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    classElements = parseSyntaxList(1 /* ClassDeclaration_ClassElements */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }
                ;

                return new Parser.syntaxFactory.ClassDeclarationSyntax(parseNodeData, modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, eatToken(71 /* CloseBraceToken */));
            }

            function isAccessor(modifierCount, inErrorRecovery) {
                var tokenKind = peekToken(modifierCount).kind();
                if (tokenKind !== 64 /* GetKeyword */ && tokenKind !== 68 /* SetKeyword */) {
                    return false;
                }

                return isPropertyName(peekToken(modifierCount + 1), inErrorRecovery);
            }

            function parseAccessor(checkForStrictMode) {
                var modifiers = parseModifiers();
                var _currenToken = currentToken();
                var tokenKind = _currenToken.kind();

                if (tokenKind === 64 /* GetKeyword */) {
                    return parseGetMemberAccessorDeclaration(modifiers, _currenToken, checkForStrictMode);
                } else if (tokenKind === 68 /* SetKeyword */) {
                    return parseSetMemberAccessorDeclaration(modifiers, _currenToken, checkForStrictMode);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }

            function parseGetMemberAccessorDeclaration(modifiers, getKeyword, checkForStrictMode) {
                return new Parser.syntaxFactory.GetAccessorSyntax(parseNodeData, modifiers, consumeToken(getKeyword), eatPropertyName(), parseCallSignature(false), parseBlock(false, checkForStrictMode));
            }

            function parseSetMemberAccessorDeclaration(modifiers, setKeyword, checkForStrictMode) {
                return new Parser.syntaxFactory.SetAccessorSyntax(parseNodeData, modifiers, consumeToken(setKeyword), eatPropertyName(), parseCallSignature(false), parseBlock(false, checkForStrictMode));
            }

            function isClassElement(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isClassElement(currentNode())) {
                    return true;
                }

                var _modifierCount = modifierCount();
                return isConstructorDeclaration(_modifierCount) || isMemberFunctionDeclaration(_modifierCount, inErrorRecovery) || isAccessor(_modifierCount, inErrorRecovery) || isMemberVariableDeclaration(_modifierCount, inErrorRecovery) || isIndexMemberDeclaration(_modifierCount);
            }

            function tryParseClassElement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isClassElement(node)) {
                    consumeNode(node);
                    return node;
                }

                var _modifierCount = modifierCount();
                if (isConstructorDeclaration(_modifierCount)) {
                    return parseConstructorDeclaration();
                } else if (isMemberFunctionDeclaration(_modifierCount, inErrorRecovery)) {
                    return parseMemberFunctionDeclaration();
                } else if (isAccessor(_modifierCount, inErrorRecovery)) {
                    return parseAccessor(false);
                } else if (isMemberVariableDeclaration(_modifierCount, inErrorRecovery)) {
                    return parseMemberVariableDeclaration();
                } else if (isIndexMemberDeclaration(_modifierCount)) {
                    return parseIndexMemberDeclaration();
                } else {
                    return null;
                }
            }

            function isConstructorDeclaration(modifierCount) {
                return peekToken(modifierCount).kind() === 62 /* ConstructorKeyword */;
            }

            function parseConstructorDeclaration() {
                var modifiers = parseModifiers();
                var constructorKeyword = eatToken(62 /* ConstructorKeyword */);
                var callSignature = parseCallSignature(false);

                var semicolonToken = null;
                var block = null;

                if (isBlock()) {
                    block = parseBlock(false, true);
                } else {
                    semicolonToken = eatExplicitOrAutomaticSemicolon(false);
                }

                return new Parser.syntaxFactory.ConstructorDeclarationSyntax(parseNodeData, modifiers, constructorKeyword, callSignature, block, semicolonToken);
            }

            function isMemberFunctionDeclaration(modifierCount, inErrorRecovery) {
                return isPropertyName(peekToken(modifierCount), inErrorRecovery) && isCallSignature(modifierCount + 1);
            }

            function parseMemberFunctionDeclaration() {
                var modifiers = parseModifiers();
                var propertyName = eatPropertyName();
                var callSignature = parseCallSignature(false);

                var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);

                var block = null;
                var semicolon = null;

                if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                    block = parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolon = eatExplicitOrAutomaticSemicolon(false);
                }

                return new Parser.syntaxFactory.MemberFunctionDeclarationSyntax(parseNodeData, modifiers, propertyName, callSignature, block, semicolon);
            }

            function isDefinitelyMemberVariablePropertyName(index) {
                if (TypeScript.SyntaxFacts.isAnyKeyword(peekToken(index).kind())) {
                    var nextToken = peekToken(index + 1);
                    switch (nextToken.kind()) {
                        case 78 /* SemicolonToken */:
                        case 107 /* EqualsToken */:
                        case 106 /* ColonToken */:
                        case 71 /* CloseBraceToken */:
                        case 10 /* EndOfFileToken */:
                            return true;
                        default:
                            return previousTokenHasTrailingNewLine(nextToken);
                    }
                } else {
                    return true;
                }
            }

            function isMemberVariableDeclaration(modifierCount, inErrorRecover) {
                return isPropertyName(peekToken(modifierCount), inErrorRecover) && isDefinitelyMemberVariablePropertyName(modifierCount);
            }

            function parseMemberVariableDeclaration() {
                return new Parser.syntaxFactory.MemberVariableDeclarationSyntax(parseNodeData, parseModifiers(), tryParseVariableDeclarator(true, true), eatExplicitOrAutomaticSemicolon(false));
            }

            function isIndexMemberDeclaration(modifierCount) {
                return isIndexSignature(modifierCount);
            }

            function parseIndexMemberDeclaration() {
                return new Parser.syntaxFactory.IndexMemberDeclarationSyntax(parseNodeData, parseModifiers(), parseIndexSignature(), eatExplicitOrAutomaticSemicolon(false));
            }

            function tryAddUnexpectedEqualsGreaterThanToken(callSignature) {
                var token0 = currentToken();

                var hasEqualsGreaterThanToken = token0.kind() === 85 /* EqualsGreaterThanToken */;
                if (hasEqualsGreaterThanToken) {
                    var _lastToken = TypeScript.lastToken(callSignature);
                    if (_lastToken && _lastToken.fullWidth() > 0) {
                        var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token0, source.text), TypeScript.width(token0), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [TypeScript.SyntaxFacts.getText(70 /* OpenBraceToken */)]);
                        addDiagnostic(diagnostic);

                        consumeToken(token0);

                        if (Parser.syntaxFactory.isConcrete) {
                            addSkippedTokenAfterNode(callSignature, token0);
                        }
                        return true;
                    }
                }

                return false;
            }

            function isFunctionDeclaration(modifierCount) {
                return peekToken(modifierCount).kind() === 27 /* FunctionKeyword */;
            }

            function parseFunctionDeclaration() {
                var modifiers = parseModifiers();
                var functionKeyword = eatToken(27 /* FunctionKeyword */);
                var identifier = eatIdentifierToken();
                var callSignature = parseCallSignature(false);

                var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);

                var semicolonToken = null;
                var block = null;

                if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                    block = parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolonToken = eatExplicitOrAutomaticSemicolon(false);
                }

                return new Parser.syntaxFactory.FunctionDeclarationSyntax(parseNodeData, modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
            }

            function parseModuleDeclaration() {
                var modifiers = parseModifiers();
                var moduleKeyword = eatToken(65 /* ModuleKeyword */);

                var moduleName = null;
                var stringLiteral = null;

                if (currentToken().kind() === 14 /* StringLiteral */) {
                    stringLiteral = eatToken(14 /* StringLiteral */);
                } else {
                    moduleName = parseName(false);
                }

                var openBraceToken = eatToken(70 /* OpenBraceToken */);

                var moduleElements = TypeScript.Syntax.emptyList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    moduleElements = parseSyntaxList(2 /* ModuleDeclaration_ModuleElements */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }

                return new Parser.syntaxFactory.ModuleDeclarationSyntax(parseNodeData, modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, eatToken(71 /* CloseBraceToken */));
            }

            function parseInterfaceDeclaration() {
                return new Parser.syntaxFactory.InterfaceDeclarationSyntax(parseNodeData, parseModifiers(), eatToken(52 /* InterfaceKeyword */), eatIdentifierToken(), tryParseTypeParameterList(false), parseHeritageClauses(), parseObjectType());
            }

            function parseObjectType() {
                var openBraceToken = eatToken(70 /* OpenBraceToken */);

                var typeMembers = TypeScript.Syntax.emptySeparatedList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    typeMembers = parseSeparatedSyntaxList(9 /* ObjectType_TypeMembers */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }

                return new Parser.syntaxFactory.ObjectTypeSyntax(parseNodeData, openBraceToken, typeMembers, eatToken(71 /* CloseBraceToken */));
            }

            function parseTupleType(currentToken) {
                var openBracket = consumeToken(currentToken);

                var types = TypeScript.Syntax.emptySeparatedList();
                if (openBracket.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    types = parseSeparatedSyntaxList(21 /* TupleType_Types */, skippedTokens);
                    openBracket = addSkippedTokensAfterToken(openBracket, skippedTokens);
                }

                return new Parser.syntaxFactory.TupleTypeSyntax(parseNodeData, openBracket, types, eatToken(75 /* CloseBracketToken */));
            }

            function isTypeMember(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isTypeMember(currentNode())) {
                    return true;
                }

                return isCallSignature(0) || isConstructSignature() || isIndexSignature(0) || isMethodSignature(inErrorRecovery) || isPropertySignature(inErrorRecovery);
            }

            function tryParseTypeMember(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isTypeMember(node)) {
                    consumeNode(node);
                    return node;
                }

                if (isCallSignature(0)) {
                    return parseCallSignature(false);
                } else if (isConstructSignature()) {
                    return parseConstructSignature();
                } else if (isIndexSignature(0)) {
                    return parseIndexSignature();
                } else if (isMethodSignature(inErrorRecovery)) {
                    return parseMethodSignature();
                } else if (isPropertySignature(inErrorRecovery)) {
                    return parsePropertySignature();
                } else {
                    return null;
                }
            }

            function parseConstructSignature() {
                return new Parser.syntaxFactory.ConstructSignatureSyntax(parseNodeData, eatToken(31 /* NewKeyword */), parseCallSignature(false));
            }

            function parseIndexSignature() {
                var openBracketToken = eatToken(74 /* OpenBracketToken */);

                var skippedTokens = getArray();
                var parameters = parseSeparatedSyntaxList(18 /* IndexSignature_Parameters */, skippedTokens);
                openBracketToken = addSkippedTokensAfterToken(openBracketToken, skippedTokens);

                return new Parser.syntaxFactory.IndexSignatureSyntax(parseNodeData, openBracketToken, parameters, eatToken(75 /* CloseBracketToken */), parseOptionalTypeAnnotation(false));
            }

            function parseMethodSignature() {
                return new Parser.syntaxFactory.MethodSignatureSyntax(parseNodeData, eatPropertyName(), tryEatToken(105 /* QuestionToken */), parseCallSignature(false));
            }

            function parsePropertySignature() {
                return new Parser.syntaxFactory.PropertySignatureSyntax(parseNodeData, eatPropertyName(), tryEatToken(105 /* QuestionToken */), parseOptionalTypeAnnotation(false));
            }

            function isCallSignature(peekIndex) {
                var tokenKind = peekToken(peekIndex).kind();
                return tokenKind === 72 /* OpenParenToken */ || tokenKind === 80 /* LessThanToken */;
            }

            function isConstructSignature() {
                if (currentToken().kind() !== 31 /* NewKeyword */) {
                    return false;
                }

                return isCallSignature(1);
            }

            function isIndexSignature(peekIndex) {
                return peekToken(peekIndex).kind() === 74 /* OpenBracketToken */;
            }

            function isMethodSignature(inErrorRecovery) {
                if (isPropertyName(currentToken(), inErrorRecovery)) {
                    if (isCallSignature(1)) {
                        return true;
                    }

                    if (peekToken(1).kind() === 105 /* QuestionToken */ && isCallSignature(2)) {
                        return true;
                    }
                }

                return false;
            }

            function isPropertySignature(inErrorRecovery) {
                var _currentToken = currentToken();

                if (isModifier(_currentToken, 0)) {
                    if (!TypeScript.existsNewLineBetweenTokens(_currentToken, peekToken(1), source.text) && isPropertyName(peekToken(1), inErrorRecovery)) {
                        return false;
                    }
                }

                return isPropertyName(_currentToken, inErrorRecovery);
            }

            function isHeritageClause() {
                var tokenKind = currentToken().kind();
                return tokenKind === 48 /* ExtendsKeyword */ || tokenKind === 51 /* ImplementsKeyword */;
            }

            function isNotHeritageClauseTypeName() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 51 /* ImplementsKeyword */ || tokenKind === 48 /* ExtendsKeyword */) {
                    return isIdentifier(peekToken(1));
                }

                return false;
            }

            function isHeritageClauseTypeName() {
                if (isIdentifier(currentToken())) {
                    return !isNotHeritageClauseTypeName();
                }

                return false;
            }

            function tryParseHeritageClause() {
                var extendsOrImplementsKeyword = currentToken();
                var tokenKind = extendsOrImplementsKeyword.kind();
                if (tokenKind !== 48 /* ExtendsKeyword */ && tokenKind !== 51 /* ImplementsKeyword */) {
                    return null;
                }

                consumeToken(extendsOrImplementsKeyword);

                var skippedTokens = getArray();
                var typeNames = parseSeparatedSyntaxList(11 /* HeritageClause_TypeNameList */, skippedTokens);
                extendsOrImplementsKeyword = addSkippedTokensAfterToken(extendsOrImplementsKeyword, skippedTokens);

                return new Parser.syntaxFactory.HeritageClauseSyntax(parseNodeData, extendsOrImplementsKeyword, typeNames);
            }

            function isInterfaceEnumClassModuleImportOrExport(modifierCount) {
                var _currentToken = currentToken();

                if (modifierCount) {
                    switch (peekToken(modifierCount).kind()) {
                        case 49 /* ImportKeyword */:
                        case 65 /* ModuleKeyword */:
                        case 52 /* InterfaceKeyword */:
                        case 44 /* ClassKeyword */:
                        case 46 /* EnumKeyword */:
                            return true;
                    }
                }

                var nextToken = peekToken(1);

                switch (_currentToken.kind()) {
                    case 65 /* ModuleKeyword */:
                        if (isIdentifier(nextToken) || nextToken.kind() === 14 /* StringLiteral */) {
                            return true;
                        }
                        break;

                    case 49 /* ImportKeyword */:
                    case 44 /* ClassKeyword */:
                    case 46 /* EnumKeyword */:
                    case 52 /* InterfaceKeyword */:
                        if (isIdentifier(nextToken)) {
                            return true;
                        }
                        break;

                    case 47 /* ExportKeyword */:
                        if (nextToken.kind() === 107 /* EqualsToken */) {
                            return true;
                        }
                        break;
                }

                return false;
            }

            function isStatement(modifierCount, inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isStatement(currentNode())) {
                    return true;
                }

                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 56 /* ProtectedKeyword */:
                    case 58 /* StaticKeyword */:
                        var token1 = peekToken(1);
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                            return false;
                        }

                        break;

                    case 28 /* IfKeyword */:
                    case 70 /* OpenBraceToken */:
                    case 33 /* ReturnKeyword */:
                    case 34 /* SwitchKeyword */:
                    case 36 /* ThrowKeyword */:
                    case 15 /* BreakKeyword */:
                    case 18 /* ContinueKeyword */:
                    case 26 /* ForKeyword */:
                    case 42 /* WhileKeyword */:
                    case 43 /* WithKeyword */:
                    case 22 /* DoKeyword */:
                    case 38 /* TryKeyword */:
                    case 19 /* DebuggerKeyword */:
                        return true;
                }

                if (isInterfaceEnumClassModuleImportOrExport(modifierCount)) {
                    return false;
                }

                return isLabeledStatement(_currentToken) || isVariableStatement(modifierCount) || isFunctionDeclaration(modifierCount) || isEmptyStatement(_currentToken, inErrorRecovery) || isExpressionStatement(_currentToken);
            }

            function parseStatement(inErrorRecovery) {
                return tryParseStatement(inErrorRecovery) || parseExpressionStatement();
            }

            function tryParseStatement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isStatement(node)) {
                    consumeNode(node);
                    return node;
                }

                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind();
                return tryParseStatementWorker(_currentToken, currentTokenKind, modifierCount(), inErrorRecovery);
            }

            function tryParseStatementWorker(_currentToken, currentTokenKind, modifierCount, inErrorRecovery) {
                switch (currentTokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 56 /* ProtectedKeyword */:
                    case 58 /* StaticKeyword */:
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(peekToken(1))) {
                            return null;
                        } else {
                            break;
                        }

                    case 28 /* IfKeyword */: return parseIfStatement(_currentToken);
                    case 70 /* OpenBraceToken */: return parseBlock(false, false);
                    case 33 /* ReturnKeyword */: return parseReturnStatement(_currentToken);
                    case 34 /* SwitchKeyword */: return parseSwitchStatement(_currentToken);
                    case 36 /* ThrowKeyword */: return parseThrowStatement(_currentToken);
                    case 15 /* BreakKeyword */: return parseBreakStatement(_currentToken);
                    case 18 /* ContinueKeyword */: return parseContinueStatement(_currentToken);
                    case 26 /* ForKeyword */: return parseForOrForInStatement(_currentToken);
                    case 42 /* WhileKeyword */: return parseWhileStatement(_currentToken);
                    case 43 /* WithKeyword */: return parseWithStatement(_currentToken);
                    case 22 /* DoKeyword */: return parseDoStatement(_currentToken);
                    case 38 /* TryKeyword */: return parseTryStatement(_currentToken);
                    case 19 /* DebuggerKeyword */: return parseDebuggerStatement(_currentToken);
                }

                if (isInterfaceEnumClassModuleImportOrExport(modifierCount)) {
                    return null;
                } else if (isVariableStatement(modifierCount)) {
                    return parseVariableStatement();
                } else if (isLabeledStatement(_currentToken)) {
                    return parseLabeledStatement(_currentToken);
                } else if (isFunctionDeclaration(modifierCount)) {
                    return parseFunctionDeclaration();
                } else if (isEmptyStatement(_currentToken, inErrorRecovery)) {
                    return parseEmptyStatement(_currentToken);
                } else if (isExpressionStatement(_currentToken)) {
                    return parseExpressionStatement();
                } else {
                    return null;
                }
            }

            function parseDebuggerStatement(debuggerKeyword) {
                return new Parser.syntaxFactory.DebuggerStatementSyntax(parseNodeData, consumeToken(debuggerKeyword), eatExplicitOrAutomaticSemicolon(false));
            }

            function parseDoStatement(doKeyword) {
                return new Parser.syntaxFactory.DoStatementSyntax(parseNodeData, consumeToken(doKeyword), parseStatement(false), eatToken(42 /* WhileKeyword */), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), eatExplicitOrAutomaticSemicolon(true));
            }

            function isLabeledStatement(currentToken) {
                return isIdentifier(currentToken) && peekToken(1).kind() === 106 /* ColonToken */;
            }

            function parseLabeledStatement(identifierToken) {
                return new Parser.syntaxFactory.LabeledStatementSyntax(parseNodeData, consumeToken(identifierToken), eatToken(106 /* ColonToken */), parseStatement(false));
            }

            function parseTryStatement(tryKeyword) {
                var tryKeyword = consumeToken(tryKeyword);

                var savedListParsingState = listParsingState;
                listParsingState |= (1 << 6 /* TryBlock_Statements */);
                var block = parseBlock(false, false);
                listParsingState = savedListParsingState;

                var catchClause = null;
                if (currentToken().kind() === 17 /* CatchKeyword */) {
                    catchClause = parseCatchClause();
                }

                var finallyClause = null;
                if (catchClause === null || currentToken().kind() === 25 /* FinallyKeyword */) {
                    finallyClause = parseFinallyClause();
                }

                return new Parser.syntaxFactory.TryStatementSyntax(parseNodeData, tryKeyword, block, catchClause, finallyClause);
            }

            function parseCatchClauseBlock() {
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << 7 /* CatchBlock_Statements */);
                var block = parseBlock(false, false);
                listParsingState = savedListParsingState;

                return block;
            }

            function parseCatchClause() {
                return new Parser.syntaxFactory.CatchClauseSyntax(parseNodeData, eatToken(17 /* CatchKeyword */), eatToken(72 /* OpenParenToken */), eatIdentifierToken(), parseOptionalTypeAnnotation(false), eatToken(73 /* CloseParenToken */), parseCatchClauseBlock());
            }

            function parseFinallyClause() {
                return new Parser.syntaxFactory.FinallyClauseSyntax(parseNodeData, eatToken(25 /* FinallyKeyword */), parseBlock(false, false));
            }

            function parseWithStatement(withKeyword) {
                return new Parser.syntaxFactory.WithStatementSyntax(parseNodeData, consumeToken(withKeyword), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }

            function parseWhileStatement(whileKeyword) {
                return new Parser.syntaxFactory.WhileStatementSyntax(parseNodeData, consumeToken(whileKeyword), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }

            function isEmptyStatement(currentToken, inErrorRecovery) {
                if (inErrorRecovery) {
                    return false;
                }

                return currentToken.kind() === 78 /* SemicolonToken */;
            }

            function parseEmptyStatement(semicolonToken) {
                return new Parser.syntaxFactory.EmptyStatementSyntax(parseNodeData, consumeToken(semicolonToken));
            }

            function parseForOrForInStatement(forKeyword) {
                consumeToken(forKeyword);
                var openParenToken = eatToken(72 /* OpenParenToken */);

                var _currentToken = currentToken();
                var tokenKind = _currentToken.kind();
                if (tokenKind === 40 /* VarKeyword */) {
                    return parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
                } else if (tokenKind === 78 /* SemicolonToken */) {
                    return parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword, openParenToken);
                } else {
                    return parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
                }
            }

            function parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken) {
                var variableDeclaration = parseVariableDeclaration(false);
                return currentToken().kind() === 29 /* InKeyword */ ? parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null) : parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            }

            function parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, initializer) {
                return new Parser.syntaxFactory.ForInStatementSyntax(parseNodeData, forKeyword, openParenToken, variableDeclaration, initializer, eatToken(29 /* InKeyword */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }

            function parseForOrForInStatementWithInitializer(forKeyword, openParenToken) {
                var initializer = parseExpression(false);
                return currentToken().kind() === 29 /* InKeyword */ ? parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer) : parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }

            function parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword, openParenToken) {
                return parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, null);
            }

            function tryParseForStatementCondition() {
                var tokenKind = currentToken().kind();
                if (tokenKind !== 78 /* SemicolonToken */ && tokenKind !== 73 /* CloseParenToken */ && tokenKind !== 10 /* EndOfFileToken */) {
                    return parseExpression(true);
                }

                return null;
            }

            function tryParseForStatementIncrementor() {
                var tokenKind = currentToken().kind();
                if (tokenKind !== 73 /* CloseParenToken */ && tokenKind !== 10 /* EndOfFileToken */) {
                    return parseExpression(true);
                }

                return null;
            }

            function parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, initializer) {
                return new Parser.syntaxFactory.ForStatementSyntax(parseNodeData, forKeyword, openParenToken, variableDeclaration, initializer, eatToken(78 /* SemicolonToken */), tryParseForStatementCondition(), eatToken(78 /* SemicolonToken */), tryParseForStatementIncrementor(), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }

            function tryEatBreakOrContinueLabel() {
                var identifier = null;
                if (!canEatExplicitOrAutomaticSemicolon(false)) {
                    if (isIdentifier(currentToken())) {
                        return eatIdentifierToken();
                    }
                }

                return null;
            }

            function parseBreakStatement(breakKeyword) {
                return new Parser.syntaxFactory.BreakStatementSyntax(parseNodeData, consumeToken(breakKeyword), tryEatBreakOrContinueLabel(), eatExplicitOrAutomaticSemicolon(false));
            }

            function parseContinueStatement(continueKeyword) {
                return new Parser.syntaxFactory.ContinueStatementSyntax(parseNodeData, consumeToken(continueKeyword), tryEatBreakOrContinueLabel(), eatExplicitOrAutomaticSemicolon(false));
            }

            function parseSwitchStatement(switchKeyword) {
                consumeToken(switchKeyword);
                var openParenToken = eatToken(72 /* OpenParenToken */);
                var expression = parseExpression(true);
                var closeParenToken = eatToken(73 /* CloseParenToken */);
                var openBraceToken = eatToken(70 /* OpenBraceToken */);

                var switchClauses = TypeScript.Syntax.emptyList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    switchClauses = parseSyntaxList(3 /* SwitchStatement_SwitchClauses */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }

                return new Parser.syntaxFactory.SwitchStatementSyntax(parseNodeData, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, eatToken(71 /* CloseBraceToken */));
            }

            function isSwitchClause() {
                if (TypeScript.SyntaxUtilities.isSwitchClause(currentNode())) {
                    return true;
                }

                var currentTokenKind = currentToken().kind();
                return currentTokenKind === 16 /* CaseKeyword */ || currentTokenKind === 20 /* DefaultKeyword */;
            }

            function tryParseSwitchClause() {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isSwitchClause(node)) {
                    consumeNode(node);
                    return node;
                }

                var _currentToken = currentToken();
                var kind = _currentToken.kind();
                if (kind === 16 /* CaseKeyword */) {
                    return parseCaseSwitchClause(_currentToken);
                } else if (kind === 20 /* DefaultKeyword */) {
                    return parseDefaultSwitchClause(_currentToken);
                } else {
                    return null;
                }
            }

            function parseCaseSwitchClause(caseKeyword) {
                consumeToken(caseKeyword);
                var expression = parseExpression(true);
                var colonToken = eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList();

                if (colonToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    statements = parseSyntaxList(4 /* SwitchClause_Statements */, skippedTokens);
                    colonToken = addSkippedTokensAfterToken(colonToken, skippedTokens);
                }

                return new Parser.syntaxFactory.CaseSwitchClauseSyntax(parseNodeData, caseKeyword, expression, colonToken, statements);
            }

            function parseDefaultSwitchClause(defaultKeyword) {
                consumeToken(defaultKeyword);
                var colonToken = eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList();

                if (colonToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    statements = parseSyntaxList(4 /* SwitchClause_Statements */, skippedTokens);
                    colonToken = addSkippedTokensAfterToken(colonToken, skippedTokens);
                }

                return new Parser.syntaxFactory.DefaultSwitchClauseSyntax(parseNodeData, defaultKeyword, colonToken, statements);
            }

            function parseThrowStatementExpression() {
                return canEatExplicitOrAutomaticSemicolon(false) ? createMissingToken(11 /* IdentifierName */, null) : parseExpression(true);
            }

            function parseThrowStatement(throwKeyword) {
                return new Parser.syntaxFactory.ThrowStatementSyntax(parseNodeData, consumeToken(throwKeyword), parseThrowStatementExpression(), eatExplicitOrAutomaticSemicolon(false));
            }

            function tryParseReturnStatementExpression() {
                return !canEatExplicitOrAutomaticSemicolon(false) ? parseExpression(true) : null;
            }

            function parseReturnStatement(returnKeyword) {
                return new Parser.syntaxFactory.ReturnStatementSyntax(parseNodeData, consumeToken(returnKeyword), tryParseReturnStatementExpression(), eatExplicitOrAutomaticSemicolon(false));
            }

            function isExpressionStatement(currentToken) {
                var tokenKind = currentToken.kind();
                return tokenKind !== 70 /* OpenBraceToken */ && tokenKind !== 27 /* FunctionKeyword */ && isExpression(currentToken);
            }

            function isAssignmentOrOmittedExpression() {
                var _currentToken = currentToken();
                return _currentToken.kind() === 79 /* CommaToken */ || isExpression(_currentToken);
            }

            function tryParseAssignmentOrOmittedExpression() {
                if (currentToken().kind() === 79 /* CommaToken */) {
                    return new Parser.syntaxFactory.OmittedExpressionSyntax(parseNodeData);
                }

                return tryParseAssignmentExpressionOrHigher(false, true);
            }

            function isExpression(currentToken) {
                switch (currentToken.kind()) {
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 12 /* RegularExpressionLiteral */:

                    case 74 /* OpenBracketToken */:

                    case 72 /* OpenParenToken */:

                    case 80 /* LessThanToken */:

                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                    case 102 /* TildeToken */:
                    case 101 /* ExclamationToken */:

                    case 70 /* OpenBraceToken */:

                    case 85 /* EqualsGreaterThanToken */:

                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:

                    case 50 /* SuperKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:

                    case 31 /* NewKeyword */:

                    case 21 /* DeleteKeyword */:
                    case 41 /* VoidKeyword */:
                    case 39 /* TypeOfKeyword */:

                    case 27 /* FunctionKeyword */:
                        return true;
                }

                return isIdentifier(currentToken);
            }

            function parseExpressionStatement() {
                return new Parser.syntaxFactory.ExpressionStatementSyntax(parseNodeData, parseExpression(true), eatExplicitOrAutomaticSemicolon(false));
            }

            function parseIfStatement(ifKeyword) {
                return new Parser.syntaxFactory.IfStatementSyntax(parseNodeData, consumeToken(ifKeyword), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false), parseOptionalElseClause());
            }

            function parseOptionalElseClause() {
                return currentToken().kind() === 23 /* ElseKeyword */ ? parseElseClause() : null;
            }

            function parseElseClause() {
                return new Parser.syntaxFactory.ElseClauseSyntax(parseNodeData, eatToken(23 /* ElseKeyword */), parseStatement(false));
            }

            function isVariableStatement(modifierCount) {
                return peekToken(modifierCount).kind() === 40 /* VarKeyword */;
            }

            function parseVariableStatement() {
                return new Parser.syntaxFactory.VariableStatementSyntax(parseNodeData, parseModifiers(), parseVariableDeclaration(true), eatExplicitOrAutomaticSemicolon(false));
            }

            function parseVariableDeclaration(allowIn) {
                var varKeyword = eatToken(40 /* VarKeyword */);

                var listParsingState = allowIn ? 12 /* VariableDeclaration_VariableDeclarators_AllowIn */ : 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */;

                var skippedTokens = getArray();
                var variableDeclarators = parseSeparatedSyntaxList(listParsingState, skippedTokens);
                varKeyword = addSkippedTokensAfterToken(varKeyword, skippedTokens);

                return new Parser.syntaxFactory.VariableDeclarationSyntax(parseNodeData, varKeyword, variableDeclarators);
            }

            function isVariableDeclarator() {
                var node = currentNode();
                if (node !== null && node.kind() === 226 /* VariableDeclarator */) {
                    return true;
                }

                return isIdentifier(currentToken());
            }

            function canReuseVariableDeclaratorNode(node) {
                if (node === null || node.kind() !== 226 /* VariableDeclarator */) {
                    return false;
                }

                var variableDeclarator = node;
                return variableDeclarator.equalsValueClause === null;
            }

            function tryParseVariableDeclarator(allowIn, allowPropertyName) {
                var node = currentNode();
                if (canReuseVariableDeclaratorNode(node)) {
                    consumeNode(node);
                    return node;
                }

                if (allowPropertyName) {
                }

                if (!allowPropertyName && !isIdentifier(currentToken())) {
                    return null;
                }

                var propertyName = allowPropertyName ? eatPropertyName() : eatIdentifierToken();
                var equalsValueClause = null;
                var typeAnnotation = null;

                if (propertyName.fullWidth() > 0) {
                    typeAnnotation = parseOptionalTypeAnnotation(false);

                    if (isEqualsValueClause(false)) {
                        equalsValueClause = parseEqualsValueClause(allowIn);
                    }
                }

                return new Parser.syntaxFactory.VariableDeclaratorSyntax(parseNodeData, propertyName, typeAnnotation, equalsValueClause);
            }

            function isEqualsValueClause(inParameter) {
                var token0 = currentToken();
                if (token0.kind() === 107 /* EqualsToken */) {
                    return true;
                }

                if (!previousTokenHasTrailingNewLine(token0)) {
                    var tokenKind = token0.kind();

                    if (tokenKind === 85 /* EqualsGreaterThanToken */) {
                        return false;
                    }

                    if (tokenKind === 70 /* OpenBraceToken */ && inParameter) {
                        return false;
                    }

                    return isExpression(token0);
                }

                return false;
            }

            function parseEqualsValueClause(allowIn) {
                return new Parser.syntaxFactory.EqualsValueClauseSyntax(parseNodeData, eatToken(107 /* EqualsToken */), tryParseAssignmentExpressionOrHigher(true, allowIn));
            }

            function parseExpression(allowIn) {
                var leftOperand = tryParseAssignmentExpressionOrHigher(true, allowIn);
                while (true) {
                    var _currentToken = currentToken();
                    if (_currentToken.kind() !== 79 /* CommaToken */) {
                        break;
                    }

                    leftOperand = new Parser.syntaxFactory.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(_currentToken), tryParseAssignmentExpressionOrHigher(true, allowIn));
                }

                return leftOperand;
            }

            function tryParseAssignmentExpressionOrHigher(force, allowIn) {
                var _currentToken = currentToken();
                var arrowFunction = tryParseAnyArrowFunctionExpression(_currentToken);
                if (arrowFunction !== null) {
                    return arrowFunction;
                }

                var leftOperand = tryParseBinaryExpressionOrHigher(_currentToken, force, 1 /* Lowest */, allowIn);
                if (leftOperand === null) {
                    return null;
                }

                if (TypeScript.SyntaxUtilities.isLeftHandSizeExpression(leftOperand)) {
                    var operatorToken = currentOperatorToken();

                    if (TypeScript.SyntaxFacts.isAssignmentOperatorToken(operatorToken.kind())) {
                        return new Parser.syntaxFactory.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(operatorToken), tryParseAssignmentExpressionOrHigher(true, allowIn));
                    }
                }

                return parseConditionalExpressionRest(allowIn, leftOperand);
            }

            function tryParseAnyArrowFunctionExpression(_currentToken) {
                return isSimpleArrowFunctionExpression(_currentToken) ? parseSimpleArrowFunctionExpression() : tryParseParenthesizedArrowFunctionExpression();
            }

            function tryParseUnaryExpressionOrHigher(_currentToken, force) {
                var currentTokenKind = _currentToken.kind();

                switch (currentTokenKind) {
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                    case 102 /* TildeToken */:
                    case 101 /* ExclamationToken */:
                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                        return new Parser.syntaxFactory.PrefixUnaryExpressionSyntax(parseNodeData, consumeToken(_currentToken), tryParseUnaryExpressionOrHigher(currentToken(), true));
                    case 39 /* TypeOfKeyword */: return parseTypeOfExpression(_currentToken);
                    case 41 /* VoidKeyword */: return parseVoidExpression(_currentToken);
                    case 21 /* DeleteKeyword */: return parseDeleteExpression(_currentToken);
                    case 80 /* LessThanToken */: return parseCastExpression(_currentToken);
                    default:
                        return tryParsePostfixExpressionOrHigher(_currentToken, force);
                }
            }

            function tryParseBinaryExpressionOrHigher(_currentToken, force, precedence, allowIn) {
                var leftOperand = tryParseUnaryExpressionOrHigher(_currentToken, force);
                if (leftOperand === null) {
                    return null;
                }

                return parseBinaryExpressionRest(precedence, allowIn, leftOperand);
            }

            function parseConditionalExpressionRest(allowIn, leftOperand) {
                var _currentToken = currentToken();

                if (_currentToken.kind() !== 105 /* QuestionToken */) {
                    return leftOperand;
                }

                return new Parser.syntaxFactory.ConditionalExpressionSyntax(parseNodeData, leftOperand, consumeToken(_currentToken), tryParseAssignmentExpressionOrHigher(true, true), eatToken(106 /* ColonToken */), tryParseAssignmentExpressionOrHigher(true, allowIn));
            }

            function parseBinaryExpressionRest(precedence, allowIn, leftOperand) {
                while (true) {
                    var operatorToken = currentOperatorToken();
                    var tokenKind = operatorToken.kind();

                    if (!TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(tokenKind) || tokenKind === 79 /* CommaToken */ || TypeScript.SyntaxFacts.isAssignmentOperatorToken(tokenKind)) {
                        break;
                    }

                    if (tokenKind === 29 /* InKeyword */ && !allowIn) {
                        break;
                    }

                    var newPrecedence = getBinaryExpressionPrecedence(tokenKind);

                    if (newPrecedence <= precedence) {
                        break;
                    }

                    leftOperand = new Parser.syntaxFactory.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(operatorToken), tryParseBinaryExpressionOrHigher(currentToken(), true, newPrecedence, allowIn));
                }

                return leftOperand;
            }

            function currentOperatorToken() {
                var token0 = currentToken();

                if (token0.kind() === 81 /* GreaterThanToken */) {
                    return currentContextualToken();
                }

                return token0;
            }

            function tryParseMemberExpressionOrHigher(_currentToken, force, inObjectCreation) {
                var expression = tryParsePrimaryExpression(_currentToken, force);
                if (expression === null) {
                    return null;
                }

                return parseMemberExpressionRest(expression, inObjectCreation);
            }

            function parseCallExpressionRest(expression) {
                while (true) {
                    var _currentToken = currentToken();
                    var currentTokenKind = _currentToken.kind();

                    switch (currentTokenKind) {
                        case 72 /* OpenParenToken */:
                            expression = new Parser.syntaxFactory.InvocationExpressionSyntax(parseNodeData, expression, parseArgumentList(null));
                            continue;

                        case 80 /* LessThanToken */:
                            var argumentList = tryParseArgumentList();
                            if (argumentList === null) {
                                break;
                            }

                            expression = new Parser.syntaxFactory.InvocationExpressionSyntax(parseNodeData, expression, argumentList);
                            continue;

                        case 74 /* OpenBracketToken */:
                            expression = parseElementAccessExpression(expression, _currentToken, false);
                            continue;

                        case 76 /* DotToken */:
                            expression = new Parser.syntaxFactory.MemberAccessExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken), eatIdentifierNameToken());
                            continue;
                    }

                    return expression;
                }
            }

            function parseMemberExpressionRest(expression, inObjectCreation) {
                while (true) {
                    var _currentToken = currentToken();
                    var currentTokenKind = _currentToken.kind();

                    switch (currentTokenKind) {
                        case 74 /* OpenBracketToken */:
                            expression = parseElementAccessExpression(expression, _currentToken, inObjectCreation);
                            continue;

                        case 76 /* DotToken */:
                            expression = new Parser.syntaxFactory.MemberAccessExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken), eatIdentifierNameToken());
                            continue;
                    }

                    return expression;
                }
            }

            function tryParseLeftHandSideExpressionOrHigher(_currentToken, force) {
                var expression = null;
                if (_currentToken.kind() === 50 /* SuperKeyword */) {
                    expression = parseSuperExpression(_currentToken);
                } else {
                    expression = tryParseMemberExpressionOrHigher(_currentToken, force, false);
                    if (expression === null) {
                        return null;
                    }
                }

                return parseCallExpressionRest(expression);
            }

            function parseSuperExpression(superToken) {
                var expression = consumeToken(superToken);

                var currentTokenKind = currentToken().kind();
                return currentTokenKind === 72 /* OpenParenToken */ || currentTokenKind === 76 /* DotToken */ ? expression : new Parser.syntaxFactory.MemberAccessExpressionSyntax(parseNodeData, expression, eatToken(76 /* DotToken */), eatIdentifierNameToken());
            }

            function tryParsePostfixExpressionOrHigher(_currentToken, force) {
                var expression = tryParseLeftHandSideExpressionOrHigher(_currentToken, force);
                if (expression === null) {
                    return null;
                }

                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind();

                switch (currentTokenKind) {
                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                        if (previousTokenHasTrailingNewLine(_currentToken)) {
                            break;
                        }

                        return new Parser.syntaxFactory.PostfixUnaryExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken));
                }

                return expression;
            }

            function tryParseGenericArgumentList() {
                var rewindPoint = getRewindPoint();

                var typeArgumentList = tryParseTypeArgumentList(true);
                var token0 = currentToken();
                var tokenKind = token0.kind();

                var isOpenParen = tokenKind === 72 /* OpenParenToken */;
                var isDot = tokenKind === 76 /* DotToken */;
                var isOpenParenOrDot = isOpenParen || isDot;

                var argumentList = null;
                if (typeArgumentList === null || !isOpenParenOrDot) {
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return null;
                } else {
                    releaseRewindPoint(rewindPoint);

                    if (isDot) {
                        var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token0, source.text), TypeScript.width(token0), TypeScript.DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list_expected, null);
                        addDiagnostic(diagnostic);

                        return new Parser.syntaxFactory.ArgumentListSyntax(parseNodeData, typeArgumentList, TypeScript.Syntax.emptyToken(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList(), TypeScript.Syntax.emptyToken(73 /* CloseParenToken */));
                    } else {
                        return parseArgumentList(typeArgumentList);
                    }
                }
            }

            function tryParseArgumentList() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 80 /* LessThanToken */) {
                    return tryParseGenericArgumentList();
                }

                if (tokenKind === 72 /* OpenParenToken */) {
                    return parseArgumentList(null);
                }

                return null;
            }

            function parseArgumentList(typeArgumentList) {
                var openParenToken = eatToken(72 /* OpenParenToken */);

                var _arguments = TypeScript.Syntax.emptySeparatedList();

                if (openParenToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    _arguments = parseSeparatedSyntaxList(14 /* ArgumentList_AssignmentExpressions */, skippedTokens);
                    openParenToken = addSkippedTokensAfterToken(openParenToken, skippedTokens);
                }

                return new Parser.syntaxFactory.ArgumentListSyntax(parseNodeData, typeArgumentList, openParenToken, _arguments, eatToken(73 /* CloseParenToken */));
            }

            function tryParseArgumentListExpression() {
                var force = currentToken().kind() === 79 /* CommaToken */;
                return tryParseAssignmentExpressionOrHigher(force, true);
            }

            function parseElementAccessArgumentExpression(openBracketToken, inObjectCreation) {
                if (inObjectCreation && currentToken().kind() === 75 /* CloseBracketToken */) {
                    var errorStart = TypeScript.start(openBracketToken, source.text);
                    var errorEnd = TypeScript.end(currentToken(), source.text);
                    var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), errorStart, errorEnd - errorStart, TypeScript.DiagnosticCode.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead, null);
                    addDiagnostic(diagnostic);

                    return TypeScript.Syntax.emptyToken(11 /* IdentifierName */);
                } else {
                    return parseExpression(true);
                }
            }

            function parseElementAccessExpression(expression, openBracketToken, inObjectCreation) {
                return new Parser.syntaxFactory.ElementAccessExpressionSyntax(parseNodeData, expression, consumeToken(openBracketToken), parseElementAccessArgumentExpression(openBracketToken, inObjectCreation), eatToken(75 /* CloseBracketToken */));
            }

            function tryParsePrimaryExpression(_currentToken, force) {
                if (isIdentifier(_currentToken)) {
                    return eatIdentifierToken();
                }

                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                    case 13 /* NumericLiteral */:
                    case 12 /* RegularExpressionLiteral */:
                    case 14 /* StringLiteral */:
                        return consumeToken(_currentToken);

                    case 27 /* FunctionKeyword */: return parseFunctionExpression(_currentToken);
                    case 74 /* OpenBracketToken */: return parseArrayLiteralExpression(_currentToken);
                    case 70 /* OpenBraceToken */: return parseObjectLiteralExpression(_currentToken);
                    case 72 /* OpenParenToken */: return parseParenthesizedExpression(_currentToken);
                    case 31 /* NewKeyword */: return parseObjectCreationExpression(_currentToken);

                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:
                        var result = tryReparseDivideAsRegularExpression();

                        return result || eatIdentifierToken(TypeScript.DiagnosticCode.Expression_expected);
                }

                if (!force) {
                    return null;
                }

                return eatIdentifierToken(TypeScript.DiagnosticCode.Expression_expected);
            }

            function tryReparseDivideAsRegularExpression() {
                var currentToken = currentContextualToken();

                var tokenKind = currentToken.kind();
                if (tokenKind === 118 /* SlashToken */ || tokenKind === 119 /* SlashEqualsToken */) {
                    return null;
                } else if (tokenKind === 12 /* RegularExpressionLiteral */) {
                    return consumeToken(currentToken);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }

            function parseTypeOfExpression(typeOfKeyword) {
                return new Parser.syntaxFactory.TypeOfExpressionSyntax(parseNodeData, consumeToken(typeOfKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }

            function parseDeleteExpression(deleteKeyword) {
                return new Parser.syntaxFactory.DeleteExpressionSyntax(parseNodeData, consumeToken(deleteKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }

            function parseVoidExpression(voidKeyword) {
                return new Parser.syntaxFactory.VoidExpressionSyntax(parseNodeData, consumeToken(voidKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }

            function parseFunctionExpression(functionKeyword) {
                return new Parser.syntaxFactory.FunctionExpressionSyntax(parseNodeData, consumeToken(functionKeyword), eatOptionalIdentifierToken(), parseCallSignature(false), parseBlock(false, true));
            }

            function parseObjectCreationExpression(newKeyword) {
                return new Parser.syntaxFactory.ObjectCreationExpressionSyntax(parseNodeData, consumeToken(newKeyword), tryParseMemberExpressionOrHigher(currentToken(), true, true), tryParseArgumentList());
            }

            function parseCastExpression(lessThanToken) {
                return new Parser.syntaxFactory.CastExpressionSyntax(parseNodeData, consumeToken(lessThanToken), parseType(), eatToken(81 /* GreaterThanToken */), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }

            function parseParenthesizedExpression(openParenToken) {
                return new Parser.syntaxFactory.ParenthesizedExpressionSyntax(parseNodeData, consumeToken(openParenToken), parseExpression(true), eatToken(73 /* CloseParenToken */));
            }

            function tryParseParenthesizedArrowFunctionExpression() {
                var tokenKind = currentToken().kind();
                if (tokenKind !== 72 /* OpenParenToken */ && tokenKind !== 80 /* LessThanToken */) {
                    return null;
                }

                if (isDefinitelyArrowFunctionExpression()) {
                    return tryParseParenthesizedArrowFunctionExpressionWorker(false);
                }

                if (!isPossiblyArrowFunctionExpression()) {
                    return null;
                }

                var rewindPoint = getRewindPoint();

                var arrowFunction = tryParseParenthesizedArrowFunctionExpressionWorker(true);
                if (arrowFunction === null) {
                    rewind(rewindPoint);
                }

                releaseRewindPoint(rewindPoint);
                return arrowFunction;
            }

            function tryParseParenthesizedArrowFunctionExpressionWorker(requireArrow) {
                var _currentToken = currentToken();

                var callSignature = parseCallSignature(true);

                if (requireArrow && currentToken().kind() !== 85 /* EqualsGreaterThanToken */) {
                    return null;
                }

                var equalsGreaterThanToken = eatToken(85 /* EqualsGreaterThanToken */);

                var block = tryParseArrowFunctionBlock();
                var expression = null;
                if (block === null) {
                    expression = tryParseAssignmentExpressionOrHigher(true, true);
                }

                return new Parser.syntaxFactory.ParenthesizedArrowFunctionExpressionSyntax(parseNodeData, callSignature, equalsGreaterThanToken, block, expression);
            }

            function tryParseArrowFunctionBlock() {
                if (isBlock()) {
                    return parseBlock(false, false);
                } else {
                    var _modifierCount = modifierCount();
                    if (isStatement(_modifierCount, false) && !isExpressionStatement(currentToken()) && !isFunctionDeclaration(_modifierCount)) {
                        return parseBlock(true, false);
                    } else {
                        return null;
                    }
                }
            }

            function isSimpleArrowFunctionExpression(_currentToken) {
                if (_currentToken.kind() === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return isIdentifier(_currentToken) && peekToken(1).kind() === 85 /* EqualsGreaterThanToken */;
            }

            function parseSimpleArrowFunctionExpression() {
                var parameter = eatSimpleParameter();
                var equalsGreaterThanToken = eatToken(85 /* EqualsGreaterThanToken */);

                var block = tryParseArrowFunctionBlock();
                var expression = null;
                if (block === null) {
                    expression = tryParseAssignmentExpressionOrHigher(true, true);
                }

                return new Parser.syntaxFactory.SimpleArrowFunctionExpressionSyntax(parseNodeData, parameter, equalsGreaterThanToken, block, expression);
            }

            function isBlock() {
                return currentToken().kind() === 70 /* OpenBraceToken */;
            }

            function isDefinitelyArrowFunctionExpression() {
                var token0 = currentToken();
                if (token0.kind() !== 72 /* OpenParenToken */) {
                    return false;
                }

                var token1 = peekToken(1);
                var token1Kind = token1.kind();

                var token2;

                if (token1Kind === 73 /* CloseParenToken */) {
                    token2 = peekToken(2);
                    var token2Kind = token2.kind();
                    return token2Kind === 106 /* ColonToken */ || token2Kind === 85 /* EqualsGreaterThanToken */ || token2Kind === 70 /* OpenBraceToken */;
                }

                if (token1Kind === 77 /* DotDotDotToken */) {
                    return true;
                }

                token2 = peekToken(2);
                token2Kind = token2.kind();

                if (TypeScript.SyntaxFacts.isAccessibilityModifier(token1Kind)) {
                    if (isIdentifier(token2)) {
                        return true;
                    }
                }

                if (!isIdentifier(token1)) {
                    return false;
                }

                if (token2Kind === 106 /* ColonToken */) {
                    return true;
                }

                var token3 = peekToken(3);
                var token3Kind = token3.kind();
                if (token2Kind === 105 /* QuestionToken */) {
                    if (token3Kind === 106 /* ColonToken */ || token3Kind === 73 /* CloseParenToken */ || token3Kind === 79 /* CommaToken */) {
                        return true;
                    }
                }

                if (token2Kind === 73 /* CloseParenToken */) {
                    if (token3Kind === 85 /* EqualsGreaterThanToken */) {
                        return true;
                    }
                }

                return false;
            }

            function isPossiblyArrowFunctionExpression() {
                var token0 = currentToken();
                if (token0.kind() !== 72 /* OpenParenToken */) {
                    return true;
                }

                var token1 = peekToken(1);

                if (!isIdentifier(token1)) {
                    return false;
                }

                var token2 = peekToken(2);
                var token2Kind = token2.kind();
                if (token2Kind === 107 /* EqualsToken */) {
                    return true;
                }

                if (token2Kind === 79 /* CommaToken */) {
                    return true;
                }

                if (token2Kind === 73 /* CloseParenToken */) {
                    var token3 = peekToken(3);
                    if (token3.kind() === 106 /* ColonToken */) {
                        return true;
                    }
                }

                return false;
            }

            function parseObjectLiteralExpression(openBraceToken) {
                consumeToken(openBraceToken);

                var skippedTokens = getArray();
                var propertyAssignments = parseSeparatedSyntaxList(15 /* ObjectLiteralExpression_PropertyAssignments */, skippedTokens);
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);

                return new Parser.syntaxFactory.ObjectLiteralExpressionSyntax(parseNodeData, openBraceToken, propertyAssignments, eatToken(71 /* CloseBraceToken */));
            }

            function tryParsePropertyAssignment(inErrorRecovery) {
                if (isAccessor(modifierCount(), inErrorRecovery)) {
                    return parseAccessor(true);
                } else if (isFunctionPropertyAssignment(inErrorRecovery)) {
                    return parseFunctionPropertyAssignment();
                } else if (isSimplePropertyAssignment(inErrorRecovery)) {
                    return parseSimplePropertyAssignment();
                } else {
                    return null;
                }
            }

            function isPropertyAssignment(inErrorRecovery) {
                return isAccessor(modifierCount(), inErrorRecovery) || isFunctionPropertyAssignment(inErrorRecovery) || isSimplePropertyAssignment(inErrorRecovery);
            }

            function eatPropertyName() {
                var _currentToken = currentToken();
                return TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(_currentToken) ? eatIdentifierNameToken() : consumeToken(_currentToken);
            }

            function isFunctionPropertyAssignment(inErrorRecovery) {
                return isPropertyName(currentToken(), inErrorRecovery) && isCallSignature(1);
            }

            function parseFunctionPropertyAssignment() {
                return new Parser.syntaxFactory.FunctionPropertyAssignmentSyntax(parseNodeData, eatPropertyName(), parseCallSignature(false), parseBlock(false, true));
            }

            function isSimplePropertyAssignment(inErrorRecovery) {
                return isPropertyName(currentToken(), inErrorRecovery);
            }

            function parseSimplePropertyAssignment() {
                return new Parser.syntaxFactory.SimplePropertyAssignmentSyntax(parseNodeData, eatPropertyName(), eatToken(106 /* ColonToken */), tryParseAssignmentExpressionOrHigher(true, true));
            }

            function isPropertyName(token, inErrorRecovery) {
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    if (inErrorRecovery) {
                        return isIdentifier(token);
                    } else {
                        return true;
                    }
                }

                var kind = token.kind();
                return kind === 14 /* StringLiteral */ || kind === 13 /* NumericLiteral */;
            }

            function parseArrayLiteralExpression(openBracketToken) {
                consumeToken(openBracketToken);

                var skippedTokens = getArray();
                var expressions = parseSeparatedSyntaxList(16 /* ArrayLiteralExpression_AssignmentExpressions */, skippedTokens);
                openBracketToken = addSkippedTokensAfterToken(openBracketToken, skippedTokens);

                return new Parser.syntaxFactory.ArrayLiteralExpressionSyntax(parseNodeData, openBracketToken, expressions, eatToken(75 /* CloseBracketToken */));
            }

            function parseBlock(parseBlockEvenWithNoOpenBrace, checkForStrictMode) {
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var statements = TypeScript.Syntax.emptyList();

                if (parseBlockEvenWithNoOpenBrace || openBraceToken.fullWidth() > 0) {
                    var savedIsInStrictMode = isInStrictMode;

                    var processItems = checkForStrictMode ? updateStrictModeState : null;
                    var skippedTokens = getArray();
                    var statements = parseSyntaxList(5 /* Block_Statements */, skippedTokens, processItems);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);

                    setStrictMode(savedIsInStrictMode);
                }

                return new Parser.syntaxFactory.BlockSyntax(parseNodeData, openBraceToken, statements, eatToken(71 /* CloseBraceToken */));
            }

            function parseCallSignature(requireCompleteTypeParameterList) {
                return new Parser.syntaxFactory.CallSignatureSyntax(parseNodeData, tryParseTypeParameterList(requireCompleteTypeParameterList), parseParameterList(), parseOptionalTypeAnnotation(false));
            }

            function tryParseTypeParameterList(requireCompleteTypeParameterList) {
                var _currentToken = currentToken();
                if (_currentToken.kind() !== 80 /* LessThanToken */) {
                    return null;
                }

                var rewindPoint = getRewindPoint();

                var lessThanToken = consumeToken(_currentToken);

                var skippedTokens = getArray();
                var typeParameters = parseSeparatedSyntaxList(20 /* TypeParameterList_TypeParameters */, skippedTokens);
                lessThanToken = addSkippedTokensAfterToken(lessThanToken, skippedTokens);

                var greaterThanToken = eatToken(81 /* GreaterThanToken */);

                if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return null;
                } else {
                    releaseRewindPoint(rewindPoint);
                    return new Parser.syntaxFactory.TypeParameterListSyntax(parseNodeData, lessThanToken, typeParameters, greaterThanToken);
                }
            }

            function isTypeParameter() {
                return isIdentifier(currentToken());
            }

            function tryParseTypeParameter() {
                if (!isIdentifier(currentToken())) {
                    return null;
                }

                return new Parser.syntaxFactory.TypeParameterSyntax(parseNodeData, eatIdentifierToken(), tryParseConstraint());
            }

            function tryParseConstraint() {
                if (currentToken().kind() !== 48 /* ExtendsKeyword */) {
                    return null;
                }

                return new Parser.syntaxFactory.ConstraintSyntax(parseNodeData, eatToken(48 /* ExtendsKeyword */), parseTypeOrExpression());
            }

            function tryParseParameterList() {
                if (currentToken().kind() === 72 /* OpenParenToken */) {
                    var token1 = peekToken(1);

                    if (token1.kind() === 73 /* CloseParenToken */ || isParameterHelper(token1)) {
                        return parseParameterList();
                    }
                }

                return null;
            }

            function parseParameterList() {
                var openParenToken = eatToken(72 /* OpenParenToken */);
                var parameters = TypeScript.Syntax.emptySeparatedList();

                if (openParenToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    parameters = parseSeparatedSyntaxList(17 /* ParameterList_Parameters */, skippedTokens);
                    openParenToken = addSkippedTokensAfterToken(openParenToken, skippedTokens);
                }

                return new Parser.syntaxFactory.ParameterListSyntax(parseNodeData, openParenToken, parameters, eatToken(73 /* CloseParenToken */));
            }

            function parseOptionalTypeAnnotation(allowStringLiteral) {
                return currentToken().kind() === 106 /* ColonToken */ ? parseTypeAnnotation(allowStringLiteral) : null;
            }

            function parseTypeAnnotationType(allowStringLiteral) {
                if (allowStringLiteral) {
                    var _currentToken = currentToken();
                    if (_currentToken.kind() === 14 /* StringLiteral */) {
                        return consumeToken(_currentToken);
                    }
                }

                return parseType();
            }

            function parseTypeAnnotation(allowStringLiteral) {
                return new Parser.syntaxFactory.TypeAnnotationSyntax(parseNodeData, consumeToken(currentToken()), parseTypeAnnotationType(allowStringLiteral));
            }

            function isType() {
                var _currentToken = currentToken();

                switch (_currentToken.kind()) {
                    case 39 /* TypeOfKeyword */:
                    case 60 /* AnyKeyword */:
                    case 67 /* NumberKeyword */:
                    case 61 /* BooleanKeyword */:
                    case 69 /* StringKeyword */:
                    case 41 /* VoidKeyword */:
                    case 70 /* OpenBraceToken */:
                    case 72 /* OpenParenToken */:
                    case 80 /* LessThanToken */:
                    case 31 /* NewKeyword */:
                        return true;
                    default:
                        return isIdentifier(_currentToken);
                }
            }

            function parseTypeOrExpression() {
                var result = tryParseType();
                if (result) {
                    return result;
                }

                var _currentToken = currentToken();
                if (isExpression(_currentToken)) {
                    return tryParseUnaryExpressionOrHigher(_currentToken, true);
                }

                return eatIdentifierToken(TypeScript.DiagnosticCode.Type_expected);
            }

            function parseType() {
                return tryParseType() || eatIdentifierToken(TypeScript.DiagnosticCode.Type_expected);
            }

            function tryParseType() {
                var type = tryParseNonArrayType();

                while (type) {
                    var _currentToken = currentToken();

                    if (previousTokenHasTrailingNewLine(_currentToken) || _currentToken.kind() !== 74 /* OpenBracketToken */) {
                        break;
                    }

                    type = new Parser.syntaxFactory.ArrayTypeSyntax(parseNodeData, type, consumeToken(_currentToken), eatToken(75 /* CloseBracketToken */));
                }

                return type;
            }

            function parseTypeQuery(typeOfKeyword) {
                return new Parser.syntaxFactory.TypeQuerySyntax(parseNodeData, consumeToken(typeOfKeyword), parseName(true));
            }

            function tryParseNonArrayType() {
                var _currentToken = currentToken();
                switch (_currentToken.kind()) {
                    case 60 /* AnyKeyword */:
                    case 67 /* NumberKeyword */:
                    case 61 /* BooleanKeyword */:
                    case 69 /* StringKeyword */:
                        if (peekToken(1).kind() === 76 /* DotToken */) {
                            break;
                        }

                        return consumeToken(_currentToken);
                    case 72 /* OpenParenToken */:
                    case 80 /* LessThanToken */: return tryParseFunctionType();
                    case 41 /* VoidKeyword */: return consumeToken(_currentToken);
                    case 70 /* OpenBraceToken */: return parseObjectType();
                    case 31 /* NewKeyword */: return parseConstructorType();
                    case 39 /* TypeOfKeyword */: return parseTypeQuery(_currentToken);
                    case 74 /* OpenBracketToken */: return parseTupleType(_currentToken);
                }

                return tryParseNameOrGenericType();
            }

            function tryParseNameOrGenericType() {
                var name = tryParseName(false);
                if (name === null) {
                    return null;
                }

                if (previousTokenHasTrailingNewLine(currentToken())) {
                    return name;
                }

                var typeArgumentList = tryParseTypeArgumentList(false);
                return typeArgumentList === null ? name : new Parser.syntaxFactory.GenericTypeSyntax(parseNodeData, name, typeArgumentList);
            }

            function tryParseFunctionType() {
                var typeParameterList = tryParseTypeParameterList(false);
                var parameterList = null;
                if (typeParameterList === null) {
                    parameterList = tryParseParameterList();
                    if (parameterList === null) {
                        return null;
                    }
                } else {
                    parameterList = parseParameterList();
                }

                return new Parser.syntaxFactory.FunctionTypeSyntax(parseNodeData, typeParameterList, parameterList, eatToken(85 /* EqualsGreaterThanToken */), parseType());
            }

            function parseConstructorType() {
                return new Parser.syntaxFactory.ConstructorTypeSyntax(parseNodeData, eatToken(31 /* NewKeyword */), tryParseTypeParameterList(false), parseParameterList(), eatToken(85 /* EqualsGreaterThanToken */), parseType());
            }

            function isParameter() {
                if (currentNode() !== null && currentNode().kind() === 243 /* Parameter */) {
                    return true;
                }

                return isParameterHelper(currentToken());
            }

            function isParameterHelper(token) {
                var tokenKind = token.kind();
                return tokenKind === 77 /* DotDotDotToken */ || isModifierKind(tokenKind) || isIdentifier(token);
            }

            function eatSimpleParameter() {
                return new Parser.syntaxFactory.ParameterSyntax(parseNodeData, null, TypeScript.Syntax.emptyList(), eatIdentifierToken(), null, null, null);
            }

            function tryParseParameter() {
                var node = currentNode();
                if (node !== null && node.kind() === 243 /* Parameter */) {
                    consumeNode(node);
                    return node;
                }

                var dotDotDotToken = tryEatToken(77 /* DotDotDotToken */);
                var modifiers = parseModifiers();

                var _currentToken = currentToken();
                if (!isIdentifier(_currentToken) && dotDotDotToken === null && modifiers.length === 0) {
                    if (isModifierKind(_currentToken.kind())) {
                        modifiers = TypeScript.Syntax.list([consumeToken(_currentToken)]);
                    } else {
                        return null;
                    }
                }

                var identifier = eatIdentifierToken();
                var questionToken = tryEatToken(105 /* QuestionToken */);
                var typeAnnotation = parseOptionalTypeAnnotation(true);

                var equalsValueClause = null;
                if (isEqualsValueClause(true)) {
                    equalsValueClause = parseEqualsValueClause(true);
                }

                return new Parser.syntaxFactory.ParameterSyntax(parseNodeData, dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause);
            }

            function parseSyntaxList(currentListType, skippedTokens, processItems) {
                if (typeof processItems === "undefined") { processItems = null; }
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << currentListType);

                var result = parseSyntaxListWorker(currentListType, skippedTokens, processItems);

                listParsingState = savedListParsingState;

                return result;
            }

            function parseSeparatedSyntaxList(currentListType, skippedTokens) {
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << currentListType);

                var result = parseSeparatedSyntaxListWorker(currentListType, skippedTokens);

                listParsingState = savedListParsingState;

                return result;
            }

            function abortParsingListOrMoveToNextToken(currentListType, nodes, separators, skippedTokens) {
                reportUnexpectedTokenDiagnostic(currentListType);

                for (var state = 21 /* LastListParsingState */; state >= 0 /* FirstListParsingState */; state--) {
                    if ((listParsingState & (1 << state)) !== 0) {
                        if (isExpectedListTerminator(state) || isExpectedListItem(state, true)) {
                            return true;
                        }
                    }
                }

                addSkippedTokenToList(nodes, separators, skippedTokens, consumeToken(currentToken()));

                return false;
            }

            function addSkippedTokenToList(nodes, separators, skippedTokens, skippedToken) {
                if (Parser.syntaxFactory.isConcrete) {
                    var length = nodes.length + (separators ? separators.length : 0);

                    for (var i = length - 1; i >= 0; i--) {
                        var array = separators && (i % 2 === 1) ? separators : nodes;
                        var arrayIndex = separators ? TypeScript.IntegerUtilities.integerDivide(i, 2) : i;

                        var item = array[arrayIndex];
                        var _lastToken = TypeScript.lastToken(item);
                        if (_lastToken && _lastToken.fullWidth() > 0) {
                            array[arrayIndex] = addSkippedTokenAfterNodeOrToken(item, skippedToken);
                            return;
                        }
                    }

                    skippedTokens.push(skippedToken);
                }
            }

            function tryParseExpectedListItem(currentListType, inErrorRecovery, items, processItems) {
                var item = tryParseExpectedListItemWorker(currentListType, inErrorRecovery);

                if (item === null) {
                    return false;
                }

                items.push(item);

                if (processItems !== null) {
                    processItems(items);
                }

                return true;
            }

            function listIsTerminated(currentListType) {
                return isExpectedListTerminator(currentListType) || currentToken().kind() === 10 /* EndOfFileToken */;
            }

            function parseSyntaxListWorker(currentListType, skippedTokens, processItems) {
                var items = getArray();

                while (true) {
                    var succeeded = tryParseExpectedListItem(currentListType, false, items, processItems);

                    if (!succeeded) {
                        if (listIsTerminated(currentListType)) {
                            break;
                        }

                        var abort = abortParsingListOrMoveToNextToken(currentListType, items, null, skippedTokens);
                        if (abort) {
                            break;
                        }
                    }
                }

                var result = TypeScript.Syntax.list(items);

                returnZeroLengthArray(items);

                return result;
            }

            function parseSeparatedSyntaxListWorker(currentListType, skippedTokens) {
                var nodes = getArray();
                var separators = getArray();

                var _separatorKind = currentListType === 9 /* ObjectType_TypeMembers */ ? 78 /* SemicolonToken */ : 79 /* CommaToken */;
                var allowAutomaticSemicolonInsertion = _separatorKind === 78 /* SemicolonToken */;

                var inErrorRecovery = false;
                while (true) {
                    var succeeded = tryParseExpectedListItem(currentListType, inErrorRecovery, nodes, null);

                    if (!succeeded) {
                        if (listIsTerminated(currentListType)) {
                            break;
                        }

                        var abort = abortParsingListOrMoveToNextToken(currentListType, nodes, separators, skippedTokens);
                        if (abort) {
                            break;
                        } else {
                            inErrorRecovery = true;
                            continue;
                        }
                    }

                    inErrorRecovery = false;

                    var _currentToken = currentToken();
                    var tokenKind = _currentToken.kind();
                    if (tokenKind === _separatorKind || tokenKind === 79 /* CommaToken */) {
                        separators.push(consumeToken(_currentToken));
                        continue;
                    }

                    if (listIsTerminated(currentListType)) {
                        break;
                    }

                    if (allowAutomaticSemicolonInsertion && canEatAutomaticSemicolon(false)) {
                        var semicolonToken = eatExplicitOrAutomaticSemicolon(false) || TypeScript.Syntax.emptyToken(78 /* SemicolonToken */);
                        separators.push(semicolonToken);

                        continue;
                    }

                    separators.push(eatToken(_separatorKind));

                    inErrorRecovery = true;
                }

                var result = TypeScript.Syntax.separatedList(nodes, separators);

                returnZeroLengthArray(nodes);
                returnZeroLengthArray(separators);

                return result;
            }

            function reportUnexpectedTokenDiagnostic(listType) {
                var token = currentToken();

                var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token, source.text), TypeScript.width(token), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [getExpectedListElementType(listType)]);
                addDiagnostic(diagnostic);
            }

            function addDiagnostic(diagnostic) {
                if (diagnostics.length > 0 && diagnostics[diagnostics.length - 1].start() === diagnostic.start()) {
                    return;
                }

                diagnostics.push(diagnostic);
            }

            function isExpectedListTerminator(currentListType) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return isExpectedSourceUnit_ModuleElementsTerminator();
                    case 1 /* ClassDeclaration_ClassElements */: return isExpectedClassDeclaration_ClassElementsTerminator();
                    case 2 /* ModuleDeclaration_ModuleElements */: return isExpectedModuleDeclaration_ModuleElementsTerminator();
                    case 3 /* SwitchStatement_SwitchClauses */: return isExpectedSwitchStatement_SwitchClausesTerminator();
                    case 4 /* SwitchClause_Statements */: return isExpectedSwitchClause_StatementsTerminator();
                    case 5 /* Block_Statements */: return isExpectedBlock_StatementsTerminator();
                    case 6 /* TryBlock_Statements */: return isExpectedTryBlock_StatementsTerminator();
                    case 7 /* CatchBlock_Statements */: return isExpectedCatchBlock_StatementsTerminator();
                    case 8 /* EnumDeclaration_EnumElements */: return isExpectedEnumDeclaration_EnumElementsTerminator();
                    case 9 /* ObjectType_TypeMembers */: return isExpectedObjectType_TypeMembersTerminator();
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();
                    case 11 /* HeritageClause_TypeNameList */: return isExpectedHeritageClause_TypeNameListTerminator();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();
                    case 14 /* ArgumentList_AssignmentExpressions */: return isExpectedArgumentList_AssignmentExpressionsTerminator();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return isExpectedLiteralExpression_AssignmentExpressionsTerminator();
                    case 17 /* ParameterList_Parameters */: return isExpectedParameterList_ParametersTerminator();
                    case 18 /* IndexSignature_Parameters */: return isExpectedIndexSignature_ParametersTerminator();
                    case 19 /* TypeArgumentList_Types */: return isExpectedTypeArgumentList_TypesTerminator();
                    case 20 /* TypeParameterList_TypeParameters */: return isExpectedTypeParameterList_TypeParametersTerminator();
                    case 21 /* TupleType_Types */: return isExpectedTupleType_TypesTerminator();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }

            function isExpectedSourceUnit_ModuleElementsTerminator() {
                return currentToken().kind() === 10 /* EndOfFileToken */;
            }

            function isExpectedEnumDeclaration_EnumElementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }

            function isExpectedModuleDeclaration_ModuleElementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }

            function isExpectedObjectType_TypeMembersTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }

            function isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }

            function isExpectedLiteralExpression_AssignmentExpressionsTerminator() {
                return currentToken().kind() === 75 /* CloseBracketToken */;
            }

            function isExpectedTypeArgumentList_TypesTerminator() {
                var token = currentToken();
                var tokenKind = token.kind();
                if (tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }

                if (canFollowTypeArgumentListInExpression(tokenKind)) {
                    return true;
                }

                return false;
            }

            function isExpectedTupleType_TypesTerminator() {
                var token = currentToken();
                var tokenKind = token.kind();
                if (tokenKind === 75 /* CloseBracketToken */) {
                    return true;
                }

                return false;
            }

            function isExpectedTypeParameterList_TypeParametersTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }

                if (tokenKind === 72 /* OpenParenToken */ || tokenKind === 70 /* OpenBraceToken */ || tokenKind === 48 /* ExtendsKeyword */ || tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                return false;
            }

            function isExpectedParameterList_ParametersTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }

                if (tokenKind === 70 /* OpenBraceToken */) {
                    return true;
                }

                if (tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return false;
            }

            function isExpectedIndexSignature_ParametersTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 75 /* CloseBracketToken */) {
                    return true;
                }

                if (tokenKind === 70 /* OpenBraceToken */) {
                    return true;
                }

                return false;
            }

            function isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator() {
                var tokenKind = currentToken().kind();

                if (tokenKind === 78 /* SemicolonToken */ || tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }

                if (tokenKind === 29 /* InKeyword */) {
                    return true;
                }

                return false;
            }

            function isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator() {
                if (currentToken().kind() === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return canEatExplicitOrAutomaticSemicolon(false);
            }

            function isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 70 /* OpenBraceToken */ || tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }

                return false;
            }

            function isExpectedHeritageClause_TypeNameListTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 48 /* ExtendsKeyword */ || tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                if (isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                    return true;
                }

                return false;
            }

            function isExpectedArgumentList_AssignmentExpressionsTerminator() {
                var token0 = currentToken();
                var tokenKind = token0.kind();
                return tokenKind === 73 /* CloseParenToken */ || tokenKind === 78 /* SemicolonToken */;
            }

            function isExpectedClassDeclaration_ClassElementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }

            function isExpectedSwitchStatement_SwitchClausesTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }

            function isExpectedSwitchClause_StatementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */ || isSwitchClause();
            }

            function isExpectedBlock_StatementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }

            function isExpectedTryBlock_StatementsTerminator() {
                var tokenKind = currentToken().kind();
                return tokenKind === 17 /* CatchKeyword */ || tokenKind === 25 /* FinallyKeyword */;
            }

            function isExpectedCatchBlock_StatementsTerminator() {
                return currentToken().kind() === 25 /* FinallyKeyword */;
            }

            function isExpectedListItem(currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return isModuleElement(inErrorRecovery);
                    case 1 /* ClassDeclaration_ClassElements */: return isClassElement(inErrorRecovery);
                    case 2 /* ModuleDeclaration_ModuleElements */: return isModuleElement(inErrorRecovery);
                    case 3 /* SwitchStatement_SwitchClauses */: return isSwitchClause();
                    case 4 /* SwitchClause_Statements */: return isStatement(modifierCount(), inErrorRecovery);
                    case 5 /* Block_Statements */: return isStatement(modifierCount(), inErrorRecovery);

                    case 6 /* TryBlock_Statements */: return false;
                    case 7 /* CatchBlock_Statements */: return false;
                    case 8 /* EnumDeclaration_EnumElements */: return isEnumElement(inErrorRecovery);
                    case 9 /* ObjectType_TypeMembers */: return isTypeMember(inErrorRecovery);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return isHeritageClause();
                    case 11 /* HeritageClause_TypeNameList */: return isHeritageClauseTypeName();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return isVariableDeclarator();
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return isVariableDeclarator();
                    case 14 /* ArgumentList_AssignmentExpressions */: return isExpectedArgumentList_AssignmentExpression();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return isPropertyAssignment(inErrorRecovery);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return isAssignmentOrOmittedExpression();
                    case 17 /* ParameterList_Parameters */: return isParameter();
                    case 18 /* IndexSignature_Parameters */: return isParameter();
                    case 19 /* TypeArgumentList_Types */: return isType();
                    case 20 /* TypeParameterList_TypeParameters */: return isTypeParameter();
                    case 21 /* TupleType_Types */: return isType();
                    default: throw TypeScript.Errors.invalidOperation();
                }
            }

            function isExpectedArgumentList_AssignmentExpression() {
                var _currentToken = currentToken();
                if (isExpression(_currentToken)) {
                    return true;
                }

                if (_currentToken.kind() === 79 /* CommaToken */) {
                    return true;
                }

                return false;
            }

            function tryParseExpectedListItemWorker(currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return tryParseModuleElement(inErrorRecovery);
                    case 1 /* ClassDeclaration_ClassElements */: return tryParseClassElement(inErrorRecovery);
                    case 2 /* ModuleDeclaration_ModuleElements */: return tryParseModuleElement(inErrorRecovery);
                    case 3 /* SwitchStatement_SwitchClauses */: return tryParseSwitchClause();
                    case 4 /* SwitchClause_Statements */: return tryParseStatement(inErrorRecovery);
                    case 5 /* Block_Statements */: return tryParseStatement(inErrorRecovery);
                    case 6 /* TryBlock_Statements */: return tryParseStatement(inErrorRecovery);
                    case 7 /* CatchBlock_Statements */: return tryParseStatement(inErrorRecovery);
                    case 8 /* EnumDeclaration_EnumElements */: return tryParseEnumElement(inErrorRecovery);
                    case 9 /* ObjectType_TypeMembers */: return tryParseTypeMember(inErrorRecovery);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return tryParseHeritageClause();
                    case 11 /* HeritageClause_TypeNameList */: return tryParseHeritageClauseTypeName();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return tryParseVariableDeclarator(true, false);
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return tryParseVariableDeclarator(false, false);
                    case 14 /* ArgumentList_AssignmentExpressions */: return tryParseArgumentListExpression();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return tryParsePropertyAssignment(inErrorRecovery);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return tryParseAssignmentOrOmittedExpression();
                    case 17 /* ParameterList_Parameters */: return tryParseParameter();
                    case 18 /* IndexSignature_Parameters */: return tryParseParameter();
                    case 19 /* TypeArgumentList_Types */: return tryParseType();
                    case 20 /* TypeParameterList_TypeParameters */: return tryParseTypeParameter();
                    case 21 /* TupleType_Types */: return tryParseType();
                    default: throw TypeScript.Errors.invalidOperation();
                }
            }

            function getExpectedListElementType(currentListType) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return '{';
                    case 1 /* ClassDeclaration_ClassElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.constructor_function_accessor_or_variable, null);
                    case 2 /* ModuleDeclaration_ModuleElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);
                    case 3 /* SwitchStatement_SwitchClauses */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.case_or_default_clause, null);
                    case 4 /* SwitchClause_Statements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);
                    case 5 /* Block_Statements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);
                    case 8 /* EnumDeclaration_EnumElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);
                    case 9 /* ObjectType_TypeMembers */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.call_construct_index_property_or_function_signature, null);
                    case 14 /* ArgumentList_AssignmentExpressions */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);
                    case 11 /* HeritageClause_TypeNameList */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, null);
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.property_or_accessor, null);
                    case 17 /* ParameterList_Parameters */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, null);
                    case 18 /* IndexSignature_Parameters */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, null);
                    case 19 /* TypeArgumentList_Types */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null);
                    case 20 /* TypeParameterList_TypeParameters */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, null);
                    case 21 /* TupleType_Types */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);
                    default: throw TypeScript.Errors.invalidOperation();
                }
            }

            return parseSyntaxTree;
        }

        var BinaryExpressionPrecedence;
        (function (BinaryExpressionPrecedence) {
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["Lowest"] = 1] = "Lowest";

            BinaryExpressionPrecedence[BinaryExpressionPrecedence["LogicalOrExpressionPrecedence"] = 2] = "LogicalOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["LogicalAndExpressionPrecedence"] = 3] = "LogicalAndExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseOrExpressionPrecedence"] = 4] = "BitwiseOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseExclusiveOrExpressionPrecedence"] = 5] = "BitwiseExclusiveOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseAndExpressionPrecedence"] = 6] = "BitwiseAndExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["EqualityExpressionPrecedence"] = 7] = "EqualityExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["RelationalExpressionPrecedence"] = 8] = "RelationalExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["ShiftExpressionPrecdence"] = 9] = "ShiftExpressionPrecdence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["AdditiveExpressionPrecedence"] = 10] = "AdditiveExpressionPrecedence";

            BinaryExpressionPrecedence[BinaryExpressionPrecedence["MultiplicativeExpressionPrecedence"] = 11] = "MultiplicativeExpressionPrecedence";
        })(BinaryExpressionPrecedence || (BinaryExpressionPrecedence = {}));

        var ListParsingState;
        (function (ListParsingState) {
            ListParsingState[ListParsingState["SourceUnit_ModuleElements"] = 0] = "SourceUnit_ModuleElements";
            ListParsingState[ListParsingState["ClassDeclaration_ClassElements"] = 1] = "ClassDeclaration_ClassElements";
            ListParsingState[ListParsingState["ModuleDeclaration_ModuleElements"] = 2] = "ModuleDeclaration_ModuleElements";
            ListParsingState[ListParsingState["SwitchStatement_SwitchClauses"] = 3] = "SwitchStatement_SwitchClauses";
            ListParsingState[ListParsingState["SwitchClause_Statements"] = 4] = "SwitchClause_Statements";
            ListParsingState[ListParsingState["Block_Statements"] = 5] = "Block_Statements";
            ListParsingState[ListParsingState["TryBlock_Statements"] = 6] = "TryBlock_Statements";
            ListParsingState[ListParsingState["CatchBlock_Statements"] = 7] = "CatchBlock_Statements";
            ListParsingState[ListParsingState["EnumDeclaration_EnumElements"] = 8] = "EnumDeclaration_EnumElements";
            ListParsingState[ListParsingState["ObjectType_TypeMembers"] = 9] = "ObjectType_TypeMembers";
            ListParsingState[ListParsingState["ClassOrInterfaceDeclaration_HeritageClauses"] = 10] = "ClassOrInterfaceDeclaration_HeritageClauses";
            ListParsingState[ListParsingState["HeritageClause_TypeNameList"] = 11] = "HeritageClause_TypeNameList";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_AllowIn"] = 12] = "VariableDeclaration_VariableDeclarators_AllowIn";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_DisallowIn"] = 13] = "VariableDeclaration_VariableDeclarators_DisallowIn";
            ListParsingState[ListParsingState["ArgumentList_AssignmentExpressions"] = 14] = "ArgumentList_AssignmentExpressions";
            ListParsingState[ListParsingState["ObjectLiteralExpression_PropertyAssignments"] = 15] = "ObjectLiteralExpression_PropertyAssignments";
            ListParsingState[ListParsingState["ArrayLiteralExpression_AssignmentExpressions"] = 16] = "ArrayLiteralExpression_AssignmentExpressions";
            ListParsingState[ListParsingState["ParameterList_Parameters"] = 17] = "ParameterList_Parameters";
            ListParsingState[ListParsingState["IndexSignature_Parameters"] = 18] = "IndexSignature_Parameters";
            ListParsingState[ListParsingState["TypeArgumentList_Types"] = 19] = "TypeArgumentList_Types";
            ListParsingState[ListParsingState["TypeParameterList_TypeParameters"] = 20] = "TypeParameterList_TypeParameters";
            ListParsingState[ListParsingState["TupleType_Types"] = 21] = "TupleType_Types";

            ListParsingState[ListParsingState["FirstListParsingState"] = ListParsingState.SourceUnit_ModuleElements] = "FirstListParsingState";
            ListParsingState[ListParsingState["LastListParsingState"] = ListParsingState.TupleType_Types] = "LastListParsingState";
        })(ListParsingState || (ListParsingState = {}));

        var parseSyntaxTree = createParseSyntaxTree();

        function parse(fileName, text, languageVersion, isDeclaration) {
            return parseSource(TypeScript.Scanner.createParserSource(fileName, text, languageVersion), isDeclaration);
        }
        Parser.parse = parse;

        function parseSource(source, isDeclaration) {
            return parseSyntaxTree(source, isDeclaration);
        }
        Parser.parseSource = parseSource;
    })(TypeScript.Parser || (TypeScript.Parser = {}));
    var Parser = TypeScript.Parser;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        (function (Concrete) {
            TypeScript.Parser.syntaxFactory = Concrete;
            Concrete.isConcrete = true;

            var SourceUnitSyntax = (function (_super) {
                __extends(SourceUnitSyntax, _super);
                function SourceUnitSyntax(data, moduleElements, endOfFileToken) {
                    _super.call(this, data);
                    this.syntaxTree = null;
                    this.parent = null, this.moduleElements = moduleElements, this.endOfFileToken = endOfFileToken, !TypeScript.isShared(moduleElements) && (moduleElements.parent = this), endOfFileToken.parent = this;
                }
                return SourceUnitSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SourceUnitSyntax = SourceUnitSyntax;
            var QualifiedNameSyntax = (function (_super) {
                __extends(QualifiedNameSyntax, _super);
                function QualifiedNameSyntax(data, left, dotToken, right) {
                    _super.call(this, data);
                    this.left = left, this.dotToken = dotToken, this.right = right, left.parent = this, dotToken.parent = this, right.parent = this;
                }
                return QualifiedNameSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.QualifiedNameSyntax = QualifiedNameSyntax;
            var ObjectTypeSyntax = (function (_super) {
                __extends(ObjectTypeSyntax, _super);
                function ObjectTypeSyntax(data, openBraceToken, typeMembers, closeBraceToken) {
                    _super.call(this, data);
                    this.openBraceToken = openBraceToken, this.typeMembers = typeMembers, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, !TypeScript.isShared(typeMembers) && (typeMembers.parent = this), closeBraceToken.parent = this;
                }
                return ObjectTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ObjectTypeSyntax = ObjectTypeSyntax;
            var FunctionTypeSyntax = (function (_super) {
                __extends(FunctionTypeSyntax, _super);
                function FunctionTypeSyntax(data, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                    _super.call(this, data);
                    this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.equalsGreaterThanToken = equalsGreaterThanToken, this.type = type, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, equalsGreaterThanToken.parent = this, type.parent = this;
                }
                return FunctionTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionTypeSyntax = FunctionTypeSyntax;
            var ArrayTypeSyntax = (function (_super) {
                __extends(ArrayTypeSyntax, _super);
                function ArrayTypeSyntax(data, type, openBracketToken, closeBracketToken) {
                    _super.call(this, data);
                    this.type = type, this.openBracketToken = openBracketToken, this.closeBracketToken = closeBracketToken, type.parent = this, openBracketToken.parent = this, closeBracketToken.parent = this;
                }
                return ArrayTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ArrayTypeSyntax = ArrayTypeSyntax;
            var ConstructorTypeSyntax = (function (_super) {
                __extends(ConstructorTypeSyntax, _super);
                function ConstructorTypeSyntax(data, newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                    _super.call(this, data);
                    this.newKeyword = newKeyword, this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.equalsGreaterThanToken = equalsGreaterThanToken, this.type = type, newKeyword.parent = this, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, equalsGreaterThanToken.parent = this, type.parent = this;
                }
                return ConstructorTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstructorTypeSyntax = ConstructorTypeSyntax;
            var GenericTypeSyntax = (function (_super) {
                __extends(GenericTypeSyntax, _super);
                function GenericTypeSyntax(data, name, typeArgumentList) {
                    _super.call(this, data);
                    this.name = name, this.typeArgumentList = typeArgumentList, name.parent = this, typeArgumentList.parent = this;
                }
                return GenericTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.GenericTypeSyntax = GenericTypeSyntax;
            var TypeQuerySyntax = (function (_super) {
                __extends(TypeQuerySyntax, _super);
                function TypeQuerySyntax(data, typeOfKeyword, name) {
                    _super.call(this, data);
                    this.typeOfKeyword = typeOfKeyword, this.name = name, typeOfKeyword.parent = this, name.parent = this;
                }
                return TypeQuerySyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeQuerySyntax = TypeQuerySyntax;
            var TupleTypeSyntax = (function (_super) {
                __extends(TupleTypeSyntax, _super);
                function TupleTypeSyntax(data, openBracketToken, types, closeBracketToken) {
                    _super.call(this, data);
                    this.openBracketToken = openBracketToken, this.types = types, this.closeBracketToken = closeBracketToken, openBracketToken.parent = this, !TypeScript.isShared(types) && (types.parent = this), closeBracketToken.parent = this;
                }
                return TupleTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TupleTypeSyntax = TupleTypeSyntax;
            var InterfaceDeclarationSyntax = (function (_super) {
                __extends(InterfaceDeclarationSyntax, _super);
                function InterfaceDeclarationSyntax(data, modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.interfaceKeyword = interfaceKeyword, this.identifier = identifier, this.typeParameterList = typeParameterList, this.heritageClauses = heritageClauses, this.body = body, !TypeScript.isShared(modifiers) && (modifiers.parent = this), interfaceKeyword.parent = this, identifier.parent = this, typeParameterList && (typeParameterList.parent = this), !TypeScript.isShared(heritageClauses) && (heritageClauses.parent = this), body.parent = this;
                }
                return InterfaceDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.InterfaceDeclarationSyntax = InterfaceDeclarationSyntax;
            var FunctionDeclarationSyntax = (function (_super) {
                __extends(FunctionDeclarationSyntax, _super);
                function FunctionDeclarationSyntax(data, modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.functionKeyword = functionKeyword, this.identifier = identifier, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), functionKeyword.parent = this, identifier.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return FunctionDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionDeclarationSyntax = FunctionDeclarationSyntax;
            var ModuleDeclarationSyntax = (function (_super) {
                __extends(ModuleDeclarationSyntax, _super);
                function ModuleDeclarationSyntax(data, modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.moduleKeyword = moduleKeyword, this.name = name, this.stringLiteral = stringLiteral, this.openBraceToken = openBraceToken, this.moduleElements = moduleElements, this.closeBraceToken = closeBraceToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), moduleKeyword.parent = this, name && (name.parent = this), stringLiteral && (stringLiteral.parent = this), openBraceToken.parent = this, !TypeScript.isShared(moduleElements) && (moduleElements.parent = this), closeBraceToken.parent = this;
                }
                return ModuleDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ModuleDeclarationSyntax = ModuleDeclarationSyntax;
            var ClassDeclarationSyntax = (function (_super) {
                __extends(ClassDeclarationSyntax, _super);
                function ClassDeclarationSyntax(data, modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.classKeyword = classKeyword, this.identifier = identifier, this.typeParameterList = typeParameterList, this.heritageClauses = heritageClauses, this.openBraceToken = openBraceToken, this.classElements = classElements, this.closeBraceToken = closeBraceToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), classKeyword.parent = this, identifier.parent = this, typeParameterList && (typeParameterList.parent = this), !TypeScript.isShared(heritageClauses) && (heritageClauses.parent = this), openBraceToken.parent = this, !TypeScript.isShared(classElements) && (classElements.parent = this), closeBraceToken.parent = this;
                }
                return ClassDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ClassDeclarationSyntax = ClassDeclarationSyntax;
            var EnumDeclarationSyntax = (function (_super) {
                __extends(EnumDeclarationSyntax, _super);
                function EnumDeclarationSyntax(data, modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.enumKeyword = enumKeyword, this.identifier = identifier, this.openBraceToken = openBraceToken, this.enumElements = enumElements, this.closeBraceToken = closeBraceToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), enumKeyword.parent = this, identifier.parent = this, openBraceToken.parent = this, !TypeScript.isShared(enumElements) && (enumElements.parent = this), closeBraceToken.parent = this;
                }
                return EnumDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EnumDeclarationSyntax = EnumDeclarationSyntax;
            var ImportDeclarationSyntax = (function (_super) {
                __extends(ImportDeclarationSyntax, _super);
                function ImportDeclarationSyntax(data, modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.importKeyword = importKeyword, this.identifier = identifier, this.equalsToken = equalsToken, this.moduleReference = moduleReference, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), importKeyword.parent = this, identifier.parent = this, equalsToken.parent = this, moduleReference.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ImportDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ImportDeclarationSyntax = ImportDeclarationSyntax;
            var ExportAssignmentSyntax = (function (_super) {
                __extends(ExportAssignmentSyntax, _super);
                function ExportAssignmentSyntax(data, exportKeyword, equalsToken, identifier, semicolonToken) {
                    _super.call(this, data);
                    this.exportKeyword = exportKeyword, this.equalsToken = equalsToken, this.identifier = identifier, this.semicolonToken = semicolonToken, exportKeyword.parent = this, equalsToken.parent = this, identifier.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ExportAssignmentSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ExportAssignmentSyntax = ExportAssignmentSyntax;
            var MemberFunctionDeclarationSyntax = (function (_super) {
                __extends(MemberFunctionDeclarationSyntax, _super);
                function MemberFunctionDeclarationSyntax(data, modifiers, propertyName, callSignature, block, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), propertyName.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return MemberFunctionDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MemberFunctionDeclarationSyntax = MemberFunctionDeclarationSyntax;
            var MemberVariableDeclarationSyntax = (function (_super) {
                __extends(MemberVariableDeclarationSyntax, _super);
                function MemberVariableDeclarationSyntax(data, modifiers, variableDeclarator, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.variableDeclarator = variableDeclarator, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), variableDeclarator.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return MemberVariableDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MemberVariableDeclarationSyntax = MemberVariableDeclarationSyntax;
            var ConstructorDeclarationSyntax = (function (_super) {
                __extends(ConstructorDeclarationSyntax, _super);
                function ConstructorDeclarationSyntax(data, modifiers, constructorKeyword, callSignature, block, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.constructorKeyword = constructorKeyword, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), constructorKeyword.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return ConstructorDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstructorDeclarationSyntax = ConstructorDeclarationSyntax;
            var IndexMemberDeclarationSyntax = (function (_super) {
                __extends(IndexMemberDeclarationSyntax, _super);
                function IndexMemberDeclarationSyntax(data, modifiers, indexSignature, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.indexSignature = indexSignature, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), indexSignature.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return IndexMemberDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.IndexMemberDeclarationSyntax = IndexMemberDeclarationSyntax;
            var GetAccessorSyntax = (function (_super) {
                __extends(GetAccessorSyntax, _super);
                function GetAccessorSyntax(data, modifiers, getKeyword, propertyName, callSignature, block) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.getKeyword = getKeyword, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, !TypeScript.isShared(modifiers) && (modifiers.parent = this), getKeyword.parent = this, propertyName.parent = this, callSignature.parent = this, block.parent = this;
                }
                return GetAccessorSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.GetAccessorSyntax = GetAccessorSyntax;
            var SetAccessorSyntax = (function (_super) {
                __extends(SetAccessorSyntax, _super);
                function SetAccessorSyntax(data, modifiers, setKeyword, propertyName, callSignature, block) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.setKeyword = setKeyword, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, !TypeScript.isShared(modifiers) && (modifiers.parent = this), setKeyword.parent = this, propertyName.parent = this, callSignature.parent = this, block.parent = this;
                }
                return SetAccessorSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SetAccessorSyntax = SetAccessorSyntax;
            var PropertySignatureSyntax = (function (_super) {
                __extends(PropertySignatureSyntax, _super);
                function PropertySignatureSyntax(data, propertyName, questionToken, typeAnnotation) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.questionToken = questionToken, this.typeAnnotation = typeAnnotation, propertyName.parent = this, questionToken && (questionToken.parent = this), typeAnnotation && (typeAnnotation.parent = this);
                }
                return PropertySignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.PropertySignatureSyntax = PropertySignatureSyntax;
            var CallSignatureSyntax = (function (_super) {
                __extends(CallSignatureSyntax, _super);
                function CallSignatureSyntax(data, typeParameterList, parameterList, typeAnnotation) {
                    _super.call(this, data);
                    this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.typeAnnotation = typeAnnotation, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, typeAnnotation && (typeAnnotation.parent = this);
                }
                return CallSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CallSignatureSyntax = CallSignatureSyntax;
            var ConstructSignatureSyntax = (function (_super) {
                __extends(ConstructSignatureSyntax, _super);
                function ConstructSignatureSyntax(data, newKeyword, callSignature) {
                    _super.call(this, data);
                    this.newKeyword = newKeyword, this.callSignature = callSignature, newKeyword.parent = this, callSignature.parent = this;
                }
                return ConstructSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstructSignatureSyntax = ConstructSignatureSyntax;
            var IndexSignatureSyntax = (function (_super) {
                __extends(IndexSignatureSyntax, _super);
                function IndexSignatureSyntax(data, openBracketToken, parameters, closeBracketToken, typeAnnotation) {
                    _super.call(this, data);
                    this.openBracketToken = openBracketToken, this.parameters = parameters, this.closeBracketToken = closeBracketToken, this.typeAnnotation = typeAnnotation, openBracketToken.parent = this, !TypeScript.isShared(parameters) && (parameters.parent = this), closeBracketToken.parent = this, typeAnnotation && (typeAnnotation.parent = this);
                }
                return IndexSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.IndexSignatureSyntax = IndexSignatureSyntax;
            var MethodSignatureSyntax = (function (_super) {
                __extends(MethodSignatureSyntax, _super);
                function MethodSignatureSyntax(data, propertyName, questionToken, callSignature) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.questionToken = questionToken, this.callSignature = callSignature, propertyName.parent = this, questionToken && (questionToken.parent = this), callSignature.parent = this;
                }
                return MethodSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MethodSignatureSyntax = MethodSignatureSyntax;
            var BlockSyntax = (function (_super) {
                __extends(BlockSyntax, _super);
                function BlockSyntax(data, openBraceToken, statements, closeBraceToken) {
                    _super.call(this, data);
                    this.openBraceToken = openBraceToken, this.statements = statements, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, !TypeScript.isShared(statements) && (statements.parent = this), closeBraceToken.parent = this;
                }
                return BlockSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.BlockSyntax = BlockSyntax;
            var IfStatementSyntax = (function (_super) {
                __extends(IfStatementSyntax, _super);
                function IfStatementSyntax(data, ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                    _super.call(this, data);
                    this.ifKeyword = ifKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, this.elseClause = elseClause, ifKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this, elseClause && (elseClause.parent = this);
                }
                return IfStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.IfStatementSyntax = IfStatementSyntax;
            var VariableStatementSyntax = (function (_super) {
                __extends(VariableStatementSyntax, _super);
                function VariableStatementSyntax(data, modifiers, variableDeclaration, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.variableDeclaration = variableDeclaration, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), variableDeclaration.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return VariableStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VariableStatementSyntax = VariableStatementSyntax;
            var ExpressionStatementSyntax = (function (_super) {
                __extends(ExpressionStatementSyntax, _super);
                function ExpressionStatementSyntax(data, expression, semicolonToken) {
                    _super.call(this, data);
                    this.expression = expression, this.semicolonToken = semicolonToken, expression.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ExpressionStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ExpressionStatementSyntax = ExpressionStatementSyntax;
            var ReturnStatementSyntax = (function (_super) {
                __extends(ReturnStatementSyntax, _super);
                function ReturnStatementSyntax(data, returnKeyword, expression, semicolonToken) {
                    _super.call(this, data);
                    this.returnKeyword = returnKeyword, this.expression = expression, this.semicolonToken = semicolonToken, returnKeyword.parent = this, expression && (expression.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return ReturnStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ReturnStatementSyntax = ReturnStatementSyntax;
            var SwitchStatementSyntax = (function (_super) {
                __extends(SwitchStatementSyntax, _super);
                function SwitchStatementSyntax(data, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                    _super.call(this, data);
                    this.switchKeyword = switchKeyword, this.openParenToken = openParenToken, this.expression = expression, this.closeParenToken = closeParenToken, this.openBraceToken = openBraceToken, this.switchClauses = switchClauses, this.closeBraceToken = closeBraceToken, switchKeyword.parent = this, openParenToken.parent = this, expression.parent = this, closeParenToken.parent = this, openBraceToken.parent = this, !TypeScript.isShared(switchClauses) && (switchClauses.parent = this), closeBraceToken.parent = this;
                }
                return SwitchStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SwitchStatementSyntax = SwitchStatementSyntax;
            var BreakStatementSyntax = (function (_super) {
                __extends(BreakStatementSyntax, _super);
                function BreakStatementSyntax(data, breakKeyword, identifier, semicolonToken) {
                    _super.call(this, data);
                    this.breakKeyword = breakKeyword, this.identifier = identifier, this.semicolonToken = semicolonToken, breakKeyword.parent = this, identifier && (identifier.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return BreakStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.BreakStatementSyntax = BreakStatementSyntax;
            var ContinueStatementSyntax = (function (_super) {
                __extends(ContinueStatementSyntax, _super);
                function ContinueStatementSyntax(data, continueKeyword, identifier, semicolonToken) {
                    _super.call(this, data);
                    this.continueKeyword = continueKeyword, this.identifier = identifier, this.semicolonToken = semicolonToken, continueKeyword.parent = this, identifier && (identifier.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return ContinueStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ContinueStatementSyntax = ContinueStatementSyntax;
            var ForStatementSyntax = (function (_super) {
                __extends(ForStatementSyntax, _super);
                function ForStatementSyntax(data, forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                    _super.call(this, data);
                    this.forKeyword = forKeyword, this.openParenToken = openParenToken, this.variableDeclaration = variableDeclaration, this.initializer = initializer, this.firstSemicolonToken = firstSemicolonToken, this.condition = condition, this.secondSemicolonToken = secondSemicolonToken, this.incrementor = incrementor, this.closeParenToken = closeParenToken, this.statement = statement, forKeyword.parent = this, openParenToken.parent = this, variableDeclaration && (variableDeclaration.parent = this), initializer && (initializer.parent = this), firstSemicolonToken.parent = this, condition && (condition.parent = this), secondSemicolonToken.parent = this, incrementor && (incrementor.parent = this), closeParenToken.parent = this, statement.parent = this;
                }
                return ForStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ForStatementSyntax = ForStatementSyntax;
            var ForInStatementSyntax = (function (_super) {
                __extends(ForInStatementSyntax, _super);
                function ForInStatementSyntax(data, forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                    _super.call(this, data);
                    this.forKeyword = forKeyword, this.openParenToken = openParenToken, this.variableDeclaration = variableDeclaration, this.left = left, this.inKeyword = inKeyword, this.expression = expression, this.closeParenToken = closeParenToken, this.statement = statement, forKeyword.parent = this, openParenToken.parent = this, variableDeclaration && (variableDeclaration.parent = this), left && (left.parent = this), inKeyword.parent = this, expression.parent = this, closeParenToken.parent = this, statement.parent = this;
                }
                return ForInStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ForInStatementSyntax = ForInStatementSyntax;
            var EmptyStatementSyntax = (function (_super) {
                __extends(EmptyStatementSyntax, _super);
                function EmptyStatementSyntax(data, semicolonToken) {
                    _super.call(this, data);
                    this.semicolonToken = semicolonToken, semicolonToken.parent = this;
                }
                return EmptyStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EmptyStatementSyntax = EmptyStatementSyntax;
            var ThrowStatementSyntax = (function (_super) {
                __extends(ThrowStatementSyntax, _super);
                function ThrowStatementSyntax(data, throwKeyword, expression, semicolonToken) {
                    _super.call(this, data);
                    this.throwKeyword = throwKeyword, this.expression = expression, this.semicolonToken = semicolonToken, throwKeyword.parent = this, expression.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ThrowStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ThrowStatementSyntax = ThrowStatementSyntax;
            var WhileStatementSyntax = (function (_super) {
                __extends(WhileStatementSyntax, _super);
                function WhileStatementSyntax(data, whileKeyword, openParenToken, condition, closeParenToken, statement) {
                    _super.call(this, data);
                    this.whileKeyword = whileKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, whileKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this;
                }
                return WhileStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.WhileStatementSyntax = WhileStatementSyntax;
            var TryStatementSyntax = (function (_super) {
                __extends(TryStatementSyntax, _super);
                function TryStatementSyntax(data, tryKeyword, block, catchClause, finallyClause) {
                    _super.call(this, data);
                    this.tryKeyword = tryKeyword, this.block = block, this.catchClause = catchClause, this.finallyClause = finallyClause, tryKeyword.parent = this, block.parent = this, catchClause && (catchClause.parent = this), finallyClause && (finallyClause.parent = this);
                }
                return TryStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TryStatementSyntax = TryStatementSyntax;
            var LabeledStatementSyntax = (function (_super) {
                __extends(LabeledStatementSyntax, _super);
                function LabeledStatementSyntax(data, identifier, colonToken, statement) {
                    _super.call(this, data);
                    this.identifier = identifier, this.colonToken = colonToken, this.statement = statement, identifier.parent = this, colonToken.parent = this, statement.parent = this;
                }
                return LabeledStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.LabeledStatementSyntax = LabeledStatementSyntax;
            var DoStatementSyntax = (function (_super) {
                __extends(DoStatementSyntax, _super);
                function DoStatementSyntax(data, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                    _super.call(this, data);
                    this.doKeyword = doKeyword, this.statement = statement, this.whileKeyword = whileKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.semicolonToken = semicolonToken, doKeyword.parent = this, statement.parent = this, whileKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return DoStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DoStatementSyntax = DoStatementSyntax;
            var DebuggerStatementSyntax = (function (_super) {
                __extends(DebuggerStatementSyntax, _super);
                function DebuggerStatementSyntax(data, debuggerKeyword, semicolonToken) {
                    _super.call(this, data);
                    this.debuggerKeyword = debuggerKeyword, this.semicolonToken = semicolonToken, debuggerKeyword.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return DebuggerStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DebuggerStatementSyntax = DebuggerStatementSyntax;
            var WithStatementSyntax = (function (_super) {
                __extends(WithStatementSyntax, _super);
                function WithStatementSyntax(data, withKeyword, openParenToken, condition, closeParenToken, statement) {
                    _super.call(this, data);
                    this.withKeyword = withKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, withKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this;
                }
                return WithStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.WithStatementSyntax = WithStatementSyntax;
            var PrefixUnaryExpressionSyntax = (function (_super) {
                __extends(PrefixUnaryExpressionSyntax, _super);
                function PrefixUnaryExpressionSyntax(data, operatorToken, operand) {
                    _super.call(this, data);
                    this.operatorToken = operatorToken, this.operand = operand, operatorToken.parent = this, operand.parent = this;
                }
                PrefixUnaryExpressionSyntax.prototype.kind = function () {
                    return TypeScript.SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(this.operatorToken.kind());
                };
                return PrefixUnaryExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.PrefixUnaryExpressionSyntax = PrefixUnaryExpressionSyntax;
            var DeleteExpressionSyntax = (function (_super) {
                __extends(DeleteExpressionSyntax, _super);
                function DeleteExpressionSyntax(data, deleteKeyword, expression) {
                    _super.call(this, data);
                    this.deleteKeyword = deleteKeyword, this.expression = expression, deleteKeyword.parent = this, expression.parent = this;
                }
                return DeleteExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DeleteExpressionSyntax = DeleteExpressionSyntax;
            var TypeOfExpressionSyntax = (function (_super) {
                __extends(TypeOfExpressionSyntax, _super);
                function TypeOfExpressionSyntax(data, typeOfKeyword, expression) {
                    _super.call(this, data);
                    this.typeOfKeyword = typeOfKeyword, this.expression = expression, typeOfKeyword.parent = this, expression.parent = this;
                }
                return TypeOfExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeOfExpressionSyntax = TypeOfExpressionSyntax;
            var VoidExpressionSyntax = (function (_super) {
                __extends(VoidExpressionSyntax, _super);
                function VoidExpressionSyntax(data, voidKeyword, expression) {
                    _super.call(this, data);
                    this.voidKeyword = voidKeyword, this.expression = expression, voidKeyword.parent = this, expression.parent = this;
                }
                return VoidExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VoidExpressionSyntax = VoidExpressionSyntax;
            var ConditionalExpressionSyntax = (function (_super) {
                __extends(ConditionalExpressionSyntax, _super);
                function ConditionalExpressionSyntax(data, condition, questionToken, whenTrue, colonToken, whenFalse) {
                    _super.call(this, data);
                    this.condition = condition, this.questionToken = questionToken, this.whenTrue = whenTrue, this.colonToken = colonToken, this.whenFalse = whenFalse, condition.parent = this, questionToken.parent = this, whenTrue.parent = this, colonToken.parent = this, whenFalse.parent = this;
                }
                return ConditionalExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConditionalExpressionSyntax = ConditionalExpressionSyntax;
            var BinaryExpressionSyntax = (function (_super) {
                __extends(BinaryExpressionSyntax, _super);
                function BinaryExpressionSyntax(data, left, operatorToken, right) {
                    _super.call(this, data);
                    this.left = left, this.operatorToken = operatorToken, this.right = right, left.parent = this, operatorToken.parent = this, right.parent = this;
                }
                BinaryExpressionSyntax.prototype.kind = function () {
                    return TypeScript.SyntaxFacts.getBinaryExpressionFromOperatorToken(this.operatorToken.kind());
                };
                return BinaryExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.BinaryExpressionSyntax = BinaryExpressionSyntax;
            var PostfixUnaryExpressionSyntax = (function (_super) {
                __extends(PostfixUnaryExpressionSyntax, _super);
                function PostfixUnaryExpressionSyntax(data, operand, operatorToken) {
                    _super.call(this, data);
                    this.operand = operand, this.operatorToken = operatorToken, operand.parent = this, operatorToken.parent = this;
                }
                PostfixUnaryExpressionSyntax.prototype.kind = function () {
                    return TypeScript.SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(this.operatorToken.kind());
                };
                return PostfixUnaryExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.PostfixUnaryExpressionSyntax = PostfixUnaryExpressionSyntax;
            var MemberAccessExpressionSyntax = (function (_super) {
                __extends(MemberAccessExpressionSyntax, _super);
                function MemberAccessExpressionSyntax(data, expression, dotToken, name) {
                    _super.call(this, data);
                    this.expression = expression, this.dotToken = dotToken, this.name = name, expression.parent = this, dotToken.parent = this, name.parent = this;
                }
                return MemberAccessExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MemberAccessExpressionSyntax = MemberAccessExpressionSyntax;
            var InvocationExpressionSyntax = (function (_super) {
                __extends(InvocationExpressionSyntax, _super);
                function InvocationExpressionSyntax(data, expression, argumentList) {
                    _super.call(this, data);
                    this.expression = expression, this.argumentList = argumentList, expression.parent = this, argumentList.parent = this;
                }
                return InvocationExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.InvocationExpressionSyntax = InvocationExpressionSyntax;
            var ArrayLiteralExpressionSyntax = (function (_super) {
                __extends(ArrayLiteralExpressionSyntax, _super);
                function ArrayLiteralExpressionSyntax(data, openBracketToken, expressions, closeBracketToken) {
                    _super.call(this, data);
                    this.openBracketToken = openBracketToken, this.expressions = expressions, this.closeBracketToken = closeBracketToken, openBracketToken.parent = this, !TypeScript.isShared(expressions) && (expressions.parent = this), closeBracketToken.parent = this;
                }
                return ArrayLiteralExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ArrayLiteralExpressionSyntax = ArrayLiteralExpressionSyntax;
            var ObjectLiteralExpressionSyntax = (function (_super) {
                __extends(ObjectLiteralExpressionSyntax, _super);
                function ObjectLiteralExpressionSyntax(data, openBraceToken, propertyAssignments, closeBraceToken) {
                    _super.call(this, data);
                    this.openBraceToken = openBraceToken, this.propertyAssignments = propertyAssignments, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, !TypeScript.isShared(propertyAssignments) && (propertyAssignments.parent = this), closeBraceToken.parent = this;
                }
                return ObjectLiteralExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ObjectLiteralExpressionSyntax = ObjectLiteralExpressionSyntax;
            var ObjectCreationExpressionSyntax = (function (_super) {
                __extends(ObjectCreationExpressionSyntax, _super);
                function ObjectCreationExpressionSyntax(data, newKeyword, expression, argumentList) {
                    _super.call(this, data);
                    this.newKeyword = newKeyword, this.expression = expression, this.argumentList = argumentList, newKeyword.parent = this, expression.parent = this, argumentList && (argumentList.parent = this);
                }
                return ObjectCreationExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ObjectCreationExpressionSyntax = ObjectCreationExpressionSyntax;
            var ParenthesizedExpressionSyntax = (function (_super) {
                __extends(ParenthesizedExpressionSyntax, _super);
                function ParenthesizedExpressionSyntax(data, openParenToken, expression, closeParenToken) {
                    _super.call(this, data);
                    this.openParenToken = openParenToken, this.expression = expression, this.closeParenToken = closeParenToken, openParenToken.parent = this, expression.parent = this, closeParenToken.parent = this;
                }
                return ParenthesizedExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParenthesizedExpressionSyntax = ParenthesizedExpressionSyntax;
            var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
                __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
                function ParenthesizedArrowFunctionExpressionSyntax(data, callSignature, equalsGreaterThanToken, block, expression) {
                    _super.call(this, data);
                    this.callSignature = callSignature, this.equalsGreaterThanToken = equalsGreaterThanToken, this.block = block, this.expression = expression, callSignature.parent = this, equalsGreaterThanToken.parent = this, block && (block.parent = this), expression && (expression.parent = this);
                }
                return ParenthesizedArrowFunctionExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParenthesizedArrowFunctionExpressionSyntax = ParenthesizedArrowFunctionExpressionSyntax;
            var SimpleArrowFunctionExpressionSyntax = (function (_super) {
                __extends(SimpleArrowFunctionExpressionSyntax, _super);
                function SimpleArrowFunctionExpressionSyntax(data, parameter, equalsGreaterThanToken, block, expression) {
                    _super.call(this, data);
                    this.parameter = parameter, this.equalsGreaterThanToken = equalsGreaterThanToken, this.block = block, this.expression = expression, parameter.parent = this, equalsGreaterThanToken.parent = this, block && (block.parent = this), expression && (expression.parent = this);
                }
                return SimpleArrowFunctionExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SimpleArrowFunctionExpressionSyntax = SimpleArrowFunctionExpressionSyntax;
            var CastExpressionSyntax = (function (_super) {
                __extends(CastExpressionSyntax, _super);
                function CastExpressionSyntax(data, lessThanToken, type, greaterThanToken, expression) {
                    _super.call(this, data);
                    this.lessThanToken = lessThanToken, this.type = type, this.greaterThanToken = greaterThanToken, this.expression = expression, lessThanToken.parent = this, type.parent = this, greaterThanToken.parent = this, expression.parent = this;
                }
                return CastExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CastExpressionSyntax = CastExpressionSyntax;
            var ElementAccessExpressionSyntax = (function (_super) {
                __extends(ElementAccessExpressionSyntax, _super);
                function ElementAccessExpressionSyntax(data, expression, openBracketToken, argumentExpression, closeBracketToken) {
                    _super.call(this, data);
                    this.expression = expression, this.openBracketToken = openBracketToken, this.argumentExpression = argumentExpression, this.closeBracketToken = closeBracketToken, expression.parent = this, openBracketToken.parent = this, argumentExpression.parent = this, closeBracketToken.parent = this;
                }
                return ElementAccessExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ElementAccessExpressionSyntax = ElementAccessExpressionSyntax;
            var FunctionExpressionSyntax = (function (_super) {
                __extends(FunctionExpressionSyntax, _super);
                function FunctionExpressionSyntax(data, functionKeyword, identifier, callSignature, block) {
                    _super.call(this, data);
                    this.functionKeyword = functionKeyword, this.identifier = identifier, this.callSignature = callSignature, this.block = block, functionKeyword.parent = this, identifier && (identifier.parent = this), callSignature.parent = this, block.parent = this;
                }
                return FunctionExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionExpressionSyntax = FunctionExpressionSyntax;
            var OmittedExpressionSyntax = (function (_super) {
                __extends(OmittedExpressionSyntax, _super);
                function OmittedExpressionSyntax(data) {
                    _super.call(this, data);
                }
                return OmittedExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.OmittedExpressionSyntax = OmittedExpressionSyntax;
            var VariableDeclarationSyntax = (function (_super) {
                __extends(VariableDeclarationSyntax, _super);
                function VariableDeclarationSyntax(data, varKeyword, variableDeclarators) {
                    _super.call(this, data);
                    this.varKeyword = varKeyword, this.variableDeclarators = variableDeclarators, varKeyword.parent = this, !TypeScript.isShared(variableDeclarators) && (variableDeclarators.parent = this);
                }
                return VariableDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VariableDeclarationSyntax = VariableDeclarationSyntax;
            var VariableDeclaratorSyntax = (function (_super) {
                __extends(VariableDeclaratorSyntax, _super);
                function VariableDeclaratorSyntax(data, propertyName, typeAnnotation, equalsValueClause) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.typeAnnotation = typeAnnotation, this.equalsValueClause = equalsValueClause, propertyName.parent = this, typeAnnotation && (typeAnnotation.parent = this), equalsValueClause && (equalsValueClause.parent = this);
                }
                return VariableDeclaratorSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VariableDeclaratorSyntax = VariableDeclaratorSyntax;
            var ArgumentListSyntax = (function (_super) {
                __extends(ArgumentListSyntax, _super);
                function ArgumentListSyntax(data, typeArgumentList, openParenToken, _arguments, closeParenToken) {
                    _super.call(this, data);
                    this.typeArgumentList = typeArgumentList, this.openParenToken = openParenToken, this.arguments = _arguments, this.closeParenToken = closeParenToken, typeArgumentList && (typeArgumentList.parent = this), openParenToken.parent = this, !TypeScript.isShared(_arguments) && (_arguments.parent = this), closeParenToken.parent = this;
                }
                return ArgumentListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ArgumentListSyntax = ArgumentListSyntax;
            var ParameterListSyntax = (function (_super) {
                __extends(ParameterListSyntax, _super);
                function ParameterListSyntax(data, openParenToken, parameters, closeParenToken) {
                    _super.call(this, data);
                    this.openParenToken = openParenToken, this.parameters = parameters, this.closeParenToken = closeParenToken, openParenToken.parent = this, !TypeScript.isShared(parameters) && (parameters.parent = this), closeParenToken.parent = this;
                }
                return ParameterListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParameterListSyntax = ParameterListSyntax;
            var TypeArgumentListSyntax = (function (_super) {
                __extends(TypeArgumentListSyntax, _super);
                function TypeArgumentListSyntax(data, lessThanToken, typeArguments, greaterThanToken) {
                    _super.call(this, data);
                    this.lessThanToken = lessThanToken, this.typeArguments = typeArguments, this.greaterThanToken = greaterThanToken, lessThanToken.parent = this, !TypeScript.isShared(typeArguments) && (typeArguments.parent = this), greaterThanToken.parent = this;
                }
                return TypeArgumentListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeArgumentListSyntax = TypeArgumentListSyntax;
            var TypeParameterListSyntax = (function (_super) {
                __extends(TypeParameterListSyntax, _super);
                function TypeParameterListSyntax(data, lessThanToken, typeParameters, greaterThanToken) {
                    _super.call(this, data);
                    this.lessThanToken = lessThanToken, this.typeParameters = typeParameters, this.greaterThanToken = greaterThanToken, lessThanToken.parent = this, !TypeScript.isShared(typeParameters) && (typeParameters.parent = this), greaterThanToken.parent = this;
                }
                return TypeParameterListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeParameterListSyntax = TypeParameterListSyntax;
            var HeritageClauseSyntax = (function (_super) {
                __extends(HeritageClauseSyntax, _super);
                function HeritageClauseSyntax(data, extendsOrImplementsKeyword, typeNames) {
                    _super.call(this, data);
                    this.extendsOrImplementsKeyword = extendsOrImplementsKeyword, this.typeNames = typeNames, extendsOrImplementsKeyword.parent = this, !TypeScript.isShared(typeNames) && (typeNames.parent = this);
                }
                HeritageClauseSyntax.prototype.kind = function () {
                    return this.extendsOrImplementsKeyword.kind() === 48 /* ExtendsKeyword */ ? 231 /* ExtendsHeritageClause */ : 232 /* ImplementsHeritageClause */;
                };
                return HeritageClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.HeritageClauseSyntax = HeritageClauseSyntax;
            var EqualsValueClauseSyntax = (function (_super) {
                __extends(EqualsValueClauseSyntax, _super);
                function EqualsValueClauseSyntax(data, equalsToken, value) {
                    _super.call(this, data);
                    this.equalsToken = equalsToken, this.value = value, equalsToken.parent = this, value.parent = this;
                }
                return EqualsValueClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EqualsValueClauseSyntax = EqualsValueClauseSyntax;
            var CaseSwitchClauseSyntax = (function (_super) {
                __extends(CaseSwitchClauseSyntax, _super);
                function CaseSwitchClauseSyntax(data, caseKeyword, expression, colonToken, statements) {
                    _super.call(this, data);
                    this.caseKeyword = caseKeyword, this.expression = expression, this.colonToken = colonToken, this.statements = statements, caseKeyword.parent = this, expression.parent = this, colonToken.parent = this, !TypeScript.isShared(statements) && (statements.parent = this);
                }
                return CaseSwitchClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CaseSwitchClauseSyntax = CaseSwitchClauseSyntax;
            var DefaultSwitchClauseSyntax = (function (_super) {
                __extends(DefaultSwitchClauseSyntax, _super);
                function DefaultSwitchClauseSyntax(data, defaultKeyword, colonToken, statements) {
                    _super.call(this, data);
                    this.defaultKeyword = defaultKeyword, this.colonToken = colonToken, this.statements = statements, defaultKeyword.parent = this, colonToken.parent = this, !TypeScript.isShared(statements) && (statements.parent = this);
                }
                return DefaultSwitchClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DefaultSwitchClauseSyntax = DefaultSwitchClauseSyntax;
            var ElseClauseSyntax = (function (_super) {
                __extends(ElseClauseSyntax, _super);
                function ElseClauseSyntax(data, elseKeyword, statement) {
                    _super.call(this, data);
                    this.elseKeyword = elseKeyword, this.statement = statement, elseKeyword.parent = this, statement.parent = this;
                }
                return ElseClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ElseClauseSyntax = ElseClauseSyntax;
            var CatchClauseSyntax = (function (_super) {
                __extends(CatchClauseSyntax, _super);
                function CatchClauseSyntax(data, catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                    _super.call(this, data);
                    this.catchKeyword = catchKeyword, this.openParenToken = openParenToken, this.identifier = identifier, this.typeAnnotation = typeAnnotation, this.closeParenToken = closeParenToken, this.block = block, catchKeyword.parent = this, openParenToken.parent = this, identifier.parent = this, typeAnnotation && (typeAnnotation.parent = this), closeParenToken.parent = this, block.parent = this;
                }
                return CatchClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CatchClauseSyntax = CatchClauseSyntax;
            var FinallyClauseSyntax = (function (_super) {
                __extends(FinallyClauseSyntax, _super);
                function FinallyClauseSyntax(data, finallyKeyword, block) {
                    _super.call(this, data);
                    this.finallyKeyword = finallyKeyword, this.block = block, finallyKeyword.parent = this, block.parent = this;
                }
                return FinallyClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FinallyClauseSyntax = FinallyClauseSyntax;
            var TypeParameterSyntax = (function (_super) {
                __extends(TypeParameterSyntax, _super);
                function TypeParameterSyntax(data, identifier, constraint) {
                    _super.call(this, data);
                    this.identifier = identifier, this.constraint = constraint, identifier.parent = this, constraint && (constraint.parent = this);
                }
                return TypeParameterSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeParameterSyntax = TypeParameterSyntax;
            var ConstraintSyntax = (function (_super) {
                __extends(ConstraintSyntax, _super);
                function ConstraintSyntax(data, extendsKeyword, typeOrExpression) {
                    _super.call(this, data);
                    this.extendsKeyword = extendsKeyword, this.typeOrExpression = typeOrExpression, extendsKeyword.parent = this, typeOrExpression.parent = this;
                }
                return ConstraintSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstraintSyntax = ConstraintSyntax;
            var SimplePropertyAssignmentSyntax = (function (_super) {
                __extends(SimplePropertyAssignmentSyntax, _super);
                function SimplePropertyAssignmentSyntax(data, propertyName, colonToken, expression) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.colonToken = colonToken, this.expression = expression, propertyName.parent = this, colonToken.parent = this, expression.parent = this;
                }
                return SimplePropertyAssignmentSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SimplePropertyAssignmentSyntax = SimplePropertyAssignmentSyntax;
            var FunctionPropertyAssignmentSyntax = (function (_super) {
                __extends(FunctionPropertyAssignmentSyntax, _super);
                function FunctionPropertyAssignmentSyntax(data, propertyName, callSignature, block) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, propertyName.parent = this, callSignature.parent = this, block.parent = this;
                }
                return FunctionPropertyAssignmentSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionPropertyAssignmentSyntax = FunctionPropertyAssignmentSyntax;
            var ParameterSyntax = (function (_super) {
                __extends(ParameterSyntax, _super);
                function ParameterSyntax(data, dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause) {
                    _super.call(this, data);
                    this.dotDotDotToken = dotDotDotToken, this.modifiers = modifiers, this.identifier = identifier, this.questionToken = questionToken, this.typeAnnotation = typeAnnotation, this.equalsValueClause = equalsValueClause, dotDotDotToken && (dotDotDotToken.parent = this), !TypeScript.isShared(modifiers) && (modifiers.parent = this), identifier.parent = this, questionToken && (questionToken.parent = this), typeAnnotation && (typeAnnotation.parent = this), equalsValueClause && (equalsValueClause.parent = this);
                }
                return ParameterSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParameterSyntax = ParameterSyntax;
            var EnumElementSyntax = (function (_super) {
                __extends(EnumElementSyntax, _super);
                function EnumElementSyntax(data, propertyName, equalsValueClause) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.equalsValueClause = equalsValueClause, propertyName.parent = this, equalsValueClause && (equalsValueClause.parent = this);
                }
                return EnumElementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EnumElementSyntax = EnumElementSyntax;
            var TypeAnnotationSyntax = (function (_super) {
                __extends(TypeAnnotationSyntax, _super);
                function TypeAnnotationSyntax(data, colonToken, type) {
                    _super.call(this, data);
                    this.colonToken = colonToken, this.type = type, colonToken.parent = this, type.parent = this;
                }
                return TypeAnnotationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeAnnotationSyntax = TypeAnnotationSyntax;
            var ExternalModuleReferenceSyntax = (function (_super) {
                __extends(ExternalModuleReferenceSyntax, _super);
                function ExternalModuleReferenceSyntax(data, requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                    _super.call(this, data);
                    this.requireKeyword = requireKeyword, this.openParenToken = openParenToken, this.stringLiteral = stringLiteral, this.closeParenToken = closeParenToken, requireKeyword.parent = this, openParenToken.parent = this, stringLiteral.parent = this, closeParenToken.parent = this;
                }
                return ExternalModuleReferenceSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ExternalModuleReferenceSyntax = ExternalModuleReferenceSyntax;
            var ModuleNameModuleReferenceSyntax = (function (_super) {
                __extends(ModuleNameModuleReferenceSyntax, _super);
                function ModuleNameModuleReferenceSyntax(data, moduleName) {
                    _super.call(this, data);
                    this.moduleName = moduleName, moduleName.parent = this;
                }
                return ModuleNameModuleReferenceSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ModuleNameModuleReferenceSyntax = ModuleNameModuleReferenceSyntax;

            SourceUnitSyntax.prototype.__kind = 120 /* SourceUnit */, QualifiedNameSyntax.prototype.__kind = 121 /* QualifiedName */, ObjectTypeSyntax.prototype.__kind = 122 /* ObjectType */, FunctionTypeSyntax.prototype.__kind = 123 /* FunctionType */, ArrayTypeSyntax.prototype.__kind = 124 /* ArrayType */, ConstructorTypeSyntax.prototype.__kind = 125 /* ConstructorType */, GenericTypeSyntax.prototype.__kind = 126 /* GenericType */, TypeQuerySyntax.prototype.__kind = 127 /* TypeQuery */, TupleTypeSyntax.prototype.__kind = 128 /* TupleType */, InterfaceDeclarationSyntax.prototype.__kind = 129 /* InterfaceDeclaration */, FunctionDeclarationSyntax.prototype.__kind = 130 /* FunctionDeclaration */, ModuleDeclarationSyntax.prototype.__kind = 131 /* ModuleDeclaration */, ClassDeclarationSyntax.prototype.__kind = 132 /* ClassDeclaration */, EnumDeclarationSyntax.prototype.__kind = 133 /* EnumDeclaration */, ImportDeclarationSyntax.prototype.__kind = 134 /* ImportDeclaration */, ExportAssignmentSyntax.prototype.__kind = 135 /* ExportAssignment */, MemberFunctionDeclarationSyntax.prototype.__kind = 136 /* MemberFunctionDeclaration */, MemberVariableDeclarationSyntax.prototype.__kind = 137 /* MemberVariableDeclaration */, ConstructorDeclarationSyntax.prototype.__kind = 138 /* ConstructorDeclaration */, IndexMemberDeclarationSyntax.prototype.__kind = 139 /* IndexMemberDeclaration */, GetAccessorSyntax.prototype.__kind = 140 /* GetAccessor */, SetAccessorSyntax.prototype.__kind = 141 /* SetAccessor */, PropertySignatureSyntax.prototype.__kind = 142 /* PropertySignature */, CallSignatureSyntax.prototype.__kind = 143 /* CallSignature */, ConstructSignatureSyntax.prototype.__kind = 144 /* ConstructSignature */, IndexSignatureSyntax.prototype.__kind = 145 /* IndexSignature */, MethodSignatureSyntax.prototype.__kind = 146 /* MethodSignature */, BlockSyntax.prototype.__kind = 147 /* Block */, IfStatementSyntax.prototype.__kind = 148 /* IfStatement */, VariableStatementSyntax.prototype.__kind = 149 /* VariableStatement */, ExpressionStatementSyntax.prototype.__kind = 150 /* ExpressionStatement */, ReturnStatementSyntax.prototype.__kind = 151 /* ReturnStatement */, SwitchStatementSyntax.prototype.__kind = 152 /* SwitchStatement */, BreakStatementSyntax.prototype.__kind = 153 /* BreakStatement */, ContinueStatementSyntax.prototype.__kind = 154 /* ContinueStatement */, ForStatementSyntax.prototype.__kind = 155 /* ForStatement */, ForInStatementSyntax.prototype.__kind = 156 /* ForInStatement */, EmptyStatementSyntax.prototype.__kind = 157 /* EmptyStatement */, ThrowStatementSyntax.prototype.__kind = 158 /* ThrowStatement */, WhileStatementSyntax.prototype.__kind = 159 /* WhileStatement */, TryStatementSyntax.prototype.__kind = 160 /* TryStatement */, LabeledStatementSyntax.prototype.__kind = 161 /* LabeledStatement */, DoStatementSyntax.prototype.__kind = 162 /* DoStatement */, DebuggerStatementSyntax.prototype.__kind = 163 /* DebuggerStatement */, WithStatementSyntax.prototype.__kind = 164 /* WithStatement */, DeleteExpressionSyntax.prototype.__kind = 171 /* DeleteExpression */, TypeOfExpressionSyntax.prototype.__kind = 172 /* TypeOfExpression */, VoidExpressionSyntax.prototype.__kind = 173 /* VoidExpression */, ConditionalExpressionSyntax.prototype.__kind = 187 /* ConditionalExpression */, MemberAccessExpressionSyntax.prototype.__kind = 213 /* MemberAccessExpression */, InvocationExpressionSyntax.prototype.__kind = 214 /* InvocationExpression */, ArrayLiteralExpressionSyntax.prototype.__kind = 215 /* ArrayLiteralExpression */, ObjectLiteralExpressionSyntax.prototype.__kind = 216 /* ObjectLiteralExpression */, ObjectCreationExpressionSyntax.prototype.__kind = 217 /* ObjectCreationExpression */, ParenthesizedExpressionSyntax.prototype.__kind = 218 /* ParenthesizedExpression */, ParenthesizedArrowFunctionExpressionSyntax.prototype.__kind = 219 /* ParenthesizedArrowFunctionExpression */, SimpleArrowFunctionExpressionSyntax.prototype.__kind = 220 /* SimpleArrowFunctionExpression */, CastExpressionSyntax.prototype.__kind = 221 /* CastExpression */, ElementAccessExpressionSyntax.prototype.__kind = 222 /* ElementAccessExpression */, FunctionExpressionSyntax.prototype.__kind = 223 /* FunctionExpression */, OmittedExpressionSyntax.prototype.__kind = 224 /* OmittedExpression */, VariableDeclarationSyntax.prototype.__kind = 225 /* VariableDeclaration */, VariableDeclaratorSyntax.prototype.__kind = 226 /* VariableDeclarator */, ArgumentListSyntax.prototype.__kind = 227 /* ArgumentList */, ParameterListSyntax.prototype.__kind = 228 /* ParameterList */, TypeArgumentListSyntax.prototype.__kind = 229 /* TypeArgumentList */, TypeParameterListSyntax.prototype.__kind = 230 /* TypeParameterList */, EqualsValueClauseSyntax.prototype.__kind = 233 /* EqualsValueClause */, CaseSwitchClauseSyntax.prototype.__kind = 234 /* CaseSwitchClause */, DefaultSwitchClauseSyntax.prototype.__kind = 235 /* DefaultSwitchClause */, ElseClauseSyntax.prototype.__kind = 236 /* ElseClause */, CatchClauseSyntax.prototype.__kind = 237 /* CatchClause */, FinallyClauseSyntax.prototype.__kind = 238 /* FinallyClause */, TypeParameterSyntax.prototype.__kind = 239 /* TypeParameter */, ConstraintSyntax.prototype.__kind = 240 /* Constraint */, SimplePropertyAssignmentSyntax.prototype.__kind = 241 /* SimplePropertyAssignment */, FunctionPropertyAssignmentSyntax.prototype.__kind = 242 /* FunctionPropertyAssignment */, ParameterSyntax.prototype.__kind = 243 /* Parameter */, EnumElementSyntax.prototype.__kind = 244 /* EnumElement */, TypeAnnotationSyntax.prototype.__kind = 245 /* TypeAnnotation */, ExternalModuleReferenceSyntax.prototype.__kind = 246 /* ExternalModuleReference */, ModuleNameModuleReferenceSyntax.prototype.__kind = 247 /* ModuleNameModuleReference */;
        })(Syntax.Concrete || (Syntax.Concrete = {}));
        var Concrete = Syntax.Concrete;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.syntaxDiagnosticsTime = 0;

    var SyntaxTree = (function () {
        function SyntaxTree(isConcrete, sourceUnit, isDeclaration, diagnostics, fileName, text, languageVersion) {
            this.text = text;
            this._allDiagnostics = null;
            this._isConcrete = isConcrete;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = text.lineMap();
            this._languageVersion = languageVersion;

            sourceUnit.syntaxTree = this;
        }
        SyntaxTree.prototype.isConcrete = function () {
            return this._isConcrete;
        };

        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };

        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };

        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }

            var diagnostics = [];
            TypeScript.visitNodeOrToken(new GrammarCheckerWalker(this, diagnostics), this.sourceUnit());

            return diagnostics;
        };

        SyntaxTree.prototype.diagnostics = function () {
            if (this._allDiagnostics === null) {
                var start = new Date().getTime();
                this._allDiagnostics = this.computeDiagnostics();
                TypeScript.syntaxDiagnosticsTime += new Date().getTime() - start;
            }

            return this._allDiagnostics;
        };

        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };

        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };

        SyntaxTree.prototype.languageVersion = function () {
            return this._languageVersion;
        };

        SyntaxTree.prototype.cacheSyntaxTreeInfo = function () {
            var sourceUnit = this.sourceUnit();
            var firstToken = firstSyntaxTreeToken(this);
            var leadingTrivia = firstToken.leadingTrivia(this.text);

            this._isExternalModule = externalModuleIndicatorSpanWorker(this, firstToken) !== null;

            var amdDependencies = [];
            for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    var amdDependency = this.getAmdDependency(trivia.fullText());
                    if (amdDependency) {
                        amdDependencies.push(amdDependency);
                    }
                }
            }

            this._amdDependencies = amdDependencies;
        };

        SyntaxTree.prototype.getAmdDependency = function (comment) {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : null;
        };

        SyntaxTree.prototype.isExternalModule = function () {
            if (this._isExternalModule === undefined) {
                this.cacheSyntaxTreeInfo();
                TypeScript.Debug.assert(this._isExternalModule !== undefined);
            }

            return this._isExternalModule;
        };

        SyntaxTree.prototype.amdDependencies = function () {
            if (this._amdDependencies === undefined) {
                this.cacheSyntaxTreeInfo();
                TypeScript.Debug.assert(this._amdDependencies !== undefined);
            }

            return this._amdDependencies;
        };
        return SyntaxTree;
    })();
    TypeScript.SyntaxTree = SyntaxTree;

    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(syntaxTree, diagnostics) {
            _super.call(this);
            this.syntaxTree = syntaxTree;
            this.diagnostics = diagnostics;
            this.inAmbientDeclaration = false;
            this.inBlock = false;
            this.inObjectLiteralExpression = false;
            this.text = syntaxTree.text;
        }
        GrammarCheckerWalker.prototype.pushDiagnostic = function (element, diagnosticKey, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), this.syntaxTree.lineMap(), TypeScript.start(element, this.text), TypeScript.width(element), diagnosticKey, args));
        };

        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (this.checkForCatchClauseTypeAnnotation(node) || this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }

            _super.prototype.visitCatchClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForCatchClauseTypeAnnotation = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(node.typeAnnotation.colonToken, TypeScript.DiagnosticCode.Catch_clause_parameter_cannot_have_a_type_annotation);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var seenOptionalParameter = false;
            var parameterCount = node.parameters.length;

            for (var i = 0; i < parameterCount; i++) {
                var parameter = node.parameters[i];

                if (parameter.dotDotDotToken) {
                    if (i !== (parameterCount - 1)) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list);
                        return true;
                    }

                    if (parameter.questionToken) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_cannot_be_optional);
                        return true;
                    }

                    if (parameter.equalsValueClause) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_cannot_have_an_initializer);
                        return true;
                    }
                } else if (parameter.questionToken || parameter.equalsValueClause) {
                    seenOptionalParameter = true;

                    if (parameter.questionToken && parameter.equalsValueClause) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                        return true;
                    }
                } else {
                    if (seenOptionalParameter) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter);
                        return true;
                    }
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            for (var i = 0, n = node.parameters.length; i < n; i++) {
                var parameter = node.parameters[i];

                if (this.checkParameterAccessibilityModifiers(node, parameter)) {
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifiers = function (parameterList, parameter) {
            if (parameter.modifiers.length > 0) {
                var modifiers = parameter.modifiers;

                for (var i = 0, n = modifiers.length; i < n; i++) {
                    var modifier = modifiers[i];

                    if (this.checkParameterAccessibilityModifier(parameterList, modifier, i)) {
                        return true;
                    }
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifier = function (parameterList, modifier, modifierIndex) {
            if (!TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind())) {
                this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_parameter, [modifier.text()]);
                return true;
            } else {
                if (modifierIndex > 0) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForTrailingComma = function (list) {
            if (TypeScript.childCount(list) === 0 || TypeScript.childCount(list) % 2 === 1) {
                return false;
            }

            var child = TypeScript.childAt(list, TypeScript.childCount(list) - 1);
            this.pushDiagnostic(child, TypeScript.DiagnosticCode.Trailing_comma_not_allowed);

            return true;
        };

        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (parent, list, reportToken, listKind) {
            if (TypeScript.childCount(list) > 0) {
                return false;
            }

            this.pushDiagnostic(reportToken, TypeScript.DiagnosticCode._0_list_cannot_be_empty, [listKind]);
            return true;
        };

        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) || this.checkParameterListOrder(node) || this.checkForTrailingComma(node.parameters)) {
                return;
            }

            _super.prototype.visitParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingComma(node.typeNames) || this.checkForAtLeastOneElement(node, node.typeNames, node.extendsOrImplementsKeyword, TypeScript.SyntaxFacts.getText(node.extendsOrImplementsKeyword.kind()))) {
                return;
            }

            _super.prototype.visitHeritageClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingComma(node.arguments)) {
                return;
            }

            _super.prototype.visitArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForAtLeastOneElement(node, node.variableDeclarators, node.varKeyword, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.variable_declaration, null)) || this.checkForTrailingComma(node.variableDeclarators)) {
                return;
            }

            _super.prototype.visitVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingComma(node.typeArguments) || this.checkForAtLeastOneElement(node, node.typeArguments, node.lessThanToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_argument, null))) {
                return;
            }

            _super.prototype.visitTypeArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTupleType = function (node) {
            if (this.checkForTrailingComma(node.types) || this.checkForAtLeastOneElement(node, node.types, node.openBracketToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null))) {
                return;
            }

            _super.prototype.visitTupleType.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingComma(node.typeParameters) || this.checkForAtLeastOneElement(node, node.typeParameters, node.lessThanToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, null))) {
                return;
            }

            _super.prototype.visitTypeParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            if (node.parameters.length !== 1) {
                this.pushDiagnostic(node.openBracketToken, TypeScript.DiagnosticCode.Index_signature_must_have_exactly_one_parameter);
                return true;
            }

            var parameter = node.parameters[0];

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            } else if (parameter.modifiers.length > 0) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifiers);
                return true;
            } else if (parameter.questionToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            } else if (parameter.equalsValueClause) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            } else if (!parameter.typeAnnotation) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            } else if (parameter.typeAnnotation.type.kind() !== 69 /* StringKeyword */ && parameter.typeAnnotation.type.kind() !== 67 /* NumberKeyword */) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_type_must_be_string_or_number);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                return;
            }

            if (!node.typeAnnotation) {
                this.pushDiagnostic(node, TypeScript.DiagnosticCode.Index_signature_must_have_a_type_annotation);
                return;
            }

            _super.prototype.visitIndexSignature.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var seenExtendsClause = false;
            var seenImplementsClause = false;

            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses[i];

                if (heritageClause.extendsOrImplementsKeyword.kind() === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_must_precede_implements_clause);
                        return true;
                    }

                    if (heritageClause.typeNames.length > 1) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.Classes_can_only_extend_a_single_class);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.kind() === 51 /* ImplementsKeyword */);
                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.implements_clause_already_seen);
                        return true;
                    }

                    seenImplementsClause = true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);

                if (declareToken) {
                    this.pushDiagnostic(declareToken, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, reportToken, modifiers) {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                if (!TypeScript.SyntaxUtilities.containsToken(modifiers, 63 /* DeclareKeyword */)) {
                    this.pushDiagnostic(reportToken, TypeScript.DiagnosticCode.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
                    return true;
                }
            }
        };

        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkClassDeclarationHeritageClauses(node)) {
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var seenExtendsClause = false;

            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses[i];

                if (heritageClause.extendsOrImplementsKeyword.kind() === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.kind() === 51 /* ImplementsKeyword */);
                    this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.Interface_declaration_cannot_have_implements_clause);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (modifier.kind() === 63 /* DeclareKeyword */) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_with_an_interface_declaration);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkInterfaceModifiers(node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkInterfaceDeclarationHeritageClauses(node)) {
                return;
            }

            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;

            for (var i = 0, n = list.length; i < n; i++) {
                var modifier = list[i];
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind())) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }

                    if (seenStaticModifier) {
                        var previousToken = list[i - 1];
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [modifier.text(), previousToken.text()]);
                        return true;
                    }

                    seenAccessibilityModifier = true;
                } else if (modifier.kind() === 58 /* StaticKeyword */) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return true;
                    }

                    seenStaticModifier = true;
                } else {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_class_element, [modifier.text()]);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                return;
            }

            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                return;
            }

            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkGetAccessorParameter = function (node) {
            if (node.callSignature.parameterList.parameters.length !== 0) {
                this.pushDiagnostic(node.propertyName, TypeScript.DiagnosticCode.get_accessor_cannot_have_parameters);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitIndexMemberDeclaration = function (node) {
            if (this.checkIndexMemberModifiers(node)) {
                return;
            }

            _super.prototype.visitIndexMemberDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkIndexMemberModifiers = function (node) {
            if (node.modifiers.length > 0) {
                this.pushDiagnostic(TypeScript.childAt(node.modifiers, 0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkEcmaScriptVersionIsAtLeast = function (parent, reportToken, languageVersion, diagnosticKey) {
            if (this.syntaxTree.languageVersion() < languageVersion) {
                this.pushDiagnostic(reportToken, diagnosticKey);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitObjectLiteralExpression = function (node) {
            var savedInObjectLiteralExpression = this.inObjectLiteralExpression;
            this.inObjectLiteralExpression = true;
            _super.prototype.visitObjectLiteralExpression.call(this, node);
            this.inObjectLiteralExpression = savedInObjectLiteralExpression;
        };

        GrammarCheckerWalker.prototype.visitGetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node, node.propertyName, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkClassElementModifiers(node.modifiers) || this.checkForDisallowedAccessorTypeParameters(node.callSignature) || this.checkGetAccessorParameter(node)) {
                return;
            }

            _super.prototype.visitGetAccessor.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForDisallowedSetAccessorTypeAnnotation = function (accessor) {
            if (accessor.callSignature.typeAnnotation) {
                this.pushDiagnostic(accessor.callSignature.typeAnnotation, TypeScript.DiagnosticCode.Type_annotation_cannot_appear_on_a_set_accessor);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedAccessorTypeParameters = function (callSignature) {
            if (callSignature.typeParameterList !== null) {
                this.pushDiagnostic(callSignature.typeParameterList, TypeScript.DiagnosticCode.Type_parameters_cannot_appear_on_an_accessor);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForAccessorDeclarationInAmbientContext = function (accessor) {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic(accessor, TypeScript.DiagnosticCode.Accessors_are_not_allowed_in_ambient_contexts);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkSetAccessorParameter = function (node) {
            var parameters = node.callSignature.parameterList.parameters;
            if (TypeScript.childCount(parameters) !== 1) {
                this.pushDiagnostic(node.propertyName, TypeScript.DiagnosticCode.set_accessor_must_have_exactly_one_parameter);
                return true;
            }

            var parameter = parameters[0];

            if (parameter.questionToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_be_optional);
                return true;
            }

            if (parameter.equalsValueClause) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_an_initializer);
                return true;
            }

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_cannot_have_rest_parameter);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitSetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node, node.propertyName, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkClassElementModifiers(node.modifiers) || this.checkForDisallowedAccessorTypeParameters(node.callSignature) || this.checkForDisallowedSetAccessorTypeAnnotation(node) || this.checkSetAccessorParameter(node)) {
                return;
            }

            _super.prototype.visitSetAccessor.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers), this.checkEnumElements(node)) {
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkEnumElements = function (node) {
            var previousValueWasComputed = false;
            for (var i = 0, n = TypeScript.childCount(node.enumElements); i < n; i++) {
                var child = TypeScript.childAt(node.enumElements, i);

                if (i % 2 === 0) {
                    var enumElement = child;

                    if (!enumElement.equalsValueClause && previousValueWasComputed) {
                        this.pushDiagnostic(enumElement, TypeScript.DiagnosticCode.Enum_member_must_have_initializer);
                        return true;
                    }

                    if (enumElement.equalsValueClause) {
                        var value = enumElement.equalsValueClause.value;
                        previousValueWasComputed = !TypeScript.Syntax.isIntegerLiteral(value);
                    }
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitEnumElement = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                var expression = node.equalsValueClause.value;
                if (!TypeScript.Syntax.isIntegerLiteral(expression)) {
                    this.pushDiagnostic(node.equalsValueClause.value, TypeScript.DiagnosticCode.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    return;
                }
            }

            _super.prototype.visitEnumElement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind() === 50 /* SuperKeyword */ && node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic(node, TypeScript.DiagnosticCode.super_invocation_cannot_have_type_arguments);
            }

            _super.prototype.visitInvocationExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var seenExportModifier = false;
            var seenDeclareModifier = false;

            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind()) || modifier.kind() === 58 /* StaticKeyword */) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_module_element, [modifier.text()]);
                    return true;
                }

                if (modifier.kind() === 63 /* DeclareKeyword */) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }

                    seenDeclareModifier = true;
                } else if (modifier.kind() === 47 /* ExportKeyword */) {
                    if (seenExportModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return;
                    }

                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [TypeScript.SyntaxFacts.getText(47 /* ExportKeyword */), TypeScript.SyntaxFacts.getText(63 /* DeclareKeyword */)]);
                        return;
                    }

                    seenExportModifier = true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            if (!node.stringLiteral) {
                for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                    var child = node.moduleElements[i];
                    if (child.kind() === 134 /* ImportDeclaration */) {
                        var importDeclaration = child;
                        if (importDeclaration.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                            this.pushDiagnostic(importDeclaration, TypeScript.DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);
                        }
                    }
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifierOnImportDeclaration = function (modifiers) {
            var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);

            if (declareToken) {
                this.pushDiagnostic(declareToken, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_with_an_import_declaration);
                return true;
            }
        };

        GrammarCheckerWalker.prototype.visitImportDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifierOnImportDeclaration(node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                return;
            }

            _super.prototype.visitImportDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.stringLiteral ? node.stringLiteral : TypeScript.firstToken(node.name), node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedImportDeclaration(node)) {
                return;
            }

            if (node.stringLiteral) {
                if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                    this.pushDiagnostic(node.stringLiteral, TypeScript.DiagnosticCode.Only_ambient_modules_can_use_quoted_names);
                    return;
                }
            }

            if (!node.stringLiteral && this.checkForDisallowedExportAssignment(node)) {
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedExportAssignment = function (node) {
            for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                var child = node.moduleElements[i];

                if (child.kind() === 135 /* ExportAssignment */) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode.Export_assignment_cannot_be_used_in_internal_modules);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.checkForBlockInAmbientContext(node)) {
                return;
            }

            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };

        GrammarCheckerWalker.prototype.checkForBlockInAmbientContext = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                if (node.parent.kind() === 1 /* List */) {
                    this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                } else {
                    this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.A_function_implementation_cannot_be_declared_in_an_ambient_context);
                }

                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkBreakStatementTarget(node)) {
                return;
            }

            _super.prototype.visitBreakStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkContinueStatementTarget(node)) {
                return;
            }

            _super.prototype.visitContinueStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkBreakStatementTarget = function (node) {
            if (node.identifier) {
                var breakableLabels = this.getEnclosingLabels(node, true, false);

                if (!TypeScript.ArrayUtilities.any(breakableLabels, function (s) {
                    return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier);
                })) {
                    var breakableLabels = this.getEnclosingLabels(node, true, true);
                    if (TypeScript.ArrayUtilities.any(breakableLabels, function (s) {
                        return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier);
                    })) {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    } else {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_not_found);
                    }

                    return true;
                }
            } else if (!this.inIterationStatement(node, false) && !this.inSwitchStatement(node)) {
                if (this.inIterationStatement(node, true)) {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                } else {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);
                }

                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.inSwitchStatement = function (ast) {
            while (ast) {
                if (ast.kind() === 152 /* SwitchStatement */) {
                    return true;
                }

                if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(ast)) {
                    return false;
                }

                ast = ast.parent;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.isIterationStatement = function (ast) {
            switch (ast.kind()) {
                case 155 /* ForStatement */:
                case 156 /* ForInStatement */:
                case 159 /* WhileStatement */:
                case 162 /* DoStatement */:
                    return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.inIterationStatement = function (element, crossFunctions) {
            while (element) {
                if (this.isIterationStatement(element)) {
                    return true;
                }

                if (!crossFunctions && TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    return false;
                }

                element = element.parent;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.getEnclosingLabels = function (element, breakable, crossFunctions) {
            var result = [];

            element = element.parent;
            while (element) {
                if (element.kind() === 161 /* LabeledStatement */) {
                    var labeledStatement = element;
                    if (breakable) {
                        result.push(labeledStatement);
                    } else {
                        if (this.labelIsOnContinuableConstruct(labeledStatement.statement)) {
                            result.push(labeledStatement);
                        }
                    }
                }

                if (!crossFunctions && TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    break;
                }

                element = element.parent;
            }

            return result;
        };

        GrammarCheckerWalker.prototype.labelIsOnContinuableConstruct = function (statement) {
            switch (statement.kind()) {
                case 161 /* LabeledStatement */:
                    return this.labelIsOnContinuableConstruct(statement.statement);

                case 159 /* WhileStatement */:
                case 155 /* ForStatement */:
                case 156 /* ForInStatement */:
                case 162 /* DoStatement */:
                    return true;

                default:
                    return false;
            }
        };

        GrammarCheckerWalker.prototype.checkContinueStatementTarget = function (node) {
            if (!this.inIterationStatement(node, false)) {
                if (this.inIterationStatement(node, true)) {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                } else {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);
                }

                return true;
            } else if (node.identifier) {
                var continuableLabels = this.getEnclosingLabels(node, false, false);

                if (!TypeScript.ArrayUtilities.any(continuableLabels, function (s) {
                    return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier);
                })) {
                    var continuableLabels = this.getEnclosingLabels(node, false, true);

                    if (TypeScript.ArrayUtilities.any(continuableLabels, function (s) {
                        return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier);
                    })) {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    } else {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_not_found);
                    }

                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitDebuggerStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitDoStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitEmptyStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitExpressionStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForInStatementVariableDeclaration(node) || this.checkForInLeftHandSideExpression(node)) {
                return;
            }

            _super.prototype.visitForInStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForInLeftHandSideExpression = function (node) {
            if (node.left && !TypeScript.SyntaxUtilities.isLeftHandSizeExpression(node.left)) {
                this.pushDiagnostic(node.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_in_for_in_statement);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForInStatementVariableDeclaration = function (node) {
            if (node.variableDeclaration && node.variableDeclaration.variableDeclarators.length > 1) {
                this.pushDiagnostic(node.variableDeclaration, TypeScript.DiagnosticCode.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitForStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitIfStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForInvalidLabelIdentifier(node)) {
                return;
            }

            _super.prototype.visitLabeledStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForInvalidLabelIdentifier = function (node) {
            var labelIdentifier = TypeScript.tokenValueText(node.identifier);

            var breakableLabels = this.getEnclosingLabels(node, true, false);

            var matchingLabel = TypeScript.ArrayUtilities.firstOrDefault(breakableLabels, function (s) {
                return TypeScript.tokenValueText(s.identifier) === labelIdentifier;
            });
            if (matchingLabel) {
                this.pushDiagnostic(node.identifier, TypeScript.DiagnosticCode.Duplicate_identifier_0, [labelIdentifier]);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForReturnStatementNotInFunctionBody(node)) {
                return;
            }

            _super.prototype.visitReturnStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForReturnStatementNotInFunctionBody = function (node) {
            for (var element = node; element; element = element.parent) {
                if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    return false;
                }
            }

            this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.return_statement_must_be_contained_within_a_function_body);
            return true;
        };

        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitSwitchStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitThrowStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitTryStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            _super.prototype.visitWhileStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForWithInStrictMode(node)) {
                return;
            }

            _super.prototype.visitWithStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForWithInStrictMode = function (node) {
            if (TypeScript.parsedInStrictMode(node)) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.with_statements_are_not_allowed_in_strict_mode);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (parent, modifiers) {
            if (this.inBlock || this.inObjectLiteralExpression) {
                if (modifiers.length > 0) {
                    this.pushDiagnostic(TypeScript.childAt(modifiers, 0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitFunctionExpression = function (node) {
            if (this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }

            _super.prototype.visitFunctionExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.variableDeclaration.varKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkListSeparators = function (parent, list, kind) {
            for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                var child = TypeScript.childAt(list, i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(kind)]);
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node, node.typeMembers, 78 /* SemicolonToken */)) {
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitVariableDeclarator = function (node) {
            if (this.checkVariableDeclaratorInitializer(node) || this.checkVariableDeclaratorIdentifier(node)) {
                return;
            }

            _super.prototype.visitVariableDeclarator.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkVariableDeclaratorIdentifier = function (node) {
            if (node.parent.kind() !== 137 /* MemberVariableDeclaration */) {
                if (this.checkForDisallowedEvalOrArguments(node, node.propertyName)) {
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkVariableDeclaratorInitializer = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                this.pushDiagnostic(TypeScript.firstToken(node.equalsValueClause.value), TypeScript.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) || this.checkConstructorModifiers(node.modifiers) || this.checkConstructorTypeParameterList(node) || this.checkConstructorTypeAnnotation(node)) {
                return;
            }

            _super.prototype.visitConstructorDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkConstructorModifiers = function (modifiers) {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var child = modifiers[i];
                if (child.kind() !== 57 /* PublicKeyword */) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_constructor_declaration, [TypeScript.SyntaxFacts.getText(child.kind())]);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkConstructorTypeParameterList = function (node) {
            if (node.callSignature.typeParameterList) {
                this.pushDiagnostic(node.callSignature.typeParameterList, TypeScript.DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkConstructorTypeAnnotation = function (node) {
            if (node.callSignature.typeAnnotation) {
                this.pushDiagnostic(node.callSignature.typeAnnotation, TypeScript.DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBinaryExpression = function (node) {
            if (this.checkIllegalAssignment(node)) {
                return;
            }

            _super.prototype.visitBinaryExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitPrefixUnaryExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && this.isPreIncrementOrDecrementExpression(node) && this.isEvalOrArguments(node.operand)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.operand)]);
            }

            _super.prototype.visitPrefixUnaryExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitPostfixUnaryExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && this.isEvalOrArguments(node.operand)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.operand)]);
            }

            _super.prototype.visitPostfixUnaryExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitParameter = function (node) {
            if (this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }

            _super.prototype.visitParameter.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForDisallowedEvalOrArguments = function (node, token) {
            if (token) {
                if (TypeScript.parsedInStrictMode(node) && this.isEvalOrArguments(token)) {
                    this.pushDiagnostic(token, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(token)]);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.isPreIncrementOrDecrementExpression = function (node) {
            switch (node.kind()) {
                case 170 /* PreDecrementExpression */:
                case 169 /* PreIncrementExpression */:
                    return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitDeleteExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && node.expression.kind() === 11 /* IdentifierName */) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.delete_cannot_be_called_on_an_identifier_in_strict_mode);
                return;
            }

            _super.prototype.visitDeleteExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkIllegalAssignment = function (node) {
            if (TypeScript.parsedInStrictMode(node) && TypeScript.SyntaxFacts.isAssignmentOperatorToken(node.operatorToken.kind()) && this.isEvalOrArguments(node.left)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.left)]);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.getEvalOrArguments = function (expr) {
            if (expr.kind() === 11 /* IdentifierName */) {
                var text = TypeScript.tokenValueText(expr);
                if (text === "eval" || text === "arguments") {
                    return text;
                }
            }

            return null;
        };

        GrammarCheckerWalker.prototype.isEvalOrArguments = function (expr) {
            return this.getEvalOrArguments(expr) !== null;
        };

        GrammarCheckerWalker.prototype.visitConstraint = function (node) {
            if (this.checkConstraintType(node)) {
                return;
            }

            _super.prototype.visitConstraint.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkConstraintType = function (node) {
            if (!TypeScript.SyntaxFacts.isType(node.typeOrExpression.kind())) {
                this.pushDiagnostic(node.typeOrExpression, TypeScript.DiagnosticCode.Type_expected);
                return true;
            }

            return false;
        };
        return GrammarCheckerWalker;
    })(TypeScript.SyntaxWalker);

    function firstSyntaxTreeToken(syntaxTree) {
        var scanner = TypeScript.Scanner.createScanner(syntaxTree.languageVersion(), syntaxTree.text, function () {
        });
        return scanner.scan(false);
    }

    function externalModuleIndicatorSpan(syntaxTree) {
        var firstToken = firstSyntaxTreeToken(syntaxTree);
        return externalModuleIndicatorSpanWorker(syntaxTree, firstToken);
    }
    TypeScript.externalModuleIndicatorSpan = externalModuleIndicatorSpan;

    function externalModuleIndicatorSpanWorker(syntaxTree, firstToken) {
        var leadingTrivia = firstToken.leadingTrivia(syntaxTree.text);
        return implicitImportSpan(leadingTrivia) || topLevelImportOrExportSpan(syntaxTree.sourceUnit());
    }
    TypeScript.externalModuleIndicatorSpanWorker = externalModuleIndicatorSpanWorker;

    function implicitImportSpan(sourceUnitLeadingTrivia) {
        for (var i = 0, n = sourceUnitLeadingTrivia.count(); i < n; i++) {
            var trivia = sourceUnitLeadingTrivia.syntaxTriviaAt(i);

            if (trivia.isComment()) {
                var span = implicitImportSpanWorker(trivia);
                if (span) {
                    return span;
                }
            }
        }

        return null;
    }

    function implicitImportSpanWorker(trivia) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(trivia.fullText());

        if (match) {
            return new TypeScript.TextSpan(trivia.fullStart(), trivia.fullWidth());
        }

        return null;
    }

    function topLevelImportOrExportSpan(node) {
        for (var i = 0, n = node.moduleElements.length; i < n; i++) {
            var moduleElement = node.moduleElements[i];

            var _firstToken = TypeScript.firstToken(moduleElement);
            if (_firstToken !== null && _firstToken.kind() === 47 /* ExportKeyword */) {
                return new TypeScript.TextSpan(TypeScript.start(_firstToken), TypeScript.width(_firstToken));
            }

            if (moduleElement.kind() === 134 /* ImportDeclaration */) {
                var importDecl = moduleElement;
                if (importDecl.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                    var literal = importDecl.moduleReference.stringLiteral;
                    return new TypeScript.TextSpan(TypeScript.start(literal), TypeScript.width(literal));
                }
            }
        }

        return null;
    }
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.lookupInUnicodeMap = function (code, map) {
            if (code < map[0]) {
                return false;
            }

            var lo = 0;
            var hi = map.length;
            var mid;

            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;

                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }

                if (code < map[mid]) {
                    hi = mid;
                } else {
                    lo = mid + 2;
                }
            }

            return false;
        };

        Unicode.isIdentifierStart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };

        Unicode.isIdentifierPart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];

        Unicode.unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        return Unicode;
    })();
    TypeScript.Unicode = Unicode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PrettyPrinter) {
        function prettyPrint(node, indentWhitespace) {
            if (typeof indentWhitespace === "undefined") { indentWhitespace = "    "; }
            var impl = new PrettyPrinterImpl(indentWhitespace);
            TypeScript.visitNodeOrToken(impl, node);
            return impl.result.join("");
        }
        PrettyPrinter.prettyPrint = prettyPrint;

        var PrettyPrinterImpl = (function () {
            function PrettyPrinterImpl(indentWhitespace) {
                this.indentWhitespace = indentWhitespace;
                this.result = [];
                this.indentations = [];
                this.indentation = 0;
            }
            PrettyPrinterImpl.prototype.newLineCountBetweenModuleElements = function (element1, element2) {
                if (element1 === null || element2 === null) {
                    return 0;
                }

                if (TypeScript.lastToken(element1).kind() === 71 /* CloseBraceToken */) {
                    return 2;
                }

                return 1;
            };

            PrettyPrinterImpl.prototype.newLineCountBetweenClassElements = function (element1, element2) {
                if (element1 === null || element2 === null) {
                    return 0;
                }

                return 1;
            };

            PrettyPrinterImpl.prototype.newLineCountBetweenStatements = function (element1, element2) {
                if (element1 === null || element2 === null) {
                    return 0;
                }

                if (TypeScript.lastToken(element1).kind() === 71 /* CloseBraceToken */) {
                    return 2;
                }

                return 1;
            };

            PrettyPrinterImpl.prototype.newLineCountBetweenSwitchClauses = function (element1, element2) {
                if (element1 === null || element2 === null) {
                    return 0;
                }

                if (TypeScript.childCount(element1.statements) === 0) {
                    return 1;
                }

                return 2;
            };

            PrettyPrinterImpl.prototype.ensureSpace = function () {
                if (this.result.length > 0) {
                    var last = TypeScript.ArrayUtilities.last(this.result);
                    if (last !== " " && last !== "\r\n") {
                        this.appendText(" ");
                    }
                }
            };

            PrettyPrinterImpl.prototype.ensureNewLine = function () {
                if (this.result.length > 0) {
                    var last = TypeScript.ArrayUtilities.last(this.result);
                    if (last !== "\r\n") {
                        this.appendText("\r\n");
                    }
                }
            };

            PrettyPrinterImpl.prototype.appendNewLines = function (count) {
                for (var i = 0; i < count; i++) {
                    this.appendText("\r\n");
                }
            };

            PrettyPrinterImpl.prototype.getIndentation = function (count) {
                for (var i = this.indentations.length; i <= count; i++) {
                    var text = i === 0 ? "" : this.indentations[i - 1] + this.indentWhitespace;
                    this.indentations[i] = text;
                }

                return this.indentations[count];
            };

            PrettyPrinterImpl.prototype.appendIndentationIfAfterNewLine = function () {
                if (this.result.length > 0) {
                    if (TypeScript.ArrayUtilities.last(this.result) === "\r\n") {
                        this.result.push(this.getIndentation(this.indentation));
                    }
                }
            };

            PrettyPrinterImpl.prototype.appendText = function (text) {
                this.result.push(text);
            };

            PrettyPrinterImpl.prototype.appendElement = function (element) {
                if (TypeScript.isToken(element)) {
                    this.appendToken(element);
                } else if (TypeScript.isNode(element)) {
                    this.appendNode(element);
                }
            };

            PrettyPrinterImpl.prototype.appendNode = function (node) {
                TypeScript.visitNodeOrToken(this, node);
            };

            PrettyPrinterImpl.prototype.appendToken = function (token) {
                if (token !== null && token.fullWidth() > 0) {
                    this.appendIndentationIfAfterNewLine();
                    this.appendText(token.text());
                }
            };

            PrettyPrinterImpl.prototype.visitToken = function (token) {
                this.appendToken(token);
            };

            PrettyPrinterImpl.prototype.appendSpaceList = function (list) {
                for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                    if (TypeScript.isNode(TypeScript.childAt(list, i))) {
                        this.appendNode(TypeScript.childAt(list, i));
                    } else {
                        this.appendToken(TypeScript.childAt(list, i));
                    }

                    this.ensureSpace();
                }
            };

            PrettyPrinterImpl.prototype.appendSeparatorSpaceList = function (list) {
                for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                    if (i % 2 === 0) {
                        if (i > 0) {
                            this.ensureSpace();
                        }

                        TypeScript.visitNodeOrToken(this, TypeScript.childAt(list, i));
                    } else {
                        this.appendToken(TypeScript.childAt(list, i));
                    }
                }
            };

            PrettyPrinterImpl.prototype.appendSeparatorNewLineList = function (list) {
                for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                    if (i % 2 === 0) {
                        if (i > 0) {
                            this.ensureNewLine();
                        }

                        TypeScript.visitNodeOrToken(this, TypeScript.childAt(list, i));
                    } else {
                        this.appendToken(TypeScript.childAt(list, i));
                    }
                }
            };

            PrettyPrinterImpl.prototype.appendModuleElements = function (list) {
                var lastModuleElement = null;
                for (var i = 0, n = list.length; i < n; i++) {
                    var moduleElement = list[i];
                    var newLineCount = this.newLineCountBetweenModuleElements(lastModuleElement, moduleElement);

                    this.appendNewLines(newLineCount);
                    TypeScript.visitNodeOrToken(this, moduleElement);

                    lastModuleElement = moduleElement;
                }
            };

            PrettyPrinterImpl.prototype.visitSourceUnit = function (node) {
                this.appendModuleElements(node.moduleElements);
            };

            PrettyPrinterImpl.prototype.visitExternalModuleReference = function (node) {
                this.appendToken(node.requireKeyword);
                this.appendToken(node.openParenToken);
                this.appendToken(node.stringLiteral);
                this.appendToken(node.closeParenToken);
            };

            PrettyPrinterImpl.prototype.visitModuleNameModuleReference = function (node) {
                TypeScript.visitNodeOrToken(this, node.moduleName);
            };

            PrettyPrinterImpl.prototype.visitImportDeclaration = function (node) {
                this.appendToken(node.importKeyword);
                this.ensureSpace();
                this.appendToken(node.identifier);
                this.ensureSpace();
                this.appendToken(node.equalsToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.moduleReference);
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitExportAssignment = function (node) {
                this.appendToken(node.exportKeyword);
                this.ensureSpace();
                this.appendToken(node.equalsToken);
                this.ensureSpace();
                this.appendToken(node.identifier);
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitClassDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.classKeyword);
                this.ensureSpace();
                this.appendToken(node.identifier);
                this.appendNode(node.typeParameterList);
                this.ensureSpace();
                this.appendSpaceList(node.heritageClauses);
                this.ensureSpace();
                this.appendToken(node.openBraceToken);
                this.ensureNewLine();

                this.indentation++;

                var lastClassElement = null;
                for (var i = 0, n = node.classElements.length; i < n; i++) {
                    var classElement = node.classElements[i];
                    var newLineCount = this.newLineCountBetweenClassElements(lastClassElement, classElement);

                    this.appendNewLines(newLineCount);
                    TypeScript.visitNodeOrToken(this, classElement);

                    lastClassElement = classElement;
                }

                this.indentation--;

                this.ensureNewLine();
                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.visitInterfaceDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.interfaceKeyword);
                this.ensureSpace();
                this.appendToken(node.identifier);
                this.appendNode(node.typeParameterList);
                this.ensureSpace();
                this.appendSpaceList(node.heritageClauses);
                this.ensureSpace();
                this.appendObjectType(node.body, true);
            };

            PrettyPrinterImpl.prototype.appendObjectType = function (node, appendNewLines) {
                this.appendToken(node.openBraceToken);

                if (appendNewLines) {
                    this.ensureNewLine();
                    this.indentation++;
                } else {
                    this.ensureSpace();
                }

                for (var i = 0, n = TypeScript.childCount(node.typeMembers); i < n; i++) {
                    TypeScript.visitNodeOrToken(this, TypeScript.childAt(node.typeMembers, i));

                    if (appendNewLines) {
                        this.ensureNewLine();
                    } else {
                        this.ensureSpace();
                    }
                }

                this.indentation--;
                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.visitHeritageClause = function (node) {
                this.appendToken(node.extendsOrImplementsKeyword);
                this.ensureSpace();
                this.appendSeparatorSpaceList(node.typeNames);
            };

            PrettyPrinterImpl.prototype.visitModuleDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.moduleKeyword);
                this.ensureSpace();
                this.appendElement(node.name);
                this.ensureSpace();
                this.appendToken(node.stringLiteral);
                this.ensureSpace();

                this.appendToken(node.openBraceToken);
                this.ensureNewLine();

                this.indentation++;

                this.appendModuleElements(node.moduleElements);

                this.indentation--;
                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.appendBlockOrSemicolon = function (block, semicolonToken) {
                if (block) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, block);
                } else {
                    this.appendToken(semicolonToken);
                }
            };

            PrettyPrinterImpl.prototype.visitFunctionDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.functionKeyword);
                this.ensureSpace();
                this.appendToken(node.identifier);
                this.appendNode(node.callSignature);
                this.appendBlockOrSemicolon(node.block, node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitVariableStatement = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.variableDeclaration);
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitVariableDeclaration = function (node) {
                this.appendToken(node.varKeyword);
                this.ensureSpace();
                this.appendSeparatorSpaceList(node.variableDeclarators);
            };

            PrettyPrinterImpl.prototype.visitVariableDeclarator = function (node) {
                this.appendToken(node.propertyName);
                this.appendNode(node.equalsValueClause);
            };

            PrettyPrinterImpl.prototype.visitEqualsValueClause = function (node) {
                this.ensureSpace();
                this.appendToken(node.equalsToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.value);
            };

            PrettyPrinterImpl.prototype.visitPrefixUnaryExpression = function (node) {
                this.appendToken(node.operatorToken);
                TypeScript.visitNodeOrToken(this, node.operand);
            };

            PrettyPrinterImpl.prototype.visitArrayLiteralExpression = function (node) {
                this.appendToken(node.openBracketToken);
                this.appendSeparatorSpaceList(node.expressions);
                this.appendToken(node.closeBracketToken);
            };

            PrettyPrinterImpl.prototype.visitOmittedExpression = function (node) {
            };

            PrettyPrinterImpl.prototype.visitParenthesizedExpression = function (node) {
                this.appendToken(node.openParenToken);
                TypeScript.visitNodeOrToken(this, node.expression);
                this.appendToken(node.closeParenToken);
            };

            PrettyPrinterImpl.prototype.visitSimpleArrowFunctionExpression = function (node) {
                this.appendNode(node.parameter);
                this.ensureSpace();
                this.appendToken(node.equalsGreaterThanToken);
                this.ensureSpace();
                this.appendNode(node.block);
                this.appendElement(node.expression);
            };

            PrettyPrinterImpl.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
                TypeScript.visitNodeOrToken(this, node.callSignature);
                this.ensureSpace();
                this.appendToken(node.equalsGreaterThanToken);
                this.ensureSpace();
                this.appendNode(node.block);
                this.appendElement(node.expression);
            };

            PrettyPrinterImpl.prototype.visitQualifiedName = function (node) {
                TypeScript.visitNodeOrToken(this, node.left);
                this.appendToken(node.dotToken);
                this.appendToken(node.right);
            };

            PrettyPrinterImpl.prototype.visitTypeQuery = function (node) {
                this.appendToken(node.typeOfKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.name);
            };

            PrettyPrinterImpl.prototype.visitTypeArgumentList = function (node) {
                this.appendToken(node.lessThanToken);
                this.appendSeparatorSpaceList(node.typeArguments);
                this.appendToken(node.greaterThanToken);
            };

            PrettyPrinterImpl.prototype.visitTupleType = function (node) {
                this.appendToken(node.openBracketToken);
                this.appendSeparatorSpaceList(node.types);
                this.appendToken(node.closeBracketToken);
            };

            PrettyPrinterImpl.prototype.visitConstructorType = function (node) {
                this.appendToken(node.newKeyword);
                this.ensureSpace();
                this.appendNode(node.typeParameterList);
                TypeScript.visitNodeOrToken(this, node.parameterList);
                this.ensureSpace();
                this.appendToken(node.equalsGreaterThanToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.type);
            };

            PrettyPrinterImpl.prototype.visitFunctionType = function (node) {
                this.appendNode(node.typeParameterList);
                TypeScript.visitNodeOrToken(this, node.parameterList);
                this.ensureSpace();
                this.appendToken(node.equalsGreaterThanToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.type);
            };

            PrettyPrinterImpl.prototype.visitObjectType = function (node) {
                this.appendToken(node.openBraceToken);
                this.ensureSpace();
                this.appendSeparatorSpaceList(node.typeMembers);
                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.visitArrayType = function (node) {
                TypeScript.visitNodeOrToken(this, node.type);
                this.appendToken(node.openBracketToken);
                this.appendToken(node.closeBracketToken);
            };

            PrettyPrinterImpl.prototype.visitGenericType = function (node) {
                TypeScript.visitNodeOrToken(this, node.name);
                TypeScript.visitNodeOrToken(this, node.typeArgumentList);
            };

            PrettyPrinterImpl.prototype.visitTypeAnnotation = function (node) {
                this.appendToken(node.colonToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.type);
            };

            PrettyPrinterImpl.prototype.appendStatements = function (statements) {
                var lastStatement = null;
                for (var i = 0, n = statements.length; i < n; i++) {
                    var statement = statements[i];

                    var newLineCount = this.newLineCountBetweenStatements(lastStatement, statement);

                    this.appendNewLines(newLineCount);
                    TypeScript.visitNodeOrToken(this, statement);

                    lastStatement = statement;
                }
            };

            PrettyPrinterImpl.prototype.visitBlock = function (node) {
                this.appendToken(node.openBraceToken);
                this.ensureNewLine();
                this.indentation++;

                this.appendStatements(node.statements);

                this.indentation--;
                this.ensureNewLine();
                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.visitParameter = function (node) {
                this.appendToken(node.dotDotDotToken);
                this.appendSpaceList(node.modifiers);
                this.appendToken(node.identifier);
                this.appendToken(node.questionToken);
                this.appendNode(node.typeAnnotation);
                this.appendNode(node.equalsValueClause);
            };

            PrettyPrinterImpl.prototype.visitMemberAccessExpression = function (node) {
                TypeScript.visitNodeOrToken(this, node.expression);
                this.appendToken(node.dotToken);
                this.appendToken(node.name);
            };

            PrettyPrinterImpl.prototype.visitPostfixUnaryExpression = function (node) {
                TypeScript.visitNodeOrToken(this, node.operand);
                this.appendToken(node.operatorToken);
            };

            PrettyPrinterImpl.prototype.visitElementAccessExpression = function (node) {
                TypeScript.visitNodeOrToken(this, node.expression);
                this.appendToken(node.openBracketToken);
                TypeScript.visitNodeOrToken(this, node.argumentExpression);
                this.appendToken(node.closeBracketToken);
            };

            PrettyPrinterImpl.prototype.visitInvocationExpression = function (node) {
                TypeScript.visitNodeOrToken(this, node.expression);
                TypeScript.visitNodeOrToken(this, node.argumentList);
            };

            PrettyPrinterImpl.prototype.visitArgumentList = function (node) {
                this.appendToken(node.openParenToken);
                this.appendSeparatorSpaceList(node.arguments);
                this.appendToken(node.closeParenToken);
            };

            PrettyPrinterImpl.prototype.visitBinaryExpression = function (node) {
                TypeScript.visitNodeOrToken(this, node.left);

                if (node.kind() !== 174 /* CommaExpression */) {
                    this.ensureSpace();
                }

                this.appendToken(node.operatorToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.right);
            };

            PrettyPrinterImpl.prototype.visitConditionalExpression = function (node) {
                TypeScript.visitNodeOrToken(this, node.condition);
                this.ensureSpace();
                this.appendToken(node.questionToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.whenTrue);
                this.ensureSpace();
                this.appendToken(node.colonToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.whenFalse);
            };

            PrettyPrinterImpl.prototype.visitConstructSignature = function (node) {
                this.appendToken(node.newKeyword);
                TypeScript.visitNodeOrToken(this, node.callSignature);
            };

            PrettyPrinterImpl.prototype.visitMethodSignature = function (node) {
                this.appendToken(node.propertyName);
                this.appendToken(node.questionToken);
                TypeScript.visitNodeOrToken(this, node.callSignature);
            };

            PrettyPrinterImpl.prototype.visitIndexSignature = function (node) {
                this.appendToken(node.openBracketToken);
                this.appendSeparatorSpaceList(node.parameters);
                this.appendToken(node.closeBracketToken);
                this.appendNode(node.typeAnnotation);
            };

            PrettyPrinterImpl.prototype.visitPropertySignature = function (node) {
                this.appendToken(node.propertyName);
                this.appendToken(node.questionToken);
                this.appendNode(node.typeAnnotation);
            };

            PrettyPrinterImpl.prototype.visitParameterList = function (node) {
                this.appendToken(node.openParenToken);
                this.appendSeparatorSpaceList(node.parameters);
                this.appendToken(node.closeParenToken);
            };

            PrettyPrinterImpl.prototype.visitCallSignature = function (node) {
                this.appendNode(node.typeParameterList);
                TypeScript.visitNodeOrToken(this, node.parameterList);
                this.appendNode(node.typeAnnotation);
            };

            PrettyPrinterImpl.prototype.visitTypeParameterList = function (node) {
                this.appendToken(node.lessThanToken);
                this.appendSeparatorSpaceList(node.typeParameters);
                this.appendToken(node.greaterThanToken);
            };

            PrettyPrinterImpl.prototype.visitTypeParameter = function (node) {
                this.appendToken(node.identifier);
                this.appendNode(node.constraint);
            };

            PrettyPrinterImpl.prototype.visitConstraint = function (node) {
                this.ensureSpace();
                this.appendToken(node.extendsKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.typeOrExpression);
            };

            PrettyPrinterImpl.prototype.appendBlockOrStatement = function (node) {
                if (node.kind() === 147 /* Block */) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, node);
                } else {
                    this.ensureNewLine();
                    this.indentation++;
                    TypeScript.visitNodeOrToken(this, node);
                    this.indentation--;
                }
            };

            PrettyPrinterImpl.prototype.visitIfStatement = function (node) {
                this.appendToken(node.ifKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                TypeScript.visitNodeOrToken(this, node.condition);
                this.appendToken(node.closeParenToken);
                this.appendBlockOrStatement(node.statement);
                this.appendNode(node.elseClause);
            };

            PrettyPrinterImpl.prototype.visitElseClause = function (node) {
                this.ensureNewLine();
                this.appendToken(node.elseKeyword);

                if (node.statement.kind() === 148 /* IfStatement */) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, node.statement);
                } else {
                    this.appendBlockOrStatement(node.statement);
                }
            };

            PrettyPrinterImpl.prototype.visitExpressionStatement = function (node) {
                TypeScript.visitNodeOrToken(this, node.expression);
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitConstructorDeclaration = function (node) {
                this.appendToken(node.constructorKeyword);
                TypeScript.visitNodeOrToken(this, node.callSignature);
                this.appendBlockOrSemicolon(node.block, node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitIndexMemberDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.indexSignature);
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitMemberFunctionDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.propertyName);
                TypeScript.visitNodeOrToken(this, node.callSignature);
                this.appendBlockOrSemicolon(node.block, node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitGetAccessor = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.getKeyword);
                this.ensureSpace();
                this.appendToken(node.propertyName);
                TypeScript.visitNodeOrToken(this, node.callSignature);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.block);
            };

            PrettyPrinterImpl.prototype.visitSetAccessor = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.setKeyword);
                this.ensureSpace();
                this.appendToken(node.propertyName);
                TypeScript.visitNodeOrToken(this, node.callSignature);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.block);
            };

            PrettyPrinterImpl.prototype.visitMemberVariableDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.variableDeclarator);
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitThrowStatement = function (node) {
                this.appendToken(node.throwKeyword);

                if (node.expression) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, node.expression);
                }

                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitReturnStatement = function (node) {
                this.appendToken(node.returnKeyword);

                if (node.expression) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, node.expression);
                }

                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitObjectCreationExpression = function (node) {
                this.appendToken(node.newKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.expression);
                this.appendNode(node.argumentList);
            };

            PrettyPrinterImpl.prototype.visitSwitchStatement = function (node) {
                this.appendToken(node.switchKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                TypeScript.visitNodeOrToken(this, node.expression);
                this.appendToken(node.closeParenToken);
                this.ensureSpace();
                this.appendToken(node.openBraceToken);
                this.ensureNewLine();

                var lastSwitchClause = null;
                for (var i = 0, n = node.switchClauses.length; i < n; i++) {
                    var switchClause = node.switchClauses[i];

                    var newLineCount = this.newLineCountBetweenSwitchClauses(lastSwitchClause, switchClause);

                    this.appendNewLines(newLineCount);
                    TypeScript.visitNodeOrToken(this, switchClause);

                    lastSwitchClause = switchClause;
                }

                this.ensureNewLine();
                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.appendSwitchClauseStatements = function (node) {
                if (TypeScript.childCount(node.statements) === 1 && TypeScript.childAt(node.statements, 0).kind() === 147 /* Block */) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, TypeScript.childAt(node.statements, 0));
                } else if (TypeScript.childCount(node.statements) > 0) {
                    this.ensureNewLine();

                    this.indentation++;
                    this.appendStatements(node.statements);
                    this.indentation--;
                }
            };

            PrettyPrinterImpl.prototype.visitCaseSwitchClause = function (node) {
                this.appendToken(node.caseKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.expression);
                this.appendToken(node.colonToken);
                this.appendSwitchClauseStatements(node);
            };

            PrettyPrinterImpl.prototype.visitDefaultSwitchClause = function (node) {
                this.appendToken(node.defaultKeyword);
                this.appendToken(node.colonToken);
                this.appendSwitchClauseStatements(node);
            };

            PrettyPrinterImpl.prototype.visitBreakStatement = function (node) {
                this.appendToken(node.breakKeyword);
                if (node.identifier) {
                    this.ensureSpace();
                    this.appendToken(node.identifier);
                }

                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitContinueStatement = function (node) {
                this.appendToken(node.continueKeyword);
                if (node.identifier) {
                    this.ensureSpace();
                    this.appendToken(node.identifier);
                }

                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitForStatement = function (node) {
                this.appendToken(node.forKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                this.appendNode(node.variableDeclaration);
                this.appendElement(node.initializer);
                this.appendToken(node.firstSemicolonToken);

                if (node.condition) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, node.condition);
                }

                this.appendToken(node.secondSemicolonToken);

                if (node.incrementor) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, node.incrementor);
                }

                this.appendToken(node.closeParenToken);
                this.appendBlockOrStatement(node.statement);
            };

            PrettyPrinterImpl.prototype.visitForInStatement = function (node) {
                this.appendToken(node.forKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                this.appendNode(node.variableDeclaration);
                this.appendElement(node.left);
                this.ensureSpace();
                this.appendToken(node.inKeyword);
                this.ensureSpace();
                this.appendElement(node.expression);
                this.appendToken(node.closeParenToken);
                this.appendBlockOrStatement(node.statement);
            };

            PrettyPrinterImpl.prototype.visitWhileStatement = function (node) {
                this.appendToken(node.whileKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                TypeScript.visitNodeOrToken(this, node.condition);
                this.appendToken(node.closeParenToken);
                this.appendBlockOrStatement(node.statement);
            };

            PrettyPrinterImpl.prototype.visitWithStatement = function (node) {
                this.appendToken(node.withKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                TypeScript.visitNodeOrToken(this, node.condition);
                this.appendToken(node.closeParenToken);
                this.appendBlockOrStatement(node.statement);
            };

            PrettyPrinterImpl.prototype.visitEnumDeclaration = function (node) {
                this.appendSpaceList(node.modifiers);
                this.ensureSpace();
                this.appendToken(node.enumKeyword);
                this.ensureSpace();
                this.appendToken(node.identifier);
                this.ensureSpace();
                this.appendToken(node.openBraceToken);
                this.ensureNewLine();

                this.indentation++;
                this.appendSeparatorNewLineList(node.enumElements);
                this.indentation--;

                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.visitEnumElement = function (node) {
                this.appendToken(node.propertyName);
                this.ensureSpace();
                this.appendNode(node.equalsValueClause);
            };

            PrettyPrinterImpl.prototype.visitCastExpression = function (node) {
                this.appendToken(node.lessThanToken);
                TypeScript.visitNodeOrToken(this, node.type);
                this.appendToken(node.greaterThanToken);
                TypeScript.visitNodeOrToken(this, node.expression);
            };

            PrettyPrinterImpl.prototype.visitObjectLiteralExpression = function (node) {
                this.appendToken(node.openBraceToken);

                if (TypeScript.childCount(node.propertyAssignments) === 1) {
                    this.ensureSpace();
                    TypeScript.visitNodeOrToken(this, TypeScript.childAt(node.propertyAssignments, 0));
                    this.ensureSpace();
                } else if (TypeScript.childCount(node.propertyAssignments) > 0) {
                    this.indentation++;
                    this.ensureNewLine();
                    this.appendSeparatorNewLineList(node.propertyAssignments);
                    this.ensureNewLine();
                    this.indentation--;
                }

                this.appendToken(node.closeBraceToken);
            };

            PrettyPrinterImpl.prototype.visitSimplePropertyAssignment = function (node) {
                this.appendToken(node.propertyName);
                this.appendToken(node.colonToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.expression);
            };

            PrettyPrinterImpl.prototype.visitFunctionPropertyAssignment = function (node) {
                this.appendToken(node.propertyName);
                TypeScript.visitNodeOrToken(this, node.callSignature);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.block);
            };

            PrettyPrinterImpl.prototype.visitFunctionExpression = function (node) {
                this.appendToken(node.functionKeyword);

                if (node.identifier) {
                    this.ensureSpace();
                    this.appendToken(node.identifier);
                }

                TypeScript.visitNodeOrToken(this, node.callSignature);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.block);
            };

            PrettyPrinterImpl.prototype.visitEmptyStatement = function (node) {
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitTryStatement = function (node) {
                this.appendToken(node.tryKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.block);
                this.appendNode(node.catchClause);
                this.appendNode(node.finallyClause);
            };

            PrettyPrinterImpl.prototype.visitCatchClause = function (node) {
                this.ensureNewLine();
                this.appendToken(node.catchKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                this.appendToken(node.identifier);
                this.appendToken(node.closeParenToken);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.block);
            };

            PrettyPrinterImpl.prototype.visitFinallyClause = function (node) {
                this.ensureNewLine();
                this.appendToken(node.finallyKeyword);
                this.ensureNewLine();
                TypeScript.visitNodeOrToken(this, node.block);
            };

            PrettyPrinterImpl.prototype.visitLabeledStatement = function (node) {
                this.appendToken(node.identifier);
                this.appendToken(node.colonToken);
                this.appendBlockOrStatement(node.statement);
            };

            PrettyPrinterImpl.prototype.visitDoStatement = function (node) {
                this.appendToken(node.doKeyword);
                this.appendBlockOrStatement(node.statement);
                this.ensureNewLine();
                this.appendToken(node.whileKeyword);
                this.ensureSpace();
                this.appendToken(node.openParenToken);
                TypeScript.visitNodeOrToken(this, node.condition);
                this.appendToken(node.closeParenToken);
                this.appendToken(node.semicolonToken);
            };

            PrettyPrinterImpl.prototype.visitTypeOfExpression = function (node) {
                this.appendToken(node.typeOfKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.expression);
            };

            PrettyPrinterImpl.prototype.visitDeleteExpression = function (node) {
                this.appendToken(node.deleteKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.expression);
            };

            PrettyPrinterImpl.prototype.visitVoidExpression = function (node) {
                this.appendToken(node.voidKeyword);
                this.ensureSpace();
                TypeScript.visitNodeOrToken(this, node.expression);
            };

            PrettyPrinterImpl.prototype.visitDebuggerStatement = function (node) {
                this.appendToken(node.debuggerKeyword);
                this.appendToken(node.semicolonToken);
            };
            return PrettyPrinterImpl;
        })();
    })(TypeScript.PrettyPrinter || (TypeScript.PrettyPrinter = {}));
    var PrettyPrinter = TypeScript.PrettyPrinter;
})(TypeScript || (TypeScript = {}));
var negative262ExpectedResults = {
    'Sbp_12.5_A9_T3.js': false,
    'Sbp_12.6.1_A13_T3.js': false,
    'Sbp_12.6.2_A13_T3.js': false,
    'Sbp_12.6.4_A13_T3.js': false,
    'Sbp_7.8.4_A6.1_T4.js': false,
    'Sbp_7.8.4_A6.2_T1.js': false,
    'Sbp_7.8.4_A6.2_T2.js': false,
    'Sbp_A1_T1.js': true,
    'Sbp_A2_T1.js': true,
    'Sbp_A2_T2.js': true,
    'Sbp_A3_T1.js': true,
    'Sbp_A3_T2.js': true,
    'Sbp_A4_T1.js': true,
    'Sbp_A4_T2.js': true,
    'Sbp_A5_T1.js': true,
    'Sbp_A5_T2.js': true,
    'S7.2_A5_T1.js': false,
    'S7.2_A5_T2.js': false,
    'S7.2_A5_T3.js': false,
    'S7.2_A5_T4.js': false,
    'S7.2_A5_T5.js': false,
    'S7.3_A2.1_T1.js': true,
    'S7.3_A2.1_T2.js': false,
    'S7.3_A2.2_T1.js': true,
    'S7.3_A2.2_T2.js': false,
    'S7.3_A2.3.js': true,
    'S7.3_A2.4.js': true,
    'S7.3_A3.1_T1.js': true,
    'S7.3_A3.1_T2.js': true,
    'S7.3_A3.1_T3.js': false,
    'S7.3_A3.2_T1.js': true,
    'S7.3_A3.2_T2.js': true,
    'S7.3_A3.2_T3.js': false,
    'S7.3_A3.3_T1.js': true,
    'S7.3_A3.3_T2.js': true,
    'S7.3_A3.4_T1.js': true,
    'S7.3_A3.4_T2.js': true,
    'S7.3_A6_T1.js': false,
    'S7.3_A6_T2.js': false,
    'S7.3_A6_T3.js': false,
    'S7.3_A6_T4.js': false,
    'S7.4_A2_T2.js': false,
    'S7.4_A3.js': false,
    'S7.4_A4_T1.js': false,
    'S7.4_A4_T4.js': false,
    'S7.6.1.1_A1.1.js': false,
    'S7.6.1.1_A1.10.js': false,
    'S7.6.1.1_A1.11.js': false,
    'S7.6.1.1_A1.12.js': false,
    'S7.6.1.1_A1.13.js': false,
    'S7.6.1.1_A1.14.js': false,
    'S7.6.1.1_A1.15.js': false,
    'S7.6.1.1_A1.16.js': false,
    'S7.6.1.1_A1.17.js': false,
    'S7.6.1.1_A1.18.js': true,
    'S7.6.1.1_A1.19.js': false,
    'S7.6.1.1_A1.2.js': false,
    'S7.6.1.1_A1.20.js': false,
    'S7.6.1.1_A1.21.js': false,
    'S7.6.1.1_A1.22.js': false,
    'S7.6.1.1_A1.23.js': false,
    'S7.6.1.1_A1.24.js': false,
    'S7.6.1.1_A1.25.js': false,
    'S7.6.1.1_A1.3.js': false,
    'S7.6.1.1_A1.4.js': false,
    'S7.6.1.1_A1.5.js': false,
    'S7.6.1.1_A1.6.js': false,
    'S7.6.1.1_A1.7.js': false,
    'S7.6.1.1_A1.8.js': false,
    'S7.6.1.1_A1.9.js': false,
    'S7.6.1.2_A1.10.js': false,
    'S7.6.1.2_A1.11.js': false,
    'S7.6.1.2_A1.15.js': false,
    'S7.6.1.2_A1.16.js': false,
    'S7.6.1.2_A1.18.js': false,
    'S7.6.1.2_A1.21.js': false,
    'S7.6.1.2_A1.22.js': false,
    'S7.6.1.2_A1.23.js': false,
    'S7.6.1.2_A1.24.js': false,
    'S7.6.1.2_A1.26.js': false,
    'S7.6.1.2_A1.27.js': false,
    'S7.6.1.2_A1.5.js': false,
    'S7.6.1.2_A1.6.js': false,
    'S7.6.1.2_A1.7.js': false,
    'S7.6.1.2_A1.9.js': false,
    '7.6.1.2-1gs.js': false,
    'S7.6.1_A1.1.js': true,
    'S7.6.1_A1.2.js': true,
    'S7.6.1_A1.3.js': true,
    'S7.7_A2_T1.js': false,
    'S7.7_A2_T10.js': false,
    'S7.7_A2_T2.js': false,
    'S7.7_A2_T3.js': false,
    'S7.7_A2_T4.js': false,
    'S7.7_A2_T5.js': false,
    'S7.7_A2_T6.js': false,
    'S7.7_A2_T7.js': false,
    'S7.7_A2_T8.js': false,
    'S7.7_A2_T9.js': false,
    '7.8.3-1gs.js': true,
    '7.8.3-2gs.js': true,
    '7.8.3-3gs.js': true,
    'S7.8.3_A4.1_T1.js': true,
    'S7.8.3_A4.1_T2.js': true,
    'S7.8.3_A4.1_T3.js': true,
    'S7.8.3_A4.1_T4.js': true,
    'S7.8.3_A4.1_T5.js': true,
    'S7.8.3_A4.1_T6.js': true,
    'S7.8.3_A4.1_T7.js': true,
    'S7.8.3_A4.1_T8.js': true,
    'S7.8.3_A6.1_T1.js': false,
    'S7.8.3_A6.1_T2.js': false,
    'S7.8.3_A6.2_T1.js': false,
    'S7.8.3_A6.2_T2.js': false,
    '7.8.4-1gs.js': true,
    'S7.8.4_A1.1_T1.js': false,
    'S7.8.4_A1.1_T2.js': false,
    'S7.8.4_A1.2_T1.js': false,
    'S7.8.4_A1.2_T2.js': false,
    'S7.8.4_A3.1_T1.js': false,
    'S7.8.4_A3.1_T2.js': false,
    'S7.8.4_A3.2_T1.js': false,
    'S7.8.4_A3.2_T2.js': false,
    'S7.8.4_A4.3_T1.js': true,
    'S7.8.4_A4.3_T2.js': true,
    'S7.8.4_A7.1_T4.js': false,
    'S7.8.4_A7.2_T1.js': false,
    'S7.8.4_A7.2_T2.js': false,
    'S7.8.4_A7.2_T3.js': false,
    'S7.8.4_A7.2_T4.js': false,
    'S7.8.4_A7.2_T5.js': false,
    'S7.8.4_A7.2_T6.js': false,
    '7.8.5-1gs.js': false,
    'S7.8.5_A1.2_T1.js': false,
    'S7.8.5_A1.2_T2.js': false,
    'S7.8.5_A1.2_T3.js': false,
    'S7.8.5_A1.2_T4.js': false,
    'S7.8.5_A1.3_T1.js': false,
    'S7.8.5_A1.3_T3.js': false,
    'S7.8.5_A1.5_T1.js': false,
    'S7.8.5_A1.5_T3.js': false,
    'S7.8.5_A2.2_T1.js': false,
    'S7.8.5_A2.2_T2.js': false,
    'S7.8.5_A2.3_T1.js': false,
    'S7.8.5_A2.3_T3.js': false,
    'S7.8.5_A2.5_T1.js': false,
    'S7.8.5_A2.5_T3.js': false,
    'S7.9.2_A1_T1.js': false,
    'S7.9.2_A1_T3.js': false,
    'S7.9.2_A1_T6.js': false,
    'S7.9_A10_T2.js': false,
    'S7.9_A10_T4.js': false,
    'S7.9_A10_T6.js': false,
    'S7.9_A10_T8.js': false,
    'S7.9_A11_T4.js': false,
    'S7.9_A11_T8.js': false,
    'S7.9_A4.js': false,
    'S7.9_A5.1_T1.js': false,
    'S7.9_A5.3_T1.js': false,
    'S7.9_A5.7_T1.js': true,
    'S7.9_A6.2_T1.js': false,
    'S7.9_A6.2_T10.js': false,
    'S7.9_A6.2_T2.js': false,
    'S7.9_A6.2_T3.js': false,
    'S7.9_A6.2_T4.js': false,
    'S7.9_A6.2_T5.js': false,
    'S7.9_A6.2_T6.js': false,
    'S7.9_A6.2_T7.js': false,
    'S7.9_A6.2_T8.js': false,
    'S7.9_A6.2_T9.js': false,
    'S7.9_A6.3_T1.js': false,
    'S7.9_A6.3_T2.js': false,
    'S7.9_A6.3_T3.js': false,
    'S7.9_A6.3_T4.js': false,
    'S7.9_A6.3_T5.js': false,
    'S7.9_A6.3_T6.js': false,
    'S7.9_A6.3_T7.js': false,
    'S7.9_A6.4_T1.js': false,
    'S7.9_A6.4_T2.js': false,
    'S7.9_A7_T7.js': true,
    'S7.9_A9_T6.js': false,
    'S7.9_A9_T7.js': false,
    'S7.9_A9_T8.js': false,
    'S8.2_A2.js': false,
    'S8.3_A2.1.js': true,
    'S8.3_A2.2.js': true,
    'S8.4_A13_T1.js': false,
    'S8.4_A13_T2.js': false,
    'S8.4_A13_T3.js': false,
    'S8.4_A14_T1.js': false,
    'S8.4_A14_T2.js': false,
    'S8.4_A14_T3.js': false,
    'S8.4_A7.1.js': true,
    'S8.4_A7.2.js': true,
    'S8.4_A7.3.js': true,
    'S8.4_A7.4.js': true,
    'S8.6.2_A7.js': true,
    '8.7.2-3-a-1gs.js': true,
    '8.7.2-3-a-2gs.js': true,
    'S8.7.2_A1_T1.js': true,
    'S8.7.2_A1_T2.js': true,
    '10.1.1-2gs.js': false,
    '10.1.1-5gs.js': false,
    '10.1.1-8gs.js': false,
    '10.4.2.1-1gs.js': true,
    '10.5-1gs.js': true,
    '10.6-2gs.js': true,
    'S11.1.1_A1.js': true,
    '11.1.5-1gs.js': true,
    '11.1.5-2gs.js': true,
    '11.13.1-4-28gs.js': true,
    '11.13.1-4-29gs.js': true,
    'S11.13.1_A2.1_T3.js': true,
    '11.13.2-6-1gs.js': true,
    'S11.13.2_A2.2_T1.js': true,
    'S11.13.2_A2.2_T10.js': true,
    'S11.13.2_A2.2_T11.js': true,
    'S11.13.2_A2.2_T2.js': true,
    'S11.13.2_A2.2_T3.js': true,
    'S11.13.2_A2.2_T4.js': true,
    'S11.13.2_A2.2_T5.js': true,
    'S11.13.2_A2.2_T6.js': true,
    'S11.13.2_A2.2_T7.js': true,
    'S11.13.2_A2.2_T8.js': true,
    'S11.13.2_A2.2_T9.js': true,
    'S11.2.4_A1.3_T1.js': false,
    '11.3.1-2-1gs.js': true,
    'S11.3.1_A1.1_T1.js': true,
    'S11.3.1_A1.1_T2.js': true,
    'S11.3.1_A1.1_T3.js': true,
    'S11.3.1_A1.1_T4.js': true,
    'S11.3.1_A2.1_T3.js': true,
    'S11.3.2_A1.1_T1.js': true,
    'S11.3.2_A1.1_T2.js': true,
    'S11.3.2_A1.1_T3.js': true,
    'S11.3.2_A1.1_T4.js': true,
    'S11.3.2_A2.1_T3.js': true,
    '11.4.1-5-a-5gs.js': true,
    'S11.4.2_A2_T2.js': true,
    'S11.4.4_A2.1_T3.js': true,
    '11.4.5-2-2gs.js': true,
    'S11.4.5_A2.1_T3.js': true,
    'S12.1_A4_T1.js': false,
    'S12.1_A4_T2.js': false,
    '12.10.1-11gs.js': true,
    'S12.11_A2_T1.js': true,
    'S12.11_A3_T1.js': false,
    'S12.11_A3_T2.js': false,
    'S12.11_A3_T3.js': false,
    'S12.11_A3_T4.js': false,
    'S12.11_A3_T5.js': false,
    'S12.13_A1.js': true,
    '12.14.1-1gs.js': true,
    'S12.14_A16_T1.js': false,
    'S12.14_A16_T10.js': false,
    'S12.14_A16_T11.js': false,
    'S12.14_A16_T12.js': false,
    'S12.14_A16_T13.js': false,
    'S12.14_A16_T14.js': false,
    'S12.14_A16_T15.js': false,
    'S12.14_A16_T2.js': false,
    'S12.14_A16_T3.js': false,
    'S12.14_A16_T4.js': false,
    'S12.14_A16_T5.js': false,
    'S12.14_A16_T6.js': false,
    'S12.14_A16_T7.js': false,
    'S12.14_A16_T8.js': false,
    'S12.14_A16_T9.js': false,
    '12.2.1-1gs.js': true,
    '12.2.1-4gs.js': true,
    'S12.2_A8_T1.js': false,
    'S12.2_A8_T2.js': false,
    'S12.2_A8_T3.js': false,
    'S12.2_A8_T4.js': false,
    'S12.2_A8_T5.js': false,
    'S12.2_A8_T6.js': false,
    'S12.2_A8_T7.js': false,
    'S12.2_A8_T8.js': false,
    'S12.4_A1.js': false,
    'S12.5_A11.js': false,
    'S12.5_A2.js': true,
    'S12.5_A6_T1.js': false,
    'S12.5_A6_T2.js': false,
    'S12.5_A8.js': false,
    'S12.6.1_A12.js': false,
    'S12.6.1_A15.js': false,
    'S12.6.1_A6_T1.js': false,
    'S12.6.1_A6_T2.js': false,
    'S12.6.1_A6_T3.js': false,
    'S12.6.1_A6_T4.js': false,
    'S12.6.1_A6_T5.js': false,
    'S12.6.1_A6_T6.js': false,
    'S12.6.2_A15.js': false,
    'S12.6.2_A6_T1.js': false,
    'S12.6.2_A6_T2.js': false,
    'S12.6.2_A6_T3.js': false,
    'S12.6.2_A6_T4.js': false,
    'S12.6.2_A6_T5.js': false,
    'S12.6.2_A6_T6.js': false,
    'S12.6.3_A11.1_T3.js': true,
    'S12.6.3_A11_T3.js': true,
    'S12.6.3_A12.1_T3.js': true,
    'S12.6.3_A12_T3.js': true,
    'S12.6.3_A4.1.js': false,
    'S12.6.3_A4_T1.js': false,
    'S12.6.3_A4_T2.js': false,
    'S12.6.3_A7.1_T1.js': false,
    'S12.6.3_A7.1_T2.js': false,
    'S12.6.3_A7_T1.js': false,
    'S12.6.3_A7_T2.js': false,
    'S12.6.3_A8.1_T1.js': false,
    'S12.6.3_A8.1_T2.js': false,
    'S12.6.3_A8.1_T3.js': false,
    'S12.6.3_A8_T1.js': false,
    'S12.6.3_A8_T2.js': false,
    'S12.6.3_A8_T3.js': false,
    'S12.6.4_A15.js': false,
    'S12.7_A1_T1.js': true,
    'S12.7_A1_T2.js': true,
    'S12.7_A1_T3.js': true,
    'S12.7_A1_T4.js': true,
    'S12.7_A5_T1.js': true,
    'S12.7_A5_T2.js': true,
    'S12.7_A5_T3.js': true,
    'S12.7_A6.js': true,
    'S12.7_A8_T1.js': true,
    'S12.7_A8_T2.js': true,
    'S12.8_A1_T1.js': true,
    'S12.8_A1_T2.js': true,
    'S12.8_A1_T3.js': true,
    'S12.8_A1_T4.js': true,
    'S12.8_A5_T1.js': true,
    'S12.8_A5_T2.js': true,
    'S12.8_A5_T3.js': true,
    'S12.8_A6.js': true,
    'S12.8_A8_T1.js': true,
    'S12.8_A8_T2.js': true,
    'S12.9_A1_T1.js': true,
    'S12.9_A1_T10.js': true,
    'S12.9_A1_T2.js': true,
    'S12.9_A1_T3.js': true,
    'S12.9_A1_T4.js': true,
    'S12.9_A1_T5.js': true,
    'S12.9_A1_T6.js': true,
    'S12.9_A1_T7.js': true,
    'S12.9_A1_T8.js': true,
    'S12.9_A1_T9.js': true,
    '13.0_4-17gs.js': true,
    '13.0_4-5gs.js': true,
    'S13_A7_T3.js': false,
    '13.1-13gs.js': true,
    '13.1-1gs.js': true,
    '13.1-4gs.js': true,
    '13.1-5gs.js': true,
    '13.1-8gs.js': true,
    '13.2-19-b-3gs.js': true,
    '14.1-4gs.js': true,
    '14.1-5gs.js': true,
    'S15.1.2.1_A2_T2.js': true,
    'S15.1_A1_T1.js': true,
    'S15.1_A1_T2.js': true,
    'S15.1_A2_T1.js': true,
    'S15.2.4.3_A12.js': true,
    'S15.2.4.3_A13.js': true,
    'S15.2.4.4_A12.js': true,
    'S15.2.4.4_A13.js': true,
    'S15.2.4.4_A14.js': true,
    'S15.2.4.4_A15.js': true,
    'S15.2.4.5_A12.js': true,
    'S15.2.4.5_A13.js': true,
    'S15.2.4.6_A12.js': true,
    'S15.2.4.6_A13.js': true,
    'S15.2.4.7_A12.js': true,
    'S15.2.4.7_A13.js': true,
    '15.3.2.1-10-4gs.js': true,
    '15.3.2.1-10-6gs.js': true,
    'S15.3.4.2_A12.js': true,
    'S15.3.4.2_A13.js': true,
    'S15.3.4.2_A14.js': true,
    'S15.3.4.2_A15.js': true,
    'S15.3.4.2_A16.js': true,
    'S15.3.4.3_A13.js': true,
    'S15.3.4.3_A14.js': true,
    'S15.3.4.3_A15.js': true,
    'S15.3.4.4_A13.js': true,
    'S15.3.4.4_A14.js': true,
    'S15.3.4.4_A15.js': true,
    'S15.3.4.5_A1.js': true,
    'S15.3.4.5_A13.js': true,
    'S15.3.4.5_A14.js': true,
    'S15.3.4.5_A15.js': true,
    'S15.3.4.5_A2.js': true,
    '15.3.5.4_2-10gs.js': true,
    '15.3.5.4_2-11gs.js': true,
    '15.3.5.4_2-13gs.js': true,
    '15.3.5.4_2-15gs.js': true,
    '15.3.5.4_2-16gs.js': true,
    '15.3.5.4_2-17gs.js': true,
    '15.3.5.4_2-18gs.js': true,
    '15.3.5.4_2-19gs.js': true,
    '15.3.5.4_2-1gs.js': true,
    '15.3.5.4_2-20gs.js': true,
    '15.3.5.4_2-21gs.js': true,
    '15.3.5.4_2-22gs.js': true,
    '15.3.5.4_2-23gs.js': true,
    '15.3.5.4_2-24gs.js': true,
    '15.3.5.4_2-25gs.js': true,
    '15.3.5.4_2-26gs.js': true,
    '15.3.5.4_2-27gs.js': true,
    '15.3.5.4_2-28gs.js': true,
    '15.3.5.4_2-29gs.js': true,
    '15.3.5.4_2-2gs.js': true,
    '15.3.5.4_2-30gs.js': true,
    '15.3.5.4_2-31gs.js': true,
    '15.3.5.4_2-32gs.js': true,
    '15.3.5.4_2-33gs.js': true,
    '15.3.5.4_2-34gs.js': true,
    '15.3.5.4_2-35gs.js': true,
    '15.3.5.4_2-36gs.js': true,
    '15.3.5.4_2-37gs.js': true,
    '15.3.5.4_2-38gs.js': true,
    '15.3.5.4_2-39gs.js': true,
    '15.3.5.4_2-3gs.js': true,
    '15.3.5.4_2-40gs.js': true,
    '15.3.5.4_2-41gs.js': true,
    '15.3.5.4_2-42gs.js': true,
    '15.3.5.4_2-43gs.js': true,
    '15.3.5.4_2-44gs.js': true,
    '15.3.5.4_2-45gs.js': true,
    '15.3.5.4_2-46gs.js': true,
    '15.3.5.4_2-47gs.js': true,
    '15.3.5.4_2-48gs.js': true,
    '15.3.5.4_2-49gs.js': true,
    '15.3.5.4_2-4gs.js': true,
    '15.3.5.4_2-50gs.js': true,
    '15.3.5.4_2-51gs.js': true,
    '15.3.5.4_2-52gs.js': true,
    '15.3.5.4_2-53gs.js': true,
    '15.3.5.4_2-54gs.js': true,
    '15.3.5.4_2-55gs.js': true,
    '15.3.5.4_2-56gs.js': true,
    '15.3.5.4_2-57gs.js': true,
    '15.3.5.4_2-58gs.js': true,
    '15.3.5.4_2-59gs.js': true,
    '15.3.5.4_2-5gs.js': true,
    '15.3.5.4_2-60gs.js': true,
    '15.3.5.4_2-61gs.js': true,
    '15.3.5.4_2-62gs.js': true,
    '15.3.5.4_2-63gs.js': true,
    '15.3.5.4_2-64gs.js': true,
    '15.3.5.4_2-65gs.js': true,
    '15.3.5.4_2-66gs.js': true,
    '15.3.5.4_2-67gs.js': true,
    '15.3.5.4_2-68gs.js': true,
    '15.3.5.4_2-69gs.js': true,
    '15.3.5.4_2-6gs.js': true,
    '15.3.5.4_2-70gs.js': true,
    '15.3.5.4_2-71gs.js': true,
    '15.3.5.4_2-72gs.js': true,
    '15.3.5.4_2-73gs.js': true,
    '15.3.5.4_2-74gs.js': true,
    '15.3.5.4_2-7gs.js': true,
    '15.3.5.4_2-8gs.js': true,
    '15.3.5.4_2-94gs.js': true,
    '15.3.5.4_2-95gs.js': true,
    '15.3.5.4_2-96gs.js': true,
    '15.3.5.4_2-97gs.js': true,
    '15.3.5.4_2-9gs.js': true,
    '15.3.5-1gs.js': true,
    '15.3.5-2gs.js': true
};
var TypeScript;
(function (TypeScript) {
    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.information = function () {
            return false;
        };
        NullLogger.prototype.debug = function () {
            return false;
        };
        NullLogger.prototype.warning = function () {
            return false;
        };
        NullLogger.prototype.error = function () {
            return false;
        };
        NullLogger.prototype.fatal = function () {
            return false;
        };
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;

    function timeFunction(logger, funcDescription, func) {
        var start = (new Date()).getTime();
        var result = func();
        var end = (new Date()).getTime();
        if (logger.information()) {
            logger.log(funcDescription + " completed in " + (end - start) + " msec");
        }
        return result;
    }
    TypeScript.timeFunction = timeFunction;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Document = (function () {
        function Document(compilationSettings, fileName, referencedFiles, _scriptSnapshot, byteOrderMark, version, isOpen, _syntaxTree, _topLevelDecl) {
            this.compilationSettings = compilationSettings;
            this.fileName = fileName;
            this.referencedFiles = referencedFiles;
            this._scriptSnapshot = _scriptSnapshot;
            this.byteOrderMark = byteOrderMark;
            this.version = version;
            this.isOpen = isOpen;
            this._syntaxTree = _syntaxTree;
            this._topLevelDecl = _topLevelDecl;
            this._bloomFilter = null;
            this._declASTMap = [];
            this._astDeclMap = [];
        }
        Document.prototype.isDeclareFile = function () {
            return TypeScript.isDTSFile(this.fileName);
        };

        Document.prototype.sourceUnit = function () {
            return this.syntaxTree().sourceUnit();
        };

        Document.prototype.diagnostics = function () {
            return this.syntaxTree().diagnostics();
        };

        Document.prototype.lineMap = function () {
            return this.syntaxTree().lineMap();
        };

        Document.prototype.syntaxTree = function () {
            if (!this._syntaxTree) {
                var start = new Date().getTime();

                this._syntaxTree = TypeScript.Parser.parse(this.fileName, TypeScript.SimpleText.fromScriptSnapshot(this._scriptSnapshot), this.compilationSettings.codeGenTarget(), this.isDeclareFile());

                var time = new Date().getTime() - start;

                TypeScript.syntaxTreeParseTime += time;
            }

            return this._syntaxTree;
        };

        Document.prototype.bloomFilter = function () {
            if (!this._bloomFilter) {
                var identifiers = TypeScript.createIntrinsicsObject();
                var pre = function (cur) {
                    if (TypeScript.ASTHelpers.isValidAstNode(cur)) {
                        if (cur.kind() === 11 /* IdentifierName */) {
                            var nodeText = TypeScript.tokenValueText(cur);

                            identifiers[nodeText] = true;
                        }
                    }
                };

                TypeScript.getAstWalkerFactory().simpleWalk(this.sourceUnit(), pre, null, identifiers);

                var identifierCount = 0;
                for (var name in identifiers) {
                    if (identifiers[name]) {
                        identifierCount++;
                    }
                }

                this._bloomFilter = new TypeScript.BloomFilter(identifierCount);
                this._bloomFilter.addKeys(identifiers);
            }
            return this._bloomFilter;
        };

        Document.prototype.emitToOwnOutputFile = function () {
            return !this.compilationSettings.outFileOption() || this.syntaxTree().isExternalModule();
        };

        Document.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange) {
            var oldSyntaxTree = this._syntaxTree;

            if (textChangeRange !== null && TypeScript.Debug.shouldAssert(1 /* Normal */)) {
                var oldText = this._scriptSnapshot;
                var newText = scriptSnapshot;

                TypeScript.Debug.assert((oldText.getLength() - textChangeRange.span().length() + textChangeRange.newLength()) === newText.getLength());

                if (TypeScript.Debug.shouldAssert(3 /* VeryAggressive */)) {
                    var oldTextPrefix = oldText.getText(0, textChangeRange.span().start());
                    var newTextPrefix = newText.getText(0, textChangeRange.span().start());
                    TypeScript.Debug.assert(oldTextPrefix === newTextPrefix);

                    var oldTextSuffix = oldText.getText(textChangeRange.span().end(), oldText.getLength());
                    var newTextSuffix = newText.getText(textChangeRange.newSpan().end(), newText.getLength());
                    TypeScript.Debug.assert(oldTextSuffix === newTextSuffix);
                }
            }

            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);

            var newSyntaxTree = textChangeRange === null || oldSyntaxTree === null || Document.incrementalParse === null ? TypeScript.Parser.parse(this.fileName, text, this.compilationSettings.codeGenTarget(), TypeScript.isDTSFile(this.fileName)) : Document.incrementalParse(oldSyntaxTree, textChangeRange, text);

            return new Document(this.compilationSettings, this.fileName, this.referencedFiles, scriptSnapshot, this.byteOrderMark, version, isOpen, newSyntaxTree, null);
        };

        Document.create = function (compilationSettings, fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            return new Document(compilationSettings, fileName, referencedFiles, scriptSnapshot, byteOrderMark, version, isOpen, null, null);
        };

        Document.prototype.topLevelDecl = function () {
            if (this._topLevelDecl === null) {
                this._topLevelDecl = TypeScript.DeclarationCreator.create(this, this.compilationSettings);
            }

            return this._topLevelDecl;
        };

        Document.prototype._getDeclForAST = function (ast) {
            this.topLevelDecl();
            return this._astDeclMap[TypeScript.syntaxID(ast)];
        };

        Document.prototype.getEnclosingDecl = function (ast) {
            if (ast.kind() === 120 /* SourceUnit */) {
                return this._getDeclForAST(ast);
            }

            ast = ast.parent;
            var decl = null;
            while (ast) {
                decl = this._getDeclForAST(ast);

                if (decl) {
                    break;
                }

                ast = ast.parent;
            }

            return decl._getEnclosingDeclFromParentDecl();
        };

        Document.prototype._setDeclForAST = function (ast, decl) {
            TypeScript.Debug.assert(decl.fileName() === this.fileName);
            this._astDeclMap[TypeScript.syntaxID(ast)] = decl;
        };

        Document.prototype._getASTForDecl = function (decl) {
            return this._declASTMap[decl.declID];
        };

        Document.prototype._setASTForDecl = function (decl, ast) {
            TypeScript.Debug.assert(decl.fileName() === this.fileName);
            this._declASTMap[decl.declID] = ast;
        };
        Document.incrementalParse = null;
        return Document;
    })();
    TypeScript.Document = Document;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function hasFlag(val, flag) {
        return (val & flag) !== 0;
    }
    TypeScript.hasFlag = hasFlag;

    (function (ModuleGenTarget) {
        ModuleGenTarget[ModuleGenTarget["Unspecified"] = 0] = "Unspecified";
        ModuleGenTarget[ModuleGenTarget["Synchronous"] = 1] = "Synchronous";
        ModuleGenTarget[ModuleGenTarget["Asynchronous"] = 2] = "Asynchronous";
    })(TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));
    var ModuleGenTarget = TypeScript.ModuleGenTarget;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var proto = "__proto__";

    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            this["constructor"] = undefined;

            this[proto] = null;
            this[proto] = undefined;
        }
        return BlockIntrinsics;
    })();

    function createIntrinsicsObject() {
        return new BlockIntrinsics();
    }
    TypeScript.createIntrinsicsObject = createIntrinsicsObject;

    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0;
            this.table = createIntrinsicsObject();
        }
        StringHashTable.prototype.getAllKeys = function () {
            var result = [];

            for (var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }

            return result;
        };

        StringHashTable.prototype.add = function (key, data) {
            if (this.table[key] !== undefined) {
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.map = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        };

        StringHashTable.prototype.every = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }

            return true;
        };

        StringHashTable.prototype.some = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }

            return false;
        };

        StringHashTable.prototype.count = function () {
            return this.itemCount;
        };

        StringHashTable.prototype.lookup = function (key) {
            var data = this.table[key];
            return data === undefined ? null : data;
        };

        StringHashTable.prototype.remove = function (key) {
            if (this.table[key] !== undefined) {
                this.table[key] = undefined;
                this.itemCount--;
            }
        };
        return StringHashTable;
    })();
    TypeScript.StringHashTable = StringHashTable;

    var IdentiferNameHashTable = (function (_super) {
        __extends(IdentiferNameHashTable, _super);
        function IdentiferNameHashTable() {
            _super.apply(this, arguments);
        }
        IdentiferNameHashTable.prototype.getAllKeys = function () {
            var result = [];

            _super.prototype.map.call(this, function (k, v, c) {
                if (v !== undefined) {
                    result.push(k.substring(1));
                }
            }, null);

            return result;
        };

        IdentiferNameHashTable.prototype.add = function (key, data) {
            return _super.prototype.add.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.addOrUpdate = function (key, data) {
            return _super.prototype.addOrUpdate.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.map = function (fn, context) {
            return _super.prototype.map.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.every = function (fn, context) {
            return _super.prototype.every.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.some = function (fn, context) {
            return _super.prototype.some.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.lookup = function (key) {
            return _super.prototype.lookup.call(this, "#" + key);
        };
        return IdentiferNameHashTable;
    })(StringHashTable);
    TypeScript.IdentiferNameHashTable = IdentiferNameHashTable;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Comment = (function () {
        function Comment(_trivia, endsLine, _start, _end) {
            this._trivia = _trivia;
            this.endsLine = endsLine;
            this._start = _start;
            this._end = _end;
        }
        Comment.prototype.start = function () {
            return this._start;
        };

        Comment.prototype.end = function () {
            return this._end;
        };

        Comment.prototype.fullText = function () {
            return this._trivia.fullText();
        };

        Comment.prototype.kind = function () {
            return this._trivia.kind();
        };

        Comment.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.start() !== ast.start() || this.end() !== ast.end()) {
                    return false;
                }
            }

            return this._trivia.fullText() === ast._trivia.fullText() && this.endsLine === ast.endsLine;
        };
        return Comment;
    })();
    TypeScript.Comment = Comment;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (ASTHelpers) {
        function scriptIsElided(sourceUnit) {
            return TypeScript.isDTSFile(sourceUnit.syntaxTree.fileName()) || moduleMembersAreElided(sourceUnit.moduleElements);
        }
        ASTHelpers.scriptIsElided = scriptIsElided;

        function moduleIsElided(declaration) {
            return TypeScript.hasModifier(declaration.modifiers, 8 /* Ambient */) || moduleMembersAreElided(declaration.moduleElements);
        }
        ASTHelpers.moduleIsElided = moduleIsElided;

        function moduleMembersAreElided(members) {
            for (var i = 0, n = members.length; i < n; i++) {
                var member = members[i];

                if (member.kind() === 131 /* ModuleDeclaration */) {
                    if (!moduleIsElided(member)) {
                        return false;
                    }
                } else if (member.kind() !== 129 /* InterfaceDeclaration */) {
                    return false;
                }
            }

            return true;
        }

        function enumIsElided(declaration) {
            if (TypeScript.hasModifier(declaration.modifiers, 8 /* Ambient */)) {
                return true;
            }

            return false;
        }
        ASTHelpers.enumIsElided = enumIsElided;

        function isValidAstNode(ast) {
            return ast && !TypeScript.isShared(ast) && TypeScript.start(ast) !== -1 && TypeScript.end(ast) !== -1;
        }
        ASTHelpers.isValidAstNode = isValidAstNode;

        function isValidSpan(ast) {
            if (!ast)
                return false;

            if (ast.start() === -1 || ast.end() === -1)
                return false;

            return true;
        }
        ASTHelpers.isValidSpan = isValidSpan;

        function getAstAtPosition(script, pos, useTrailingTriviaAsLimChar, forceInclusive) {
            if (typeof useTrailingTriviaAsLimChar === "undefined") { useTrailingTriviaAsLimChar = true; }
            if (typeof forceInclusive === "undefined") { forceInclusive = false; }
            var top = null;

            var pre = function (cur, walker) {
                if (!TypeScript.isShared(cur) && isValidAstNode(cur)) {
                    var isInvalid1 = cur.kind() === 150 /* ExpressionStatement */ && TypeScript.width(cur) === 0;

                    if (isInvalid1) {
                        walker.options.goChildren = false;
                    } else {
                        var inclusive = forceInclusive || cur.kind() === 11 /* IdentifierName */ || cur.kind() === 213 /* MemberAccessExpression */ || cur.kind() === 121 /* QualifiedName */ || cur.kind() === 225 /* VariableDeclaration */ || cur.kind() === 226 /* VariableDeclarator */ || cur.kind() === 214 /* InvocationExpression */ || pos === TypeScript.end(script) + TypeScript.lastToken(script).trailingTriviaWidth();

                        var minChar = TypeScript.start(cur);
                        var limChar = TypeScript.end(cur) + (useTrailingTriviaAsLimChar ? TypeScript.trailingTriviaWidth(cur) : 0) + (inclusive ? 1 : 0);
                        if (pos >= minChar && pos < limChar) {
                            if ((cur.kind() !== 1 /* List */ && cur.kind() !== 2 /* SeparatedList */) || TypeScript.end(cur) > TypeScript.start(cur)) {
                                if (top === null) {
                                    top = cur;
                                } else if (TypeScript.start(cur) >= TypeScript.start(top) && (TypeScript.end(cur) + (useTrailingTriviaAsLimChar ? TypeScript.trailingTriviaWidth(cur) : 0)) <= (TypeScript.end(top) + (useTrailingTriviaAsLimChar ? TypeScript.trailingTriviaWidth(top) : 0))) {
                                    if (TypeScript.width(top) !== 0 || TypeScript.width(cur) !== 0) {
                                        top = cur;
                                    }
                                }
                            }
                        }

                        walker.options.goChildren = (minChar <= pos && pos <= limChar);
                    }
                }
            };

            TypeScript.getAstWalkerFactory().walk(script, pre);
            return top;
        }
        ASTHelpers.getAstAtPosition = getAstAtPosition;

        function getExtendsHeritageClause(clauses) {
            return getHeritageClause(clauses, 231 /* ExtendsHeritageClause */);
        }
        ASTHelpers.getExtendsHeritageClause = getExtendsHeritageClause;

        function getImplementsHeritageClause(clauses) {
            return getHeritageClause(clauses, 232 /* ImplementsHeritageClause */);
        }
        ASTHelpers.getImplementsHeritageClause = getImplementsHeritageClause;

        function getHeritageClause(clauses, kind) {
            if (clauses) {
                for (var i = 0, n = clauses.length; i < n; i++) {
                    var child = clauses[i];

                    if (child.typeNames.length > 0 && child.kind() === kind) {
                        return child;
                    }
                }
            }

            return null;
        }

        function isCallExpression(ast) {
            return (ast && ast.kind() === 214 /* InvocationExpression */) || (ast && ast.kind() === 217 /* ObjectCreationExpression */);
        }
        ASTHelpers.isCallExpression = isCallExpression;

        function isCallExpressionTarget(ast) {
            return !!getCallExpressionTarget(ast);
        }
        ASTHelpers.isCallExpressionTarget = isCallExpressionTarget;

        function getCallExpressionTarget(ast) {
            if (!ast) {
                return null;
            }

            var current = ast;

            while (current && current.parent) {
                if (current.parent.kind() === 213 /* MemberAccessExpression */ && current.parent.name === current) {
                    current = current.parent;
                    continue;
                }

                break;
            }

            if (current && current.parent) {
                if (current.parent.kind() === 214 /* InvocationExpression */ || current.parent.kind() === 217 /* ObjectCreationExpression */) {
                    return current === current.parent.expression ? current : null;
                }
            }
            return null;
        }
        ASTHelpers.getCallExpressionTarget = getCallExpressionTarget;

        function isNameOfSomeDeclaration(ast) {
            if (ast === null || ast.parent === null) {
                return false;
            }
            if (ast.kind() !== 11 /* IdentifierName */) {
                return false;
            }

            switch (ast.parent.kind()) {
                case 132 /* ClassDeclaration */:
                    return ast.parent.identifier === ast;
                case 129 /* InterfaceDeclaration */:
                    return ast.parent.identifier === ast;
                case 133 /* EnumDeclaration */:
                    return ast.parent.identifier === ast;
                case 131 /* ModuleDeclaration */:
                    return ast.parent.name === ast || ast.parent.stringLiteral === ast;
                case 226 /* VariableDeclarator */:
                    return ast.parent.propertyName === ast;
                case 130 /* FunctionDeclaration */:
                    return ast.parent.identifier === ast;
                case 136 /* MemberFunctionDeclaration */:
                    return ast.parent.propertyName === ast;
                case 243 /* Parameter */:
                    return ast.parent.identifier === ast;
                case 239 /* TypeParameter */:
                    return ast.parent.identifier === ast;
                case 241 /* SimplePropertyAssignment */:
                    return ast.parent.propertyName === ast;
                case 242 /* FunctionPropertyAssignment */:
                    return ast.parent.propertyName === ast;
                case 244 /* EnumElement */:
                    return ast.parent.propertyName === ast;
                case 134 /* ImportDeclaration */:
                    return ast.parent.identifier === ast;
                case 146 /* MethodSignature */:
                    return ast.parent.propertyName === ast;
                case 142 /* PropertySignature */:
                    return ast.parent.propertyName === ast;
            }

            return false;
        }

        function isDeclarationASTOrDeclarationNameAST(ast) {
            return isNameOfSomeDeclaration(ast) || ASTHelpers.isDeclarationAST(ast);
        }
        ASTHelpers.isDeclarationASTOrDeclarationNameAST = isDeclarationASTOrDeclarationNameAST;

        function getEnclosingParameterForInitializer(ast) {
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case 233 /* EqualsValueClause */:
                        if (current.parent && current.parent.kind() === 243 /* Parameter */) {
                            return current.parent;
                        }
                        break;
                    case 132 /* ClassDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        return null;
                }

                current = current.parent;
            }
            return null;
        }
        ASTHelpers.getEnclosingParameterForInitializer = getEnclosingParameterForInitializer;

        function getEnclosingMemberDeclaration(ast) {
            var current = ast;

            while (current) {
                switch (current.kind()) {
                    case 137 /* MemberVariableDeclaration */:
                    case 146 /* MethodSignature */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                        return current;
                    case 132 /* ClassDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        return null;
                }
                current = current.parent;
            }

            return null;
        }
        ASTHelpers.getEnclosingMemberDeclaration = getEnclosingMemberDeclaration;

        function isNameOfFunction(ast) {
            return ast && ast.parent && ast.kind() === 11 /* IdentifierName */ && ast.parent.kind() === 130 /* FunctionDeclaration */ && ast.parent.identifier === ast;
        }
        ASTHelpers.isNameOfFunction = isNameOfFunction;

        function isNameOfMemberFunction(ast) {
            return ast && ast.parent && ast.kind() === 11 /* IdentifierName */ && ast.parent.kind() === 136 /* MemberFunctionDeclaration */ && ast.parent.propertyName === ast;
        }
        ASTHelpers.isNameOfMemberFunction = isNameOfMemberFunction;

        function isNameOfMemberAccessExpression(ast) {
            if (ast && ast.parent && ast.parent.kind() === 213 /* MemberAccessExpression */ && ast.parent.name === ast) {
                return true;
            }

            return false;
        }
        ASTHelpers.isNameOfMemberAccessExpression = isNameOfMemberAccessExpression;

        function isRightSideOfQualifiedName(ast) {
            if (ast && ast.parent && ast.parent.kind() === 121 /* QualifiedName */ && ast.parent.right === ast) {
                return true;
            }

            return false;
        }
        ASTHelpers.isRightSideOfQualifiedName = isRightSideOfQualifiedName;

        function parentIsModuleDeclaration(ast) {
            return ast.parent && ast.parent.kind() === 131 /* ModuleDeclaration */;
        }
        ASTHelpers.parentIsModuleDeclaration = parentIsModuleDeclaration;

        function isDeclarationAST(ast) {
            switch (ast.kind()) {
                case 226 /* VariableDeclarator */:
                    return getVariableStatement(ast) !== null;

                case 134 /* ImportDeclaration */:
                case 132 /* ClassDeclaration */:
                case 129 /* InterfaceDeclaration */:
                case 243 /* Parameter */:
                case 220 /* SimpleArrowFunctionExpression */:
                case 219 /* ParenthesizedArrowFunctionExpression */:
                case 145 /* IndexSignature */:
                case 130 /* FunctionDeclaration */:
                case 131 /* ModuleDeclaration */:
                case 124 /* ArrayType */:
                case 122 /* ObjectType */:
                case 239 /* TypeParameter */:
                case 138 /* ConstructorDeclaration */:
                case 136 /* MemberFunctionDeclaration */:
                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                case 137 /* MemberVariableDeclaration */:
                case 139 /* IndexMemberDeclaration */:
                case 133 /* EnumDeclaration */:
                case 244 /* EnumElement */:
                case 241 /* SimplePropertyAssignment */:
                case 242 /* FunctionPropertyAssignment */:
                case 223 /* FunctionExpression */:
                case 143 /* CallSignature */:
                case 144 /* ConstructSignature */:
                case 146 /* MethodSignature */:
                case 142 /* PropertySignature */:
                    return true;
                default:
                    return false;
            }
        }
        ASTHelpers.isDeclarationAST = isDeclarationAST;

        function preComments(element, text) {
            if (element) {
                switch (element.kind()) {
                    case 149 /* VariableStatement */:
                    case 150 /* ExpressionStatement */:
                    case 132 /* ClassDeclaration */:
                    case 134 /* ImportDeclaration */:
                    case 130 /* FunctionDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 133 /* EnumDeclaration */:
                    case 148 /* IfStatement */:
                    case 241 /* SimplePropertyAssignment */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                    case 151 /* ReturnStatement */:
                    case 138 /* ConstructorDeclaration */:
                    case 137 /* MemberVariableDeclaration */:
                    case 244 /* EnumElement */:
                    case 143 /* CallSignature */:
                    case 144 /* ConstructSignature */:
                    case 145 /* IndexSignature */:
                    case 142 /* PropertySignature */:
                    case 146 /* MethodSignature */:
                    case 242 /* FunctionPropertyAssignment */:
                    case 243 /* Parameter */:
                        return convertNodeLeadingComments(element, text);
                }
            }

            return null;
        }
        ASTHelpers.preComments = preComments;

        function postComments(element, text) {
            if (element) {
                switch (element.kind()) {
                    case 150 /* ExpressionStatement */:
                        return convertNodeTrailingComments(element, text, true);
                    case 149 /* VariableStatement */:
                    case 132 /* ClassDeclaration */:
                    case 134 /* ImportDeclaration */:
                    case 130 /* FunctionDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 133 /* EnumDeclaration */:
                    case 148 /* IfStatement */:
                    case 241 /* SimplePropertyAssignment */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                    case 151 /* ReturnStatement */:
                    case 138 /* ConstructorDeclaration */:
                    case 137 /* MemberVariableDeclaration */:
                    case 244 /* EnumElement */:
                    case 143 /* CallSignature */:
                    case 144 /* ConstructSignature */:
                    case 145 /* IndexSignature */:
                    case 142 /* PropertySignature */:
                    case 146 /* MethodSignature */:
                    case 242 /* FunctionPropertyAssignment */:
                    case 243 /* Parameter */:
                        return convertNodeTrailingComments(element, text);
                }
            }

            return null;
        }
        ASTHelpers.postComments = postComments;

        function convertNodeTrailingComments(node, text, allowWithNewLine) {
            if (typeof allowWithNewLine === "undefined") { allowWithNewLine = false; }
            var _lastToken = TypeScript.lastToken(node);
            if (_lastToken === null || !_lastToken.hasTrailingTrivia()) {
                return null;
            }

            if (!allowWithNewLine && TypeScript.SyntaxUtilities.isLastTokenOnLine(_lastToken, text)) {
                return null;
            }

            return convertComments(_lastToken.trailingTrivia(text), TypeScript.fullStart(node) + TypeScript.fullWidth(node) - _lastToken.trailingTriviaWidth(text));
        }

        function convertNodeLeadingComments(element, text) {
            if (element) {
                return convertTokenLeadingComments(TypeScript.firstToken(element), text);
            }

            return null;
        }

        function convertTokenLeadingComments(token, text) {
            if (token === null) {
                return null;
            }

            return token.hasLeadingTrivia() ? convertComments(token.leadingTrivia(text), token.fullStart()) : null;
        }
        ASTHelpers.convertTokenLeadingComments = convertTokenLeadingComments;

        function convertTokenTrailingComments(token, text) {
            if (token === null) {
                return null;
            }

            return token.hasTrailingTrivia() ? convertComments(token.trailingTrivia(text), TypeScript.fullEnd(token) - token.trailingTriviaWidth(text)) : null;
        }
        ASTHelpers.convertTokenTrailingComments = convertTokenTrailingComments;

        function convertComments(triviaList, commentStartPosition) {
            var result = null;

            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result = result || [];
                    result.push(convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }

                commentStartPosition += trivia.fullWidth();
            }

            return result;
        }

        function convertComment(trivia, commentStartPosition, hasTrailingNewLine) {
            var comment = new TypeScript.Comment(trivia, hasTrailingNewLine, commentStartPosition, commentStartPosition + trivia.fullWidth());

            return comment;
        }

        function docComments(ast, text) {
            if (isDeclarationAST(ast)) {
                var comments = null;

                if (ast.kind() === 226 /* VariableDeclarator */) {
                    comments = TypeScript.ASTHelpers.preComments(getVariableStatement(ast), text);
                } else if (ast.kind() === 243 /* Parameter */) {
                    comments = TypeScript.ASTHelpers.preComments(ast, text);
                    if (!comments) {
                        var previousToken = TypeScript.findToken(TypeScript.syntaxTree(ast).sourceUnit(), TypeScript.firstToken(ast).fullStart() - 1);
                        if (previousToken && (previousToken.kind() === 72 /* OpenParenToken */ || previousToken.kind() === 79 /* CommaToken */)) {
                            comments = convertTokenTrailingComments(previousToken, text);
                        }
                    }
                } else {
                    comments = TypeScript.ASTHelpers.preComments(ast, text);
                }

                if (comments && comments.length > 0) {
                    return comments.filter(function (c) {
                        return isDocComment(c);
                    });
                }
            }

            return TypeScript.sentinelEmptyArray;
        }
        ASTHelpers.docComments = docComments;

        function isDocComment(comment) {
            if (comment.kind() === 6 /* MultiLineCommentTrivia */) {
                var fullText = comment.fullText();
                return fullText.charAt(2) === "*" && fullText.charAt(3) !== "/";
            }

            return false;
        }
        ASTHelpers.isDocComment = isDocComment;

        function getParameterList(ast) {
            if (ast) {
                switch (ast.kind()) {
                    case 138 /* ConstructorDeclaration */:
                        return getParameterList(ast.callSignature);
                    case 130 /* FunctionDeclaration */:
                        return getParameterList(ast.callSignature);
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                        return getParameterList(ast.callSignature);
                    case 144 /* ConstructSignature */:
                        return getParameterList(ast.callSignature);
                    case 136 /* MemberFunctionDeclaration */:
                        return getParameterList(ast.callSignature);
                    case 242 /* FunctionPropertyAssignment */:
                        return getParameterList(ast.callSignature);
                    case 223 /* FunctionExpression */:
                        return getParameterList(ast.callSignature);
                    case 146 /* MethodSignature */:
                        return getParameterList(ast.callSignature);
                    case 125 /* ConstructorType */:
                        return ast.parameterList;
                    case 123 /* FunctionType */:
                        return ast.parameterList;
                    case 143 /* CallSignature */:
                        return ast.parameterList;
                    case 140 /* GetAccessor */:
                        return getParameterList(ast.callSignature);
                    case 141 /* SetAccessor */:
                        return getParameterList(ast.callSignature);
                }
            }

            return null;
        }
        ASTHelpers.getParameterList = getParameterList;

        function getType(ast) {
            if (ast) {
                switch (ast.kind()) {
                    case 130 /* FunctionDeclaration */:
                        return getType(ast.callSignature);
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                        return getType(ast.callSignature);
                    case 144 /* ConstructSignature */:
                        return getType(ast.callSignature);
                    case 136 /* MemberFunctionDeclaration */:
                        return getType(ast.callSignature);
                    case 242 /* FunctionPropertyAssignment */:
                        return getType(ast.callSignature);
                    case 223 /* FunctionExpression */:
                        return getType(ast.callSignature);
                    case 146 /* MethodSignature */:
                        return getType(ast.callSignature);
                    case 143 /* CallSignature */:
                        return getType(ast.typeAnnotation);
                    case 145 /* IndexSignature */:
                        return getType(ast.typeAnnotation);
                    case 142 /* PropertySignature */:
                        return getType(ast.typeAnnotation);
                    case 140 /* GetAccessor */:
                        return getType(ast.callSignature);
                    case 243 /* Parameter */:
                        return getType(ast.typeAnnotation);
                    case 137 /* MemberVariableDeclaration */:
                        return getType(ast.variableDeclarator);
                    case 226 /* VariableDeclarator */:
                        return getType(ast.typeAnnotation);
                    case 237 /* CatchClause */:
                        return getType(ast.typeAnnotation);
                    case 125 /* ConstructorType */:
                        return ast.type;
                    case 123 /* FunctionType */:
                        return ast.type;
                    case 245 /* TypeAnnotation */:
                        return ast.type;
                }
            }

            return null;
        }
        ASTHelpers.getType = getType;

        function getVariableStatement(variableDeclarator) {
            if (variableDeclarator && variableDeclarator.parent && variableDeclarator.parent.parent && variableDeclarator.parent.parent.parent && variableDeclarator.parent.kind() === 2 /* SeparatedList */ && variableDeclarator.parent.parent.kind() === 225 /* VariableDeclaration */ && variableDeclarator.parent.parent.parent.kind() === 149 /* VariableStatement */) {
                return variableDeclarator.parent.parent.parent;
            }

            return null;
        }

        function getVariableDeclaratorModifiers(variableDeclarator) {
            var variableStatement = getVariableStatement(variableDeclarator);
            return variableStatement ? variableStatement.modifiers : TypeScript.Syntax.emptyList();
        }
        ASTHelpers.getVariableDeclaratorModifiers = getVariableDeclaratorModifiers;

        function isIntegerLiteralAST(expression) {
            if (expression) {
                switch (expression.kind()) {
                    case 165 /* PlusExpression */:
                    case 166 /* NegateExpression */:
                        expression = expression.operand;
                        return expression.kind() === 13 /* NumericLiteral */ && TypeScript.IntegerUtilities.isInteger(expression.text());

                    case 13 /* NumericLiteral */:
                        var text = expression.text();
                        return TypeScript.IntegerUtilities.isInteger(text) || TypeScript.IntegerUtilities.isHexInteger(text);
                }
            }

            return false;
        }
        ASTHelpers.isIntegerLiteralAST = isIntegerLiteralAST;

        function getEnclosingModuleDeclaration(ast) {
            while (ast) {
                if (ast.kind() === 131 /* ModuleDeclaration */) {
                    return ast;
                }

                ast = ast.parent;
            }

            return null;
        }
        ASTHelpers.getEnclosingModuleDeclaration = getEnclosingModuleDeclaration;

        function isEntireNameOfModuleDeclaration(nameAST) {
            return parentIsModuleDeclaration(nameAST) && nameAST.parent.name === nameAST;
        }

        function getModuleDeclarationFromNameAST(ast) {
            if (ast) {
                switch (ast.kind()) {
                    case 14 /* StringLiteral */:
                        if (parentIsModuleDeclaration(ast) && ast.parent.stringLiteral === ast) {
                            return ast.parent;
                        }
                        return null;

                    case 11 /* IdentifierName */:
                    case 121 /* QualifiedName */:
                        if (isEntireNameOfModuleDeclaration(ast)) {
                            return ast.parent;
                        }
                        break;

                    default:
                        return null;
                }

                for (ast = ast.parent; ast && ast.kind() === 121 /* QualifiedName */; ast = ast.parent) {
                    if (isEntireNameOfModuleDeclaration(ast)) {
                        return ast.parent;
                    }
                }
            }

            return null;
        }
        ASTHelpers.getModuleDeclarationFromNameAST = getModuleDeclarationFromNameAST;

        function isLastNameOfModule(ast, astName) {
            if (ast) {
                if (ast.stringLiteral) {
                    return astName === ast.stringLiteral;
                } else if (ast.name.kind() === 121 /* QualifiedName */) {
                    return astName === ast.name.right;
                } else {
                    return astName === ast.name;
                }
            }

            return false;
        }
        ASTHelpers.isLastNameOfModule = isLastNameOfModule;

        function getNameOfIdenfierOrQualifiedName(name) {
            if (name.kind() === 11 /* IdentifierName */) {
                return name.text();
            } else {
                TypeScript.Debug.assert(name.kind() == 121 /* QualifiedName */);
                var dotExpr = name;
                return getNameOfIdenfierOrQualifiedName(dotExpr.left) + "." + getNameOfIdenfierOrQualifiedName(dotExpr.right);
            }
        }
        ASTHelpers.getNameOfIdenfierOrQualifiedName = getNameOfIdenfierOrQualifiedName;

        function getModuleNames(name, result) {
            result = result || [];

            if (name.kind() === 121 /* QualifiedName */) {
                getModuleNames(name.left, result);
                result.push(name.right);
            } else {
                result.push(name);
            }

            return result;
        }
        ASTHelpers.getModuleNames = getModuleNames;
    })(TypeScript.ASTHelpers || (TypeScript.ASTHelpers = {}));
    var ASTHelpers = TypeScript.ASTHelpers;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function walkListChildren(preAst, walker) {
        for (var i = 0, n = preAst.length; i < n; i++) {
            walker.walk(preAst[i]);
        }
    }

    function walkThrowStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }

    function walkPrefixUnaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.operand);
    }

    function walkPostfixUnaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.operand);
    }

    function walkDeleteExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }

    function walkTypeArgumentListChildren(preAst, walker) {
        walker.walk(preAst.typeArguments);
    }

    function walkTupleTypeChildren(preAst, walker) {
        walker.walk(preAst.types);
    }

    function walkTypeOfExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }

    function walkVoidExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }

    function walkArgumentListChildren(preAst, walker) {
        walker.walk(preAst.typeArgumentList);
        walker.walk(preAst.arguments);
    }

    function walkArrayLiteralExpressionChildren(preAst, walker) {
        walker.walk(preAst.expressions);
    }

    function walkSimplePropertyAssignmentChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.expression);
    }

    function walkFunctionPropertyAssignmentChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkGetAccessorChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkSeparatedListChildren(preAst, walker) {
        for (var i = 0, n = preAst.length; i < n; i++) {
            walker.walk(preAst[i]);
        }
    }

    function walkSetAccessorChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkObjectLiteralExpressionChildren(preAst, walker) {
        walker.walk(preAst.propertyAssignments);
    }

    function walkCastExpressionChildren(preAst, walker) {
        walker.walk(preAst.type);
        walker.walk(preAst.expression);
    }

    function walkParenthesizedExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }

    function walkElementAccessExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentExpression);
    }

    function walkMemberAccessExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.name);
    }

    function walkQualifiedNameChildren(preAst, walker) {
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }

    function walkBinaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }

    function walkEqualsValueClauseChildren(preAst, walker) {
        walker.walk(preAst.value);
    }

    function walkTypeParameterChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.constraint);
    }

    function walkTypeParameterListChildren(preAst, walker) {
        walker.walk(preAst.typeParameters);
    }

    function walkGenericTypeChildren(preAst, walker) {
        walker.walk(preAst.name);
        walker.walk(preAst.typeArgumentList);
    }

    function walkTypeAnnotationChildren(preAst, walker) {
        walker.walk(preAst.type);
    }

    function walkTypeQueryChildren(preAst, walker) {
        walker.walk(preAst.name);
    }

    function walkInvocationExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }

    function walkObjectCreationExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }

    function walkTrinaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.whenTrue);
        walker.walk(preAst.whenFalse);
    }

    function walkFunctionExpressionChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkFunctionTypeChildren(preAst, walker) {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }

    function walkParenthesizedArrowFunctionExpressionChildren(preAst, walker) {
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }

    function walkSimpleArrowFunctionExpressionChildren(preAst, walker) {
        walker.walk(preAst.parameter);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }

    function walkMemberFunctionDeclarationChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkFuncDeclChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkIndexMemberDeclarationChildren(preAst, walker) {
        walker.walk(preAst.indexSignature);
    }

    function walkIndexSignatureChildren(preAst, walker) {
        walker.walk(preAst.parameters);
        walker.walk(preAst.typeAnnotation);
    }

    function walkCallSignatureChildren(preAst, walker) {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.typeAnnotation);
    }

    function walkConstraintChildren(preAst, walker) {
        walker.walk(preAst.typeOrExpression);
    }

    function walkConstructorDeclarationChildren(preAst, walker) {
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkConstructorTypeChildren(preAst, walker) {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }

    function walkConstructSignatureChildren(preAst, walker) {
        walker.walk(preAst.callSignature);
    }

    function walkParameterChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }

    function walkParameterListChildren(preAst, walker) {
        walker.walk(preAst.parameters);
    }

    function walkPropertySignatureChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
    }

    function walkVariableDeclaratorChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }

    function walkMemberVariableDeclarationChildren(preAst, walker) {
        walker.walk(preAst.variableDeclarator);
    }

    function walkMethodSignatureChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
    }

    function walkReturnStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }

    function walkForStatementChildren(preAst, walker) {
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.initializer);
        walker.walk(preAst.condition);
        walker.walk(preAst.incrementor);
        walker.walk(preAst.statement);
    }

    function walkForInStatementChildren(preAst, walker) {
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.left);
        walker.walk(preAst.expression);
        walker.walk(preAst.statement);
    }

    function walkIfStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
        walker.walk(preAst.elseClause);
    }

    function walkElseClauseChildren(preAst, walker) {
        walker.walk(preAst.statement);
    }

    function walkWhileStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }

    function walkDoStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }

    function walkBlockChildren(preAst, walker) {
        walker.walk(preAst.statements);
    }

    function walkVariableDeclarationChildren(preAst, walker) {
        walker.walk(preAst.variableDeclarators);
    }

    function walkCaseSwitchClauseChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.statements);
    }

    function walkDefaultSwitchClauseChildren(preAst, walker) {
        walker.walk(preAst.statements);
    }

    function walkSwitchStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.switchClauses);
    }

    function walkTryStatementChildren(preAst, walker) {
        walker.walk(preAst.block);
        walker.walk(preAst.catchClause);
        walker.walk(preAst.finallyClause);
    }

    function walkCatchClauseChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.block);
    }

    function walkExternalModuleReferenceChildren(preAst, walker) {
        walker.walk(preAst.stringLiteral);
    }

    function walkFinallyClauseChildren(preAst, walker) {
        walker.walk(preAst.block);
    }

    function walkClassDeclChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.classElements);
    }

    function walkScriptChildren(preAst, walker) {
        walker.walk(preAst.moduleElements);
    }

    function walkHeritageClauseChildren(preAst, walker) {
        walker.walk(preAst.typeNames);
    }

    function walkInterfaceDeclerationChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.body);
    }

    function walkObjectTypeChildren(preAst, walker) {
        walker.walk(preAst.typeMembers);
    }

    function walkArrayTypeChildren(preAst, walker) {
        walker.walk(preAst.type);
    }

    function walkModuleDeclarationChildren(preAst, walker) {
        walker.walk(preAst.name);
        walker.walk(preAst.stringLiteral);
        walker.walk(preAst.moduleElements);
    }

    function walkModuleNameModuleReferenceChildren(preAst, walker) {
        walker.walk(preAst.moduleName);
    }

    function walkEnumDeclarationChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.enumElements);
    }

    function walkEnumElementChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.equalsValueClause);
    }

    function walkImportDeclarationChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.moduleReference);
    }

    function walkExportAssignmentChildren(preAst, walker) {
        walker.walk(preAst.identifier);
    }

    function walkWithStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }

    function walkExpressionStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }

    function walkLabeledStatementChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.statement);
    }

    function walkVariableStatementChildren(preAst, walker) {
        walker.walk(preAst.variableDeclaration);
    }

    var childrenWalkers = new Array(247 /* LastNode */ + 1);

    for (var i = 9 /* FirstToken */, n = 119 /* LastToken */; i <= n; i++) {
        childrenWalkers[i] = null;
    }
    for (var i = 4 /* FirstTrivia */, n = 8 /* LastTrivia */; i <= n; i++) {
        childrenWalkers[i] = null;
    }

    childrenWalkers[176 /* AddAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[209 /* AddExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[181 /* AndAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[60 /* AnyKeyword */] = null;
    childrenWalkers[227 /* ArgumentList */] = walkArgumentListChildren;
    childrenWalkers[215 /* ArrayLiteralExpression */] = walkArrayLiteralExpressionChildren;
    childrenWalkers[124 /* ArrayType */] = walkArrayTypeChildren;
    childrenWalkers[220 /* SimpleArrowFunctionExpression */] = walkSimpleArrowFunctionExpressionChildren;
    childrenWalkers[219 /* ParenthesizedArrowFunctionExpression */] = walkParenthesizedArrowFunctionExpressionChildren;
    childrenWalkers[175 /* AssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[192 /* BitwiseAndExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[191 /* BitwiseExclusiveOrExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[167 /* BitwiseNotExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[190 /* BitwiseOrExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[147 /* Block */] = walkBlockChildren;
    childrenWalkers[61 /* BooleanKeyword */] = null;
    childrenWalkers[153 /* BreakStatement */] = null;
    childrenWalkers[143 /* CallSignature */] = walkCallSignatureChildren;
    childrenWalkers[234 /* CaseSwitchClause */] = walkCaseSwitchClauseChildren;
    childrenWalkers[221 /* CastExpression */] = walkCastExpressionChildren;
    childrenWalkers[237 /* CatchClause */] = walkCatchClauseChildren;
    childrenWalkers[132 /* ClassDeclaration */] = walkClassDeclChildren;
    childrenWalkers[174 /* CommaExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[187 /* ConditionalExpression */] = walkTrinaryExpressionChildren;
    childrenWalkers[240 /* Constraint */] = walkConstraintChildren;
    childrenWalkers[138 /* ConstructorDeclaration */] = walkConstructorDeclarationChildren;
    childrenWalkers[144 /* ConstructSignature */] = walkConstructSignatureChildren;
    childrenWalkers[154 /* ContinueStatement */] = null;
    childrenWalkers[125 /* ConstructorType */] = walkConstructorTypeChildren;
    childrenWalkers[163 /* DebuggerStatement */] = null;
    childrenWalkers[235 /* DefaultSwitchClause */] = walkDefaultSwitchClauseChildren;
    childrenWalkers[171 /* DeleteExpression */] = walkDeleteExpressionChildren;
    childrenWalkers[179 /* DivideAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[207 /* DivideExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[162 /* DoStatement */] = walkDoStatementChildren;
    childrenWalkers[222 /* ElementAccessExpression */] = walkElementAccessExpressionChildren;
    childrenWalkers[236 /* ElseClause */] = walkElseClauseChildren;
    childrenWalkers[157 /* EmptyStatement */] = null;
    childrenWalkers[133 /* EnumDeclaration */] = walkEnumDeclarationChildren;
    childrenWalkers[244 /* EnumElement */] = walkEnumElementChildren;
    childrenWalkers[195 /* EqualsExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[233 /* EqualsValueClause */] = walkEqualsValueClauseChildren;
    childrenWalkers[193 /* EqualsWithTypeConversionExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[182 /* ExclusiveOrAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[135 /* ExportAssignment */] = walkExportAssignmentChildren;
    childrenWalkers[150 /* ExpressionStatement */] = walkExpressionStatementChildren;
    childrenWalkers[231 /* ExtendsHeritageClause */] = walkHeritageClauseChildren;
    childrenWalkers[246 /* ExternalModuleReference */] = walkExternalModuleReferenceChildren;
    childrenWalkers[24 /* FalseKeyword */] = null;
    childrenWalkers[238 /* FinallyClause */] = walkFinallyClauseChildren;
    childrenWalkers[156 /* ForInStatement */] = walkForInStatementChildren;
    childrenWalkers[155 /* ForStatement */] = walkForStatementChildren;
    childrenWalkers[130 /* FunctionDeclaration */] = walkFuncDeclChildren;
    childrenWalkers[223 /* FunctionExpression */] = walkFunctionExpressionChildren;
    childrenWalkers[242 /* FunctionPropertyAssignment */] = walkFunctionPropertyAssignmentChildren;
    childrenWalkers[123 /* FunctionType */] = walkFunctionTypeChildren;
    childrenWalkers[126 /* GenericType */] = walkGenericTypeChildren;
    childrenWalkers[140 /* GetAccessor */] = walkGetAccessorChildren;
    childrenWalkers[198 /* GreaterThanExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[200 /* GreaterThanOrEqualExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[148 /* IfStatement */] = walkIfStatementChildren;
    childrenWalkers[232 /* ImplementsHeritageClause */] = walkHeritageClauseChildren;
    childrenWalkers[134 /* ImportDeclaration */] = walkImportDeclarationChildren;
    childrenWalkers[139 /* IndexMemberDeclaration */] = walkIndexMemberDeclarationChildren;
    childrenWalkers[145 /* IndexSignature */] = walkIndexSignatureChildren;
    childrenWalkers[202 /* InExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[201 /* InstanceOfExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[129 /* InterfaceDeclaration */] = walkInterfaceDeclerationChildren;
    childrenWalkers[214 /* InvocationExpression */] = walkInvocationExpressionChildren;
    childrenWalkers[161 /* LabeledStatement */] = walkLabeledStatementChildren;
    childrenWalkers[184 /* LeftShiftAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[203 /* LeftShiftExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[197 /* LessThanExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[199 /* LessThanOrEqualExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[1 /* List */] = walkListChildren;
    childrenWalkers[189 /* LogicalAndExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[168 /* LogicalNotExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[188 /* LogicalOrExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[213 /* MemberAccessExpression */] = walkMemberAccessExpressionChildren;
    childrenWalkers[136 /* MemberFunctionDeclaration */] = walkMemberFunctionDeclarationChildren;
    childrenWalkers[137 /* MemberVariableDeclaration */] = walkMemberVariableDeclarationChildren;
    childrenWalkers[146 /* MethodSignature */] = walkMethodSignatureChildren;
    childrenWalkers[131 /* ModuleDeclaration */] = walkModuleDeclarationChildren;
    childrenWalkers[247 /* ModuleNameModuleReference */] = walkModuleNameModuleReferenceChildren;
    childrenWalkers[180 /* ModuloAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[208 /* ModuloExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[178 /* MultiplyAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[206 /* MultiplyExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[11 /* IdentifierName */] = null;
    childrenWalkers[166 /* NegateExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[0 /* None */] = null;
    childrenWalkers[196 /* NotEqualsExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[194 /* NotEqualsWithTypeConversionExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[32 /* NullKeyword */] = null;
    childrenWalkers[67 /* NumberKeyword */] = null;
    childrenWalkers[13 /* NumericLiteral */] = null;
    childrenWalkers[217 /* ObjectCreationExpression */] = walkObjectCreationExpressionChildren;
    childrenWalkers[216 /* ObjectLiteralExpression */] = walkObjectLiteralExpressionChildren;
    childrenWalkers[122 /* ObjectType */] = walkObjectTypeChildren;
    childrenWalkers[224 /* OmittedExpression */] = null;
    childrenWalkers[183 /* OrAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[243 /* Parameter */] = walkParameterChildren;
    childrenWalkers[228 /* ParameterList */] = walkParameterListChildren;
    childrenWalkers[218 /* ParenthesizedExpression */] = walkParenthesizedExpressionChildren;
    childrenWalkers[165 /* PlusExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[212 /* PostDecrementExpression */] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[211 /* PostIncrementExpression */] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[170 /* PreDecrementExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[169 /* PreIncrementExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[142 /* PropertySignature */] = walkPropertySignatureChildren;
    childrenWalkers[121 /* QualifiedName */] = walkQualifiedNameChildren;
    childrenWalkers[12 /* RegularExpressionLiteral */] = null;
    childrenWalkers[151 /* ReturnStatement */] = walkReturnStatementChildren;
    childrenWalkers[120 /* SourceUnit */] = walkScriptChildren;
    childrenWalkers[2 /* SeparatedList */] = walkSeparatedListChildren;
    childrenWalkers[141 /* SetAccessor */] = walkSetAccessorChildren;
    childrenWalkers[185 /* SignedRightShiftAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[204 /* SignedRightShiftExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[241 /* SimplePropertyAssignment */] = walkSimplePropertyAssignmentChildren;
    childrenWalkers[14 /* StringLiteral */] = null;
    childrenWalkers[69 /* StringKeyword */] = null;
    childrenWalkers[177 /* SubtractAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[210 /* SubtractExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[50 /* SuperKeyword */] = null;
    childrenWalkers[152 /* SwitchStatement */] = walkSwitchStatementChildren;
    childrenWalkers[35 /* ThisKeyword */] = null;
    childrenWalkers[158 /* ThrowStatement */] = walkThrowStatementChildren;
    childrenWalkers[3 /* TriviaList */] = null;
    childrenWalkers[37 /* TrueKeyword */] = null;
    childrenWalkers[160 /* TryStatement */] = walkTryStatementChildren;
    childrenWalkers[128 /* TupleType */] = walkTupleTypeChildren;
    childrenWalkers[245 /* TypeAnnotation */] = walkTypeAnnotationChildren;
    childrenWalkers[229 /* TypeArgumentList */] = walkTypeArgumentListChildren;
    childrenWalkers[172 /* TypeOfExpression */] = walkTypeOfExpressionChildren;
    childrenWalkers[239 /* TypeParameter */] = walkTypeParameterChildren;
    childrenWalkers[230 /* TypeParameterList */] = walkTypeParameterListChildren;
    childrenWalkers[127 /* TypeQuery */] = walkTypeQueryChildren;
    childrenWalkers[186 /* UnsignedRightShiftAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[205 /* UnsignedRightShiftExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[225 /* VariableDeclaration */] = walkVariableDeclarationChildren;
    childrenWalkers[226 /* VariableDeclarator */] = walkVariableDeclaratorChildren;
    childrenWalkers[149 /* VariableStatement */] = walkVariableStatementChildren;
    childrenWalkers[173 /* VoidExpression */] = walkVoidExpressionChildren;
    childrenWalkers[41 /* VoidKeyword */] = null;
    childrenWalkers[159 /* WhileStatement */] = walkWhileStatementChildren;
    childrenWalkers[164 /* WithStatement */] = walkWithStatementChildren;

    for (var e in TypeScript.SyntaxKind) {
        if (TypeScript.SyntaxKind.hasOwnProperty(e) && TypeScript.StringUtilities.isString(TypeScript.SyntaxKind[e])) {
            TypeScript.Debug.assert(childrenWalkers[e] !== undefined, "Fix initWalkers: " + TypeScript.SyntaxKind[e]);
        }
    }

    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
            this.stopWalking = false;
        }
        return AstWalkOptions;
    })();
    TypeScript.AstWalkOptions = AstWalkOptions;

    var SimplePreAstWalker = (function () {
        function SimplePreAstWalker(pre, state) {
            this.pre = pre;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        SimplePreAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }

            this.pre(ast, this.state);

            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }
        };
        return SimplePreAstWalker;
    })();

    var SimplePrePostAstWalker = (function () {
        function SimplePrePostAstWalker(pre, post, state) {
            this.pre = pre;
            this.post = post;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        SimplePrePostAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }

            this.pre(ast, this.state);

            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }

            this.post(ast, this.state);
        };
        return SimplePrePostAstWalker;
    })();

    var NormalAstWalker = (function () {
        function NormalAstWalker(pre, post, state) {
            this.pre = pre;
            this.post = post;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        NormalAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }

            if (this.options.stopWalking) {
                return;
            }

            this.pre(ast, this);

            if (this.options.stopWalking) {
                return;
            }

            if (this.options.goChildren) {
                var walker = childrenWalkers[ast.kind()];
                if (walker) {
                    walker(ast, this);
                }
            } else {
                this.options.goChildren = true;
            }

            if (this.post) {
                this.post(ast, this);
            }
        };
        return NormalAstWalker;
    })();

    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, state) {
            new NormalAstWalker(pre, post, state).walk(ast);
        };

        AstWalkerFactory.prototype.simpleWalk = function (ast, pre, post, state) {
            if (post) {
                new SimplePrePostAstWalker(pre, post, state).walk(ast);
            } else {
                new SimplePreAstWalker(pre, state).walk(ast);
            }
        };
        return AstWalkerFactory;
    })();
    TypeScript.AstWalkerFactory = AstWalkerFactory;

    var globalAstWalkerFactory = new AstWalkerFactory();

    function getAstWalkerFactory() {
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Base64Format = (function () {
        function Base64Format() {
        }
        Base64Format.encode = function (inValue) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        };

        Base64Format.decodeChar = function (inChar) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        };
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        return Base64Format;
    })();

    var Base64VLQFormat = (function () {
        function Base64VLQFormat() {
        }
        Base64VLQFormat.encode = function (inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            } else {
                inValue = inValue << 1;
            }

            var encodedStr = "";
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while(inValue > 0);

            return encodedStr;
        };

        Base64VLQFormat.decode = function (inString) {
            var result = 0;
            var negative = false;

            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15;
                } else {
                    result = result | ((byte & 31) << shift);
                }

                shift += (i === 0) ? 4 : 5;

                if ((byte & 32) === 32) {
                } else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }

            throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Base64_value_0_finished_with_a_continuation_bit, [inString]));
        };
        return Base64VLQFormat;
    })();
    TypeScript.Base64VLQFormat = Base64VLQFormat;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceMapPosition = (function () {
        function SourceMapPosition() {
        }
        return SourceMapPosition;
    })();
    TypeScript.SourceMapPosition = SourceMapPosition;

    var SourceMapping = (function () {
        function SourceMapping() {
            this.start = new SourceMapPosition();
            this.end = new SourceMapPosition();
            this.nameIndex = -1;
            this.childMappings = [];
        }
        return SourceMapping;
    })();
    TypeScript.SourceMapping = SourceMapping;

    var SourceMapEntry = (function () {
        function SourceMapEntry(emittedFile, emittedLine, emittedColumn, sourceFile, sourceLine, sourceColumn, sourceName) {
            this.emittedFile = emittedFile;
            this.emittedLine = emittedLine;
            this.emittedColumn = emittedColumn;
            this.sourceFile = sourceFile;
            this.sourceLine = sourceLine;
            this.sourceColumn = sourceColumn;
            this.sourceName = sourceName;
            TypeScript.Debug.assert(isFinite(emittedLine));
            TypeScript.Debug.assert(isFinite(emittedColumn));
            TypeScript.Debug.assert(isFinite(sourceColumn));
            TypeScript.Debug.assert(isFinite(sourceLine));
        }
        return SourceMapEntry;
    })();
    TypeScript.SourceMapEntry = SourceMapEntry;

    var SourceMapper = (function () {
        function SourceMapper(jsFile, sourceMapOut, document, jsFilePath, emitOptions, resolvePath) {
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;
            this.names = [];
            this.mappingLevel = [];
            this.tsFilePaths = [];
            this.allSourceMappings = [];
            this.sourceMapEntries = [];
            this.setSourceMapOptions(document, jsFilePath, emitOptions, resolvePath);
            this.setNewSourceFile(document, emitOptions);
        }
        SourceMapper.prototype.getOutputFile = function () {
            var result = this.sourceMapOut.getOutputFile();
            result.sourceMapEntries = this.sourceMapEntries;

            return result;
        };

        SourceMapper.prototype.increaseMappingLevel = function (ast) {
            this.mappingLevel.push(ast);
        };

        SourceMapper.prototype.decreaseMappingLevel = function (ast) {
            TypeScript.Debug.assert(this.mappingLevel.length > 0, "Mapping level should never be less than 0. This suggests a missing start call.");
            var expectedAst = this.mappingLevel.pop();
            if (ast !== expectedAst) {
                var expectedAstInfo = expectedAst.kind ? TypeScript.SyntaxKind[expectedAst.kind] : [expectedAst.start(), expectedAst.end()];
                var astInfo = ast.kind ? TypeScript.SyntaxKind[ast.kind] : [ast.start(), ast.end()];
                TypeScript.Debug.fail("Provided ast is not the expected ISyntaxElement, Expected: " + expectedAstInfo + " Given: " + astInfo);
            }
        };

        SourceMapper.prototype.setNewSourceFile = function (document, emitOptions) {
            var sourceMappings = [];
            this.allSourceMappings.push(sourceMappings);
            this.currentMappings = [sourceMappings];
            this.currentNameIndex = [];

            this.setNewSourceFilePath(document, emitOptions);
        };

        SourceMapper.prototype.setSourceMapOptions = function (document, jsFilePath, emitOptions, resolvePath) {
            var prettyJsFileName = TypeScript.getPrettyName(jsFilePath, false, true);
            var prettyMapFileName = prettyJsFileName + SourceMapper.MapFileExtension;
            this.jsFileName = prettyJsFileName;

            if (emitOptions.sourceMapRootDirectory()) {
                this.sourceMapDirectory = emitOptions.sourceMapRootDirectory();
                if (document.emitToOwnOutputFile()) {
                    this.sourceMapDirectory = this.sourceMapDirectory + TypeScript.switchToForwardSlashes(TypeScript.getRootFilePath((document.fileName)).replace(emitOptions.commonDirectoryPath(), ""));
                }

                if (TypeScript.isRelative(this.sourceMapDirectory)) {
                    this.sourceMapDirectory = emitOptions.commonDirectoryPath() + this.sourceMapDirectory;
                    this.sourceMapDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(resolvePath(this.sourceMapDirectory)));
                    this.sourceMapPath = TypeScript.getRelativePathToFixedPath(TypeScript.getRootFilePath(jsFilePath), this.sourceMapDirectory + prettyMapFileName);
                } else {
                    this.sourceMapPath = this.sourceMapDirectory + prettyMapFileName;
                }
            } else {
                this.sourceMapPath = prettyMapFileName;
                this.sourceMapDirectory = TypeScript.getRootFilePath(jsFilePath);
            }
            this.sourceRoot = emitOptions.sourceRootDirectory();
        };

        SourceMapper.prototype.setNewSourceFilePath = function (document, emitOptions) {
            var tsFilePath = TypeScript.switchToForwardSlashes(document.fileName);
            if (emitOptions.sourceRootDirectory()) {
                tsFilePath = TypeScript.getRelativePathToFixedPath(emitOptions.commonDirectoryPath(), tsFilePath);
            } else {
                tsFilePath = TypeScript.getRelativePathToFixedPath(this.sourceMapDirectory, tsFilePath);
            }
            this.tsFilePaths.push(tsFilePath);
        };

        SourceMapper.prototype.emitSourceMapping = function () {
            var _this = this;
            TypeScript.Debug.assert(this.mappingLevel.length === 0, "Mapping level is not 0. This suggest a missing end call. Value: " + this.mappingLevel.map(function (item) {
                return ['Node of type', TypeScript.SyntaxKind[item.kind], 'at', item.start(), 'to', item.end()].join(' ');
            }).join(', '));

            this.jsFile.WriteLine("//# sourceMappingURL=" + this.sourceMapPath);

            var mappingsString = "";

            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var emitComma = false;

            var recordedPosition = null;
            for (var sourceIndex = 0; sourceIndex < this.tsFilePaths.length; sourceIndex++) {
                var recordSourceMapping = function (mappedPosition, nameIndex) {
                    if (recordedPosition !== null && recordedPosition.emittedColumn === mappedPosition.emittedColumn && recordedPosition.emittedLine === mappedPosition.emittedLine) {
                        return;
                    }

                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    } else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }

                    _this.sourceMapEntries.push(new SourceMapEntry(_this.jsFileName, mappedPosition.emittedLine + 1, mappedPosition.emittedColumn + 1, _this.tsFilePaths[sourceIndex], mappedPosition.sourceLine, mappedPosition.sourceColumn + 1, nameIndex >= 0 ? _this.names[nameIndex] : undefined));

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(sourceIndex - prevSourceIndex);
                    prevSourceIndex = sourceIndex;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;

                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(nameIndex - prevNameIndex);
                        prevNameIndex = nameIndex;
                    }

                    emitComma = true;
                    recordedPosition = mappedPosition;
                };

                var recordSourceMappingSiblings = function (sourceMappings) {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };

                recordSourceMappingSiblings(this.allSourceMappings[sourceIndex]);
            }

            this.sourceMapOut.Write(JSON.stringify({
                version: 3,
                file: this.jsFileName,
                sourceRoot: this.sourceRoot,
                sources: this.tsFilePaths,
                names: this.names,
                mappings: mappingsString
            }));

            this.sourceMapOut.Close();
        };
        SourceMapper.MapFileExtension = ".map";
        return SourceMapper;
    })();
    TypeScript.SourceMapper = SourceMapper;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (EmitContainer) {
        EmitContainer[EmitContainer["Prog"] = 0] = "Prog";
        EmitContainer[EmitContainer["Module"] = 1] = "Module";
        EmitContainer[EmitContainer["DynamicModule"] = 2] = "DynamicModule";
        EmitContainer[EmitContainer["Class"] = 3] = "Class";
        EmitContainer[EmitContainer["Constructor"] = 4] = "Constructor";
        EmitContainer[EmitContainer["Function"] = 5] = "Function";
        EmitContainer[EmitContainer["Args"] = 6] = "Args";
        EmitContainer[EmitContainer["Interface"] = 7] = "Interface";
    })(TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));
    var EmitContainer = TypeScript.EmitContainer;

    var EmitState = (function () {
        function EmitState() {
            this.column = 0;
            this.line = 0;
            this.container = 0 /* Prog */;
        }
        return EmitState;
    })();
    TypeScript.EmitState = EmitState;

    var EmitOptions = (function () {
        function EmitOptions(compiler, resolvePath) {
            this.resolvePath = resolvePath;
            this._diagnostic = null;
            this._settings = null;
            this._commonDirectoryPath = "";
            this._sharedOutputFile = "";
            this._sourceRootDirectory = "";
            this._sourceMapRootDirectory = "";
            this._outputDirectory = "";
            var settings = compiler.compilationSettings();
            this._settings = settings;

            if (settings.moduleGenTarget() === 0 /* Unspecified */) {
                var fileNames = compiler.fileNames();
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var document = compiler.getDocument(fileNames[i]);
                    if (!document.isDeclareFile() && document.syntaxTree().isExternalModule()) {
                        var errorSpan = TypeScript.externalModuleIndicatorSpan(document.syntaxTree());
                        this._diagnostic = new TypeScript.Diagnostic(document.fileName, document.lineMap(), errorSpan.start(), errorSpan.length(), TypeScript.DiagnosticCode.Cannot_compile_external_modules_unless_the_module_flag_is_provided);

                        return;
                    }
                }
            }

            if (!settings.mapSourceFiles()) {
                if (settings.mapRoot()) {
                    if (settings.sourceRoot()) {
                        this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                        return;
                    } else {
                        this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                        return;
                    }
                } else if (settings.sourceRoot()) {
                    this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                    return;
                }
            }

            this._sourceMapRootDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(settings.mapRoot()));
            this._sourceRootDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(settings.sourceRoot()));

            if (settings.outFileOption() || settings.outDirOption() || settings.mapRoot() || settings.sourceRoot()) {
                if (settings.outFileOption()) {
                    this._sharedOutputFile = TypeScript.switchToForwardSlashes(resolvePath(settings.outFileOption()));
                }

                if (settings.outDirOption()) {
                    this._outputDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(resolvePath(settings.outDirOption())));
                }

                if (this._outputDirectory || this._sourceMapRootDirectory || this.sourceRootDirectory) {
                    this.determineCommonDirectoryPath(compiler);
                }
            }
        }
        EmitOptions.prototype.diagnostic = function () {
            return this._diagnostic;
        };

        EmitOptions.prototype.commonDirectoryPath = function () {
            return this._commonDirectoryPath;
        };
        EmitOptions.prototype.sharedOutputFile = function () {
            return this._sharedOutputFile;
        };
        EmitOptions.prototype.sourceRootDirectory = function () {
            return this._sourceRootDirectory;
        };
        EmitOptions.prototype.sourceMapRootDirectory = function () {
            return this._sourceMapRootDirectory;
        };
        EmitOptions.prototype.outputDirectory = function () {
            return this._outputDirectory;
        };

        EmitOptions.prototype.compilationSettings = function () {
            return this._settings;
        };

        EmitOptions.prototype.determineCommonDirectoryPath = function (compiler) {
            var commonComponents = [];
            var commonComponentsLength = -1;

            var fileNames = compiler.fileNames();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var fileName = fileNames[i];
                var document = compiler.getDocument(fileNames[i]);
                var sourceUnit = document.sourceUnit();

                if (!document.isDeclareFile()) {
                    var fileComponents = TypeScript.filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] !== fileComponents[j]) {
                                commonComponentsLength = j;
                                updatedPath = true;

                                if (j === 0) {
                                    var isDynamicModuleCompilation = TypeScript.ArrayUtilities.any(fileNames, function (fileName) {
                                        document = compiler.getDocument(fileName);
                                        return !document.isDeclareFile() && document.syntaxTree().isExternalModule();
                                    });

                                    if (this._outputDirectory || this._sourceRootDirectory || (this._sourceMapRootDirectory && (!this._sharedOutputFile || isDynamicModuleCompilation))) {
                                        this._diagnostic = new TypeScript.Diagnostic(null, null, 0, 0, TypeScript.DiagnosticCode.Cannot_find_the_common_subdirectory_path_for_the_input_files, null);
                                        return;
                                    }

                                    return;
                                }

                                break;
                            }
                        }

                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }

            this._commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
        };
        return EmitOptions;
    })();
    TypeScript.EmitOptions = EmitOptions;

    var Indenter = (function () {
        function Indenter() {
            this.indentAmt = 0;
        }
        Indenter.prototype.increaseIndent = function () {
            this.indentAmt += Indenter.indentStep;
        };

        Indenter.prototype.decreaseIndent = function () {
            this.indentAmt -= Indenter.indentStep;
        };

        Indenter.prototype.getIndent = function () {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        };
        Indenter.indentStep = 4;
        Indenter.indentStepString = "    ";
        Indenter.indentStrings = [];
        return Indenter;
    })();
    TypeScript.Indenter = Indenter;

    function lastParameterIsRest(parameters) {
        return parameters.length > 0 && (parameters[parameters.length - 1]).dotDotDotToken !== null;
    }
    TypeScript.lastParameterIsRest = lastParameterIsRest;

    var Emitter = (function () {
        function Emitter(emittingFileName, outfile, emitOptions, semanticInfoChain) {
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.semanticInfoChain = semanticInfoChain;
            this.globalThisCapturePrologueEmitted = false;
            this.extendsPrologueEmitted = false;
            this.thisClassNode = null;
            this.inArrowFunction = false;
            this.moduleName = "";
            this.emitState = new EmitState();
            this.indenter = new Indenter();
            this.sourceMapper = null;
            this.captureThisStmtString = "var _this = this;";
            this.declStack = [];
            this.exportAssignment = null;
            this.inWithBlock = false;
            this.document = null;
            this.detachedCommentsElement = null;
        }
        Emitter.prototype.pushDecl = function (decl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        };

        Emitter.prototype.popDecl = function (decl) {
            if (decl) {
                this.declStack.length--;
            }
        };

        Emitter.prototype.getEnclosingDecl = function () {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        };

        Emitter.prototype.setExportAssignment = function (exportAssignment) {
            this.exportAssignment = exportAssignment;
        };

        Emitter.prototype.getExportAssignment = function () {
            return this.exportAssignment;
        };

        Emitter.prototype.setDocument = function (document) {
            this.document = document;
        };

        Emitter.prototype.shouldEmitImportDeclaration = function (importDeclAST) {
            var isExternalModuleReference = importDeclAST.moduleReference.kind() === 246 /* ExternalModuleReference */;
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST);
            var isExported = TypeScript.hasFlag(importDecl.flags, 1 /* Exported */);
            var isAmdCodeGen = this.emitOptions.compilationSettings().moduleGenTarget() === 2 /* Asynchronous */;

            if (isExternalModuleReference && !isExported && isAmdCodeGen) {
                return false;
            }

            var importSymbol = importDecl.getSymbol(this.semanticInfoChain);
            if (importSymbol.isUsedAsValue()) {
                return true;
            }

            if (importDeclAST.moduleReference.kind() !== 246 /* ExternalModuleReference */) {
                var canBeUsedExternally = isExported || importSymbol.typeUsedExternally() || importSymbol.isUsedInExportedAlias();
                if (!canBeUsedExternally && !this.document.syntaxTree().isExternalModule()) {
                    canBeUsedExternally = TypeScript.hasFlag(importDecl.getParentDecl().kind, 1 /* Script */ | 32 /* DynamicModule */);
                }

                if (canBeUsedExternally) {
                    if (importSymbol.getExportAssignedValueSymbol()) {
                        return true;
                    }

                    var containerSymbol = importSymbol.getExportAssignedContainerSymbol();
                    if (containerSymbol && containerSymbol.getInstanceSymbol()) {
                        return true;
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitImportDeclaration = function (importDeclAST) {
            var isExternalModuleReference = importDeclAST.moduleReference.kind() === 246 /* ExternalModuleReference */;
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST);
            var isExported = TypeScript.hasFlag(importDecl.flags, 1 /* Exported */);
            var isAmdCodeGen = this.emitOptions.compilationSettings().moduleGenTarget() === 2 /* Asynchronous */;

            this.emitComments(importDeclAST, true);

            var importSymbol = importDecl.getSymbol(this.semanticInfoChain);

            var parentSymbol = importSymbol.getContainer();
            var parentKind = parentSymbol ? parentSymbol.kind : 0 /* None */;
            var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
            var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.kind : 0 /* None */;

            var needsPropertyAssignment = false;
            var usePropertyAssignmentInsteadOfVarDecl = false;
            var moduleNamePrefix;

            if (isExported && (parentKind === 4 /* Container */ || parentKind === 32 /* DynamicModule */ || associatedParentSymbolKind === 4 /* Container */ || associatedParentSymbolKind === 32 /* DynamicModule */)) {
                if (importSymbol.getExportAssignedTypeSymbol() || importSymbol.getExportAssignedContainerSymbol()) {
                    needsPropertyAssignment = true;
                } else {
                    var valueSymbol = importSymbol.getExportAssignedValueSymbol();
                    if (valueSymbol && (valueSymbol.kind === 65536 /* Method */ || valueSymbol.kind === 16384 /* Function */)) {
                        needsPropertyAssignment = true;
                    } else {
                        usePropertyAssignmentInsteadOfVarDecl = true;
                    }
                }

                if (this.emitState.container === 2 /* DynamicModule */) {
                    moduleNamePrefix = "exports.";
                } else {
                    moduleNamePrefix = this.moduleName + ".";
                }
            }

            if (isAmdCodeGen && isExternalModuleReference) {
                needsPropertyAssignment = true;
            } else {
                this.recordSourceMappingStart(importDeclAST);
                if (usePropertyAssignmentInsteadOfVarDecl) {
                    this.writeToOutput(moduleNamePrefix);
                } else {
                    this.writeToOutput("var ");
                }
                this.writeToOutput(importDeclAST.identifier.text() + " = ");
                var aliasAST = importDeclAST.moduleReference;

                if (isExternalModuleReference) {
                    this.writeToOutput("require(" + aliasAST.stringLiteral.text() + ")");
                } else {
                    this.emitJavascript(aliasAST.moduleName, false);
                }

                this.recordSourceMappingEnd(importDeclAST);
                this.writeToOutput(";");

                if (needsPropertyAssignment) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                }
            }

            if (needsPropertyAssignment) {
                this.writeToOutputWithSourceMapRecord(moduleNamePrefix + importDeclAST.identifier.text() + " = " + importDeclAST.identifier.text(), importDeclAST);
                this.writeToOutput(";");
            }
            this.emitComments(importDeclAST, false);
        };

        Emitter.prototype.createSourceMapper = function (document, jsFileName, jsFile, sourceMapOut, resolvePath) {
            this.sourceMapper = new TypeScript.SourceMapper(jsFile, sourceMapOut, document, jsFileName, this.emitOptions, resolvePath);
        };

        Emitter.prototype.setSourceMapperNewSourceFile = function (document) {
            this.sourceMapper.setNewSourceFile(document, this.emitOptions);
        };

        Emitter.prototype.updateLineAndColumn = function (s) {
            var lineNumbers = TypeScript.TextUtilities.parseLineStarts(s);
            if (lineNumbers.length > 1) {
                this.emitState.line += lineNumbers.length - 1;
                this.emitState.column = s.length - lineNumbers[lineNumbers.length - 1];
            } else {
                this.emitState.column += s.length;
            }
        };

        Emitter.prototype.writeToOutputWithSourceMapRecord = function (s, astSpan) {
            if (astSpan) {
                this.recordSourceMappingStart(astSpan);
            }

            this.writeToOutput(s);

            if (astSpan) {
                this.recordSourceMappingEnd(astSpan);
            }
        };

        Emitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);
            this.updateLineAndColumn(s);
        };

        Emitter.prototype.writeLineToOutput = function (s, force) {
            if (typeof force === "undefined") { force = false; }
            if (!force && s === "" && this.emitState.column === 0) {
                return;
            }

            this.outfile.WriteLine(s);
            this.updateLineAndColumn(s);
            this.emitState.column = 0;
            this.emitState.line++;
        };

        Emitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord(this.captureThisStmtString, ast);
            this.writeLineToOutput("");
        };

        Emitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };

        Emitter.prototype.getIndentString = function () {
            return this.indenter.getIndent();
        };

        Emitter.prototype.emitIndent = function () {
            this.writeToOutput(this.getIndentString());
        };

        Emitter.prototype.emitComment = function (comment, trailing, first, noLeadingSpace) {
            if (typeof noLeadingSpace === "undefined") { noLeadingSpace = false; }
            if (this.emitOptions.compilationSettings().removeComments()) {
                return;
            }

            var text = getTrimmedTextLines(comment);
            var emitColumn = this.emitState.column;

            if (emitColumn === 0) {
                this.emitIndent();
            } else if (trailing && first && !noLeadingSpace) {
                this.writeToOutput(" ");
            }

            if (comment.kind() === 6 /* MultiLineCommentTrivia */) {
                this.recordSourceMappingCommentStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingCommentEnd(comment);
                    this.writeLineToOutput("");
                } else {
                    this.recordSourceMappingCommentEnd(comment);
                    this.writeToOutput(" ");
                    return;
                }
            } else {
                this.recordSourceMappingCommentStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingCommentEnd(comment);
                this.writeLineToOutput("");
            }

            if (!trailing && emitColumn !== 0) {
                this.emitIndent();
            }
        };

        Emitter.prototype.text = function () {
            return this.document.syntaxTree().text;
        };

        Emitter.prototype.emitComments = function (ast, pre, onlyPinnedOrTripleSlashComments) {
            var _this = this;
            if (typeof onlyPinnedOrTripleSlashComments === "undefined") { onlyPinnedOrTripleSlashComments = false; }
            if (ast && !TypeScript.isShared(ast) && ast.kind() !== 147 /* Block */) {
                if (ast.parent.kind() === 220 /* SimpleArrowFunctionExpression */ || ast.parent.kind() === 219 /* ParenthesizedArrowFunctionExpression */) {
                    return;
                }
            }

            if (pre) {
                var preComments = TypeScript.ASTHelpers.preComments(ast, this.text());

                if (preComments && ast === this.detachedCommentsElement) {
                    var detachedComments = this.getDetachedComments(ast);
                    preComments = preComments.slice(detachedComments.length);
                    this.detachedCommentsElement = null;
                }

                if (preComments && onlyPinnedOrTripleSlashComments) {
                    preComments = TypeScript.ArrayUtilities.where(preComments, function (c) {
                        return _this.isPinnedOrTripleSlash(c);
                    });
                }

                this.emitCommentsArray(preComments, false);
            } else {
                this.emitCommentsArray(TypeScript.ASTHelpers.postComments(ast, this.text()), true);
            }
        };

        Emitter.prototype.isPinnedOrTripleSlash = function (comment) {
            var fullText = comment.fullText();
            if (fullText.match(TypeScript.tripleSlashReferenceRegExp)) {
                return true;
            } else {
                return fullText.indexOf("/*!") === 0;
            }
        };

        Emitter.prototype.emitCommentsArray = function (comments, trailing, noLeadingSpace) {
            if (typeof noLeadingSpace === "undefined") { noLeadingSpace = false; }
            if (!this.emitOptions.compilationSettings().removeComments() && comments) {
                for (var i = 0, n = comments.length; i < n; i++) {
                    this.emitComment(comments[i], trailing, i === 0, noLeadingSpace);
                }
            }
        };

        Emitter.prototype.emitObjectLiteralExpression = function (objectLiteral) {
            this.recordSourceMappingStart(objectLiteral);

            this.writeToken(objectLiteral.openBraceToken);
            this.emitCommaSeparatedList(objectLiteral, objectLiteral.propertyAssignments, " ", true);
            this.writeToken(objectLiteral.closeBraceToken);

            this.recordSourceMappingEnd(objectLiteral);
        };

        Emitter.prototype.emitArrayLiteralExpression = function (arrayLiteral) {
            this.recordSourceMappingStart(arrayLiteral);

            this.writeToken(arrayLiteral.openBracketToken);
            this.emitCommaSeparatedList(arrayLiteral, arrayLiteral.expressions, "", true);
            this.writeToken(arrayLiteral.closeBracketToken);

            this.recordSourceMappingEnd(arrayLiteral);
        };

        Emitter.prototype.emitObjectCreationExpression = function (objectCreationExpression) {
            this.recordSourceMappingStart(objectCreationExpression);
            this.writeToken(objectCreationExpression.newKeyword);
            this.writeToOutput(" ");
            var target = objectCreationExpression.expression;

            this.emit(target);
            if (objectCreationExpression.argumentList) {
                this.recordSourceMappingStart(objectCreationExpression.argumentList);
                this.writeToken(objectCreationExpression.argumentList.openParenToken);
                this.emitCommaSeparatedList(objectCreationExpression.argumentList, objectCreationExpression.argumentList.arguments, "", false);
                this.writeToken(objectCreationExpression.argumentList.closeParenToken);
                this.recordSourceMappingEnd(objectCreationExpression.argumentList);
            }

            this.recordSourceMappingEnd(objectCreationExpression);
        };

        Emitter.prototype.getConstantDecl = function (dotExpr) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(dotExpr);
            if (pullSymbol && pullSymbol.kind === 67108864 /* EnumMember */) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    if (pullDecl.kind === 67108864 /* EnumMember */) {
                        return pullDecl;
                    }
                }
            }

            return null;
        };

        Emitter.prototype.tryEmitConstant = function (dotExpr) {
            var propertyName = dotExpr.name;
            var boundDecl = this.getConstantDecl(dotExpr);
            if (boundDecl) {
                var value = boundDecl.constantValue;
                if (value !== null) {
                    this.recordSourceMappingStart(dotExpr);
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.text();
                    comment += " */";
                    this.writeToOutput(comment);
                    this.recordSourceMappingEnd(dotExpr);
                    return true;
                }
            }

            return false;
        };

        Emitter.prototype.emitInvocationExpression = function (callNode) {
            this.recordSourceMappingStart(callNode);
            var target = callNode.expression;
            var args = callNode.argumentList.arguments;

            if (target.kind() === 213 /* MemberAccessExpression */ && target.expression.kind() === 50 /* SuperKeyword */) {
                this.emit(target);
                this.writeToOutput(".call");
                this.recordSourceMappingStart(args);
                this.writeToken(callNode.argumentList.openParenToken);
                this.emitThis();
                if (args && args.length > 0) {
                    this.writeToOutput(", ");
                    this.emitCommaSeparatedList(callNode.argumentList, args, "", false);
                }
            } else {
                if (callNode.expression.kind() === 50 /* SuperKeyword */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("_super.call");
                } else {
                    this.emitJavascript(target, false);
                }
                this.recordSourceMappingStart(args);
                this.writeToken(callNode.argumentList.openParenToken);
                if (callNode.expression.kind() === 50 /* SuperKeyword */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("this");
                    if (args && args.length > 0) {
                        this.writeToOutput(", ");
                    }
                }
                this.emitCommaSeparatedList(callNode.argumentList, args, "", false);
            }

            this.writeToken(callNode.argumentList.closeParenToken);
            this.recordSourceMappingEnd(args);
            this.recordSourceMappingEnd(callNode);
        };

        Emitter.prototype.emitParameterList = function (list) {
            this.writeToken(list.openParenToken);
            this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenTrailingComments(list.openParenToken, this.text()), true, true);
            this.emitFunctionParameters(list.parameters, list.parameters);
            this.writeToken(list.closeParenToken);
        };

        Emitter.prototype.emitFunctionParameters = function (ast, parameters) {
            var argsLen = 0;

            if (parameters) {
                this.emitComments(ast, true);

                var tempContainer = this.setContainer(6 /* Args */);
                argsLen = parameters.length;
                var printLen = argsLen;
                if (lastParameterIsRest(parameters)) {
                    printLen--;
                }
                for (var i = 0; i < printLen; i++) {
                    var arg = parameters[i];
                    this.emit(arg);

                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                        if (parameters) {
                            this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenTrailingComments(parameters.separatorAt(i), this.text()), true, true);
                        }
                    }
                }
                this.setContainer(tempContainer);

                this.emitComments(ast, false);
            }
        };

        Emitter.prototype.emitFunctionBodyStatements = function (name, funcDecl, parameters, block, bodyExpression) {
            this.writeLineToOutput(" {");
            if (name) {
                this.recordSourceMappingNameStart(name);
            }

            this.indenter.increaseIndent();

            if (block) {
                this.emitDetachedComments(block.statements);
            }

            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (parameters) {
                this.emitDefaultValueAssignments(parameters);
                this.emitRestParameterInitializer(parameters);
            }

            if (block) {
                this.emitList(block.statements);
                this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenLeadingComments(block.closeBraceToken, this.text()), false);
            } else {
                this.emitIndent();
                this.emitCommentsArray(TypeScript.ASTHelpers.preComments(bodyExpression, this.text()), false);
                this.writeToOutput("return ");
                this.emit(bodyExpression);
                this.writeLineToOutput(";");
                this.emitCommentsArray(TypeScript.ASTHelpers.preComments(bodyExpression, this.text()), true);
            }

            this.indenter.decreaseIndent();
            this.emitIndent();

            if (block) {
                this.writeToken(block.closeBraceToken);
            } else {
                this.writeToOutputWithSourceMapRecord("}", bodyExpression);
            }

            if (name) {
                this.recordSourceMappingNameEnd();
            }
        };

        Emitter.prototype.emitDefaultValueAssignments = function (parameters) {
            var n = parameters.length;
            if (lastParameterIsRest(parameters)) {
                n--;
            }

            for (var i = 0; i < n; i++) {
                var arg = parameters[i];
                var id = arg.identifier;
                var equalsValueClause = arg.equalsValueClause;
                if (equalsValueClause) {
                    this.emitIndent();
                    this.recordSourceMappingStart(arg);
                    this.writeToOutput("if (typeof " + id.text() + " === \"undefined\") { ");
                    this.writeToken(id);
                    this.emitJavascript(equalsValueClause, false);
                    this.writeLineToOutput("; }");
                    this.recordSourceMappingEnd(arg);
                }
            }
        };

        Emitter.prototype.emitRestParameterInitializer = function (parameters) {
            if (lastParameterIsRest(parameters)) {
                var n = parameters.length;
                var lastArg = parameters[n - 1];
                var id = lastArg.identifier;
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.writeToken(id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.writeToOutputWithSourceMapRecord("var _i = 0;", lastArg);
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord("_i < (arguments.length - " + (n - 1) + ")", lastArg);
                this.writeToOutput("; ");
                this.writeToOutputWithSourceMapRecord("_i++", lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.writeToOutputWithSourceMapRecord(id.text() + "[_i] = arguments[_i + " + (n - 1) + "];", lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
        };

        Emitter.prototype.getImportDecls = function (fileName) {
            var topLevelDecl = this.semanticInfoChain.topLevelDecl(this.document.fileName);
            var result = [];

            var dynamicModuleDecl = topLevelDecl.getChildDecls()[0];
            var queue = dynamicModuleDecl.getChildDecls();

            for (var i = 0, n = queue.length; i < n; i++) {
                var decl = queue[i];

                if (decl.kind & 128 /* TypeAlias */) {
                    var importStatementAST = this.semanticInfoChain.getASTForDecl(decl);
                    if (importStatementAST.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                        var symbol = decl.getSymbol(this.semanticInfoChain);
                        var typeSymbol = symbol && symbol.type;
                        if (typeSymbol && typeSymbol !== this.semanticInfoChain.anyTypeSymbol && !typeSymbol.isError()) {
                            result.push(decl);
                        }
                    }
                }
            }

            return result;
        };

        Emitter.prototype.getModuleImportAndDependencyList = function (sourceUnit) {
            var importList = "";
            var dependencyList = "";

            var importDecls = this.getImportDecls(this.document.fileName);

            if (importDecls.length) {
                for (var i = 0; i < importDecls.length; i++) {
                    var importStatementDecl = importDecls[i];
                    var importStatementSymbol = importStatementDecl.getSymbol(this.semanticInfoChain);
                    var importStatementAST = this.semanticInfoChain.getASTForDecl(importStatementDecl);

                    if (importStatementSymbol.isUsedAsValue()) {
                        if (i <= importDecls.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }

                        importList += importStatementDecl.name;
                        dependencyList += importStatementAST.moduleReference.stringLiteral.text();
                    }
                }
            }

            var amdDependencies = this.document.syntaxTree().amdDependencies();
            for (var i = 0; i < amdDependencies.length; i++) {
                dependencyList += ", \"" + amdDependencies[i] + "\"";
            }

            return {
                importList: importList,
                dependencyList: dependencyList
            };
        };

        Emitter.prototype.shouldCaptureThis = function (ast) {
            if (ast.kind() === 120 /* SourceUnit */) {
                var scriptDecl = this.semanticInfoChain.topLevelDecl(this.document.fileName);
                return TypeScript.hasFlag(scriptDecl.flags, 262144 /* MustCaptureThis */);
            }

            var decl = this.semanticInfoChain.getDeclForAST(ast);
            if (decl) {
                return TypeScript.hasFlag(decl.flags, 262144 /* MustCaptureThis */);
            }

            return false;
        };

        Emitter.prototype.emitEnum = function (moduleDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl);
            this.pushDecl(pullDecl);

            var svModuleName = this.moduleName;
            this.moduleName = moduleDecl.identifier.text();

            var temp = this.setContainer(1 /* Module */);
            var isExported = TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */);

            if (!isExported) {
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("var ");
                this.writeToOutputWithSourceMapRecord(this.moduleName, moduleDecl.identifier);
                this.writeLineToOutput(";");
                this.recordSourceMappingEnd(moduleDecl);
                this.emitIndent();
            }

            this.writeToOutput("(");
            this.recordSourceMappingStart(moduleDecl);
            this.writeToOutput("function (");
            this.writeToOutputWithSourceMapRecord(this.moduleName, moduleDecl.identifier);
            this.writeLineToOutput(") {");

            this.recordSourceMappingNameStart(this.moduleName);

            this.indenter.increaseIndent();

            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }

            this.emitSeparatedList(moduleDecl.enumElements);
            this.indenter.decreaseIndent();
            this.emitIndent();

            var parentIsDynamic = temp === 2 /* DynamicModule */;
            if (temp === 0 /* Prog */ && isExported) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
            } else if (isExported || temp === 0 /* Prog */) {
                var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
            } else if (!isExported && temp !== 0 /* Prog */) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
            } else {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")();");
            }

            this.recordSourceMappingEnd(moduleDecl);
            if (temp !== 0 /* Prog */ && isExported) {
                this.recordSourceMappingStart(moduleDecl);
                if (parentIsDynamic) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                } else {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                }
                this.recordSourceMappingEnd(moduleDecl);
            }

            this.setContainer(temp);
            this.moduleName = svModuleName;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.getModuleDeclToVerifyChildNameCollision = function (moduleDecl, changeNameIfAnyDeclarationInContext) {
            if (TypeScript.ArrayUtilities.contains(this.declStack, moduleDecl)) {
                return moduleDecl;
            } else if (changeNameIfAnyDeclarationInContext) {
                var symbol = moduleDecl.getSymbol(this.semanticInfoChain);
                if (symbol) {
                    var otherDecls = symbol.getDeclarations();
                    for (var i = 0; i < otherDecls.length; i++) {
                        if (TypeScript.ArrayUtilities.contains(this.declStack, otherDecls[i])) {
                            return otherDecls[i];
                        }
                    }
                }
            }

            return null;
        };

        Emitter.prototype.hasChildNameCollision = function (moduleName, parentDecl) {
            var _this = this;
            var childDecls = parentDecl.getChildDecls();
            return TypeScript.ArrayUtilities.any(childDecls, function (childDecl) {
                var childAST = _this.semanticInfoChain.getASTForDecl(childDecl);

                if (childDecl.kind != 67108864 /* EnumMember */ && _this.shouldEmit(childAST)) {
                    if (childDecl.name === moduleName) {
                        if (parentDecl.kind != 8 /* Class */) {
                            return true;
                        }

                        if (!(childDecl.kind == 65536 /* Method */ || childDecl.kind == 4096 /* Property */ || childDecl.kind == 524288 /* SetAccessor */ || childDecl.kind == 262144 /* GetAccessor */)) {
                            return true;
                        }
                    }

                    if (_this.hasChildNameCollision(moduleName, childDecl)) {
                        return true;
                    }
                }
                return false;
            });
        };

        Emitter.prototype.getModuleName = function (moduleDecl, changeNameIfAnyDeclarationInContext) {
            var moduleName = moduleDecl.name;
            var moduleDisplayName = moduleDecl.getDisplayName();

            moduleDecl = this.getModuleDeclToVerifyChildNameCollision(moduleDecl, changeNameIfAnyDeclarationInContext);
            if (moduleDecl && moduleDecl.kind != 64 /* Enum */) {
                while (this.hasChildNameCollision(moduleName, moduleDecl)) {
                    moduleName = "_" + moduleName;
                    moduleDisplayName = "_" + moduleDisplayName;
                }
            }

            return moduleDisplayName;
        };

        Emitter.prototype.emitModuleDeclarationWorker = function (moduleDecl) {
            if (moduleDecl.stringLiteral) {
                this.emitSingleModuleDeclaration(moduleDecl, moduleDecl.stringLiteral);
            } else {
                var moduleNames = TypeScript.ASTHelpers.getModuleNames(moduleDecl.name);
                this.emitSingleModuleDeclaration(moduleDecl, moduleNames[0]);
            }
        };

        Emitter.prototype.writeToken = function (token) {
            if (token) {
                this.writeToOutputWithSourceMapRecord(token.text(), token);
            }
        };

        Emitter.prototype.emitSingleModuleDeclaration = function (moduleDecl, moduleName) {
            var isLastName = TypeScript.ASTHelpers.isLastNameOfModule(moduleDecl, moduleName);

            if (isLastName) {
                this.emitComments(moduleDecl, true);
            }

            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleName);
            this.pushDecl(pullDecl);

            var svModuleName = this.moduleName;

            if (moduleDecl.stringLiteral) {
                this.moduleName = TypeScript.tokenValueText(moduleDecl.stringLiteral);
                if (TypeScript.isTSFile(this.moduleName)) {
                    this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
                }
            } else {
                this.moduleName = moduleName.text();
            }

            var temp = this.setContainer(1 /* Module */);
            var isExported = TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */);

            if (!isExported) {
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("var ");
                this.writeToOutputWithSourceMapRecord(this.moduleName, moduleName);
                this.writeLineToOutput(";");
                this.recordSourceMappingEnd(moduleDecl);
                this.emitIndent();
            }

            this.writeToOutput("(");
            this.recordSourceMappingStart(moduleDecl);
            this.writeToOutput("function (");

            this.moduleName = this.getModuleName(pullDecl);
            this.writeToOutputWithSourceMapRecord(this.moduleName, moduleName);
            this.writeLineToOutput(") {");

            this.recordSourceMappingNameStart(moduleName.text());

            this.indenter.increaseIndent();

            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }

            if (moduleName === moduleDecl.stringLiteral) {
                this.emitList(moduleDecl.moduleElements);
            } else {
                var moduleNames = TypeScript.ASTHelpers.getModuleNames(moduleDecl.name);
                var nameIndex = moduleNames.indexOf(moduleName);

                TypeScript.Debug.assert(nameIndex >= 0);

                if (isLastName) {
                    this.emitList(moduleDecl.moduleElements);
                } else {
                    this.emitIndent();
                    this.emitSingleModuleDeclaration(moduleDecl, moduleNames[nameIndex + 1]);
                    this.writeLineToOutput("");
                }
            }

            this.moduleName = moduleName.text();
            this.indenter.decreaseIndent();
            this.emitIndent();

            var parentIsDynamic = temp === 2 /* DynamicModule */;
            this.recordSourceMappingStart(moduleDecl.closeBraceToken);
            if (temp === 0 /* Prog */ && isExported) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
            } else if (isExported || temp === 0 /* Prog */) {
                var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
            } else if (!isExported && temp !== 0 /* Prog */) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
            } else {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")();");
            }

            this.recordSourceMappingEnd(moduleDecl);
            if (temp !== 0 /* Prog */ && isExported) {
                this.recordSourceMappingStart(moduleDecl);
                if (parentIsDynamic) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                } else {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                }
                this.recordSourceMappingEnd(moduleDecl);
            }

            this.setContainer(temp);
            this.moduleName = svModuleName;

            this.popDecl(pullDecl);

            if (isLastName) {
                this.emitComments(moduleDecl, false);
            }
        };

        Emitter.prototype.emitEnumElement = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            TypeScript.Debug.assert(pullDecl && pullDecl.kind === 67108864 /* EnumMember */);

            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);

            var representation = (varDecl.propertyName.kind() === 14 /* StringLiteral */) ? varDecl.propertyName.text() : ('"' + TypeScript.tokenValueText(varDecl.propertyName) + '"');

            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(representation);
            this.writeToOutput(']');

            if (varDecl.equalsValueClause) {
                this.emit(varDecl.equalsValueClause);
            } else if (pullDecl.constantValue !== null) {
                this.writeToOutput(' = ');
                this.writeToOutput(pullDecl.constantValue.toString());
            } else {
                this.writeToOutput(' = null');
            }

            this.writeToOutput('] = ');
            this.writeToOutput(representation);
            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);
            this.writeToOutput(';');
        };

        Emitter.prototype.emitElementAccessExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.emit(expression.expression);
            this.writeToken(expression.openBracketToken);
            this.emit(expression.argumentExpression);
            this.writeToken(expression.closeBracketToken);
            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitSimpleArrowFunctionExpression = function (arrowFunction) {
            this.emitAnyArrowFunctionExpression(arrowFunction, arrowFunction.block, arrowFunction.expression);
        };

        Emitter.prototype.emitParenthesizedArrowFunctionExpression = function (arrowFunction) {
            this.emitAnyArrowFunctionExpression(arrowFunction, arrowFunction.block, arrowFunction.expression);
        };

        Emitter.prototype.emitAnyArrowFunctionExpression = function (arrowFunction, block, expression) {
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = true;

            var temp = this.setContainer(5 /* Function */);

            this.recordSourceMappingStart(arrowFunction);

            var pullDecl = this.semanticInfoChain.getDeclForAST(arrowFunction);
            this.pushDecl(pullDecl);

            this.emitComments(arrowFunction, true);

            this.recordSourceMappingStart(arrowFunction);
            this.writeToOutput("function ");

            var parameters = null;
            if (arrowFunction.kind() === 219 /* ParenthesizedArrowFunctionExpression */) {
                var parenthesizedArrowFunction = arrowFunction;

                parameters = parenthesizedArrowFunction.callSignature.parameterList.parameters;
                this.emitParameterList(parenthesizedArrowFunction.callSignature.parameterList);
            } else {
                var parameter = arrowFunction.parameter;
                parameters = [parameter];
                this.writeToOutput("(");
                this.emitFunctionParameters(parameter, parameters);
                this.writeToOutput(")");
            }

            this.emitFunctionBodyStatements(null, arrowFunction, parameters, block, expression);

            this.recordSourceMappingEnd(arrowFunction);

            this.recordSourceMappingEnd(arrowFunction);

            this.emitComments(arrowFunction, false);

            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        };

        Emitter.prototype.emitConstructor = function (funcDecl) {
            if (!funcDecl.block) {
                return;
            }
            var temp = this.setContainer(4 /* Constructor */);

            this.recordSourceMappingStart(funcDecl);

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.emitComments(funcDecl, true);

            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            this.writeToOutput(this.thisClassNode.identifier.text());

            this.emitParameterList(funcDecl.callSignature.parameterList);
            this.writeLineToOutput(" {");

            this.recordSourceMappingNameStart("constructor");
            this.indenter.increaseIndent();

            var parameters = funcDecl.callSignature.parameterList.parameters;
            this.emitDefaultValueAssignments(parameters);
            this.emitRestParameterInitializer(parameters);

            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            this.emitConstructorStatements(funcDecl);
            this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenLeadingComments(funcDecl.block.closeBraceToken, this.text()), false);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(funcDecl.block.closeBraceToken);

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl);

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);
            this.setContainer(temp);
        };

        Emitter.prototype.emitGetAccessor = function (accessor) {
            this.recordSourceMappingStart(accessor);
            this.writeToOutput("get ");

            var temp = this.setContainer(5 /* Function */);

            this.recordSourceMappingStart(accessor);

            var pullDecl = this.semanticInfoChain.getDeclForAST(accessor);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(accessor);

            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(accessor, this.semanticInfoChain);
            var container = accessorSymbol.getContainer();
            var containerKind = container.kind;

            this.recordSourceMappingNameStart(accessor.propertyName.text());
            this.writeToOutput(accessor.propertyName.text());
            this.emitParameterList(accessor.callSignature.parameterList);

            this.emitFunctionBodyStatements(null, accessor, accessor.callSignature.parameterList.parameters, accessor.block, null);

            this.recordSourceMappingEnd(accessor);

            this.recordSourceMappingEnd(accessor);

            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.recordSourceMappingEnd(accessor);
        };

        Emitter.prototype.emitSetAccessor = function (accessor) {
            this.recordSourceMappingStart(accessor);
            this.writeToOutput("set ");

            var temp = this.setContainer(5 /* Function */);

            this.recordSourceMappingStart(accessor);

            var pullDecl = this.semanticInfoChain.getDeclForAST(accessor);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(accessor);

            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(accessor, this.semanticInfoChain);
            var container = accessorSymbol.getContainer();
            var containerKind = container.kind;

            this.recordSourceMappingNameStart(accessor.propertyName.text());
            this.writeToOutput(accessor.propertyName.text());

            this.emitParameterList(accessor.callSignature.parameterList);

            this.emitFunctionBodyStatements(null, accessor, accessor.callSignature.parameterList.parameters, accessor.block, null);

            this.recordSourceMappingEnd(accessor);

            this.recordSourceMappingEnd(accessor);

            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.recordSourceMappingEnd(accessor);
        };

        Emitter.prototype.emitFunctionExpression = function (funcDecl) {
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;

            var temp = this.setContainer(5 /* Function */);

            var funcName = funcDecl.identifier ? funcDecl.identifier.text() : null;

            this.recordSourceMappingStart(funcDecl);

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcDecl);
            this.writeToken(funcDecl.functionKeyword);
            this.writeToOutput(" ");

            if (funcDecl.identifier) {
                this.writeToOutputWithSourceMapRecord(funcDecl.identifier.text(), funcDecl.identifier);
            }

            this.emitParameterList(funcDecl.callSignature.parameterList);
            this.emitFunctionBodyStatements(funcName, funcDecl, funcDecl.callSignature.parameterList.parameters, funcDecl.block, null);

            this.recordSourceMappingEnd(funcDecl);

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);

            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        };

        Emitter.prototype.emitFunction = function (funcDecl) {
            if (funcDecl.block === null) {
                return;
            }
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;

            var temp = this.setContainer(5 /* Function */);

            var funcName = funcDecl.identifier.text();

            this.recordSourceMappingStart(funcDecl);

            var printName = funcDecl.identifier !== null;
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.emitComments(funcDecl, true);

            this.recordSourceMappingStart(funcDecl);
            this.writeToken(funcDecl.functionKeyword);
            this.writeToOutput(" ");

            if (printName) {
                var id = funcDecl.identifier.text();
                if (id) {
                    if (funcDecl.identifier) {
                        this.recordSourceMappingStart(funcDecl.identifier);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.identifier) {
                        this.recordSourceMappingEnd(funcDecl.identifier);
                    }
                }
            }

            this.emitParameterList(funcDecl.callSignature.parameterList);

            var parameters = funcDecl.callSignature.parameterList.parameters;
            this.emitFunctionBodyStatements(funcDecl.identifier.text(), funcDecl, parameters, funcDecl.block, null);

            this.recordSourceMappingEnd(funcDecl);

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);

            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;

            if (funcDecl.block) {
                var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
                if ((this.emitState.container === 1 /* Module */ || this.emitState.container === 2 /* DynamicModule */) && pullFunctionDecl && TypeScript.hasFlag(pullFunctionDecl.flags, 1 /* Exported */)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = this.emitState.container === 1 /* Module */ ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };

        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {
            this.recordSourceMappingStart(this.currentVariableDeclaration);
            if (varDecl.equalsValueClause) {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.writeToOutputWithSourceMapRecord(varDecl.propertyName.text(), varDecl.propertyName);
                this.emitJavascript(varDecl.equalsValueClause, false);
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
        };

        Emitter.prototype.emitVarDeclVar = function () {
            if (this.currentVariableDeclaration) {
                this.writeToOutput("var ");
            }
        };

        Emitter.prototype.emitVariableDeclaration = function (declaration) {
            var varDecl = declaration.variableDeclarators[0];

            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);

            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentKind = parentSymbol ? parentSymbol.kind : 0 /* None */;

            this.emitComments(declaration, true);

            var pullVarDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            var isAmbientWithoutInit = pullVarDecl && TypeScript.hasFlag(pullVarDecl.flags, 8 /* Ambient */) && varDecl.equalsValueClause === null;
            if (!isAmbientWithoutInit) {
                var prevVariableDeclaration = this.currentVariableDeclaration;
                this.currentVariableDeclaration = declaration;

                for (var i = 0, n = declaration.variableDeclarators.length; i < n; i++) {
                    var declarator = declaration.variableDeclarators[i];

                    if (i > 0) {
                        this.writeToOutput(", ");
                    }

                    this.emit(declarator);
                }
                this.currentVariableDeclaration = prevVariableDeclaration;

                this.recordSourceMappingEnd(declaration);
            }

            this.emitComments(declaration, false);
        };

        Emitter.prototype.emitMemberVariableDeclaration = function (varDecl) {
            TypeScript.Debug.assert(!TypeScript.hasModifier(varDecl.modifiers, 16 /* Static */) && varDecl.variableDeclarator.equalsValueClause);

            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            this.pushDecl(pullDecl);

            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);

            var varDeclName = varDecl.variableDeclarator.propertyName.text();
            var quotedOrNumber = TypeScript.isQuoted(varDeclName) || varDecl.variableDeclarator.propertyName.kind() !== 11 /* IdentifierName */;

            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);
            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentDecl = pullDecl && pullDecl.getParentDecl();

            if (quotedOrNumber) {
                this.writeToOutput("this[");
            } else {
                this.writeToOutput("this.");
            }

            this.writeToOutputWithSourceMapRecord(varDecl.variableDeclarator.propertyName.text(), varDecl.variableDeclarator.propertyName);

            if (quotedOrNumber) {
                this.writeToOutput("]");
            }

            if (varDecl.variableDeclarator.equalsValueClause) {
                var prevVariableDeclaration = this.currentVariableDeclaration;
                this.emit(varDecl.variableDeclarator.equalsValueClause);
                this.currentVariableDeclaration = prevVariableDeclaration;
            }

            if (this.emitState.container !== 6 /* Args */) {
                this.writeToOutput(";");
            }

            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitVariableDeclarator = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            this.pushDecl(pullDecl);
            if (pullDecl && (pullDecl.flags & 8 /* Ambient */) === 8 /* Ambient */) {
                this.emitAmbientVarDecl(varDecl);
            } else {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(this.currentVariableDeclaration);
                this.recordSourceMappingStart(varDecl);

                var varDeclName = varDecl.propertyName.text();

                var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);
                var parentSymbol = symbol ? symbol.getContainer() : null;
                var parentDecl = pullDecl && pullDecl.getParentDecl();
                var parentIsModule = parentDecl && (parentDecl.flags & 102400 /* SomeInitializedModule */);

                if (parentIsModule) {
                    if (!TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */)) {
                        this.emitVarDeclVar();
                    } else {
                        if (this.emitState.container === 2 /* DynamicModule */) {
                            this.writeToOutput("exports.");
                        } else {
                            this.writeToOutput(this.moduleName + ".");
                        }
                    }
                } else {
                    this.emitVarDeclVar();
                }

                this.writeToOutputWithSourceMapRecord(varDecl.propertyName.text(), varDecl.propertyName);

                if (varDecl.equalsValueClause) {
                    var prevVariableDeclaration = this.currentVariableDeclaration;
                    this.emit(varDecl.equalsValueClause);
                    this.currentVariableDeclaration = prevVariableDeclaration;
                }

                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
            this.currentVariableDeclaration = undefined;
            this.popDecl(pullDecl);
        };

        Emitter.prototype.symbolIsUsedInItsEnclosingContainer = function (symbol, dynamic) {
            if (typeof dynamic === "undefined") { dynamic = false; }
            var symDecls = symbol.getDeclarations();

            if (symDecls.length) {
                var enclosingDecl = this.getEnclosingDecl();
                if (enclosingDecl) {
                    var parentDecl = symDecls[0].getParentDecl();
                    if (parentDecl) {
                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;

                        while (symbolDeclarationEnclosingContainer) {
                            if (symbolDeclarationEnclosingContainer.kind === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                break;
                            }
                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }

                        if (symbolDeclarationEnclosingContainer) {
                            while (enclosingContainer) {
                                if (enclosingContainer.kind === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                    break;
                                }

                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }

                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer === enclosingContainer;

                            if (!same && symbol.anyDeclHasFlag(32768 /* InitializedModule */)) {
                                same = symbolDeclarationEnclosingContainer === enclosingContainer.getParentDecl();
                            }

                            return same;
                        }
                    }
                }
            }

            return false;
        };

        Emitter.prototype.shouldQualifySymbolNameWithParentName = function (symbol) {
            var enclosingContextDeclPath = this.declStack;
            var symbolDeclarations = symbol.getDeclarations();
            for (var i = 0; i < symbolDeclarations.length; i++) {
                var currentDecl = symbolDeclarations[i];
                var declParent = currentDecl.getParentDecl();

                if (currentDecl.kind === 67108864 /* EnumMember */) {
                    return true;
                }

                if (!TypeScript.hasFlag(currentDecl.flags, 1 /* Exported */)) {
                    return false;
                }

                if (currentDecl.kind === 512 /* Variable */ && !TypeScript.hasFlag(currentDecl.flags, 118784 /* ImplicitVariable */)) {
                    return true;
                }

                if (TypeScript.ArrayUtilities.contains(this.declStack, declParent)) {
                    return false;
                }
            }

            return true;
        };

        Emitter.prototype.getSymbolForEmit = function (ast) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(ast);
            var pullSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(ast);
            if (pullSymbol && pullSymbolAlias) {
                var symbolToCompare = TypeScript.isTypesOnlyLocation(ast) ? pullSymbolAlias.getExportAssignedTypeSymbol() : pullSymbolAlias.getExportAssignedValueSymbol();

                if (pullSymbol === symbolToCompare) {
                    pullSymbol = pullSymbolAlias;
                    pullSymbolAlias = null;
                }
            }
            return { symbol: pullSymbol, aliasSymbol: pullSymbolAlias };
        };

        Emitter.prototype.emitName = function (name, addThis) {
            this.emitComments(name, true);
            this.recordSourceMappingStart(name);
            if (name.text().length > 0) {
                var symbolForEmit = this.getSymbolForEmit(name);
                var pullSymbol = symbolForEmit.symbol;
                if (!pullSymbol) {
                    pullSymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                var pullSymbolAlias = symbolForEmit.aliasSymbol;
                var pullSymbolKind = pullSymbol.kind;
                var isLocalAlias = pullSymbolAlias && (pullSymbolAlias.getDeclarations()[0].getParentDecl() === this.getEnclosingDecl());
                if (addThis && (this.emitState.container !== 6 /* Args */) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();

                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.kind;

                        if (TypeScript.PullHelpers.symbolIsModule(pullSymbolContainer) || pullSymbolContainerKind === 64 /* Enum */ || pullSymbolContainer.anyDeclHasFlag(32768 /* InitializedModule */ | 4096 /* Enum */)) {
                            var needToEmitParentName = this.shouldQualifySymbolNameWithParentName(pullSymbol);
                            if (needToEmitParentName) {
                                var parentDecl = pullSymbol.getDeclarations()[0].getParentDecl();
                                TypeScript.Debug.assert(parentDecl && !parentDecl.isRootDecl());
                                this.writeToOutput(this.getModuleName(parentDecl, true) + ".");
                            }
                        } else if (pullSymbolContainerKind === 32 /* DynamicModule */ || pullSymbolContainer.anyDeclHasFlag(65536 /* InitializedDynamicModule */)) {
                            if (pullSymbolKind === 4096 /* Property */) {
                                this.writeToOutput("exports.");
                            } else if (pullSymbol.anyDeclHasFlag(1 /* Exported */) && !isLocalAlias && !pullSymbol.anyDeclHasFlag(118784 /* ImplicitVariable */) && pullSymbol.kind !== 32768 /* ConstructorMethod */ && pullSymbol.kind !== 8 /* Class */ && pullSymbol.kind !== 64 /* Enum */) {
                                this.writeToOutput("exports.");
                            }
                        }
                    }
                }

                this.writeToOutput(name.text());
            }

            this.recordSourceMappingEnd(name);
            this.emitComments(name, false);
        };

        Emitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var nameIndex = -1;
                if (name) {
                    if (this.sourceMapper.currentNameIndex.length > 0) {
                        var parentNameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                        if (parentNameIndex !== -1) {
                            name = this.sourceMapper.names[parentNameIndex] + "." + name;
                        }
                    }

                    var nameIndex = this.sourceMapper.names.length - 1;
                    for (nameIndex; nameIndex >= 0; nameIndex--) {
                        if (this.sourceMapper.names[nameIndex] === name) {
                            break;
                        }
                    }

                    if (nameIndex === -1) {
                        nameIndex = this.sourceMapper.names.length;
                        this.sourceMapper.names.push(name);
                    }
                }
                this.sourceMapper.currentNameIndex.push(nameIndex);
            }
        };

        Emitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };

        Emitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.ASTHelpers.isValidAstNode(ast)) {
                var text = this.text();
                this.recordSourceMappingSpanStart(ast, TypeScript.start(ast, text), TypeScript.end(ast, text));
            }
        };

        Emitter.prototype.recordSourceMappingCommentStart = function (comment) {
            this.recordSourceMappingSpanStart(comment, comment.start(), comment.end());
        };

        Emitter.prototype.recordSourceMappingSpanStart = function (ast, start, end) {
            if (this.sourceMapper && ast && start !== -1 && end !== -1) {
                var lineCol = { line: -1, character: -1 };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;

                var lineMap = this.document.lineMap();
                lineMap.fillLineAndCharacterFromPosition(start, lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(end, lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;

                TypeScript.Debug.assert(!isNaN(sourceMapping.start.emittedColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.start.emittedLine));
                TypeScript.Debug.assert(!isNaN(sourceMapping.start.sourceColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.start.sourceLine));
                TypeScript.Debug.assert(!isNaN(sourceMapping.end.sourceColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.end.sourceLine));

                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
                this.sourceMapper.increaseMappingLevel(ast);
            }
        };

        Emitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.ASTHelpers.isValidAstNode(ast)) {
                var text = this.text();
                this.recordSourceMappingSpanEnd(ast, TypeScript.start(ast, text), TypeScript.end(ast, text));
            }
        };

        Emitter.prototype.recordSourceMappingCommentEnd = function (ast) {
            if (this.sourceMapper && TypeScript.ASTHelpers.isValidSpan(ast)) {
                this.recordSourceMappingSpanEnd(ast, ast.start(), ast.end());
            }
        };

        Emitter.prototype.recordSourceMappingSpanEnd = function (ast, start, end) {
            if (this.sourceMapper && ast && start !== -1 && end !== -1) {
                this.sourceMapper.currentMappings.pop();

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;

                TypeScript.Debug.assert(!isNaN(sourceMapping.end.emittedColumn));
                TypeScript.Debug.assert(!isNaN(sourceMapping.end.emittedLine));

                this.sourceMapper.decreaseMappingLevel(ast);
            }
        };

        Emitter.prototype.getOutputFiles = function () {
            var result = [];
            if (this.sourceMapper !== null) {
                this.sourceMapper.emitSourceMapping();
                result.push(this.sourceMapper.getOutputFile());
            }

            result.push(this.outfile.getOutputFile());
            return result;
        };

        Emitter.prototype.emitParameterPropertyAndMemberVariableAssignments = function () {
            var constructorDecl = getLastConstructor(this.thisClassNode);

            if (constructorDecl) {
                for (var i = 0, n = constructorDecl.callSignature.parameterList.parameters.length; i < n; i++) {
                    var parameter = constructorDecl.callSignature.parameterList.parameters[i];

                    var parameterDecl = this.semanticInfoChain.getDeclForAST(parameter);
                    if (TypeScript.hasFlag(parameterDecl.flags, 8388608 /* PropertyParameter */)) {
                        this.emitIndent();
                        this.recordSourceMappingStart(parameter);
                        this.writeToOutputWithSourceMapRecord("this." + parameter.identifier.text(), parameter.identifier);
                        this.writeToOutput(" = ");
                        this.writeToOutputWithSourceMapRecord(parameter.identifier.text(), parameter.identifier);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(parameter);
                    }
                }
            }

            for (var i = 0, n = this.thisClassNode.classElements.length; i < n; i++) {
                if (this.thisClassNode.classElements[i].kind() === 137 /* MemberVariableDeclaration */) {
                    var varDecl = this.thisClassNode.classElements[i];
                    if (!TypeScript.hasModifier(varDecl.modifiers, 16 /* Static */) && varDecl.variableDeclarator.equalsValueClause) {
                        this.emitIndent();
                        this.emitMemberVariableDeclaration(varDecl);
                        this.writeLineToOutput("");
                    }
                }
            }
        };

        Emitter.prototype.isOnSameLine = function (pos1, pos2) {
            if (pos1 < 0 || pos2 < 0) {
                return true;
            }

            var lineMap = this.document.lineMap();
            return lineMap.getLineNumberFromPosition(pos1) === lineMap.getLineNumberFromPosition(pos2);
        };

        Emitter.prototype.emitCommaSeparatedList = function (parent, list, buffer, preserveNewLines) {
            if (list === null || list.length === 0) {
                return;
            }

            var text = this.text();
            var startLine = preserveNewLines && !this.isOnSameLine(TypeScript.end(parent, text), TypeScript.end(list[0], text));

            if (preserveNewLines) {
                this.indenter.increaseIndent();
            }

            if (startLine) {
                this.writeLineToOutput("");
            } else {
                this.writeToOutput(buffer);
            }

            for (var i = 0, n = list.length; i < n; i++) {
                var emitNode = list[i];

                this.emitJavascript(emitNode, startLine);

                if (i < (n - 1)) {
                    startLine = preserveNewLines && !this.isOnSameLine(TypeScript.end(emitNode, text), TypeScript.start(list[i + 1], text));
                    if (startLine) {
                        this.writeLineToOutput(",");
                    } else {
                        this.writeToOutput(", ");
                    }
                }
            }

            if (preserveNewLines) {
                this.indenter.decreaseIndent();
            }

            if (preserveNewLines && !this.isOnSameLine(TypeScript.end(parent, text), TypeScript.end(list[list.length - 1], text))) {
                this.writeLineToOutput("");
                this.emitIndent();
            } else {
                this.writeToOutput(buffer);
            }
        };

        Emitter.prototype.emitList = function (list, useNewLineSeparator, startInclusive, endExclusive) {
            if (typeof useNewLineSeparator === "undefined") { useNewLineSeparator = true; }
            if (typeof startInclusive === "undefined") { startInclusive = 0; }
            if (typeof endExclusive === "undefined") { endExclusive = list.length; }
            if (list === null) {
                return;
            }

            this.emitComments(list, true);
            var lastEmittedNode = null;

            for (var i = startInclusive; i < endExclusive; i++) {
                var node = list[i];

                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    if (useNewLineSeparator) {
                        this.writeLineToOutput("");
                    }

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.emitSeparatedList = function (list, useNewLineSeparator, startInclusive, endExclusive) {
            if (typeof useNewLineSeparator === "undefined") { useNewLineSeparator = true; }
            if (typeof startInclusive === "undefined") { startInclusive = 0; }
            if (typeof endExclusive === "undefined") { endExclusive = list.length; }
            if (list === null) {
                return;
            }

            this.emitComments(list, true);
            var lastEmittedNode = null;

            for (var i = startInclusive; i < endExclusive; i++) {
                var node = list[i];

                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    if (useNewLineSeparator) {
                        this.writeLineToOutput("");
                    }

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.isDirectivePrologueElement = function (node) {
            if (node.kind() === 150 /* ExpressionStatement */) {
                var exprStatement = node;
                return exprStatement.expression.kind() === 14 /* StringLiteral */;
            }

            return false;
        };

        Emitter.prototype.emitSpaceBetweenConstructs = function (node1, node2) {
            if (node1 === null || node2 === null) {
                return;
            }

            var text = this.text();
            if (TypeScript.start(node1, text) === -1 || TypeScript.end(node1, text) === -1 || TypeScript.start(node2, text) === -1 || TypeScript.end(node2, text) === -1) {
                return;
            }

            var lineMap = this.document.lineMap();
            var node1EndLine = lineMap.getLineNumberFromPosition(TypeScript.end(node1, text));
            var node2StartLine = lineMap.getLineNumberFromPosition(TypeScript.start(node2, text));

            if ((node2StartLine - node1EndLine) > 1) {
                this.writeLineToOutput("", true);
            }
        };

        Emitter.prototype.getDetachedComments = function (element) {
            var text = this.text();
            var preComments = TypeScript.ASTHelpers.preComments(element, text);
            if (preComments) {
                var lineMap = this.document.lineMap();

                var detachedComments = [];
                var lastComment = null;

                for (var i = 0, n = preComments.length; i < n; i++) {
                    var comment = preComments[i];

                    if (lastComment) {
                        var lastCommentLine = lineMap.getLineNumberFromPosition(lastComment.end());
                        var commentLine = lineMap.getLineNumberFromPosition(comment.start());

                        if (commentLine >= lastCommentLine + 2) {
                            return detachedComments;
                        }
                    }

                    detachedComments.push(comment);
                    lastComment = comment;
                }

                var lastCommentLine = lineMap.getLineNumberFromPosition(TypeScript.ArrayUtilities.last(detachedComments).end());
                var astLine = lineMap.getLineNumberFromPosition(TypeScript.start(element, text));
                if (astLine >= lastCommentLine + 2) {
                    return detachedComments;
                }
            }

            return [];
        };

        Emitter.prototype.emitPossibleCopyrightHeaders = function (script) {
            this.emitDetachedComments(script.moduleElements);
        };

        Emitter.prototype.emitDetachedComments = function (list) {
            if (list.length > 0) {
                var firstElement = TypeScript.childAt(list, 0);

                this.detachedCommentsElement = firstElement;
                this.emitCommentsArray(this.getDetachedComments(this.detachedCommentsElement), false);
            }
        };

        Emitter.prototype.emitScriptElements = function (sourceUnit) {
            var list = sourceUnit.moduleElements;

            this.emitPossibleCopyrightHeaders(sourceUnit);

            for (var i = 0, n = list.length; i < n; i++) {
                var node = list[i];

                if (!this.isDirectivePrologueElement(node)) {
                    break;
                }

                this.emitJavascript(node, true);
                this.writeLineToOutput("");
            }

            this.emitPrologue(sourceUnit);

            var isExternalModule = this.document.syntaxTree().isExternalModule();
            var isNonElidedExternalModule = isExternalModule && !TypeScript.ASTHelpers.scriptIsElided(sourceUnit);
            if (isNonElidedExternalModule) {
                this.recordSourceMappingStart(sourceUnit);

                if (this.emitOptions.compilationSettings().moduleGenTarget() === 2 /* Asynchronous */) {
                    var dependencyList = "[\"require\", \"exports\"";
                    var importList = "require, exports";

                    var importAndDependencyList = this.getModuleImportAndDependencyList(sourceUnit);
                    importList += importAndDependencyList.importList;
                    dependencyList += importAndDependencyList.dependencyList + "]";

                    this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                }
            }

            if (isExternalModule) {
                var temp = this.setContainer(2 /* DynamicModule */);

                var svModuleName = this.moduleName;
                this.moduleName = TypeScript.syntaxTree(sourceUnit).fileName();
                if (TypeScript.isTSFile(this.moduleName)) {
                    this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
                }

                this.setExportAssignment(null);

                if (this.emitOptions.compilationSettings().moduleGenTarget() === 2 /* Asynchronous */) {
                    this.indenter.increaseIndent();
                }

                var externalModule = this.semanticInfoChain.getDeclForAST(this.document.sourceUnit());

                if (TypeScript.hasFlag(externalModule.flags, 262144 /* MustCaptureThis */)) {
                    this.writeCaptureThisStatement(sourceUnit);
                }

                this.pushDecl(externalModule);
            }

            this.emitList(list, true, i, n);

            if (isExternalModule) {
                if (this.emitOptions.compilationSettings().moduleGenTarget() === 2 /* Asynchronous */) {
                    this.indenter.decreaseIndent();
                }

                if (isNonElidedExternalModule) {
                    var exportAssignment = this.getExportAssignment();
                    var exportAssignmentIdentifierText = exportAssignment ? exportAssignment.identifier.text() : null;
                    var exportAssignmentValueSymbol = externalModule.getSymbol(this.semanticInfoChain).getExportAssignedValueSymbol();

                    if (this.emitOptions.compilationSettings().moduleGenTarget() === 2 /* Asynchronous */) {
                        if (exportAssignmentIdentifierText && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & 58720272 /* SomeTypeReference */)) {
                            this.indenter.increaseIndent();
                            this.emitIndent();
                            this.writeToOutputWithSourceMapRecord("return " + exportAssignmentIdentifierText, exportAssignment);
                            this.writeLineToOutput(";");
                            this.indenter.decreaseIndent();
                        }
                        this.writeToOutput("});");
                    } else if (exportAssignmentIdentifierText && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & 58720272 /* SomeTypeReference */)) {
                        this.emitIndent();
                        this.writeToOutputWithSourceMapRecord("module.exports = " + exportAssignmentIdentifierText, exportAssignment);
                        this.writeToOutput(";");
                    }

                    this.recordSourceMappingEnd(sourceUnit);
                    this.writeLineToOutput("");
                }

                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.popDecl(externalModule);
            }
        };

        Emitter.prototype.emitConstructorStatements = function (funcDecl) {
            var list = funcDecl.block.statements;

            if (list === null) {
                return;
            }

            this.emitComments(list, true);

            var emitPropertyAssignmentsAfterSuperCall = TypeScript.ASTHelpers.getExtendsHeritageClause(this.thisClassNode.heritageClauses) !== null;
            var propertyAssignmentIndex = emitPropertyAssignmentsAfterSuperCall ? 1 : 0;
            var lastEmittedNode = null;

            for (var i = 0, n = list.length; i < n; i++) {
                if (i === propertyAssignmentIndex) {
                    this.emitParameterPropertyAndMemberVariableAssignments();
                }

                var node = list[i];

                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            if (i === propertyAssignmentIndex) {
                this.emitParameterPropertyAndMemberVariableAssignments();
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.emitJavascript = function (ast, startLine) {
            if (ast === null) {
                return;
            }

            if (startLine && this.indenter.indentAmt > 0) {
                this.emitIndent();
            }

            this.emit(ast);
        };

        Emitter.prototype.emitAccessorMemberDeclaration = function (funcDecl, name, className, isProto) {
            if (funcDecl.kind() !== 140 /* GetAccessor */) {
                var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain);
                if (accessorSymbol.getGetter()) {
                    return;
                }
            }

            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);

            this.writeToOutput("Object.defineProperty(" + className);
            if (isProto) {
                this.writeToOutput(".prototype, ");
            } else {
                this.writeToOutput(", ");
            }

            var functionName = name.text();
            if (TypeScript.isQuoted(functionName)) {
                this.writeToOutput(functionName);
            } else {
                this.writeToOutput('"' + functionName + '"');
            }

            this.writeLineToOutput(", {");

            this.indenter.increaseIndent();

            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain);
            if (accessors.getter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.getter);
                this.emitComments(accessors.getter, true);
                this.writeToOutput("get: ");
                this.emitAccessorBody(accessors.getter, accessors.getter.callSignature.parameterList, accessors.getter.block);
                this.writeLineToOutput(",");
            }

            if (accessors.setter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.setter);
                this.emitComments(accessors.setter, true);
                this.writeToOutput("set: ");
                this.emitAccessorBody(accessors.setter, accessors.setter.callSignature.parameterList, accessors.setter.block);
                this.writeLineToOutput(",");
            }

            this.emitIndent();
            this.writeLineToOutput("enumerable: true,");
            this.emitIndent();
            this.writeLineToOutput("configurable: true");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("});");
            this.recordSourceMappingEnd(funcDecl);
        };

        Emitter.prototype.emitAccessorBody = function (funcDecl, parameterList, block) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            this.emitParameterList(parameterList);

            var parameters = parameterList.parameters;
            this.emitFunctionBodyStatements(null, funcDecl, parameters, block, null);

            this.recordSourceMappingEnd(funcDecl);

            this.recordSourceMappingEnd(funcDecl);
            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitClass = function (classDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl);
            this.pushDecl(pullDecl);

            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var className = classDecl.identifier.text();
            this.emitComments(classDecl, true);
            var temp = this.setContainer(3 /* Class */);

            this.recordSourceMappingStart(classDecl);
            this.writeToOutput("var " + className);

            var hasBaseClass = TypeScript.ASTHelpers.getExtendsHeritageClause(classDecl.heritageClauses) !== null;
            var baseTypeReference = null;
            var varDecl = null;

            if (hasBaseClass) {
                this.writeLineToOutput(" = (function (_super) {");
            } else {
                this.writeLineToOutput(" = (function () {");
            }

            this.recordSourceMappingNameStart(className);
            this.indenter.increaseIndent();

            if (hasBaseClass) {
                baseTypeReference = TypeScript.ASTHelpers.getExtendsHeritageClause(classDecl.heritageClauses).typeNames[0];
                this.emitIndent();
                this.writeToOutputWithSourceMapRecord("__extends(" + className + ", _super)", baseTypeReference);
                this.writeLineToOutput(";");
            }

            this.emitIndent();

            var constrDecl = getLastConstructor(classDecl);

            if (constrDecl) {
                this.emit(constrDecl);
                this.writeLineToOutput("");
            } else {
                this.recordSourceMappingStart(classDecl);

                this.indenter.increaseIndent();
                this.writeLineToOutput("function " + classDecl.identifier.text() + "() {");
                this.recordSourceMappingNameStart("constructor");
                if (hasBaseClass) {
                    this.emitIndent();
                    this.writeToOutputWithSourceMapRecord("_super.apply(this, arguments)", baseTypeReference);
                    this.writeLineToOutput(";");
                }

                if (this.shouldCaptureThis(classDecl)) {
                    this.writeCaptureThisStatement(classDecl);
                }

                this.emitParameterPropertyAndMemberVariableAssignments();

                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeToken(classDecl.closeBraceToken);
                this.writeLineToOutput("");

                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl);
            }

            this.emitClassMembers(classDecl);

            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("return " + className + ";", classDecl.closeBraceToken);
            this.writeLineToOutput("");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(classDecl.closeBraceToken);
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingStart(classDecl);
            this.writeToOutput(")(");
            if (hasBaseClass) {
                this.emitJavascript(baseTypeReference, false);
            }
            this.writeToOutput(");");
            this.recordSourceMappingEnd(classDecl);

            if ((temp === 1 /* Module */ || temp === 2 /* DynamicModule */) && TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */)) {
                this.writeLineToOutput("");
                this.emitIndent();
                var modName = temp === 1 /* Module */ ? this.moduleName : "exports";
                this.writeToOutputWithSourceMapRecord(modName + "." + className + " = " + className + ";", classDecl);
            }

            this.recordSourceMappingEnd(classDecl);
            this.emitComments(classDecl, false);
            this.setContainer(temp);
            this.thisClassNode = svClassNode;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitClassMembers = function (classDecl) {
            var lastEmittedMember = null;

            for (var i = 0, n = classDecl.classElements.length; i < n; i++) {
                var memberDecl = classDecl.classElements[i];

                if (memberDecl.kind() === 140 /* GetAccessor */) {
                    this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);
                    var getter = memberDecl;
                    this.emitAccessorMemberDeclaration(getter, getter.propertyName, classDecl.identifier.text(), !TypeScript.hasModifier(getter.modifiers, 16 /* Static */));
                    lastEmittedMember = memberDecl;
                } else if (memberDecl.kind() === 141 /* SetAccessor */) {
                    this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);
                    var setter = memberDecl;
                    this.emitAccessorMemberDeclaration(setter, setter.propertyName, classDecl.identifier.text(), !TypeScript.hasModifier(setter.modifiers, 16 /* Static */));
                    lastEmittedMember = memberDecl;
                } else if (memberDecl.kind() === 136 /* MemberFunctionDeclaration */) {
                    var memberFunction = memberDecl;

                    if (memberFunction.block) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);

                        this.emitClassMemberFunctionDeclaration(classDecl, memberFunction);
                        lastEmittedMember = memberDecl;
                    }
                }
            }

            for (var i = 0, n = classDecl.classElements.length; i < n; i++) {
                var memberDecl = classDecl.classElements[i];

                if (memberDecl.kind() === 137 /* MemberVariableDeclaration */) {
                    var varDecl = memberDecl;

                    if (TypeScript.hasModifier(varDecl.modifiers, 16 /* Static */) && varDecl.variableDeclarator.equalsValueClause) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, varDecl);

                        this.emitIndent();
                        this.recordSourceMappingStart(varDecl);

                        this.emitComments(varDecl, true);
                        var varDeclName = varDecl.variableDeclarator.propertyName.text();
                        if (TypeScript.isQuoted(varDeclName) || varDecl.variableDeclarator.propertyName.kind() !== 11 /* IdentifierName */) {
                            this.writeToOutput(classDecl.identifier.text() + "[" + varDeclName + "]");
                        } else {
                            this.writeToOutput(classDecl.identifier.text() + "." + varDeclName);
                        }

                        this.emit(varDecl.variableDeclarator.equalsValueClause);

                        this.recordSourceMappingEnd(varDecl);
                        this.writeLineToOutput(";");

                        lastEmittedMember = varDecl;
                    }
                }
            }
        };

        Emitter.prototype.emitClassMemberFunctionDeclaration = function (classDecl, funcDecl) {
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);
            this.emitComments(funcDecl, true);
            var functionName = funcDecl.propertyName.text();

            this.writeToOutput(classDecl.identifier.text());

            if (!TypeScript.hasModifier(funcDecl.modifiers, 16 /* Static */)) {
                this.writeToOutput(".prototype");
            }

            if (TypeScript.isQuoted(functionName) || funcDecl.propertyName.kind() !== 11 /* IdentifierName */) {
                this.writeToOutput("[" + functionName + "] = ");
            } else {
                this.writeToOutput("." + functionName + " = ");
            }

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");

            this.emitParameterList(funcDecl.callSignature.parameterList);

            var parameters = funcDecl.callSignature.parameterList.parameters;
            this.emitFunctionBodyStatements(funcDecl.propertyName.text(), funcDecl, parameters, funcDecl.block, null);

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.recordSourceMappingEnd(funcDecl);
            this.popDecl(pullDecl);

            this.writeLineToOutput(";");
        };

        Emitter.prototype.requiresExtendsBlock = function (moduleElements) {
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var moduleElement = moduleElements[i];

                if (moduleElement.kind() === 131 /* ModuleDeclaration */) {
                    var moduleAST = moduleElement;

                    if (!TypeScript.hasModifier(moduleAST.modifiers, 8 /* Ambient */) && this.requiresExtendsBlock(moduleAST.moduleElements)) {
                        return true;
                    }
                } else if (moduleElement.kind() === 132 /* ClassDeclaration */) {
                    var classDeclaration = moduleElement;

                    if (!TypeScript.hasModifier(classDeclaration.modifiers, 8 /* Ambient */) && TypeScript.ASTHelpers.getExtendsHeritageClause(classDeclaration.heritageClauses) !== null) {
                        return true;
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitPrologue = function (sourceUnit) {
            if (!this.extendsPrologueEmitted) {
                if (this.requiresExtendsBlock(sourceUnit.moduleElements)) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }

            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(sourceUnit)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };

        Emitter.prototype.emitThis = function () {
            if (!this.inWithBlock && this.inArrowFunction) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };

        Emitter.prototype.emitBlockOrStatement = function (node) {
            if (node.kind() === 147 /* Block */) {
                this.emit(node);
            } else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascript(node, true);
                this.indenter.decreaseIndent();
            }
        };

        Emitter.prototype.emitLiteralExpression = function (expression) {
            switch (expression.kind()) {
                case 32 /* NullKeyword */:
                    this.writeToken(expression);
                    break;
                case 24 /* FalseKeyword */:
                    this.writeToken(expression);
                    break;
                case 37 /* TrueKeyword */:
                    this.writeToken(expression);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }
        };

        Emitter.prototype.emitThisExpression = function (expression) {
            if (!this.inWithBlock && this.inArrowFunction) {
                this.writeToOutputWithSourceMapRecord("_this", expression);
            } else {
                this.writeToken(expression);
            }
        };

        Emitter.prototype.emitSuperExpression = function (expression) {
            if (TypeScript.PullHelpers.isInStaticMemberContext(expression, this.semanticInfoChain)) {
                this.writeToOutputWithSourceMapRecord("_super", expression);
            } else {
                this.writeToOutputWithSourceMapRecord("_super.prototype", expression);
            }
        };

        Emitter.prototype.hasTrailingComment = function (token) {
            return token.hasTrailingTrivia() && token.trailingTrivia().hasComment();
        };

        Emitter.prototype.emitParenthesizedExpression = function (parenthesizedExpression) {
            var omitParentheses = false;

            if (parenthesizedExpression.expression.kind() === 221 /* CastExpression */ && !this.hasTrailingComment(parenthesizedExpression.openParenToken)) {
                var castedExpression = parenthesizedExpression.expression.expression;

                while (castedExpression.kind() == 221 /* CastExpression */) {
                    castedExpression = castedExpression.expression;
                }

                switch (castedExpression.kind()) {
                    case 218 /* ParenthesizedExpression */:
                    case 11 /* IdentifierName */:
                    case 32 /* NullKeyword */:
                    case 35 /* ThisKeyword */:
                    case 14 /* StringLiteral */:
                    case 13 /* NumericLiteral */:
                    case 12 /* RegularExpressionLiteral */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 215 /* ArrayLiteralExpression */:
                    case 216 /* ObjectLiteralExpression */:
                    case 213 /* MemberAccessExpression */:
                    case 222 /* ElementAccessExpression */:
                        omitParentheses = true;
                        break;

                    case 214 /* InvocationExpression */:
                        if (parenthesizedExpression.parent.kind() !== 217 /* ObjectCreationExpression */) {
                            omitParentheses = true;
                        }

                        break;
                }
            }

            if (omitParentheses) {
                this.emit(parenthesizedExpression.expression);
            } else {
                this.recordSourceMappingStart(parenthesizedExpression);
                this.writeToken(parenthesizedExpression.openParenToken);
                this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenTrailingComments(parenthesizedExpression.openParenToken, this.text()), false);
                this.emit(parenthesizedExpression.expression);
                this.writeToken(parenthesizedExpression.closeParenToken);
                this.recordSourceMappingEnd(parenthesizedExpression);
            }
        };

        Emitter.prototype.emitCastExpression = function (expression) {
            this.emit(expression.expression);
        };

        Emitter.prototype.emitPrefixUnaryExpression = function (expression) {
            var nodeType = expression.kind();

            this.recordSourceMappingStart(expression);
            switch (nodeType) {
                case 168 /* LogicalNotExpression */:
                    this.writeToken(expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                case 167 /* BitwiseNotExpression */:
                    this.writeToken(expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                case 166 /* NegateExpression */:
                    this.writeToken(expression.operatorToken);
                    if (expression.operand.kind() === 166 /* NegateExpression */ || expression.operand.kind() === 170 /* PreDecrementExpression */) {
                        this.writeToOutput(" ");
                    }
                    this.emit(expression.operand);
                    break;
                case 165 /* PlusExpression */:
                    this.writeToken(expression.operatorToken);
                    if (expression.operand.kind() === 165 /* PlusExpression */ || expression.operand.kind() === 169 /* PreIncrementExpression */) {
                        this.writeToOutput(" ");
                    }
                    this.emit(expression.operand);
                    break;
                case 169 /* PreIncrementExpression */:
                    this.writeToOutputWithSourceMapRecord("++", expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                case 170 /* PreDecrementExpression */:
                    this.writeToOutputWithSourceMapRecord("--", expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }

            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitPostfixUnaryExpression = function (expression) {
            var nodeType = expression.kind();

            this.recordSourceMappingStart(expression);
            switch (nodeType) {
                case 211 /* PostIncrementExpression */:
                    this.emit(expression.operand);
                    this.writeToOutputWithSourceMapRecord("++", expression.operatorToken);
                    break;
                case 212 /* PostDecrementExpression */:
                    this.emit(expression.operand);
                    this.writeToOutputWithSourceMapRecord("--", expression.operatorToken);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }

            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitTypeOfExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.writeToken(expression.typeOfKeyword);
            this.writeToOutput(" ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitDeleteExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.writeToken(expression.deleteKeyword);
            this.writeToOutput(" ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitVoidExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            this.writeToken(expression.voidKeyword);
            this.writeToOutput(" ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.canEmitDottedNameMemberAccessExpression = function (expression) {
            var memberExpressionNodeType = expression.expression.kind();

            if (memberExpressionNodeType === 11 /* IdentifierName */ || memberExpressionNodeType == 213 /* MemberAccessExpression */) {
                var memberAccessSymbol = this.getSymbolForEmit(expression).symbol;
                var memberAccessExpressionSymbol = this.getSymbolForEmit(expression.expression).symbol;
                if (memberAccessSymbol && memberAccessExpressionSymbol && !this.semanticInfoChain.getAliasSymbolForAST(expression.expression) && (TypeScript.PullHelpers.symbolIsModule(memberAccessExpressionSymbol) || memberAccessExpressionSymbol.kind === 64 /* Enum */ || memberAccessExpressionSymbol.anyDeclHasFlag(32768 /* InitializedModule */ | 4096 /* Enum */))) {
                    var memberAccessSymbolKind = memberAccessSymbol.kind;
                    if (memberAccessSymbolKind === 4096 /* Property */ || memberAccessSymbolKind === 67108864 /* EnumMember */ || (memberAccessSymbol.anyDeclHasFlag(1 /* Exported */) && memberAccessSymbolKind === 512 /* Variable */ && !memberAccessSymbol.anyDeclHasFlag(32768 /* InitializedModule */ | 4096 /* Enum */)) || ((memberAccessSymbol.anyDeclHasFlag(1 /* Exported */) && !this.symbolIsUsedInItsEnclosingContainer(memberAccessSymbol)))) {
                        if (memberExpressionNodeType === 213 /* MemberAccessExpression */) {
                            return this.canEmitDottedNameMemberAccessExpression(expression.expression);
                        }

                        return true;
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitDottedNameMemberAccessExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            if (expression.expression.kind() === 213 /* MemberAccessExpression */) {
                this.emitDottedNameMemberAccessExpressionRecurse(expression.expression);
            } else {
                this.emitName(expression.expression, true);
            }

            this.writeToken(expression.dotToken);
            this.emitName(expression.name, false);

            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitDottedNameMemberAccessExpressionRecurse = function (expression) {
            this.emitComments(expression, true);
            this.emitDottedNameMemberAccessExpression(expression);
            this.emitComments(expression, false);
        };

        Emitter.prototype.emitMemberAccessExpression = function (expression) {
            if (!this.tryEmitConstant(expression)) {
                if (this.canEmitDottedNameMemberAccessExpression(expression)) {
                    this.emitDottedNameMemberAccessExpression(expression);
                } else {
                    this.recordSourceMappingStart(expression);
                    this.emit(expression.expression);
                    this.writeToken(expression.dotToken);
                    this.emitName(expression.name, false);
                    this.recordSourceMappingEnd(expression);
                }
            }
        };

        Emitter.prototype.emitQualifiedName = function (name) {
            this.recordSourceMappingStart(name);

            this.emit(name.left);
            this.writeToken(name.dotToken);
            this.emitName(name.right, false);

            this.recordSourceMappingEnd(name);
        };

        Emitter.prototype.emitBinaryExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            switch (expression.kind()) {
                case 174 /* CommaExpression */:
                    this.emit(expression.left);
                    this.writeToken(expression.operatorToken);
                    this.writeToOutput(" ");
                    this.emit(expression.right);
                    break;
                default: {
                    this.emit(expression.left);
                    var binOp = TypeScript.SyntaxFacts.getText(TypeScript.SyntaxFacts.getOperatorTokenFromBinaryExpression(expression.kind()));
                    this.writeToOutput(" ");
                    this.writeToOutputWithSourceMapRecord(binOp, expression.operatorToken);
                    this.writeToOutput(" ");
                    this.emit(expression.right);
                }
            }
            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitSimplePropertyAssignment = function (property) {
            this.recordSourceMappingStart(property);
            this.emit(property.propertyName);

            this.writeToken(property.colonToken);
            this.writeToOutput(" ");
            this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenTrailingComments(property.colonToken, this.text()), true, true);

            this.emit(property.expression);
            this.recordSourceMappingEnd(property);
        };

        Emitter.prototype.emitFunctionPropertyAssignment = function (funcProp) {
            this.recordSourceMappingStart(funcProp);

            this.emit(funcProp.propertyName);
            this.writeToOutput(": ");

            var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcProp);

            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;

            var temp = this.setContainer(5 /* Function */);
            var funcName = funcProp.propertyName;

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcProp);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcProp);
            this.writeToOutput("function ");

            this.emitParameterList(funcProp.callSignature.parameterList);

            this.emitFunctionBodyStatements(funcProp.propertyName.text(), funcProp, funcProp.callSignature.parameterList.parameters, funcProp.block, null);

            this.recordSourceMappingEnd(funcProp);

            this.recordSourceMappingEnd(funcProp);

            this.emitComments(funcProp, false);

            this.popDecl(pullDecl);

            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        };

        Emitter.prototype.emitConditionalExpression = function (expression) {
            this.emit(expression.condition);
            this.writeToOutput(" ");
            this.writeToken(expression.questionToken);
            this.writeToOutput(" ");
            this.emit(expression.whenTrue);
            this.writeToOutput(" ");
            this.writeToken(expression.colonToken);
            this.writeToOutput(" ");
            this.emit(expression.whenFalse);
        };

        Emitter.prototype.emitThrowStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.throwKeyword);
            this.writeToOutput(" ");
            this.emit(statement.expression);
            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitExpressionStatement = function (statement) {
            var isArrowExpression = statement.expression.kind() === 220 /* SimpleArrowFunctionExpression */ || statement.expression.kind() === 219 /* ParenthesizedArrowFunctionExpression */;

            this.recordSourceMappingStart(statement);
            if (isArrowExpression) {
                this.writeToOutput("(");
            }

            this.emit(statement.expression);

            if (isArrowExpression) {
                this.writeToOutput(")");
            }

            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitLabeledStatement = function (statement) {
            this.writeToOutputWithSourceMapRecord(statement.identifier.text(), statement.identifier);
            this.writeToken(statement.colonToken);
            this.writeLineToOutput("");
            this.emitJavascript(statement.statement, true);
        };

        Emitter.prototype.emitBlock = function (block) {
            this.recordSourceMappingStart(block);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            if (block.statements) {
                this.emitList(block.statements);
            }
            this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenLeadingComments(block.closeBraceToken, this.text()), false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(block.closeBraceToken);
            this.recordSourceMappingEnd(block);
        };

        Emitter.prototype.emitBreakStatement = function (jump) {
            this.recordSourceMappingStart(jump);
            this.writeToken(jump.breakKeyword);

            if (jump.identifier) {
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord(jump.identifier.text(), jump.identifier);
            }

            this.writeToOutputWithSourceMapRecord(";", jump.semicolonToken);
            this.recordSourceMappingEnd(jump);
        };

        Emitter.prototype.emitContinueStatement = function (jump) {
            this.recordSourceMappingStart(jump);
            this.writeToken(jump.continueKeyword);

            if (jump.identifier) {
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord(jump.identifier.text(), jump.identifier);
            }

            this.writeToOutputWithSourceMapRecord(";", jump.semicolonToken);
            this.recordSourceMappingEnd(jump);
        };

        Emitter.prototype.emitWhileStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.whileKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            this.emit(statement.condition);
            this.writeToken(statement.closeParenToken);
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitDoStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.doKeyword);
            this.emitBlockOrStatement(statement.statement);
            this.writeToOutput(" ");
            this.writeToken(statement.whileKeyword);
            this.writeToken(statement.openParenToken);
            this.emit(statement.condition);
            this.writeToken(statement.closeParenToken);
            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitIfStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.ifKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            this.emit(statement.condition);
            this.writeToken(statement.closeParenToken);

            this.emitBlockOrStatement(statement.statement);

            if (statement.elseClause) {
                if (statement.statement.kind() !== 147 /* Block */) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                } else {
                    this.writeToOutput(" ");
                }

                this.emit(statement.elseClause);
            }
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitElseClause = function (elseClause) {
            this.writeToken(elseClause.elseKeyword);
            if (elseClause.statement.kind() === 148 /* IfStatement */) {
                this.writeToOutput(" ");
                this.emit(elseClause.statement);
            } else {
                this.emitBlockOrStatement(elseClause.statement);
            }
        };

        Emitter.prototype.emitReturnStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.returnKeyword);
            if (statement.expression) {
                this.writeToOutput(" ");
                this.emit(statement.expression);
            }

            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitForInStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.forKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);

            if (statement.left) {
                this.emit(statement.left);
            } else {
                this.emit(statement.variableDeclaration);
            }
            this.writeToOutput(" ");
            this.writeToken(statement.inKeyword);
            this.writeToOutput(" ");
            this.emit(statement.expression);
            this.writeToken(statement.closeParenToken);
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitForStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.forKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);

            if (statement.variableDeclaration) {
                this.emit(statement.variableDeclaration);
            } else if (statement.initializer) {
                this.emit(statement.initializer);
            }

            this.writeToken(statement.firstSemicolonToken);
            this.writeToOutput(" ");
            this.emitJavascript(statement.condition, false);
            this.writeToken(statement.secondSemicolonToken);
            if (statement.incrementor) {
                this.writeToOutput(" ");
                this.emitJavascript(statement.incrementor, false);
            }
            this.writeToken(statement.closeParenToken);
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitWithStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.withKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            if (statement.condition) {
                this.emit(statement.condition);
            }

            this.writeToken(statement.closeParenToken);
            var prevInWithBlock = this.inWithBlock;
            this.inWithBlock = true;
            this.emitBlockOrStatement(statement.statement);
            this.inWithBlock = prevInWithBlock;
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitSwitchStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.switchKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            this.emit(statement.expression);
            this.writeToken(statement.closeParenToken);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            this.emitList(statement.switchClauses, false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(statement.closeBraceToken);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitCaseSwitchClause = function (clause) {
            this.recordSourceMappingStart(clause);
            this.writeToken(clause.caseKeyword);
            this.writeToOutput(" ");
            this.emit(clause.expression);
            this.writeToken(clause.colonToken);

            this.emitSwitchClauseBody(clause.colonToken, clause.statements);
            this.recordSourceMappingEnd(clause);
        };

        Emitter.prototype.emitSwitchClauseBody = function (colonToken, body) {
            var text = this.text();
            if (body.length === 1 && TypeScript.childAt(body, 0).kind() === 147 /* Block */) {
                this.emit(TypeScript.childAt(body, 0));
                this.writeLineToOutput("");
            } else if (body.length === 1 && this.isOnSameLine(TypeScript.end(colonToken, text), TypeScript.start(body[0], text))) {
                this.writeToOutput(" ");
                this.emit(TypeScript.childAt(body, 0));
                this.writeLineToOutput("");
            } else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emit(body);
                this.indenter.decreaseIndent();
            }
        };

        Emitter.prototype.emitDefaultSwitchClause = function (clause) {
            this.recordSourceMappingStart(clause);
            this.writeToken(clause.defaultKeyword);
            this.writeToken(clause.colonToken);

            this.emitSwitchClauseBody(clause.colonToken, clause.statements);
            this.recordSourceMappingEnd(clause);
        };

        Emitter.prototype.emitTryStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.tryKeyword);
            this.writeToOutput(" ");
            this.emit(statement.block);
            this.emitJavascript(statement.catchClause, false);

            if (statement.finallyClause) {
                this.emit(statement.finallyClause);
            }
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitCatchClause = function (clause) {
            this.writeToOutput(" ");
            this.recordSourceMappingStart(clause);
            this.writeToken(clause.catchKeyword);
            this.writeToOutput(" ");
            this.writeToken(clause.openParenToken);
            this.emit(clause.identifier);
            this.writeToken(clause.closeParenToken);
            this.emit(clause.block);
            this.recordSourceMappingEnd(clause);
        };

        Emitter.prototype.emitFinallyClause = function (clause) {
            this.writeToOutput(" ");
            this.writeToken(clause.finallyKeyword);
            this.emit(clause.block);
        };

        Emitter.prototype.emitDebuggerStatement = function (statement) {
            this.writeToken(statement.debuggerKeyword);
            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
        };

        Emitter.prototype.emitNumericLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        };

        Emitter.prototype.emitRegularExpressionLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        };

        Emitter.prototype.emitStringLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        };

        Emitter.prototype.emitEqualsValueClause = function (clause) {
            this.writeToOutput(" ");
            this.writeToken(clause.equalsToken);
            this.writeToOutput(" ");
            this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenTrailingComments(clause.equalsToken, this.text()), true, true);

            this.emit(clause.value);
        };

        Emitter.prototype.emitParameter = function (parameter) {
            this.writeToOutputWithSourceMapRecord(parameter.identifier.text(), parameter);
        };

        Emitter.prototype.emitConstructorDeclaration = function (declaration) {
            if (declaration.block) {
                this.emitConstructor(declaration);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.shouldEmitFunctionDeclaration = function (declaration) {
            return TypeScript.ASTHelpers.preComments(declaration, this.text()) !== null || (!TypeScript.hasModifier(declaration.modifiers, 8 /* Ambient */) && declaration.block !== null);
        };

        Emitter.prototype.emitFunctionDeclaration = function (declaration) {
            if (!TypeScript.hasModifier(declaration.modifiers, 8 /* Ambient */) && declaration.block !== null) {
                this.emitFunction(declaration);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.emitSourceUnit = function (sourceUnit) {
            if (!this.document.isDeclareFile()) {
                var pullDecl = this.semanticInfoChain.getDeclForAST(sourceUnit);
                this.pushDecl(pullDecl);
                this.emitScriptElements(sourceUnit);
                this.popDecl(pullDecl);

                this.emitCommentsArray(TypeScript.ASTHelpers.convertTokenLeadingComments(sourceUnit.endOfFileToken, this.text()), false);
            }
        };

        Emitter.prototype.shouldEmitEnumDeclaration = function (declaration) {
            return TypeScript.ASTHelpers.preComments(declaration, this.text()) !== null || !TypeScript.ASTHelpers.enumIsElided(declaration);
        };

        Emitter.prototype.emitEnumDeclaration = function (declaration) {
            if (!TypeScript.ASTHelpers.enumIsElided(declaration)) {
                this.emitComments(declaration, true);
                this.emitEnum(declaration);
                this.emitComments(declaration, false);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.shouldEmitModuleDeclaration = function (declaration) {
            return TypeScript.ASTHelpers.preComments(declaration, this.text()) !== null || !TypeScript.ASTHelpers.moduleIsElided(declaration);
        };

        Emitter.prototype.emitModuleDeclaration = function (declaration) {
            if (!TypeScript.ASTHelpers.moduleIsElided(declaration)) {
                this.emitModuleDeclarationWorker(declaration);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.shouldEmitClassDeclaration = function (declaration) {
            return TypeScript.ASTHelpers.preComments(declaration, this.text()) !== null || !TypeScript.hasModifier(declaration.modifiers, 8 /* Ambient */);
        };

        Emitter.prototype.emitClassDeclaration = function (declaration) {
            if (!TypeScript.hasModifier(declaration.modifiers, 8 /* Ambient */)) {
                this.emitClass(declaration);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.shouldEmitInterfaceDeclaration = function (declaration) {
            return TypeScript.ASTHelpers.preComments(declaration, this.text()) !== null;
        };

        Emitter.prototype.emitInterfaceDeclaration = function (declaration) {
            this.emitComments(declaration, true, true);
        };

        Emitter.prototype.firstVariableDeclarator = function (statement) {
            return statement.variableDeclaration.variableDeclarators[0];
        };

        Emitter.prototype.isNotAmbientOrHasInitializer = function (variableStatement) {
            return !TypeScript.hasModifier(variableStatement.modifiers, 8 /* Ambient */) || this.firstVariableDeclarator(variableStatement).equalsValueClause !== null;
        };

        Emitter.prototype.shouldEmitVariableStatement = function (statement) {
            return TypeScript.ASTHelpers.preComments(statement, this.text()) !== null || this.isNotAmbientOrHasInitializer(statement);
        };

        Emitter.prototype.emitVariableStatement = function (statement) {
            if (this.isNotAmbientOrHasInitializer(statement)) {
                this.emitComments(statement, true);
                this.emit(statement.variableDeclaration);
                this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
                this.emitComments(statement, false);
            } else {
                this.emitComments(statement, true, true);
            }
        };

        Emitter.prototype.emitGenericType = function (type) {
            this.emit(type.name);
        };

        Emitter.prototype.shouldEmit = function (ast) {
            if (!ast) {
                return false;
            }

            switch (ast.kind()) {
                case 134 /* ImportDeclaration */:
                    return this.shouldEmitImportDeclaration(ast);
                case 132 /* ClassDeclaration */:
                    return this.shouldEmitClassDeclaration(ast);
                case 129 /* InterfaceDeclaration */:
                    return this.shouldEmitInterfaceDeclaration(ast);
                case 130 /* FunctionDeclaration */:
                    return this.shouldEmitFunctionDeclaration(ast);
                case 131 /* ModuleDeclaration */:
                    return this.shouldEmitModuleDeclaration(ast);
                case 149 /* VariableStatement */:
                    return this.shouldEmitVariableStatement(ast);
                case 224 /* OmittedExpression */:
                    return false;
                case 133 /* EnumDeclaration */:
                    return this.shouldEmitEnumDeclaration(ast);
            }

            return true;
        };

        Emitter.prototype.emit = function (ast) {
            if (!ast) {
                return;
            }

            switch (ast.kind()) {
                case 2 /* SeparatedList */:
                    return this.emitSeparatedList(ast);
                case 1 /* List */:
                    return this.emitList(ast);
                case 120 /* SourceUnit */:
                    return this.emitSourceUnit(ast);
                case 134 /* ImportDeclaration */:
                    return this.emitImportDeclaration(ast);
                case 135 /* ExportAssignment */:
                    return this.setExportAssignment(ast);
                case 132 /* ClassDeclaration */:
                    return this.emitClassDeclaration(ast);
                case 129 /* InterfaceDeclaration */:
                    return this.emitInterfaceDeclaration(ast);
                case 11 /* IdentifierName */:
                    return this.emitName(ast, true);
                case 226 /* VariableDeclarator */:
                    return this.emitVariableDeclarator(ast);
                case 220 /* SimpleArrowFunctionExpression */:
                    return this.emitSimpleArrowFunctionExpression(ast);
                case 219 /* ParenthesizedArrowFunctionExpression */:
                    return this.emitParenthesizedArrowFunctionExpression(ast);
                case 130 /* FunctionDeclaration */:
                    return this.emitFunctionDeclaration(ast);
                case 131 /* ModuleDeclaration */:
                    return this.emitModuleDeclaration(ast);
                case 225 /* VariableDeclaration */:
                    return this.emitVariableDeclaration(ast);
                case 126 /* GenericType */:
                    return this.emitGenericType(ast);
                case 138 /* ConstructorDeclaration */:
                    return this.emitConstructorDeclaration(ast);
                case 133 /* EnumDeclaration */:
                    return this.emitEnumDeclaration(ast);
                case 244 /* EnumElement */:
                    return this.emitEnumElement(ast);
                case 223 /* FunctionExpression */:
                    return this.emitFunctionExpression(ast);
                case 149 /* VariableStatement */:
                    return this.emitVariableStatement(ast);
            }

            this.emitComments(ast, true);
            this.emitWorker(ast);
            this.emitComments(ast, false);
        };

        Emitter.prototype.emitWorker = function (ast) {
            if (!ast) {
                return;
            }

            switch (ast.kind()) {
                case 13 /* NumericLiteral */:
                    return this.emitNumericLiteral(ast);
                case 12 /* RegularExpressionLiteral */:
                    return this.emitRegularExpressionLiteral(ast);
                case 14 /* StringLiteral */:
                    return this.emitStringLiteral(ast);
                case 24 /* FalseKeyword */:
                case 32 /* NullKeyword */:
                case 37 /* TrueKeyword */:
                    return this.emitLiteralExpression(ast);
                case 35 /* ThisKeyword */:
                    return this.emitThisExpression(ast);
                case 50 /* SuperKeyword */:
                    return this.emitSuperExpression(ast);
                case 218 /* ParenthesizedExpression */:
                    return this.emitParenthesizedExpression(ast);
                case 215 /* ArrayLiteralExpression */:
                    return this.emitArrayLiteralExpression(ast);
                case 212 /* PostDecrementExpression */:
                case 211 /* PostIncrementExpression */:
                    return this.emitPostfixUnaryExpression(ast);
                case 168 /* LogicalNotExpression */:
                case 167 /* BitwiseNotExpression */:
                case 166 /* NegateExpression */:
                case 165 /* PlusExpression */:
                case 169 /* PreIncrementExpression */:
                case 170 /* PreDecrementExpression */:
                    return this.emitPrefixUnaryExpression(ast);
                case 214 /* InvocationExpression */:
                    return this.emitInvocationExpression(ast);
                case 222 /* ElementAccessExpression */:
                    return this.emitElementAccessExpression(ast);
                case 213 /* MemberAccessExpression */:
                    return this.emitMemberAccessExpression(ast);
                case 121 /* QualifiedName */:
                    return this.emitQualifiedName(ast);
                case 174 /* CommaExpression */:
                case 175 /* AssignmentExpression */:
                case 176 /* AddAssignmentExpression */:
                case 177 /* SubtractAssignmentExpression */:
                case 178 /* MultiplyAssignmentExpression */:
                case 179 /* DivideAssignmentExpression */:
                case 180 /* ModuloAssignmentExpression */:
                case 181 /* AndAssignmentExpression */:
                case 182 /* ExclusiveOrAssignmentExpression */:
                case 183 /* OrAssignmentExpression */:
                case 184 /* LeftShiftAssignmentExpression */:
                case 185 /* SignedRightShiftAssignmentExpression */:
                case 186 /* UnsignedRightShiftAssignmentExpression */:
                case 188 /* LogicalOrExpression */:
                case 189 /* LogicalAndExpression */:
                case 190 /* BitwiseOrExpression */:
                case 191 /* BitwiseExclusiveOrExpression */:
                case 192 /* BitwiseAndExpression */:
                case 193 /* EqualsWithTypeConversionExpression */:
                case 194 /* NotEqualsWithTypeConversionExpression */:
                case 195 /* EqualsExpression */:
                case 196 /* NotEqualsExpression */:
                case 197 /* LessThanExpression */:
                case 198 /* GreaterThanExpression */:
                case 199 /* LessThanOrEqualExpression */:
                case 200 /* GreaterThanOrEqualExpression */:
                case 201 /* InstanceOfExpression */:
                case 202 /* InExpression */:
                case 203 /* LeftShiftExpression */:
                case 204 /* SignedRightShiftExpression */:
                case 205 /* UnsignedRightShiftExpression */:
                case 206 /* MultiplyExpression */:
                case 207 /* DivideExpression */:
                case 208 /* ModuloExpression */:
                case 209 /* AddExpression */:
                case 210 /* SubtractExpression */:
                    return this.emitBinaryExpression(ast);
                case 187 /* ConditionalExpression */:
                    return this.emitConditionalExpression(ast);
                case 233 /* EqualsValueClause */:
                    return this.emitEqualsValueClause(ast);
                case 243 /* Parameter */:
                    return this.emitParameter(ast);
                case 147 /* Block */:
                    return this.emitBlock(ast);
                case 236 /* ElseClause */:
                    return this.emitElseClause(ast);
                case 148 /* IfStatement */:
                    return this.emitIfStatement(ast);
                case 150 /* ExpressionStatement */:
                    return this.emitExpressionStatement(ast);
                case 140 /* GetAccessor */:
                    return this.emitGetAccessor(ast);
                case 141 /* SetAccessor */:
                    return this.emitSetAccessor(ast);
                case 158 /* ThrowStatement */:
                    return this.emitThrowStatement(ast);
                case 151 /* ReturnStatement */:
                    return this.emitReturnStatement(ast);
                case 217 /* ObjectCreationExpression */:
                    return this.emitObjectCreationExpression(ast);
                case 152 /* SwitchStatement */:
                    return this.emitSwitchStatement(ast);
                case 234 /* CaseSwitchClause */:
                    return this.emitCaseSwitchClause(ast);
                case 235 /* DefaultSwitchClause */:
                    return this.emitDefaultSwitchClause(ast);
                case 153 /* BreakStatement */:
                    return this.emitBreakStatement(ast);
                case 154 /* ContinueStatement */:
                    return this.emitContinueStatement(ast);
                case 155 /* ForStatement */:
                    return this.emitForStatement(ast);
                case 156 /* ForInStatement */:
                    return this.emitForInStatement(ast);
                case 159 /* WhileStatement */:
                    return this.emitWhileStatement(ast);
                case 164 /* WithStatement */:
                    return this.emitWithStatement(ast);
                case 221 /* CastExpression */:
                    return this.emitCastExpression(ast);
                case 216 /* ObjectLiteralExpression */:
                    return this.emitObjectLiteralExpression(ast);
                case 241 /* SimplePropertyAssignment */:
                    return this.emitSimplePropertyAssignment(ast);
                case 242 /* FunctionPropertyAssignment */:
                    return this.emitFunctionPropertyAssignment(ast);
                case 157 /* EmptyStatement */:
                    return this.writeToken(ast.semicolonToken);
                case 160 /* TryStatement */:
                    return this.emitTryStatement(ast);
                case 237 /* CatchClause */:
                    return this.emitCatchClause(ast);
                case 238 /* FinallyClause */:
                    return this.emitFinallyClause(ast);
                case 161 /* LabeledStatement */:
                    return this.emitLabeledStatement(ast);
                case 162 /* DoStatement */:
                    return this.emitDoStatement(ast);
                case 172 /* TypeOfExpression */:
                    return this.emitTypeOfExpression(ast);
                case 171 /* DeleteExpression */:
                    return this.emitDeleteExpression(ast);
                case 173 /* VoidExpression */:
                    return this.emitVoidExpression(ast);
                case 163 /* DebuggerStatement */:
                    return this.emitDebuggerStatement(ast);
            }
        };
        return Emitter;
    })();
    TypeScript.Emitter = Emitter;

    function getLastConstructor(classDecl) {
        for (var i = classDecl.classElements.length - 1; i >= 0; i--) {
            var child = classDecl.classElements[i];

            if (child.kind() === 138 /* ConstructorDeclaration */) {
                return child;
            }
        }

        return null;
    }
    TypeScript.getLastConstructor = getLastConstructor;

    function getTrimmedTextLines(comment) {
        if (comment.kind() === 6 /* MultiLineCommentTrivia */) {
            return comment.fullText().split("\n").map(function (s) {
                return s.trim();
            });
        } else {
            return [comment.fullText().trim()];
        }
    }
    TypeScript.getTrimmedTextLines = getTrimmedTextLines;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () {
            return false;
        };
        MemberName.prototype.isArray = function () {
            return false;
        };
        MemberName.prototype.isMarker = function () {
            return !this.isString() && !this.isArray();
        };

        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };

        MemberName.memberNameToString = function (memberName, markerInfo, markerBaseLength) {
            if (typeof markerBaseLength === "undefined") { markerBaseLength = 0; }
            var result = memberName.prefix;

            if (memberName.isString()) {
                result += memberName.text;
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    if (ar.entries[index].isMarker()) {
                        if (markerInfo) {
                            markerInfo.push(markerBaseLength + result.length);
                        }
                        continue;
                    }

                    result += MemberName.memberNameToString(ar.entries[index], markerInfo, markerBaseLength + result.length);
                    result += ar.delim;
                }
            }

            result += memberName.suffix;
            return result;
        };

        MemberName.create = function (arg1, arg2, arg3) {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            } else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    })();
    TypeScript.MemberName = MemberName;

    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
            _super.call(this);
            this.text = text;
        }
        MemberNameString.prototype.isString = function () {
            return true;
        };
        return MemberNameString;
    })(MemberName);
    TypeScript.MemberNameString = MemberNameString;

    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            _super.call(this);
            this.delim = "";
            this.entries = [];
        }
        MemberNameArray.prototype.isArray = function () {
            return true;
        };

        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };

        MemberNameArray.prototype.addAll = function (entries) {
            for (var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    })(MemberName);
    TypeScript.MemberNameArray = MemberNameArray;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function stripStartAndEndQuotes(str) {
        var firstCharCode = str && str.charCodeAt(0);
        if (str && str.length >= 2 && firstCharCode === str.charCodeAt(str.length - 1) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {
            return str.substring(1, str.length - 1);
        }

        return str;
    }
    TypeScript.stripStartAndEndQuotes = stripStartAndEndQuotes;

    function isSingleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === 39 /* singleQuote */;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;

    function isDoubleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === 34 /* doubleQuote */;
    }
    TypeScript.isDoubleQuoted = isDoubleQuoted;

    function isQuoted(str) {
        return isDoubleQuoted(str) || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;

    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;

    var switchToForwardSlashesRegEx = /\\/g;
    function switchToForwardSlashes(path) {
        return path.replace(switchToForwardSlashesRegEx, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;

    function trimModName(modName) {
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) === ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".ts") {
            return modName.substring(0, modName.length - 3);
        }

        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".js") {
            return modName.substring(0, modName.length - 3);
        }

        return modName;
    }
    TypeScript.trimModName = trimModName;

    function getDeclareFilePath(fname) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;

    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }

    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;

    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;

    function getPrettyName(modPath, quote, treatAsFileName) {
        if (typeof quote === "undefined") { quote = true; }
        if (typeof treatAsFileName === "undefined") { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripStartAndEndQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;

    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;

    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath, isAbsoultePathURL) {
        if (typeof isAbsoultePathURL === "undefined") { isAbsoultePathURL = true; }
        absoluteModPath = switchToForwardSlashes(absoluteModPath);

        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);

        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] !== modComponents[joinStartIndex]) {
                break;
            }
        }

        if (joinStartIndex !== 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + "../";
                }
            }

            return relativePath + relativePathComponents.join("/");
        }

        if (isAbsoultePathURL && absoluteModPath.indexOf("://") === -1) {
            absoluteModPath = "file:///" + absoluteModPath;
        }

        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;

    function changePathToDTS(modPath) {
        return trimModName(stripStartAndEndQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;

    function isRelative(path) {
        return path.length > 0 && path.charAt(0) === ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.length > 0 && (path.charAt(0) === "\\" || path.charAt(0) === "/" || (path.indexOf(":\\") !== -1) || (path.indexOf(":/") !== -1));
    }
    TypeScript.isRooted = isRooted;

    function getRootFilePath(outFname) {
        if (outFname === "") {
            return outFname;
        } else {
            var isPath = outFname.indexOf("/") !== -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;

    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;

    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;

    function convertToDirectoryPath(dirPath) {
        if (dirPath && dirPath.charAt(dirPath.length - 1) !== "/") {
            dirPath += "/";
        }

        return dirPath;
    }
    TypeScript.convertToDirectoryPath = convertToDirectoryPath;

    var normalizePathRegEx = /^\\\\[^\\]/;
    function normalizePath(path) {
        if (normalizePathRegEx.test(path)) {
            path = "file:" + path;
        }
        var parts = this.getPathComponents(switchToForwardSlashes(path));
        var normalizedParts = [];

        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }

            if (normalizedParts.length > 0 && TypeScript.ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }

            normalizedParts.push(part);
        }

        return normalizedParts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    

    function isNoDefaultLibMatch(comment) {
        var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
        return isNoDefaultLibRegex.exec(comment);
    }

    TypeScript.tripleSlashReferenceRegExp = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/;

    function getFileReferenceFromReferencePath(fileName, text, position, comment, diagnostics) {
        var lineMap = text.lineMap();

        var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
        if (simpleReferenceRegEx.exec(comment)) {
            var isNoDefaultLib = isNoDefaultLibMatch(comment);

            if (!isNoDefaultLib) {
                var fullReferenceRegEx = TypeScript.tripleSlashReferenceRegExp;
                var fullReference = fullReferenceRegEx.exec(comment);

                if (!fullReference) {
                    diagnostics.push(new TypeScript.Diagnostic(fileName, lineMap, position, comment.length, TypeScript.DiagnosticCode.Invalid_reference_directive_syntax));
                } else {
                    var path = TypeScript.normalizePath(fullReference[3]);
                    var adjustedPath = TypeScript.normalizePath(path);

                    var isResident = fullReference.length >= 7 && fullReference[6] === "true";
                    return {
                        line: 0,
                        character: 0,
                        position: 0,
                        length: 0,
                        path: TypeScript.switchToForwardSlashes(adjustedPath),
                        isResident: isResident
                    };
                }
            }
        }

        return null;
    }

    var reportDiagnostic = function () {
    };

    function processImports(text, scanner, token, importedFiles) {
        var lineChar = { line: -1, character: -1 };

        var lineMap = text.lineMap();
        var start = new Date().getTime();

        while (token.kind() !== 10 /* EndOfFileToken */) {
            if (token.kind() === 49 /* ImportKeyword */) {
                var importToken = token;
                token = scanner.scan(false);

                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(false);

                    if (token.kind() === 107 /* EqualsToken */) {
                        token = scanner.scan(false);

                        if (token.kind() === 65 /* ModuleKeyword */ || token.kind() === 66 /* RequireKeyword */) {
                            token = scanner.scan(false);

                            if (token.kind() === 72 /* OpenParenToken */) {
                                token = scanner.scan(false);

                                lineMap.fillLineAndCharacterFromPosition(TypeScript.start(importToken, text), lineChar);

                                if (token.kind() === 14 /* StringLiteral */) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: TypeScript.start(token, text),
                                        length: TypeScript.width(token),
                                        path: TypeScript.stripStartAndEndQuotes(TypeScript.switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }

            token = scanner.scan(false);
        }

        var totalTime = new Date().getTime() - start;
        TypeScript.fileResolutionScanImportsTime += totalTime;
    }

    function processTripleSlashDirectives(fileName, text, firstToken) {
        var leadingTrivia = firstToken.leadingTrivia(text);

        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;
        var diagnostics = [];
        var referencedFiles = [];
        var lineMap = text.lineMap();

        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);

            if (trivia.kind() === 7 /* SingleLineCommentTrivia */) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(fileName, text, position, triviaText, diagnostics);

                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.position = position;
                    referencedCode.length = trivia.fullWidth();
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;

                    referencedFiles.push(referencedCode);
                }

                var isNoDefaultLib = isNoDefaultLibMatch(triviaText);
                if (isNoDefaultLib) {
                    noDefaultLib = isNoDefaultLib[3] === "true";
                }
            }

            position += trivia.fullWidth();
        }

        return { noDefaultLib: noDefaultLib, diagnostics: diagnostics, referencedFiles: referencedFiles };
    }

    function preProcessFile(fileName, sourceText, readImportFiles) {
        if (typeof readImportFiles === "undefined") { readImportFiles = true; }
        var text = TypeScript.SimpleText.fromScriptSnapshot(sourceText);
        var scanner = TypeScript.Scanner.createScanner(1 /* EcmaScript5 */, text, reportDiagnostic);

        var firstToken = scanner.scan(false);

        var importedFiles = [];
        if (readImportFiles) {
            processImports(text, scanner, firstToken, importedFiles);
        }

        var properties = processTripleSlashDirectives(fileName, text, firstToken);

        return { referencedFiles: properties.referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib, diagnostics: properties.diagnostics };
    }
    TypeScript.preProcessFile = preProcessFile;

    function getReferencedFiles(fileName, sourceText) {
        return preProcessFile(fileName, sourceText, false).referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ReferenceResolutionResult = (function () {
        function ReferenceResolutionResult() {
            this.resolvedFiles = [];
            this.diagnostics = [];
            this.seenNoDefaultLibTag = false;
        }
        return ReferenceResolutionResult;
    })();
    TypeScript.ReferenceResolutionResult = ReferenceResolutionResult;

    var ReferenceLocation = (function () {
        function ReferenceLocation(filePath, lineMap, position, length, isImported) {
            this.filePath = filePath;
            this.lineMap = lineMap;
            this.position = position;
            this.length = length;
            this.isImported = isImported;
        }
        return ReferenceLocation;
    })();

    var ReferenceResolver = (function () {
        function ReferenceResolver(inputFileNames, host, useCaseSensitiveFileResolution) {
            this.useCaseSensitiveFileResolution = useCaseSensitiveFileResolution;
            this.inputFileNames = inputFileNames;
            this.host = host;
            this.visited = {};
        }
        ReferenceResolver.resolve = function (inputFileNames, host, useCaseSensitiveFileResolution) {
            var resolver = new ReferenceResolver(inputFileNames, host, useCaseSensitiveFileResolution);
            return resolver.resolveInputFiles();
        };

        ReferenceResolver.prototype.resolveInputFiles = function () {
            var _this = this;
            var result = new ReferenceResolutionResult();

            if (!this.inputFileNames || this.inputFileNames.length <= 0) {
                return result;
            }

            var referenceLocation = new ReferenceLocation(null, null, 0, 0, false);
            this.inputFileNames.forEach(function (fileName) {
                return _this.resolveIncludedFile(fileName, referenceLocation, result);
            });

            return result;
        };

        ReferenceResolver.prototype.resolveIncludedFile = function (path, referenceLocation, resolutionResult) {
            var normalizedPath = this.getNormalizedFilePath(path, referenceLocation.filePath);

            if (this.isSameFile(normalizedPath, referenceLocation.filePath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.lineMap, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.A_file_cannot_have_a_reference_to_itself, null));
                }

                return normalizedPath;
            }

            if (!TypeScript.isTSFile(normalizedPath) && !TypeScript.isDTSFile(normalizedPath)) {
                var dtsFile = normalizedPath + ".d.ts";
                var tsFile = normalizedPath + ".ts";

                if (this.host.fileExists(tsFile)) {
                    normalizedPath = tsFile;
                } else {
                    normalizedPath = dtsFile;
                }
            }

            if (!this.host.fileExists(normalizedPath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.lineMap, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.Cannot_resolve_referenced_file_0, [path]));
                }

                return normalizedPath;
            }

            return this.resolveFile(normalizedPath, resolutionResult);
        };

        ReferenceResolver.prototype.resolveImportedFile = function (path, referenceLocation, resolutionResult) {
            var isRelativePath = TypeScript.isRelative(path);
            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(path);

            if (isRelativePath || isRootedPath) {
                return this.resolveIncludedFile(path, referenceLocation, resolutionResult);
            } else {
                var parentDirectory = this.host.getParentDirectory(referenceLocation.filePath);
                var searchFilePath = null;
                var dtsFileName = path + ".d.ts";
                var tsFilePath = path + ".ts";

                var start = new Date().getTime();

                do {
                    currentFilePath = this.host.resolveRelativePath(tsFilePath, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }

                    var currentFilePath = this.host.resolveRelativePath(dtsFileName, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }

                    parentDirectory = this.host.getParentDirectory(parentDirectory);
                } while(parentDirectory);

                TypeScript.fileResolutionImportFileSearchTime += new Date().getTime() - start;

                if (!searchFilePath) {
                    return path;
                }

                return this.resolveFile(searchFilePath, resolutionResult);
            }
        };

        ReferenceResolver.prototype.resolveFile = function (normalizedPath, resolutionResult) {
            var _this = this;
            var visitedPath = this.isVisited(normalizedPath);
            if (!visitedPath) {
                this.recordVisitedFile(normalizedPath);

                var start = new Date().getTime();
                var scriptSnapshot = this.host.getScriptSnapshot(normalizedPath);
                var totalTime = new Date().getTime() - start;
                TypeScript.fileResolutionIOTime += totalTime;

                var lineMap = TypeScript.LineMap1.fromScriptSnapshot(scriptSnapshot);
                var preprocessedFileInformation = TypeScript.preProcessFile(normalizedPath, scriptSnapshot);
                resolutionResult.diagnostics.push.apply(resolutionResult.diagnostics, preprocessedFileInformation.diagnostics);

                if (preprocessedFileInformation.isLibFile) {
                    resolutionResult.seenNoDefaultLibTag = true;
                }

                var normalizedReferencePaths = [];
                preprocessedFileInformation.referencedFiles.forEach(function (fileReference) {
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, lineMap, fileReference.position, fileReference.length, false);
                    var normalizedReferencePath = _this.resolveIncludedFile(fileReference.path, currentReferenceLocation, resolutionResult);
                    normalizedReferencePaths.push(normalizedReferencePath);
                });

                var normalizedImportPaths = [];
                for (var i = 0; i < preprocessedFileInformation.importedFiles.length; i++) {
                    var fileImport = preprocessedFileInformation.importedFiles[i];
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, lineMap, fileImport.position, fileImport.length, true);
                    var normalizedImportPath = this.resolveImportedFile(fileImport.path, currentReferenceLocation, resolutionResult);
                    normalizedImportPaths.push(normalizedImportPath);
                }

                resolutionResult.resolvedFiles.push({
                    path: normalizedPath,
                    referencedFiles: normalizedReferencePaths,
                    importedFiles: normalizedImportPaths
                });
            } else {
                normalizedPath = visitedPath;
            }

            return normalizedPath;
        };

        ReferenceResolver.prototype.getNormalizedFilePath = function (path, parentFilePath) {
            var parentFileDirectory = parentFilePath ? this.host.getParentDirectory(parentFilePath) : "";
            var normalizedPath = this.host.resolveRelativePath(path, parentFileDirectory);
            return normalizedPath;
        };

        ReferenceResolver.prototype.getUniqueFileId = function (filePath) {
            return this.useCaseSensitiveFileResolution ? filePath : filePath.toLocaleUpperCase();
        };

        ReferenceResolver.prototype.recordVisitedFile = function (filePath) {
            this.visited[this.getUniqueFileId(filePath)] = filePath;
        };

        ReferenceResolver.prototype.isVisited = function (filePath) {
            return this.visited[this.getUniqueFileId(filePath)];
        };

        ReferenceResolver.prototype.isSameFile = function (filePath1, filePath2) {
            if (!filePath1 || !filePath2) {
                return false;
            }

            if (this.useCaseSensitiveFileResolution) {
                return filePath1 === filePath2;
            } else {
                return filePath1.toLocaleUpperCase() === filePath2.toLocaleUpperCase();
            }
        };
        return ReferenceResolver;
    })();
    TypeScript.ReferenceResolver = ReferenceResolver;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextWriter = (function () {
        function TextWriter(name, writeByteOrderMark, outputFileType) {
            this.name = name;
            this.writeByteOrderMark = writeByteOrderMark;
            this.outputFileType = outputFileType;
            this.contents = "";
            this.onNewLine = true;
        }
        TextWriter.prototype.Write = function (s) {
            this.contents += s;
            this.onNewLine = false;
        };

        TextWriter.prototype.WriteLine = function (s) {
            this.contents += s;
            this.contents += TypeScript.newLine();
            this.onNewLine = true;
        };

        TextWriter.prototype.Close = function () {
        };

        TextWriter.prototype.getOutputFile = function () {
            return new TypeScript.OutputFile(this.name, this.writeByteOrderMark, this.contents, this.outputFileType);
        };
        return TextWriter;
    })();
    TypeScript.TextWriter = TextWriter;

    var DeclarationEmitter = (function () {
        function DeclarationEmitter(emittingFileName, document, compiler, emitOptions, semanticInfoChain) {
            this.emittingFileName = emittingFileName;
            this.document = document;
            this.compiler = compiler;
            this.emitOptions = emitOptions;
            this.semanticInfoChain = semanticInfoChain;
            this.declFile = null;
            this.indenter = new TypeScript.Indenter();
            this.emittedReferencePaths = false;
            this.declFile = new TextWriter(emittingFileName, this.document.byteOrderMark !== 0 /* None */, 2 /* Declaration */);
        }
        DeclarationEmitter.prototype.getOutputFile = function () {
            return this.declFile.getOutputFile();
        };

        DeclarationEmitter.prototype.emitDeclarations = function (sourceUnit) {
            this.emitDeclarationsForSourceUnit(sourceUnit);
        };

        DeclarationEmitter.prototype.emitDeclarationsForList = function (list) {
            for (var i = 0, n = list.length; i < n; i++) {
                this.emitDeclarationsForAST(list[i]);
            }
        };

        DeclarationEmitter.prototype.emitSeparatedList = function (list) {
            for (var i = 0, n = list.length; i < n; i++) {
                this.emitDeclarationsForAST(list[i]);
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForAST = function (ast) {
            switch (ast.kind()) {
                case 149 /* VariableStatement */:
                    return this.emitDeclarationsForVariableStatement(ast);
                case 142 /* PropertySignature */:
                    return this.emitPropertySignature(ast);
                case 226 /* VariableDeclarator */:
                    return this.emitVariableDeclarator(ast, true, true);
                case 137 /* MemberVariableDeclaration */:
                    return this.emitDeclarationsForMemberVariableDeclaration(ast);
                case 138 /* ConstructorDeclaration */:
                    return this.emitDeclarationsForConstructorDeclaration(ast);
                case 140 /* GetAccessor */:
                    return this.emitDeclarationsForGetAccessor(ast);
                case 141 /* SetAccessor */:
                    return this.emitDeclarationsForSetAccessor(ast);
                case 139 /* IndexMemberDeclaration */:
                    return this.emitIndexMemberDeclaration(ast);
                case 145 /* IndexSignature */:
                    return this.emitIndexSignature(ast);
                case 143 /* CallSignature */:
                    return this.emitCallSignature(ast);
                case 144 /* ConstructSignature */:
                    return this.emitConstructSignature(ast);
                case 146 /* MethodSignature */:
                    return this.emitMethodSignature(ast);
                case 130 /* FunctionDeclaration */:
                    return this.emitDeclarationsForFunctionDeclaration(ast);
                case 136 /* MemberFunctionDeclaration */:
                    return this.emitMemberFunctionDeclaration(ast);
                case 132 /* ClassDeclaration */:
                    return this.emitDeclarationsForClassDeclaration(ast);
                case 129 /* InterfaceDeclaration */:
                    return this.emitDeclarationsForInterfaceDeclaration(ast);
                case 134 /* ImportDeclaration */:
                    return this.emitDeclarationsForImportDeclaration(ast);
                case 131 /* ModuleDeclaration */:
                    return this.emitDeclarationsForModuleDeclaration(ast);
                case 133 /* EnumDeclaration */:
                    return this.emitDeclarationsForEnumDeclaration(ast);
                case 135 /* ExportAssignment */:
                    return this.emitDeclarationsForExportAssignment(ast);
            }
        };

        DeclarationEmitter.prototype.getIndentString = function (declIndent) {
            if (typeof declIndent === "undefined") { declIndent = false; }
            return this.indenter.getIndent();
        };

        DeclarationEmitter.prototype.emitIndent = function () {
            this.declFile.Write(this.getIndentString());
        };

        DeclarationEmitter.prototype.canEmitDeclarations = function (declAST) {
            var container = DeclarationEmitter.getEnclosingContainer(declAST);
            if (container.kind() === 131 /* ModuleDeclaration */ || container.kind() === 120 /* SourceUnit */) {
                var pullDecl = this.semanticInfoChain.getDeclForAST(declAST);
                if (!TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */)) {
                    var start = new Date().getTime();
                    var declSymbol = this.semanticInfoChain.getSymbolForAST(declAST);
                    var result = declSymbol && declSymbol.isExternallyVisible();
                    TypeScript.declarationEmitIsExternallyVisibleTime += new Date().getTime() - start;

                    return result;
                }
            }

            return true;
        };

        DeclarationEmitter.prototype.getDeclFlagsString = function (pullDecl, typeString) {
            var result = this.getIndentString();
            var pullFlags = pullDecl.flags;

            if (TypeScript.hasFlag(pullFlags, 16 /* Static */)) {
                if (TypeScript.hasFlag(pullFlags, 2 /* Private */)) {
                    result += "private ";
                }
                result += "static ";
            } else {
                if (TypeScript.hasFlag(pullFlags, 2 /* Private */)) {
                    result += "private ";
                } else if (TypeScript.hasFlag(pullFlags, 4 /* Public */)) {
                    result += "public ";
                } else {
                    var emitDeclare = !TypeScript.hasFlag(pullFlags, 1 /* Exported */);

                    var declAST = this.semanticInfoChain.getASTForDecl(pullDecl);
                    var container = DeclarationEmitter.getEnclosingContainer(declAST);

                    var isExternalModule = container.kind() === 120 /* SourceUnit */ && this.document.syntaxTree().isExternalModule();

                    if (isExternalModule && TypeScript.hasFlag(pullFlags, 1 /* Exported */)) {
                        result += "export ";
                        emitDeclare = true;
                    }

                    if (isExternalModule || container.kind() === 120 /* SourceUnit */) {
                        if (emitDeclare && typeString !== "interface" && typeString !== "import") {
                            result += "declare ";
                        }
                    }

                    result += typeString + " ";
                }
            }

            return result;
        };

        DeclarationEmitter.prototype.emitDeclFlags = function (declarationAST, typeString) {
            this.declFile.Write(this.getDeclFlagsString(this.semanticInfoChain.getDeclForAST(declarationAST), typeString));
        };

        DeclarationEmitter.prototype.emitTypeNamesMember = function (memberName, emitIndent) {
            if (typeof emitIndent === "undefined") { emitIndent = false; }
            if (memberName.prefix === "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix !== "") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }

            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write(memberName.text);
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim === "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }

            if (memberName.suffix === "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        };

        DeclarationEmitter.prototype.emitTypeSignature = function (ast, type) {
            var declarationContainerAst = DeclarationEmitter.getEnclosingContainer(ast);

            var start = new Date().getTime();
            var declarationContainerDecl = this.semanticInfoChain.getDeclForAST(declarationContainerAst);

            var declarationPullSymbol = declarationContainerDecl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitTypeSignatureTime += new Date().getTime() - start;

            var isNotAGenericType = ast.kind() !== 126 /* GenericType */;

            var typeNameMembers = type.getScopedNameEx(declarationPullSymbol, false, false, false, false, false, isNotAGenericType);
            this.emitTypeNamesMember(typeNameMembers);
        };

        DeclarationEmitter.prototype.emitComment = function (comment) {
            var text = TypeScript.getTrimmedTextLines(comment);
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (comment.kind() !== 6 /* MultiLineCommentTrivia */) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }

            this.declFile.Write(text[0]);

            for (var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }

            if (comment.endsLine || comment.kind() !== 6 /* MultiLineCommentTrivia */) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        };

        DeclarationEmitter.prototype.text = function () {
            return this.document.syntaxTree().text;
        };

        DeclarationEmitter.prototype.emitDeclarationComments = function (astOrSymbol, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (this.emitOptions.compilationSettings().removeComments()) {
                return;
            }

            var declComments = astOrSymbol.docComments ? astOrSymbol.docComments() : TypeScript.ASTHelpers.docComments(astOrSymbol, this.text());
            this.writeDeclarationComments(declComments, endLine);
        };

        DeclarationEmitter.prototype.writeDeclarationComments = function (declComments, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (declComments) {
                var wroteComment = false;
                for (var i = 0; i < declComments.length; i++) {
                    if (TypeScript.ASTHelpers.isDocComment(declComments[i])) {
                        this.emitComment(declComments[i]);
                        wroteComment = true;
                    }
                }

                if (wroteComment) {
                    if (endLine) {
                        if (!this.declFile.onNewLine) {
                            this.declFile.WriteLine("");
                        }
                    } else {
                        if (this.declFile.onNewLine) {
                            this.emitIndent();
                        }
                    }
                }
            }
        };

        DeclarationEmitter.prototype.emitTypeOfVariableDeclaratorOrParameter = function (boundDecl) {
            var start = new Date().getTime();
            var decl = this.semanticInfoChain.getDeclForAST(boundDecl);
            var pullSymbol = decl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitGetBoundDeclTypeTime += new Date().getTime() - start;

            var type = pullSymbol.type;
            TypeScript.Debug.assert(type);

            this.declFile.Write(": ");
            this.emitTypeSignature(boundDecl, type);
        };

        DeclarationEmitter.prototype.emitPropertySignature = function (varDecl) {
            this.emitDeclarationComments(varDecl);
            this.emitIndent();
            this.declFile.Write(varDecl.propertyName.text());
            if (varDecl.questionToken) {
                this.declFile.Write("?");
            }

            this.emitTypeOfVariableDeclaratorOrParameter(varDecl);

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitVariableDeclarator = function (varDecl, isFirstVarInList, isLastVarInList) {
            if (this.canEmitDeclarations(varDecl)) {
                this.emitDeclarationComments(varDecl);

                if (isFirstVarInList) {
                    this.emitDeclFlags(varDecl, "var");
                }

                this.declFile.Write(varDecl.propertyName.text());

                if (!TypeScript.hasModifier(TypeScript.ASTHelpers.getVariableDeclaratorModifiers(varDecl), 2 /* Private */)) {
                    this.emitTypeOfVariableDeclaratorOrParameter(varDecl);
                }

                if (isLastVarInList) {
                    this.declFile.WriteLine(";");
                } else {
                    this.declFile.Write(", ");
                }
            }
        };

        DeclarationEmitter.prototype.emitClassElementModifiers = function (modifiers) {
            if (TypeScript.hasModifier(modifiers, 16 /* Static */)) {
                if (TypeScript.hasModifier(modifiers, 2 /* Private */)) {
                    this.declFile.Write("private ");
                }
                this.declFile.Write("static ");
            } else {
                if (TypeScript.hasModifier(modifiers, 2 /* Private */)) {
                    this.declFile.Write("private ");
                } else {
                    this.declFile.Write("public ");
                }
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForMemberVariableDeclaration = function (varDecl) {
            if (this.canEmitDeclarations(varDecl)) {
                this.emitDeclarationComments(varDecl);

                this.declFile.Write(this.getIndentString());
                this.emitClassElementModifiers(varDecl.modifiers);
                ;

                this.declFile.Write(varDecl.variableDeclarator.propertyName.text());

                if (!TypeScript.hasModifier(varDecl.modifiers, 2 /* Private */)) {
                    this.emitTypeOfVariableDeclaratorOrParameter(varDecl);
                }

                this.declFile.WriteLine(";");
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForVariableStatement = function (variableStatement) {
            this.emitDeclarationsForVariableDeclaration(variableStatement.variableDeclaration);
        };

        DeclarationEmitter.prototype.emitDeclarationsForVariableDeclaration = function (variableDeclaration) {
            var varListCount = variableDeclaration.variableDeclarators.length;
            for (var i = 0; i < varListCount; i++) {
                this.emitVariableDeclarator(variableDeclaration.variableDeclarators[i], i === 0, i === varListCount - 1);
            }
        };

        DeclarationEmitter.prototype.parameterIsOptional = function (parameter) {
            return parameter.questionToken !== null || parameter.equalsValueClause !== null;
        };

        DeclarationEmitter.prototype.emitParameter = function (argDecl, isPrivate) {
            this.indenter.increaseIndent();

            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.identifier.text());
            if (this.parameterIsOptional(argDecl)) {
                this.declFile.Write("?");
            }

            this.indenter.decreaseIndent();

            if (!isPrivate) {
                this.emitTypeOfVariableDeclaratorOrParameter(argDecl);
            }
        };

        DeclarationEmitter.prototype.isOverloadedCallSignature = function (funcDecl) {
            var start = new Date().getTime();
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSymbol = functionDecl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitIsOverloadedCallSignatureTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            var signatures = funcTypeSymbol.getCallSignatures();
            var result = signatures && signatures.length > 1;

            return result;
        };

        DeclarationEmitter.prototype.emitDeclarationsForConstructorDeclaration = function (funcDecl) {
            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return;
                }
            }

            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write("constructor");

            this.emitParameterList(false, funcDecl.callSignature.parameterList);

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitParameterList = function (isPrivate, parameterList) {
            this.declFile.Write("(");
            this.emitParameters(isPrivate, parameterList.parameters);
            this.declFile.Write(")");
        };

        DeclarationEmitter.prototype.emitParameters = function (isPrivate, parameterList) {
            var hasLastParameterRestParameter = TypeScript.lastParameterIsRest(parameterList);
            var argsLen = parameterList.length;
            if (hasLastParameterRestParameter) {
                argsLen--;
            }

            for (var i = 0; i < argsLen; i++) {
                this.emitParameter(parameterList[i], isPrivate);
                if (i < (argsLen - 1)) {
                    this.declFile.Write(", ");
                }
            }

            if (hasLastParameterRestParameter) {
                if (parameterList.length > 1) {
                    this.declFile.Write(", ...");
                } else {
                    this.declFile.Write("...");
                }

                var index = parameterList.length - 1;
                this.emitParameter(parameterList[index], isPrivate);
            }
        };

        DeclarationEmitter.prototype.emitMemberFunctionDeclaration = function (funcDecl) {
            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return;
                } else if (this.isOverloadedCallSignature(funcDecl)) {
                    return;
                }
            } else if (TypeScript.hasModifier(funcDecl.modifiers, 2 /* Private */) && this.isOverloadedCallSignature(funcDecl)) {
                var callSignatures = funcTypeSymbol.getCallSignatures();
                TypeScript.Debug.assert(callSignatures && callSignatures.length > 1);
                var firstSignature = callSignatures[0].isDefinition() ? callSignatures[1] : callSignatures[0];
                var firstSignatureDecl = firstSignature.getDeclarations()[0];
                var firstFuncDecl = this.semanticInfoChain.getASTForDecl(firstSignatureDecl);
                if (firstFuncDecl !== funcDecl) {
                    return;
                }
            }

            if (!this.canEmitDeclarations(funcDecl)) {
                return;
            }

            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitDeclarationComments(funcDecl);

            this.emitDeclFlags(funcDecl, "function");
            var id = funcDecl.propertyName.text();
            this.declFile.Write(id);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            var isPrivate = TypeScript.hasModifier(funcDecl.modifiers, 2 /* Private */);

            this.emitParameterList(isPrivate, funcDecl.callSignature.parameterList);

            if (!isPrivate) {
                var returnType = funcSignature.returnType;
                this.declFile.Write(": ");
                this.emitTypeSignature(funcDecl, returnType);
            }

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitCallSignature = function (funcDecl) {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            this.emitDeclarationComments(funcDecl);

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.typeParameterList, funcSignature);

            this.emitIndent();

            this.emitParameterList(false, funcDecl.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            } else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitConstructSignature = function (funcDecl) {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write("new");

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            this.emitParameterList(false, funcDecl.callSignature.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            } else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitMethodSignature = function (funcDecl) {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write(funcDecl.propertyName.text());
            if (funcDecl.questionToken) {
                this.declFile.Write("? ");
            }

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            this.emitParameterList(false, funcDecl.callSignature.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            } else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitDeclarationsForFunctionDeclaration = function (funcDecl) {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            if (funcDecl.block) {
                var funcTypeSymbol = funcSymbol.type;
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return;
                } else if (this.isOverloadedCallSignature(funcDecl)) {
                    return;
                }
            }

            if (!this.canEmitDeclarations(funcDecl)) {
                return;
            }

            this.emitDeclarationComments(funcDecl);

            var id = funcDecl.identifier.text();
            this.emitDeclFlags(funcDecl, "function");
            if (id !== "" || !funcDecl.identifier || funcDecl.identifier.text().length > 0) {
                this.declFile.Write(id);
            } else if (funcPullDecl.kind === 2097152 /* ConstructSignature */) {
                this.declFile.Write("new");
            }

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            this.emitParameterList(false, funcDecl.callSignature.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            } else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitIndexMemberDeclaration = function (funcDecl) {
            this.emitDeclarationsForAST(funcDecl.indexSignature);
        };

        DeclarationEmitter.prototype.emitIndexSignature = function (funcDecl) {
            if (!this.canEmitDeclarations(funcDecl)) {
                return;
            }

            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write("[");
            this.emitParameters(false, funcDecl.parameters);
            this.declFile.Write("]");

            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            this.emitTypeSignature(funcDecl, returnType);

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitBaseList = function (bases, useExtendsList) {
            if (bases && (bases.length > 0)) {
                var qual = useExtendsList ? "extends" : "implements";
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.length;
                for (var i = 0; i < basesLen; i++) {
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    var base = bases[i];
                    var baseType = this.semanticInfoChain.getSymbolForAST(base);
                    this.emitTypeSignature(base, baseType);
                }
            }
        };

        DeclarationEmitter.prototype.emitAccessorDeclarationComments = function (funcDecl) {
            if (this.emitOptions.compilationSettings().removeComments()) {
                return;
            }

            var start = new Date().getTime();
            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            var comments = [];
            if (accessors.getter) {
                comments = comments.concat(TypeScript.ASTHelpers.docComments(accessors.getter, this.text()));
            }
            if (accessors.setter) {
                comments = comments.concat(TypeScript.ASTHelpers.docComments(accessors.setter, this.text()));
            }

            this.writeDeclarationComments(comments);
        };

        DeclarationEmitter.prototype.emitDeclarationsForGetAccessor = function (funcDecl) {
            this.emitMemberAccessorDeclaration(funcDecl, funcDecl.modifiers, funcDecl.propertyName);
        };

        DeclarationEmitter.prototype.emitDeclarationsForSetAccessor = function (funcDecl) {
            this.emitMemberAccessorDeclaration(funcDecl, funcDecl.modifiers, funcDecl.propertyName);
        };

        DeclarationEmitter.prototype.emitMemberAccessorDeclaration = function (funcDecl, modifiers, name) {
            var start = new Date().getTime();
            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            if (funcDecl.kind() === 141 /* SetAccessor */ && accessorSymbol.getGetter()) {
                return;
            }

            var isPrivate = TypeScript.hasModifier(modifiers, 2 /* Private */);
            this.emitAccessorDeclarationComments(funcDecl);
            this.declFile.Write(this.getIndentString());
            this.emitClassElementModifiers(modifiers);
            this.declFile.Write(name.text());
            if (!isPrivate) {
                this.declFile.Write(" : ");
                var type = accessorSymbol.type;
                this.emitTypeSignature(funcDecl, type);
            }
            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitClassMembersFromConstructorDefinition = function (funcDecl) {
            var argsLen = funcDecl.callSignature.parameterList.parameters.length;
            if (TypeScript.lastParameterIsRest(funcDecl.callSignature.parameterList.parameters)) {
                argsLen--;
            }

            for (var i = 0; i < argsLen; i++) {
                var parameter = funcDecl.callSignature.parameterList.parameters[i];
                var parameterDecl = this.semanticInfoChain.getDeclForAST(parameter);
                if (TypeScript.hasFlag(parameterDecl.flags, 8388608 /* PropertyParameter */)) {
                    var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
                    this.emitDeclarationComments(parameter);
                    this.declFile.Write(this.getIndentString());
                    this.emitClassElementModifiers(parameter.modifiers);
                    this.declFile.Write(parameter.identifier.text());

                    if (!TypeScript.hasModifier(parameter.modifiers, 2 /* Private */)) {
                        this.emitTypeOfVariableDeclaratorOrParameter(parameter);
                    }
                    this.declFile.WriteLine(";");
                }
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForClassDeclaration = function (classDecl) {
            if (!this.canEmitDeclarations(classDecl)) {
                return;
            }

            var className = classDecl.identifier.text();
            this.emitDeclarationComments(classDecl);
            var classPullDecl = this.semanticInfoChain.getDeclForAST(classDecl);
            this.emitDeclFlags(classDecl, "class");
            this.declFile.Write(className);

            this.emitTypeParameters(classDecl.typeParameterList);
            this.emitHeritageClauses(classDecl.heritageClauses);
            this.declFile.WriteLine(" {");

            this.indenter.increaseIndent();
            var constructorDecl = TypeScript.getLastConstructor(classDecl);
            if (constructorDecl) {
                this.emitClassMembersFromConstructorDefinition(constructorDecl);
            }

            this.emitDeclarationsForList(classDecl.classElements);

            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");
        };

        DeclarationEmitter.prototype.emitHeritageClauses = function (clauses) {
            if (clauses) {
                for (var i = 0, n = clauses.length; i < n; i++) {
                    this.emitHeritageClause(clauses[i]);
                }
            }
        };

        DeclarationEmitter.prototype.emitHeritageClause = function (clause) {
            this.emitBaseList(clause.typeNames, clause.kind() === 231 /* ExtendsHeritageClause */);
        };

        DeclarationEmitter.getEnclosingContainer = function (ast) {
            var enclosingModule = TypeScript.ASTHelpers.getModuleDeclarationFromNameAST(ast);
            ast = enclosingModule || ast;

            ast = ast.parent;
            while (ast) {
                if (ast.kind() === 132 /* ClassDeclaration */ || ast.kind() === 129 /* InterfaceDeclaration */ || ast.kind() === 131 /* ModuleDeclaration */ || ast.kind() === 120 /* SourceUnit */) {
                    return ast;
                }

                ast = ast.parent;
            }

            return null;
        };

        DeclarationEmitter.prototype.emitTypeParameters = function (typeParams, funcSignature) {
            if (!typeParams || !typeParams.typeParameters.length) {
                return;
            }

            this.declFile.Write("<");
            var containerAst = DeclarationEmitter.getEnclosingContainer(typeParams);

            var start = new Date().getTime();
            var containerDecl = this.semanticInfoChain.getDeclForAST(containerAst);
            var containerSymbol = containerDecl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitGetTypeParameterSymbolTime += new Date().getTime() - start;

            var typars;
            if (funcSignature) {
                typars = funcSignature.getTypeParameters();
            } else {
                typars = containerSymbol.getTypeArgumentsOrTypeParameters();
            }

            for (var i = 0; i < typars.length; i++) {
                if (i) {
                    this.declFile.Write(", ");
                }

                var memberName = typars[i].getScopedNameEx(containerSymbol, false, true);
                this.emitTypeNamesMember(memberName);
            }

            this.declFile.Write(">");
        };

        DeclarationEmitter.prototype.emitDeclarationsForInterfaceDeclaration = function (interfaceDecl) {
            if (!this.canEmitDeclarations(interfaceDecl)) {
                return;
            }

            var interfaceName = interfaceDecl.identifier.text();
            this.emitDeclarationComments(interfaceDecl);
            var interfacePullDecl = this.semanticInfoChain.getDeclForAST(interfaceDecl);
            this.emitDeclFlags(interfaceDecl, "interface");
            this.declFile.Write(interfaceName);

            this.emitTypeParameters(interfaceDecl.typeParameterList);
            this.emitHeritageClauses(interfaceDecl.heritageClauses);
            this.declFile.WriteLine(" {");

            this.indenter.increaseIndent();

            this.emitSeparatedList(interfaceDecl.body.typeMembers);

            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");
        };

        DeclarationEmitter.prototype.emitDeclarationsForImportDeclaration = function (importDeclAST) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST);
            var importSymbol = importDecl.getSymbol(this.semanticInfoChain);
            var isExportedImportDecl = TypeScript.hasModifier(importDeclAST.modifiers, 1 /* Exported */);

            if (isExportedImportDecl || importSymbol.typeUsedExternally() || TypeScript.PullContainerSymbol.usedAsSymbol(importSymbol.getContainer(), importSymbol)) {
                this.emitDeclarationComments(importDeclAST);
                this.emitIndent();
                if (isExportedImportDecl) {
                    this.declFile.Write("export ");
                }
                this.declFile.Write("import ");
                this.declFile.Write(importDeclAST.identifier.text() + " = ");
                if (importDeclAST.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                    this.declFile.WriteLine("require(" + importDeclAST.moduleReference.stringLiteral.text() + ");");
                } else {
                    this.declFile.WriteLine(TypeScript.ASTHelpers.getNameOfIdenfierOrQualifiedName(importDeclAST.moduleReference.moduleName) + ";");
                }
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForEnumDeclaration = function (moduleDecl) {
            if (!this.canEmitDeclarations(moduleDecl)) {
                return;
            }

            this.emitDeclarationComments(moduleDecl);
            var modulePullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl);
            this.emitDeclFlags(moduleDecl, "enum");
            this.declFile.WriteLine(moduleDecl.identifier.text() + " {");

            this.indenter.increaseIndent();
            var membersLen = moduleDecl.enumElements.length;
            for (var j = 0; j < membersLen; j++) {
                var enumElement = moduleDecl.enumElements[j];
                var enumElementDecl = this.semanticInfoChain.getDeclForAST(enumElement);
                this.emitDeclarationComments(enumElement);
                this.emitIndent();
                this.declFile.Write(enumElement.propertyName.text());
                if (enumElementDecl.constantValue !== null) {
                    this.declFile.Write(" = " + enumElementDecl.constantValue);
                }
                this.declFile.WriteLine(",");
            }
            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");
        };

        DeclarationEmitter.prototype.emitDeclarationsForModuleDeclaration = function (moduleDecl) {
            var name = moduleDecl.stringLiteral || TypeScript.ArrayUtilities.first(TypeScript.ASTHelpers.getModuleNames(moduleDecl.name));
            if (!this.canEmitDeclarations(name)) {
                return;
            }

            this.emitDeclarationComments(moduleDecl);
            this.emitDeclFlags(name, "module");

            if (moduleDecl.stringLiteral) {
                this.declFile.Write(moduleDecl.stringLiteral.text());
            } else {
                this.declFile.Write(TypeScript.ASTHelpers.getNameOfIdenfierOrQualifiedName(moduleDecl.name));
            }

            this.declFile.WriteLine(" {");
            this.indenter.increaseIndent();

            this.emitDeclarationsForList(moduleDecl.moduleElements);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.declFile.WriteLine("}");
        };

        DeclarationEmitter.prototype.emitDeclarationsForExportAssignment = function (ast) {
            this.emitIndent();
            this.declFile.Write("export = ");
            this.declFile.Write(ast.identifier.text());
            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.resolveScriptReference = function (document, reference) {
            if (!this.emitOptions.compilationSettings().noResolve() || TypeScript.isRooted(reference)) {
                return reference;
            }

            var documentDir = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(TypeScript.getRootFilePath(document.fileName)));
            var resolvedReferencePath = this.emitOptions.resolvePath(documentDir + reference);
            return resolvedReferencePath;
        };

        DeclarationEmitter.prototype.emitReferencePaths = function (sourceUnit) {
            if (this.emittedReferencePaths) {
                return;
            }

            var documents = [];
            if (this.document.emitToOwnOutputFile()) {
                var scriptReferences = this.document.referencedFiles;
                var addedGlobalDocument = false;
                for (var j = 0; j < scriptReferences.length; j++) {
                    var currentReference = this.resolveScriptReference(this.document, scriptReferences[j]);
                    var document = this.compiler.getDocument(currentReference);

                    if (document && (document.emitToOwnOutputFile() || document.isDeclareFile() || !addedGlobalDocument)) {
                        documents = documents.concat(document);

                        if (!document.isDeclareFile() && document.syntaxTree().isExternalModule()) {
                            addedGlobalDocument = true;
                        }
                    }
                }
            } else {
                var fileNames = this.compiler.fileNames();
                for (var i = 0; i < fileNames.length; i++) {
                    var doc = this.compiler.getDocument(fileNames[i]);
                    if (!doc.isDeclareFile() && !doc.syntaxTree().isExternalModule()) {
                        var scriptReferences = doc.referencedFiles;
                        for (var j = 0; j < scriptReferences.length; j++) {
                            var currentReference = this.resolveScriptReference(doc, scriptReferences[j]);
                            var document = this.compiler.getDocument(currentReference);

                            if (document && (document.isDeclareFile() || document.syntaxTree().isExternalModule())) {
                                for (var k = 0; k < documents.length; k++) {
                                    if (documents[k] === document) {
                                        break;
                                    }
                                }

                                if (k === documents.length) {
                                    documents = documents.concat(document);
                                }
                            }
                        }
                    }
                }
            }

            var emittingFilePath = documents.length ? TypeScript.getRootFilePath(this.emittingFileName) : null;
            for (var i = 0; i < documents.length; i++) {
                var document = documents[i];
                var declFileName;
                if (document.isDeclareFile()) {
                    declFileName = document.fileName;
                } else {
                    declFileName = this.compiler.mapOutputFileName(document, this.emitOptions, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                }

                declFileName = TypeScript.getRelativePathToFixedPath(emittingFilePath, declFileName, false);
                this.declFile.WriteLine('/// <reference path="' + declFileName + '" />');
            }

            this.emittedReferencePaths = true;
        };

        DeclarationEmitter.prototype.emitDeclarationsForSourceUnit = function (sourceUnit) {
            this.emitReferencePaths(sourceUnit);
            this.emitDeclarationsForList(sourceUnit.moduleElements);
        };
        return DeclarationEmitter;
    })();
    TypeScript.DeclarationEmitter = DeclarationEmitter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BloomFilter = (function () {
        function BloomFilter(expectedCount) {
            var m = Math.max(1, BloomFilter.computeM(expectedCount));
            var k = Math.max(1, BloomFilter.computeK(expectedCount));
            ;

            var sizeInEvenBytes = (m + 7) & ~7;

            this.bitArray = [];
            for (var i = 0, len = sizeInEvenBytes; i < len; i++) {
                this.bitArray[i] = false;
            }
            this.hashFunctionCount = k;
        }
        BloomFilter.computeM = function (expectedCount) {
            var p = BloomFilter.falsePositiveProbability;
            var n = expectedCount;

            var numerator = n * Math.log(p);
            var denominator = Math.log(1.0 / Math.pow(2.0, Math.log(2.0)));
            return Math.ceil(numerator / denominator);
        };

        BloomFilter.computeK = function (expectedCount) {
            var n = expectedCount;
            var m = BloomFilter.computeM(expectedCount);

            var temp = Math.log(2.0) * m / n;
            return Math.round(temp);
        };

        BloomFilter.prototype.computeHash = function (key, seed) {
            return TypeScript.Hash.computeMurmur2StringHashCode(key, seed);
        };

        BloomFilter.prototype.addKeys = function (keys) {
            for (var name in keys) {
                if (keys[name]) {
                    this.add(name);
                }
            }
        };

        BloomFilter.prototype.add = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                this.bitArray[Math.abs(hash)] = true;
            }
        };

        BloomFilter.prototype.probablyContains = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                if (!this.bitArray[Math.abs(hash)]) {
                    return false;
                }
            }

            return true;
        };

        BloomFilter.prototype.isEquivalent = function (filter) {
            return BloomFilter.isEquivalent(this.bitArray, filter.bitArray) && this.hashFunctionCount === filter.hashFunctionCount;
        };

        BloomFilter.isEquivalent = function (array1, array2) {
            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0; i < array1.length; i++) {
                if (array1[i] !== array2[i]) {
                    return false;
                }
            }

            return true;
        };
        BloomFilter.falsePositiveProbability = 0.0001;
        return BloomFilter;
    })();
    TypeScript.BloomFilter = BloomFilter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IdentifierWalker = (function (_super) {
        __extends(IdentifierWalker, _super);
        function IdentifierWalker(list) {
            _super.call(this);
            this.list = list;
        }
        IdentifierWalker.prototype.visitToken = function (token) {
            this.list[token.text()] = true;
        };
        return IdentifierWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.IdentifierWalker = IdentifierWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.propagateEnumConstants = false;
            this.removeComments = false;
            this.watch = false;
            this.noResolve = false;
            this.allowAutomaticSemicolonInsertion = true;
            this.noImplicitAny = false;
            this.noLib = false;
            this.codeGenTarget = 0 /* EcmaScript3 */;
            this.moduleGenTarget = 0 /* Unspecified */;
            this.outFileOption = "";
            this.outDirOption = "";
            this.mapSourceFiles = false;
            this.mapRoot = "";
            this.sourceRoot = "";
            this.generateDeclarationFiles = false;
            this.useCaseSensitiveFileResolution = false;
            this.gatherDiagnostics = false;
            this.codepage = null;
        }
        return CompilationSettings;
    })();
    TypeScript.CompilationSettings = CompilationSettings;

    var ImmutableCompilationSettings = (function () {
        function ImmutableCompilationSettings(propagateEnumConstants, removeComments, watch, noResolve, allowAutomaticSemicolonInsertion, noImplicitAny, noLib, codeGenTarget, moduleGenTarget, outFileOption, outDirOption, mapSourceFiles, mapRoot, sourceRoot, generateDeclarationFiles, useCaseSensitiveFileResolution, gatherDiagnostics, codepage) {
            this._propagateEnumConstants = propagateEnumConstants;
            this._removeComments = removeComments;
            this._watch = watch;
            this._noResolve = noResolve;
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
            this._noImplicitAny = noImplicitAny;
            this._noLib = noLib;
            this._codeGenTarget = codeGenTarget;
            this._moduleGenTarget = moduleGenTarget;
            this._outFileOption = outFileOption;
            this._outDirOption = outDirOption;
            this._mapSourceFiles = mapSourceFiles;
            this._mapRoot = mapRoot;
            this._sourceRoot = sourceRoot;
            this._generateDeclarationFiles = generateDeclarationFiles;
            this._useCaseSensitiveFileResolution = useCaseSensitiveFileResolution;
            this._gatherDiagnostics = gatherDiagnostics;
            this._codepage = codepage;
        }
        ImmutableCompilationSettings.prototype.propagateEnumConstants = function () {
            return this._propagateEnumConstants;
        };
        ImmutableCompilationSettings.prototype.removeComments = function () {
            return this._removeComments;
        };
        ImmutableCompilationSettings.prototype.watch = function () {
            return this._watch;
        };
        ImmutableCompilationSettings.prototype.noResolve = function () {
            return this._noResolve;
        };
        ImmutableCompilationSettings.prototype.allowAutomaticSemicolonInsertion = function () {
            return this._allowAutomaticSemicolonInsertion;
        };
        ImmutableCompilationSettings.prototype.noImplicitAny = function () {
            return this._noImplicitAny;
        };
        ImmutableCompilationSettings.prototype.noLib = function () {
            return this._noLib;
        };
        ImmutableCompilationSettings.prototype.codeGenTarget = function () {
            return this._codeGenTarget;
        };
        ImmutableCompilationSettings.prototype.moduleGenTarget = function () {
            return this._moduleGenTarget;
        };
        ImmutableCompilationSettings.prototype.outFileOption = function () {
            return this._outFileOption;
        };
        ImmutableCompilationSettings.prototype.outDirOption = function () {
            return this._outDirOption;
        };
        ImmutableCompilationSettings.prototype.mapSourceFiles = function () {
            return this._mapSourceFiles;
        };
        ImmutableCompilationSettings.prototype.mapRoot = function () {
            return this._mapRoot;
        };
        ImmutableCompilationSettings.prototype.sourceRoot = function () {
            return this._sourceRoot;
        };
        ImmutableCompilationSettings.prototype.generateDeclarationFiles = function () {
            return this._generateDeclarationFiles;
        };
        ImmutableCompilationSettings.prototype.useCaseSensitiveFileResolution = function () {
            return this._useCaseSensitiveFileResolution;
        };
        ImmutableCompilationSettings.prototype.gatherDiagnostics = function () {
            return this._gatherDiagnostics;
        };
        ImmutableCompilationSettings.prototype.codepage = function () {
            return this._codepage;
        };

        ImmutableCompilationSettings.defaultSettings = function () {
            if (!ImmutableCompilationSettings._defaultSettings) {
                ImmutableCompilationSettings._defaultSettings = ImmutableCompilationSettings.fromCompilationSettings(new CompilationSettings());
            }

            return ImmutableCompilationSettings._defaultSettings;
        };

        ImmutableCompilationSettings.fromCompilationSettings = function (settings) {
            return new ImmutableCompilationSettings(settings.propagateEnumConstants, settings.removeComments, settings.watch, settings.noResolve, settings.allowAutomaticSemicolonInsertion, settings.noImplicitAny, settings.noLib, settings.codeGenTarget, settings.moduleGenTarget, settings.outFileOption, settings.outDirOption, settings.mapSourceFiles, settings.mapRoot, settings.sourceRoot, settings.generateDeclarationFiles, settings.useCaseSensitiveFileResolution, settings.gatherDiagnostics, settings.codepage);
        };

        ImmutableCompilationSettings.prototype.toCompilationSettings = function () {
            var result = new CompilationSettings();

            var thisAsIndexable = this;
            var resultAsIndexable = result;
            for (var name in this) {
                if (this.hasOwnProperty(name) && TypeScript.StringUtilities.startsWith(name, "_")) {
                    resultAsIndexable[name.substr(1)] = thisAsIndexable[name];
                }
            }

            return result;
        };
        return ImmutableCompilationSettings;
    })();
    TypeScript.ImmutableCompilationSettings = ImmutableCompilationSettings;

    function settingsChangeAffectsSyntax(before, after) {
        return before.allowAutomaticSemicolonInsertion() !== after.allowAutomaticSemicolonInsertion() || before.codeGenTarget() !== after.codeGenTarget() || before.propagateEnumConstants() !== after.propagateEnumConstants();
    }
    TypeScript.settingsChangeAffectsSyntax = settingsChangeAffectsSyntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullElementFlags) {
        PullElementFlags[PullElementFlags["None"] = 0] = "None";
        PullElementFlags[PullElementFlags["Exported"] = 1] = "Exported";
        PullElementFlags[PullElementFlags["Private"] = 1 << 1] = "Private";
        PullElementFlags[PullElementFlags["Public"] = 1 << 2] = "Public";
        PullElementFlags[PullElementFlags["Ambient"] = 1 << 3] = "Ambient";
        PullElementFlags[PullElementFlags["Static"] = 1 << 4] = "Static";
        PullElementFlags[PullElementFlags["Optional"] = 1 << 7] = "Optional";
        PullElementFlags[PullElementFlags["Signature"] = 1 << 11] = "Signature";
        PullElementFlags[PullElementFlags["Enum"] = 1 << 12] = "Enum";
        PullElementFlags[PullElementFlags["ArrowFunction"] = 1 << 13] = "ArrowFunction";

        PullElementFlags[PullElementFlags["ClassConstructorVariable"] = 1 << 14] = "ClassConstructorVariable";
        PullElementFlags[PullElementFlags["InitializedModule"] = 1 << 15] = "InitializedModule";
        PullElementFlags[PullElementFlags["InitializedDynamicModule"] = 1 << 16] = "InitializedDynamicModule";

        PullElementFlags[PullElementFlags["MustCaptureThis"] = 1 << 18] = "MustCaptureThis";

        PullElementFlags[PullElementFlags["DeclaredInAWithBlock"] = 1 << 21] = "DeclaredInAWithBlock";

        PullElementFlags[PullElementFlags["HasReturnStatement"] = 1 << 22] = "HasReturnStatement";

        PullElementFlags[PullElementFlags["PropertyParameter"] = 1 << 23] = "PropertyParameter";

        PullElementFlags[PullElementFlags["IsAnnotatedWithAny"] = 1 << 24] = "IsAnnotatedWithAny";

        PullElementFlags[PullElementFlags["HasDefaultArgs"] = 1 << 25] = "HasDefaultArgs";

        PullElementFlags[PullElementFlags["ConstructorParameter"] = 1 << 26] = "ConstructorParameter";

        PullElementFlags[PullElementFlags["ImplicitVariable"] = PullElementFlags.ClassConstructorVariable | PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.Enum] = "ImplicitVariable";
        PullElementFlags[PullElementFlags["SomeInitializedModule"] = PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.Enum] = "SomeInitializedModule";
    })(TypeScript.PullElementFlags || (TypeScript.PullElementFlags = {}));
    var PullElementFlags = TypeScript.PullElementFlags;

    function mapFlagToTokenKind(flag) {
        switch (flag) {
            case 8 /* Ambient */:
                return 63 /* DeclareKeyword */;
            case 1 /* Exported */:
                return 47 /* ExportKeyword */;
            case 4 /* Public */:
                return 57 /* PublicKeyword */;
            case 2 /* Private */:
                return 55 /* PrivateKeyword */;
            case 16 /* Static */:
                return 58 /* StaticKeyword */;
            default:
                throw TypeScript.Errors.invalidOperation();
        }
    }

    function hasModifier(modifiers, flag) {
        var kind = mapFlagToTokenKind(flag);

        for (var i = 0, n = modifiers.length; i < n; i++) {
            var modifier = modifiers[i];

            if (modifier.kind() === kind) {
                return true;
            }
        }

        return false;
    }
    TypeScript.hasModifier = hasModifier;

    (function (PullElementKind) {
        PullElementKind[PullElementKind["None"] = 0] = "None";
        PullElementKind[PullElementKind["Global"] = 0] = "Global";

        PullElementKind[PullElementKind["Script"] = 1 << 0] = "Script";
        PullElementKind[PullElementKind["Primitive"] = 1 << 1] = "Primitive";

        PullElementKind[PullElementKind["Container"] = 1 << 2] = "Container";
        PullElementKind[PullElementKind["Class"] = 1 << 3] = "Class";
        PullElementKind[PullElementKind["Interface"] = 1 << 4] = "Interface";
        PullElementKind[PullElementKind["DynamicModule"] = 1 << 5] = "DynamicModule";
        PullElementKind[PullElementKind["Enum"] = 1 << 6] = "Enum";
        PullElementKind[PullElementKind["TypeAlias"] = 1 << 7] = "TypeAlias";
        PullElementKind[PullElementKind["ObjectLiteral"] = 1 << 8] = "ObjectLiteral";

        PullElementKind[PullElementKind["Variable"] = 1 << 9] = "Variable";
        PullElementKind[PullElementKind["CatchVariable"] = 1 << 10] = "CatchVariable";
        PullElementKind[PullElementKind["Parameter"] = 1 << 11] = "Parameter";
        PullElementKind[PullElementKind["Property"] = 1 << 12] = "Property";
        PullElementKind[PullElementKind["TypeParameter"] = 1 << 13] = "TypeParameter";

        PullElementKind[PullElementKind["Function"] = 1 << 14] = "Function";
        PullElementKind[PullElementKind["ConstructorMethod"] = 1 << 15] = "ConstructorMethod";
        PullElementKind[PullElementKind["Method"] = 1 << 16] = "Method";
        PullElementKind[PullElementKind["FunctionExpression"] = 1 << 17] = "FunctionExpression";

        PullElementKind[PullElementKind["GetAccessor"] = 1 << 18] = "GetAccessor";
        PullElementKind[PullElementKind["SetAccessor"] = 1 << 19] = "SetAccessor";

        PullElementKind[PullElementKind["CallSignature"] = 1 << 20] = "CallSignature";
        PullElementKind[PullElementKind["ConstructSignature"] = 1 << 21] = "ConstructSignature";
        PullElementKind[PullElementKind["IndexSignature"] = 1 << 22] = "IndexSignature";

        PullElementKind[PullElementKind["ObjectType"] = 1 << 23] = "ObjectType";
        PullElementKind[PullElementKind["FunctionType"] = 1 << 24] = "FunctionType";
        PullElementKind[PullElementKind["ConstructorType"] = 1 << 25] = "ConstructorType";

        PullElementKind[PullElementKind["EnumMember"] = 1 << 26] = "EnumMember";

        PullElementKind[PullElementKind["WithBlock"] = 1 << 27] = "WithBlock";
        PullElementKind[PullElementKind["CatchBlock"] = 1 << 28] = "CatchBlock";

        PullElementKind[PullElementKind["All"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Container | PullElementKind.Class | PullElementKind.Interface | PullElementKind.DynamicModule | PullElementKind.Enum | PullElementKind.TypeAlias | PullElementKind.ObjectLiteral | PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.TypeParameter | PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.EnumMember | PullElementKind.WithBlock | PullElementKind.CatchBlock] = "All";

        PullElementKind[PullElementKind["SomeFunction"] = PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor] = "SomeFunction";

        PullElementKind[PullElementKind["SomeValue"] = PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.EnumMember | PullElementKind.SomeFunction] = "SomeValue";

        PullElementKind[PullElementKind["SomeType"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.ObjectLiteral | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.TypeParameter] = "SomeType";

        PullElementKind[PullElementKind["AcceptableAlias"] = PullElementKind.Variable | PullElementKind.SomeFunction | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.Container | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "AcceptableAlias";

        PullElementKind[PullElementKind["SomeContainer"] = PullElementKind.Container | PullElementKind.DynamicModule | PullElementKind.TypeAlias] = "SomeContainer";

        PullElementKind[PullElementKind["SomeSignature"] = PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature] = "SomeSignature";

        PullElementKind[PullElementKind["SomeTypeReference"] = PullElementKind.Interface | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "SomeTypeReference";

        PullElementKind[PullElementKind["SomeInstantiatableType"] = PullElementKind.Class | PullElementKind.Interface | PullElementKind.TypeParameter] = "SomeInstantiatableType";
    })(TypeScript.PullElementKind || (TypeScript.PullElementKind = {}));
    var PullElementKind = TypeScript.PullElementKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var pullDeclID = 0;
    var sentinelEmptyPullDeclArray = [];

    var PullDecl = (function () {
        function PullDecl(declName, displayName, kind, declFlags) {
            this.declID = pullDeclID++;
            this.flags = 0 /* None */;
            this.declGroups = null;
            this.childDecls = null;
            this.typeParameters = null;
            this.synthesizedValDecl = null;
            this.containerDecl = null;
            this.childDeclTypeCache = null;
            this.childDeclValueCache = null;
            this.childDeclNamespaceCache = null;
            this.childDeclTypeParameterCache = null;
            this.name = declName;
            this.kind = kind;
            this.flags = declFlags;

            if (displayName !== this.name) {
                this.declDisplayName = displayName;
            }
        }
        PullDecl.prototype.getASTForDeclMap = function () {
            throw TypeScript.Errors.abstract();
        };

        PullDecl.prototype.fileName = function () {
            throw TypeScript.Errors.abstract();
        };

        PullDecl.prototype.getParentPath = function () {
            throw TypeScript.Errors.abstract();
        };

        PullDecl.prototype.getParentDecl = function () {
            throw TypeScript.Errors.abstract();
        };

        PullDecl.prototype.isExternalModule = function () {
            throw TypeScript.Errors.abstract();
        };

        PullDecl.prototype.getEnclosingDecl = function () {
            throw TypeScript.Errors.abstract();
        };

        PullDecl.prototype._getEnclosingDeclFromParentDecl = function () {
            var decl = this;
            while (decl) {
                switch (decl.kind) {
                    default:
                        return decl;
                    case 512 /* Variable */:
                    case 8192 /* TypeParameter */:
                    case 2048 /* Parameter */:
                    case 128 /* TypeAlias */:
                    case 67108864 /* EnumMember */:
                }

                decl = decl.getParentDecl();
            }

            TypeScript.Debug.fail();
        };

        PullDecl.prototype.getDisplayName = function () {
            return this.declDisplayName === undefined ? this.name : this.declDisplayName;
        };

        PullDecl.prototype.setSymbol = function (symbol, semanticInfoChain) {
            semanticInfoChain.setSymbolForDecl(this, symbol);
        };

        PullDecl.prototype.ensureSymbolIsBound = function (semanticInfoChain) {
            if (!this.hasBeenBound(semanticInfoChain) && this.kind !== 1 /* Script */) {
                var binder = semanticInfoChain.getBinder();
                binder.bindDeclToPullSymbol(this);
            }
        };

        PullDecl.prototype.getSymbol = function (semanticInfoChain) {
            if (this.kind === 1 /* Script */) {
                return null;
            }

            this.ensureSymbolIsBound(semanticInfoChain);

            return semanticInfoChain.getSymbolForDecl(this);
        };

        PullDecl.prototype.hasSymbol = function (semanticInfoChain) {
            var symbol = semanticInfoChain.getSymbolForDecl(this);
            return !!symbol;
        };

        PullDecl.prototype.setSignatureSymbol = function (signatureSymbol, semanticInfoChain) {
            semanticInfoChain.setSignatureSymbolForDecl(this, signatureSymbol);
        };

        PullDecl.prototype.getSignatureSymbol = function (semanticInfoChain) {
            this.ensureSymbolIsBound(semanticInfoChain);
            return semanticInfoChain.getSignatureSymbolForDecl(this);
        };

        PullDecl.prototype.hasSignatureSymbol = function (semanticInfoChain) {
            var signatureSymbol = semanticInfoChain.getSignatureSymbolForDecl(this);
            return !!signatureSymbol;
        };

        PullDecl.prototype.setFlags = function (flags) {
            this.flags = flags;
        };

        PullDecl.prototype.setFlag = function (flags) {
            this.flags |= flags;
        };

        PullDecl.prototype.setValueDecl = function (valDecl) {
            this.synthesizedValDecl = valDecl;
            valDecl.containerDecl = this;
        };

        PullDecl.prototype.getValueDecl = function () {
            return this.synthesizedValDecl;
        };

        PullDecl.prototype.getContainerDecl = function () {
            return this.containerDecl;
        };

        PullDecl.prototype.getChildDeclCache = function (declKind) {
            if (declKind === 8192 /* TypeParameter */) {
                if (!this.childDeclTypeParameterCache) {
                    this.childDeclTypeParameterCache = TypeScript.createIntrinsicsObject();
                }

                return this.childDeclTypeParameterCache;
            } else if (TypeScript.hasFlag(declKind, 164 /* SomeContainer */)) {
                if (!this.childDeclNamespaceCache) {
                    this.childDeclNamespaceCache = TypeScript.createIntrinsicsObject();
                }

                return this.childDeclNamespaceCache;
            } else if (TypeScript.hasFlag(declKind, 58728795 /* SomeType */)) {
                if (!this.childDeclTypeCache) {
                    this.childDeclTypeCache = TypeScript.createIntrinsicsObject();
                }

                return this.childDeclTypeCache;
            } else {
                if (!this.childDeclValueCache) {
                    this.childDeclValueCache = TypeScript.createIntrinsicsObject();
                }

                return this.childDeclValueCache;
            }
        };

        PullDecl.prototype.addChildDecl = function (childDecl) {
            if (childDecl.kind === 8192 /* TypeParameter */) {
                if (!this.typeParameters) {
                    this.typeParameters = [];
                }
                this.typeParameters[this.typeParameters.length] = childDecl;
            } else {
                if (!this.childDecls) {
                    this.childDecls = [];
                }
                this.childDecls[this.childDecls.length] = childDecl;
            }

            var declName = childDecl.name;

            if (!(childDecl.kind & 7340032 /* SomeSignature */)) {
                var cache = this.getChildDeclCache(childDecl.kind);
                var childrenOfName = cache[declName];
                if (!childrenOfName) {
                    childrenOfName = [];
                }

                childrenOfName.push(childDecl);
                cache[declName] = childrenOfName;
            }
        };

        PullDecl.prototype.searchChildDecls = function (declName, searchKind) {
            var cacheVal = null;

            if (searchKind & 58728795 /* SomeType */) {
                cacheVal = this.childDeclTypeCache ? this.childDeclTypeCache[declName] : null;
            } else if (searchKind & 164 /* SomeContainer */) {
                cacheVal = this.childDeclNamespaceCache ? this.childDeclNamespaceCache[declName] : null;
            } else {
                cacheVal = this.childDeclValueCache ? this.childDeclValueCache[declName] : null;
            }

            if (cacheVal) {
                return cacheVal;
            } else {
                if (searchKind & 58728795 /* SomeType */) {
                    cacheVal = this.childDeclTypeParameterCache ? this.childDeclTypeParameterCache[declName] : null;

                    if (cacheVal) {
                        return cacheVal;
                    }
                }

                return sentinelEmptyPullDeclArray;
            }
        };

        PullDecl.prototype.getChildDecls = function () {
            return this.childDecls || sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.getTypeParameters = function () {
            return this.typeParameters || sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.addVariableDeclToGroup = function (decl) {
            if (!this.declGroups) {
                this.declGroups = TypeScript.createIntrinsicsObject();
            }

            var declGroup = this.declGroups[decl.name];
            if (declGroup) {
                declGroup.addDecl(decl);
            } else {
                declGroup = new PullDeclGroup(decl.name);
                declGroup.addDecl(decl);
                this.declGroups[decl.name] = declGroup;
            }
        };

        PullDecl.prototype.getVariableDeclGroups = function () {
            var declGroups = null;

            if (this.declGroups) {
                for (var declName in this.declGroups) {
                    if (this.declGroups[declName]) {
                        if (declGroups === null) {
                            declGroups = [];
                        }

                        declGroups.push(this.declGroups[declName].getDecls());
                    }
                }
            }

            return declGroups || sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.hasBeenBound = function (semanticInfoChain) {
            return this.hasSymbol(semanticInfoChain) || this.hasSignatureSymbol(semanticInfoChain);
        };

        PullDecl.prototype.isSynthesized = function () {
            return false;
        };

        PullDecl.prototype.ast = function () {
            return this.isSynthesized() ? null : this.getASTForDeclMap()._getASTForDecl(this);
        };

        PullDecl.prototype.isRootDecl = function () {
            throw TypeScript.Errors.abstract();
        };
        return PullDecl;
    })();
    TypeScript.PullDecl = PullDecl;

    var RootPullDecl = (function (_super) {
        __extends(RootPullDecl, _super);
        function RootPullDecl(astToDeclMap, name, fileName, kind, declFlags, isExternalModule) {
            _super.call(this, name, name, kind, declFlags);
            this.astToDeclMap = astToDeclMap;
            this._isExternalModule = isExternalModule;
            this._fileName = fileName;
        }
        RootPullDecl.prototype.fileName = function () {
            return this._fileName;
        };

        RootPullDecl.prototype.getASTForDeclMap = function () {
            return this.astToDeclMap;
        };

        RootPullDecl.prototype.getParentPath = function () {
            return [this];
        };

        RootPullDecl.prototype.getParentDecl = function () {
            return null;
        };

        RootPullDecl.prototype.isExternalModule = function () {
            return this._isExternalModule;
        };

        RootPullDecl.prototype.getEnclosingDecl = function () {
            return this;
        };

        RootPullDecl.prototype.isRootDecl = function () {
            return true;
        };
        return RootPullDecl;
    })(PullDecl);
    TypeScript.RootPullDecl = RootPullDecl;

    var NormalPullDecl = (function (_super) {
        __extends(NormalPullDecl, _super);
        function NormalPullDecl(declName, displayName, kind, declFlags, parentDecl, addToParent) {
            if (typeof addToParent === "undefined") { addToParent = true; }
            _super.call(this, declName, displayName, kind, declFlags);
            this.parentDecl = null;
            this.parentPath = null;

            this.parentDecl = parentDecl;
            if (addToParent) {
                parentDecl.addChildDecl(this);
            }

            if (this.parentDecl) {
                if (this.parentDecl.isRootDecl()) {
                    this._rootDecl = this.parentDecl;
                } else {
                    this._rootDecl = this.parentDecl._rootDecl;
                }
            } else {
                TypeScript.Debug.assert(this.isSynthesized());
                this._rootDecl = null;
            }
        }
        NormalPullDecl.prototype.fileName = function () {
            return this._rootDecl.fileName();
        };

        NormalPullDecl.prototype.getASTForDeclMap = function () {
            return this._rootDecl.getASTForDeclMap();
        };

        NormalPullDecl.prototype.getParentDecl = function () {
            return this.parentDecl;
        };

        NormalPullDecl.prototype.getParentPath = function () {
            if (!this.parentPath) {
                var path = [this];
                var parentDecl = this.parentDecl;

                while (parentDecl) {
                    if (parentDecl && path[path.length - 1] !== parentDecl && !(parentDecl.kind & (256 /* ObjectLiteral */ | 8388608 /* ObjectType */))) {
                        path.unshift(parentDecl);
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                this.parentPath = path;
            }

            return this.parentPath;
        };

        NormalPullDecl.prototype.isExternalModule = function () {
            return false;
        };

        NormalPullDecl.prototype.getEnclosingDecl = function () {
            return this.parentDecl && this.parentDecl._getEnclosingDeclFromParentDecl();
        };

        NormalPullDecl.prototype.isRootDecl = function () {
            return false;
        };
        return NormalPullDecl;
    })(PullDecl);
    TypeScript.NormalPullDecl = NormalPullDecl;

    var PullEnumElementDecl = (function (_super) {
        __extends(PullEnumElementDecl, _super);
        function PullEnumElementDecl(declName, displayName, parentDecl) {
            _super.call(this, declName, displayName, 67108864 /* EnumMember */, 4 /* Public */, parentDecl);
            this.constantValue = null;
        }
        return PullEnumElementDecl;
    })(NormalPullDecl);
    TypeScript.PullEnumElementDecl = PullEnumElementDecl;

    var PullFunctionExpressionDecl = (function (_super) {
        __extends(PullFunctionExpressionDecl, _super);
        function PullFunctionExpressionDecl(expressionName, declFlags, parentDecl, displayName) {
            if (typeof displayName === "undefined") { displayName = ""; }
            _super.call(this, "", displayName, 131072 /* FunctionExpression */, declFlags, parentDecl);
            this.functionExpressionName = expressionName;
        }
        PullFunctionExpressionDecl.prototype.getFunctionExpressionName = function () {
            return this.functionExpressionName;
        };
        return PullFunctionExpressionDecl;
    })(NormalPullDecl);
    TypeScript.PullFunctionExpressionDecl = PullFunctionExpressionDecl;

    var PullSynthesizedDecl = (function (_super) {
        __extends(PullSynthesizedDecl, _super);
        function PullSynthesizedDecl(declName, displayName, kind, declFlags, parentDecl) {
            _super.call(this, declName, displayName, kind, declFlags, parentDecl, false);
        }
        PullSynthesizedDecl.prototype.isSynthesized = function () {
            return true;
        };

        PullSynthesizedDecl.prototype.fileName = function () {
            return this._rootDecl ? this._rootDecl.fileName() : "";
        };
        return PullSynthesizedDecl;
    })(NormalPullDecl);
    TypeScript.PullSynthesizedDecl = PullSynthesizedDecl;

    var PullDeclGroup = (function () {
        function PullDeclGroup(name) {
            this.name = name;
            this._decls = [];
        }
        PullDeclGroup.prototype.addDecl = function (decl) {
            if (decl.name === this.name) {
                this._decls[this._decls.length] = decl;
            }
        };

        PullDeclGroup.prototype.getDecls = function () {
            return this._decls;
        };
        return PullDeclGroup;
    })();
    TypeScript.PullDeclGroup = PullDeclGroup;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullSymbolID = 0;
    TypeScript.sentinelEmptyArray = [];

    var PullSymbol = (function () {
        function PullSymbol(name, declKind, semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.pullSymbolID = ++TypeScript.pullSymbolID;
            this._container = null;
            this.type = null;
            this._declarations = null;
            this.isResolved = false;
            this.isOptional = false;
            this.inResolution = false;
            this.isSynthesized = false;
            this.isVarArg = false;
            this.rootSymbol = null;
            this._enclosingSignature = null;
            this._docComments = null;
            this.isPrinting = false;
            this.name = name;
            this.kind = declKind;
        }
        PullSymbol.prototype.isAny = function () {
            return false;
        };

        PullSymbol.prototype.isType = function () {
            return (this.kind & 58728795 /* SomeType */) !== 0;
        };

        PullSymbol.prototype.isTypeReference = function () {
            return false;
        };

        PullSymbol.prototype.isSignature = function () {
            return (this.kind & 7340032 /* SomeSignature */) !== 0;
        };

        PullSymbol.prototype.isArrayNamedTypeReference = function () {
            return false;
        };

        PullSymbol.prototype.isPrimitive = function () {
            return this.kind === 2 /* Primitive */;
        };

        PullSymbol.prototype.isAccessor = function () {
            return false;
        };

        PullSymbol.prototype.isError = function () {
            return false;
        };

        PullSymbol.prototype.isInterface = function () {
            return this.kind === 16 /* Interface */;
        };

        PullSymbol.prototype.isMethod = function () {
            return this.kind === 65536 /* Method */;
        };

        PullSymbol.prototype.isProperty = function () {
            return this.kind === 4096 /* Property */;
        };

        PullSymbol.prototype.isAlias = function () {
            return false;
        };

        PullSymbol.prototype.isContainer = function () {
            return false;
        };

        PullSymbol.prototype.findAliasedTypeSymbols = function (scopeSymbol, skipScopeSymbolAliasesLookIn, lookIntoOnlyExportedAlias, aliasSymbols, visitedScopeDeclarations) {
            if (typeof aliasSymbols === "undefined") { aliasSymbols = []; }
            if (typeof visitedScopeDeclarations === "undefined") { visitedScopeDeclarations = []; }
            var scopeDeclarations = scopeSymbol.getDeclarations();
            var scopeSymbolAliasesToLookIn = [];

            for (var i = 0; i < scopeDeclarations.length; i++) {
                var scopeDecl = scopeDeclarations[i];
                if (!TypeScript.ArrayUtilities.contains(visitedScopeDeclarations, scopeDecl)) {
                    visitedScopeDeclarations.push(scopeDecl);

                    var childDecls = scopeDecl.getChildDecls();
                    for (var j = 0; j < childDecls.length; j++) {
                        var childDecl = childDecls[j];
                        if (childDecl.kind === 128 /* TypeAlias */ && (!lookIntoOnlyExportedAlias || (childDecl.flags & 1 /* Exported */))) {
                            var symbol = childDecl.getSymbol(this.semanticInfoChain);

                            if (PullContainerSymbol.usedAsSymbol(symbol, this) || (this.rootSymbol && PullContainerSymbol.usedAsSymbol(symbol, this.rootSymbol))) {
                                aliasSymbols.push(symbol);
                                return aliasSymbols;
                            }

                            if (!skipScopeSymbolAliasesLookIn && PullSymbol._isExternalModuleReferenceAlias(symbol) && (!symbol.assignedContainer().hasExportAssignment() || (symbol.assignedContainer().getExportAssignedContainerSymbol() && symbol.assignedContainer().getExportAssignedContainerSymbol().kind === 32 /* DynamicModule */))) {
                                scopeSymbolAliasesToLookIn.push(symbol);
                            }
                        }
                    }
                }
            }

            for (var i = 0; i < scopeSymbolAliasesToLookIn.length; i++) {
                var scopeSymbolAlias = scopeSymbolAliasesToLookIn[i];

                aliasSymbols.push(scopeSymbolAlias);
                var result = this.findAliasedTypeSymbols(scopeSymbolAlias.assignedContainer().hasExportAssignment() ? scopeSymbolAlias.assignedContainer().getExportAssignedContainerSymbol() : scopeSymbolAlias.assignedContainer(), false, true, aliasSymbols, visitedScopeDeclarations);
                if (result) {
                    return result;
                }

                aliasSymbols.pop();
            }

            return null;
        };

        PullSymbol.prototype.getExternalAliasedSymbols = function (scopeSymbol) {
            if (!scopeSymbol) {
                return null;
            }

            var scopePath = scopeSymbol.pathToRoot();
            if (scopePath.length && scopePath[scopePath.length - 1].kind === 32 /* DynamicModule */) {
                var symbols = this.findAliasedTypeSymbols(scopePath[scopePath.length - 1]);
                return symbols;
            }

            return null;
        };

        PullSymbol._isExternalModuleReferenceAlias = function (aliasSymbol) {
            if (aliasSymbol) {
                if (aliasSymbol.assignedValue()) {
                    return false;
                }

                if (aliasSymbol.assignedType() && aliasSymbol.assignedType() !== aliasSymbol.assignedContainer()) {
                    return false;
                }

                if (aliasSymbol.assignedContainer() && aliasSymbol.assignedContainer().kind !== 32 /* DynamicModule */) {
                    return false;
                }

                return true;
            }

            return false;
        };

        PullSymbol.prototype.getExportedInternalAliasSymbol = function (scopeSymbol) {
            if (scopeSymbol) {
                if (this.kind !== 128 /* TypeAlias */) {
                    var scopePath = scopeSymbol.pathToRoot();
                    for (var i = 0; i < scopePath.length; i++) {
                        var internalAliases = this.findAliasedTypeSymbols(scopeSymbol, true, true);
                        if (internalAliases) {
                            TypeScript.Debug.assert(internalAliases.length === 1);
                            return internalAliases[0];
                        }
                    }
                }
            }

            return null;
        };

        PullSymbol.prototype.getAliasSymbolName = function (scopeSymbol, aliasNameGetter, aliasPartsNameGetter, skipInternalAlias) {
            if (!skipInternalAlias) {
                var internalAlias = this.getExportedInternalAliasSymbol(scopeSymbol);
                if (internalAlias) {
                    return aliasNameGetter(internalAlias);
                }
            }

            var externalAliases = this.getExternalAliasedSymbols(scopeSymbol);

            if (externalAliases && externalAliases[0] != this && PullSymbol._isExternalModuleReferenceAlias(externalAliases[externalAliases.length - 1])) {
                var aliasFullName = aliasNameGetter(externalAliases[0]);
                if (!aliasFullName) {
                    return null;
                }
                for (var i = 1, symbolsLen = externalAliases.length; i < symbolsLen; i++) {
                    aliasFullName = aliasFullName + "." + aliasPartsNameGetter(externalAliases[i]);
                }
                return aliasFullName;
            }

            return null;
        };

        PullSymbol.prototype._getResolver = function () {
            return this.semanticInfoChain.getResolver();
        };

        PullSymbol.prototype._resolveDeclaredSymbol = function () {
            return this._getResolver().resolveDeclaredSymbol(this);
        };

        PullSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var aliasName = this.getAliasSymbolName(scopeSymbol, function (symbol) {
                return symbol.getName(scopeSymbol, useConstraintInName);
            }, function (symbol) {
                return symbol.getName();
            });
            return aliasName || this.name;
        };

        PullSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName, skipInternalAliasName) {
            var aliasDisplayName = this.getAliasSymbolName(scopeSymbol, function (symbol) {
                return symbol.getDisplayName(scopeSymbol, useConstraintInName);
            }, function (symbol) {
                return symbol.getDisplayName();
            }, skipInternalAliasName);
            if (aliasDisplayName) {
                return aliasDisplayName;
            }

            var decls = this.getDeclarations();
            var name = decls.length && decls[0].getDisplayName();

            return (name && name.length) ? name : this.name;
        };

        PullSymbol.prototype.getIsSpecialized = function () {
            return false;
        };

        PullSymbol.prototype.getRootSymbol = function () {
            if (!this.rootSymbol) {
                return this;
            }
            return this.rootSymbol;
        };
        PullSymbol.prototype.setRootSymbol = function (symbol) {
            this.rootSymbol = symbol;
        };

        PullSymbol.prototype.isRootSymbol = function () {
            return !this.rootSymbol;
        };

        PullSymbol.prototype.setIsSynthesized = function (value) {
            if (typeof value === "undefined") { value = true; }
            TypeScript.Debug.assert(this.rootSymbol == null);
            this.isSynthesized = value;
        };

        PullSymbol.prototype.getIsSynthesized = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getIsSynthesized();
            }
            return this.isSynthesized;
        };

        PullSymbol.prototype.setEnclosingSignature = function (signature) {
            this._enclosingSignature = signature;
        };

        PullSymbol.prototype.getEnclosingSignature = function () {
            return this._enclosingSignature;
        };

        PullSymbol.prototype.addDeclaration = function (decl) {
            TypeScript.Debug.assert(!!decl);

            if (this.rootSymbol) {
                return;
            }

            if (!this._declarations) {
                this._declarations = [decl];
            } else {
                this._declarations[this._declarations.length] = decl;
            }
        };

        PullSymbol.prototype.getDeclarations = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getDeclarations();
            }

            if (!this._declarations) {
                this._declarations = [];
            }

            return this._declarations;
        };

        PullSymbol.prototype.hasDeclaration = function (decl) {
            if (!this._declarations) {
                return false;
            }

            return TypeScript.ArrayUtilities.any(this._declarations, function (eachDecl) {
                return eachDecl === decl;
            });
        };

        PullSymbol.prototype.setContainer = function (containerSymbol) {
            if (this.rootSymbol) {
                return;
            }

            this._container = containerSymbol;
        };

        PullSymbol.prototype.getContainer = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getContainer();
            }

            return this._container;
        };

        PullSymbol.prototype.setResolved = function () {
            this.isResolved = true;
            this.inResolution = false;
        };

        PullSymbol.prototype.startResolving = function () {
            this.inResolution = true;
        };

        PullSymbol.prototype.setUnresolved = function () {
            this.isResolved = false;
            this.inResolution = false;
        };

        PullSymbol.prototype.anyDeclHasFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (TypeScript.hasFlag(declarations[i].flags, flag)) {
                    return true;
                }
            }
            return false;
        };

        PullSymbol.prototype.allDeclsHaveFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (!TypeScript.hasFlag(declarations[i].flags, flag)) {
                    return false;
                }
            }
            return true;
        };

        PullSymbol.prototype.pathToRoot = function () {
            var path = [];
            var node = this;
            while (node) {
                if (node.isType()) {
                    var associatedContainerSymbol = node.getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                var nodeKind = node.kind;
                if (nodeKind === 2048 /* Parameter */) {
                    break;
                } else {
                    node = node.getContainer();
                }
            }
            return path;
        };

        PullSymbol.unqualifiedNameReferencesDifferentSymbolInScope = function (symbol, scopePath, endScopePathIndex) {
            var declPath = scopePath[0].getDeclarations()[0].getParentPath();
            for (var i = 0, declIndex = declPath.length - 1; i <= endScopePathIndex; i++, declIndex--) {
                if (scopePath[i].isContainer()) {
                    var scopeContainer = scopePath[i];
                    if (symbol.isContainer()) {
                        var memberSymbol = scopeContainer.findContainedNonMemberContainer(symbol.name, 164 /* SomeContainer */);
                        if (memberSymbol && memberSymbol != symbol && memberSymbol.getDeclarations()[0].getParentDecl() == declPath[declIndex]) {
                            return true;
                        }

                        var memberSymbol = scopeContainer.findNestedContainer(symbol.name, 164 /* SomeContainer */);
                        if (memberSymbol && memberSymbol != symbol) {
                            return true;
                        }
                    } else if (symbol.isType()) {
                        var memberSymbol = scopeContainer.findContainedNonMemberType(symbol.name, 58728795 /* SomeType */);
                        var symbolRootType = TypeScript.PullHelpers.getRootType(symbol);
                        if (memberSymbol && TypeScript.PullHelpers.getRootType(memberSymbol) != symbolRootType && memberSymbol.getDeclarations()[0].getParentDecl() == declPath[declIndex]) {
                            return true;
                        }

                        var memberSymbol = scopeContainer.findNestedType(symbol.name, 58728795 /* SomeType */);
                        if (memberSymbol && TypeScript.PullHelpers.getRootType(memberSymbol) != symbolRootType) {
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullSymbol.prototype.findQualifyingSymbolPathInScopeSymbol = function (scopeSymbol) {
            var thisPath = this.pathToRoot();
            if (thisPath.length === 1) {
                return thisPath;
            }

            var scopeSymbolPath;
            if (scopeSymbol) {
                scopeSymbolPath = scopeSymbol.pathToRoot();
            } else {
                return thisPath;
            }

            var thisCommonAncestorIndex = TypeScript.ArrayUtilities.indexOf(thisPath, function (thisNode) {
                return TypeScript.ArrayUtilities.contains(scopeSymbolPath, thisNode);
            });
            if (thisCommonAncestorIndex > 0) {
                var thisCommonAncestor = thisPath[thisCommonAncestorIndex];
                var scopeCommonAncestorIndex = TypeScript.ArrayUtilities.indexOf(scopeSymbolPath, function (scopeNode) {
                    return scopeNode === thisCommonAncestor;
                });
                TypeScript.Debug.assert(thisPath.length - thisCommonAncestorIndex === scopeSymbolPath.length - scopeCommonAncestorIndex);

                for (; thisCommonAncestorIndex < thisPath.length; thisCommonAncestorIndex++, scopeCommonAncestorIndex++) {
                    if (!PullSymbol.unqualifiedNameReferencesDifferentSymbolInScope(thisPath[thisCommonAncestorIndex - 1], scopeSymbolPath, scopeCommonAncestorIndex)) {
                        break;
                    }
                }
            }

            if (thisCommonAncestorIndex >= 0 && thisCommonAncestorIndex < thisPath.length) {
                return thisPath.slice(0, thisCommonAncestorIndex);
            } else {
                return thisPath;
            }
        };

        PullSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var str = this.getNameAndTypeName(scopeSymbol);
            return str;
        };

        PullSymbol.prototype.getNamePartForFullName = function () {
            return this.getDisplayName(null, true);
        };

        PullSymbol.prototype.fullName = function (scopeSymbol) {
            var _this = this;
            var path = this.pathToRoot();
            var fullName = "";

            var aliasFullName = this.getAliasSymbolName(scopeSymbol, function (symbol) {
                return symbol.fullName(scopeSymbol);
            }, function (symbol) {
                return symbol.getNamePartForFullName();
            });
            if (aliasFullName) {
                return aliasFullName;
            }

            for (var i = 1; i < path.length; i++) {
                var aliasFullName = path[i].getAliasSymbolName(scopeSymbol, function (symbol) {
                    return symbol === _this ? null : symbol.fullName(scopeSymbol);
                }, function (symbol) {
                    return symbol.getNamePartForFullName();
                });
                if (aliasFullName) {
                    fullName = aliasFullName + "." + fullName;
                    break;
                }

                var scopedName = path[i].getNamePartForFullName();
                if (path[i].kind === 32 /* DynamicModule */ && !TypeScript.isQuoted(scopedName)) {
                    break;
                }

                if (scopedName === "") {
                    break;
                }

                fullName = scopedName + "." + fullName;
            }

            fullName = fullName + this.getNamePartForFullName();
            return fullName;
        };

        PullSymbol.prototype.getScopedName = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName) {
            var path = this.findQualifyingSymbolPathInScopeSymbol(scopeSymbol);
            var fullName = "";

            var aliasFullName = this.getAliasSymbolName(scopeSymbol, function (symbol) {
                return symbol.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName);
            }, function (symbol) {
                return symbol.getNamePartForFullName();
            }, skipInternalAliasName);
            if (aliasFullName) {
                return aliasFullName;
            }

            for (var i = 1; i < path.length; i++) {
                var kind = path[i].kind;
                if (kind === 4 /* Container */ || kind === 32 /* DynamicModule */) {
                    var aliasFullName = path[i].getAliasSymbolName(scopeSymbol, function (symbol) {
                        return symbol.getScopedName(scopeSymbol, skipTypeParametersInName, false, skipInternalAliasName);
                    }, function (symbol) {
                        return symbol.getNamePartForFullName();
                    }, skipInternalAliasName);
                    if (aliasFullName) {
                        fullName = aliasFullName + "." + fullName;
                        break;
                    }

                    if (kind === 4 /* Container */) {
                        fullName = path[i].getDisplayName() + "." + fullName;
                    } else {
                        var displayName = path[i].getDisplayName();
                        if (TypeScript.isQuoted(displayName)) {
                            fullName = displayName + "." + fullName;
                        }
                        break;
                    }
                } else {
                    break;
                }
            }
            fullName = fullName + this.getDisplayName(scopeSymbol, useConstraintInName, skipInternalAliasName);
            return fullName;
        };

        PullSymbol.prototype.getScopedNameEx = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo, skipInternalAliasName) {
            var name = this.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName);
            return TypeScript.MemberName.create(name);
        };

        PullSymbol.prototype.getTypeName = function (scopeSymbol, getPrettyTypeName) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        };

        PullSymbol.prototype.getTypeNameEx = function (scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type) {
                var memberName = getPrettyTypeName ? this.getTypeNameForFunctionSignature("", scopeSymbol, getPrettyTypeName) : null;
                if (!memberName) {
                    memberName = type.getScopedNameEx(scopeSymbol, false, true, getPrettyTypeName);
                }

                return memberName;
            }
            return TypeScript.MemberName.create("");
        };

        PullSymbol.prototype.getTypeNameForFunctionSignature = function (prefix, scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type && !type.isNamedTypeSymbol() && this.kind !== 4096 /* Property */ && this.kind !== 512 /* Variable */ && this.kind !== 2048 /* Parameter */) {
                var signatures = type.getCallSignatures();
                if (signatures.length === 1 || (getPrettyTypeName && signatures.length)) {
                    var typeName = new TypeScript.MemberNameArray();
                    var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, prefix, false, false, scopeSymbol, getPrettyTypeName);
                    typeName.addAll(signatureName);
                    return typeName;
                }
            }

            return null;
        };

        PullSymbol.prototype.getNameAndTypeName = function (scopeSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        };

        PullSymbol.prototype.getNameAndTypeNameEx = function (scopeSymbol) {
            var type = this.type;
            var nameStr = this.getDisplayName(scopeSymbol);
            if (type) {
                nameStr = nameStr + (this.isOptional ? "?" : "");
                var memberName = this.getTypeNameForFunctionSignature(nameStr, scopeSymbol);
                if (!memberName) {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    memberName = TypeScript.MemberName.create(typeNameEx, nameStr + ": ", "");
                }
                return memberName;
            }
            return TypeScript.MemberName.create(nameStr);
        };

        PullSymbol.getTypeParameterString = function (typars, scopeSymbol, useConstraintInName) {
            return PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, undefined, useConstraintInName).toString();
        };

        PullSymbol.getTypeParameterStringEx = function (typeParameters, scopeSymbol, getTypeParamMarkerInfo, useConstraintInName) {
            var builder = new TypeScript.MemberNameArray();
            builder.prefix = "";

            if (typeParameters && typeParameters.length) {
                builder.add(TypeScript.MemberName.create("<"));

                for (var i = 0; i < typeParameters.length; i++) {
                    if (i) {
                        builder.add(TypeScript.MemberName.create(", "));
                    }

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }

                    builder.add(typeParameters[i].getScopedNameEx(scopeSymbol, false, useConstraintInName));

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }
                }

                builder.add(TypeScript.MemberName.create(">"));
            }

            return builder;
        };

        PullSymbol.getIsExternallyVisible = function (symbol, fromIsExternallyVisibleSymbol, inIsExternallyVisibleSymbols) {
            if (inIsExternallyVisibleSymbols) {
                for (var i = 0; i < inIsExternallyVisibleSymbols.length; i++) {
                    if (inIsExternallyVisibleSymbols[i] === symbol) {
                        return true;
                    }
                }
            } else {
                inIsExternallyVisibleSymbols = [];
            }

            if (fromIsExternallyVisibleSymbol === symbol) {
                return true;
            }

            inIsExternallyVisibleSymbols.push(fromIsExternallyVisibleSymbol);

            var result = symbol.isExternallyVisible(inIsExternallyVisibleSymbols);

            TypeScript.Debug.assert(TypeScript.ArrayUtilities.last(inIsExternallyVisibleSymbols) === fromIsExternallyVisibleSymbol);
            inIsExternallyVisibleSymbols.pop();

            return result;
        };

        PullSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var kind = this.kind;
            if (kind === 2 /* Primitive */) {
                return true;
            }

            if (this.rootSymbol) {
                return PullSymbol.getIsExternallyVisible(this.rootSymbol, this, inIsExternallyVisibleSymbols);
            }

            if (this.isType()) {
                var associatedContainerSymbol = this.getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    return PullSymbol.getIsExternallyVisible(associatedContainerSymbol, this, inIsExternallyVisibleSymbols);
                }
            }

            if (this.anyDeclHasFlag(2 /* Private */)) {
                return false;
            }

            var container = this.getContainer();
            if (container === null) {
                var decls = this.getDeclarations();
                if (decls.length) {
                    var parentDecl = decls[0].getParentDecl();
                    if (parentDecl) {
                        var parentSymbol = parentDecl.getSymbol(this.semanticInfoChain);
                        if (!parentSymbol || parentDecl.kind === 1 /* Script */) {
                            return true;
                        }

                        return PullSymbol.getIsExternallyVisible(parentSymbol, this, inIsExternallyVisibleSymbols);
                    }
                }

                return true;
            }

            if (container.kind === 32 /* DynamicModule */ || (container.getAssociatedContainerType() && container.getAssociatedContainerType().kind === 32 /* DynamicModule */)) {
                var containerSymbol = container.kind === 32 /* DynamicModule */ ? container : container.getAssociatedContainerType();
                if (PullContainerSymbol.usedAsSymbol(containerSymbol, this)) {
                    return true;
                }
            }

            if (!this.anyDeclHasFlag(1 /* Exported */) && kind !== 4096 /* Property */ && kind !== 65536 /* Method */) {
                return false;
            }

            return PullSymbol.getIsExternallyVisible(container, this, inIsExternallyVisibleSymbols);
        };

        PullSymbol.prototype.getDocCommentsOfDecl = function (decl) {
            var ast = decl.ast();

            if (ast) {
                var enclosingModuleDeclaration = TypeScript.ASTHelpers.getModuleDeclarationFromNameAST(ast);
                if (TypeScript.ASTHelpers.isLastNameOfModule(enclosingModuleDeclaration, ast)) {
                    return TypeScript.ASTHelpers.docComments(enclosingModuleDeclaration, TypeScript.syntaxTree(ast).text);
                }

                if (ast.kind() !== 131 /* ModuleDeclaration */ || decl.kind !== 512 /* Variable */) {
                    return TypeScript.ASTHelpers.docComments(ast, TypeScript.syntaxTree(ast).text);
                }
            }

            return [];
        };

        PullSymbol.prototype.getDocCommentArray = function (symbol) {
            var docComments = [];
            if (!symbol) {
                return docComments;
            }

            var isParameter = symbol.kind === 2048 /* Parameter */;
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (isParameter && decls[i].kind === 4096 /* Property */) {
                    continue;
                }
                docComments = docComments.concat(this.getDocCommentsOfDecl(decls[i]));
            }
            return docComments;
        };

        PullSymbol.getDefaultConstructorSymbolForDocComments = function (classSymbol) {
            if (classSymbol.getHasDefaultConstructor()) {
                var extendedTypes = classSymbol.getExtendedTypes();
                if (extendedTypes.length) {
                    return PullSymbol.getDefaultConstructorSymbolForDocComments(extendedTypes[0]);
                }
            }

            return classSymbol.type.getConstructSignatures()[0];
        };

        PullSymbol.prototype.getDocCommentText = function (comments) {
            var docCommentText = new Array();
            for (var c = 0; c < comments.length; c++) {
                var commentText = this.getDocCommentTextValue(comments[c]);
                if (commentText !== "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        };

        PullSymbol.prototype.getDocCommentTextValue = function (comment) {
            return this.cleanJSDocComment(comment.fullText());
        };

        PullSymbol.prototype.docComments = function (useConstructorAsClass) {
            var decls = this.getDeclarations();
            if (useConstructorAsClass && decls.length && decls[0].kind === 32768 /* ConstructorMethod */) {
                var classDecl = decls[0].getParentDecl();
                return this.getDocCommentText(this.getDocCommentsOfDecl(classDecl));
            }

            if (this._docComments === null) {
                var docComments = "";
                if (!useConstructorAsClass && this.kind === 2097152 /* ConstructSignature */ && decls.length && decls[0].kind === 8 /* Class */) {
                    var classSymbol = this.returnType;
                    var extendedTypes = classSymbol.getExtendedTypes();
                    if (extendedTypes.length) {
                        docComments = extendedTypes[0].getConstructorMethod().docComments();
                    } else {
                        docComments = "";
                    }
                } else if (this.kind === 2048 /* Parameter */) {
                    var parameterComments = [];

                    var funcContainer = this.getEnclosingSignature();
                    var funcDocComments = this.getDocCommentArray(funcContainer);
                    var paramComment = this.getParameterDocCommentText(this.getDisplayName(), funcDocComments);
                    if (paramComment != "") {
                        parameterComments.push(paramComment);
                    }

                    var paramSelfComment = this.getDocCommentText(this.getDocCommentArray(this));
                    if (paramSelfComment != "") {
                        parameterComments.push(paramSelfComment);
                    }
                    docComments = parameterComments.join("\n");
                } else {
                    var getSymbolComments = true;
                    if (this.kind === 16777216 /* FunctionType */) {
                        var functionSymbol = this.getFunctionSymbol();

                        if (functionSymbol) {
                            docComments = functionSymbol._docComments || "";
                            getSymbolComments = false;
                        } else {
                            var declarationList = this.getDeclarations();
                            if (declarationList.length > 0) {
                                docComments = declarationList[0].getSymbol(this.semanticInfoChain)._docComments || "";
                                getSymbolComments = false;
                            }
                        }
                    }
                    if (getSymbolComments) {
                        docComments = this.getDocCommentText(this.getDocCommentArray(this));
                        if (docComments === "") {
                            if (this.kind === 1048576 /* CallSignature */) {
                                var callTypeSymbol = this.functionType;
                                if (callTypeSymbol && callTypeSymbol.getCallSignatures().length === 1) {
                                    docComments = callTypeSymbol.docComments();
                                }
                            }
                        }
                    }
                }

                this._docComments = docComments;
            }

            return this._docComments;
        };

        PullSymbol.prototype.getParameterDocCommentText = function (param, fncDocComments) {
            if (fncDocComments.length === 0 || fncDocComments[0].kind() !== 6 /* MultiLineCommentTrivia */) {
                return "";
            }

            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].fullText();
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!this.isSpaceChar(commentContents, j)) {
                        continue;
                    }

                    j = this.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }

                    if (commentContents.charCodeAt(j) === 123 /* openBrace */) {
                        j++;

                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);

                            if (charCode === 123 /* openBrace */) {
                                curlies++;
                                continue;
                            }

                            if (charCode === 125 /* closeBrace */) {
                                curlies--;
                                if (curlies === 0) {
                                    break;
                                } else {
                                    continue;
                                }
                            }

                            if (charCode === 64 /* at */) {
                                break;
                            }
                        }

                        if (j === commentContents.length) {
                            break;
                        }

                        if (charCode === 64 /* at */) {
                            continue;
                        }

                        j = this.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }

                    if (param !== commentContents.substr(j, param.length) || !this.isSpaceChar(commentContents, j + param.length)) {
                        continue;
                    }

                    j = this.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }

                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);

                    var paramSpacesToRemove = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex !== 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = this.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex !== j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }

                    return this.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }

            return "";
        };

        PullSymbol.prototype.cleanJSDocComment = function (content, spacesToRemove) {
            var docCommentLines = new Array();
            content = content.replace("/**", "");
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2);
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = this.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    continue;
                }

                var docCommentText = "";
                var prevPos = cleanLinePos.start;
                for (var i = line.indexOf("@", cleanLinePos.start); 0 <= i && i < cleanLinePos.end; i = line.indexOf("@", i + 1)) {
                    var wasInParamtag = inParamTag;

                    if (line.indexOf("param", i + 1) === i + 1 && this.isSpaceChar(line, i + 6)) {
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }

                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        prevPos = i;
                        inParamTag = false;
                    }
                }

                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.end);
                }

                var newCleanPos = this.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }

            return docCommentLines.join("\n");
        };

        PullSymbol.prototype.consumeLeadingSpace = function (line, startIndex, maxSpacesToRemove) {
            var endIndex = line.length;
            if (maxSpacesToRemove !== undefined) {
                endIndex = Math.min(startIndex + maxSpacesToRemove, endIndex);
            }

            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode !== 32 /* space */ && charCode !== 9 /* tab */) {
                    return startIndex;
                }
            }

            if (endIndex !== line.length) {
                return endIndex;
            }

            return -1;
        };

        PullSymbol.prototype.isSpaceChar = function (line, index) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);

                return charCode === 32 /* space */ || charCode === 9 /* tab */;
            }

            return index === length;
        };

        PullSymbol.prototype.cleanDocCommentLine = function (line, jsDocStyleComment, jsDocLineSpaceToRemove) {
            var nonSpaceIndex = this.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex !== -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') {
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = this.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);

                    if (nonSpaceIndex !== -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }

                return {
                    start: nonSpaceIndex,
                    end: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }

            return null;
        };
        return PullSymbol;
    })();
    TypeScript.PullSymbol = PullSymbol;

    

    var PullSignatureSymbol = (function (_super) {
        __extends(PullSignatureSymbol, _super);
        function PullSignatureSymbol(kind, semanticInfoChain, _isDefinition) {
            if (typeof _isDefinition === "undefined") { _isDefinition = false; }
            _super.call(this, "", kind, semanticInfoChain);
            this._isDefinition = _isDefinition;
            this._memberTypeParameterNameCache = null;
            this._stringConstantOverload = undefined;
            this.parameters = TypeScript.sentinelEmptyArray;
            this._typeParameters = null;
            this.returnType = null;
            this.functionType = null;
            this.hasOptionalParam = false;
            this.nonOptionalParamCount = 0;
            this.hasVarArgs = false;
            this._allowedToReferenceTypeParameters = null;
            this._instantiationCache = null;
            this.hasBeenChecked = false;
            this.inWrapCheck = false;
            this.inWrapInfiniteExpandingReferenceCheck = false;
        }
        PullSignatureSymbol.prototype.isDefinition = function () {
            return this._isDefinition;
        };

        PullSignatureSymbol.prototype.isGeneric = function () {
            var typeParameters = this.getTypeParameters();
            return !!typeParameters && typeParameters.length !== 0;
        };

        PullSignatureSymbol.prototype.addParameter = function (parameter, isOptional) {
            if (typeof isOptional === "undefined") { isOptional = false; }
            if (this.parameters === TypeScript.sentinelEmptyArray) {
                this.parameters = [];
            }

            this.parameters[this.parameters.length] = parameter;
            this.hasOptionalParam = isOptional;

            if (!parameter.getEnclosingSignature()) {
                parameter.setEnclosingSignature(this);
            }

            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        };

        PullSignatureSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            if (!this._memberTypeParameterNameCache) {
                this._memberTypeParameterNameCache = TypeScript.createIntrinsicsObject();
            }

            this._typeParameters[this._typeParameters.length] = typeParameter;

            this._memberTypeParameterNameCache[typeParameter.getName()] = typeParameter;
        };

        PullSignatureSymbol.prototype.addTypeParametersFromReturnType = function () {
            var typeParameters = this.returnType.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                this.addTypeParameter(typeParameters[i]);
            }
        };

        PullSignatureSymbol.prototype.getTypeParameters = function () {
            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            return this._typeParameters;
        };

        PullSignatureSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;

            if (!this._memberTypeParameterNameCache) {
                this._memberTypeParameterNameCache = TypeScript.createIntrinsicsObject();

                for (var i = 0; i < this.getTypeParameters().length; i++) {
                    this._memberTypeParameterNameCache[this._typeParameters[i].getName()] = this._typeParameters[i];
                }
            }

            memberSymbol = this._memberTypeParameterNameCache[name];

            return memberSymbol;
        };

        PullSignatureSymbol.prototype.getTypeParameterSubstitutionMap = function () {
            return null;
        };

        PullSignatureSymbol.prototype.getAllowedToReferenceTypeParameters = function () {
            TypeScript.Debug.assert(this.getRootSymbol() == this);
            if (!this._allowedToReferenceTypeParameters) {
                this._allowedToReferenceTypeParameters = TypeScript.PullInstantiationHelpers.getAllowedToReferenceTypeParametersFromDecl(this.getDeclarations()[0], this.semanticInfoChain);
            }

            return this._allowedToReferenceTypeParameters;
        };

        PullSignatureSymbol.prototype.getIsInstantiated = function () {
            return false;
        };

        PullSignatureSymbol.prototype.addSpecialization = function (specializedVersionOfThisSignature, typeArgumentMap) {
            TypeScript.Debug.assert(this.getRootSymbol() == this);
            if (!this._instantiationCache) {
                this._instantiationCache = TypeScript.createIntrinsicsObject();
            }

            this._instantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)] = specializedVersionOfThisSignature;
        };

        PullSignatureSymbol.prototype.getSpecialization = function (typeArgumentMap) {
            TypeScript.Debug.assert(this.getRootSymbol() == this);
            if (!this._instantiationCache) {
                return null;
            }

            var result = this._instantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)];
            return result || null;
        };

        PullSignatureSymbol.prototype.isStringConstantOverloadSignature = function () {
            if (this._stringConstantOverload === undefined) {
                var params = this.parameters;
                this._stringConstantOverload = false;
                for (var i = 0; i < params.length; i++) {
                    var paramType = params[i].type;
                    if (paramType && paramType.isPrimitive() && paramType.isStringConstant()) {
                        this._stringConstantOverload = true;
                    }
                }
            }

            return this._stringConstantOverload;
        };

        PullSignatureSymbol.prototype.getParameterTypeAtIndex = function (iParam) {
            if (iParam < this.parameters.length - 1 || (iParam < this.parameters.length && !this.hasVarArgs)) {
                return this.parameters[iParam].type;
            } else if (this.hasVarArgs) {
                var paramType = this.parameters[this.parameters.length - 1].type;
                if (paramType.isArrayNamedTypeReference()) {
                    paramType = paramType.getElementType();
                }
                return paramType;
            }

            return null;
        };

        PullSignatureSymbol.getSignatureTypeMemberName = function (candidateSignature, signatures, scopeSymbol) {
            var allMemberNames = new TypeScript.MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, "", false, false, scopeSymbol, true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        };

        PullSignatureSymbol.getSignaturesTypeNameEx = function (signatures, prefix, shortform, brackets, scopeSymbol, getPrettyTypeName, candidateSignature) {
            var result = [];
            if (!signatures) {
                return result;
            }

            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                candidateSignature = null;
            }

            for (var i = 0; i < len; i++) {
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }

                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }

                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }

            if (getPrettyTypeName && result.length && len > 1) {
                var lastMemberName = result[result.length - 1];
                for (var i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = TypeScript.getLocalizedText(TypeScript.DiagnosticCode._0_overload_s, [foundDefinition ? len - 2 : len - 1]);
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }

            return result;
        };

        PullSignatureSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), false, false, scopeSymbol, undefined, useConstraintInName).toString();
            return s;
        };

        PullSignatureSymbol.prototype.getSignatureTypeNameEx = function (prefix, shortform, brackets, scopeSymbol, getParamMarkerInfo, getTypeParamMarkerInfo) {
            var typeParamterBuilder = new TypeScript.MemberNameArray();

            typeParamterBuilder.add(PullSymbol.getTypeParameterStringEx(this.getTypeParameters(), scopeSymbol, getTypeParamMarkerInfo, true));

            if (brackets) {
                typeParamterBuilder.add(TypeScript.MemberName.create("["));
            } else {
                typeParamterBuilder.add(TypeScript.MemberName.create("("));
            }

            var builder = new TypeScript.MemberNameArray();
            builder.prefix = prefix;

            if (getTypeParamMarkerInfo) {
                builder.prefix = prefix;
                builder.addAll(typeParamterBuilder.entries);
            } else {
                builder.prefix = prefix + typeParamterBuilder.toString();
            }

            var params = this.parameters;
            var paramLen = params.length;
            for (var i = 0; i < paramLen; i++) {
                var paramType = params[i].type;
                var typeString = paramType ? ": " : "";
                var paramIsVarArg = params[i].isVarArg;
                var varArgPrefix = paramIsVarArg ? "..." : "";
                var optionalString = (!paramIsVarArg && params[i].isOptional) ? "?" : "";
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                builder.add(TypeScript.MemberName.create(varArgPrefix + params[i].getScopedNameEx(scopeSymbol).toString() + optionalString + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }

            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                } else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            } else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                } else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }

            if (this.returnType) {
                builder.add(this.returnType.getScopedNameEx(scopeSymbol));
            } else {
                builder.add(TypeScript.MemberName.create("any"));
            }

            return builder;
        };

        PullSignatureSymbol.prototype.forAllParameterTypes = function (length, predicate) {
            if (this.parameters.length < length && !this.hasVarArgs) {
                length = this.parameters.length;
            }

            for (var i = 0; i < length; i++) {
                var paramType = this.getParameterTypeAtIndex(i);
                if (!predicate(paramType, i)) {
                    return false;
                }
            }

            return true;
        };

        PullSignatureSymbol.prototype.forAllCorrespondingParameterTypesInThisAndOtherSignature = function (otherSignature, predicate) {
            var length;
            if (this.hasVarArgs) {
                length = otherSignature.hasVarArgs ? Math.max(this.parameters.length, otherSignature.parameters.length) : otherSignature.parameters.length;
            } else {
                length = otherSignature.hasVarArgs ? this.parameters.length : Math.min(this.parameters.length, otherSignature.parameters.length);
            }

            for (var i = 0; i < length; i++) {
                var thisParamType = this.getParameterTypeAtIndex(i);
                var otherParamType = otherSignature.getParameterTypeAtIndex(i);
                if (!predicate(thisParamType, otherParamType, i)) {
                    return false;
                }
            }

            return true;
        };

        PullSignatureSymbol.prototype.wrapsSomeTypeParameter = function (typeParameterArgumentMap) {
            return this.getWrappingTypeParameterID(typeParameterArgumentMap) !== 0;
        };

        PullSignatureSymbol.prototype.getWrappingTypeParameterID = function (typeParameterArgumentMap) {
            if (this.inWrapCheck) {
                return 0;
            }

            this._wrapsTypeParameterCache = this._wrapsTypeParameterCache || new TypeScript.WrapsTypeParameterCache();

            var wrappingTypeParameterID = this._wrapsTypeParameterCache.getWrapsTypeParameter(typeParameterArgumentMap);
            if (wrappingTypeParameterID === undefined) {
                this.inWrapCheck = true;
                wrappingTypeParameterID = this.getWrappingTypeParameterIDWorker(typeParameterArgumentMap);
                this.inWrapCheck = false;
                this._wrapsTypeParameterCache.setWrapsTypeParameter(typeParameterArgumentMap, wrappingTypeParameterID);
            }

            return wrappingTypeParameterID;
        };

        PullSignatureSymbol.prototype.getWrappingTypeParameterIDWorker = function (typeParameterArgumentMap) {
            TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(this);
            var wrappingTypeParameterID = 0;
            if (this.returnType) {
                wrappingTypeParameterID = this.returnType.getWrappingTypeParameterID(typeParameterArgumentMap);
                if (wrappingTypeParameterID !== 0) {
                    return wrappingTypeParameterID;
                }
            }

            var parameters = this.parameters;
            for (var i = 0; i < parameters.length; i++) {
                TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(parameters[i]);
                wrappingTypeParameterID = parameters[i].type.getWrappingTypeParameterID(typeParameterArgumentMap);
                if (wrappingTypeParameterID !== 0) {
                    return wrappingTypeParameterID;
                }
            }

            var typeParameters = this.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(typeParameters[i]);
                var constraint = typeParameters[i].getConstraint();
                if (constraint) {
                    wrappingTypeParameterID = constraint.getWrappingTypeParameterID(typeParameterArgumentMap);
                    if (wrappingTypeParameterID !== 0) {
                        return wrappingTypeParameterID;
                    }
                }
            }

            return 0;
        };

        PullSignatureSymbol.prototype._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference = function (enclosingType, knownWrapMap) {
            var wrapsIntoInfinitelyExpandingTypeReference = knownWrapMap.valueAt(this.pullSymbolID, enclosingType.pullSymbolID);
            if (wrapsIntoInfinitelyExpandingTypeReference != undefined) {
                return wrapsIntoInfinitelyExpandingTypeReference;
            }

            if (this.inWrapInfiniteExpandingReferenceCheck) {
                return false;
            }

            this.inWrapInfiniteExpandingReferenceCheck = true;
            wrapsIntoInfinitelyExpandingTypeReference = this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType, knownWrapMap);
            knownWrapMap.setValueAt(this.pullSymbolID, enclosingType.pullSymbolID, wrapsIntoInfinitelyExpandingTypeReference);
            this.inWrapInfiniteExpandingReferenceCheck = false;

            return wrapsIntoInfinitelyExpandingTypeReference;
        };

        PullSignatureSymbol.prototype._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker = function (enclosingType, knownWrapMap) {
            if (this.returnType && this.returnType._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType, knownWrapMap)) {
                return true;
            }

            var parameters = this.parameters;

            for (var i = 0; i < parameters.length; i++) {
                if (parameters[i].type && parameters[i].type._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            return false;
        };
        return PullSignatureSymbol;
    })(PullSymbol);
    TypeScript.PullSignatureSymbol = PullSignatureSymbol;

    var PullTypeSymbol = (function (_super) {
        __extends(PullTypeSymbol, _super);
        function PullTypeSymbol(name, kind, semanticInfoChain) {
            _super.call(this, name, kind, semanticInfoChain);
            this._members = TypeScript.sentinelEmptyArray;
            this._enclosedMemberTypes = null;
            this._enclosedMemberContainers = null;
            this._typeParameters = null;
            this._allowedToReferenceTypeParameters = null;
            this._specializedVersionsOfThisType = null;
            this._arrayVersionOfThisType = null;
            this._implementedTypes = null;
            this._extendedTypes = null;
            this._typesThatExplicitlyImplementThisType = null;
            this._typesThatExtendThisType = null;
            this._callSignatures = null;
            this._allCallSignatures = null;
            this._constructSignatures = null;
            this._allConstructSignatures = null;
            this._indexSignatures = null;
            this._allIndexSignatures = null;
            this._allIndexSignaturesOfAugmentedType = null;
            this._memberNameCache = null;
            this._enclosedTypeNameCache = null;
            this._enclosedContainerCache = null;
            this._typeParameterNameCache = null;
            this._containedNonMemberNameCache = null;
            this._containedNonMemberTypeNameCache = null;
            this._containedNonMemberContainerCache = null;
            this._simpleInstantiationCache = null;
            this._complexInstantiationCache = null;
            this._hasGenericSignature = false;
            this._hasGenericMember = false;
            this._hasBaseTypeConflict = false;
            this._knownBaseTypeCount = 0;
            this._associatedContainerTypeSymbol = null;
            this._constructorMethod = null;
            this._hasDefaultConstructor = false;
            this._functionSymbol = null;
            this._inMemberTypeNameEx = false;
            this.inSymbolPrivacyCheck = false;
            this.inWrapCheck = false;
            this.inWrapInfiniteExpandingReferenceCheck = false;
            this.typeReference = null;
            this._widenedType = null;
            this._isArrayNamedTypeReference = undefined;
            this.type = this;
        }
        PullTypeSymbol.prototype.isArrayNamedTypeReference = function () {
            if (this._isArrayNamedTypeReference === undefined) {
                this._isArrayNamedTypeReference = this.computeIsArrayNamedTypeReference();
            }

            return this._isArrayNamedTypeReference;
        };

        PullTypeSymbol.prototype.computeIsArrayNamedTypeReference = function () {
            var typeArgs = this.getTypeArguments();
            if (typeArgs && this.getTypeArguments().length === 1 && this.name === "Array") {
                var declaration = this.getDeclarations()[0];

                if (declaration && declaration.getParentDecl() && declaration.getParentDecl().getParentDecl() === null) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype.isType = function () {
            return true;
        };
        PullTypeSymbol.prototype.isClass = function () {
            return this.kind === 8 /* Class */ || (this._constructorMethod !== null);
        };
        PullTypeSymbol.prototype.isFunction = function () {
            return (this.kind & (33554432 /* ConstructorType */ | 16777216 /* FunctionType */)) !== 0;
        };
        PullTypeSymbol.prototype.isConstructor = function () {
            return this.kind === 33554432 /* ConstructorType */ || (this._associatedContainerTypeSymbol && this._associatedContainerTypeSymbol.isClass());
        };
        PullTypeSymbol.prototype.isTypeParameter = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeVariable = function () {
            return false;
        };
        PullTypeSymbol.prototype.isError = function () {
            return false;
        };
        PullTypeSymbol.prototype.isEnum = function () {
            return this.kind === 64 /* Enum */;
        };

        PullTypeSymbol.prototype.getTypeParameterSubstitutionMap = function () {
            return null;
        };

        PullTypeSymbol.prototype.isObject = function () {
            return TypeScript.hasFlag(this.kind, 8 /* Class */ | 33554432 /* ConstructorType */ | 64 /* Enum */ | 16777216 /* FunctionType */ | 16 /* Interface */ | 8388608 /* ObjectType */ | 256 /* ObjectLiteral */);
        };

        PullTypeSymbol.prototype.isFunctionType = function () {
            return this.getCallSignatures().length > 0 || this.getConstructSignatures().length > 0;
        };

        PullTypeSymbol.prototype.getKnownBaseTypeCount = function () {
            return this._knownBaseTypeCount;
        };
        PullTypeSymbol.prototype.resetKnownBaseTypeCount = function () {
            this._knownBaseTypeCount = 0;
        };
        PullTypeSymbol.prototype.incrementKnownBaseCount = function () {
            this._knownBaseTypeCount++;
        };

        PullTypeSymbol.prototype.setHasBaseTypeConflict = function () {
            this._hasBaseTypeConflict = true;
        };
        PullTypeSymbol.prototype.hasBaseTypeConflict = function () {
            return this._hasBaseTypeConflict;
        };

        PullTypeSymbol.prototype.hasMembers = function () {
            if (this._members !== TypeScript.sentinelEmptyArray) {
                return true;
            }

            var parents = this.getExtendedTypes();

            for (var i = 0; i < parents.length; i++) {
                if (parents[i].hasMembers()) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype.setHasGenericSignature = function () {
            this._hasGenericSignature = true;
        };
        PullTypeSymbol.prototype.getHasGenericSignature = function () {
            return this._hasGenericSignature;
        };

        PullTypeSymbol.prototype.setHasGenericMember = function () {
            this._hasGenericMember = true;
        };
        PullTypeSymbol.prototype.getHasGenericMember = function () {
            return this._hasGenericMember;
        };

        PullTypeSymbol.prototype.setAssociatedContainerType = function (type) {
            this._associatedContainerTypeSymbol = type;
        };

        PullTypeSymbol.prototype.getAssociatedContainerType = function () {
            return this._associatedContainerTypeSymbol;
        };

        PullTypeSymbol.prototype.getArrayType = function () {
            return this._arrayVersionOfThisType;
        };

        PullTypeSymbol.prototype.getElementType = function () {
            return null;
        };

        PullTypeSymbol.prototype.setArrayType = function (arrayType) {
            this._arrayVersionOfThisType = arrayType;
        };

        PullTypeSymbol.prototype.getFunctionSymbol = function () {
            return this._functionSymbol;
        };

        PullTypeSymbol.prototype.setFunctionSymbol = function (symbol) {
            if (symbol) {
                this._functionSymbol = symbol;
            }
        };

        PullTypeSymbol.prototype.findContainedNonMember = function (name) {
            if (!this._containedNonMemberNameCache) {
                return null;
            }

            return this._containedNonMemberNameCache[name];
        };

        PullTypeSymbol.prototype.findContainedNonMemberType = function (typeName, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            if (!this._containedNonMemberTypeNameCache) {
                return null;
            }

            var nonMemberSymbol = this._containedNonMemberTypeNameCache[typeName];

            if (nonMemberSymbol && kind !== 0 /* None */) {
                nonMemberSymbol = TypeScript.hasFlag(nonMemberSymbol.kind, kind) ? nonMemberSymbol : null;
            }

            return nonMemberSymbol;
        };

        PullTypeSymbol.prototype.findContainedNonMemberContainer = function (containerName, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            if (!this._containedNonMemberContainerCache) {
                return null;
            }

            var nonMemberSymbol = this._containedNonMemberContainerCache[containerName];

            if (nonMemberSymbol && kind !== 0 /* None */) {
                nonMemberSymbol = TypeScript.hasFlag(nonMemberSymbol.kind, kind) ? nonMemberSymbol : null;
            }

            return nonMemberSymbol;
        };

        PullTypeSymbol.prototype.addMember = function (memberSymbol) {
            if (!memberSymbol) {
                return;
            }

            memberSymbol.setContainer(this);

            if (!this._memberNameCache) {
                this._memberNameCache = TypeScript.createIntrinsicsObject();
            }

            if (this._members === TypeScript.sentinelEmptyArray) {
                this._members = [];
            }

            this._members.push(memberSymbol);
            this._memberNameCache[memberSymbol.name] = memberSymbol;
        };

        PullTypeSymbol.prototype.addEnclosedMemberType = function (enclosedType) {
            if (!enclosedType) {
                return;
            }

            enclosedType.setContainer(this);

            if (!this._enclosedTypeNameCache) {
                this._enclosedTypeNameCache = TypeScript.createIntrinsicsObject();
            }

            if (!this._enclosedMemberTypes) {
                this._enclosedMemberTypes = [];
            }

            this._enclosedMemberTypes[this._enclosedMemberTypes.length] = enclosedType;
            this._enclosedTypeNameCache[enclosedType.name] = enclosedType;
        };

        PullTypeSymbol.prototype.addEnclosedMemberContainer = function (enclosedContainer) {
            if (!enclosedContainer) {
                return;
            }

            enclosedContainer.setContainer(this);

            if (!this._enclosedContainerCache) {
                this._enclosedContainerCache = TypeScript.createIntrinsicsObject();
            }

            if (!this._enclosedMemberContainers) {
                this._enclosedMemberContainers = [];
            }

            this._enclosedMemberContainers[this._enclosedMemberContainers.length] = enclosedContainer;
            this._enclosedContainerCache[enclosedContainer.name] = enclosedContainer;
        };

        PullTypeSymbol.prototype.addEnclosedNonMember = function (enclosedNonMember) {
            if (!enclosedNonMember) {
                return;
            }

            enclosedNonMember.setContainer(this);

            if (!this._containedNonMemberNameCache) {
                this._containedNonMemberNameCache = TypeScript.createIntrinsicsObject();
            }

            this._containedNonMemberNameCache[enclosedNonMember.name] = enclosedNonMember;
        };

        PullTypeSymbol.prototype.addEnclosedNonMemberType = function (enclosedNonMemberType) {
            if (!enclosedNonMemberType) {
                return;
            }

            enclosedNonMemberType.setContainer(this);

            if (!this._containedNonMemberTypeNameCache) {
                this._containedNonMemberTypeNameCache = TypeScript.createIntrinsicsObject();
            }

            this._containedNonMemberTypeNameCache[enclosedNonMemberType.name] = enclosedNonMemberType;
        };

        PullTypeSymbol.prototype.addEnclosedNonMemberContainer = function (enclosedNonMemberContainer) {
            if (!enclosedNonMemberContainer) {
                return;
            }

            enclosedNonMemberContainer.setContainer(this);

            if (!this._containedNonMemberContainerCache) {
                this._containedNonMemberContainerCache = TypeScript.createIntrinsicsObject();
            }

            this._containedNonMemberContainerCache[enclosedNonMemberContainer.name] = enclosedNonMemberContainer;
        };

        PullTypeSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!typeParameter) {
                return;
            }

            if (!typeParameter.getContainer()) {
                typeParameter.setContainer(this);
            }

            if (!this._typeParameterNameCache) {
                this._typeParameterNameCache = TypeScript.createIntrinsicsObject();
            }

            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            this._typeParameters[this._typeParameters.length] = typeParameter;
            this._typeParameterNameCache[typeParameter.getName()] = typeParameter;
        };

        PullTypeSymbol.prototype.getMembers = function () {
            return this._members;
        };

        PullTypeSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (typeof hasOne === "undefined") { hasOne = true; }
            this._hasDefaultConstructor = hasOne;
        };

        PullTypeSymbol.prototype.getHasDefaultConstructor = function () {
            return this._hasDefaultConstructor;
        };

        PullTypeSymbol.prototype.getConstructorMethod = function () {
            return this._constructorMethod;
        };

        PullTypeSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            this._constructorMethod = constructorMethod;
        };

        PullTypeSymbol.prototype.getTypeParameters = function () {
            if (!this._typeParameters) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._typeParameters;
        };

        PullTypeSymbol.prototype.getAllowedToReferenceTypeParameters = function () {
            if (!!(this.kind && 8216 /* SomeInstantiatableType */) && this.isNamedTypeSymbol() && !this.isTypeParameter()) {
                return this.getTypeParameters();
            }

            if (!this._allowedToReferenceTypeParameters) {
                this._allowedToReferenceTypeParameters = TypeScript.PullInstantiationHelpers.getAllowedToReferenceTypeParametersFromDecl(this.getDeclarations()[0], this.semanticInfoChain);
            }

            return this._allowedToReferenceTypeParameters;
        };

        PullTypeSymbol.prototype.isGeneric = function () {
            return (this._typeParameters && this._typeParameters.length > 0) || this._hasGenericSignature || this._hasGenericMember || this.isArrayNamedTypeReference();
        };

        PullTypeSymbol.prototype.canUseSimpleInstantiationCache = function (typeArgumentMap) {
            if (this.isTypeParameter()) {
                return true;
            }

            var typeParameters = this.getTypeParameters();
            return typeArgumentMap && this.isNamedTypeSymbol() && typeParameters.length === 1 && typeArgumentMap[typeParameters[0].pullSymbolID].kind !== 8388608 /* ObjectType */;
        };

        PullTypeSymbol.prototype.getSimpleInstantiationCacheId = function (typeArgumentMap) {
            return typeArgumentMap[this.getTypeParameters()[0].pullSymbolID].pullSymbolID;
        };

        PullTypeSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, typeArgumentMap) {
            if (this.canUseSimpleInstantiationCache(typeArgumentMap)) {
                if (!this._simpleInstantiationCache) {
                    this._simpleInstantiationCache = [];
                }

                this._simpleInstantiationCache[this.getSimpleInstantiationCacheId(typeArgumentMap)] = specializedVersionOfThisType;
            } else {
                if (!this._complexInstantiationCache) {
                    this._complexInstantiationCache = TypeScript.createIntrinsicsObject();
                }

                this._complexInstantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)] = specializedVersionOfThisType;
            }

            if (!this._specializedVersionsOfThisType) {
                this._specializedVersionsOfThisType = [];
            }

            this._specializedVersionsOfThisType.push(specializedVersionOfThisType);
        };

        PullTypeSymbol.prototype.getSpecialization = function (typeArgumentMap) {
            if (this.canUseSimpleInstantiationCache(typeArgumentMap)) {
                if (!this._simpleInstantiationCache) {
                    return null;
                }

                var result = this._simpleInstantiationCache[this.getSimpleInstantiationCacheId(typeArgumentMap)];
                return result || null;
            } else {
                if (!this._complexInstantiationCache) {
                    return null;
                }

                if (this.getAllowedToReferenceTypeParameters().length == 0) {
                    return this;
                }

                var result = this._complexInstantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)];
                return result || null;
            }
        };

        PullTypeSymbol.prototype.getKnownSpecializations = function () {
            if (!this._specializedVersionsOfThisType) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._specializedVersionsOfThisType;
        };

        PullTypeSymbol.prototype.getTypeArguments = function () {
            return null;
        };

        PullTypeSymbol.prototype.getTypeArgumentsOrTypeParameters = function () {
            return this.getTypeParameters();
        };

        PullTypeSymbol.prototype.addCallOrConstructSignaturePrerequisiteBase = function (signature) {
            if (signature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            signature.functionType = this;
        };

        PullTypeSymbol.prototype.addCallSignaturePrerequisite = function (callSignature) {
            if (!this._callSignatures) {
                this._callSignatures = [];
            }

            this.addCallOrConstructSignaturePrerequisiteBase(callSignature);
        };

        PullTypeSymbol.prototype.appendCallSignature = function (callSignature) {
            this.addCallSignaturePrerequisite(callSignature);
            this._callSignatures.push(callSignature);
        };

        PullTypeSymbol.prototype.insertCallSignatureAtIndex = function (callSignature, index) {
            this.addCallSignaturePrerequisite(callSignature);
            TypeScript.Debug.assert(index <= this._callSignatures.length);
            if (index === this._callSignatures.length) {
                this._callSignatures.push(callSignature);
            } else {
                this._callSignatures.splice(index, 0, callSignature);
            }
        };

        PullTypeSymbol.prototype.addConstructSignaturePrerequisite = function (constructSignature) {
            if (!this._constructSignatures) {
                this._constructSignatures = [];
            }

            this.addCallOrConstructSignaturePrerequisiteBase(constructSignature);
        };

        PullTypeSymbol.prototype.appendConstructSignature = function (constructSignature) {
            this.addConstructSignaturePrerequisite(constructSignature);
            this._constructSignatures.push(constructSignature);
        };

        PullTypeSymbol.prototype.insertConstructSignatureAtIndex = function (constructSignature, index) {
            this.addConstructSignaturePrerequisite(constructSignature);
            TypeScript.Debug.assert(index <= this._constructSignatures.length);
            if (index === this._constructSignatures.length) {
                this._constructSignatures.push(constructSignature);
            } else {
                this._constructSignatures.splice(index, 0, constructSignature);
            }
        };

        PullTypeSymbol.prototype.addIndexSignature = function (indexSignature) {
            if (!this._indexSignatures) {
                this._indexSignatures = [];
            }

            this._indexSignatures[this._indexSignatures.length] = indexSignature;

            if (indexSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            indexSignature.functionType = this;
        };

        PullTypeSymbol.prototype.hasOwnCallSignatures = function () {
            return this._callSignatures !== null;
        };

        PullTypeSymbol.prototype.getOwnCallSignatures = function () {
            return this._callSignatures || TypeScript.sentinelEmptyArray;
        };

        PullTypeSymbol.prototype.getCallSignatures = function () {
            if (this._allCallSignatures) {
                return this._allCallSignatures;
            }

            var signatures = [];

            if (this._callSignatures) {
                signatures = signatures.concat(this._callSignatures);
            }

            if (this._extendedTypes && this.kind === 16 /* Interface */) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    this._getResolver()._addUnhiddenSignaturesFromBaseType(this._callSignatures, this._extendedTypes[i].getCallSignatures(), signatures);
                }
            }

            this._allCallSignatures = signatures;

            return signatures;
        };

        PullTypeSymbol.prototype.hasOwnConstructSignatures = function () {
            return this._constructSignatures !== null;
        };

        PullTypeSymbol.prototype.getOwnDeclaredConstructSignatures = function () {
            return this._constructSignatures || TypeScript.sentinelEmptyArray;
        };

        PullTypeSymbol.prototype.getConstructSignatures = function () {
            if (this._allConstructSignatures) {
                return this._allConstructSignatures;
            }

            var signatures = [];

            if (this._constructSignatures) {
                signatures = signatures.concat(this._constructSignatures);
            } else if (this.isConstructor()) {
                if (this._extendedTypes && this._extendedTypes.length > 0) {
                    signatures = this.getBaseClassConstructSignatures(this._extendedTypes[0]);
                } else {
                    signatures = [this.getDefaultClassConstructSignature()];
                }
            }

            if (this._extendedTypes && this.kind === 16 /* Interface */) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    this._getResolver()._addUnhiddenSignaturesFromBaseType(this._constructSignatures, this._extendedTypes[i].getConstructSignatures(), signatures);
                }
            }

            this._allConstructSignatures = signatures;

            return signatures;
        };

        PullTypeSymbol.prototype.hasOwnIndexSignatures = function () {
            return this._indexSignatures !== null;
        };

        PullTypeSymbol.prototype.getOwnIndexSignatures = function () {
            return this._indexSignatures || TypeScript.sentinelEmptyArray;
        };

        PullTypeSymbol.prototype.getIndexSignatures = function () {
            if (this._allIndexSignatures) {
                return this._allIndexSignatures;
            }

            var signatures = [];

            if (this._indexSignatures) {
                signatures = signatures.concat(this._indexSignatures);
            }

            if (this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    this._getResolver()._addUnhiddenSignaturesFromBaseType(this._indexSignatures, this._extendedTypes[i].getIndexSignatures(), signatures);
                }
            }

            this._allIndexSignatures = signatures;

            return signatures;
        };

        PullTypeSymbol.prototype.getIndexSignaturesOfAugmentedType = function (resolver, globalFunctionInterface, globalObjectInterface) {
            if (!this._allIndexSignaturesOfAugmentedType) {
                var initialIndexSignatures = this.getIndexSignatures();
                var shouldAddFunctionSignatures = false;
                var shouldAddObjectSignatures = false;

                if (globalFunctionInterface && this.isFunctionType() && this !== globalFunctionInterface) {
                    var functionIndexSignatures = globalFunctionInterface.getIndexSignatures();
                    if (functionIndexSignatures.length) {
                        shouldAddFunctionSignatures = true;
                    }
                }

                if (globalObjectInterface && this !== globalObjectInterface) {
                    var objectIndexSignatures = globalObjectInterface.getIndexSignatures();
                    if (objectIndexSignatures.length) {
                        shouldAddObjectSignatures = true;
                    }
                }

                if (shouldAddFunctionSignatures || shouldAddObjectSignatures) {
                    this._allIndexSignaturesOfAugmentedType = initialIndexSignatures.slice(0);
                    if (shouldAddFunctionSignatures) {
                        resolver._addUnhiddenSignaturesFromBaseType(initialIndexSignatures, functionIndexSignatures, this._allIndexSignaturesOfAugmentedType);
                    }
                    if (shouldAddObjectSignatures) {
                        if (shouldAddFunctionSignatures) {
                            initialIndexSignatures = initialIndexSignatures.concat(functionIndexSignatures);
                        }
                        resolver._addUnhiddenSignaturesFromBaseType(initialIndexSignatures, objectIndexSignatures, this._allIndexSignaturesOfAugmentedType);
                    }
                } else {
                    this._allIndexSignaturesOfAugmentedType = initialIndexSignatures;
                }
            }

            return this._allIndexSignaturesOfAugmentedType;
        };

        PullTypeSymbol.prototype.getBaseClassConstructSignatures = function (baseType) {
            TypeScript.Debug.assert(this.isConstructor() && baseType.isConstructor());
            var instanceTypeSymbol = this.getAssociatedContainerType();
            TypeScript.Debug.assert(instanceTypeSymbol.getDeclarations().length === 1);
            if (baseType.hasBase(this)) {
                return null;
            }

            var baseConstructSignatures = baseType.getConstructSignatures();
            var signatures = [];
            for (var i = 0; i < baseConstructSignatures.length; i++) {
                var baseSignature = baseConstructSignatures[i];

                baseSignature._resolveDeclaredSymbol();
                var currentSignature = new PullSignatureSymbol(2097152 /* ConstructSignature */, this.semanticInfoChain, baseSignature.isDefinition());
                currentSignature.returnType = instanceTypeSymbol;
                currentSignature.addTypeParametersFromReturnType();
                for (var j = 0; j < baseSignature.parameters.length; j++) {
                    currentSignature.addParameter(baseSignature.parameters[j], baseSignature.parameters[j].isOptional);
                }
                if (baseSignature.parameters.length > 0) {
                    currentSignature.hasVarArgs = baseSignature.parameters[baseSignature.parameters.length - 1].isVarArg;
                }

                currentSignature.addDeclaration(instanceTypeSymbol.getDeclarations()[0]);
                this.addCallOrConstructSignaturePrerequisiteBase(currentSignature);
                signatures.push(currentSignature);
            }

            return signatures;
        };

        PullTypeSymbol.prototype.getDefaultClassConstructSignature = function () {
            TypeScript.Debug.assert(this.isConstructor());
            var instanceTypeSymbol = this.getAssociatedContainerType();
            TypeScript.Debug.assert(instanceTypeSymbol.getDeclarations().length == 1);
            var signature = new PullSignatureSymbol(2097152 /* ConstructSignature */, this.semanticInfoChain, true);
            signature.returnType = instanceTypeSymbol;
            signature.addTypeParametersFromReturnType();
            signature.addDeclaration(instanceTypeSymbol.getDeclarations()[0]);
            this.addCallOrConstructSignaturePrerequisiteBase(signature);

            return signature;
        };

        PullTypeSymbol.prototype.addImplementedType = function (implementedType) {
            if (!implementedType) {
                return;
            }

            if (!this._implementedTypes) {
                this._implementedTypes = [];
            }

            this._implementedTypes[this._implementedTypes.length] = implementedType;

            implementedType.addTypeThatExplicitlyImplementsThisType(this);
        };

        PullTypeSymbol.prototype.getImplementedTypes = function () {
            if (!this._implementedTypes) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._implementedTypes;
        };

        PullTypeSymbol.prototype.addExtendedType = function (extendedType) {
            if (!extendedType) {
                return;
            }

            if (!this._extendedTypes) {
                this._extendedTypes = [];
            }

            this._extendedTypes[this._extendedTypes.length] = extendedType;

            extendedType.addTypeThatExtendsThisType(this);
        };

        PullTypeSymbol.prototype.getExtendedTypes = function () {
            if (!this._extendedTypes) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._extendedTypes;
        };

        PullTypeSymbol.prototype.addTypeThatExtendsThisType = function (type) {
            if (!type) {
                return;
            }

            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }

            this._typesThatExtendThisType[this._typesThatExtendThisType.length] = type;
        };

        PullTypeSymbol.prototype.getTypesThatExtendThisType = function () {
            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }

            return this._typesThatExtendThisType;
        };

        PullTypeSymbol.prototype.addTypeThatExplicitlyImplementsThisType = function (type) {
            if (!type) {
                return;
            }

            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            this._typesThatExplicitlyImplementThisType[this._typesThatExplicitlyImplementThisType.length] = type;
        };

        PullTypeSymbol.prototype.getTypesThatExplicitlyImplementThisType = function () {
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            return this._typesThatExplicitlyImplementThisType;
        };

        PullTypeSymbol.prototype.hasBase = function (potentialBase, visited) {
            if (typeof visited === "undefined") { visited = []; }
            if (this === potentialBase || this.getRootSymbol() === potentialBase || this === potentialBase.getRootSymbol()) {
                return true;
            }

            if (TypeScript.ArrayUtilities.contains(visited, this)) {
                return true;
            }

            visited.push(this);

            var extendedTypes = this.getExtendedTypes();

            for (var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }

            var implementedTypes = this.getImplementedTypes();

            for (var i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }

            visited.pop();

            return false;
        };

        PullTypeSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            if (baseType.isError()) {
                return false;
            }

            var thisIsClass = this.isClass();
            if (isExtendedType) {
                if (thisIsClass) {
                    return baseType.kind === 8 /* Class */;
                }
            } else {
                if (!thisIsClass) {
                    return false;
                }
            }

            return !!(baseType.kind & (16 /* Interface */ | 8 /* Class */));
        };

        PullTypeSymbol.prototype.findMember = function (name, lookInParent) {
            var memberSymbol = null;

            if (this._memberNameCache) {
                memberSymbol = this._memberNameCache[name];
            }

            if (memberSymbol || !lookInParent) {
                return memberSymbol;
            }

            if (this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    memberSymbol = this._extendedTypes[i].findMember(name, lookInParent);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            return null;
        };

        PullTypeSymbol.prototype.findNestedType = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            var memberSymbol;

            if (!this._enclosedTypeNameCache) {
                return null;
            }

            memberSymbol = this._enclosedTypeNameCache[name];

            if (memberSymbol && kind !== 0 /* None */) {
                memberSymbol = TypeScript.hasFlag(memberSymbol.kind, kind) ? memberSymbol : null;
            }

            return memberSymbol;
        };

        PullTypeSymbol.prototype.findNestedContainer = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            var memberSymbol;

            if (!this._enclosedContainerCache) {
                return null;
            }

            memberSymbol = this._enclosedContainerCache[name];

            if (memberSymbol && kind !== 0 /* None */) {
                memberSymbol = TypeScript.hasFlag(memberSymbol.kind, kind) ? memberSymbol : null;
            }

            return memberSymbol;
        };

        PullTypeSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisiblity) {
            var allMembers = [];

            if (this._members !== TypeScript.sentinelEmptyArray) {
                for (var i = 0, n = this._members.length; i < n; i++) {
                    var member = this._members[i];
                    if ((member.kind & searchDeclKind) && (memberVisiblity !== 2 /* externallyVisible */ || !member.anyDeclHasFlag(2 /* Private */))) {
                        allMembers[allMembers.length] = member;
                    }
                }
            }

            if (this._extendedTypes) {
                var extenedMembersVisibility = memberVisiblity !== 0 /* all */ ? 2 /* externallyVisible */ : 0 /* all */;

                for (var i = 0, n = this._extendedTypes.length; i < n; i++) {
                    var extendedMembers = this._extendedTypes[i].getAllMembers(searchDeclKind, extenedMembersVisibility);

                    for (var j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!(this._memberNameCache && this._memberNameCache[extendedMember.name])) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }

            if (this.isContainer()) {
                if (this._enclosedMemberTypes) {
                    for (var i = 0; i < this._enclosedMemberTypes.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberTypes[i];
                    }
                }
                if (this._enclosedMemberContainers) {
                    for (var i = 0; i < this._enclosedMemberContainers.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberContainers[i];
                    }
                }
            }

            return allMembers;
        };

        PullTypeSymbol.prototype.findTypeParameter = function (name) {
            if (!this._typeParameterNameCache) {
                return null;
            }

            return this._typeParameterNameCache[name];
        };

        PullTypeSymbol.prototype.setResolved = function () {
            _super.prototype.setResolved.call(this);
        };

        PullTypeSymbol.prototype.getNamePartForFullName = function () {
            var name = _super.prototype.getNamePartForFullName.call(this);

            var typars = this.getTypeArgumentsOrTypeParameters();
            var typarString = PullSymbol.getTypeParameterString(typars, this, true);
            return name + typarString;
        };

        PullTypeSymbol.prototype.getScopedName = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName) {
            return this.getScopedNameEx(scopeSymbol, skipTypeParametersInName, useConstraintInName, false, false, skipInternalAliasName).toString();
        };

        PullTypeSymbol.prototype.isNamedTypeSymbol = function () {
            var kind = this.kind;
            if (kind === 2 /* Primitive */ || kind === 8 /* Class */ || kind === 4 /* Container */ || kind === 32 /* DynamicModule */ || kind === 128 /* TypeAlias */ || kind === 64 /* Enum */ || kind === 8192 /* TypeParameter */ || ((kind === 16 /* Interface */ || kind === 8388608 /* ObjectType */) && this.name !== "")) {
                return true;
            }

            return false;
        };

        PullTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getScopedNameEx(scopeSymbol, false, useConstraintInName).toString();
            return s;
        };

        PullTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, skipTypeParametersInName, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo, skipInternalAliasName, shouldAllowArrayType) {
            if (typeof shouldAllowArrayType === "undefined") { shouldAllowArrayType = true; }
            if (this.isArrayNamedTypeReference() && shouldAllowArrayType) {
                var elementType = this.getElementType();
                var elementMemberName = elementType ? (elementType.isArrayNamedTypeReference() || elementType.isNamedTypeSymbol() ? elementType.getScopedNameEx(scopeSymbol, false, false, getPrettyTypeName, getTypeParamMarkerInfo, skipInternalAliasName) : elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName)) : TypeScript.MemberName.create("any");
                return TypeScript.MemberName.create(elementMemberName, "", "[]");
            }

            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(true, scopeSymbol, getPrettyTypeName);
            }

            if (skipTypeParametersInName) {
                return TypeScript.MemberName.create(_super.prototype.getScopedName.call(this, scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName));
            } else {
                var builder = new TypeScript.MemberNameArray();
                builder.prefix = _super.prototype.getScopedName.call(this, scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName);

                var typars = this.getTypeArgumentsOrTypeParameters();
                builder.add(PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, getTypeParamMarkerInfo, useConstraintInName));

                return builder;
            }
        };

        PullTypeSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length === 0 && constructSignatures.length === 0 && callSignatures.length > 1;
        };

        PullTypeSymbol.prototype.getTypeOfSymbol = function () {
            var associatedContainerType = this.getAssociatedContainerType();
            if (associatedContainerType && associatedContainerType.isNamedTypeSymbol()) {
                return associatedContainerType;
            }

            var functionSymbol = this.getFunctionSymbol();
            if (functionSymbol && functionSymbol.kind === 16384 /* Function */ && !TypeScript.PullHelpers.isSymbolLocal(functionSymbol)) {
                return TypeScript.PullHelpers.isExportedSymbolInClodule(functionSymbol) ? null : functionSymbol;
            }

            return null;
        };

        PullTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();

            var typeOfSymbol = this.getTypeOfSymbol();
            if (typeOfSymbol) {
                var nameForTypeOf = typeOfSymbol.getScopedNameEx(scopeSymbol, true);
                return TypeScript.MemberName.create(nameForTypeOf, "typeof ", "");
            }

            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                if (this._inMemberTypeNameEx) {
                    return TypeScript.MemberName.create("any");
                }

                this._inMemberTypeNameEx = true;

                var allMemberNames = new TypeScript.MemberNameArray();
                var curlies = !topLevel || indexSignatures.length !== 0;
                var delim = "; ";
                for (var i = 0; i < members.length; i++) {
                    if (members[i].kind === 65536 /* Method */ && members[i].type.hasOnlyOverloadCallSignatures()) {
                        var methodCallSignatures = members[i].type.getCallSignatures();
                        var nameStr = members[i].getDisplayName(scopeSymbol) + (members[i].isOptional ? "?" : "");
                        ;
                        var methodMemberNames = PullSignatureSymbol.getSignaturesTypeNameEx(methodCallSignatures, nameStr, false, false, scopeSymbol);
                        allMemberNames.addAll(methodMemberNames);
                    } else {
                        var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);
                        if (memberTypeName.isArray() && memberTypeName.delim === delim) {
                            allMemberNames.addAll(memberTypeName.entries);
                        } else {
                            allMemberNames.add(memberTypeName);
                        }
                    }
                    curlies = true;
                }

                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();

                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                var useShortFormSignature = !curlies && (signatureCount === 1);
                var signatureMemberName;

                if (callSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, "", useShortFormSignature, false, scopeSymbol, getPrettyFunctionOverload);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (constructSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, false, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (indexSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, "", useShortFormSignature, true, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                    allMemberNames.prefix = "{ ";
                    allMemberNames.suffix = "}";
                    allMemberNames.delim = delim;
                } else if (allMemberNames.entries.length > 1) {
                    allMemberNames.delim = delim;
                }

                this._inMemberTypeNameEx = false;

                return allMemberNames;
            }

            return TypeScript.MemberName.create("{}");
        };

        PullTypeSymbol.prototype.getGenerativeTypeClassification = function (enclosingType) {
            return 2 /* Closed */;
        };

        PullTypeSymbol.prototype.wrapsSomeTypeParameter = function (typeParameterArgumentMap, skipTypeArgumentCheck) {
            return this.getWrappingTypeParameterID(typeParameterArgumentMap, skipTypeArgumentCheck) != 0;
        };

        PullTypeSymbol.prototype.getWrappingTypeParameterID = function (typeParameterArgumentMap, skipTypeArgumentCheck) {
            if (this.isTypeParameter()) {
                if (typeParameterArgumentMap[this.pullSymbolID] || typeParameterArgumentMap[this.getRootSymbol().pullSymbolID]) {
                    return this.pullSymbolID;
                }
            }

            if (this.inWrapCheck) {
                return 0;
            }

            this._wrapsTypeParameterCache = this._wrapsTypeParameterCache || new TypeScript.WrapsTypeParameterCache();
            var wrappingTypeParameterID = this._wrapsTypeParameterCache.getWrapsTypeParameter(typeParameterArgumentMap);
            if (wrappingTypeParameterID === undefined) {
                this.inWrapCheck = true;
                wrappingTypeParameterID = this.getWrappingTypeParameterIDWorker(typeParameterArgumentMap, skipTypeArgumentCheck);
                this.inWrapCheck = false;

                this._wrapsTypeParameterCache.setWrapsTypeParameter(typeParameterArgumentMap, wrappingTypeParameterID);
            }
            return wrappingTypeParameterID;
        };

        PullTypeSymbol.prototype.getWrappingTypeParameterIDWorker = function (typeParameterArgumentMap, skipTypeArgumentCheck) {
            var wrappingTypeParameterID = 0;

            if (!skipTypeArgumentCheck) {
                var typeArguments = this.getTypeArguments();

                if (this.isGeneric() && !typeArguments) {
                    typeArguments = this.getTypeParameters();
                }

                if (typeArguments) {
                    for (var i = 0; !wrappingTypeParameterID && i < typeArguments.length; i++) {
                        wrappingTypeParameterID = typeArguments[i].getWrappingTypeParameterID(typeParameterArgumentMap);
                        if (wrappingTypeParameterID !== 0) {
                            return wrappingTypeParameterID;
                        }
                    }
                }
            }

            if (skipTypeArgumentCheck || !(this.kind & 8216 /* SomeInstantiatableType */) || !this.name) {
                var members = this.getAllMembers(68147712 /* SomeValue */, 0 /* all */);
                for (var i = 0; i < members.length; i++) {
                    TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(members[i]);
                    wrappingTypeParameterID = members[i].type.getWrappingTypeParameterID(typeParameterArgumentMap);
                    if (wrappingTypeParameterID !== 0) {
                        return wrappingTypeParameterID;
                    }
                }

                return this.getWrappingTypeParameterIDFromSignatures(this.getCallSignatures(), typeParameterArgumentMap) || this.getWrappingTypeParameterIDFromSignatures(this.getConstructSignatures(), typeParameterArgumentMap) || this.getWrappingTypeParameterIDFromSignatures(this.getIndexSignatures(), typeParameterArgumentMap);
            }

            return 0;
        };

        PullTypeSymbol.prototype.getWrappingTypeParameterIDFromSignatures = function (signatures, typeParameterArgumentMap) {
            for (var i = 0; i < signatures.length; i++) {
                var wrappingTypeParameterID = signatures[i].getWrappingTypeParameterID(typeParameterArgumentMap);
                if (wrappingTypeParameterID !== 0) {
                    return wrappingTypeParameterID;
                }
            }

            return 0;
        };

        PullTypeSymbol.prototype.wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference = function (enclosingType) {
            TypeScript.Debug.assert(this.isNamedTypeSymbol());
            TypeScript.Debug.assert(TypeScript.PullHelpers.getRootType(enclosingType) == enclosingType);
            var knownWrapMap = TypeScript.BitMatrix.getBitMatrix(true);
            var wrapsIntoInfinitelyExpandingTypeReference = this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType, knownWrapMap);
            knownWrapMap.release();
            return wrapsIntoInfinitelyExpandingTypeReference;
        };

        PullTypeSymbol.prototype._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse = function (enclosingType, knownWrapMap) {
            var wrapsIntoInfinitelyExpandingTypeReference = knownWrapMap.valueAt(this.pullSymbolID, enclosingType.pullSymbolID);
            if (wrapsIntoInfinitelyExpandingTypeReference != undefined) {
                return wrapsIntoInfinitelyExpandingTypeReference;
            }

            if (this.inWrapInfiniteExpandingReferenceCheck) {
                return false;
            }

            this.inWrapInfiniteExpandingReferenceCheck = true;
            wrapsIntoInfinitelyExpandingTypeReference = this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType, knownWrapMap);
            knownWrapMap.setValueAt(this.pullSymbolID, enclosingType.pullSymbolID, wrapsIntoInfinitelyExpandingTypeReference);
            this.inWrapInfiniteExpandingReferenceCheck = false;

            return wrapsIntoInfinitelyExpandingTypeReference;
        };

        PullTypeSymbol.prototype._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker = function (enclosingType, knownWrapMap) {
            var thisRootType = TypeScript.PullHelpers.getRootType(this);

            if (thisRootType != enclosingType) {
                var thisIsNamedType = this.isNamedTypeSymbol();

                if (thisIsNamedType) {
                    if (thisRootType.inWrapInfiniteExpandingReferenceCheck) {
                        return false;
                    }

                    thisRootType.inWrapInfiniteExpandingReferenceCheck = true;
                }

                var wrapsIntoInfinitelyExpandingTypeReference = this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceStructure(enclosingType, knownWrapMap);

                if (thisIsNamedType) {
                    thisRootType.inWrapInfiniteExpandingReferenceCheck = false;
                }

                return wrapsIntoInfinitelyExpandingTypeReference;
            }

            var enclosingTypeParameters = enclosingType.getTypeParameters();
            var typeArguments = this.getTypeArguments();
            for (var i = 0; i < typeArguments.length; i++) {
                if (TypeScript.ArrayUtilities.contains(enclosingTypeParameters, typeArguments[i])) {
                    continue;
                }

                if (typeArguments[i].wrapsSomeTypeParameter(this.getTypeParameterSubstitutionMap())) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceStructure = function (enclosingType, knownWrapMap) {
            var members = this.getAllMembers(68147712 /* SomeValue */, 0 /* all */);
            for (var i = 0; i < members.length; i++) {
                if (members[i].type && members[i].type._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            var sigs = this.getCallSignatures();
            for (var i = 0; i < sigs.length; i++) {
                if (sigs[i]._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            sigs = this.getConstructSignatures();
            for (var i = 0; i < sigs.length; i++) {
                if (sigs[i]._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            sigs = this.getIndexSignatures();
            for (var i = 0; i < sigs.length; i++) {
                if (sigs[i]._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype.widenedType = function (resolver, ast, context) {
            if (!this._widenedType) {
                this._widenedType = resolver.widenType(this, ast, context);
            }
            return this._widenedType;
        };
        return PullTypeSymbol;
    })(PullSymbol);
    TypeScript.PullTypeSymbol = PullTypeSymbol;

    var PullPrimitiveTypeSymbol = (function (_super) {
        __extends(PullPrimitiveTypeSymbol, _super);
        function PullPrimitiveTypeSymbol(name, semanticInfoChain) {
            _super.call(this, name, 2 /* Primitive */, semanticInfoChain);

            this.isResolved = true;
        }
        PullPrimitiveTypeSymbol.prototype.isAny = function () {
            return !this.isStringConstant() && this.name === "any";
        };

        PullPrimitiveTypeSymbol.prototype.isNull = function () {
            return !this.isStringConstant() && this.name === "null";
        };

        PullPrimitiveTypeSymbol.prototype.isUndefined = function () {
            return !this.isStringConstant() && this.name === "undefined";
        };

        PullPrimitiveTypeSymbol.prototype.isStringConstant = function () {
            return false;
        };

        PullPrimitiveTypeSymbol.prototype.setUnresolved = function () {
        };

        PullPrimitiveTypeSymbol.prototype.getDisplayName = function () {
            if (this.isNull() || this.isUndefined()) {
                return "any";
            } else {
                return _super.prototype.getDisplayName.call(this);
            }
        };
        return PullPrimitiveTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullPrimitiveTypeSymbol = PullPrimitiveTypeSymbol;

    var PullStringConstantTypeSymbol = (function (_super) {
        __extends(PullStringConstantTypeSymbol, _super);
        function PullStringConstantTypeSymbol(name, semanticInfoChain) {
            _super.call(this, name, semanticInfoChain);
        }
        PullStringConstantTypeSymbol.prototype.isStringConstant = function () {
            return true;
        };
        return PullStringConstantTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullStringConstantTypeSymbol = PullStringConstantTypeSymbol;

    var PullErrorTypeSymbol = (function (_super) {
        __extends(PullErrorTypeSymbol, _super);
        function PullErrorTypeSymbol(_anyType, name, semanticInfoChain) {
            _super.call(this, name, semanticInfoChain);
            this._anyType = _anyType;

            TypeScript.Debug.assert(this._anyType);
            this.isResolved = true;
        }
        PullErrorTypeSymbol.prototype.isError = function () {
            return true;
        };

        PullErrorTypeSymbol.prototype._getResolver = function () {
            return this._anyType._getResolver();
        };

        PullErrorTypeSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            return this._anyType.getName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName, skipInternalAliasName) {
            return this._anyType.getName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            return this._anyType.getName(scopeSymbol, useConstraintInName);
        };
        return PullErrorTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullErrorTypeSymbol = PullErrorTypeSymbol;

    var PullContainerSymbol = (function (_super) {
        __extends(PullContainerSymbol, _super);
        function PullContainerSymbol(name, kind, semanticInfoChain) {
            _super.call(this, name, kind, semanticInfoChain);
            this.instanceSymbol = null;
            this.assignedValue = null;
            this.assignedType = null;
            this.assignedContainer = null;
        }
        PullContainerSymbol.prototype.isContainer = function () {
            return true;
        };

        PullContainerSymbol.prototype.setInstanceSymbol = function (symbol) {
            this.instanceSymbol = symbol;
        };

        PullContainerSymbol.prototype.getInstanceSymbol = function () {
            return this.instanceSymbol;
        };

        PullContainerSymbol.prototype.setExportAssignedValueSymbol = function (symbol) {
            this.assignedValue = symbol;
        };

        PullContainerSymbol.prototype.getExportAssignedValueSymbol = function () {
            return this.assignedValue;
        };

        PullContainerSymbol.prototype.setExportAssignedTypeSymbol = function (type) {
            this.assignedType = type;
        };

        PullContainerSymbol.prototype.getExportAssignedTypeSymbol = function () {
            return this.assignedType;
        };

        PullContainerSymbol.prototype.setExportAssignedContainerSymbol = function (container) {
            this.assignedContainer = container;
        };

        PullContainerSymbol.prototype.getExportAssignedContainerSymbol = function () {
            return this.assignedContainer;
        };

        PullContainerSymbol.prototype.hasExportAssignment = function () {
            return !!this.assignedValue || !!this.assignedType || !!this.assignedContainer;
        };

        PullContainerSymbol.usedAsSymbol = function (containerSymbol, symbol) {
            if (!containerSymbol || !containerSymbol.isContainer()) {
                return false;
            }

            if (!containerSymbol.isAlias() && containerSymbol.type === symbol) {
                return true;
            }

            var moduleSymbol = containerSymbol;
            var valueExportSymbol = moduleSymbol.getExportAssignedValueSymbol();
            var typeExportSymbol = moduleSymbol.getExportAssignedTypeSymbol();
            var containerExportSymbol = moduleSymbol.getExportAssignedContainerSymbol();
            if (valueExportSymbol || typeExportSymbol || containerExportSymbol) {
                if (valueExportSymbol === symbol || typeExportSymbol == symbol || containerExportSymbol == symbol) {
                    return true;
                }

                if (containerExportSymbol != containerSymbol) {
                    return PullContainerSymbol.usedAsSymbol(containerExportSymbol, symbol);
                }
            }

            return false;
        };

        PullContainerSymbol.prototype.getInstanceType = function () {
            return this.instanceSymbol ? this.instanceSymbol.type : null;
        };
        return PullContainerSymbol;
    })(PullTypeSymbol);
    TypeScript.PullContainerSymbol = PullContainerSymbol;

    var PullTypeAliasSymbol = (function (_super) {
        __extends(PullTypeAliasSymbol, _super);
        function PullTypeAliasSymbol(name, semanticInfoChain) {
            _super.call(this, name, 128 /* TypeAlias */, semanticInfoChain);
            this._assignedValue = null;
            this._assignedType = null;
            this._assignedContainer = null;
            this._isUsedAsValue = false;
            this._typeUsedExternally = false;
            this._isUsedInExportAlias = false;
            this.retrievingExportAssignment = false;
            this.linkedAliasSymbols = null;
        }
        PullTypeAliasSymbol.prototype.isUsedInExportedAlias = function () {
            this._resolveDeclaredSymbol();
            return this._isUsedInExportAlias;
        };

        PullTypeAliasSymbol.prototype.typeUsedExternally = function () {
            this._resolveDeclaredSymbol();
            return this._typeUsedExternally;
        };

        PullTypeAliasSymbol.prototype.isUsedAsValue = function () {
            this._resolveDeclaredSymbol();
            return this._isUsedAsValue;
        };

        PullTypeAliasSymbol.prototype.setTypeUsedExternally = function () {
            this._typeUsedExternally = true;
        };

        PullTypeAliasSymbol.prototype.setIsUsedInExportedAlias = function () {
            this._isUsedInExportAlias = true;
            if (this.linkedAliasSymbols) {
                this.linkedAliasSymbols.forEach(function (s) {
                    return s.setIsUsedInExportedAlias();
                });
            }
        };

        PullTypeAliasSymbol.prototype.addLinkedAliasSymbol = function (contingentValueSymbol) {
            if (!this.linkedAliasSymbols) {
                this.linkedAliasSymbols = [contingentValueSymbol];
            } else {
                this.linkedAliasSymbols.push(contingentValueSymbol);
            }
        };

        PullTypeAliasSymbol.prototype.setIsUsedAsValue = function () {
            this._isUsedAsValue = true;
            if (this.linkedAliasSymbols) {
                this.linkedAliasSymbols.forEach(function (s) {
                    return s.setIsUsedAsValue();
                });
            }
        };

        PullTypeAliasSymbol.prototype.assignedValue = function () {
            this._resolveDeclaredSymbol();
            return this._assignedValue;
        };

        PullTypeAliasSymbol.prototype.assignedType = function () {
            this._resolveDeclaredSymbol();
            return this._assignedType;
        };

        PullTypeAliasSymbol.prototype.assignedContainer = function () {
            this._resolveDeclaredSymbol();
            return this._assignedContainer;
        };

        PullTypeAliasSymbol.prototype.isAlias = function () {
            return true;
        };
        PullTypeAliasSymbol.prototype.isContainer = function () {
            return true;
        };

        PullTypeAliasSymbol.prototype.setAssignedValueSymbol = function (symbol) {
            this._assignedValue = symbol;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedValueSymbol = function () {
            if (this._assignedValue) {
                return this._assignedValue;
            }

            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this._assignedContainer) {
                if (this._assignedContainer.hasExportAssignment()) {
                    this.retrievingExportAssignment = true;
                    var sym = this._assignedContainer.getExportAssignedValueSymbol();
                    this.retrievingExportAssignment = false;
                    return sym;
                }

                return this._assignedContainer.getInstanceSymbol();
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.setAssignedTypeSymbol = function (type) {
            this._assignedType = type;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedTypeSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this._assignedType) {
                if (this._assignedType.isAlias()) {
                    this.retrievingExportAssignment = true;
                    var sym = this._assignedType.getExportAssignedTypeSymbol();
                    this.retrievingExportAssignment = false;
                } else if (this._assignedType !== this._assignedContainer) {
                    return this._assignedType;
                }
            }

            if (this._assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this._assignedContainer.getExportAssignedTypeSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this._assignedContainer;
        };

        PullTypeAliasSymbol.prototype.setAssignedContainerSymbol = function (container) {
            this._assignedContainer = container;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedContainerSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this._assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this._assignedContainer.getExportAssignedContainerSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this._assignedContainer;
        };

        PullTypeAliasSymbol.prototype.getMembers = function () {
            if (this._assignedType) {
                return this._assignedType.getMembers();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getCallSignatures = function () {
            if (this._assignedType) {
                return this._assignedType.getCallSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getConstructSignatures = function () {
            if (this._assignedType) {
                return this._assignedType.getConstructSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getIndexSignatures = function () {
            if (this._assignedType) {
                return this._assignedType.getIndexSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.findMember = function (name) {
            if (this._assignedType) {
                return this._assignedType.findMember(name, true);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.findNestedType = function (name) {
            if (this._assignedType) {
                return this._assignedType.findNestedType(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.findNestedContainer = function (name) {
            if (this._assignedType) {
                return this._assignedType.findNestedContainer(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisibility) {
            if (this._assignedType) {
                return this._assignedType.getAllMembers(searchDeclKind, memberVisibility);
            }

            return TypeScript.sentinelEmptyArray;
        };
        return PullTypeAliasSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeAliasSymbol = PullTypeAliasSymbol;

    var PullTypeParameterSymbol = (function (_super) {
        __extends(PullTypeParameterSymbol, _super);
        function PullTypeParameterSymbol(name, semanticInfoChain) {
            _super.call(this, name, 8192 /* TypeParameter */, semanticInfoChain);
            this._constraint = null;
        }
        PullTypeParameterSymbol.prototype.isTypeParameter = function () {
            return true;
        };

        PullTypeParameterSymbol.prototype.setConstraint = function (constraintType) {
            this._constraint = constraintType;
        };

        PullTypeParameterSymbol.prototype.getConstraint = function () {
            return this._constraint;
        };

        PullTypeParameterSymbol.prototype.getBaseConstraint = function (semanticInfoChain) {
            var preBaseConstraint = this.getConstraintRecursively({});
            TypeScript.Debug.assert(preBaseConstraint === null || !preBaseConstraint.isTypeParameter());
            return preBaseConstraint || semanticInfoChain.emptyTypeSymbol;
        };

        PullTypeParameterSymbol.prototype.getConstraintRecursively = function (visitedTypeParameters) {
            var constraint = this.getConstraint();

            if (constraint) {
                if (constraint.isTypeParameter()) {
                    var constraintAsTypeParameter = constraint;
                    if (!visitedTypeParameters[constraintAsTypeParameter.pullSymbolID]) {
                        visitedTypeParameters[constraintAsTypeParameter.pullSymbolID] = constraintAsTypeParameter;
                        return constraintAsTypeParameter.getConstraintRecursively(visitedTypeParameters);
                    }
                } else {
                    return constraint;
                }
            }

            return null;
        };

        PullTypeParameterSymbol.prototype.getDefaultConstraint = function (semanticInfoChain) {
            return this._constraint || semanticInfoChain.emptyTypeSymbol;
        };

        PullTypeParameterSymbol.prototype.getCallSignatures = function () {
            if (this._constraint) {
                return this._constraint.getCallSignatures();
            }

            return _super.prototype.getCallSignatures.call(this);
        };

        PullTypeParameterSymbol.prototype.getConstructSignatures = function () {
            if (this._constraint) {
                return this._constraint.getConstructSignatures();
            }

            return _super.prototype.getConstructSignatures.call(this);
        };

        PullTypeParameterSymbol.prototype.getIndexSignatures = function () {
            if (this._constraint) {
                return this._constraint.getIndexSignatures();
            }

            return _super.prototype.getIndexSignatures.call(this);
        };

        PullTypeParameterSymbol.prototype.isGeneric = function () {
            return true;
        };

        PullTypeParameterSymbol.prototype.fullName = function (scopeSymbol) {
            var name = this.getDisplayName(scopeSymbol);
            var container = this.getContainer();
            if (container) {
                var containerName = container.fullName(scopeSymbol);
                name = name + " in " + containerName;
            }

            return name;
        };

        PullTypeParameterSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getName.call(this, scopeSymbol);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName, skipInternalAliasName) {
            var name = _super.prototype.getDisplayName.call(this, scopeSymbol, useConstraintInName, skipInternalAliasName);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            return true;
        };
        return PullTypeParameterSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeParameterSymbol = PullTypeParameterSymbol;

    var PullAccessorSymbol = (function (_super) {
        __extends(PullAccessorSymbol, _super);
        function PullAccessorSymbol(name, semanticInfoChain) {
            _super.call(this, name, 4096 /* Property */, semanticInfoChain);
            this._getterSymbol = null;
            this._setterSymbol = null;
        }
        PullAccessorSymbol.prototype.isAccessor = function () {
            return true;
        };

        PullAccessorSymbol.prototype.setSetter = function (setter) {
            if (!setter) {
                return;
            }

            this._setterSymbol = setter;
        };

        PullAccessorSymbol.prototype.getSetter = function () {
            return this._setterSymbol;
        };

        PullAccessorSymbol.prototype.setGetter = function (getter) {
            if (!getter) {
                return;
            }

            this._getterSymbol = getter;
        };

        PullAccessorSymbol.prototype.getGetter = function () {
            return this._getterSymbol;
        };
        return PullAccessorSymbol;
    })(PullSymbol);
    TypeScript.PullAccessorSymbol = PullAccessorSymbol;

    function getIDForTypeSubstitutions(instantiatingTypeOrSignature, typeArgumentMap) {
        var substitution = "";
        var members = null;

        var allowedToReferenceTypeParameters = instantiatingTypeOrSignature.getAllowedToReferenceTypeParameters();
        for (var i = 0; i < allowedToReferenceTypeParameters.length; i++) {
            var typeParameter = allowedToReferenceTypeParameters[i];
            var typeParameterID = typeParameter.pullSymbolID;
            var typeArg = typeArgumentMap[typeParameterID];
            if (!typeArg) {
                typeArg = typeParameter;
            }
            substitution += typeParameterID + ":" + getIDForTypeSubstitutionsOfType(typeArg);
        }

        return substitution;
    }
    TypeScript.getIDForTypeSubstitutions = getIDForTypeSubstitutions;

    function getIDForTypeSubstitutionsOfType(type) {
        var structure;
        if (type.isError()) {
            structure = "E" + getIDForTypeSubstitutionsOfType(type._anyType);
        } else if (!type.isNamedTypeSymbol()) {
            structure = getIDForTypeSubstitutionsFromObjectType(type);
        }

        if (!structure) {
            structure = type.pullSymbolID + "#";
        }

        return structure;
    }

    function getIDForTypeSubstitutionsFromObjectType(type) {
        if (type.isResolved) {
            var getIDForTypeSubStitutionWalker = new GetIDForTypeSubStitutionWalker();
            TypeScript.PullHelpers.walkPullTypeSymbolStructure(type, getIDForTypeSubStitutionWalker);
        }

        return null;
    }

    var GetIDForTypeSubStitutionWalker = (function () {
        function GetIDForTypeSubStitutionWalker() {
            this.structure = "";
        }
        GetIDForTypeSubStitutionWalker.prototype.memberSymbolWalk = function (memberSymbol) {
            this.structure += memberSymbol.name + "@" + getIDForTypeSubstitutionsOfType(memberSymbol.type);
            return true;
        };
        GetIDForTypeSubStitutionWalker.prototype.callSignatureWalk = function (signatureSymbol) {
            this.structure += "(";
            return true;
        };
        GetIDForTypeSubStitutionWalker.prototype.constructSignatureWalk = function (signatureSymbol) {
            this.structure += "new(";
            return true;
        };
        GetIDForTypeSubStitutionWalker.prototype.indexSignatureWalk = function (signatureSymbol) {
            this.structure += "[](";
            return true;
        };
        GetIDForTypeSubStitutionWalker.prototype.signatureParameterWalk = function (parameterSymbol) {
            this.structure += parameterSymbol.name + "@" + getIDForTypeSubstitutionsOfType(parameterSymbol.type);
            return true;
        };
        GetIDForTypeSubStitutionWalker.prototype.signatureReturnTypeWalk = function (returnType) {
            this.structure += ")" + getIDForTypeSubstitutionsOfType(returnType);
            return true;
        };
        return GetIDForTypeSubStitutionWalker;
    })();

    (function (GetAllMembersVisiblity) {
        GetAllMembersVisiblity[GetAllMembersVisiblity["all"] = 0] = "all";

        GetAllMembersVisiblity[GetAllMembersVisiblity["internallyVisible"] = 1] = "internallyVisible";

        GetAllMembersVisiblity[GetAllMembersVisiblity["externallyVisible"] = 2] = "externallyVisible";
    })(TypeScript.GetAllMembersVisiblity || (TypeScript.GetAllMembersVisiblity = {}));
    var GetAllMembersVisiblity = TypeScript.GetAllMembersVisiblity;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var EnclosingTypeWalkerState = (function () {
        function EnclosingTypeWalkerState() {
        }
        EnclosingTypeWalkerState.getDefaultEnclosingTypeWalkerState = function () {
            var defaultEnclosingTypeWalkerState = new EnclosingTypeWalkerState();
            defaultEnclosingTypeWalkerState._hasSetEnclosingType = false;
            return defaultEnclosingTypeWalkerState;
        };

        EnclosingTypeWalkerState.getNonGenericEnclosingTypeWalkerState = function () {
            var defaultEnclosingTypeWalkerState = new EnclosingTypeWalkerState();
            defaultEnclosingTypeWalkerState._hasSetEnclosingType = true;
            return defaultEnclosingTypeWalkerState;
        };

        EnclosingTypeWalkerState.getGenericEnclosingTypeWalkerState = function (genericEnclosingType) {
            var defaultEnclosingTypeWalkerState = new EnclosingTypeWalkerState();
            defaultEnclosingTypeWalkerState._hasSetEnclosingType = true;
            defaultEnclosingTypeWalkerState._currentSymbols = [TypeScript.PullHelpers.getRootType(genericEnclosingType)];
            return defaultEnclosingTypeWalkerState;
        };
        return EnclosingTypeWalkerState;
    })();
    TypeScript.EnclosingTypeWalkerState = EnclosingTypeWalkerState;

    var PullTypeEnclosingTypeWalker = (function () {
        function PullTypeEnclosingTypeWalker(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.setDefaultTypeWalkerState();
        }
        PullTypeEnclosingTypeWalker.prototype.setDefaultTypeWalkerState = function () {
            this.enclosingTypeWalkerState = PullTypeEnclosingTypeWalker._defaultEnclosingTypeWalkerState;
        };

        PullTypeEnclosingTypeWalker.prototype.setNonGenericEnclosingTypeWalkerState = function () {
            this.enclosingTypeWalkerState = PullTypeEnclosingTypeWalker._nonGenericEnclosingTypeWalkerState;
        };

        PullTypeEnclosingTypeWalker.prototype.canSymbolOrDeclBeUsedAsEnclosingTypeHelper = function (name, kind) {
            return name && (kind === 8 /* Class */ || kind === 16 /* Interface */);
        };

        PullTypeEnclosingTypeWalker.prototype.canDeclBeUsedAsEnclosingType = function (decl) {
            return this.canSymbolOrDeclBeUsedAsEnclosingTypeHelper(decl.name, decl.kind);
        };

        PullTypeEnclosingTypeWalker.prototype.canSymbolBeUsedAsEnclosingType = function (symbol) {
            return this.canSymbolOrDeclBeUsedAsEnclosingTypeHelper(symbol.name, symbol.kind);
        };

        PullTypeEnclosingTypeWalker.prototype.getEnclosingType = function () {
            var currentSymbols = this.enclosingTypeWalkerState._currentSymbols;
            if (currentSymbols) {
                TypeScript.Debug.assert(currentSymbols.length > 0);
                return currentSymbols[0];
            }

            return null;
        };

        PullTypeEnclosingTypeWalker.prototype._canWalkStructure = function () {
            var enclosingType = this.getEnclosingType();
            TypeScript.Debug.assert(!enclosingType || enclosingType.isGeneric());
            return !!enclosingType;
        };

        PullTypeEnclosingTypeWalker.prototype._getCurrentSymbol = function () {
            var currentSymbols = this.enclosingTypeWalkerState._currentSymbols;
            if (currentSymbols && currentSymbols.length) {
                return currentSymbols[currentSymbols.length - 1];
            }

            return null;
        };

        PullTypeEnclosingTypeWalker.prototype.getGenerativeClassification = function () {
            if (this._canWalkStructure()) {
                var currentType = this._getCurrentSymbol();
                if (!currentType) {
                    return 0 /* Unknown */;
                }

                var variableNeededToFixNodeJitterBug = this.getEnclosingType();

                return currentType.getGenerativeTypeClassification(variableNeededToFixNodeJitterBug);
            }

            return 2 /* Closed */;
        };

        PullTypeEnclosingTypeWalker.prototype._pushSymbol = function (symbol) {
            return this.enclosingTypeWalkerState._currentSymbols.push(symbol);
        };

        PullTypeEnclosingTypeWalker.prototype._popSymbol = function () {
            return this.enclosingTypeWalkerState._currentSymbols.pop();
        };

        PullTypeEnclosingTypeWalker.prototype.setSymbolAsEnclosingType = function (type) {
            if (type.isGeneric()) {
                this.enclosingTypeWalkerState = EnclosingTypeWalkerState.getGenericEnclosingTypeWalkerState(type);
            } else {
                this.setNonGenericEnclosingTypeWalkerState();
            }
        };

        PullTypeEnclosingTypeWalker.prototype._setEnclosingTypeOfParentDecl = function (decl, setSignature) {
            var parentDecl = decl.getParentDecl();

            if (parentDecl && !(parentDecl.kind & (164 /* SomeContainer */ | 1 /* Script */))) {
                if (this.canDeclBeUsedAsEnclosingType(parentDecl)) {
                    this.setSymbolAsEnclosingType(parentDecl.getSymbol(this.semanticInfoChain));
                } else {
                    this._setEnclosingTypeOfParentDecl(parentDecl, true);
                }

                if (this._canWalkStructure()) {
                    var symbol = decl.getSymbol(this.semanticInfoChain);
                    if (symbol) {
                        if (!symbol.isType() && !symbol.isSignature()) {
                            symbol = symbol.type;
                        }

                        this._pushSymbol(symbol);
                    }

                    if (setSignature) {
                        var signature = decl.getSignatureSymbol(this.semanticInfoChain);
                        if (signature) {
                            this._pushSymbol(signature);
                        }
                    }
                }
            }
        };

        PullTypeEnclosingTypeWalker.prototype.setEnclosingTypeForSymbol = function (symbol) {
            var currentEnclosingTypeWalkerState = this.enclosingTypeWalkerState;
            if (this.canSymbolBeUsedAsEnclosingType(symbol)) {
                this.setSymbolAsEnclosingType(symbol);
            } else {
                this.setDefaultTypeWalkerState();

                var decls = symbol.getDeclarations();
                for (var i = 0; i < decls.length; i++) {
                    var decl = decls[i];
                    this._setEnclosingTypeOfParentDecl(decl, symbol.isSignature());

                    if (this.enclosingTypeWalkerState._hasSetEnclosingType) {
                        break;
                    }
                }

                if (!this.enclosingTypeWalkerState._hasSetEnclosingType) {
                    this.setNonGenericEnclosingTypeWalkerState();
                }
            }
            return currentEnclosingTypeWalkerState;
        };

        PullTypeEnclosingTypeWalker.prototype.startWalkingType = function (symbol) {
            var currentState = this.enclosingTypeWalkerState;

            var setEnclosingTypeForSymbol = !this.enclosingTypeWalkerState._hasSetEnclosingType || this.canSymbolBeUsedAsEnclosingType(symbol);
            if (setEnclosingTypeForSymbol) {
                this.setEnclosingTypeForSymbol(symbol);
            }
            return currentState;
        };

        PullTypeEnclosingTypeWalker.prototype.endWalkingType = function (stateWhenStartedWalkingTypes) {
            this.enclosingTypeWalkerState = stateWhenStartedWalkingTypes;
        };

        PullTypeEnclosingTypeWalker.prototype.walkMemberType = function (memberName, resolver) {
            if (this._canWalkStructure()) {
                var currentType = this._getCurrentSymbol();
                var memberSymbol = currentType ? resolver._getNamedPropertySymbolOfAugmentedType(memberName, currentType) : null;
                this._pushSymbol(memberSymbol ? memberSymbol.type : null);
            }
        };

        PullTypeEnclosingTypeWalker.prototype.postWalkMemberType = function () {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        };

        PullTypeEnclosingTypeWalker.prototype.walkSignature = function (kind, index) {
            if (this._canWalkStructure()) {
                var currentType = this._getCurrentSymbol();
                var signatures;
                if (currentType) {
                    if (kind == 1048576 /* CallSignature */) {
                        signatures = currentType.getCallSignatures();
                    } else if (kind == 2097152 /* ConstructSignature */) {
                        signatures = currentType.getConstructSignatures();
                    } else {
                        signatures = currentType.getIndexSignatures();
                    }
                }

                this._pushSymbol(signatures ? signatures[index] : null);
            }
        };

        PullTypeEnclosingTypeWalker.prototype.postWalkSignature = function () {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        };

        PullTypeEnclosingTypeWalker.prototype.walkTypeArgument = function (index) {
            if (this._canWalkStructure()) {
                var typeArgument = null;
                var currentType = this._getCurrentSymbol();
                if (currentType) {
                    var typeArguments = currentType.getTypeArguments();
                    typeArgument = typeArguments ? typeArguments[index] : null;
                }
                this._pushSymbol(typeArgument);
            }
        };

        PullTypeEnclosingTypeWalker.prototype.postWalkTypeArgument = function () {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        };

        PullTypeEnclosingTypeWalker.prototype.walkTypeParameterConstraint = function (index) {
            if (this._canWalkStructure()) {
                var typeParameters;
                var currentSymbol = this._getCurrentSymbol();
                if (currentSymbol) {
                    if (currentSymbol.isSignature()) {
                        typeParameters = currentSymbol.getTypeParameters();
                    } else {
                        TypeScript.Debug.assert(currentSymbol.isType());
                        typeParameters = currentSymbol.getTypeParameters();
                    }
                }
                this._pushSymbol(typeParameters ? typeParameters[index].getConstraint() : null);
            }
        };

        PullTypeEnclosingTypeWalker.prototype.postWalkTypeParameterConstraint = function () {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        };

        PullTypeEnclosingTypeWalker.prototype.walkReturnType = function () {
            if (this._canWalkStructure()) {
                var currentSignature = this._getCurrentSymbol();
                this._pushSymbol(currentSignature ? currentSignature.returnType : null);
            }
        };

        PullTypeEnclosingTypeWalker.prototype.postWalkReturnType = function () {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        };

        PullTypeEnclosingTypeWalker.prototype.walkParameterType = function (iParam) {
            if (this._canWalkStructure()) {
                var currentSignature = this._getCurrentSymbol();
                this._pushSymbol(currentSignature ? currentSignature.getParameterTypeAtIndex(iParam) : null);
            }
        };
        PullTypeEnclosingTypeWalker.prototype.postWalkParameterType = function () {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        };

        PullTypeEnclosingTypeWalker.prototype.getBothKindOfIndexSignatures = function (resolver, context, includeAugmentedType) {
            if (this._canWalkStructure()) {
                var currentType = this._getCurrentSymbol();
                if (currentType) {
                    return resolver._getBothKindsOfIndexSignatures(currentType, context, includeAugmentedType);
                }
            }
            return null;
        };

        PullTypeEnclosingTypeWalker.prototype.walkIndexSignatureReturnType = function (indexSigInfo, useStringIndexSignature, onlySignature) {
            if (this._canWalkStructure()) {
                var indexSig = indexSigInfo ? (useStringIndexSignature ? indexSigInfo.stringSignature : indexSigInfo.numericSignature) : null;
                this._pushSymbol(indexSig);
                if (!onlySignature) {
                    this._pushSymbol(indexSig ? indexSig.returnType : null);
                }
            }
        };

        PullTypeEnclosingTypeWalker.prototype.postWalkIndexSignatureReturnType = function (onlySignature) {
            if (this._canWalkStructure()) {
                if (!onlySignature) {
                    this._popSymbol();
                }
                this._popSymbol();
            }
        };

        PullTypeEnclosingTypeWalker.prototype.resetEnclosingTypeWalkerState = function () {
            var currentState = this.enclosingTypeWalkerState;
            this.setDefaultTypeWalkerState();
            return currentState;
        };

        PullTypeEnclosingTypeWalker.prototype.setEnclosingTypeWalkerState = function (enclosingTypeWalkerState) {
            if (enclosingTypeWalkerState) {
                this.enclosingTypeWalkerState = enclosingTypeWalkerState;
            } else {
                this.setDefaultTypeWalkerState();
            }
        };
        PullTypeEnclosingTypeWalker._defaultEnclosingTypeWalkerState = EnclosingTypeWalkerState.getDefaultEnclosingTypeWalkerState();

        PullTypeEnclosingTypeWalker._nonGenericEnclosingTypeWalkerState = EnclosingTypeWalkerState.getNonGenericEnclosingTypeWalkerState();
        return PullTypeEnclosingTypeWalker;
    })();
    TypeScript.PullTypeEnclosingTypeWalker = PullTypeEnclosingTypeWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CandidateInferenceInfo = (function () {
        function CandidateInferenceInfo() {
            this.typeParameter = null;
            this._inferredTypeAfterFixing = null;
            this.inferenceCandidates = [];
        }
        CandidateInferenceInfo.prototype.addCandidate = function (candidate) {
            if (!this._inferredTypeAfterFixing) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        };

        CandidateInferenceInfo.prototype.isFixed = function () {
            return !!this._inferredTypeAfterFixing;
        };

        CandidateInferenceInfo.prototype.fixTypeParameter = function (resolver, context) {
            var _this = this;
            if (!this._inferredTypeAfterFixing) {
                var collection = {
                    getLength: function () {
                        return _this.inferenceCandidates.length;
                    },
                    getTypeAtIndex: function (index) {
                        return _this.inferenceCandidates[index].type;
                    }
                };

                var bestCommonType = resolver.findBestCommonType(null, collection, context);

                this._inferredTypeAfterFixing = bestCommonType.widenedType(resolver, null, context);
            }
        };
        return CandidateInferenceInfo;
    })();
    TypeScript.CandidateInferenceInfo = CandidateInferenceInfo;

    var TypeArgumentInferenceContext = (function () {
        function TypeArgumentInferenceContext(resolver, context, signatureBeingInferred) {
            this.resolver = resolver;
            this.context = context;
            this.signatureBeingInferred = signatureBeingInferred;
            this.inferenceCache = TypeScript.BitMatrix.getBitMatrix(false);
            this.candidateCache = [];
            var typeParameters = signatureBeingInferred.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                this.addInferenceRoot(typeParameters[i]);
            }
        }
        TypeArgumentInferenceContext.prototype.alreadyRelatingTypes = function (objectType, parameterType) {
            if (this.inferenceCache.valueAt(objectType.pullSymbolID, parameterType.pullSymbolID)) {
                return true;
            } else {
                this.inferenceCache.setValueAt(objectType.pullSymbolID, parameterType.pullSymbolID, true);
                return false;
            }
        };

        TypeArgumentInferenceContext.prototype.resetRelationshipCache = function () {
            this.inferenceCache.release();
            this.inferenceCache = TypeScript.BitMatrix.getBitMatrix(false);
        };

        TypeArgumentInferenceContext.prototype.addInferenceRoot = function (param) {
            var info = this.candidateCache[param.pullSymbolID];

            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.pullSymbolID] = info;
            }
        };

        TypeArgumentInferenceContext.prototype.getInferenceInfo = function (param) {
            return this.candidateCache[param.pullSymbolID];
        };

        TypeArgumentInferenceContext.prototype.addCandidateForInference = function (param, candidate) {
            var info = this.getInferenceInfo(param);

            if (info && candidate && info.inferenceCandidates.indexOf(candidate) < 0) {
                info.addCandidate(candidate);
            }
        };

        TypeArgumentInferenceContext.prototype.inferTypeArguments = function () {
            throw TypeScript.Errors.abstract();
        };

        TypeArgumentInferenceContext.prototype.fixTypeParameter = function (typeParameter) {
            var candidateInfo = this.candidateCache[typeParameter.pullSymbolID];
            if (candidateInfo) {
                candidateInfo.fixTypeParameter(this.resolver, this.context);
            }
        };

        TypeArgumentInferenceContext.prototype._finalizeInferredTypeArguments = function () {
            var results = [];
            var typeParameters = this.signatureBeingInferred.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                var info = this.candidateCache[typeParameters[i].pullSymbolID];

                info.fixTypeParameter(this.resolver, this.context);

                for (var i = 0; i < results.length; i++) {
                    if (results[i].type === info.typeParameter) {
                        results[i].type = info._inferredTypeAfterFixing;
                    }
                }

                results.push(info._inferredTypeAfterFixing);
            }

            return results;
        };

        TypeArgumentInferenceContext.prototype.isInvocationInferenceContext = function () {
            throw TypeScript.Errors.abstract();
        };
        return TypeArgumentInferenceContext;
    })();
    TypeScript.TypeArgumentInferenceContext = TypeArgumentInferenceContext;

    var InvocationTypeArgumentInferenceContext = (function (_super) {
        __extends(InvocationTypeArgumentInferenceContext, _super);
        function InvocationTypeArgumentInferenceContext(resolver, context, signatureBeingInferred, argumentList) {
            _super.call(this, resolver, context, signatureBeingInferred);
            this.argumentList = argumentList;
        }
        InvocationTypeArgumentInferenceContext.prototype.isInvocationInferenceContext = function () {
            return true;
        };

        InvocationTypeArgumentInferenceContext.prototype.inferTypeArguments = function () {
            var _this = this;
            this.signatureBeingInferred.forAllParameterTypes(this.argumentList.arguments.length, function (parameterType, argumentIndex) {
                var argumentAST = _this.argumentList.arguments[argumentIndex];

                _this.context.pushInferentialType(parameterType, _this);
                var argumentType = _this.resolver.resolveAST(argumentAST, true, _this.context).type;
                _this.resolver.relateTypeToTypeParametersWithNewEnclosingTypes(argumentType, parameterType, _this, _this.context);
                _this.context.popAnyContextualType();

                return true;
            });

            return this._finalizeInferredTypeArguments();
        };
        return InvocationTypeArgumentInferenceContext;
    })(TypeArgumentInferenceContext);
    TypeScript.InvocationTypeArgumentInferenceContext = InvocationTypeArgumentInferenceContext;

    var ContextualSignatureInstantiationTypeArgumentInferenceContext = (function (_super) {
        __extends(ContextualSignatureInstantiationTypeArgumentInferenceContext, _super);
        function ContextualSignatureInstantiationTypeArgumentInferenceContext(resolver, context, signatureBeingInferred, contextualSignature, shouldFixContextualSignatureParameterTypes) {
            _super.call(this, resolver, context, signatureBeingInferred);
            this.contextualSignature = contextualSignature;
            this.shouldFixContextualSignatureParameterTypes = shouldFixContextualSignatureParameterTypes;
        }
        ContextualSignatureInstantiationTypeArgumentInferenceContext.prototype.isInvocationInferenceContext = function () {
            return false;
        };

        ContextualSignatureInstantiationTypeArgumentInferenceContext.prototype.inferTypeArguments = function () {
            var _this = this;
            var relateTypesCallback = function (parameterTypeBeingInferred, contextualParameterType) {
                if (_this.shouldFixContextualSignatureParameterTypes) {
                    contextualParameterType = _this.context.fixAllTypeParametersReferencedByType(contextualParameterType, _this.resolver, _this);
                }
                _this.resolver.relateTypeToTypeParametersWithNewEnclosingTypes(contextualParameterType, parameterTypeBeingInferred, _this, _this.context);

                return true;
            };

            this.signatureBeingInferred.forAllCorrespondingParameterTypesInThisAndOtherSignature(this.contextualSignature, relateTypesCallback);

            return this._finalizeInferredTypeArguments();
        };
        return ContextualSignatureInstantiationTypeArgumentInferenceContext;
    })(TypeArgumentInferenceContext);
    TypeScript.ContextualSignatureInstantiationTypeArgumentInferenceContext = ContextualSignatureInstantiationTypeArgumentInferenceContext;

    var PullContextualTypeContext = (function () {
        function PullContextualTypeContext(contextualType, provisional, isInferentiallyTyping, typeArgumentInferenceContext) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.isInferentiallyTyping = isInferentiallyTyping;
            this.typeArgumentInferenceContext = typeArgumentInferenceContext;
            this.provisionallyTypedSymbols = [];
            this.hasProvisionalErrors = false;
            this.astSymbolMap = [];
        }
        PullContextualTypeContext.prototype.recordProvisionallyTypedSymbol = function (symbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        };

        PullContextualTypeContext.prototype.invalidateProvisionallyTypedSymbols = function () {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].setUnresolved();
            }
        };

        PullContextualTypeContext.prototype.setSymbolForAST = function (ast, symbol) {
            TypeScript.Debug.assert(!TypeScript.isShared(ast));
            this.astSymbolMap[TypeScript.syntaxID(ast)] = symbol;
        };

        PullContextualTypeContext.prototype.getSymbolForAST = function (ast) {
            return TypeScript.isShared(ast) ? null : this.astSymbolMap[TypeScript.syntaxID(ast)];
        };
        return PullContextualTypeContext;
    })();
    TypeScript.PullContextualTypeContext = PullContextualTypeContext;

    var PullTypeResolutionContext = (function () {
        function PullTypeResolutionContext(resolver, inTypeCheck, fileName) {
            if (typeof inTypeCheck === "undefined") { inTypeCheck = false; }
            if (typeof fileName === "undefined") { fileName = null; }
            this.resolver = resolver;
            this.inTypeCheck = inTypeCheck;
            this.fileName = fileName;
            this.contextStack = [];
            this.typeCheckedNodes = null;
            this.enclosingTypeWalker1 = null;
            this.enclosingTypeWalker2 = null;
            this.inBaseTypeResolution = false;
            if (inTypeCheck) {
                TypeScript.Debug.assert(fileName, "A file name must be provided if you are typechecking");
                this.typeCheckedNodes = TypeScript.BitVector.getBitVector(false);
            }
        }
        PullTypeResolutionContext.prototype.setTypeChecked = function (ast) {
            if (!this.inProvisionalResolution()) {
                this.typeCheckedNodes.setValueAt(TypeScript.syntaxID(ast), true);
            }
        };

        PullTypeResolutionContext.prototype.canTypeCheckAST = function (ast) {
            return !TypeScript.isShared(ast) && this.typeCheck() && !this.typeCheckedNodes.valueAt(TypeScript.syntaxID(ast)) && this.fileName === TypeScript.syntaxTree(ast).fileName();
        };

        PullTypeResolutionContext.prototype._pushAnyContextualType = function (type, provisional, isInferentiallyTyping, argContext) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, isInferentiallyTyping, argContext));
        };

        PullTypeResolutionContext.prototype.pushNewContextualType = function (type) {
            this._pushAnyContextualType(type, this.inProvisionalResolution(), false, null);
        };

        PullTypeResolutionContext.prototype.propagateContextualType = function (type) {
            this._pushAnyContextualType(type, this.inProvisionalResolution(), this.isInferentiallyTyping(), this.getCurrentTypeArgumentInferenceContext());
        };

        PullTypeResolutionContext.prototype.pushInferentialType = function (type, typeArgumentInferenceContext) {
            this._pushAnyContextualType(type, true, true, typeArgumentInferenceContext);
        };

        PullTypeResolutionContext.prototype.pushProvisionalType = function (type) {
            this._pushAnyContextualType(type, true, false, null);
        };

        PullTypeResolutionContext.prototype.popAnyContextualType = function () {
            var tc = this.contextStack.pop();

            tc.invalidateProvisionallyTypedSymbols();

            if (tc.hasProvisionalErrors && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].hasProvisionalErrors = true;
            }

            return tc;
        };

        PullTypeResolutionContext.prototype.hasProvisionalErrors = function () {
            return this.contextStack.length ? this.contextStack[this.contextStack.length - 1].hasProvisionalErrors : false;
        };

        PullTypeResolutionContext.prototype.getContextualType = function () {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];

            if (context) {
                var type = context.contextualType;

                if (!type) {
                    return null;
                }

                return type;
            }

            return null;
        };

        PullTypeResolutionContext.prototype.fixAllTypeParametersReferencedByType = function (type, resolver, argContext) {
            var argContext = this.getCurrentTypeArgumentInferenceContext();
            if (type.wrapsSomeTypeParameter(argContext.candidateCache)) {
                var typeParameterArgumentMap = [];

                for (var n in argContext.candidateCache) {
                    var typeParameter = argContext.candidateCache[n] && argContext.candidateCache[n].typeParameter;
                    if (typeParameter) {
                        var dummyMap = [];
                        dummyMap[typeParameter.pullSymbolID] = typeParameter;
                        if (type.wrapsSomeTypeParameter(dummyMap)) {
                            argContext.fixTypeParameter(typeParameter);
                            TypeScript.Debug.assert(argContext.candidateCache[n]._inferredTypeAfterFixing);
                            typeParameterArgumentMap[typeParameter.pullSymbolID] = argContext.candidateCache[n]._inferredTypeAfterFixing;
                        }
                    }
                }

                return resolver.instantiateType(type, typeParameterArgumentMap);
            }

            return type;
        };

        PullTypeResolutionContext.prototype.getCurrentTypeArgumentInferenceContext = function () {
            return this.contextStack.length ? this.contextStack[this.contextStack.length - 1].typeArgumentInferenceContext : null;
        };

        PullTypeResolutionContext.prototype.isInferentiallyTyping = function () {
            return this.contextStack.length > 0 && this.contextStack[this.contextStack.length - 1].isInferentiallyTyping;
        };

        PullTypeResolutionContext.prototype.inProvisionalResolution = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };

        PullTypeResolutionContext.prototype.isInBaseTypeResolution = function () {
            return this.inBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.startBaseTypeResolution = function () {
            var wasInBaseTypeResoltion = this.inBaseTypeResolution;
            this.inBaseTypeResolution = true;
            return wasInBaseTypeResoltion;
        };

        PullTypeResolutionContext.prototype.doneBaseTypeResolution = function (wasInBaseTypeResolution) {
            this.inBaseTypeResolution = wasInBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.setTypeInContext = function (symbol, type) {
            if (symbol.type && symbol.type.isError() && !type.isError()) {
                return;
            }
            symbol.type = type;

            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        };

        PullTypeResolutionContext.prototype.postDiagnostic = function (diagnostic) {
            if (diagnostic) {
                if (this.inProvisionalResolution()) {
                    (this.contextStack[this.contextStack.length - 1]).hasProvisionalErrors = true;
                } else if (this.inTypeCheck && this.resolver) {
                    this.resolver.semanticInfoChain.addDiagnostic(diagnostic);
                }
            }
        };

        PullTypeResolutionContext.prototype.typeCheck = function () {
            return this.inTypeCheck && !this.inProvisionalResolution();
        };

        PullTypeResolutionContext.prototype.setSymbolForAST = function (ast, symbol) {
            this.contextStack[this.contextStack.length - 1].setSymbolForAST(ast, symbol);
        };

        PullTypeResolutionContext.prototype.getSymbolForAST = function (ast) {
            for (var i = this.contextStack.length - 1; i >= 0; i--) {
                var typeContext = this.contextStack[i];
                if (!typeContext.provisional) {
                    break;
                }

                var symbol = typeContext.getSymbolForAST(ast);
                if (symbol) {
                    return symbol;
                }
            }

            return null;
        };

        PullTypeResolutionContext.prototype.startWalkingTypes = function (symbol1, symbol2) {
            if (!this.enclosingTypeWalker1) {
                this.enclosingTypeWalker1 = new TypeScript.PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var stateWhenStartedWalkingTypes1 = this.enclosingTypeWalker1.startWalkingType(symbol1);
            if (!this.enclosingTypeWalker2) {
                this.enclosingTypeWalker2 = new TypeScript.PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var stateWhenStartedWalkingTypes2 = this.enclosingTypeWalker2.startWalkingType(symbol2);
            return {
                stateWhenStartedWalkingTypes1: stateWhenStartedWalkingTypes1,
                stateWhenStartedWalkingTypes2: stateWhenStartedWalkingTypes2
            };
        };

        PullTypeResolutionContext.prototype.endWalkingTypes = function (statesWhenStartedWalkingTypes) {
            this.enclosingTypeWalker1.endWalkingType(statesWhenStartedWalkingTypes.stateWhenStartedWalkingTypes1);
            this.enclosingTypeWalker2.endWalkingType(statesWhenStartedWalkingTypes.stateWhenStartedWalkingTypes2);
        };

        PullTypeResolutionContext.prototype.setEnclosingTypeForSymbols = function (symbol1, symbol2) {
            if (!this.enclosingTypeWalker1) {
                this.enclosingTypeWalker1 = new TypeScript.PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var enclosingTypeWalkerState1 = this.enclosingTypeWalker1.setEnclosingTypeForSymbol(symbol1);
            if (!this.enclosingTypeWalker2) {
                this.enclosingTypeWalker2 = new TypeScript.PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var enclosingTypeWalkerState2 = this.enclosingTypeWalker2.setEnclosingTypeForSymbol(symbol2);
            return {
                enclosingTypeWalkerState1: enclosingTypeWalkerState1,
                enclosingTypeWalkerState2: enclosingTypeWalkerState2
            };
        };

        PullTypeResolutionContext.prototype.walkMemberTypes = function (memberName) {
            this.enclosingTypeWalker1.walkMemberType(memberName, this.resolver);
            this.enclosingTypeWalker2.walkMemberType(memberName, this.resolver);
        };

        PullTypeResolutionContext.prototype.postWalkMemberTypes = function () {
            this.enclosingTypeWalker1.postWalkMemberType();
            this.enclosingTypeWalker2.postWalkMemberType();
        };

        PullTypeResolutionContext.prototype.walkSignatures = function (kind, index, index2) {
            this.enclosingTypeWalker1.walkSignature(kind, index);
            this.enclosingTypeWalker2.walkSignature(kind, index2 == undefined ? index : index2);
        };

        PullTypeResolutionContext.prototype.postWalkSignatures = function () {
            this.enclosingTypeWalker1.postWalkSignature();
            this.enclosingTypeWalker2.postWalkSignature();
        };

        PullTypeResolutionContext.prototype.walkTypeParameterConstraints = function (index) {
            this.enclosingTypeWalker1.walkTypeParameterConstraint(index);
            this.enclosingTypeWalker2.walkTypeParameterConstraint(index);
        };

        PullTypeResolutionContext.prototype.postWalkTypeParameterConstraints = function () {
            this.enclosingTypeWalker1.postWalkTypeParameterConstraint();
            this.enclosingTypeWalker2.postWalkTypeParameterConstraint();
        };

        PullTypeResolutionContext.prototype.walkTypeArgument = function (index) {
            this.enclosingTypeWalker1.walkTypeArgument(index);
            this.enclosingTypeWalker2.walkTypeArgument(index);
        };

        PullTypeResolutionContext.prototype.postWalkTypeArgument = function () {
            this.enclosingTypeWalker1.postWalkTypeArgument();
            this.enclosingTypeWalker2.postWalkTypeArgument();
        };

        PullTypeResolutionContext.prototype.walkReturnTypes = function () {
            this.enclosingTypeWalker1.walkReturnType();
            this.enclosingTypeWalker2.walkReturnType();
        };

        PullTypeResolutionContext.prototype.postWalkReturnTypes = function () {
            this.enclosingTypeWalker1.postWalkReturnType();
            this.enclosingTypeWalker2.postWalkReturnType();
        };

        PullTypeResolutionContext.prototype.walkParameterTypes = function (iParam) {
            this.enclosingTypeWalker1.walkParameterType(iParam);
            this.enclosingTypeWalker2.walkParameterType(iParam);
        };

        PullTypeResolutionContext.prototype.postWalkParameterTypes = function () {
            this.enclosingTypeWalker1.postWalkParameterType();
            this.enclosingTypeWalker2.postWalkParameterType();
        };

        PullTypeResolutionContext.prototype.getBothKindOfIndexSignatures = function (includeAugmentedType1, includeAugmentedType2) {
            var indexSigs1 = this.enclosingTypeWalker1.getBothKindOfIndexSignatures(this.resolver, this, includeAugmentedType1);
            var indexSigs2 = this.enclosingTypeWalker2.getBothKindOfIndexSignatures(this.resolver, this, includeAugmentedType2);
            return { indexSigs1: indexSigs1, indexSigs2: indexSigs2 };
        };

        PullTypeResolutionContext.prototype.walkIndexSignatureReturnTypes = function (indexSigs, useStringIndexSignature1, useStringIndexSignature2, onlySignature) {
            this.enclosingTypeWalker1.walkIndexSignatureReturnType(indexSigs.indexSigs1, useStringIndexSignature1, onlySignature);
            this.enclosingTypeWalker2.walkIndexSignatureReturnType(indexSigs.indexSigs2, useStringIndexSignature2, onlySignature);
        };

        PullTypeResolutionContext.prototype.postWalkIndexSignatureReturnTypes = function (onlySignature) {
            this.enclosingTypeWalker1.postWalkIndexSignatureReturnType(onlySignature);
            this.enclosingTypeWalker2.postWalkIndexSignatureReturnType(onlySignature);
        };

        PullTypeResolutionContext.prototype.swapEnclosingTypeWalkers = function () {
            var tempEnclosingWalker1 = this.enclosingTypeWalker1;
            this.enclosingTypeWalker1 = this.enclosingTypeWalker2;
            this.enclosingTypeWalker2 = tempEnclosingWalker1;
        };

        PullTypeResolutionContext.prototype.oneOfClassificationsIsInfinitelyExpanding = function () {
            var generativeClassification1 = this.enclosingTypeWalker1.getGenerativeClassification();
            if (generativeClassification1 === 3 /* InfinitelyExpanding */) {
                return true;
            }
            var generativeClassification2 = this.enclosingTypeWalker2.getGenerativeClassification();
            if (generativeClassification2 === 3 /* InfinitelyExpanding */) {
                return true;
            }

            return false;
        };

        PullTypeResolutionContext.prototype.resetEnclosingTypeWalkerStates = function () {
            var enclosingTypeWalkerState1 = this.enclosingTypeWalker1 ? this.enclosingTypeWalker1.resetEnclosingTypeWalkerState() : null;
            var enclosingTypeWalkerState2 = this.enclosingTypeWalker2 ? this.enclosingTypeWalker2.resetEnclosingTypeWalkerState() : null;
            return {
                enclosingTypeWalkerState1: enclosingTypeWalkerState1,
                enclosingTypeWalkerState2: enclosingTypeWalkerState2
            };
        };

        PullTypeResolutionContext.prototype.setEnclosingTypeWalkerStates = function (enclosingTypeWalkerStates) {
            TypeScript.Debug.assert(this.enclosingTypeWalker1 || !enclosingTypeWalkerStates.enclosingTypeWalkerState1);
            if (this.enclosingTypeWalker1) {
                this.enclosingTypeWalker1.setEnclosingTypeWalkerState(enclosingTypeWalkerStates.enclosingTypeWalkerState1);
            }
            TypeScript.Debug.assert(this.enclosingTypeWalker2 || !enclosingTypeWalkerStates.enclosingTypeWalkerState2);
            if (this.enclosingTypeWalker2) {
                this.enclosingTypeWalker2.setEnclosingTypeWalkerState(enclosingTypeWalkerStates.enclosingTypeWalkerState2);
            }
        };
        return PullTypeResolutionContext;
    })();
    TypeScript.PullTypeResolutionContext = PullTypeResolutionContext;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var OverloadApplicabilityStatus;
    (function (OverloadApplicabilityStatus) {
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["NotAssignable"] = 0] = "NotAssignable";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["AssignableButWithProvisionalErrors"] = 1] = "AssignableButWithProvisionalErrors";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["AssignableWithNoProvisionalErrors"] = 2] = "AssignableWithNoProvisionalErrors";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["Subtype"] = 3] = "Subtype";
    })(OverloadApplicabilityStatus || (OverloadApplicabilityStatus = {}));

    var PullAdditionalCallResolutionData = (function () {
        function PullAdditionalCallResolutionData() {
            this.targetSymbol = null;
            this.resolvedSignatures = null;
            this.candidateSignature = null;
            this.actualParametersContextTypeSymbols = null;
            this.diagnosticsFromOverloadResolution = [];
        }
        return PullAdditionalCallResolutionData;
    })();
    TypeScript.PullAdditionalCallResolutionData = PullAdditionalCallResolutionData;

    var PullAdditionalObjectLiteralResolutionData = (function () {
        function PullAdditionalObjectLiteralResolutionData() {
            this.membersContextTypeSymbols = null;
        }
        return PullAdditionalObjectLiteralResolutionData;
    })();
    TypeScript.PullAdditionalObjectLiteralResolutionData = PullAdditionalObjectLiteralResolutionData;

    var MemberWithBaseOrigin = (function () {
        function MemberWithBaseOrigin(memberSymbol, baseOrigin) {
            this.memberSymbol = memberSymbol;
            this.baseOrigin = baseOrigin;
        }
        return MemberWithBaseOrigin;
    })();

    var SignatureWithBaseOrigin = (function () {
        function SignatureWithBaseOrigin(signature, baseOrigin) {
            this.signature = signature;
            this.baseOrigin = baseOrigin;
        }
        return SignatureWithBaseOrigin;
    })();

    var InheritedIndexSignatureInfo = (function () {
        function InheritedIndexSignatureInfo() {
        }
        return InheritedIndexSignatureInfo;
    })();

    var CompilerReservedName;
    (function (CompilerReservedName) {
        CompilerReservedName[CompilerReservedName["_this"] = 1] = "_this";
        CompilerReservedName[CompilerReservedName["_super"] = 2] = "_super";
        CompilerReservedName[CompilerReservedName["arguments"] = 3] = "arguments";
        CompilerReservedName[CompilerReservedName["_i"] = 4] = "_i";
        CompilerReservedName[CompilerReservedName["require"] = 5] = "require";
        CompilerReservedName[CompilerReservedName["exports"] = 6] = "exports";
    })(CompilerReservedName || (CompilerReservedName = {}));

    function getCompilerReservedName(name) {
        var nameText = TypeScript.tokenValueText(name);
        return CompilerReservedName[nameText];
    }

    var PullTypeResolver = (function () {
        function PullTypeResolver(compilationSettings, semanticInfoChain) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this._cachedAnyTypeArgs = null;
            this.typeCheckCallBacks = [];
            this.postTypeCheckWorkitems = [];
            this._cachedFunctionArgumentsSymbol = null;
            this.assignableCache = TypeScript.BitMatrix.getBitMatrix(true);
            this.subtypeCache = TypeScript.BitMatrix.getBitMatrix(true);
            this.identicalCache = TypeScript.BitMatrix.getBitMatrix(true);
            this.inResolvingOtherDeclsWalker = new TypeScript.PullHelpers.OtherPullDeclsWalker();
        }
        PullTypeResolver.prototype.cachedArrayInterfaceType = function () {
            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (!this._cachedArrayInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedArrayInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedArrayInterfaceType;
        };

        PullTypeResolver.prototype.getArrayNamedType = function () {
            return this.cachedArrayInterfaceType();
        };

        PullTypeResolver.prototype.cachedNumberInterfaceType = function () {
            if (!this._cachedNumberInterfaceType) {
                this._cachedNumberInterfaceType = this.getSymbolFromDeclPath("Number", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedNumberInterfaceType && !this._cachedNumberInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedNumberInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedNumberInterfaceType;
        };

        PullTypeResolver.prototype.cachedStringInterfaceType = function () {
            if (!this._cachedStringInterfaceType) {
                this._cachedStringInterfaceType = this.getSymbolFromDeclPath("String", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedStringInterfaceType && !this._cachedStringInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedStringInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedStringInterfaceType;
        };

        PullTypeResolver.prototype.cachedBooleanInterfaceType = function () {
            if (!this._cachedBooleanInterfaceType) {
                this._cachedBooleanInterfaceType = this.getSymbolFromDeclPath("Boolean", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedBooleanInterfaceType && !this._cachedBooleanInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedBooleanInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedBooleanInterfaceType;
        };

        PullTypeResolver.prototype.cachedObjectInterfaceType = function () {
            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.getSymbolFromDeclPath("Object", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedObjectInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedObjectInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedObjectInterfaceType;
        };

        PullTypeResolver.prototype.cachedFunctionInterfaceType = function () {
            if (!this._cachedFunctionInterfaceType) {
                this._cachedFunctionInterfaceType = this.getSymbolFromDeclPath("Function", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedFunctionInterfaceType && !this._cachedFunctionInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedFunctionInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedFunctionInterfaceType;
        };

        PullTypeResolver.prototype.cachedIArgumentsInterfaceType = function () {
            if (!this._cachedIArgumentsInterfaceType) {
                this._cachedIArgumentsInterfaceType = this.getSymbolFromDeclPath("IArguments", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedIArgumentsInterfaceType && !this._cachedIArgumentsInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedIArgumentsInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedIArgumentsInterfaceType;
        };

        PullTypeResolver.prototype.cachedRegExpInterfaceType = function () {
            if (!this._cachedRegExpInterfaceType) {
                this._cachedRegExpInterfaceType = this.getSymbolFromDeclPath("RegExp", [], 16 /* Interface */) || this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedRegExpInterfaceType && !this._cachedRegExpInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedRegExpInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedRegExpInterfaceType;
        };

        PullTypeResolver.prototype.cachedFunctionArgumentsSymbol = function () {
            if (!this._cachedFunctionArgumentsSymbol) {
                this._cachedFunctionArgumentsSymbol = new TypeScript.PullSymbol("arguments", 512 /* Variable */, this.semanticInfoChain);
                this._cachedFunctionArgumentsSymbol.type = this.cachedIArgumentsInterfaceType() || this.semanticInfoChain.anyTypeSymbol;
                this._cachedFunctionArgumentsSymbol.setResolved();

                var functionArgumentsDecl = new TypeScript.PullSynthesizedDecl("arguments", "arguments", 2048 /* Parameter */, 0 /* None */, null);
                functionArgumentsDecl.setSymbol(this._cachedFunctionArgumentsSymbol, this.semanticInfoChain);
                this._cachedFunctionArgumentsSymbol.addDeclaration(functionArgumentsDecl);
            }

            return this._cachedFunctionArgumentsSymbol;
        };

        PullTypeResolver.prototype.getApparentType = function (type) {
            if (type.isTypeParameter()) {
                var baseConstraint = type.getBaseConstraint(this.semanticInfoChain);
                if (baseConstraint === this.semanticInfoChain.anyTypeSymbol) {
                    return this.semanticInfoChain.emptyTypeSymbol;
                } else {
                    type = baseConstraint;
                }
            }
            if (type.isPrimitive()) {
                if (type === this.semanticInfoChain.numberTypeSymbol) {
                    return this.cachedNumberInterfaceType();
                }
                if (type === this.semanticInfoChain.booleanTypeSymbol) {
                    return this.cachedBooleanInterfaceType();
                }
                if (type === this.semanticInfoChain.stringTypeSymbol) {
                    return this.cachedStringInterfaceType();
                }
                return type;
            }
            if (type.isEnum()) {
                return this.cachedNumberInterfaceType();
            }
            return type;
        };

        PullTypeResolver.prototype.setTypeChecked = function (ast, context) {
            context.setTypeChecked(ast);
        };

        PullTypeResolver.prototype.canTypeCheckAST = function (ast, context) {
            return context.canTypeCheckAST(ast);
        };

        PullTypeResolver.prototype.setSymbolForAST = function (ast, symbol, context) {
            if (context && context.inProvisionalResolution()) {
                context.setSymbolForAST(ast, symbol);
            } else {
                this.semanticInfoChain.setSymbolForAST(ast, symbol);
            }
        };

        PullTypeResolver.prototype.getSymbolForAST = function (ast, context) {
            var symbol = this.semanticInfoChain.getSymbolForAST(ast);

            if (!symbol) {
                if (context && context.inProvisionalResolution()) {
                    symbol = context.getSymbolForAST(ast);
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.getASTForDecl = function (decl) {
            return this.semanticInfoChain.getASTForDecl(decl);
        };

        PullTypeResolver.prototype.getNewErrorTypeSymbol = function (name) {
            if (typeof name === "undefined") { name = null; }
            return new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, name, this.semanticInfoChain);
        };

        PullTypeResolver.prototype.getEnclosingDecl = function (decl) {
            var declPath = decl.getParentPath();

            if (declPath.length > 1 && declPath[declPath.length - 1] === decl) {
                return declPath[declPath.length - 2];
            } else {
                return declPath[declPath.length - 1];
            }
        };

        PullTypeResolver.prototype.getExportedMemberSymbol = function (symbol, parent) {
            if (!(symbol.kind & (65536 /* Method */ | 4096 /* Property */))) {
                var isContainer = (parent.kind & (4 /* Container */ | 32 /* DynamicModule */)) !== 0;
                var containerType = !isContainer ? parent.getAssociatedContainerType() : parent;

                if (isContainer && containerType) {
                    if (symbol.anyDeclHasFlag(1 /* Exported */)) {
                        return symbol;
                    }

                    return null;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype._getNamedPropertySymbolOfAugmentedType = function (symbolName, parent) {
            var memberSymbol = this.getNamedPropertySymbol(symbolName, 68147712 /* SomeValue */, parent);
            if (memberSymbol) {
                return memberSymbol;
            }

            if (this.cachedFunctionInterfaceType() && parent.isFunctionType()) {
                memberSymbol = this.cachedFunctionInterfaceType().findMember(symbolName, true);
                if (memberSymbol) {
                    return memberSymbol;
                }
            }

            if (this.cachedObjectInterfaceType()) {
                return this.cachedObjectInterfaceType().findMember(symbolName, true);
            }

            return null;
        };

        PullTypeResolver.prototype.getNamedPropertySymbol = function (symbolName, declSearchKind, parent) {
            var member = null;

            if (declSearchKind & 68147712 /* SomeValue */) {
                member = parent.findMember(symbolName, true);
            } else if (declSearchKind & 58728795 /* SomeType */) {
                member = parent.findNestedType(symbolName);
            } else if (declSearchKind & 164 /* SomeContainer */) {
                member = parent.findNestedContainer(symbolName);
            }

            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }

            var containerType = parent.getAssociatedContainerType();

            if (containerType) {
                if (containerType.isClass()) {
                    return null;
                }

                parent = containerType;

                if (declSearchKind & 68147712 /* SomeValue */) {
                    member = parent.findMember(symbolName, true);
                } else if (declSearchKind & 58728795 /* SomeType */) {
                    member = parent.findNestedType(symbolName);
                } else if (declSearchKind & 164 /* SomeContainer */) {
                    member = parent.findNestedContainer(symbolName);
                }

                if (member) {
                    return this.getExportedMemberSymbol(member, parent);
                }
            }

            if (parent.kind & 164 /* SomeContainer */) {
                var typeDeclarations = parent.getDeclarations();
                var childDecls = null;

                for (var j = 0; j < typeDeclarations.length; j++) {
                    childDecls = typeDeclarations[j].searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        member = childDecls[0].getSymbol(this.semanticInfoChain);

                        if (!member) {
                            member = childDecls[0].getSignatureSymbol(this.semanticInfoChain);
                        }
                        return this.getExportedMemberSymbol(member, parent);
                    }

                    if ((declSearchKind & 58728795 /* SomeType */) !== 0 || (declSearchKind & 68147712 /* SomeValue */) !== 0) {
                        childDecls = typeDeclarations[j].searchChildDecls(symbolName, 128 /* TypeAlias */);
                        if (childDecls.length && childDecls[0].kind === 128 /* TypeAlias */) {
                            var aliasSymbol = this.getExportedMemberSymbol(childDecls[0].getSymbol(this.semanticInfoChain), parent);
                            if (aliasSymbol) {
                                if (!aliasSymbol.isResolved) {
                                    this.resolveDeclaredSymbol(aliasSymbol);
                                }

                                if ((declSearchKind & 58728795 /* SomeType */) !== 0) {
                                    var typeSymbol = aliasSymbol.getExportAssignedTypeSymbol();
                                    if (typeSymbol) {
                                        return typeSymbol;
                                    }
                                } else {
                                    var valueSymbol = aliasSymbol.getExportAssignedValueSymbol();
                                    if (valueSymbol) {
                                        aliasSymbol.setIsUsedAsValue();
                                        return valueSymbol;
                                    }
                                }

                                return aliasSymbol;
                            }
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.getSymbolFromDeclPath = function (symbolName, declPath, declSearchKind) {
            var _this = this;
            var symbol = null;

            var decl = null;
            var childDecls;
            var declSymbol = null;
            var declMembers;
            var pathDeclKind;
            var valDecl = null;
            var kind;
            var instanceSymbol = null;
            var instanceType = null;
            var childSymbol = null;

            var allowedContainerDeclKind = 4 /* Container */ | 32 /* DynamicModule */;
            if (TypeScript.hasFlag(declSearchKind, 67108864 /* EnumMember */)) {
                allowedContainerDeclKind |= 64 /* Enum */;
            }

            var isAcceptableAlias = function (symbol) {
                if (symbol.isAlias()) {
                    _this.resolveDeclaredSymbol(symbol);
                    if (TypeScript.hasFlag(declSearchKind, 164 /* SomeContainer */)) {
                        if (symbol.assignedContainer() || symbol.getExportAssignedContainerSymbol()) {
                            return true;
                        }
                    } else if (TypeScript.hasFlag(declSearchKind, 58728795 /* SomeType */)) {
                        var type = symbol.getExportAssignedTypeSymbol();
                        if (type && type.kind !== 32 /* DynamicModule */) {
                            return true;
                        }

                        var type = symbol.assignedType();
                        if (type && type.kind !== 32 /* DynamicModule */) {
                            return true;
                        }
                    } else if (TypeScript.hasFlag(declSearchKind, 68147712 /* SomeValue */ & ~67108864 /* EnumMember */)) {
                        if (symbol.assignedType() && symbol.assignedType().isError()) {
                            return true;
                        } else if (symbol.assignedValue() || symbol.getExportAssignedValueSymbol()) {
                            return true;
                        } else {
                            var assignedType = symbol.assignedType();
                            if (assignedType && assignedType.isContainer() && assignedType.getInstanceType()) {
                                return true;
                            }

                            var decls = symbol.getDeclarations();
                            var ast = decls[0].ast();
                            return ast.moduleReference.kind() === 246 /* ExternalModuleReference */;
                        }
                    }
                }

                return false;
            };

            var tryFindAlias = function (decl) {
                var childDecls = decl.searchChildDecls(symbolName, 128 /* TypeAlias */);

                if (childDecls.length) {
                    var sym = childDecls[0].getSymbol(_this.semanticInfoChain);
                    if (isAcceptableAlias(sym)) {
                        return sym;
                    }
                }
                return null;
            };

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                if (decl.flags & 2097152 /* DeclaredInAWithBlock */) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }

                var inClassOrInterface = TypeScript.hasFlag(pathDeclKind, 8 /* Class */ | 16 /* Interface */);
                if (inClassOrInterface && TypeScript.hasFlag(declSearchKind, 68147712 /* SomeValue */)) {
                    continue;
                }

                if (pathDeclKind & allowedContainerDeclKind) {
                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol(this.semanticInfoChain);
                    }

                    var alias = tryFindAlias(decl);
                    if (alias) {
                        return alias;
                    }

                    if (declSearchKind & 68147712 /* SomeValue */) {
                        instanceSymbol = decl.getSymbol(this.semanticInfoChain).getInstanceSymbol();

                        if (instanceSymbol) {
                            instanceType = instanceSymbol.type;

                            childSymbol = this.getNamedPropertySymbol(symbolName, declSearchKind, instanceType);

                            if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.anyDeclHasFlag(16 /* Static */)) {
                                return childSymbol;
                            }
                        }

                        valDecl = decl.getValueDecl();

                        if (valDecl) {
                            decl = valDecl;
                        }
                    }

                    declSymbol = decl.getSymbol(this.semanticInfoChain).type;

                    var childSymbol = this.getNamedPropertySymbol(symbolName, declSearchKind, declSymbol);

                    if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.anyDeclHasFlag(16 /* Static */)) {
                        return childSymbol;
                    }
                } else {
                    var candidateSymbol = null;

                    if (pathDeclKind === 131072 /* FunctionExpression */ && symbolName === decl.getFunctionExpressionName()) {
                        candidateSymbol = decl.getSymbol(this.semanticInfoChain);
                    }

                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        if (decl.kind & 1032192 /* SomeFunction */) {
                            decl.ensureSymbolIsBound(this.semanticInfoChain);
                        }
                        return childDecls[0].getSymbol(this.semanticInfoChain);
                    }

                    if (candidateSymbol) {
                        return candidateSymbol;
                    }

                    var alias = tryFindAlias(decl);
                    if (alias) {
                        return alias;
                    }
                }
            }

            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);
            if (symbol) {
                return symbol;
            }

            if (!TypeScript.hasFlag(declSearchKind, 128 /* TypeAlias */)) {
                symbol = this.semanticInfoChain.findSymbol([symbolName], 128 /* TypeAlias */);
                if (symbol && isAcceptableAlias(symbol)) {
                    return symbol;
                }
            }

            return null;
        };

        PullTypeResolver.prototype.getVisibleDeclsFromDeclPath = function (declPath, declSearchKind) {
            var result = [];
            var decl = null;
            var childDecls;
            var pathDeclKind;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                var declKind = decl.kind;

                if (declKind !== 8 /* Class */ && declKind !== 16 /* Interface */) {
                    this.addFilteredDecls(decl.getChildDecls(), declSearchKind, result);
                }

                switch (declKind) {
                    case 4 /* Container */:
                    case 32 /* DynamicModule */:
                        var otherDecls = this.semanticInfoChain.findDeclsFromPath(declPath.slice(0, i + 1), 164 /* SomeContainer */);
                        for (var j = 0, m = otherDecls.length; j < m; j++) {
                            var otherDecl = otherDecls[j];
                            if (otherDecl === decl) {
                                continue;
                            }

                            var otherDeclChildren = otherDecl.getChildDecls();
                            for (var k = 0, s = otherDeclChildren.length; k < s; k++) {
                                var otherDeclChild = otherDeclChildren[k];
                                if ((otherDeclChild.flags & 1 /* Exported */) && (otherDeclChild.kind & declSearchKind)) {
                                    result.push(otherDeclChild);
                                }
                            }
                        }

                        break;

                    case 8 /* Class */:
                    case 16 /* Interface */:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;

                    case 131072 /* FunctionExpression */:
                        var functionExpressionName = decl.getFunctionExpressionName();
                        if (functionExpressionName) {
                            result.push(decl);
                        }

                    case 16384 /* Function */:
                    case 32768 /* ConstructorMethod */:
                    case 65536 /* Method */:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;
                }
            }

            var topLevelDecls = this.semanticInfoChain.topLevelDecls();
            for (var i = 0, n = topLevelDecls.length; i < n; i++) {
                var topLevelDecl = topLevelDecls[i];
                if (declPath.length > 0 && topLevelDecl.fileName() === declPath[0].fileName()) {
                    continue;
                }

                if (!topLevelDecl.isExternalModule()) {
                    this.addFilteredDecls(topLevelDecl.getChildDecls(), declSearchKind, result);
                }
            }

            return result;
        };

        PullTypeResolver.prototype.addFilteredDecls = function (decls, declSearchKind, result) {
            if (decls.length) {
                for (var i = 0, n = decls.length; i < n; i++) {
                    var decl = decls[i];
                    if (decl.kind & declSearchKind) {
                        result.push(decl);
                    }
                }
            }
        };

        PullTypeResolver.prototype.getVisibleDecls = function (enclosingDecl) {
            var declPath = enclosingDecl.getParentPath();

            var declSearchKind = 58728795 /* SomeType */ | 164 /* SomeContainer */ | 68147712 /* SomeValue */;

            return this.getVisibleDeclsFromDeclPath(declPath, declSearchKind);
        };

        PullTypeResolver.prototype.getVisibleContextSymbols = function (enclosingDecl, context) {
            var contextualTypeSymbol = context.getContextualType();
            if (!contextualTypeSymbol || this.isAnyOrEquivalent(contextualTypeSymbol)) {
                return null;
            }

            var declSearchKind = 58728795 /* SomeType */ | 164 /* SomeContainer */ | 68147712 /* SomeValue */;
            var members = contextualTypeSymbol.getAllMembers(declSearchKind, 2 /* externallyVisible */);

            for (var i = 0; i < members.length; i++) {
                members[i].setUnresolved();
            }

            return members;
        };

        PullTypeResolver.prototype.getVisibleMembersFromExpression = function (expression, enclosingDecl, context) {
            var lhs = this.resolveAST(expression, false, context);

            if (isTypesOnlyLocation(expression) && (lhs.kind === 8 /* Class */ || lhs.kind === 16 /* Interface */ || lhs.kind === 64 /* Enum */)) {
                return null;
            }

            var lhsType = lhs.type;
            if (!lhsType) {
                return null;
            }

            this.resolveDeclaredSymbol(lhsType, context);

            if (lhsType.isContainer() && lhsType.isAlias()) {
                lhsType = lhsType.getExportAssignedTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return null;
            }

            var memberVisibilty = 2 /* externallyVisible */;
            var containerSymbol = lhsType;
            if (containerSymbol.kind === 33554432 /* ConstructorType */) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].returnType;
            }

            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = enclosingDecl.getParentPath();
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (TypeScript.ArrayUtilities.contains(declPath, declaration)) {
                            memberVisibilty = 1 /* internallyVisible */;
                            break;
                        }
                    }
                }
            }

            var declSearchKind = 58728795 /* SomeType */ | 164 /* SomeContainer */ | 68147712 /* SomeValue */;

            var members = [];

            if (lhsType.isContainer()) {
                var exportedAssignedContainerSymbol = lhsType.getExportAssignedContainerSymbol();
                if (exportedAssignedContainerSymbol) {
                    lhsType = exportedAssignedContainerSymbol;
                }
            }

            lhsType = this.getApparentType(lhsType);

            if (!lhsType.isResolved) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, context);

                if (potentiallySpecializedType !== lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            members = lhsType.getAllMembers(declSearchKind, memberVisibilty);

            if (lhsType.isContainer()) {
                var associatedInstance = lhsType.getInstanceSymbol();
                if (associatedInstance) {
                    var instanceType = associatedInstance.type;
                    this.resolveDeclaredSymbol(instanceType, context);
                    var instanceMembers = instanceType.getAllMembers(declSearchKind, memberVisibilty);
                    members = members.concat(instanceMembers);
                }

                var exportedContainer = lhsType.getExportAssignedContainerSymbol();
                if (exportedContainer) {
                    var exportedContainerMembers = exportedContainer.getAllMembers(declSearchKind, memberVisibilty);
                    members = members.concat(exportedContainerMembers);
                }
            } else if (!lhsType.isConstructor() && !lhsType.isEnum()) {
                var associatedContainerSymbol = lhsType.getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    var containerType = associatedContainerSymbol.type;
                    this.resolveDeclaredSymbol(containerType, context);
                    var containerMembers = containerType.getAllMembers(declSearchKind, memberVisibilty);
                    members = members.concat(containerMembers);
                }
            }

            if (lhsType.isFunctionType() && this.cachedFunctionInterfaceType()) {
                members = members.concat(this.cachedFunctionInterfaceType().getAllMembers(declSearchKind, 2 /* externallyVisible */));
            }

            return members;
        };

        PullTypeResolver.prototype.isAnyOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.anyTypeSymbol) || type.isError();
        };

        PullTypeResolver.prototype.resolveExternalModuleReference = function (idText, currentFileName) {
            var originalIdText = idText;
            var symbol = null;

            if (TypeScript.isRelative(originalIdText)) {
                var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));
                symbol = this.semanticInfoChain.findExternalModule(path + idText);
            } else {
                idText = originalIdText;

                symbol = this.semanticInfoChain.findAmbientExternalModuleInGlobalContext(TypeScript.quoteStr(originalIdText));

                if (!symbol) {
                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));

                    while (symbol === null && path != "") {
                        symbol = this.semanticInfoChain.findExternalModule(path + idText);
                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            } else {
                                path = TypeScript.normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.resolveDeclaredSymbol = function (symbol, context) {
            if (!symbol || symbol.isResolved || symbol.isTypeReference()) {
                return symbol;
            }

            if (!context) {
                context = new TypeScript.PullTypeResolutionContext(this);
            }

            return this.resolveDeclaredSymbolWorker(symbol, context);
        };

        PullTypeResolver.prototype.resolveDeclaredSymbolWorker = function (symbol, context) {
            if (!symbol || symbol.isResolved) {
                return symbol;
            }

            if (symbol.inResolution) {
                if (!symbol.type && !symbol.isType()) {
                    symbol.type = this.semanticInfoChain.anyTypeSymbol;
                }

                return symbol;
            }

            var decls = symbol.getDeclarations();

            for (var i = 0; i < decls.length; i++) {
                var decl = decls[i];

                var ast = this.semanticInfoChain.getASTForDecl(decl);

                if (!ast || (ast.kind() === 140 /* GetAccessor */ && ast.parent.parent.kind() === 216 /* ObjectLiteralExpression */) || (ast.kind() === 141 /* SetAccessor */ && ast.parent.parent.kind() === 216 /* ObjectLiteralExpression */)) {
                    return symbol;
                }

                if (ast.parent && ast.parent.kind() === 237 /* CatchClause */ && ast.parent.identifier === ast) {
                    return symbol;
                }

                if (ast.parent && ast.parent.kind() === 220 /* SimpleArrowFunctionExpression */ && ast.parent.parameter === ast) {
                    return symbol;
                }

                var enclosingModule = TypeScript.ASTHelpers.getModuleDeclarationFromNameAST(ast);
                var resolvedSymbol;
                if (enclosingModule) {
                    resolvedSymbol = this.resolveSingleModuleDeclaration(enclosingModule, ast, context);
                } else if (ast.kind() === 120 /* SourceUnit */ && decl.kind === 32 /* DynamicModule */) {
                    resolvedSymbol = this.resolveModuleSymbol(decl.getSymbol(this.semanticInfoChain), context, null, null, ast);
                } else {
                    TypeScript.Debug.assert(ast.kind() !== 11 /* IdentifierName */ && ast.kind() !== 213 /* MemberAccessExpression */);
                    resolvedSymbol = this.resolveAST(ast, false, context);
                }

                if (decl.kind === 2048 /* Parameter */ && !symbol.isResolved && !symbol.type && resolvedSymbol && symbol.anyDeclHasFlag(8388608 /* PropertyParameter */ | 67108864 /* ConstructorParameter */)) {
                    symbol.type = resolvedSymbol.type;
                    symbol.setResolved();
                }
            }

            if (!symbol.isResolved) {
                TypeScript.Debug.assert(!symbol.inResolution);

                symbol.setResolved();
            }

            return symbol;
        };

        PullTypeResolver.prototype.resolveOtherDecl = function (otherDecl, context) {
            var astForOtherDecl = this.getASTForDecl(otherDecl);
            var moduleDecl = TypeScript.ASTHelpers.getModuleDeclarationFromNameAST(astForOtherDecl);
            if (moduleDecl) {
                this.resolveSingleModuleDeclaration(moduleDecl, astForOtherDecl, context);
            } else {
                this.resolveAST(astForOtherDecl, false, context);
            }
        };

        PullTypeResolver.prototype.resolveOtherDeclarations = function (astName, context) {
            var _this = this;
            var resolvedDecl = this.semanticInfoChain.getDeclForAST(astName);
            var symbol = resolvedDecl.getSymbol(this.semanticInfoChain);

            var allDecls = symbol.getDeclarations();
            this.inResolvingOtherDeclsWalker.walkOtherPullDecls(resolvedDecl, symbol.getDeclarations(), function (otherDecl) {
                return _this.resolveOtherDecl(otherDecl, context);
            });
        };

        PullTypeResolver.prototype.resolveSourceUnit = function (sourceUnit, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(sourceUnit);
            var moduleSymbol = enclosingDecl.getSymbol(this.semanticInfoChain);
            this.ensureAllSymbolsAreBound(moduleSymbol);

            this.resolveFirstExportAssignmentStatement(sourceUnit.moduleElements, context);
            this.resolveAST(sourceUnit.moduleElements, false, context);

            if (this.canTypeCheckAST(sourceUnit, context)) {
                this.typeCheckSourceUnit(sourceUnit, context);
            }

            return moduleSymbol;
        };

        PullTypeResolver.prototype.typeCheckSourceUnit = function (sourceUnit, context) {
            var _this = this;
            this.setTypeChecked(sourceUnit, context);
            this.checkForDisallowedExports(sourceUnit.moduleElements);
            this.checkForMultipleExportAssignments(sourceUnit.moduleElements);
            this.checkFunctionOverloadChains(sourceUnit, sourceUnit.moduleElements);

            this.resolveAST(sourceUnit.moduleElements, false, context);

            this.typeCheckCallBacks.push(function (context) {
                return _this.verifyUniquenessOfImportNamesInSourceUnit(sourceUnit);
            });
        };

        PullTypeResolver.prototype.verifyUniquenessOfImportNamesInSourceUnit = function (sourceUnit) {
            var _this = this;
            var enclosingDecl = this.semanticInfoChain.getDeclForAST(sourceUnit);

            var doesImportNameExistInOtherFiles = function (name) {
                var importSymbol = _this.semanticInfoChain.findTopLevelSymbol(name, 128 /* TypeAlias */, null);
                return importSymbol && importSymbol.isAlias();
            };

            this.checkUniquenessOfImportNames([enclosingDecl], doesImportNameExistInOtherFiles);
        };

        PullTypeResolver.prototype.resolveEnumDeclaration = function (ast, context) {
            var containerDecl = this.semanticInfoChain.getDeclForAST(ast);
            var containerSymbol = containerDecl.getSymbol(this.semanticInfoChain);

            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }

            containerSymbol.inResolution = true;

            var containerDecls = containerSymbol.getDeclarations();

            for (var i = 0; i < containerDecls.length; i++) {
                var childDecls = containerDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                }
            }

            containerSymbol.setResolved();

            this.resolveOtherDeclarations(ast, context);

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckEnumDeclaration(ast, context);
            }

            return containerSymbol;
        };

        PullTypeResolver.prototype.typeCheckEnumDeclaration = function (ast, context) {
            var _this = this;
            this.setTypeChecked(ast, context);

            this.checkForReservedName(ast, ast.identifier, TypeScript.DiagnosticCode.Enum_name_cannot_be_0);

            this.resolveAST(ast.enumElements, false, context);
            var containerDecl = this.semanticInfoChain.getDeclForAST(ast);
            this.validateVariableDeclarationGroups(containerDecl, context);

            this.typeCheckCallBacks.push(function (context) {
                return _this.checkInitializersInEnumDeclarations(containerDecl, context);
            });

            if (!TypeScript.ASTHelpers.enumIsElided(ast)) {
                this.checkNameForCompilerGeneratedDeclarationCollision(ast, true, ast.identifier, context);
            }
        };

        PullTypeResolver.prototype.postTypeCheckEnumDeclaration = function (ast, context) {
            this.checkThisCaptureVariableCollides(ast, true, context);
        };

        PullTypeResolver.prototype.checkInitializersInEnumDeclarations = function (decl, context) {
            var symbol = decl.getSymbol(this.semanticInfoChain);

            var declarations = symbol.getDeclarations();
            if (decl !== declarations[0]) {
                return;
            }

            var seenEnumDeclWithNoFirstMember = false;
            for (var i = 0; i < declarations.length; ++i) {
                var currentDecl = declarations[i];

                var ast = currentDecl.ast();
                if (ast.enumElements.length === 0) {
                    continue;
                }

                var firstVariable = ast.enumElements[0];
                if (!firstVariable.equalsValueClause) {
                    if (!seenEnumDeclWithNoFirstMember) {
                        seenEnumDeclWithNoFirstMember = true;
                    } else {
                        this.semanticInfoChain.addDiagnosticFromAST(firstVariable, TypeScript.DiagnosticCode.In_enums_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_the_first_enum_element);
                    }
                }
            }
        };

        PullTypeResolver.prototype.resolveModuleDeclaration = function (ast, context) {
            var result;

            if (ast.stringLiteral) {
                result = this.resolveSingleModuleDeclaration(ast, ast.stringLiteral, context);
            } else {
                var moduleNames = TypeScript.ASTHelpers.getModuleNames(ast.name);
                for (var i = 0, n = moduleNames.length; i < n; i++) {
                    result = this.resolveSingleModuleDeclaration(ast, moduleNames[i], context);
                }
            }

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckModuleDeclaration(ast, context);
            }

            return result;
        };

        PullTypeResolver.prototype.ensureAllSymbolsAreBound = function (containerSymbol) {
            if (containerSymbol) {
                var containerDecls = containerSymbol.getDeclarations();

                for (var i = 0; i < containerDecls.length; i++) {
                    var childDecls = containerDecls[i].getChildDecls();

                    for (var j = 0; j < childDecls.length; j++) {
                        childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                    }
                }
            }
        };

        PullTypeResolver.prototype.resolveModuleSymbol = function (containerSymbol, context, moduleDeclAST, moduleDeclNameAST, sourceUnitAST) {
            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }

            containerSymbol.inResolution = true;
            this.ensureAllSymbolsAreBound(containerSymbol);

            var instanceSymbol = containerSymbol.getInstanceSymbol();

            if (instanceSymbol) {
                this.resolveDeclaredSymbol(instanceSymbol, context);
            }

            var isLastName = TypeScript.ASTHelpers.isLastNameOfModule(moduleDeclAST, moduleDeclNameAST);
            if (isLastName) {
                this.resolveFirstExportAssignmentStatement(moduleDeclAST.moduleElements, context);
            } else if (sourceUnitAST) {
                this.resolveFirstExportAssignmentStatement(sourceUnitAST.moduleElements, context);
            }

            containerSymbol.setResolved();

            if (moduleDeclNameAST) {
                this.resolveOtherDeclarations(moduleDeclNameAST, context);
            }

            return containerSymbol;
        };

        PullTypeResolver.prototype.resolveFirstExportAssignmentStatement = function (moduleElements, context) {
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var moduleElement = moduleElements[i];
                if (moduleElement.kind() === 135 /* ExportAssignment */) {
                    this.resolveExportAssignmentStatement(moduleElement, context);
                    return;
                }
            }
        };

        PullTypeResolver.prototype.resolveSingleModuleDeclaration = function (ast, astName, context) {
            var containerDecl = this.semanticInfoChain.getDeclForAST(astName);
            var containerSymbol = containerDecl.getSymbol(this.semanticInfoChain);

            return this.resolveModuleSymbol(containerSymbol, context, ast, astName, null);
        };

        PullTypeResolver.prototype.typeCheckModuleDeclaration = function (ast, context) {
            this.checkForDisallowedExports(ast.moduleElements);
            this.checkForMultipleExportAssignments(ast.moduleElements);

            if (ast.stringLiteral) {
                this.typeCheckSingleModuleDeclaration(ast, ast.stringLiteral, context);
            } else {
                if (!TypeScript.SyntaxUtilities.containsToken(ast.modifiers, 63 /* DeclareKeyword */)) {
                    this.checkFunctionOverloadChains(ast, ast.moduleElements);
                }

                var moduleNames = TypeScript.ASTHelpers.getModuleNames(ast.name);
                for (var i = 0, n = moduleNames.length; i < n; i++) {
                    this.typeCheckSingleModuleDeclaration(ast, moduleNames[i], context);
                }
            }
        };

        PullTypeResolver.prototype.typeCheckSingleModuleDeclaration = function (ast, astName, context) {
            var _this = this;
            this.setTypeChecked(ast, context);

            if (TypeScript.ASTHelpers.isLastNameOfModule(ast, astName)) {
                this.resolveAST(ast.moduleElements, false, context);
            }

            var containerDecl = this.semanticInfoChain.getDeclForAST(astName);
            this.validateVariableDeclarationGroups(containerDecl, context);

            if (ast.stringLiteral) {
                if (TypeScript.isRelative(TypeScript.tokenValueText(ast.stringLiteral))) {
                    this.semanticInfoChain.addDiagnosticFromAST(ast.stringLiteral, TypeScript.DiagnosticCode.Ambient_external_module_declaration_cannot_specify_relative_module_name);
                }
            }

            if (!TypeScript.ASTHelpers.moduleIsElided(ast) && !ast.stringLiteral) {
                this.checkNameForCompilerGeneratedDeclarationCollision(astName, true, astName, context);
            }

            this.typeCheckCallBacks.push(function (context) {
                return _this.verifyUniquenessOfImportNamesInModule(containerDecl);
            });
        };

        PullTypeResolver.prototype.verifyUniquenessOfImportNamesInModule = function (decl) {
            var symbol = decl.getSymbol(this.semanticInfoChain);
            if (!symbol) {
                return;
            }

            var decls = symbol.getDeclarations();

            if (decls[0] !== decl) {
                return;
            }

            this.checkUniquenessOfImportNames(decls);
        };

        PullTypeResolver.prototype.checkUniquenessOfImportNames = function (decls, doesNameExistOutside) {
            var _this = this;
            var importDeclarationNames;

            for (var i = 0; i < decls.length; ++i) {
                var childDecls = decls[i].getChildDecls();
                for (var j = 0; j < childDecls.length; ++j) {
                    var childDecl = childDecls[j];
                    if (childDecl.kind === 128 /* TypeAlias */) {
                        importDeclarationNames = importDeclarationNames || TypeScript.createIntrinsicsObject();
                        importDeclarationNames[childDecl.name] = true;
                    }
                }
            }

            if (!importDeclarationNames && !doesNameExistOutside) {
                return;
            }

            for (var i = 0; i < decls.length; ++i) {
                this.scanVariableDeclarationGroups(decls[i], function (firstDeclInGroup) {
                    var nameConflict = importDeclarationNames && importDeclarationNames[firstDeclInGroup.name];
                    if (!nameConflict) {
                        nameConflict = doesNameExistOutside && doesNameExistOutside(firstDeclInGroup.name);
                        if (nameConflict) {
                            importDeclarationNames = importDeclarationNames || TypeScript.createIntrinsicsObject();
                            importDeclarationNames[firstDeclInGroup.name] = true;
                        }
                    }

                    if (nameConflict) {
                        _this.semanticInfoChain.addDiagnosticFromAST(firstDeclInGroup.ast(), TypeScript.DiagnosticCode.Variable_declaration_cannot_have_the_same_name_as_an_import_declaration);
                    }
                });
            }
        };

        PullTypeResolver.prototype.scanVariableDeclarationGroups = function (enclosingDecl, firstDeclHandler, subsequentDeclHandler) {
            var declGroups = enclosingDecl.getVariableDeclGroups();

            for (var i = 0; i < declGroups.length; i++) {
                var firstSymbol = null;
                var enclosingDeclForFirstSymbol = null;

                if (enclosingDecl.kind === 1 /* Script */ && declGroups[i].length) {
                    var name = declGroups[i][0].name;
                    var candidateSymbol = this.semanticInfoChain.findTopLevelSymbol(name, 512 /* Variable */, enclosingDecl);
                    if (candidateSymbol) {
                        if (!candidateSymbol.anyDeclHasFlag(118784 /* ImplicitVariable */)) {
                            if (!candidateSymbol.isResolved) {
                                this.resolveDeclaredSymbol(candidateSymbol);
                            }
                            firstSymbol = candidateSymbol;
                        }
                    }
                }

                for (var j = 0; j < declGroups[i].length; j++) {
                    var decl = declGroups[i][j];

                    var name = decl.name;

                    var symbol = decl.getSymbol(this.semanticInfoChain);

                    if (j === 0) {
                        firstDeclHandler(decl);
                        if (!subsequentDeclHandler) {
                            break;
                        }

                        if (!firstSymbol || !firstSymbol.type) {
                            firstSymbol = symbol;
                            continue;
                        }
                    }

                    subsequentDeclHandler(decl, firstSymbol);
                }
            }
        };

        PullTypeResolver.prototype.postTypeCheckModuleDeclaration = function (ast, context) {
            this.checkThisCaptureVariableCollides(ast, true, context);
        };

        PullTypeResolver.prototype.isTypeRefWithoutTypeArgs = function (term) {
            if (term.kind() === 11 /* IdentifierName */) {
                return true;
            } else if (term.kind() === 121 /* QualifiedName */) {
                var binex = term;

                if (binex.right.kind() === 11 /* IdentifierName */) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.createInstantiatedType = function (type, typeArguments) {
            if (!type.isGeneric()) {
                return type;
            }

            var typeParameters = type.getTypeArgumentsOrTypeParameters();

            var typeParameterArgumentMap = [];

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterArgumentMap[typeParameters[i].pullSymbolID] = typeArguments[i] || new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, typeParameters[i].name, this.semanticInfoChain);
            }

            return TypeScript.InstantiatedTypeReferenceSymbol.create(this, type, typeParameterArgumentMap);
        };

        PullTypeResolver.prototype.resolveReferenceTypeDeclaration = function (classOrInterface, name, heritageClauses, context) {
            var _this = this;
            var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(typeDecl);
            var typeDeclSymbol = typeDecl.getSymbol(this.semanticInfoChain);
            var typeDeclIsClass = classOrInterface.kind() === 132 /* ClassDeclaration */;
            var hasVisited = this.getSymbolForAST(classOrInterface, context) !== null;

            if ((typeDeclSymbol.isResolved && hasVisited) || (typeDeclSymbol.inResolution && !context.isInBaseTypeResolution())) {
                return typeDeclSymbol;
            }

            var wasResolving = typeDeclSymbol.inResolution;
            typeDeclSymbol.startResolving();

            var typeRefDecls = typeDeclSymbol.getDeclarations();

            for (var i = 0; i < typeRefDecls.length; i++) {
                var childDecls = typeRefDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                }
            }

            if (!typeDeclSymbol.isResolved) {
                var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
                for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclTypeParameters[i], context);
                }
            }

            var wasInBaseTypeResolution = context.startBaseTypeResolution();

            if (!typeDeclIsClass && !hasVisited) {
                typeDeclSymbol.resetKnownBaseTypeCount();
            }

            var extendsClause = TypeScript.ASTHelpers.getExtendsHeritageClause(heritageClauses);
            if (extendsClause) {
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); i < extendsClause.typeNames.length; i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var parentType = this.resolveTypeReference(extendsClause.typeNames[i], context);

                    if (typeDeclSymbol.isValidBaseKind(parentType, true)) {
                        this.setSymbolForAST(extendsClause.typeNames[i], parentType, null);

                        if (!typeDeclSymbol.hasBase(parentType) && !parentType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addExtendedType(parentType);

                            var specializations = typeDeclSymbol.getKnownSpecializations();

                            for (var j = 0; j < specializations.length; j++) {
                                specializations[j].addExtendedType(parentType);
                            }
                        }
                    } else if (parentType && !this.getSymbolForAST(extendsClause.typeNames[i], context)) {
                        this.setSymbolForAST(extendsClause.typeNames[i], parentType, null);
                    }
                }
            }

            var implementsClause = TypeScript.ASTHelpers.getImplementsHeritageClause(heritageClauses);
            if (implementsClause && typeDeclIsClass) {
                var extendsCount = extendsClause ? extendsClause.typeNames.length : 0;
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); ((i - extendsCount) >= 0) && ((i - extendsCount) < implementsClause.typeNames.length); i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var implementedTypeAST = implementsClause.typeNames[i - extendsCount];
                    var implementedType = this.resolveTypeReference(implementedTypeAST, context);

                    if (typeDeclSymbol.isValidBaseKind(implementedType, false)) {
                        this.setSymbolForAST(implementsClause.typeNames[i - extendsCount], implementedType, null);

                        if (!typeDeclSymbol.hasBase(implementedType) && !implementedType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addImplementedType(implementedType);
                        }
                    } else if (implementedType && !this.getSymbolForAST(implementsClause.typeNames[i - extendsCount], context)) {
                        this.setSymbolForAST(implementsClause.typeNames[i - extendsCount], implementedType, null);
                    }
                }
            }

            context.doneBaseTypeResolution(wasInBaseTypeResolution);

            if (wasInBaseTypeResolution) {
                typeDeclSymbol.inResolution = false;

                this.typeCheckCallBacks.push(function (context) {
                    if (classOrInterface.kind() === 132 /* ClassDeclaration */) {
                        _this.resolveClassDeclaration(classOrInterface, context);
                    } else {
                        _this.resolveInterfaceDeclaration(classOrInterface, context);
                    }
                });

                return typeDeclSymbol;
            }

            this.setSymbolForAST(name, typeDeclSymbol, context);
            this.setSymbolForAST(classOrInterface, typeDeclSymbol, context);

            typeDeclSymbol.setResolved();

            return typeDeclSymbol;
        };

        PullTypeResolver.prototype.resolveClassDeclaration = function (classDeclAST, context) {
            var classDecl = this.semanticInfoChain.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol(this.semanticInfoChain);

            if (!classDeclSymbol.isResolved) {
                this.resolveReferenceTypeDeclaration(classDeclAST, classDeclAST.identifier, classDeclAST.heritageClauses, context);

                var constructorMethod = classDeclSymbol.getConstructorMethod();
                var extendedTypes = classDeclSymbol.getExtendedTypes();
                var parentType = extendedTypes.length ? extendedTypes[0] : null;

                if (constructorMethod) {
                    if (parentType) {
                        var parentConstructorSymbol = parentType.getConstructorMethod();

                        if (parentConstructorSymbol) {
                            var parentConstructorTypeSymbol = parentConstructorSymbol.type;
                            var constructorTypeSymbol = constructorMethod.type;
                            if (!constructorTypeSymbol.hasBase(parentConstructorTypeSymbol)) {
                                constructorTypeSymbol.addExtendedType(parentConstructorTypeSymbol);
                            }
                        }
                    }

                    if (!classDeclSymbol.isResolved) {
                        return classDeclSymbol;
                    }
                }

                this.resolveOtherDeclarations(classDeclAST, context);
            }

            if (this.canTypeCheckAST(classDeclAST, context)) {
                this.typeCheckClassDeclaration(classDeclAST, context);
            }

            return classDeclSymbol;
        };

        PullTypeResolver.prototype.typeCheckTypeParametersOfTypeDeclaration = function (classOrInterface, context) {
            var _this = this;
            var typeParametersList = classOrInterface.kind() == 132 /* ClassDeclaration */ ? classOrInterface.typeParameterList : classOrInterface.typeParameterList;

            if (typeParametersList) {
                var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);
                var typeDeclSymbol = typeDecl.getSymbol(this.semanticInfoChain);

                for (var i = 0; i < typeParametersList.typeParameters.length; i++) {
                    var typeParameterAST = typeParametersList.typeParameters[i];
                    this.resolveTypeParameterDeclaration(typeParameterAST, context);

                    var typeParameterDecl = this.semanticInfoChain.getDeclForAST(typeParameterAST);
                    var typeParameterSymbol = typeParameterDecl.getSymbol(this.semanticInfoChain);

                    this.checkSymbolPrivacy(typeDeclSymbol, typeParameterSymbol, function (symbol) {
                        return _this.typeParameterOfTypeDeclarationPrivacyErrorReporter(classOrInterface, typeParameterAST, typeParameterSymbol, symbol, context);
                    });
                }
            }
        };

        PullTypeResolver.prototype.typeCheckClassDeclaration = function (classDeclAST, context) {
            this.setTypeChecked(classDeclAST, context);

            this.checkForReservedName(classDeclAST, classDeclAST.identifier, TypeScript.DiagnosticCode.Class_name_cannot_be_0);
            this.checkClassOverloadChains(classDeclAST);

            var classDecl = this.semanticInfoChain.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol(this.semanticInfoChain);

            this.checkNameForCompilerGeneratedDeclarationCollision(classDeclAST, true, classDeclAST.identifier, context);
            this.resolveAST(classDeclAST.classElements, false, context);

            this.typeCheckTypeParametersOfTypeDeclaration(classDeclAST, context);
            this.typeCheckBases(classDeclAST, classDeclAST.identifier, classDeclAST.heritageClauses, classDeclSymbol, this.getEnclosingDecl(classDecl), context);

            if (!classDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(classDeclSymbol, classDecl, context);
            }

            this.checkTypeForDuplicateIndexSignatures(classDeclSymbol);
        };

        PullTypeResolver.prototype.postTypeCheckClassDeclaration = function (classDeclAST, context) {
            this.checkThisCaptureVariableCollides(classDeclAST, true, context);
        };

        PullTypeResolver.prototype.resolveTypeSymbolSignatures = function (typeSymbol, context) {
            var callSignatures = typeSymbol.getCallSignatures();
            for (var i = 0; i < callSignatures.length; i++) {
                this.resolveDeclaredSymbol(callSignatures[i], context);
            }

            var constructSignatures = typeSymbol.getConstructSignatures();
            for (var i = 0; i < constructSignatures.length; i++) {
                this.resolveDeclaredSymbol(constructSignatures[i], context);
            }

            var indexSignatures = typeSymbol.getIndexSignatures();
            for (var i = 0; i < indexSignatures.length; i++) {
                this.resolveDeclaredSymbol(indexSignatures[i], context);
            }
        };

        PullTypeResolver.prototype.resolveInterfaceDeclaration = function (interfaceDeclAST, context) {
            this.resolveReferenceTypeDeclaration(interfaceDeclAST, interfaceDeclAST.identifier, interfaceDeclAST.heritageClauses, context);

            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol(this.semanticInfoChain);

            this.resolveTypeSymbolSignatures(interfaceDeclSymbol, context);

            if (interfaceDeclSymbol.isResolved) {
                this.resolveOtherDeclarations(interfaceDeclAST, context);

                if (this.canTypeCheckAST(interfaceDeclAST, context)) {
                    this.typeCheckInterfaceDeclaration(interfaceDeclAST, context);
                }
            }

            return interfaceDeclSymbol;
        };

        PullTypeResolver.prototype.typeCheckInterfaceDeclaration = function (interfaceDeclAST, context) {
            this.setTypeChecked(interfaceDeclAST, context);

            this.checkForReservedName(interfaceDeclAST, interfaceDeclAST.identifier, TypeScript.DiagnosticCode.Interface_name_cannot_be_0);

            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol(this.semanticInfoChain);

            this.resolveAST(interfaceDeclAST.body.typeMembers, false, context);

            this.typeCheckTypeParametersOfTypeDeclaration(interfaceDeclAST, context);
            this.typeCheckBases(interfaceDeclAST, interfaceDeclAST.identifier, interfaceDeclAST.heritageClauses, interfaceDeclSymbol, this.getEnclosingDecl(interfaceDecl), context);

            if (!interfaceDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(interfaceDeclSymbol, interfaceDecl, context);
            }

            var allInterfaceDecls = interfaceDeclSymbol.getDeclarations();
            if (interfaceDecl === allInterfaceDecls[allInterfaceDecls.length - 1]) {
                this.checkTypeForDuplicateIndexSignatures(interfaceDeclSymbol);
            }

            if (!this.checkInterfaceDeclForIdenticalTypeParameters(interfaceDeclAST, context)) {
                this.semanticInfoChain.addDiagnosticFromAST(interfaceDeclAST.identifier, TypeScript.DiagnosticCode.All_declarations_of_an_interface_must_have_identical_type_parameters);
            }
        };

        PullTypeResolver.prototype.checkInterfaceDeclForIdenticalTypeParameters = function (interfaceDeclAST, context) {
            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol(this.semanticInfoChain);

            if (!interfaceDeclSymbol.isGeneric()) {
                return true;
            }

            var firstInterfaceDecl = interfaceDeclSymbol.getDeclarations()[0];
            if (firstInterfaceDecl == interfaceDecl) {
                return true;
            }

            var typeParameters = interfaceDecl.getTypeParameters();
            var firstInterfaceDeclTypeParameters = firstInterfaceDecl.getTypeParameters();

            if (typeParameters.length != firstInterfaceDeclTypeParameters.length) {
                return false;
            }

            for (var i = 0; i < typeParameters.length; i++) {
                var typeParameter = typeParameters[i];
                var firstInterfaceDeclTypeParameter = firstInterfaceDeclTypeParameters[i];

                if (typeParameter.name != firstInterfaceDeclTypeParameter.name) {
                    return false;
                }

                var typeParameterSymbol = typeParameter.getSymbol(this.semanticInfoChain);
                var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter);
                var firstInterfaceDeclTypeParameterAST = this.semanticInfoChain.getASTForDecl(firstInterfaceDeclTypeParameter);

                if (!!typeParameterAST.constraint != !!firstInterfaceDeclTypeParameterAST.constraint) {
                    return false;
                }

                if (typeParameterAST.constraint) {
                    var typeParameterConstraint = this.resolveAST(typeParameterAST.constraint, false, context);
                    if (!this.typesAreIdenticalWithNewEnclosingTypes(typeParameterConstraint, typeParameterSymbol.getConstraint(), context)) {
                        return false;
                    }
                }
            }

            return true;
        };

        PullTypeResolver.prototype.checkTypeForDuplicateIndexSignatures = function (enclosingTypeSymbol) {
            var indexSignatures = enclosingTypeSymbol.getOwnIndexSignatures();
            var firstStringIndexer = null;
            var firstNumberIndexer = null;
            for (var i = 0; i < indexSignatures.length; i++) {
                var currentIndexer = indexSignatures[i];
                if (currentIndexer.parameters.length > 0) {
                    var currentParameterType = currentIndexer.parameters[0].type;
                    TypeScript.Debug.assert(currentParameterType);
                    if (currentParameterType === this.semanticInfoChain.stringTypeSymbol) {
                        if (firstStringIndexer) {
                            this.semanticInfoChain.addDiagnosticFromAST(currentIndexer.getDeclarations()[0].ast(), TypeScript.DiagnosticCode.Duplicate_string_index_signature, null);
                            return;
                        } else {
                            firstStringIndexer = currentIndexer;
                        }
                    } else if (currentParameterType === this.semanticInfoChain.numberTypeSymbol) {
                        if (firstNumberIndexer) {
                            this.semanticInfoChain.addDiagnosticFromAST(currentIndexer.getDeclarations()[0].ast(), TypeScript.DiagnosticCode.Duplicate_number_index_signature, null);
                            return;
                        } else {
                            firstNumberIndexer = currentIndexer;
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.filterSymbol = function (symbol, kind, enclosingDecl, context) {
            if (symbol) {
                if (symbol.kind & kind) {
                    return symbol;
                }

                if (symbol.isAlias()) {
                    this.resolveDeclaredSymbol(symbol, context);

                    var alias = symbol;
                    if (kind & 164 /* SomeContainer */) {
                        return alias.getExportAssignedContainerSymbol();
                    } else if (kind & 58728795 /* SomeType */) {
                        return alias.getExportAssignedTypeSymbol();
                    } else if (kind & 68147712 /* SomeValue */) {
                        return alias.getExportAssignedValueSymbol();
                    }
                }
            }
            return null;
        };

        PullTypeResolver.prototype.getMemberSymbolOfKind = function (symbolName, kind, pullTypeSymbol, enclosingDecl, context) {
            var memberSymbol = this.getNamedPropertySymbol(symbolName, kind, pullTypeSymbol);

            return {
                symbol: this.filterSymbol(memberSymbol, kind, enclosingDecl, context),
                aliasSymbol: memberSymbol && memberSymbol.isAlias() ? memberSymbol : null
            };
        };

        PullTypeResolver.prototype.resolveIdentifierOfInternalModuleReference = function (importDecl, identifier, moduleSymbol, enclosingDecl, context) {
            var rhsName = TypeScript.tokenValueText(identifier);
            if (rhsName.length === 0) {
                return null;
            }

            var moduleTypeSymbol = moduleSymbol.type;
            var memberSymbol = this.getMemberSymbolOfKind(rhsName, 164 /* SomeContainer */, moduleTypeSymbol, enclosingDecl, context);
            var containerSymbol = memberSymbol.symbol;
            var valueSymbol = null;
            var typeSymbol = null;
            var aliasSymbol = null;

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & 59753052 /* AcceptableAlias */) !== 0;
                aliasSymbol = memberSymbol.aliasSymbol;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind === 128 /* TypeAlias */) {
                this.resolveDeclaredSymbol(containerSymbol, context);
                var aliasedAssignedValue = containerSymbol.getExportAssignedValueSymbol();
                var aliasedAssignedType = containerSymbol.getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = containerSymbol.getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    aliasSymbol = containerSymbol;
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    acceptableAlias = true;
                }
            }

            if (!acceptableAlias) {
                this.semanticInfoChain.addDiagnosticFromAST(identifier, TypeScript.DiagnosticCode.Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules);
                return null;
            }

            if (!valueSymbol) {
                if (moduleTypeSymbol.getInstanceSymbol()) {
                    memberSymbol = this.getMemberSymbolOfKind(rhsName, 68147712 /* SomeValue */, moduleTypeSymbol.getInstanceSymbol().type, enclosingDecl, context);
                    valueSymbol = memberSymbol.symbol;
                    if (valueSymbol && memberSymbol.aliasSymbol) {
                        aliasSymbol = memberSymbol.aliasSymbol;
                    }
                }
            }

            if (!typeSymbol) {
                memberSymbol = this.getMemberSymbolOfKind(rhsName, 58728795 /* SomeType */, moduleTypeSymbol, enclosingDecl, context);
                typeSymbol = memberSymbol.symbol;
                if (typeSymbol && memberSymbol.aliasSymbol) {
                    aliasSymbol = memberSymbol.aliasSymbol;
                }
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                this.semanticInfoChain.addDiagnosticFromAST(identifier, TypeScript.DiagnosticCode.Module_0_has_no_exported_member_1, [moduleSymbol.toString(), rhsName]);
                return null;
            }

            if (!typeSymbol && containerSymbol) {
                typeSymbol = containerSymbol;
            }

            return {
                valueSymbol: valueSymbol,
                typeSymbol: typeSymbol,
                containerSymbol: containerSymbol,
                aliasSymbol: aliasSymbol
            };
        };

        PullTypeResolver.prototype.resolveModuleReference = function (importDecl, moduleNameExpr, enclosingDecl, context, declPath) {
            TypeScript.Debug.assert(moduleNameExpr.kind() === 121 /* QualifiedName */ || moduleNameExpr.kind() === 11 /* IdentifierName */ || moduleNameExpr.kind() === 14 /* StringLiteral */, "resolving module reference should always be either name or member reference");

            var moduleSymbol = null;
            var moduleName;

            if (moduleNameExpr.kind() === 121 /* QualifiedName */) {
                var dottedNameAST = moduleNameExpr;

                var moduleContainer = this.resolveModuleReference(importDecl, dottedNameAST.left, enclosingDecl, context, declPath);
                if (moduleContainer) {
                    moduleName = TypeScript.tokenValueText(dottedNameAST.right);

                    moduleSymbol = this.getMemberSymbolOfKind(moduleName, 4 /* Container */, moduleContainer.type, enclosingDecl, context).symbol;
                    if (!moduleSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(dottedNameAST.right, TypeScript.DiagnosticCode.Could_not_find_module_0_in_module_1, [moduleName, moduleContainer.toString()]);
                    }
                }
            } else {
                var valueText = moduleNameExpr.kind() === 11 /* IdentifierName */ ? TypeScript.tokenValueText(moduleNameExpr) : TypeScript.tokenValueText(moduleNameExpr);
                var text = moduleNameExpr.kind() === 11 /* IdentifierName */ ? moduleNameExpr.text() : moduleNameExpr.text();

                if (text.length > 0) {
                    var resolvedModuleNameSymbol = this.getSymbolFromDeclPath(valueText, declPath, 4 /* Container */);
                    moduleSymbol = this.filterSymbol(resolvedModuleNameSymbol, 4 /* Container */, enclosingDecl, context);
                    if (moduleSymbol) {
                        this.semanticInfoChain.setSymbolForAST(moduleNameExpr, moduleSymbol);
                        if (resolvedModuleNameSymbol.isAlias()) {
                            this.semanticInfoChain.setAliasSymbolForAST(moduleNameExpr, resolvedModuleNameSymbol);
                            var importDeclSymbol = importDecl.getSymbol(this.semanticInfoChain);
                            importDeclSymbol.addLinkedAliasSymbol(resolvedModuleNameSymbol);
                        }
                    } else {
                        this.semanticInfoChain.addDiagnosticFromAST(moduleNameExpr, TypeScript.DiagnosticCode.Unable_to_resolve_module_reference_0, [valueText]);
                    }
                }
            }

            return moduleSymbol;
        };

        PullTypeResolver.prototype.resolveInternalModuleReference = function (importStatementAST, context) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);

            var moduleReference = importStatementAST.moduleReference;

            var aliasExpr = moduleReference.kind() === 246 /* ExternalModuleReference */ ? moduleReference.stringLiteral : moduleReference.moduleName;

            var declPath = enclosingDecl.getParentPath();
            var aliasedType = null;
            var importDeclSymbol = importDecl.getSymbol(this.semanticInfoChain);

            if (aliasExpr.kind() === 11 /* IdentifierName */ || aliasExpr.kind() === 14 /* StringLiteral */) {
                var moduleSymbol = this.resolveModuleReference(importDecl, aliasExpr, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    aliasedType = moduleSymbol.type;
                    this.semanticInfoChain.setAliasSymbolForAST(moduleReference, this.semanticInfoChain.getAliasSymbolForAST(aliasExpr));
                    if (aliasedType.anyDeclHasFlag(32768 /* InitializedModule */)) {
                        var moduleName = aliasExpr.kind() === 11 /* IdentifierName */ ? TypeScript.tokenValueText(aliasExpr) : TypeScript.tokenValueText(aliasExpr);
                        var valueSymbol = this.getSymbolFromDeclPath(moduleName, declPath, 68147712 /* SomeValue */);
                        var instanceSymbol = aliasedType.getInstanceSymbol();

                        if (valueSymbol && (instanceSymbol != valueSymbol || valueSymbol.type === aliasedType)) {
                            var text = aliasExpr.text();
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(aliasExpr, TypeScript.DiagnosticCode.Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1, [text, moduleSymbol.type.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                        } else {
                            importDeclSymbol.setAssignedValueSymbol(valueSymbol);
                        }
                    }
                } else {
                    aliasedType = this.getNewErrorTypeSymbol();
                }
            } else if (aliasExpr.kind() === 121 /* QualifiedName */) {
                var dottedNameAST = aliasExpr;
                var moduleSymbol = this.resolveModuleReference(importDecl, dottedNameAST.left, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    var identifierResolution = this.resolveIdentifierOfInternalModuleReference(importDecl, dottedNameAST.right, moduleSymbol, enclosingDecl, context);
                    if (identifierResolution) {
                        importDeclSymbol.setAssignedValueSymbol(identifierResolution.valueSymbol);
                        importDeclSymbol.setAssignedTypeSymbol(identifierResolution.typeSymbol);
                        importDeclSymbol.setAssignedContainerSymbol(identifierResolution.containerSymbol);
                        this.semanticInfoChain.setAliasSymbolForAST(moduleReference, identifierResolution.aliasSymbol);
                        return null;
                    }
                }
            }

            if (!aliasedType) {
                importDeclSymbol.setAssignedTypeSymbol(this.getNewErrorTypeSymbol());
            }

            return aliasedType;
        };

        PullTypeResolver.prototype.resolveImportDeclaration = function (importStatementAST, context) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol(this.semanticInfoChain);

            var aliasedType = null;

            if (importDeclSymbol.isResolved) {
                return importDeclSymbol;
            }

            importDeclSymbol.startResolving();

            if (importStatementAST.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                var modPath = TypeScript.tokenValueText(importStatementAST.moduleReference.stringLiteral);
                var declPath = enclosingDecl.getParentPath();

                aliasedType = this.resolveExternalModuleReference(modPath, importDecl.fileName());

                if (!aliasedType) {
                    var path = importStatementAST.moduleReference.stringLiteral.text();
                    this.semanticInfoChain.addDiagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Cannot_find_external_module_0, [path]);
                    aliasedType = this.getNewErrorTypeSymbol();
                }
            } else {
                aliasedType = this.resolveInternalModuleReference(importStatementAST, context);
            }

            if (aliasedType) {
                if (!aliasedType.isContainer()) {
                    this.semanticInfoChain.addDiagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Module_cannot_be_aliased_to_a_non_module_type);
                    if (!aliasedType.isError()) {
                        aliasedType = this.getNewErrorTypeSymbol();
                    }
                }

                if (aliasedType.isContainer()) {
                    importDeclSymbol.setAssignedContainerSymbol(aliasedType);
                }
                importDeclSymbol.setAssignedTypeSymbol(aliasedType);

                this.setSymbolForAST(importStatementAST.moduleReference, aliasedType, null);
            }

            importDeclSymbol.setResolved();

            this.resolveDeclaredSymbol(importDeclSymbol.assignedValue(), context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedType(), context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedContainer(), context);

            if (aliasedType && importDeclSymbol.anyDeclHasFlag(1 /* Exported */)) {
                importDeclSymbol.setIsUsedInExportedAlias();

                if (aliasedType.isContainer() && aliasedType.getExportAssignedValueSymbol()) {
                    importDeclSymbol.setIsUsedAsValue();
                }
            }

            if (this.canTypeCheckAST(importStatementAST, context)) {
                this.typeCheckImportDeclaration(importStatementAST, context);
            }

            return importDeclSymbol;
        };

        PullTypeResolver.prototype.typeCheckImportDeclaration = function (importStatementAST, context) {
            var _this = this;
            this.setTypeChecked(importStatementAST, context);

            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol(this.semanticInfoChain);

            if (importStatementAST.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                if (this.compilationSettings.noResolve()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set, null));
                }

                var modPath = TypeScript.tokenValueText(importStatementAST.moduleReference.stringLiteral);
                if (enclosingDecl.kind === 32 /* DynamicModule */) {
                    var ast = TypeScript.ASTHelpers.getEnclosingModuleDeclaration(this.getASTForDecl(enclosingDecl));
                    if (ast && ast.kind() === 131 /* ModuleDeclaration */) {
                        if (TypeScript.isRelative(modPath)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST, TypeScript.DiagnosticCode.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name));
                        }
                    }
                }
            }

            var checkPrivacy;
            if (importStatementAST.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var container = containerSymbol ? containerSymbol.getContainer() : null;
                if (container && container.kind === 32 /* DynamicModule */) {
                    checkPrivacy = true;
                }
            } else {
                checkPrivacy = true;
            }

            if (checkPrivacy) {
                var typeSymbol = importDeclSymbol.getExportAssignedTypeSymbol();
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var valueSymbol = importDeclSymbol.getExportAssignedValueSymbol();

                this.checkSymbolPrivacy(importDeclSymbol, containerSymbol, function (symbol) {
                    var messageCode = TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1;
                    var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(_this.semanticInfoChain) : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(_this.semanticInfoChain) : null, false, false, true)];
                    context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                });

                if (typeSymbol !== containerSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, typeSymbol, function (symbol) {
                        var messageCode = symbol.isContainer() && !symbol.isEnum() ? TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1 : TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1;

                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(_this.semanticInfoChain) : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(_this.semanticInfoChain) : null, false, false, true)];
                        context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                    });
                }

                if (valueSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, valueSymbol.type, function (symbol) {
                        var messageCode = symbol.isContainer() && !symbol.isEnum() ? TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1 : TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1;
                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(_this.semanticInfoChain) : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(_this.semanticInfoChain) : null, false, false, true)];
                        context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                    });
                }
            }

            this.checkNameForCompilerGeneratedDeclarationCollision(importStatementAST, true, importStatementAST.identifier, context);
        };

        PullTypeResolver.prototype.postTypeCheckImportDeclaration = function (importStatementAST, context) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var importSymbol = importDecl.getSymbol(this.semanticInfoChain);

            var isUsedAsValue = importSymbol.isUsedAsValue();
            var hasAssignedValue = importStatementAST.moduleReference.kind() !== 246 /* ExternalModuleReference */ && importSymbol.getExportAssignedValueSymbol() !== null;

            if (isUsedAsValue || hasAssignedValue) {
                this.checkThisCaptureVariableCollides(importStatementAST, true, context);
            }
        };

        PullTypeResolver.prototype.resolveExportAssignmentStatement = function (exportAssignmentAST, context) {
            var id = TypeScript.tokenValueText(exportAssignmentAST.identifier);
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var valueSymbol = null;
            var typeSymbol = null;
            var containerSymbol = null;

            var enclosingDecl = this.getEnclosingDeclForAST(exportAssignmentAST);
            var parentSymbol = enclosingDecl.getSymbol(this.semanticInfoChain);

            if (!parentSymbol.isType() && parentSymbol.isContainer()) {
                this.semanticInfoChain.addDiagnosticFromAST(exportAssignmentAST, TypeScript.DiagnosticCode.Export_assignments_may_only_be_used_at_the_top_level_of_external_modules);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath = enclosingDecl !== null ? [enclosingDecl] : [];

            containerSymbol = this.getSymbolFromDeclPath(id, declPath, 164 /* SomeContainer */);

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & 59753052 /* AcceptableAlias */) !== 0;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind === 128 /* TypeAlias */) {
                this.resolveDeclaredSymbol(containerSymbol, context);

                var aliasSymbol = containerSymbol;
                var aliasedAssignedValue = aliasSymbol.getExportAssignedValueSymbol();
                var aliasedAssignedType = aliasSymbol.getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = aliasSymbol.getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    aliasSymbol.setTypeUsedExternally();
                    if (valueSymbol) {
                        aliasSymbol.setIsUsedAsValue();
                    }
                    acceptableAlias = true;
                }
            }

            if (!acceptableAlias) {
                this.semanticInfoChain.addDiagnosticFromAST(exportAssignmentAST, TypeScript.DiagnosticCode.Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules);
                return this.semanticInfoChain.voidTypeSymbol;
            }

            if (!valueSymbol) {
                valueSymbol = this.getSymbolFromDeclPath(id, declPath, 68147712 /* SomeValue */);
            }
            if (!typeSymbol) {
                typeSymbol = this.getSymbolFromDeclPath(id, declPath, 58728795 /* SomeType */);
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(exportAssignmentAST, TypeScript.DiagnosticCode.Cannot_find_name_0, [id]));
                return this.semanticInfoChain.voidTypeSymbol;
            }

            if (valueSymbol) {
                parentSymbol.setExportAssignedValueSymbol(valueSymbol);
            }
            if (typeSymbol) {
                parentSymbol.setExportAssignedTypeSymbol(typeSymbol);
            }
            if (containerSymbol) {
                parentSymbol.setExportAssignedContainerSymbol(containerSymbol);
            }

            this.resolveDeclaredSymbol(valueSymbol, context);
            this.resolveDeclaredSymbol(typeSymbol, context);
            this.resolveDeclaredSymbol(containerSymbol, context);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveAnyFunctionTypeSignature = function (funcDeclAST, typeParameters, parameterList, returnTypeAnnotation, context) {
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            TypeScript.Debug.assert(functionDecl);

            var funcDeclSymbol = functionDecl.getSymbol(this.semanticInfoChain);

            var signature = funcDeclSymbol.kind === 33554432 /* ConstructorType */ ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];

            if (returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(returnTypeAnnotation, context);
            }

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            if (parameterList) {
                for (var i = 0; i < parameterList.parameters.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(parameterList.parameters[i], signature, functionDecl, context);
                }
            }

            funcDeclSymbol.setResolved();

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.setTypeChecked(funcDeclAST, context);
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            }

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionTypeSignatureParameter = function (argDeclAST, signature, enclosingDecl, context) {
            var paramDecl = this.semanticInfoChain.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol(this.semanticInfoChain);

            if (argDeclAST.typeAnnotation) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeAnnotation.type, context);

                if (paramSymbol.isVarArg && !typeRef.isArrayNamedTypeReference()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.A_rest_parameter_must_be_of_an_array_type));
                    typeRef = this.getNewErrorTypeSymbol();
                }

                context.setTypeInContext(paramSymbol, typeRef);
            } else {
                if (paramSymbol.isVarArg) {
                    if (this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, this.createInstantiatedType(this.cachedArrayInterfaceType(), [this.semanticInfoChain.anyTypeSymbol]));
                    } else {
                        context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }

                if (this.compilationSettings.noImplicitAny()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Parameter_0_of_function_type_implicitly_has_an_any_type, [argDeclAST.identifier.text()]));
                }
            }

            if (TypeScript.hasFlag(paramDecl.flags, 128 /* Optional */) && argDeclAST.equalsValueClause && isTypesOnlyLocation(argDeclAST)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation));
            }

            this.typeCheckParameterModifiers(argDeclAST, context);

            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.resolveFunctionExpressionParameter = function (argDeclAST, contextParam, enclosingDecl, context) {
            var paramDecl = this.semanticInfoChain.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol(this.semanticInfoChain);
            var contextualType = contextParam && contextParam.type;
            var isImplicitAny = false;

            if (argDeclAST.typeAnnotation) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeAnnotation.type, context);

                if (paramSymbol.isVarArg && !typeRef.isArrayNamedTypeReference()) {
                    var diagnostic = context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.A_rest_parameter_must_be_of_an_array_type));
                    typeRef = this.getNewErrorTypeSymbol();
                }

                contextualType = typeRef || contextualType;
            }
            if (contextualType) {
                if (context.isInferentiallyTyping()) {
                    contextualType = context.fixAllTypeParametersReferencedByType(contextualType, this);
                }
                context.setTypeInContext(paramSymbol, contextualType);
            } else if (paramSymbol.isVarArg) {
                if (this.cachedArrayInterfaceType()) {
                    context.setTypeInContext(paramSymbol, this.createInstantiatedType(this.cachedArrayInterfaceType(), [this.semanticInfoChain.anyTypeSymbol]));
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
                isImplicitAny = true;
            }

            var canTypeCheckAST = this.canTypeCheckAST(argDeclAST, context);
            if (argDeclAST.equalsValueClause && (canTypeCheckAST || !contextualType)) {
                if (contextualType) {
                    context.propagateContextualType(contextualType);
                }

                var initExprSymbol = this.resolveAST(argDeclAST.equalsValueClause, contextualType !== null, context);

                if (contextualType) {
                    context.popAnyContextualType();
                }

                if (!initExprSymbol || !initExprSymbol.type) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [argDeclAST.identifier.text()]));

                    if (!contextualType) {
                        context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(paramSymbol.name));
                    }
                } else {
                    var initTypeSymbol = this.getInstanceTypeForAssignment(argDeclAST, initExprSymbol.type, context);
                    if (!contextualType) {
                        context.setTypeInContext(paramSymbol, initTypeSymbol.widenedType(this, argDeclAST.equalsValueClause, context));
                        isImplicitAny = initTypeSymbol !== paramSymbol.type;
                    } else {
                        var comparisonInfo = new TypeComparisonInfo();

                        var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, contextualType, argDeclAST, context, comparisonInfo);

                        if (!isAssignable) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(argDeclAST);
                            if (comparisonInfo.message) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1_NL_2, [initTypeSymbol.toString(enclosingSymbol), contextualType.toString(enclosingSymbol), comparisonInfo.message]));
                            } else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1, [initTypeSymbol.toString(enclosingSymbol), contextualType.toString(enclosingSymbol)]));
                            }
                        }
                    }
                }
            }

            if (!contextualType && !paramSymbol.isVarArg && !initTypeSymbol) {
                context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                isImplicitAny = true;
            }

            if (isImplicitAny && this.compilationSettings.noImplicitAny()) {
                var functionExpressionName = paramDecl.getParentDecl().getFunctionExpressionName();
                if (functionExpressionName) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [argDeclAST.identifier.text(), functionExpressionName]));
                } else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, TypeScript.DiagnosticCode.Parameter_0_of_lambda_function_implicitly_has_an_any_type, [argDeclAST.identifier.text()]));
                }
            }

            if (canTypeCheckAST) {
                this.checkNameForCompilerGeneratedDeclarationCollision(argDeclAST, true, argDeclAST.identifier, context);
                this.typeCheckParameterModifiers(argDeclAST, context);
            }

            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.checkNameForCompilerGeneratedDeclarationCollision = function (astWithName, isDeclaration, name, context) {
            var compilerReservedName = getCompilerReservedName(name);
            switch (compilerReservedName) {
                case 1 /* _this */:
                    this.postTypeCheckWorkitems.push(astWithName);
                    return;

                case 2 /* _super */:
                    this.checkSuperCaptureVariableCollides(astWithName, isDeclaration, context);
                    return;

                case 3 /* arguments */:
                    this.checkArgumentsCollides(astWithName, context);
                    return;

                case 4 /* _i */:
                    this.checkIndexOfRestArgumentInitializationCollides(astWithName, isDeclaration, context);
                    return;

                case 5 /* require */:
                case 6 /* exports */:
                    if (isDeclaration) {
                        this.checkExternalModuleRequireExportsCollides(astWithName, name, context);
                    }
                    return;
            }
        };

        PullTypeResolver.prototype.hasRestParameterCodeGen = function (someFunctionDecl) {
            var enclosingAST = this.getASTForDecl(someFunctionDecl);
            var nodeType = enclosingAST.kind();

            if (nodeType === 130 /* FunctionDeclaration */) {
                var functionDeclaration = enclosingAST;
                return !TypeScript.hasFlag(someFunctionDecl.kind === 65536 /* Method */ ? someFunctionDecl.getParentDecl().flags : someFunctionDecl.flags, 8 /* Ambient */) && functionDeclaration.block && TypeScript.lastParameterIsRest(functionDeclaration.callSignature.parameterList.parameters);
            } else if (nodeType === 136 /* MemberFunctionDeclaration */) {
                var memberFunction = enclosingAST;
                return !TypeScript.hasFlag(someFunctionDecl.kind === 65536 /* Method */ ? someFunctionDecl.getParentDecl().flags : someFunctionDecl.flags, 8 /* Ambient */) && memberFunction.block && TypeScript.lastParameterIsRest(memberFunction.callSignature.parameterList.parameters);
            } else if (nodeType === 138 /* ConstructorDeclaration */) {
                var constructorDeclaration = enclosingAST;
                return !TypeScript.hasFlag(someFunctionDecl.getParentDecl().flags, 8 /* Ambient */) && constructorDeclaration.block && TypeScript.lastParameterIsRest(constructorDeclaration.callSignature.parameterList.parameters);
            } else if (nodeType === 219 /* ParenthesizedArrowFunctionExpression */) {
                var arrowFunctionExpression = enclosingAST;
                return TypeScript.lastParameterIsRest(arrowFunctionExpression.callSignature.parameterList.parameters);
            } else if (nodeType === 223 /* FunctionExpression */) {
                var functionExpression = enclosingAST;
                return TypeScript.lastParameterIsRest(functionExpression.callSignature.parameterList.parameters);
            }

            return false;
        };

        PullTypeResolver.prototype.checkArgumentsCollides = function (ast, context) {
            if (ast.kind() === 243 /* Parameter */) {
                var enclosingDecl = this.getEnclosingDeclForAST(ast);
                if (TypeScript.hasFlag(enclosingDecl.kind, 1032192 /* SomeFunction */)) {
                    if (this.hasRestParameterCodeGen(enclosingDecl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters));
                    }
                }
            }
        };

        PullTypeResolver.prototype.checkIndexOfRestArgumentInitializationCollides = function (ast, isDeclaration, context) {
            if (!isDeclaration || ast.kind() === 243 /* Parameter */) {
                var enclosingDecl = this.getEnclosingDeclForAST(ast);
                var declPath = isDeclaration ? [enclosingDecl] : (enclosingDecl ? enclosingDecl.getParentPath() : []);
                var resolvedSymbol = null;
                var resolvedSymbolContainer;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    if (!isDeclaration) {
                        if (!resolvedSymbol) {
                            resolvedSymbol = this.resolveNameExpression(ast, context);
                            if (resolvedSymbol.isError()) {
                                return;
                            }

                            resolvedSymbolContainer = resolvedSymbol.getContainer();
                        }

                        if (resolvedSymbolContainer && TypeScript.ArrayUtilities.contains(resolvedSymbolContainer.getDeclarations(), decl)) {
                            break;
                        }
                    }

                    if (TypeScript.hasFlag(decl.kind, 1032192 /* SomeFunction */)) {
                        if (this.hasRestParameterCodeGen(decl)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, isDeclaration ? TypeScript.DiagnosticCode.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter : TypeScript.DiagnosticCode.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter));
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.checkExternalModuleRequireExportsCollides = function (ast, name, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);

            var enclosingModule = TypeScript.ASTHelpers.getModuleDeclarationFromNameAST(name);
            if (enclosingModule) {
                enclosingDecl = this.getEnclosingDeclForAST(enclosingModule);
            }

            if (enclosingDecl && enclosingDecl.kind === 32 /* DynamicModule */) {
                var decl = this.semanticInfoChain.getDeclForAST(ast);

                if (!TypeScript.hasFlag(decl.flags, 8 /* Ambient */)) {
                    var nameText = TypeScript.tokenValueText(name);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module, [nameText, nameText]));
                }
            }
        };

        PullTypeResolver.prototype.resolveObjectTypeTypeReference = function (objectType, context) {
            var interfaceDecl = this.semanticInfoChain.getDeclForAST(objectType);
            TypeScript.Debug.assert(interfaceDecl);

            var interfaceSymbol = interfaceDecl.getSymbol(this.semanticInfoChain);
            TypeScript.Debug.assert(interfaceSymbol);

            if (objectType.typeMembers) {
                var memberDecl = null;
                var memberSymbol = null;
                var memberType = null;
                var typeMembers = objectType.typeMembers;

                for (var i = 0; i < typeMembers.length; i++) {
                    memberDecl = this.semanticInfoChain.getDeclForAST(typeMembers[i]);
                    memberSymbol = (memberDecl.kind & 7340032 /* SomeSignature */) ? memberDecl.getSignatureSymbol(this.semanticInfoChain) : memberDecl.getSymbol(this.semanticInfoChain);

                    this.resolveAST(typeMembers[i], false, context);

                    memberType = memberSymbol.type;

                    if ((memberType && memberType.isGeneric()) || (memberSymbol.isSignature() && memberSymbol.isGeneric())) {
                        interfaceSymbol.setHasGenericMember();
                    }
                }
            }

            interfaceSymbol.setResolved();

            if (this.canTypeCheckAST(objectType, context)) {
                this.typeCheckObjectTypeTypeReference(objectType, context);
            }

            return interfaceSymbol;
        };

        PullTypeResolver.prototype.typeCheckObjectTypeTypeReference = function (objectType, context) {
            this.setTypeChecked(objectType, context);
            var objectTypeDecl = this.semanticInfoChain.getDeclForAST(objectType);
            var objectTypeSymbol = objectTypeDecl.getSymbol(this.semanticInfoChain);

            this.typeCheckMembersAgainstIndexer(objectTypeSymbol, objectTypeDecl, context);
            this.checkTypeForDuplicateIndexSignatures(objectTypeSymbol);
        };

        PullTypeResolver.prototype.resolveTypeAnnotation = function (typeAnnotation, context) {
            return this.resolveTypeReference(typeAnnotation.type, context);
        };

        PullTypeResolver.prototype.resolveTypeReference = function (typeRef, context) {
            if (typeRef === null) {
                return null;
            }

            TypeScript.Debug.assert(typeRef.kind() !== 245 /* TypeAnnotation */);

            var aliasType = null;
            var type = this.computeTypeReferenceSymbol(typeRef, context);

            if (type.kind === 4 /* Container */) {
                var container = type;
                var instanceSymbol = container.getInstanceSymbol();

                if (instanceSymbol && (instanceSymbol.anyDeclHasFlag(16384 /* ClassConstructorVariable */) || instanceSymbol.kind === 32768 /* ConstructorMethod */)) {
                    type = instanceSymbol.type.getAssociatedContainerType();
                }
            }

            if (type && type.isAlias()) {
                aliasType = type;
                type = aliasType.getExportAssignedTypeSymbol();
            }

            if (type && !type.isGeneric()) {
                if (aliasType) {
                    this.semanticInfoChain.setAliasSymbolForAST(typeRef, aliasType);
                }
            }

            if (type && !type.isError()) {
                if ((type.kind & 58728795 /* SomeType */) === 0) {
                    if (type.kind & 164 /* SomeContainer */) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeRef, TypeScript.DiagnosticCode.Type_reference_cannot_refer_to_container_0, [aliasType ? aliasType.toString() : type.toString()]));
                    } else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeRef, TypeScript.DiagnosticCode.Type_reference_must_refer_to_type));
                    }
                }
            }

            if (this.canTypeCheckAST(typeRef, context)) {
                this.setTypeChecked(typeRef, context);
            }

            return type;
        };

        PullTypeResolver.prototype.getArrayType = function (elementType) {
            var arraySymbol = elementType.getArrayType();

            if (!arraySymbol) {
                arraySymbol = this.createInstantiatedType(this.cachedArrayInterfaceType(), [elementType]);

                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }

                elementType.setArrayType(arraySymbol);
            }

            return arraySymbol;
        };

        PullTypeResolver.prototype.computeTypeReferenceSymbol = function (term, context) {
            switch (term.kind()) {
                case 60 /* AnyKeyword */: return this.semanticInfoChain.anyTypeSymbol;
                case 61 /* BooleanKeyword */: return this.semanticInfoChain.booleanTypeSymbol;
                case 67 /* NumberKeyword */: return this.semanticInfoChain.numberTypeSymbol;
                case 69 /* StringKeyword */: return this.semanticInfoChain.stringTypeSymbol;
                case 41 /* VoidKeyword */: return this.semanticInfoChain.voidTypeSymbol;
            }

            var typeDeclSymbol = null;

            if (term.kind() === 11 /* IdentifierName */) {
                typeDeclSymbol = this.resolveTypeNameExpression(term, context);
            } else if (term.kind() === 123 /* FunctionType */) {
                var functionType = term;
                typeDeclSymbol = this.resolveAnyFunctionTypeSignature(functionType, functionType.typeParameterList, functionType.parameterList, functionType.type, context);
            } else if (term.kind() === 125 /* ConstructorType */) {
                var constructorType = term;
                typeDeclSymbol = this.resolveAnyFunctionTypeSignature(constructorType, constructorType.typeParameterList, constructorType.parameterList, constructorType.type, context);
            } else if (term.kind() === 122 /* ObjectType */) {
                typeDeclSymbol = this.resolveObjectTypeTypeReference(term, context);
            } else if (term.kind() === 126 /* GenericType */) {
                typeDeclSymbol = this.resolveGenericTypeReference(term, context);
            } else if (term.kind() === 121 /* QualifiedName */) {
                typeDeclSymbol = this.resolveQualifiedName(term, context);
            } else if (term.kind() === 14 /* StringLiteral */) {
                var stringConstantAST = term;
                var enclosingDecl = this.getEnclosingDeclForAST(term);
                typeDeclSymbol = new TypeScript.PullStringConstantTypeSymbol(stringConstantAST.text(), this.semanticInfoChain);
                var decl = new TypeScript.PullSynthesizedDecl(stringConstantAST.text(), stringConstantAST.text(), typeDeclSymbol.kind, null, enclosingDecl);
                typeDeclSymbol.addDeclaration(decl);
            } else if (term.kind() === 127 /* TypeQuery */) {
                var typeQuery = term;

                var typeQueryTerm = typeQuery.name;

                var valueSymbol = this.resolveAST(typeQueryTerm, false, context);

                if (valueSymbol && valueSymbol.isAlias()) {
                    if (valueSymbol.assignedValue()) {
                        valueSymbol = valueSymbol.assignedValue();
                    } else {
                        var containerSymbol = valueSymbol.getExportAssignedContainerSymbol();
                        valueSymbol = (containerSymbol && containerSymbol.isContainer() && !containerSymbol.isEnum()) ? containerSymbol.getInstanceSymbol() : null;
                    }
                }

                if (valueSymbol) {
                    typeDeclSymbol = valueSymbol.type.widenedType(this, typeQueryTerm, context);
                } else {
                    typeDeclSymbol = this.getNewErrorTypeSymbol();
                }
            } else if (term.kind() === 124 /* ArrayType */) {
                var arrayType = term;
                var underlying = this.resolveTypeReference(arrayType.type, context);
                typeDeclSymbol = this.getArrayType(underlying);
            } else {
                throw TypeScript.Errors.invalidOperation("unknown type");
            }

            if (!typeDeclSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(term, TypeScript.DiagnosticCode.Unable_to_resolve_type));
                return this.getNewErrorTypeSymbol();
            }

            if (typeDeclSymbol.isError()) {
                return typeDeclSymbol;
            }

            if (this.genericTypeIsUsedWithoutRequiredTypeArguments(typeDeclSymbol, term, context)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(term, TypeScript.DiagnosticCode.Generic_type_0_requires_1_type_argument_s, [typeDeclSymbol.toString(), typeDeclSymbol.getTypeParameters().length]));
                typeDeclSymbol = this.instantiateTypeToAny(typeDeclSymbol, context);
            }

            return typeDeclSymbol;
        };

        PullTypeResolver.prototype.genericTypeIsUsedWithoutRequiredTypeArguments = function (typeSymbol, term, context) {
            if (!typeSymbol) {
                return false;
            }

            if (typeSymbol.isAlias()) {
                return this.genericTypeIsUsedWithoutRequiredTypeArguments(typeSymbol.getExportAssignedTypeSymbol(), term, context);
            }

            return typeSymbol.isNamedTypeSymbol() && typeSymbol.isGeneric() && !typeSymbol.isTypeParameter() && (typeSymbol.isResolved || typeSymbol.inResolution) && !typeSymbol.getIsSpecialized() && typeSymbol.getTypeParameters().length && typeSymbol.getTypeArguments() === null && this.isTypeRefWithoutTypeArgs(term);
        };

        PullTypeResolver.prototype.resolveMemberVariableDeclaration = function (varDecl, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(varDecl, varDecl.modifiers, varDecl.variableDeclarator.propertyName, TypeScript.ASTHelpers.getType(varDecl.variableDeclarator), varDecl.variableDeclarator.equalsValueClause, context);
        };

        PullTypeResolver.prototype.resolvePropertySignature = function (varDecl, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(varDecl, TypeScript.Syntax.emptyList(), varDecl.propertyName, TypeScript.ASTHelpers.getType(varDecl), null, context);
        };

        PullTypeResolver.prototype.resolveVariableDeclarator = function (varDecl, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(varDecl, TypeScript.ASTHelpers.getVariableDeclaratorModifiers(varDecl), varDecl.propertyName, TypeScript.ASTHelpers.getType(varDecl), varDecl.equalsValueClause, context);
        };

        PullTypeResolver.prototype.resolveParameterList = function (list, context) {
            return this.resolveSeparatedList(list.parameters, context);
        };

        PullTypeResolver.prototype.resolveParameter = function (parameter, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(parameter, parameter.modifiers, parameter.identifier, TypeScript.ASTHelpers.getType(parameter), parameter.equalsValueClause, context);
        };

        PullTypeResolver.prototype.getEnumTypeSymbol = function (enumElement, context) {
            var enumDeclaration = enumElement.parent.parent;
            var decl = this.semanticInfoChain.getDeclForAST(enumDeclaration);
            var symbol = decl.getSymbol(this.semanticInfoChain);
            this.resolveDeclaredSymbol(symbol, context);

            return symbol;
        };

        PullTypeResolver.prototype.resolveEnumElement = function (enumElement, context) {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(enumElement, TypeScript.Syntax.emptyList(), enumElement.propertyName, null, enumElement.equalsValueClause, context);
        };

        PullTypeResolver.prototype.typeCheckEnumElement = function (enumElement, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(enumElement, TypeScript.Syntax.emptyList(), enumElement.propertyName, null, enumElement.equalsValueClause, context);
        };

        PullTypeResolver.prototype.resolveEqualsValueClause = function (clause, isContextuallyTyped, context) {
            if (this.canTypeCheckAST(clause, context)) {
                this.setTypeChecked(clause, context);
            }

            return this.resolveAST(clause.value, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.resolveVariableDeclaratorOrParameterOrEnumElement = function (varDeclOrParameter, modifiers, name, typeExpr, init, context) {
            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === 244 /* EnumElement */;
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);

            if (enclosingDecl && decl.kind === 2048 /* Parameter */) {
                enclosingDecl.ensureSymbolIsBound(this.semanticInfoChain);
            }

            var declSymbol = decl.getSymbol(this.semanticInfoChain);
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol(this.semanticInfoChain) : null;

            if (declSymbol.isResolved) {
                var declType = declSymbol.type;
                var valDecl = decl.getValueDecl();

                if (valDecl) {
                    var valSymbol = valDecl.getSymbol(this.semanticInfoChain);

                    if (valSymbol && !valSymbol.isResolved) {
                        valSymbol.type = declType;
                        valSymbol.setResolved();
                    }
                }
            } else {
                if (declSymbol.inResolution) {
                    declSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    declSymbol.setResolved();
                    return declSymbol;
                }

                if (!declSymbol.type || !declSymbol.type.isError()) {
                    declSymbol.startResolving();

                    var typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter, name, typeExpr, context);

                    if (!hasTypeExpr) {
                        this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol);
                    }

                    if (!(hasTypeExpr || init)) {
                        var defaultType = this.semanticInfoChain.anyTypeSymbol;

                        if (declSymbol.isVarArg && this.cachedArrayInterfaceType()) {
                            defaultType = this.createInstantiatedType(this.cachedArrayInterfaceType(), [defaultType]);
                        }

                        context.setTypeInContext(declSymbol, defaultType);

                        if (declParameterSymbol) {
                            declParameterSymbol.type = defaultType;
                        }
                    }
                    declSymbol.setResolved();

                    if (declParameterSymbol) {
                        declParameterSymbol.setResolved();
                    }
                }
            }

            if (this.canTypeCheckAST(varDeclOrParameter, context)) {
                this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDeclOrParameter, modifiers, name, typeExpr, init, context);
            }

            return declSymbol;
        };

        PullTypeResolver.prototype.resolveAndTypeCheckVariableDeclarationTypeExpr = function (varDeclOrParameter, name, typeExpr, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol(this.semanticInfoChain);
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol(this.semanticInfoChain) : null;

            if (varDeclOrParameter.kind() === 244 /* EnumElement */) {
                var result = this.getEnumTypeSymbol(varDeclOrParameter, context);
                declSymbol.type = result;
                return result;
            }

            if (!typeExpr) {
                return null;
            }

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl || enclosingDecl;

            var typeExprSymbol = this.resolveTypeReference(typeExpr, context);

            if (!typeExprSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [name.text()]));
                declSymbol.type = this.getNewErrorTypeSymbol();

                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            } else if (typeExprSymbol.isError()) {
                context.setTypeInContext(declSymbol, typeExprSymbol);
                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, typeExprSymbol);
                }
            } else {
                if (typeExprSymbol === this.semanticInfoChain.anyTypeSymbol) {
                    decl.setFlag(16777216 /* IsAnnotatedWithAny */);
                }

                if (typeExprSymbol.isContainer()) {
                    var exportedTypeSymbol = typeExprSymbol.getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    } else {
                        typeExprSymbol = typeExprSymbol.type;

                        if (typeExprSymbol.isAlias()) {
                            typeExprSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                        }

                        if (typeExprSymbol && typeExprSymbol.isContainer() && !typeExprSymbol.isEnum()) {
                            var instanceSymbol = typeExprSymbol.getInstanceSymbol();

                            if (!instanceSymbol || !TypeScript.PullHelpers.symbolIsEnum(instanceSymbol)) {
                                typeExprSymbol = this.getNewErrorTypeSymbol();
                            } else {
                                typeExprSymbol = instanceSymbol.type;
                            }
                        }
                    }
                } else if (declSymbol.isVarArg && !(typeExprSymbol.isArrayNamedTypeReference() || typeExprSymbol === this.cachedArrayInterfaceType())) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.A_rest_parameter_must_be_of_an_array_type));
                    typeExprSymbol = this.getNewErrorTypeSymbol();
                }

                context.setTypeInContext(declSymbol, typeExprSymbol);

                if (declParameterSymbol) {
                    declParameterSymbol.type = typeExprSymbol;
                }

                if (typeExprSymbol.kind === 16777216 /* FunctionType */ && !typeExprSymbol.getFunctionSymbol()) {
                    typeExprSymbol.setFunctionSymbol(declSymbol);
                }
            }

            return typeExprSymbol;
        };

        PullTypeResolver.prototype.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr = function (varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol) {
            if (!init) {
                return null;
            }

            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === 244 /* EnumElement */;
            if (typeExprSymbol) {
                context.pushNewContextualType(typeExprSymbol);
            }

            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol(this.semanticInfoChain);
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol(this.semanticInfoChain) : null;

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl || enclosingDecl;

            var initExprSymbol = this.resolveAST(init, typeExprSymbol !== null, context);

            if (typeExprSymbol) {
                context.popAnyContextualType();
            }

            if (!initExprSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [name.text()]));

                if (!hasTypeExpr) {
                    context.setTypeInContext(declSymbol, this.getNewErrorTypeSymbol());

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            } else {
                var initTypeSymbol = initExprSymbol.type;

                if (!hasTypeExpr) {
                    var widenedInitTypeSymbol = initTypeSymbol.widenedType(this, init.value, context);
                    context.setTypeInContext(declSymbol, widenedInitTypeSymbol);

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, widenedInitTypeSymbol);
                    }

                    if (this.compilationSettings.noImplicitAny()) {
                        if ((widenedInitTypeSymbol !== initTypeSymbol) && (widenedInitTypeSymbol === this.semanticInfoChain.anyTypeSymbol)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.text()]));
                        }
                    }

                    return widenedInitTypeSymbol;
                }
            }

            return initTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckPropertySignature = function (varDecl, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDecl, TypeScript.Syntax.emptyList(), varDecl.propertyName, TypeScript.ASTHelpers.getType(varDecl), null, context);
        };

        PullTypeResolver.prototype.typeCheckMemberVariableDeclaration = function (varDecl, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDecl, varDecl.modifiers, varDecl.variableDeclarator.propertyName, TypeScript.ASTHelpers.getType(varDecl), varDecl.variableDeclarator.equalsValueClause, context);
        };

        PullTypeResolver.prototype.typeCheckVariableDeclarator = function (varDecl, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(varDecl, TypeScript.ASTHelpers.getVariableDeclaratorModifiers(varDecl), varDecl.propertyName, TypeScript.ASTHelpers.getType(varDecl), varDecl.equalsValueClause, context);
        };

        PullTypeResolver.prototype.getContainingConstructorDeclaration = function (parameter) {
            var current = parameter;
            while (current.kind() !== 138 /* ConstructorDeclaration */) {
                current = current.parent;
            }

            return current;
        };

        PullTypeResolver.prototype.typeCheckParameter = function (parameter, context) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(parameter, parameter.modifiers, parameter.identifier, TypeScript.ASTHelpers.getType(parameter), parameter.equalsValueClause, context);
        };

        PullTypeResolver.prototype.typeCheckParameterModifiers = function (parameter, context) {
            if (parameter.modifiers.length) {
                var parameterDecl = this.semanticInfoChain.getDeclForAST(parameter);
                var isConstructorParam = TypeScript.hasFlag(parameterDecl.flags, 67108864 /* ConstructorParameter */);

                var inAmbientDeclaration = TypeScript.hasFlag(parameterDecl.getParentDecl().flags, 8 /* Ambient */);

                if (!inAmbientDeclaration && isConstructorParam) {
                    var constructorDeclaration = this.getContainingConstructorDeclaration(parameter);
                    if (!constructorDeclaration.block) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(parameter.modifiers[0], TypeScript.DiagnosticCode.A_parameter_property_is_only_allowed_in_a_constructor_implementation));
                    }
                } else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(parameter.modifiers[0], TypeScript.DiagnosticCode.A_parameter_property_is_only_allowed_in_a_constructor_implementation));
                }
            }
        };

        PullTypeResolver.prototype.typeCheckVariableDeclaratorOrParameterOrEnumElement = function (varDeclOrParameter, modifiers, name, typeExpr, init, context) {
            var _this = this;
            this.setTypeChecked(varDeclOrParameter, context);

            if (varDeclOrParameter.kind() === 243 /* Parameter */) {
                this.typeCheckParameterModifiers(varDeclOrParameter, context);
            }

            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === 244 /* EnumElement */;
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol(this.semanticInfoChain);

            var typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter, name, typeExpr, context);

            var initTypeSymbol = this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol);

            if (hasTypeExpr || init) {
                if (typeExprSymbol && typeExprSymbol.isAlias()) {
                    typeExprSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                }

                if (typeExprSymbol && typeExprSymbol.kind === 32 /* DynamicModule */) {
                    var exportedTypeSymbol = typeExprSymbol.getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    } else {
                        var instanceTypeSymbol = typeExprSymbol.getInstanceType();

                        if (!instanceTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [typeExprSymbol.toString()]));
                            typeExprSymbol = null;
                        } else {
                            typeExprSymbol = instanceTypeSymbol;
                        }
                    }
                }

                initTypeSymbol = this.getInstanceTypeForAssignment(varDeclOrParameter, initTypeSymbol, context);

                if (initTypeSymbol && typeExprSymbol) {
                    var comparisonInfo = new TypeComparisonInfo();

                    var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, typeExprSymbol, varDeclOrParameter, context, comparisonInfo);

                    if (!isAssignable) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(varDeclOrParameter);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1_NL_2, [initTypeSymbol.toString(enclosingSymbol), typeExprSymbol.toString(enclosingSymbol), comparisonInfo.message]));
                        } else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1, [initTypeSymbol.toString(enclosingSymbol), typeExprSymbol.toString(enclosingSymbol)]));
                        }
                    }
                }
            } else if (varDeclOrParameter.kind() !== 244 /* EnumElement */ && this.compilationSettings.noImplicitAny() && !this.isForInVariableDeclarator(varDeclOrParameter)) {
                var wrapperDecl = this.getEnclosingDecl(decl);
                wrapperDecl = wrapperDecl || enclosingDecl;

                var needReportError = function (containerDecl, selfDecl) {
                    if (!TypeScript.hasFlag(containerDecl.flags, 8 /* Ambient */)) {
                        return true;
                    }

                    return selfDecl && !TypeScript.hasFlag(selfDecl.flags, 2 /* Private */);
                };

                if ((wrapperDecl.kind === 16384 /* Function */ || wrapperDecl.kind === 32768 /* ConstructorMethod */ || wrapperDecl.kind === 2097152 /* ConstructSignature */)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.text(), enclosingDecl.name]));
                } else if (wrapperDecl.kind === 65536 /* Method */) {
                    var parentDecl = wrapperDecl.getParentDecl();

                    if (needReportError(parentDecl, wrapperDecl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.text(), enclosingDecl.name]));
                    }
                } else if (decl.kind === 4096 /* Property */ && !declSymbol.getContainer().isNamedTypeSymbol()) {
                    if (needReportError(wrapperDecl, decl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Member_0_of_object_type_implicitly_has_an_any_type, [name.text()]));
                    }
                } else if (wrapperDecl.kind !== 268435456 /* CatchBlock */) {
                    if (needReportError(wrapperDecl) || !TypeScript.hasModifier(modifiers, 2 /* Private */)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.text()]));
                    }
                }
            }

            if (init && varDeclOrParameter.kind() === 243 /* Parameter */) {
                var containerSignature = enclosingDecl.getSignatureSymbol(this.semanticInfoChain);
                if (containerSignature && !containerSignature.isDefinition()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, TypeScript.DiagnosticCode.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation));
                }
            }
            if (declSymbol.kind !== 2048 /* Parameter */ && (declSymbol.kind !== 4096 /* Property */ || declSymbol.getContainer().isNamedTypeSymbol())) {
                this.checkSymbolPrivacy(declSymbol, declSymbol.type, function (symbol) {
                    return _this.variablePrivacyErrorReporter(varDeclOrParameter, declSymbol, symbol, context);
                });
            }

            if ((declSymbol.kind !== 4096 /* Property */ && declSymbol.kind !== 67108864 /* EnumMember */) || declSymbol.anyDeclHasFlag(8388608 /* PropertyParameter */)) {
                this.checkNameForCompilerGeneratedDeclarationCollision(varDeclOrParameter, true, name, context);
            }
        };

        PullTypeResolver.prototype.isForInVariableDeclarator = function (ast) {
            return ast.kind() === 226 /* VariableDeclarator */ && ast.parent && ast.parent.parent && ast.parent.parent.parent && ast.parent.kind() === 2 /* SeparatedList */ && ast.parent.parent.kind() === 225 /* VariableDeclaration */ && ast.parent.parent.parent.kind() === 156 /* ForInStatement */ && ast.parent.parent.parent.variableDeclaration === ast.parent.parent;
        };

        PullTypeResolver.prototype.checkSuperCaptureVariableCollides = function (superAST, isDeclaration, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(superAST);

            var classSymbol = this.getContextualClassSymbolForEnclosingDecl(superAST, enclosingDecl);

            if (classSymbol && !classSymbol.anyDeclHasFlag(8 /* Ambient */)) {
                if (superAST.kind() === 243 /* Parameter */) {
                    var enclosingAST = this.getASTForDecl(enclosingDecl);
                    if (enclosingAST.kind() !== 219 /* ParenthesizedArrowFunctionExpression */ && enclosingAST.kind() !== 220 /* SimpleArrowFunctionExpression */) {
                        var block = enclosingDecl.kind === 65536 /* Method */ ? enclosingAST.block : enclosingAST.block;
                        if (!block) {
                            return;
                        }
                    }
                }

                this.resolveDeclaredSymbol(classSymbol, context);

                var parents = classSymbol.getExtendedTypes();
                if (parents.length) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(superAST, isDeclaration ? TypeScript.DiagnosticCode.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference : TypeScript.DiagnosticCode.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference));
                }
            }
        };

        PullTypeResolver.prototype.checkThisCaptureVariableCollides = function (_thisAST, isDeclaration, context) {
            if (isDeclaration) {
                var decl = this.semanticInfoChain.getDeclForAST(_thisAST);
                if (TypeScript.hasFlag(decl.flags, 8 /* Ambient */)) {
                    return;
                }
            }

            var enclosingDecl = this.getEnclosingDeclForAST(_thisAST);

            var enclosingModule = TypeScript.ASTHelpers.getModuleDeclarationFromNameAST(_thisAST);
            if (enclosingModule) {
                enclosingDecl = this.getEnclosingDeclForAST(enclosingModule);
            }

            var declPath = enclosingDecl.getParentPath();

            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];
                var declKind = decl.kind;
                if (declKind === 131072 /* FunctionExpression */ && TypeScript.hasFlag(decl.flags, 8192 /* ArrowFunction */)) {
                    continue;
                }

                if (declKind === 16384 /* Function */ || declKind === 65536 /* Method */ || declKind === 32768 /* ConstructorMethod */ || declKind === 262144 /* GetAccessor */ || declKind === 524288 /* SetAccessor */ || declKind === 131072 /* FunctionExpression */ || declKind === 8 /* Class */ || declKind === 4 /* Container */ || declKind === 32 /* DynamicModule */ || declKind === 1 /* Script */) {
                    if (TypeScript.hasFlag(decl.flags, 262144 /* MustCaptureThis */)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(_thisAST, isDeclaration ? TypeScript.DiagnosticCode.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference : TypeScript.DiagnosticCode.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference));
                    }
                    break;
                }
            }
        };

        PullTypeResolver.prototype.postTypeCheckVariableDeclaratorOrParameter = function (varDeclOrParameter, context) {
            this.checkThisCaptureVariableCollides(varDeclOrParameter, true, context);
        };

        PullTypeResolver.prototype.resolveTypeParameterDeclaration = function (typeParameterAST, context) {
            var typeParameterDecl = this.semanticInfoChain.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = typeParameterDecl.getSymbol(this.semanticInfoChain);

            this.resolveFirstTypeParameterDeclaration(typeParameterSymbol, context);

            if (typeParameterSymbol.isResolved && this.canTypeCheckAST(typeParameterAST, context)) {
                this.typeCheckTypeParameterDeclaration(typeParameterAST, context);
            }

            return typeParameterSymbol;
        };

        PullTypeResolver.prototype.resolveFirstTypeParameterDeclaration = function (typeParameterSymbol, context) {
            var typeParameterDecl = typeParameterSymbol.getDeclarations()[0];
            var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecl);

            if (typeParameterSymbol.isResolved || typeParameterSymbol.inResolution) {
                return;
            }

            typeParameterSymbol.startResolving();

            if (typeParameterAST.constraint) {
                var constraintTypeSymbol = TypeScript.SyntaxFacts.isType(typeParameterAST.constraint.typeOrExpression.kind()) ? this.resolveTypeReference(typeParameterAST.constraint.typeOrExpression, context) : this.semanticInfoChain.anyTypeSymbol;

                if (constraintTypeSymbol) {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }

            typeParameterSymbol.setResolved();
        };

        PullTypeResolver.prototype.typeCheckTypeParameterDeclaration = function (typeParameterAST, context) {
            this.setTypeChecked(typeParameterAST, context);

            var constraint = this.resolveAST(typeParameterAST.constraint, false, context);

            if (constraint) {
                var typeParametersAST = typeParameterAST.parent;
                var typeParameters = [];
                for (var i = 0; i < typeParametersAST.length; i++) {
                    var currentTypeParameterAST = typeParametersAST[i];
                    var currentTypeParameterDecl = this.semanticInfoChain.getDeclForAST(currentTypeParameterAST);
                    var currentTypeParameter = this.semanticInfoChain.getSymbolForDecl(currentTypeParameterDecl);
                    typeParameters[currentTypeParameter.pullSymbolID] = currentTypeParameter;
                }

                if (constraint.wrapsSomeTypeParameter(typeParameters)) {
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list);
                }
            }
        };

        PullTypeResolver.prototype.resolveConstraint = function (constraint, context) {
            if (this.canTypeCheckAST(constraint, context)) {
                this.setTypeChecked(constraint, context);
            }

            return TypeScript.SyntaxFacts.isType(constraint.typeOrExpression.kind()) ? this.resolveTypeReference(constraint.typeOrExpression, context) : this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionBodyReturnTypes = function (funcDeclAST, block, bodyExpression, signature, useContextualType, enclosingDecl, context) {
            var _this = this;
            var returnStatementsExpressions = [];

            var enclosingDeclStack = [enclosingDecl];

            var preFindReturnExpressionTypes = function (ast, walker) {
                var go = true;

                switch (ast.kind()) {
                    case 151 /* ReturnStatement */:
                        var returnStatement = ast;
                        enclosingDecl.setFlag(4194304 /* HasReturnStatement */);
                        returnStatementsExpressions.push({ expression: returnStatement.expression, enclosingDecl: enclosingDeclStack[enclosingDeclStack.length - 1] });
                        go = false;
                        break;

                    case 237 /* CatchClause */:
                    case 164 /* WithStatement */:
                        enclosingDeclStack[enclosingDeclStack.length] = _this.semanticInfoChain.getDeclForAST(ast);
                        break;

                    default:
                        go = !TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(ast);
                        break;
                }

                walker.options.goChildren = go;

                return ast;
            };

            var postFindReturnExpressionEnclosingDecls = function (ast, walker) {
                switch (ast.kind()) {
                    case 237 /* CatchClause */:
                    case 164 /* WithStatement */:
                        enclosingDeclStack.length--;
                        break;
                    default:
                        break;
                }

                walker.options.goChildren = true;

                return ast;
            };

            if (block) {
                TypeScript.getAstWalkerFactory().walk(block, preFindReturnExpressionTypes, postFindReturnExpressionEnclosingDecls);
            } else {
                returnStatementsExpressions.push({ expression: bodyExpression, enclosingDecl: enclosingDecl });
                enclosingDecl.setFlag(4194304 /* HasReturnStatement */);
            }

            if (!returnStatementsExpressions.length) {
                signature.returnType = this.semanticInfoChain.voidTypeSymbol;
            } else {
                var returnExpressionSymbols = [];
                var returnExpressions = [];

                for (var i = 0; i < returnStatementsExpressions.length; i++) {
                    var returnExpression = returnStatementsExpressions[i].expression;
                    if (returnExpression) {
                        var returnType = this.resolveAST(returnExpression, useContextualType, context).type;

                        if (returnType.isError()) {
                            signature.returnType = returnType;
                            return;
                        } else {
                            if (returnExpression.parent.kind() === 151 /* ReturnStatement */) {
                                this.setSymbolForAST(returnExpression.parent, returnType, context);
                            }
                        }

                        returnExpressionSymbols.push(returnType);
                        returnExpressions.push(returnExpression);
                    }
                }

                if (!returnExpressionSymbols.length) {
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                } else {
                    var collection = {
                        getLength: function () {
                            return returnExpressionSymbols.length;
                        },
                        getTypeAtIndex: function (index) {
                            return returnExpressionSymbols[index].type;
                        }
                    };

                    var bestCommonReturnType = this.findBestCommonType(null, collection, context);
                    var returnType = bestCommonReturnType;
                    var returnExpression = returnExpressions[returnExpressionSymbols.indexOf(returnType)];

                    var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
                    var functionSymbol = functionDecl.getSymbol(this.semanticInfoChain);

                    if (returnType) {
                        var previousReturnType = returnType;
                        var newReturnType = returnType.widenedType(this, returnExpression, context);
                        signature.returnType = newReturnType;

                        if (!TypeScript.ArrayUtilities.contains(returnExpressionSymbols, bestCommonReturnType)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.No_best_common_type_exists_among_return_expressions));
                        }

                        if (this.compilationSettings.noImplicitAny()) {
                            if (previousReturnType !== newReturnType && newReturnType === this.semanticInfoChain.anyTypeSymbol) {
                                var functionName = enclosingDecl.name;
                                if (functionName === "") {
                                    functionName = enclosingDecl.getFunctionExpressionName();
                                }

                                if (functionName != "") {
                                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionName]));
                                } else {
                                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                                }
                            }
                        }
                    }

                    if (!functionSymbol.type && functionSymbol.isAccessor()) {
                        functionSymbol.type = signature.returnType;
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckConstructorDeclaration = function (funcDeclAST, context) {
            var _this = this;
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            for (var i = 0; i < funcDeclAST.callSignature.parameterList.parameters.length; i++) {
                this.resolveAST(funcDeclAST.callSignature.parameterList.parameters[i], false, context);
            }

            this.resolveAST(funcDeclAST.block, false, context);

            if (funcDecl.getSignatureSymbol(this.semanticInfoChain) && funcDecl.getSignatureSymbol(this.semanticInfoChain).isDefinition() && this.enclosingClassIsDerived(funcDecl.getParentDecl())) {
                if (!this.constructorHasSuperCall(funcDeclAST)) {
                    var syntaxTree = TypeScript.syntaxTree(funcDeclAST);
                    context.postDiagnostic(new TypeScript.Diagnostic(syntaxTree.fileName(), syntaxTree.lineMap(), TypeScript.start(funcDeclAST.constructorKeyword), TypeScript.width(funcDeclAST.constructorKeyword), TypeScript.DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call));
                } else if (this.superCallMustBeFirstStatementInConstructor(funcDecl)) {
                    var firstStatement = this.getFirstStatementOfBlockOrNull(funcDeclAST.block);
                    if (!firstStatement || !this.isSuperInvocationExpressionStatement(firstStatement)) {
                        var syntaxTree = TypeScript.syntaxTree(funcDeclAST);
                        context.postDiagnostic(new TypeScript.Diagnostic(syntaxTree.fileName(), syntaxTree.lineMap(), TypeScript.start(funcDeclAST.constructorKeyword), TypeScript.width(funcDeclAST.constructorKeyword), TypeScript.DiagnosticCode.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties));
                    }
                }
            }

            this.validateVariableDeclarationGroups(funcDecl, context);

            this.checkFunctionTypePrivacy(funcDeclAST, false, null, funcDeclAST.callSignature.parameterList.parameters, null, funcDeclAST.block, context);

            this.typeCheckCallBacks.push(function (context) {
                _this.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        };

        PullTypeResolver.prototype.constructorHasSuperCall = function (constructorDecl) {
            var _this = this;
            if (constructorDecl.block) {
                var foundSuperCall = false;
                var pre = function (ast, walker) {
                    if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(ast)) {
                        walker.options.goChildren = false;
                        return;
                    }

                    if (_this.isSuperInvocationExpression(ast)) {
                        foundSuperCall = true;
                        walker.options.stopWalking = true;
                    }
                };

                TypeScript.getAstWalkerFactory().walk(constructorDecl.block, pre);
                return foundSuperCall;
            }

            return false;
        };

        PullTypeResolver.prototype.typeCheckFunctionExpression = function (funcDecl, isContextuallyTyped, context) {
            this.typeCheckAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList.parameters, funcDecl.callSignature.typeAnnotation, funcDecl.block, null, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.typeCheckCallSignature = function (funcDecl, context) {
            this.typeCheckAnyFunctionDeclaration(funcDecl, false, null, funcDecl.typeParameterList, funcDecl.parameterList, TypeScript.ASTHelpers.getType(funcDecl), null, context);
        };

        PullTypeResolver.prototype.typeCheckConstructSignature = function (funcDecl, context) {
            this.typeCheckAnyFunctionDeclaration(funcDecl, false, null, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), null, context);
        };

        PullTypeResolver.prototype.typeCheckMethodSignature = function (funcDecl, context) {
            this.typeCheckAnyFunctionDeclaration(funcDecl, false, funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), null, context);
        };

        PullTypeResolver.prototype.typeCheckMemberFunctionDeclaration = function (funcDecl, context) {
            this.typeCheckAnyFunctionDeclaration(funcDecl, TypeScript.hasModifier(funcDecl.modifiers, 16 /* Static */), funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), funcDecl.block, context);
        };

        PullTypeResolver.prototype.containsSingleThrowStatement = function (block) {
            return block !== null && block.statements.length === 1 && block.statements[0].kind() === 158 /* ThrowStatement */;
        };

        PullTypeResolver.prototype.typeCheckAnyFunctionDeclaration = function (funcDeclAST, isStatic, name, typeParameters, parameters, returnTypeAnnotation, block, context) {
            var _this = this;
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            this.resolveAST(parameters, false, context);

            this.resolveAST(block, false, context);
            var enclosingDecl = this.getEnclosingDecl(funcDecl);

            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);
            this.validateVariableDeclarationGroups(funcDecl, context);

            this.checkFunctionTypePrivacy(funcDeclAST, isStatic, typeParameters, parameters.parameters, returnTypeAnnotation, block, context);

            this.checkThatNonVoidFunctionHasReturnExpressionOrThrowStatement(funcDecl, returnTypeAnnotation, funcDecl.getSignatureSymbol(this.semanticInfoChain).returnType, block, context);

            if (funcDecl.kind === 16384 /* Function */) {
                this.checkNameForCompilerGeneratedDeclarationCollision(funcDeclAST, true, name, context);
            }

            if (this.compilationSettings.noImplicitAny() && block === null && returnTypeAnnotation === null) {
                this.checkAndReportImplicitAnyOnFunctionSignature(funcDeclAST, name, context);
            }

            this.typeCheckCallBacks.push(function (context) {
                _this.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        };

        PullTypeResolver.prototype.checkAndReportImplicitAnyOnFunctionSignature = function (funcDeclAST, funcDeclASTName, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            if (this.isPrivateWithinAmbientDeclaration(funcDecl)) {
                return;
            }

            if (funcDecl.kind === 2097152 /* ConstructSignature */) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
            } else if (funcDeclASTName !== null) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [funcDeclASTName.text()]));
            } else {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
            }
        };

        PullTypeResolver.prototype.isPrivateWithinAmbientDeclaration = function (funcDecl) {
            if (TypeScript.hasFlag(funcDecl.flags, 2 /* Private */)) {
                var parentDecl = funcDecl.getParentDecl();

                if (parentDecl !== null) {
                    return TypeScript.hasFlag(parentDecl.flags, 8 /* Ambient */);
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkThatNonVoidFunctionHasReturnExpressionOrThrowStatement = function (functionDecl, returnTypeAnnotation, returnTypeSymbol, block, context) {
            var hasReturn = TypeScript.hasFlag(functionDecl.flags, 4194304 /* HasReturnStatement */);

            if (block !== null && returnTypeAnnotation !== null && !hasReturn) {
                var isVoidOrAny = this.isAnyOrEquivalent(returnTypeSymbol) || returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol;

                if (!isVoidOrAny && !this.containsSingleThrowStatement(block)) {
                    var funcName = functionDecl.getDisplayName() || TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);

                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, TypeScript.DiagnosticCode.Function_declared_a_non_void_return_type_but_has_no_return_expression));
                }
            }
        };

        PullTypeResolver.prototype.typeCheckIndexSignature = function (funcDeclAST, context) {
            var _this = this;
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            this.resolveAST(funcDeclAST.parameters, false, context);

            var enclosingDecl = this.getEnclosingDecl(funcDecl);

            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, TypeScript.ASTHelpers.getType(funcDeclAST), context);
            this.validateVariableDeclarationGroups(funcDecl, context);

            this.checkFunctionTypePrivacy(funcDeclAST, false, null, funcDeclAST.parameters, TypeScript.ASTHelpers.getType(funcDeclAST), null, context);

            var signature = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            this.typeCheckCallBacks.push(function (context) {
                var parentSymbol = funcDecl.getSignatureSymbol(_this.semanticInfoChain).getContainer();
                var allIndexSignatures = _this.getBothKindsOfIndexSignaturesExcludingAugmentedType(parentSymbol, context);
                var stringIndexSignature = allIndexSignatures.stringSignature;
                var numberIndexSignature = allIndexSignatures.numericSignature;
                var isNumericIndexer = numberIndexSignature === signature;

                if (numberIndexSignature && stringIndexSignature && (isNumericIndexer || stringIndexSignature.getDeclarations()[0].getParentDecl() !== numberIndexSignature.getDeclarations()[0].getParentDecl())) {
                    var comparisonInfo = new TypeComparisonInfo();

                    if (!_this.sourceIsAssignableToTarget(numberIndexSignature.returnType, stringIndexSignature.returnType, funcDeclAST, context, comparisonInfo)) {
                        var enclosingSymbol = _this.getEnclosingSymbolForAST(funcDeclAST);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1_NL_2, [numberIndexSignature.returnType.toString(enclosingSymbol), stringIndexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                        } else {
                            context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1, [numberIndexSignature.returnType.toString(enclosingSymbol), stringIndexSignature.returnType.toString(enclosingSymbol)]));
                        }
                    }
                }

                var allMembers = parentSymbol.type.getAllMembers(536869887 /* All */, 0 /* all */);
                for (var i = 0; i < allMembers.length; i++) {
                    var member = allMembers[i];
                    var name = member.name;
                    if (name || (member.kind === 4096 /* Property */ && name === "")) {
                        if (!allMembers[i].isResolved) {
                            _this.resolveDeclaredSymbol(allMembers[i], context);
                        }

                        if (parentSymbol !== allMembers[i].getContainer()) {
                            var isMemberNumeric = TypeScript.PullHelpers.isNameNumeric(name);
                            var indexerKindMatchesMemberNameKind = isNumericIndexer === isMemberNumeric;
                            var onlyStringIndexerIsPresent = !numberIndexSignature;

                            if (indexerKindMatchesMemberNameKind || onlyStringIndexerIsPresent) {
                                var comparisonInfo = new TypeComparisonInfo();
                                if (!_this.sourceIsAssignableToTarget(allMembers[i].type, signature.returnType, funcDeclAST, context, comparisonInfo, false)) {
                                    _this.reportErrorThatMemberIsNotSubtypeOfIndexer(allMembers[i], signature, funcDeclAST, context, comparisonInfo);
                                }
                            }
                        }
                    }
                }
            });
        };

        PullTypeResolver.prototype.postTypeCheckFunctionDeclaration = function (funcDeclAST, context) {
            this.checkThisCaptureVariableCollides(funcDeclAST, true, context);
        };

        PullTypeResolver.prototype.resolveReturnTypeAnnotationOfFunctionDeclaration = function (funcDeclAST, returnTypeAnnotation, context) {
            var returnTypeSymbol = null;

            if (returnTypeAnnotation) {
                var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

                returnTypeSymbol = this.resolveTypeReference(returnTypeAnnotation, context);

                if (!returnTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference));
                } else {
                    var isConstructor = funcDeclAST.kind() === 138 /* ConstructorDeclaration */ || funcDeclAST.kind() === 144 /* ConstructSignature */;
                    if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void));
                    }
                }
            }

            return returnTypeSymbol;
        };

        PullTypeResolver.prototype.resolveMemberFunctionDeclaration = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, TypeScript.hasModifier(funcDecl.modifiers, 16 /* Static */), funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), funcDecl.block, context);
        };

        PullTypeResolver.prototype.resolveCallSignature = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, false, null, funcDecl.typeParameterList, funcDecl.parameterList, TypeScript.ASTHelpers.getType(funcDecl), null, context);
        };

        PullTypeResolver.prototype.resolveConstructSignature = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, false, null, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), null, context);
        };

        PullTypeResolver.prototype.resolveMethodSignature = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, false, funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), null, context);
        };

        PullTypeResolver.prototype.resolveAnyFunctionDeclaration = function (funcDecl, context) {
            return this.resolveFunctionDeclaration(funcDecl, TypeScript.hasModifier(funcDecl.modifiers, 16 /* Static */), funcDecl.identifier, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), funcDecl.block, context);
        };

        PullTypeResolver.prototype.resolveFunctionExpression = function (funcDecl, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(funcDecl), funcDecl.block, null, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.resolveSimpleArrowFunctionExpression = function (funcDecl, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcDecl, null, [funcDecl.parameter], null, funcDecl.block, funcDecl.expression, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.resolveParenthesizedArrowFunctionExpression = function (funcDecl, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(funcDecl), funcDecl.block, funcDecl.expression, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.getEnclosingClassDeclaration = function (ast) {
            while (ast) {
                if (ast.kind() === 132 /* ClassDeclaration */) {
                    return ast;
                }

                ast = ast.parent;
            }

            return null;
        };

        PullTypeResolver.prototype.resolveConstructorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var signature = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckConstructorDeclaration(funcDeclAST, context);
                    }
                    return funcSymbol;
                }

                if (!signature.inResolution) {
                    var classAST = this.getEnclosingClassDeclaration(funcDeclAST);

                    if (classAST) {
                        var classDecl = this.semanticInfoChain.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol(this.semanticInfoChain);

                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, context);
                        }
                    }
                }

                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                var prevInTypeCheck = context.inTypeCheck;

                context.inTypeCheck = false;

                for (var i = 0; i < funcDeclAST.callSignature.parameterList.parameters.length; i++) {
                    this.resolveParameter(funcDeclAST.callSignature.parameterList.parameters[i], context);
                }

                context.inTypeCheck = prevInTypeCheck;

                if (signature.isGeneric()) {
                    if (funcSymbol) {
                        funcSymbol.type.setHasGenericSignature();
                    }
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckConstructorDeclaration(funcDeclAST, context);
            }

            return funcSymbol;
        };

        PullTypeResolver.prototype.resolveIndexMemberDeclaration = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
            }

            return this.resolveIndexSignature(ast.indexSignature, context);
        };

        PullTypeResolver.prototype.resolveIndexSignature = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var signature = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckIndexSignature(funcDeclAST, context);
                    }
                    return funcSymbol;
                }

                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {
                    if (funcDeclAST.typeAnnotation) {
                        var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.typeAnnotation.type, context);
                        if (!returnTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(TypeScript.ASTHelpers.getType(funcDeclAST), TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference));
                            signature.returnType = this.getNewErrorTypeSymbol();
                            hadError = true;
                        } else {
                            signature.returnType = returnTypeSymbol;
                        }
                    } else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                if (funcDeclAST.parameters.length === 1) {
                    var prevInTypeCheck = context.inTypeCheck;

                    context.inTypeCheck = false;
                    this.resolveParameter(funcDeclAST.parameters[0], context);
                    context.inTypeCheck = prevInTypeCheck;
                }

                if (funcDeclAST.typeAnnotation) {
                    returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, TypeScript.ASTHelpers.getType(funcDeclAST), context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    } else {
                        signature.returnType = returnTypeSymbol;
                    }
                } else {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckIndexSignature(funcDeclAST, context);
            }

            return funcSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionDeclaration = function (funcDeclAST, isStatic, name, typeParameters, parameterList, returnTypeAnnotation, block, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var signature = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            var isConstructor = funcDeclAST.kind() === 144 /* ConstructSignature */;

            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckAnyFunctionDeclaration(funcDeclAST, isStatic, name, typeParameters, parameterList, returnTypeAnnotation, block, context);
                    }
                    return funcSymbol;
                }

                if (isConstructor && !signature.inResolution) {
                    var classAST = this.getEnclosingClassDeclaration(funcDeclAST);

                    if (classAST) {
                        var classDecl = this.semanticInfoChain.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol(this.semanticInfoChain);

                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, context);
                        }
                    }
                }

                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {
                    if (returnTypeAnnotation) {
                        var returnTypeSymbol = this.resolveTypeReference(returnTypeAnnotation, context);
                        if (!returnTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference));
                            signature.returnType = this.getNewErrorTypeSymbol();
                            hadError = true;
                        } else {
                            signature.returnType = returnTypeSymbol;

                            if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void));
                            }
                        }
                    } else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                if (typeParameters) {
                    for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                        this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                    }
                }

                if (parameterList) {
                    var prevInTypeCheck = context.inTypeCheck;

                    context.inTypeCheck = false;

                    for (var i = 0; i < parameterList.parameters.length; i++) {
                        this.resolveParameter(parameterList.parameters[i], context);
                    }

                    context.inTypeCheck = prevInTypeCheck;
                }

                if (returnTypeAnnotation) {
                    returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    } else {
                        signature.returnType = returnTypeSymbol;
                    }
                } else if (funcDecl.kind !== 2097152 /* ConstructSignature */) {
                    if (TypeScript.hasFlag(funcDecl.flags, 2048 /* Signature */)) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, null, signature, false, funcDecl, context);
                    }
                } else {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckAnyFunctionDeclaration(funcDeclAST, isStatic, name, typeParameters, parameterList, returnTypeAnnotation, block, context);
            }

            return funcSymbol;
        };

        PullTypeResolver.prototype.resolveGetterReturnTypeAnnotation = function (getterFunctionDeclarationAst, enclosingDecl, context) {
            if (getterFunctionDeclarationAst && getterFunctionDeclarationAst.callSignature.typeAnnotation) {
                return this.resolveTypeReference(TypeScript.ASTHelpers.getType(getterFunctionDeclarationAst), context);
            }

            return null;
        };

        PullTypeResolver.prototype.resolveSetterArgumentTypeAnnotation = function (setterFunctionDeclarationAst, enclosingDecl, context) {
            if (setterFunctionDeclarationAst && setterFunctionDeclarationAst.callSignature.parameterList && setterFunctionDeclarationAst.callSignature.parameterList.parameters.length > 0) {
                var parameter = setterFunctionDeclarationAst.callSignature.parameterList.parameters[0];
                return this.resolveTypeReference(TypeScript.ASTHelpers.getType(parameter), context);
            }

            return null;
        };

        PullTypeResolver.prototype.resolveAccessorDeclaration = function (funcDeclAst, context) {
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDeclAst);
            var accessorSymbol = functionDeclaration.getSymbol(this.semanticInfoChain);

            if (accessorSymbol.inResolution) {
                accessorSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                accessorSymbol.setResolved();

                return accessorSymbol;
            }

            if (accessorSymbol.isResolved) {
                if (!accessorSymbol.type) {
                    accessorSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                var getterSymbol = accessorSymbol.getGetter();
                var getterFunctionDeclarationAst = getterSymbol ? getterSymbol.getDeclarations()[0].ast() : null;
                var hasGetter = getterSymbol !== null;

                var setterSymbol = accessorSymbol.getSetter();
                var setterFunctionDeclarationAst = setterSymbol ? setterSymbol.getDeclarations()[0].ast() : null;
                var hasSetter = setterSymbol !== null;

                var getterAnnotatedType = this.resolveGetterReturnTypeAnnotation(getterFunctionDeclarationAst, functionDeclaration, context);
                var getterHasTypeAnnotation = getterAnnotatedType !== null;

                var setterAnnotatedType = this.resolveSetterArgumentTypeAnnotation(setterFunctionDeclarationAst, functionDeclaration, context);
                var setterHasTypeAnnotation = setterAnnotatedType !== null;

                accessorSymbol.startResolving();

                if (hasGetter) {
                    getterSymbol = this.resolveGetAccessorDeclaration(getterFunctionDeclarationAst, getterFunctionDeclarationAst.callSignature.parameterList, TypeScript.ASTHelpers.getType(getterFunctionDeclarationAst), getterFunctionDeclarationAst.block, setterAnnotatedType, context);
                }

                if (hasSetter) {
                    setterSymbol = this.resolveSetAccessorDeclaration(setterFunctionDeclarationAst, setterFunctionDeclarationAst.callSignature.parameterList, context);
                }

                if (hasGetter && hasSetter) {
                    var setterSig = setterSymbol.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;
                    var setterHasParameters = setterParameters.length > 0;
                    var getterSig = getterSymbol.type.getCallSignatures()[0];

                    var setterSuppliedTypeSymbol = setterHasParameters ? setterParameters[0].type : null;
                    var getterSuppliedTypeSymbol = getterSig.returnType;

                    if (setterHasTypeAnnotation && !getterHasTypeAnnotation) {
                        getterSuppliedTypeSymbol = setterSuppliedTypeSymbol;
                        getterSig.returnType = setterSuppliedTypeSymbol;
                    } else if ((getterHasTypeAnnotation && !setterHasTypeAnnotation) || (!getterHasTypeAnnotation && !setterHasTypeAnnotation)) {
                        setterSuppliedTypeSymbol = getterSuppliedTypeSymbol;

                        if (setterHasParameters) {
                            setterParameters[0].type = getterSuppliedTypeSymbol;
                        }
                    }

                    if (!this.typesAreIdentical(setterSuppliedTypeSymbol, getterSuppliedTypeSymbol, context)) {
                        accessorSymbol.type = this.getNewErrorTypeSymbol();
                    } else {
                        accessorSymbol.type = getterSuppliedTypeSymbol;
                    }
                } else if (hasSetter) {
                    var setterSig = setterSymbol.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;
                    var setterHasParameters = setterParameters.length > 0;

                    accessorSymbol.type = setterHasParameters ? setterParameters[0].type : this.semanticInfoChain.anyTypeSymbol;
                } else {
                    var getterSig = getterSymbol.type.getCallSignatures()[0];
                    accessorSymbol.type = getterSig.returnType;
                }

                accessorSymbol.setResolved();
            }

            if (this.canTypeCheckAST(funcDeclAst, context)) {
                this.typeCheckAccessorDeclaration(funcDeclAst, context);
            }

            return accessorSymbol;
        };

        PullTypeResolver.prototype.typeCheckAccessorDeclaration = function (funcDeclAst, context) {
            this.setTypeChecked(funcDeclAst, context);
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDeclAst);
            var accessorSymbol = functionDeclaration.getSymbol(this.semanticInfoChain);
            var getterSymbol = accessorSymbol.getGetter();
            var setterSymbol = accessorSymbol.getSetter();

            var isGetter = funcDeclAst.kind() === 140 /* GetAccessor */;
            if (isGetter) {
                var getterFunctionDeclarationAst = funcDeclAst;
                context.pushNewContextualType(getterSymbol.type);
                this.typeCheckGetAccessorDeclaration(getterFunctionDeclarationAst, context);
                context.popAnyContextualType();
            } else {
                var setterFunctionDeclarationAst = funcDeclAst;
                this.typeCheckSetAccessorDeclaration(setterFunctionDeclarationAst, context);
            }
        };

        PullTypeResolver.prototype.resolveGetAccessorDeclaration = function (funcDeclAST, parameters, returnTypeAnnotation, block, setterAnnotatedType, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = getterSymbol.type;

            var signature = getterTypeSymbol.getCallSignatures()[0];

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    return getterSymbol;
                }

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    signature.setResolved();

                    return getterSymbol;
                }

                signature.startResolving();

                if (returnTypeAnnotation) {
                    var returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();

                        hadError = true;
                    } else {
                        signature.returnType = returnTypeSymbol;
                    }
                } else {
                    if (!setterAnnotatedType) {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, null, signature, false, funcDecl, context);
                    } else {
                        signature.returnType = setterAnnotatedType;
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            return getterSymbol;
        };

        PullTypeResolver.prototype.checkIfGetterAndSetterTypeMatch = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol(this.semanticInfoChain);
            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();

            if (getter && setter) {
                var getterAST = getter.getDeclarations()[0].ast();
                var setterAST = setter.getDeclarations()[0].ast();

                if (getterAST.callSignature.typeAnnotation && PullTypeResolver.hasSetAccessorParameterTypeAnnotation(setterAST)) {
                    var setterSig = setter.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;

                    var getter = accessorSymbol.getGetter();
                    var getterSig = getter.type.getCallSignatures()[0];

                    var setterSuppliedTypeSymbol = setterParameters[0].type;
                    var getterSuppliedTypeSymbol = getterSig.returnType;

                    if (!this.typesAreIdentical(setterSuppliedTypeSymbol, getterSuppliedTypeSymbol, context)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.get_and_set_accessor_must_have_the_same_type));
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckGetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, TypeScript.ASTHelpers.getType(funcDeclAST), context);

            this.resolveAST(funcDeclAST.block, false, context);

            this.validateVariableDeclarationGroups(funcDecl, context);

            var enclosingDecl = this.getEnclosingDecl(funcDecl);

            var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) !== 0;
            var funcNameAST = funcDeclAST.propertyName;

            if (!hasReturn && !this.containsSingleThrowStatement(funcDeclAST.block)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, TypeScript.DiagnosticCode.Getters_must_return_a_value));
            }

            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                var setterIsPrivate = TypeScript.hasFlag(setterDecl.flags, 2 /* Private */);
                var getterIsPrivate = TypeScript.hasModifier(funcDeclAST.modifiers, 2 /* Private */);

                if (getterIsPrivate !== setterIsPrivate) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility));
                }

                this.checkIfGetterAndSetterTypeMatch(funcDeclAST, context);
            }

            this.checkFunctionTypePrivacy(funcDeclAST, TypeScript.hasModifier(funcDeclAST.modifiers, 16 /* Static */), null, funcDeclAST.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(funcDeclAST), funcDeclAST.block, context);
        };

        PullTypeResolver.hasSetAccessorParameterTypeAnnotation = function (setAccessor) {
            return setAccessor.callSignature.parameterList && setAccessor.callSignature.parameterList.parameters.length > 0 && setAccessor.callSignature.parameterList.parameters[0].typeAnnotation !== null;
        };

        PullTypeResolver.prototype.resolveSetAccessorDeclaration = function (funcDeclAST, parameterList, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = setterSymbol.type;

            var signature = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    return setterSymbol;
                }

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                    signature.setResolved();
                    return setterSymbol;
                }

                signature.startResolving();

                if (parameterList) {
                    for (var i = 0; i < parameterList.parameters.length; i++) {
                        this.resolveParameter(parameterList.parameters[i], context);
                    }
                }

                signature.returnType = this.semanticInfoChain.voidTypeSymbol;

                if (!hadError) {
                    signature.setResolved();
                }
            }

            return setterSymbol;
        };

        PullTypeResolver.prototype.typeCheckSetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            if (funcDeclAST.callSignature.parameterList) {
                for (var i = 0; i < funcDeclAST.callSignature.parameterList.parameters.length; i++) {
                    this.resolveParameter(funcDeclAST.callSignature.parameterList.parameters[i], context);
                }
            }

            this.resolveAST(funcDeclAST.block, false, context);

            this.validateVariableDeclarationGroups(funcDecl, context);

            var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) !== 0;

            var getter = accessorSymbol.getGetter();

            var funcNameAST = funcDeclAST.propertyName;

            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                var getterIsPrivate = TypeScript.hasFlag(getterDecl.flags, 2 /* Private */);
                var setterIsPrivate = TypeScript.hasModifier(funcDeclAST.modifiers, 2 /* Private */);

                if (getterIsPrivate !== setterIsPrivate) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility));
                }

                this.checkIfGetterAndSetterTypeMatch(funcDeclAST, context);
            } else {
                if (this.compilationSettings.noImplicitAny()) {
                    var setterFunctionDeclarationAst = funcDeclAST;

                    if (!PullTypeResolver.hasSetAccessorParameterTypeAnnotation(setterFunctionDeclarationAst) && accessorSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type, [setterFunctionDeclarationAst.propertyName.text()]));
                    }
                }
            }

            this.checkFunctionTypePrivacy(funcDeclAST, TypeScript.hasModifier(funcDeclAST.modifiers, 16 /* Static */), null, funcDeclAST.callSignature.parameterList.parameters, null, funcDeclAST.block, context);
        };

        PullTypeResolver.prototype.resolveList = function (list, context) {
            if (this.canTypeCheckAST(list, context)) {
                this.setTypeChecked(list, context);

                for (var i = 0, n = list.length; i < n; i++) {
                    this.resolveAST(list[i], false, context);
                }
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveSeparatedList = function (list, context) {
            if (this.canTypeCheckAST(list, context)) {
                this.setTypeChecked(list, context);

                for (var i = 0, n = list.length; i < n; i++) {
                    this.resolveAST(list[i], false, context);
                }
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVoidExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, false, context);
            }

            return this.semanticInfoChain.undefinedTypeSymbol;
        };

        PullTypeResolver.prototype.resolveLogicalOperation = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLogicalOperation(ast, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckLogicalOperation = function (binex, context) {
            this.setTypeChecked(binex, context);

            var leftType = this.resolveAST(binex.left, false, context).type;
            var rightType = this.resolveAST(binex.right, false, context).type;

            var comparisonInfo = new TypeComparisonInfo();
            if (!this.sourceIsAssignableToTarget(leftType, rightType, binex, context, comparisonInfo) && !this.sourceIsAssignableToTarget(rightType, leftType, binex, context, comparisonInfo)) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(binex);
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binex, TypeScript.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, [
                    TypeScript.SyntaxFacts.getText(TypeScript.SyntaxFacts.getOperatorTokenFromBinaryExpression(binex.kind())),
                    leftType.toString(enclosingSymbol), rightType.toString(enclosingSymbol)]));
            }
        };

        PullTypeResolver.prototype.resolveLogicalNotExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.operand, false, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.resolveUnaryArithmeticOperation = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckUnaryArithmeticOperation(ast, context);
            }

            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeResolver.prototype.resolvePostfixUnaryExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckPostfixUnaryExpression(ast, context);
            }

            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeResolver.prototype.isAnyOrNumberOrEnum = function (type) {
            return this.isAnyOrEquivalent(type) || type === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(type);
        };

        PullTypeResolver.prototype.typeCheckUnaryArithmeticOperation = function (unaryExpression, context) {
            this.setTypeChecked(unaryExpression, context);

            var nodeType = unaryExpression.kind();
            var expression = this.resolveAST(unaryExpression.operand, false, context);

            if (nodeType === 165 /* PlusExpression */ || nodeType == 166 /* NegateExpression */ || nodeType == 167 /* BitwiseNotExpression */) {
                return;
            }

            TypeScript.Debug.assert(nodeType === 169 /* PreIncrementExpression */ || nodeType === 170 /* PreDecrementExpression */);

            var operandType = expression.type;
            if (!this.isAnyOrNumberOrEnum(operandType)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type));
            }

            if (!this.isReference(unaryExpression.operand, expression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer));
            }
        };

        PullTypeResolver.prototype.typeCheckPostfixUnaryExpression = function (unaryExpression, context) {
            this.setTypeChecked(unaryExpression, context);

            var nodeType = unaryExpression.kind();
            var expression = this.resolveAST(unaryExpression.operand, false, context);

            TypeScript.Debug.assert(nodeType === 211 /* PostIncrementExpression */ || nodeType === 212 /* PostDecrementExpression */);

            var operandType = expression.type;
            if (!this.isAnyOrNumberOrEnum(operandType)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type));
            }

            if (!this.isReference(unaryExpression.operand, expression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, TypeScript.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer));
            }
        };

        PullTypeResolver.prototype.resolveBinaryArithmeticExpression = function (binaryExpression, context) {
            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.typeCheckBinaryArithmeticExpression(binaryExpression, context);
            }

            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckBinaryArithmeticExpression = function (binaryExpression, context) {
            this.setTypeChecked(binaryExpression, context);

            var lhsSymbol = this.resolveAST(binaryExpression.left, false, context);

            var lhsType = lhsSymbol.type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;

            if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                lhsType = rhsType;
            }

            if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                rhsType = lhsType;
            }

            var lhsIsFit = this.isAnyOrNumberOrEnum(lhsType);
            var rhsIsFit = this.isAnyOrNumberOrEnum(rhsType);

            if (!rhsIsFit) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, TypeScript.DiagnosticCode.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type));
            }

            if (!lhsIsFit) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type));
            }

            if (lhsIsFit && rhsIsFit) {
                switch (binaryExpression.kind()) {
                    case 184 /* LeftShiftAssignmentExpression */:
                    case 185 /* SignedRightShiftAssignmentExpression */:
                    case 186 /* UnsignedRightShiftAssignmentExpression */:
                    case 177 /* SubtractAssignmentExpression */:
                    case 178 /* MultiplyAssignmentExpression */:
                    case 179 /* DivideAssignmentExpression */:
                    case 180 /* ModuloAssignmentExpression */:
                    case 183 /* OrAssignmentExpression */:
                    case 181 /* AndAssignmentExpression */:
                    case 182 /* ExclusiveOrAssignmentExpression */:
                        if (!this.isReference(binaryExpression.left, lhsSymbol)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                        }

                        this.checkAssignability(binaryExpression.left, rhsType, lhsType, context);
                }
            }
        };

        PullTypeResolver.prototype.resolveTypeOfExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, false, context);
            }

            return this.semanticInfoChain.stringTypeSymbol;
        };

        PullTypeResolver.prototype.resolveThrowStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveDeleteExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.expression, false, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.resolveInstanceOfExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInstanceOfExpression(ast, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckInstanceOfExpression = function (binaryExpression, context) {
            this.setTypeChecked(binaryExpression, context);

            var lhsType = this.resolveAST(binaryExpression.left, false, context).type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;

            var enclosingSymbol = this.getEnclosingSymbolForAST(binaryExpression);
            var isValidLHS = this.isAnyOrEquivalent(lhsType) || lhsType.isObject() || lhsType.isTypeParameter();
            var isValidRHS = this.isAnyOrEquivalent(rhsType) || this.typeIsAssignableToFunction(rhsType, binaryExpression, context);

            if (!isValidLHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }

            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, TypeScript.DiagnosticCode.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type));
            }
        };

        PullTypeResolver.prototype.resolveCommaExpression = function (commaExpression, context) {
            if (this.canTypeCheckAST(commaExpression, context)) {
                this.setTypeChecked(commaExpression, context);

                this.resolveAST(commaExpression.left, false, context);
            }

            return this.resolveAST(commaExpression.right, false, context).type;
        };

        PullTypeResolver.prototype.resolveInExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInExpression(ast, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckInExpression = function (binaryExpression, context) {
            this.setTypeChecked(binaryExpression, context);

            var lhsType = this.resolveAST(binaryExpression.left, false, context).type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;

            var isValidLHS = this.isAnyOrEquivalent(lhsType.type) || lhsType.type === this.semanticInfoChain.stringTypeSymbol || lhsType.type === this.semanticInfoChain.numberTypeSymbol;

            var isValidRHS = this.isAnyOrEquivalent(rhsType) || rhsType.isObject() || rhsType.isTypeParameter();

            if (!isValidLHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number));
            }

            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, TypeScript.DiagnosticCode.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }
        };

        PullTypeResolver.prototype.resolveForStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.variableDeclaration, false, context);
                this.resolveAST(ast.initializer, false, context);
                this.resolveAST(ast.condition, false, context);
                this.resolveAST(ast.incrementor, false, context);
                this.resolveAST(ast.statement, false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveForInStatement = function (forInStatement, context) {
            if (this.canTypeCheckAST(forInStatement, context)) {
                this.typeCheckForInStatement(forInStatement, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckForInStatement = function (forInStatement, context) {
            this.setTypeChecked(forInStatement, context);

            if (forInStatement.variableDeclaration) {
                var declaration = forInStatement.variableDeclaration;

                if (declaration.variableDeclarators.length === 1) {
                    var varDecl = declaration.variableDeclarators[0];

                    if (varDecl.typeAnnotation) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declaration, TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation));
                    }
                }
            } else {
                var varSym = this.resolveAST(forInStatement.left, false, context);
                var isStringOrNumber = varSym.type === this.semanticInfoChain.stringTypeSymbol || this.isAnyOrEquivalent(varSym.type);

                if (!isStringOrNumber) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(forInStatement.left, TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any));
                }
            }

            var rhsType = this.resolveAST(forInStatement.expression, false, context).type;
            var isValidRHS = rhsType && (this.isAnyOrEquivalent(rhsType) || rhsType.isObject() || rhsType.isTypeParameter());

            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(forInStatement.expression, TypeScript.DiagnosticCode.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }

            this.resolveAST(forInStatement.statement, false, context);
        };

        PullTypeResolver.prototype.resolveWhileStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWhileStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckWhileStatement = function (ast, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.condition, false, context);
            this.resolveAST(ast.statement, false, context);
        };

        PullTypeResolver.prototype.resolveDoStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckDoStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckDoStatement = function (ast, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.condition, false, context);
            this.resolveAST(ast.statement, false, context);
        };

        PullTypeResolver.prototype.resolveIfStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckIfStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckIfStatement = function (ast, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.condition, false, context);
            this.resolveAST(ast.statement, false, context);
            this.resolveAST(ast.elseClause, false, context);
        };

        PullTypeResolver.prototype.resolveElseClause = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckElseClause(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckElseClause = function (ast, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.statement, false, context);
        };

        PullTypeResolver.prototype.resolveBlock = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.checkFunctionOverloadChains(ast, ast.statements);
                this.resolveAST(ast.statements, false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVariableStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.variableDeclaration, false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVariableDeclarationList = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.variableDeclarators, false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveWithStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWithStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckWithStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            var withStatement = ast;
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(withStatement.condition, TypeScript.DiagnosticCode.All_symbols_within_a_with_block_will_be_resolved_to_any));
        };

        PullTypeResolver.prototype.resolveTryStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckTryStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckTryStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
            var tryStatement = ast;

            this.resolveAST(tryStatement.block, false, context);
            this.resolveAST(tryStatement.catchClause, false, context);
            this.resolveAST(tryStatement.finallyClause, false, context);
        };

        PullTypeResolver.prototype.resolveCatchClause = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckCatchClause(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckCatchClause = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.block, false, context);

            var catchDecl = this.semanticInfoChain.getDeclForAST(ast);
            this.validateVariableDeclarationGroups(catchDecl, context);
        };

        PullTypeResolver.prototype.resolveFinallyClause = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckFinallyClause(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckFinallyClause = function (ast, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.block, false, context);
        };

        PullTypeResolver.prototype.getEnclosingFunctionDeclaration = function (ast) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);

            while (enclosingDecl) {
                if (enclosingDecl.kind & 1032192 /* SomeFunction */) {
                    return enclosingDecl;
                }

                enclosingDecl = enclosingDecl.getParentDecl();
            }

            return null;
        };

        PullTypeResolver.prototype.resolveReturnExpression = function (expression, enclosingFunction, context) {
            if (enclosingFunction) {
                enclosingFunction.setFlag(4194304 /* HasReturnStatement */);
            }

            var isContextuallyTyped = false;

            if (enclosingFunction) {
                var enclosingDeclAST = this.getASTForDecl(enclosingFunction);
                var typeAnnotation = TypeScript.ASTHelpers.getType(enclosingDeclAST);
                if (typeAnnotation) {
                    var returnTypeAnnotationSymbol = this.resolveTypeReference(typeAnnotation, context);
                    if (returnTypeAnnotationSymbol) {
                        isContextuallyTyped = true;
                        context.pushNewContextualType(returnTypeAnnotationSymbol);
                    }
                } else {
                    var currentContextualType = context.getContextualType();
                    if (currentContextualType && currentContextualType.isFunction()) {
                        var contextualSignatures = currentContextualType.kind == 33554432 /* ConstructorType */ ? currentContextualType.getConstructSignatures() : currentContextualType.getCallSignatures();
                        var currentContextualTypeSignatureSymbol = contextualSignatures[0];

                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                        if (currentContextualTypeReturnTypeSymbol) {
                            isContextuallyTyped = true;
                            context.propagateContextualType(currentContextualTypeReturnTypeSymbol);
                        }
                    }
                }
            }

            var result = this.resolveAST(expression, isContextuallyTyped, context).type;
            if (isContextuallyTyped) {
                context.popAnyContextualType();
            }

            return result;
        };

        PullTypeResolver.prototype.typeCheckReturnExpression = function (expression, expressionType, enclosingFunction, context) {
            if (enclosingFunction && enclosingFunction.kind === 32768 /* ConstructorMethod */) {
                var classDecl = enclosingFunction.getParentDecl();
                if (classDecl) {
                    var classSymbol = classDecl.getSymbol(this.semanticInfoChain);
                    this.resolveDeclaredSymbol(classSymbol, context);

                    var comparisonInfo = new TypeComparisonInfo();
                    var isAssignable = this.sourceIsAssignableToTarget(expressionType, classSymbol.type, expression, context, comparisonInfo);
                    if (!isAssignable) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class));
                    }
                }
            }

            if (enclosingFunction && enclosingFunction.kind === 524288 /* SetAccessor */) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Setters_cannot_return_a_value));
            }

            if (enclosingFunction) {
                var enclosingDeclAST = this.getASTForDecl(enclosingFunction);
                var typeAnnotation = TypeScript.ASTHelpers.getType(enclosingDeclAST);
                if (typeAnnotation || enclosingFunction.kind === 262144 /* GetAccessor */) {
                    var signatureSymbol = enclosingFunction.getSignatureSymbol(this.semanticInfoChain);
                    var sigReturnType = signatureSymbol.returnType;

                    if (expressionType && sigReturnType) {
                        var comparisonInfo = new TypeComparisonInfo();
                        var upperBound = null;

                        this.resolveDeclaredSymbol(expressionType, context);
                        this.resolveDeclaredSymbol(sigReturnType, context);

                        var isAssignable = this.sourceIsAssignableToTarget(expressionType, sigReturnType, expression, context, comparisonInfo);

                        if (!isAssignable) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(expression);
                            if (comparisonInfo.message) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1_NL_2, [expressionType.toString(enclosingSymbol), sigReturnType.toString(enclosingSymbol), comparisonInfo.message]));
                            } else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1, [expressionType.toString(enclosingSymbol), sigReturnType.toString(enclosingSymbol)]));
                            }
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.resolveReturnStatement = function (returnAST, context) {
            var enclosingFunction = this.getEnclosingFunctionDeclaration(returnAST);
            if (enclosingFunction) {
                enclosingFunction.setFlag(4194304 /* HasReturnStatement */);
            }

            var returnType = this.getSymbolForAST(returnAST, context);
            var canTypeCheckAST = this.canTypeCheckAST(returnAST, context);
            if (!returnType || canTypeCheckAST) {
                var returnExpr = returnAST.expression;

                var resolvedReturnType = returnExpr === null ? this.semanticInfoChain.voidTypeSymbol : this.resolveReturnExpression(returnExpr, enclosingFunction, context);

                if (!returnType) {
                    returnType = resolvedReturnType;
                    this.setSymbolForAST(returnAST, resolvedReturnType, context);
                }

                if (returnExpr && canTypeCheckAST) {
                    this.setTypeChecked(returnExpr, context);
                    this.typeCheckReturnExpression(returnExpr, resolvedReturnType, enclosingFunction, context);
                }
            }

            return returnType;
        };

        PullTypeResolver.prototype.resolveSwitchStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSwitchStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckSwitchStatement = function (ast, context) {
            this.setTypeChecked(ast, context);

            var expressionType = this.resolveAST(ast.expression, false, context).type;

            for (var i = 0, n = ast.switchClauses.length; i < n; i++) {
                var switchClause = ast.switchClauses[i];
                if (switchClause.kind() === 234 /* CaseSwitchClause */) {
                    var caseSwitchClause = switchClause;

                    var caseClauseExpressionType = this.resolveAST(caseSwitchClause.expression, false, context).type;
                    this.resolveAST(caseSwitchClause.statements, false, context);

                    var comparisonInfo = new TypeComparisonInfo();
                    if (!this.sourceIsAssignableToTarget(expressionType, caseClauseExpressionType, caseSwitchClause.expression, context, comparisonInfo) && !this.sourceIsAssignableToTarget(caseClauseExpressionType, expressionType, caseSwitchClause.expression, context, comparisonInfo)) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(caseSwitchClause.expression);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(caseSwitchClause.expression, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1_NL_2, [caseClauseExpressionType.toString(enclosingSymbol), expressionType.toString(enclosingSymbol), comparisonInfo.message]));
                        } else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(caseSwitchClause.expression, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1, [caseClauseExpressionType.toString(enclosingSymbol), expressionType.toString(enclosingSymbol)]));
                        }
                    }
                } else {
                    var defaultSwitchClause = switchClause;
                    this.resolveAST(defaultSwitchClause.statements, false, context);
                }
            }
        };

        PullTypeResolver.prototype.resolveLabeledStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLabeledStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckLabeledStatement = function (ast, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.statement, false, context);
        };

        PullTypeResolver.prototype.resolveContinueStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckContinueStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckContinueStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
        };

        PullTypeResolver.prototype.resolveBreakStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckBreakStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckBreakStatement = function (ast, context) {
            this.setTypeChecked(ast, context);
        };

        PullTypeResolver.prototype.resolveAST = function (ast, isContextuallyTyped, context) {
            if (!ast) {
                return null;
            }

            if (TypeScript.isShared(ast)) {
                return null;
            }

            var symbol = this.getSymbolForAST(ast, context);
            if (symbol && symbol.isResolved) {
                this.typeCheckAST(ast, isContextuallyTyped, context);
                return symbol;
            }

            if (TypeScript.isNode(ast) || TypeScript.isToken(ast)) {
                if (TypeScript.SyntaxUtilities.isExpression(ast) && !isTypesOnlyLocation(ast)) {
                    return this.resolveExpressionAST(ast, isContextuallyTyped, context);
                }
            }

            var nodeType = ast.kind();

            switch (nodeType) {
                case 124 /* ArrayType */:
                case 126 /* GenericType */:
                case 122 /* ObjectType */:
                case 127 /* TypeQuery */:
                case 125 /* ConstructorType */:
                case 123 /* FunctionType */:
                    return this.resolveTypeReference(ast, context);

                case 1 /* List */:
                    return this.resolveList(ast, context);

                case 2 /* SeparatedList */:
                    return this.resolveSeparatedList(ast, context);

                case 120 /* SourceUnit */:
                    return this.resolveSourceUnit(ast, context);

                case 133 /* EnumDeclaration */:
                    return this.resolveEnumDeclaration(ast, context);

                case 131 /* ModuleDeclaration */:
                    return this.resolveModuleDeclaration(ast, context);

                case 129 /* InterfaceDeclaration */:
                    return this.resolveInterfaceDeclaration(ast, context);

                case 132 /* ClassDeclaration */:
                    return this.resolveClassDeclaration(ast, context);

                case 225 /* VariableDeclaration */:
                    return this.resolveVariableDeclarationList(ast, context);

                case 137 /* MemberVariableDeclaration */:
                    return this.resolveMemberVariableDeclaration(ast, context);

                case 226 /* VariableDeclarator */:
                    return this.resolveVariableDeclarator(ast, context);

                case 142 /* PropertySignature */:
                    return this.resolvePropertySignature(ast, context);

                case 228 /* ParameterList */:
                    return this.resolveParameterList(ast, context);

                case 243 /* Parameter */:
                    return this.resolveParameter(ast, context);

                case 244 /* EnumElement */:
                    return this.resolveEnumElement(ast, context);

                case 233 /* EqualsValueClause */:
                    return this.resolveEqualsValueClause(ast, isContextuallyTyped, context);

                case 239 /* TypeParameter */:
                    return this.resolveTypeParameterDeclaration(ast, context);

                case 240 /* Constraint */:
                    return this.resolveConstraint(ast, context);

                case 134 /* ImportDeclaration */:
                    return this.resolveImportDeclaration(ast, context);

                case 241 /* SimplePropertyAssignment */:
                    return this.resolveSimplePropertyAssignment(ast, isContextuallyTyped, context);

                case 242 /* FunctionPropertyAssignment */:
                    return this.resolveFunctionPropertyAssignment(ast, isContextuallyTyped, context);

                case 11 /* IdentifierName */:
                    TypeScript.Debug.assert(isTypesOnlyLocation(ast));
                    return this.resolveTypeNameExpression(ast, context);

                case 121 /* QualifiedName */:
                    return this.resolveQualifiedName(ast, context);

                case 138 /* ConstructorDeclaration */:
                    return this.resolveConstructorDeclaration(ast, context);

                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                    return this.resolveAccessorDeclaration(ast, context);

                case 139 /* IndexMemberDeclaration */:
                    return this.resolveIndexMemberDeclaration(ast, context);

                case 145 /* IndexSignature */:
                    return this.resolveIndexSignature(ast, context);

                case 136 /* MemberFunctionDeclaration */:
                    return this.resolveMemberFunctionDeclaration(ast, context);

                case 143 /* CallSignature */:
                    return this.resolveCallSignature(ast, context);

                case 144 /* ConstructSignature */:
                    return this.resolveConstructSignature(ast, context);

                case 146 /* MethodSignature */:
                    return this.resolveMethodSignature(ast, context);

                case 130 /* FunctionDeclaration */:
                    return this.resolveAnyFunctionDeclaration(ast, context);

                case 245 /* TypeAnnotation */:
                    return this.resolveTypeAnnotation(ast, context);

                case 135 /* ExportAssignment */:
                    return this.resolveExportAssignmentStatement(ast, context);

                case 158 /* ThrowStatement */:
                    return this.resolveThrowStatement(ast, context);

                case 150 /* ExpressionStatement */:
                    return this.resolveExpressionStatement(ast, context);

                case 155 /* ForStatement */:
                    return this.resolveForStatement(ast, context);

                case 156 /* ForInStatement */:
                    return this.resolveForInStatement(ast, context);

                case 159 /* WhileStatement */:
                    return this.resolveWhileStatement(ast, context);

                case 162 /* DoStatement */:
                    return this.resolveDoStatement(ast, context);

                case 148 /* IfStatement */:
                    return this.resolveIfStatement(ast, context);

                case 236 /* ElseClause */:
                    return this.resolveElseClause(ast, context);

                case 147 /* Block */:
                    return this.resolveBlock(ast, context);

                case 149 /* VariableStatement */:
                    return this.resolveVariableStatement(ast, context);

                case 164 /* WithStatement */:
                    return this.resolveWithStatement(ast, context);

                case 160 /* TryStatement */:
                    return this.resolveTryStatement(ast, context);

                case 237 /* CatchClause */:
                    return this.resolveCatchClause(ast, context);

                case 238 /* FinallyClause */:
                    return this.resolveFinallyClause(ast, context);

                case 151 /* ReturnStatement */:
                    return this.resolveReturnStatement(ast, context);

                case 152 /* SwitchStatement */:
                    return this.resolveSwitchStatement(ast, context);

                case 154 /* ContinueStatement */:
                    return this.resolveContinueStatement(ast, context);

                case 153 /* BreakStatement */:
                    return this.resolveBreakStatement(ast, context);

                case 161 /* LabeledStatement */:
                    return this.resolveLabeledStatement(ast, context);
            }

            return this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.resolveExpressionAST = function (ast, isContextuallyOrInferentiallyTyped, context) {
            var expressionSymbol = this.resolveExpressionWorker(ast, isContextuallyOrInferentiallyTyped, context);

            if (isContextuallyOrInferentiallyTyped && context.isInferentiallyTyping()) {
                return this.alterPotentialGenericFunctionTypeToInstantiatedFunctionTypeForTypeArgumentInference(expressionSymbol, context);
            } else {
                return expressionSymbol;
            }
        };

        PullTypeResolver.prototype.resolveExpressionWorker = function (ast, isContextuallyTyped, context) {
            switch (ast.kind()) {
                case 216 /* ObjectLiteralExpression */:
                    return this.resolveObjectLiteralExpression(ast, isContextuallyTyped, context);

                case 11 /* IdentifierName */:
                    return this.resolveNameExpression(ast, context);

                case 213 /* MemberAccessExpression */:
                    return this.resolveMemberAccessExpression(ast, context);

                case 223 /* FunctionExpression */:
                    return this.resolveFunctionExpression(ast, isContextuallyTyped, context);

                case 220 /* SimpleArrowFunctionExpression */:
                    return this.resolveSimpleArrowFunctionExpression(ast, isContextuallyTyped, context);

                case 219 /* ParenthesizedArrowFunctionExpression */:
                    return this.resolveParenthesizedArrowFunctionExpression(ast, isContextuallyTyped, context);

                case 215 /* ArrayLiteralExpression */:
                    return this.resolveArrayLiteralExpression(ast, isContextuallyTyped, context);

                case 35 /* ThisKeyword */:
                    return this.resolveThisExpression(ast, context);

                case 50 /* SuperKeyword */:
                    return this.resolveSuperExpression(ast, context);

                case 214 /* InvocationExpression */:
                    return this.resolveInvocationExpression(ast, context);

                case 217 /* ObjectCreationExpression */:
                    return this.resolveObjectCreationExpression(ast, context);

                case 221 /* CastExpression */:
                    return this.resolveCastExpression(ast, context);

                case 13 /* NumericLiteral */:
                    return this.semanticInfoChain.numberTypeSymbol;

                case 14 /* StringLiteral */:
                    return this.semanticInfoChain.stringTypeSymbol;

                case 32 /* NullKeyword */:
                    return this.semanticInfoChain.nullTypeSymbol;

                case 37 /* TrueKeyword */:
                case 24 /* FalseKeyword */:
                    return this.semanticInfoChain.booleanTypeSymbol;

                case 173 /* VoidExpression */:
                    return this.resolveVoidExpression(ast, context);

                case 175 /* AssignmentExpression */:
                    return this.resolveAssignmentExpression(ast, context);

                case 168 /* LogicalNotExpression */:
                    return this.resolveLogicalNotExpression(ast, context);

                case 194 /* NotEqualsWithTypeConversionExpression */:
                case 193 /* EqualsWithTypeConversionExpression */:
                case 195 /* EqualsExpression */:
                case 196 /* NotEqualsExpression */:
                case 197 /* LessThanExpression */:
                case 199 /* LessThanOrEqualExpression */:
                case 200 /* GreaterThanOrEqualExpression */:
                case 198 /* GreaterThanExpression */:
                    return this.resolveLogicalOperation(ast, context);

                case 209 /* AddExpression */:
                case 176 /* AddAssignmentExpression */:
                    return this.resolveBinaryAdditionOperation(ast, context);

                case 165 /* PlusExpression */:
                case 166 /* NegateExpression */:
                case 167 /* BitwiseNotExpression */:
                case 169 /* PreIncrementExpression */:
                case 170 /* PreDecrementExpression */:
                    return this.resolveUnaryArithmeticOperation(ast, context);

                case 211 /* PostIncrementExpression */:
                case 212 /* PostDecrementExpression */:
                    return this.resolvePostfixUnaryExpression(ast, context);

                case 210 /* SubtractExpression */:
                case 206 /* MultiplyExpression */:
                case 207 /* DivideExpression */:
                case 208 /* ModuloExpression */:
                case 190 /* BitwiseOrExpression */:
                case 192 /* BitwiseAndExpression */:
                case 203 /* LeftShiftExpression */:
                case 204 /* SignedRightShiftExpression */:
                case 205 /* UnsignedRightShiftExpression */:
                case 191 /* BitwiseExclusiveOrExpression */:
                case 182 /* ExclusiveOrAssignmentExpression */:
                case 184 /* LeftShiftAssignmentExpression */:
                case 185 /* SignedRightShiftAssignmentExpression */:
                case 186 /* UnsignedRightShiftAssignmentExpression */:
                case 177 /* SubtractAssignmentExpression */:
                case 178 /* MultiplyAssignmentExpression */:
                case 179 /* DivideAssignmentExpression */:
                case 180 /* ModuloAssignmentExpression */:
                case 183 /* OrAssignmentExpression */:
                case 181 /* AndAssignmentExpression */:
                    return this.resolveBinaryArithmeticExpression(ast, context);

                case 222 /* ElementAccessExpression */:
                    return this.resolveElementAccessExpression(ast, context);

                case 188 /* LogicalOrExpression */:
                    return this.resolveLogicalOrExpression(ast, isContextuallyTyped, context);

                case 189 /* LogicalAndExpression */:
                    return this.resolveLogicalAndExpression(ast, context);

                case 172 /* TypeOfExpression */:
                    return this.resolveTypeOfExpression(ast, context);

                case 171 /* DeleteExpression */:
                    return this.resolveDeleteExpression(ast, context);

                case 187 /* ConditionalExpression */:
                    return this.resolveConditionalExpression(ast, isContextuallyTyped, context);

                case 12 /* RegularExpressionLiteral */:
                    return this.resolveRegularExpressionLiteral();

                case 218 /* ParenthesizedExpression */:
                    return this.resolveParenthesizedExpression(ast, context);

                case 201 /* InstanceOfExpression */:
                    return this.resolveInstanceOfExpression(ast, context);

                case 174 /* CommaExpression */:
                    return this.resolveCommaExpression(ast, context);

                case 202 /* InExpression */:
                    return this.resolveInExpression(ast, context);

                case 224 /* OmittedExpression */:
                    return this.semanticInfoChain.undefinedTypeSymbol;
            }

            TypeScript.Debug.fail("resolveExpressionASTWorker: Missing expression kind: " + TypeScript.SyntaxKind[ast.kind()]);
        };

        PullTypeResolver.prototype.typeCheckAST = function (ast, isContextuallyTyped, context) {
            if (!this.canTypeCheckAST(ast, context)) {
                return;
            }

            var nodeType = ast.kind();
            switch (nodeType) {
                case 120 /* SourceUnit */:
                    this.typeCheckSourceUnit(ast, context);
                    return;

                case 133 /* EnumDeclaration */:
                    this.typeCheckEnumDeclaration(ast, context);
                    return;

                case 131 /* ModuleDeclaration */:
                    this.typeCheckModuleDeclaration(ast, context);
                    return;

                case 129 /* InterfaceDeclaration */:
                    this.typeCheckInterfaceDeclaration(ast, context);
                    return;

                case 132 /* ClassDeclaration */:
                    this.typeCheckClassDeclaration(ast, context);
                    return;

                case 244 /* EnumElement */:
                    this.typeCheckEnumElement(ast, context);
                    return;

                case 137 /* MemberVariableDeclaration */:
                    this.typeCheckMemberVariableDeclaration(ast, context);
                    return;

                case 226 /* VariableDeclarator */:
                    this.typeCheckVariableDeclarator(ast, context);
                    return;

                case 142 /* PropertySignature */:
                    this.typeCheckPropertySignature(ast, context);
                    return;

                case 243 /* Parameter */:
                    this.typeCheckParameter(ast, context);
                    return;

                case 134 /* ImportDeclaration */:
                    this.typeCheckImportDeclaration(ast, context);
                    return;

                case 216 /* ObjectLiteralExpression */:
                    this.resolveObjectLiteralExpression(ast, isContextuallyTyped, context);
                    return;

                case 242 /* FunctionPropertyAssignment */:
                    this.typeCheckFunctionPropertyAssignment(ast, isContextuallyTyped, context);
                    return;

                case 11 /* IdentifierName */:
                    if (isTypesOnlyLocation(ast)) {
                        this.resolveTypeNameExpression(ast, context);
                    } else {
                        this.resolveNameExpression(ast, context);
                    }
                    return;

                case 213 /* MemberAccessExpression */:
                    this.resolveMemberAccessExpression(ast, context);
                    return;

                case 121 /* QualifiedName */:
                    this.resolveQualifiedName(ast, context);
                    return;

                case 223 /* FunctionExpression */:
                    this.typeCheckFunctionExpression(ast, isContextuallyTyped, context);
                    return;

                case 138 /* ConstructorDeclaration */:
                    this.typeCheckConstructorDeclaration(ast, context);
                    return;

                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                    this.typeCheckAccessorDeclaration(ast, context);
                    return;

                case 136 /* MemberFunctionDeclaration */:
                    this.typeCheckMemberFunctionDeclaration(ast, context);
                    return;

                case 146 /* MethodSignature */:
                    this.typeCheckMethodSignature(ast, context);
                    return;

                case 145 /* IndexSignature */:
                    this.typeCheckIndexSignature(ast, context);
                    break;

                case 143 /* CallSignature */:
                    this.typeCheckCallSignature(ast, context);
                    return;

                case 144 /* ConstructSignature */:
                    this.typeCheckConstructSignature(ast, context);
                    return;

                case 130 /* FunctionDeclaration */: {
                    var funcDecl = ast;
                    this.typeCheckAnyFunctionDeclaration(funcDecl, TypeScript.hasModifier(funcDecl.modifiers, 16 /* Static */), funcDecl.identifier, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, TypeScript.ASTHelpers.getType(funcDecl), funcDecl.block, context);
                    return;
                }

                case 220 /* SimpleArrowFunctionExpression */:
                    this.typeCheckSimpleArrowFunctionExpression(ast, isContextuallyTyped, context);
                    return;

                case 219 /* ParenthesizedArrowFunctionExpression */:
                    this.typeCheckParenthesizedArrowFunctionExpression(ast, isContextuallyTyped, context);
                    return;

                case 215 /* ArrayLiteralExpression */:
                    this.resolveArrayLiteralExpression(ast, isContextuallyTyped, context);
                    return;

                case 214 /* InvocationExpression */:
                    this.typeCheckInvocationExpression(ast, context);
                    return;

                case 217 /* ObjectCreationExpression */:
                    this.typeCheckObjectCreationExpression(ast, context);
                    return;

                case 151 /* ReturnStatement */:
                    this.resolveReturnStatement(ast, context);
                    return;

                default:
                    TypeScript.Debug.assert(false, "Failure nodeType: " + TypeScript.SyntaxKind[ast.kind()] + ". Implement typeCheck when symbol is set for the ast as part of resolution.");
            }
        };

        PullTypeResolver.prototype.processPostTypeCheckWorkItems = function (context) {
            while (this.postTypeCheckWorkitems.length) {
                var ast = this.postTypeCheckWorkitems.pop();
                this.postTypeCheck(ast, context);
            }
        };

        PullTypeResolver.prototype.postTypeCheck = function (ast, context) {
            var nodeType = ast.kind();

            switch (nodeType) {
                case 243 /* Parameter */:
                case 226 /* VariableDeclarator */:
                    this.postTypeCheckVariableDeclaratorOrParameter(ast, context);
                    return;

                case 132 /* ClassDeclaration */:
                    this.postTypeCheckClassDeclaration(ast, context);
                    return;

                case 130 /* FunctionDeclaration */:
                    this.postTypeCheckFunctionDeclaration(ast, context);
                    return;

                case 131 /* ModuleDeclaration */:
                    this.postTypeCheckModuleDeclaration(ast, context);
                    return;

                case 133 /* EnumDeclaration */:
                    this.postTypeCheckEnumDeclaration(ast, context);
                    return;

                case 134 /* ImportDeclaration */:
                    this.postTypeCheckImportDeclaration(ast, context);
                    return;

                case 11 /* IdentifierName */:
                    this.postTypeCheckNameExpression(ast, context);
                    return;

                default:
                    TypeScript.Debug.assert(false, "Implement postTypeCheck clause to handle the postTypeCheck work, nodeType: " + TypeScript.SyntaxKind[ast.kind()]);
            }
        };

        PullTypeResolver.prototype.resolveRegularExpressionLiteral = function () {
            if (this.cachedRegExpInterfaceType()) {
                return this.cachedRegExpInterfaceType();
            } else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        };

        PullTypeResolver.prototype.postTypeCheckNameExpression = function (nameAST, context) {
            this.checkThisCaptureVariableCollides(nameAST, false, context);
        };

        PullTypeResolver.prototype.typeCheckNameExpression = function (nameAST, context) {
            this.setTypeChecked(nameAST, context);
            this.checkNameForCompilerGeneratedDeclarationCollision(nameAST, false, nameAST, context);
        };

        PullTypeResolver.prototype.resolveNameExpression = function (nameAST, context) {
            var nameSymbol = this.getSymbolForAST(nameAST, context);
            var foundCached = nameSymbol !== null;

            if (!foundCached || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.typeCheckNameExpression(nameAST, context);
                }
                nameSymbol = this.computeNameExpression(nameAST, context);
            }

            this.resolveDeclaredSymbol(nameSymbol, context);

            if (nameSymbol && (nameSymbol.type !== this.semanticInfoChain.anyTypeSymbol || nameSymbol.anyDeclHasFlag(16777216 /* IsAnnotatedWithAny */ | 1 /* Exported */))) {
                this.setSymbolForAST(nameAST, nameSymbol, context);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.isInEnumDecl = function (decl) {
            if (decl.kind & 64 /* Enum */) {
                return true;
            }

            var declPath = decl.getParentPath();

            var disallowedKinds = 164 /* SomeContainer */ | 58728795 /* SomeType */;
            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];

                if (decl.kind & 64 /* Enum */) {
                    return true;
                }

                if (decl.kind & disallowedKinds) {
                    return false;
                }
            }
            return false;
        };

        PullTypeResolver.prototype.getSomeInnermostFunctionScopeDecl = function (declPath) {
            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];
                if (decl.kind & 1032192 /* SomeFunction */) {
                    return decl;
                }
            }

            return null;
        };

        PullTypeResolver.prototype.isFromFunctionScope = function (nameSymbol, functionScopeDecl) {
            var _this = this;
            return TypeScript.ArrayUtilities.any(nameSymbol.getDeclarations(), function (nameSymbolDecl) {
                return _this.getSomeInnermostFunctionScopeDecl(nameSymbolDecl.getParentPath()) === functionScopeDecl;
            });
        };

        PullTypeResolver.prototype.findConstructorDeclOfEnclosingType = function (decl) {
            var current = decl;
            while (current) {
                if (TypeScript.hasFlag(current.kind, 4096 /* Property */)) {
                    var parentDecl = current.getParentDecl();
                    if (TypeScript.hasFlag(parentDecl.kind, 8 /* Class */)) {
                        return TypeScript.ArrayUtilities.lastOrDefault(parentDecl.getChildDecls(), function (decl) {
                            return TypeScript.hasFlag(decl.kind, 32768 /* ConstructorMethod */);
                        });
                    }
                }

                if (TypeScript.hasFlag(current.kind, 164 /* SomeContainer */)) {
                    return null;
                }

                current = current.getParentDecl();
            }
            return null;
        };

        PullTypeResolver.prototype.checkNameAsPartOfInitializerExpressionForInstanceMemberVariable = function (nameAST, nameSymbol, context) {
            var id = TypeScript.tokenValueText(nameAST);
            if (id.length === 0) {
                return false;
            }

            var memberVariableDeclarationAST = TypeScript.ASTHelpers.getEnclosingMemberDeclaration(nameAST);
            if (memberVariableDeclarationAST && memberVariableDeclarationAST.kind() === 137 /* MemberVariableDeclaration */) {
                var memberVariableDecl = this.semanticInfoChain.getDeclForAST(memberVariableDeclarationAST);
                if (!TypeScript.hasFlag(memberVariableDecl.flags, 16 /* Static */)) {
                    var constructorDecl = this.findConstructorDeclOfEnclosingType(memberVariableDecl);

                    if (constructorDecl) {
                        var childDecls = constructorDecl.searchChildDecls(id, 68147712 /* SomeValue */);
                        if (childDecls.length) {
                            if (TypeScript.PullHelpers.isSymbolDeclaredInScopeChain(nameSymbol, constructorDecl.getSymbol(this.semanticInfoChain).getContainer())) {
                                var memberVariableSymbol = memberVariableDecl.getSymbol(this.semanticInfoChain);

                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, [memberVariableSymbol.getScopedName(constructorDecl.getSymbol(this.semanticInfoChain)), nameAST.text()]));
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };

        PullTypeResolver.prototype.computeNameExpression = function (nameAST, context) {
            var id = TypeScript.tokenValueText(nameAST);
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var nameSymbol = null;
            var enclosingDecl = this.getEnclosingDeclForAST(nameAST);

            if (TypeScript.hasFlag(enclosingDecl.flags, 8388608 /* PropertyParameter */)) {
                var valueDecl = enclosingDecl.getValueDecl();
                if (valueDecl && TypeScript.hasFlag(valueDecl.kind, 2048 /* Parameter */)) {
                    enclosingDecl = valueDecl;
                }
            }

            var isDeclarationASTOrDeclarationNameAST = TypeScript.ASTHelpers.isDeclarationASTOrDeclarationNameAST(nameAST);
            if (isDeclarationASTOrDeclarationNameAST) {
                nameSymbol = this.semanticInfoChain.getDeclForAST(nameAST.parent).getSymbol(this.semanticInfoChain);
            }

            var declPath = enclosingDecl.getParentPath();

            if (!nameSymbol) {
                var searchKind = 68147712 /* SomeValue */;

                if (!this.isInEnumDecl(enclosingDecl)) {
                    searchKind = searchKind & ~(67108864 /* EnumMember */);
                }

                var nameSymbol = this.getSymbolFromDeclPath(id, declPath, searchKind);
            }

            if (id === "arguments") {
                var functionScopeDecl = this.getSomeInnermostFunctionScopeDecl(declPath);
                if (functionScopeDecl) {
                    if (!nameSymbol || !this.isFromFunctionScope(nameSymbol, functionScopeDecl)) {
                        nameSymbol = this.cachedFunctionArgumentsSymbol();
                        this.resolveDeclaredSymbol(this.cachedIArgumentsInterfaceType(), context);
                    }
                }
            }

            var aliasSymbol = null;
            if (nameSymbol && nameSymbol.isAlias() && !isDeclarationASTOrDeclarationNameAST) {
                aliasSymbol = nameSymbol;
                if (!this.inTypeQuery(nameAST)) {
                    aliasSymbol.setIsUsedAsValue();
                }

                this.resolveDeclaredSymbol(nameSymbol, context);

                this.resolveDeclaredSymbol(aliasSymbol.assignedValue(), context);
                this.resolveDeclaredSymbol(aliasSymbol.assignedContainer(), context);

                nameSymbol = aliasSymbol.getExportAssignedValueSymbol();
                if (!nameSymbol) {
                    aliasSymbol = null;
                }
            }

            if (!nameSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Cannot_find_name_0, [nameAST.text()]));
                return this.getNewErrorTypeSymbol(id);
            } else if (this.checkNameAsPartOfInitializerExpressionForInstanceMemberVariable(nameAST, nameSymbol, context)) {
                return this.getNewErrorTypeSymbol(id);
            }

            var nameDeclaration = nameSymbol.getDeclarations()[0];
            var nameParentDecl = nameDeclaration.getParentDecl();
            if (nameParentDecl && (nameParentDecl.kind & 1032192 /* SomeFunction */) && (nameParentDecl.flags & 33554432 /* HasDefaultArgs */)) {
                var enclosingFunctionAST = this.semanticInfoChain.getASTForDecl(nameParentDecl);
                var currentParameterIndex = this.getCurrentParameterIndexForFunction(nameAST, enclosingFunctionAST);

                var parameterList = TypeScript.ASTHelpers.getParameterList(enclosingFunctionAST);

                if (currentParameterIndex >= 0) {
                    var matchingParameter;
                    if (parameterList) {
                        for (var i = 0; i <= currentParameterIndex; i++) {
                            var candidateParameter = parameterList.parameters[i];
                            if (candidateParameter && TypeScript.tokenValueText(candidateParameter.identifier) === id) {
                                matchingParameter = candidateParameter;
                                break;
                            }
                        }
                    }

                    if (!matchingParameter) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, [parameterList.parameters[currentParameterIndex].identifier.text(), nameAST.text()]));
                        return this.getNewErrorTypeSymbol(id);
                    } else if (matchingParameter === TypeScript.ASTHelpers.getEnclosingParameterForInitializer(nameAST)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Parameter_0_cannot_be_referenced_in_its_initializer, [parameterList.parameters[currentParameterIndex].identifier.text()]));
                        return this.getNewErrorTypeSymbol(id);
                    }
                }
            }

            if (aliasSymbol) {
                this.semanticInfoChain.setAliasSymbolForAST(nameAST, aliasSymbol);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.getCurrentParameterIndexForFunction = function (parameter, funcDecl) {
            var parameterList = TypeScript.ASTHelpers.getParameterList(funcDecl);
            if (parameterList) {
                while (parameter && parameter.parent) {
                    if (parameter.parent.parent === parameterList) {
                        return TypeScript.Syntax.nonSeparatorIndexOf(parameterList.parameters, parameter);
                    }

                    parameter = parameter.parent;
                }
            }

            return -1;
        };

        PullTypeResolver.prototype.resolveMemberAccessExpression = function (dottedNameAST, context) {
            return this.resolveDottedNameExpression(dottedNameAST, dottedNameAST.expression, dottedNameAST.name, context);
        };

        PullTypeResolver.prototype.resolveDottedNameExpression = function (dottedNameAST, expression, name, context) {
            var symbol = this.getSymbolForAST(dottedNameAST, context);
            var foundCached = symbol !== null;

            if (!foundCached || this.canTypeCheckAST(dottedNameAST, context)) {
                var canTypeCheckDottedNameAST = this.canTypeCheckAST(dottedNameAST, context);
                if (canTypeCheckDottedNameAST) {
                    this.setTypeChecked(dottedNameAST, context);
                }

                symbol = this.computeDottedNameExpression(expression, name, context, canTypeCheckDottedNameAST);
            }

            this.resolveDeclaredSymbol(symbol, context);

            if (symbol && (symbol.type !== this.semanticInfoChain.anyTypeSymbol || symbol.anyDeclHasFlag(16777216 /* IsAnnotatedWithAny */ | 1 /* Exported */))) {
                this.setSymbolForAST(dottedNameAST, symbol, context);
                this.setSymbolForAST(name, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeDottedNameExpression = function (expression, name, context, checkSuperPrivateAndStaticAccess) {
            var rhsName = TypeScript.tokenValueText(name);
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var lhs = this.resolveAST(expression, false, context);
            return this.computeDottedNameExpressionFromLHS(lhs, expression, name, context, checkSuperPrivateAndStaticAccess);
        };

        PullTypeResolver.prototype.computeDottedNameExpressionFromLHS = function (lhs, expression, name, context, checkSuperPrivateAndStaticAccess) {
            var rhsName = TypeScript.tokenValueText(name);
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var lhsType = lhs.type;

            if (lhs.isAlias()) {
                var lhsAlias = lhs;
                if (!this.inTypeQuery(expression)) {
                    lhsAlias.setIsUsedAsValue();
                }
                lhsType = lhsAlias.getExportAssignedTypeSymbol();
            }

            if (lhsType.isAlias()) {
                lhsType = lhsType.getExportAssignedTypeSymbol();
            }

            if (!lhsType) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name_0, [name.text()]));
                return this.getNewErrorTypeSymbol();
            }

            if (!lhsType.isResolved) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, context);

                if (potentiallySpecializedType !== lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            if (lhsType.isContainer() && !lhsType.isAlias() && !lhsType.isEnum()) {
                var instanceSymbol = lhsType.getInstanceSymbol();

                if (instanceSymbol) {
                    lhsType = instanceSymbol.type;
                }
            }

            var originalLhsTypeForErrorReporting = lhsType;

            lhsType = this.getApparentType(lhsType).widenedType(this, expression, context);

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            var nameSymbol = this._getNamedPropertySymbolOfAugmentedType(rhsName, lhsType);

            if (!nameSymbol) {
                if (lhsType.kind === 32 /* DynamicModule */) {
                    var container = lhsType;
                    var associatedInstance = container.getInstanceSymbol();

                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;

                        nameSymbol = this.getNamedPropertySymbol(rhsName, 68147712 /* SomeValue */, instanceType);
                    }
                } else {
                    var associatedType = lhsType.getAssociatedContainerType();

                    if (associatedType && !associatedType.isClass()) {
                        nameSymbol = this.getNamedPropertySymbol(rhsName, 68147712 /* SomeValue */, associatedType);
                    }
                }

                if (!nameSymbol) {
                    var enclosingDecl = this.getEnclosingDeclForAST(expression);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode.Property_0_does_not_exist_on_value_of_type_1, [name.text(), originalLhsTypeForErrorReporting.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                    return this.getNewErrorTypeSymbol(rhsName);
                }
            }

            if (checkSuperPrivateAndStaticAccess) {
                this.checkForSuperMemberAccess(expression, name, nameSymbol, context) || this.checkForPrivateMemberAccess(name, lhsType, nameSymbol, context);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.resolveTypeNameExpression = function (nameAST, context) {
            var typeNameSymbol = this.getSymbolForAST(nameAST, context);

            if (!typeNameSymbol || !typeNameSymbol.isType() || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.setTypeChecked(nameAST, context);
                }
                typeNameSymbol = this.computeTypeNameExpression(nameAST, context);
                this.setSymbolForAST(nameAST, typeNameSymbol, context);
            }

            this.resolveDeclaredSymbol(typeNameSymbol, context);

            return typeNameSymbol;
        };

        PullTypeResolver.prototype.computeTypeNameExpression = function (nameAST, context) {
            var id = TypeScript.tokenValueText(nameAST);
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var enclosingDecl = this.getEnclosingDeclForAST(nameAST);

            var declPath = enclosingDecl.getParentPath();

            var onLeftOfDot = this.isLeftSideOfQualifiedName(nameAST);

            var kindToCheckFirst = onLeftOfDot ? 164 /* SomeContainer */ : 58728795 /* SomeType */;
            var kindToCheckSecond = onLeftOfDot ? 58728795 /* SomeType */ : 164 /* SomeContainer */;

            var typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckFirst);

            if (!typeNameSymbol) {
                typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckSecond);
            }

            if (!typeNameSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Cannot_find_name_0, [nameAST.text()]));
                return this.getNewErrorTypeSymbol(id);
            }

            var typeNameSymbolAlias = null;
            if (typeNameSymbol.isAlias()) {
                typeNameSymbolAlias = typeNameSymbol;
                this.resolveDeclaredSymbol(typeNameSymbol, context);

                var aliasedType = typeNameSymbolAlias.getExportAssignedTypeSymbol();

                this.resolveDeclaredSymbol(aliasedType, context);
            }

            if (typeNameSymbol.isTypeParameter()) {
                if (TypeScript.PullHelpers.isInStaticMemberContext(nameAST, this.semanticInfoChain)) {
                    var parentDecl = typeNameSymbol.getDeclarations()[0].getParentDecl();

                    if (parentDecl.kind === 8 /* Class */) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, TypeScript.DiagnosticCode.Static_members_cannot_reference_class_type_parameters));
                        return this.getNewErrorTypeSymbol();
                    }
                }
            }

            if (!typeNameSymbol.isGeneric() && (typeNameSymbol.isClass() || typeNameSymbol.isInterface())) {
                typeNameSymbol = TypeScript.TypeReferenceSymbol.createTypeReference(typeNameSymbol);
            }

            return typeNameSymbol;
        };

        PullTypeResolver.prototype.isLeftSideOfQualifiedName = function (ast) {
            return ast && ast.parent && ast.parent.kind() === 121 /* QualifiedName */ && ast.parent.left === ast;
        };

        PullTypeResolver.prototype.resolveGenericTypeReference = function (genericTypeAST, context) {
            var _this = this;
            var genericTypeSymbol = this.resolveAST(genericTypeAST.name, false, context).type;

            if (genericTypeSymbol.isError()) {
                return genericTypeSymbol;
            }

            if (!genericTypeSymbol.inResolution && !genericTypeSymbol.isResolved) {
                this.resolveDeclaredSymbol(genericTypeSymbol, context);
            }

            if (genericTypeSymbol.isAlias()) {
                if (this.inClassExtendsHeritageClause(genericTypeAST) && !this.inTypeArgumentList(genericTypeAST)) {
                    genericTypeSymbol.setIsUsedAsValue();
                }
                genericTypeSymbol = genericTypeSymbol.getExportAssignedTypeSymbol();
            }

            var typeParameters = genericTypeSymbol.getTypeParameters();
            if (typeParameters.length === 0) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(genericTypeAST, TypeScript.DiagnosticCode.Type_0_is_not_generic, [genericTypeSymbol.toString()]));
                return this.getNewErrorTypeSymbol();
            }

            var typeArgs = [];

            if (genericTypeAST.typeArgumentList && genericTypeAST.typeArgumentList.typeArguments.length) {
                for (var i = 0; i < genericTypeAST.typeArgumentList.typeArguments.length; i++) {
                    typeArgs[i] = this.resolveTypeReference(genericTypeAST.typeArgumentList.typeArguments[i], context);

                    if (typeArgs[i].isError()) {
                        typeArgs[i] = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
            }

            if (typeArgs.length && typeArgs.length !== typeParameters.length) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(genericTypeAST, TypeScript.DiagnosticCode.Generic_type_0_requires_1_type_argument_s, [genericTypeSymbol.toString(), genericTypeSymbol.getTypeParameters().length]));
                return this.getNewErrorTypeSymbol();
            }

            if (!genericTypeSymbol.isResolved) {
                var typeDecls = genericTypeSymbol.getDeclarations();
                var childDecls = null;

                for (var i = 0; i < typeDecls.length; i++) {
                    childDecls = typeDecls[i].getChildDecls();

                    for (var j = 0; j < childDecls.length; j++) {
                        childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                    }
                }
            }

            var specializedSymbol = this.createInstantiatedType(genericTypeSymbol, typeArgs);

            var upperBound = null;

            typeParameters = specializedSymbol.getTypeParameters();

            var typeConstraintSubstitutionMap = [];

            var instantiatedSubstitutionMap = specializedSymbol.getTypeParameterSubstitutionMap();

            for (var i = 0; i < typeParameters.length; i++) {
                typeConstraintSubstitutionMap[typeParameters[i].pullSymbolID] = typeParameters[i];
            }

            for (var id in instantiatedSubstitutionMap) {
                typeConstraintSubstitutionMap[id] = instantiatedSubstitutionMap[id];
            }

            for (var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                var typeArg = typeArgs[iArg];
                var typeParameter = typeParameters[iArg];
                var typeConstraint = typeParameter.getConstraint();

                typeConstraintSubstitutionMap[typeParameter.pullSymbolID] = typeArg;

                if (typeConstraint) {
                    if (typeConstraint.isTypeParameter()) {
                        for (var j = 0; j < typeParameters.length && j < typeArgs.length; j++) {
                            if (typeParameters[j] === typeConstraint) {
                                typeConstraint = typeArgs[j];
                            }
                        }
                    } else if (typeConstraint.isGeneric()) {
                        typeConstraint = this.instantiateType(typeConstraint, typeConstraintSubstitutionMap);
                    }

                    if (typeArg.isTypeParameter()) {
                        upperBound = typeArg.getConstraint();

                        if (upperBound) {
                            typeArg = upperBound;
                        }
                    }

                    if (typeArg.inResolution || (typeArg.isTypeReference() && typeArg.referencedTypeSymbol.inResolution)) {
                        return specializedSymbol;
                    }

                    if (context.canTypeCheckAST(genericTypeAST)) {
                        this.typeCheckCallBacks.push(function (context) {
                            if (!_this.sourceIsAssignableToTarget(typeArg, typeConstraint, genericTypeAST, context)) {
                                var enclosingSymbol = _this.getEnclosingSymbolForAST(genericTypeAST);
                                context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(genericTypeAST, TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1, [typeArg.toString(enclosingSymbol, true), typeConstraint.toString(enclosingSymbol, true)]));
                            }
                        });
                    }
                }
            }

            return specializedSymbol;
        };

        PullTypeResolver.prototype.resolveQualifiedName = function (dottedNameAST, context) {
            if (this.inTypeQuery(dottedNameAST)) {
                return this.resolveDottedNameExpression(dottedNameAST, dottedNameAST.left, dottedNameAST.right, context).type;
            }

            var symbol = this.getSymbolForAST(dottedNameAST, context);
            if (!symbol || this.canTypeCheckAST(dottedNameAST, context)) {
                var canTypeCheck = this.canTypeCheckAST(dottedNameAST, context);
                if (canTypeCheck) {
                    this.setTypeChecked(dottedNameAST, context);
                }

                symbol = this.computeQualifiedName(dottedNameAST, context);
                this.setSymbolForAST(dottedNameAST, symbol, context);
            }

            this.resolveDeclaredSymbol(symbol, context);

            return symbol;
        };

        PullTypeResolver.prototype.isLastNameOfQualifiedModuleNameModuleReference = function (ast) {
            return ast.kind() === 11 /* IdentifierName */ && ast.parent && ast.parent.kind() === 121 /* QualifiedName */ && ast.parent.right === ast && ast.parent.parent && ast.parent.parent.kind() === 247 /* ModuleNameModuleReference */;
        };

        PullTypeResolver.prototype.computeQualifiedName = function (dottedNameAST, context) {
            var rhsName = TypeScript.tokenValueText(dottedNameAST.right);
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var enclosingDecl = this.getEnclosingDeclForAST(dottedNameAST);
            var lhs = this.resolveAST(dottedNameAST.left, false, context);

            var lhsType = lhs.isAlias() ? lhs.getExportAssignedContainerSymbol() : lhs.type;

            if (this.inClassExtendsHeritageClause(dottedNameAST) && !this.inTypeArgumentList(dottedNameAST)) {
                if (lhs.isAlias()) {
                    lhs.setIsUsedAsValue();
                }
            }

            if (!lhsType) {
                return this.getNewErrorTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            var onLeftOfDot = this.isLeftSideOfQualifiedName(dottedNameAST);
            var isNameOfModule = dottedNameAST.parent.kind() === 131 /* ModuleDeclaration */ && dottedNameAST.parent.name === dottedNameAST;

            var memberKind = (onLeftOfDot || isNameOfModule) ? 164 /* SomeContainer */ : 58728795 /* SomeType */;

            var childTypeSymbol = this.getNamedPropertySymbol(rhsName, memberKind, lhsType);

            if (!childTypeSymbol && !isNameOfModule && this.isLastNameOfQualifiedModuleNameModuleReference(dottedNameAST.right)) {
                childTypeSymbol = this.getNamedPropertySymbol(rhsName, 68147712 /* SomeValue */, lhsType);
            }

            if (!childTypeSymbol && lhsType.isContainer()) {
                var exportedContainer = lhsType.getExportAssignedContainerSymbol();

                if (exportedContainer) {
                    childTypeSymbol = this.getNamedPropertySymbol(rhsName, memberKind, exportedContainer);
                }
            }

            if (!childTypeSymbol && enclosingDecl) {
                var parentDecl = enclosingDecl;

                while (parentDecl) {
                    if (parentDecl.kind & 164 /* SomeContainer */) {
                        break;
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                if (parentDecl) {
                    var enclosingSymbolType = parentDecl.getSymbol(this.semanticInfoChain).type;

                    if (enclosingSymbolType === lhsType) {
                        childTypeSymbol = this.getNamedPropertySymbol(rhsName, memberKind, lhsType);
                    }
                }
            }

            if (!childTypeSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(dottedNameAST.right, TypeScript.DiagnosticCode.Property_0_does_not_exist_on_value_of_type_1, [dottedNameAST.right.text(), lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                return this.getNewErrorTypeSymbol(rhsName);
            }

            return childTypeSymbol;
        };

        PullTypeResolver.prototype.shouldContextuallyTypeAnyFunctionExpression = function (functionExpressionAST, typeParameters, parameters, returnTypeAnnotation, context) {
            if (typeParameters && typeParameters.typeParameters.length > 0) {
                return false;
            }

            if (returnTypeAnnotation) {
                return false;
            }

            if (parameters) {
                for (var i = 0, n = parameters.length; i < n; i++) {
                    if (parameters[i].typeAnnotation) {
                        return false;
                    }
                }
            }

            var contextualFunctionTypeSymbol = context.getContextualType();

            if (contextualFunctionTypeSymbol) {
                this.resolveDeclaredSymbol(contextualFunctionTypeSymbol, context);
                var callSignatures = contextualFunctionTypeSymbol.getCallSignatures();
                var exactlyOneCallSignature = callSignatures && callSignatures.length === 1;
                if (!exactlyOneCallSignature) {
                    return false;
                }

                var callSignatureIsGeneric = callSignatures[0].getTypeParameters().length > 0;
                return !callSignatureIsGeneric;
            }

            return false;
        };

        PullTypeResolver.prototype.resolveAnyFunctionExpression = function (funcDeclAST, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, isContextuallyTyped, context) {
            var funcDeclSymbol = null;
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            TypeScript.Debug.assert(functionDecl);

            if (functionDecl && functionDecl.hasSymbol(this.semanticInfoChain)) {
                funcDeclSymbol = functionDecl.getSymbol(this.semanticInfoChain);
                if (funcDeclSymbol.isResolved || funcDeclSymbol.inResolution) {
                    return funcDeclSymbol;
                }
            }

            funcDeclSymbol = functionDecl.getSymbol(this.semanticInfoChain);
            TypeScript.Debug.assert(funcDeclSymbol);

            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            funcDeclSymbol.startResolving();

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            var assigningFunctionSignature = null;
            if (isContextuallyTyped && this.shouldContextuallyTypeAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, context)) {
                assigningFunctionSignature = context.getContextualType().getCallSignatures()[0];
            }

            this.resolveAnyFunctionExpressionParameters(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, isContextuallyTyped, context);

            if (returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(returnTypeAnnotation, context);
            } else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.returnType;

                    if (returnType) {
                        context.propagateContextualType(returnType);
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, bodyExpression, signature, true, functionDecl, context);
                        context.popAnyContextualType();
                    } else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                        if (this.compilationSettings.noImplicitAny()) {
                            var functionExpressionName = functionDecl.getFunctionExpressionName();

                            if (functionExpressionName != "") {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionExpressionName]));
                            } else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                            }
                        }
                    }
                } else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, block, bodyExpression, signature, false, functionDecl, context);
                }
            }

            context.setTypeInContext(funcDeclSymbol, funcDeclType);
            funcDeclSymbol.setResolved();

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, isContextuallyTyped, context);
            }

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.resolveAnyFunctionExpressionParameters = function (funcDeclAST, typeParameters, parameters, returnTypeAnnotation, isContextuallyTyped, context) {
            if (!parameters) {
                return;
            }

            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var contextParams = [];

            var assigningFunctionSignature = null;
            if (isContextuallyTyped && this.shouldContextuallyTypeAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, context)) {
                assigningFunctionSignature = context.getContextualType().getCallSignatures()[0];
            }

            if (assigningFunctionSignature) {
                contextParams = assigningFunctionSignature.parameters;
            }

            var contextualParametersCount = contextParams.length;
            for (var i = 0, n = parameters.length; i < n; i++) {
                var actualParameterIsVarArgParameter = (i === (n - 1)) && TypeScript.lastParameterIsRest(parameters);
                var correspondingContextualParameter = null;
                var contextualParameterType = null;

                if (i < contextualParametersCount) {
                    correspondingContextualParameter = contextParams[i];
                } else if (contextualParametersCount && contextParams[contextualParametersCount - 1].isVarArg) {
                    correspondingContextualParameter = contextParams[contextualParametersCount - 1];
                }

                if (correspondingContextualParameter) {
                    if (correspondingContextualParameter.isVarArg === actualParameterIsVarArgParameter) {
                        contextualParameterType = correspondingContextualParameter.type;
                    } else if (correspondingContextualParameter.isVarArg) {
                        contextualParameterType = correspondingContextualParameter.type.getElementType();
                    }
                }

                this.resolveFunctionExpressionParameter(parameters[i], contextualParameterType, functionDecl, context);
            }
        };

        PullTypeResolver.prototype.typeCheckSimpleArrowFunctionExpression = function (arrowFunction, isContextuallyTyped, context) {
            return this.typeCheckAnyFunctionExpression(arrowFunction, null, [arrowFunction.parameter], null, arrowFunction.block, arrowFunction.expression, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.typeCheckParenthesizedArrowFunctionExpression = function (arrowFunction, isContextuallyTyped, context) {
            return this.typeCheckAnyFunctionExpression(arrowFunction, arrowFunction.callSignature.typeParameterList, arrowFunction.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(arrowFunction), arrowFunction.block, arrowFunction.expression, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.typeCheckAnyFunctionExpression = function (funcDeclAST, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, isContextuallyTyped, context) {
            var _this = this;
            this.setTypeChecked(funcDeclAST, context);

            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcDeclSymbol = functionDecl.getSymbol(this.semanticInfoChain);
            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            var returnTypeSymbol = signature.returnType;

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            this.resolveAnyFunctionExpressionParameters(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, isContextuallyTyped, context);

            context.pushNewContextualType(null);
            if (block) {
                this.resolveAST(block, false, context);
            } else {
                var bodyExpressionType = this.resolveReturnExpression(bodyExpression, functionDecl, context);
                this.typeCheckReturnExpression(bodyExpression, bodyExpressionType, functionDecl, context);
            }

            context.popAnyContextualType();

            this.checkThatNonVoidFunctionHasReturnExpressionOrThrowStatement(functionDecl, returnTypeAnnotation, returnTypeSymbol, block, context);

            this.validateVariableDeclarationGroups(functionDecl, context);

            this.typeCheckCallBacks.push(function (context) {
                _this.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        };

        PullTypeResolver.prototype.resolveThisExpression = function (thisExpression, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(thisExpression);
            var thisTypeSymbol = this.getContextualClassSymbolForEnclosingDecl(thisExpression, enclosingDecl) || this.semanticInfoChain.anyTypeSymbol;

            if (this.canTypeCheckAST(thisExpression, context)) {
                this.typeCheckThisExpression(thisExpression, context, enclosingDecl);
            }

            return thisTypeSymbol;
        };

        PullTypeResolver.prototype.inTypeArgumentList = function (ast) {
            var previous = null;
            var current = ast;

            while (current) {
                switch (current.kind()) {
                    case 126 /* GenericType */:
                        var genericType = current;
                        if (genericType.typeArgumentList === previous) {
                            return true;
                        }
                        break;

                    case 227 /* ArgumentList */:
                        var argumentList = current;
                        return argumentList.typeArgumentList === previous;
                }

                previous = current;
                current = current.parent;
            }

            return false;
        };

        PullTypeResolver.prototype.inClassExtendsHeritageClause = function (ast) {
            while (ast) {
                switch (ast.kind()) {
                    case 231 /* ExtendsHeritageClause */:
                        var heritageClause = ast;

                        return heritageClause.parent.parent.kind() === 132 /* ClassDeclaration */;

                    case 138 /* ConstructorDeclaration */:
                    case 132 /* ClassDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        return false;
                }

                ast = ast.parent;
            }

            return false;
        };

        PullTypeResolver.prototype.inTypeQuery = function (ast) {
            while (ast) {
                switch (ast.kind()) {
                    case 127 /* TypeQuery */:
                        return true;
                    case 130 /* FunctionDeclaration */:
                    case 214 /* InvocationExpression */:
                    case 138 /* ConstructorDeclaration */:
                    case 132 /* ClassDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        return false;
                }

                ast = ast.parent;
            }

            return false;
        };

        PullTypeResolver.prototype.inArgumentListOfSuperInvocation = function (ast) {
            var previous = null;
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case 214 /* InvocationExpression */:
                        var invocationExpression = current;
                        if (previous === invocationExpression.argumentList && invocationExpression.expression.kind() === 50 /* SuperKeyword */) {
                            return true;
                        }
                        break;

                    case 138 /* ConstructorDeclaration */:
                    case 132 /* ClassDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        return false;
                }

                previous = current;
                current = current.parent;
            }

            return false;
        };

        PullTypeResolver.prototype.inConstructorParameterList = function (ast) {
            var previous = null;
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case 143 /* CallSignature */:
                        var callSignature = current;
                        if (previous === callSignature.parameterList && callSignature.parent.kind() === 138 /* ConstructorDeclaration */) {
                            return true;
                        }

                    case 132 /* ClassDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        return false;
                }

                previous = current;
                current = current.parent;
            }

            return false;
        };
        PullTypeResolver.prototype.isFunctionAccessorOrNonArrowFunctionExpression = function (decl) {
            if (decl.kind === 262144 /* GetAccessor */ || decl.kind === 524288 /* SetAccessor */) {
                return true;
            }

            return this.isFunctionOrNonArrowFunctionExpression(decl);
        };

        PullTypeResolver.prototype.isFunctionOrNonArrowFunctionExpression = function (decl) {
            if (decl.kind === 16384 /* Function */) {
                return true;
            } else if (decl.kind === 131072 /* FunctionExpression */ && !TypeScript.hasFlag(decl.flags, 8192 /* ArrowFunction */)) {
                return true;
            }

            return false;
        };

        PullTypeResolver.prototype.typeCheckThisExpression = function (thisExpression, context, enclosingDecl) {
            this.checkForThisCaptureInArrowFunction(thisExpression);

            if (this.inConstructorParameterList(thisExpression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_constructor_arguments));
                return;
            }

            for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                if (this.isFunctionAccessorOrNonArrowFunctionExpression(currentDecl)) {
                    return;
                } else if (currentDecl.kind === 4 /* Container */ || currentDecl.kind === 32 /* DynamicModule */) {
                    if (currentDecl.getParentDecl() === null) {
                        return;
                    } else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_a_module_body));
                        return;
                    }
                } else if (currentDecl.kind === 64 /* Enum */) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_current_location));
                    return;
                } else if (currentDecl.kind === 32768 /* ConstructorMethod */) {
                    if (this.inArgumentListOfSuperInvocation(thisExpression) && this.superCallMustBeFirstStatementInConstructor(currentDecl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_current_location));
                    }

                    return;
                } else if (currentDecl.kind === 8 /* Class */) {
                    if (this.inStaticMemberVariableDeclaration(thisExpression)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, TypeScript.DiagnosticCode.this_cannot_be_referenced_in_a_static_property_initializer));
                    }

                    return;
                }
            }
        };

        PullTypeResolver.prototype.getContextualClassSymbolForEnclosingDecl = function (ast, enclosingDecl) {
            var declPath = enclosingDecl.getParentPath();

            if (declPath.length) {
                var isStaticContext = false;

                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;

                    if (declFlags & 16 /* Static */) {
                        isStaticContext = true;
                    } else if (declKind === 131072 /* FunctionExpression */ && !TypeScript.hasFlag(declFlags, 8192 /* ArrowFunction */)) {
                        return null;
                    } else if (declKind === 16384 /* Function */) {
                        return null;
                    } else if (declKind === 8 /* Class */) {
                        if (this.inStaticMemberVariableDeclaration(ast)) {
                            return this.getNewErrorTypeSymbol();
                        } else {
                            var classSymbol = decl.getSymbol(this.semanticInfoChain);
                            if (isStaticContext) {
                                var constructorSymbol = classSymbol.getConstructorMethod();
                                return constructorSymbol.type;
                            } else {
                                return classSymbol;
                            }
                        }
                    }
                }
            }

            return null;
        };

        PullTypeResolver.prototype.inStaticMemberVariableDeclaration = function (ast) {
            while (ast) {
                if (ast.kind() === 137 /* MemberVariableDeclaration */ && TypeScript.hasModifier(ast.modifiers, 16 /* Static */)) {
                    return true;
                }

                ast = ast.parent;
            }

            return false;
        };

        PullTypeResolver.prototype.resolveSuperExpression = function (ast, context) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            var superType = this.semanticInfoChain.anyTypeSymbol;

            var classSymbol = this.getContextualClassSymbolForEnclosingDecl(ast, enclosingDecl);

            if (classSymbol) {
                this.resolveDeclaredSymbol(classSymbol, context);

                var parents = classSymbol.getExtendedTypes();

                if (parents.length) {
                    superType = parents[0];
                }
            }

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSuperExpression(ast, context, enclosingDecl);
            }

            return superType;
        };

        PullTypeResolver.prototype.typeCheckSuperExpression = function (ast, context, enclosingDecl) {
            this.setTypeChecked(ast, context);

            this.checkForThisCaptureInArrowFunction(ast);

            var isSuperCall = ast.parent.kind() === 214 /* InvocationExpression */;
            var isSuperPropertyAccess = ast.parent.kind() === 213 /* MemberAccessExpression */;
            TypeScript.Debug.assert(isSuperCall || isSuperPropertyAccess);

            if (isSuperPropertyAccess) {
                for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                    if (this.isFunctionOrNonArrowFunctionExpression(currentDecl)) {
                        break;
                    } else if (currentDecl.kind === 8 /* Class */) {
                        if (!this.enclosingClassIsDerived(currentDecl)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_can_only_be_referenced_in_a_derived_class));
                            return;
                        } else if (this.inConstructorParameterList(ast)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_cannot_be_referenced_in_constructor_arguments));
                            return;
                        } else if (this.inStaticMemberVariableDeclaration(ast)) {
                            break;
                        }

                        return;
                    }
                }
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class));
                return;
            } else {
                for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                    if (currentDecl.kind === 32768 /* ConstructorMethod */) {
                        var classDecl = currentDecl.getParentDecl();

                        if (!this.enclosingClassIsDerived(classDecl)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_can_only_be_referenced_in_a_derived_class));
                            return;
                        } else if (this.inConstructorParameterList(ast)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.super_cannot_be_referenced_in_constructor_arguments));
                            return;
                        }

                        return;
                    } else if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(currentDecl.ast())) {
                        break;
                    }
                }

                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors));
            }
        };

        PullTypeResolver.prototype.resolveSimplePropertyAssignment = function (propertyAssignment, isContextuallyTyped, context) {
            return this.resolveAST(propertyAssignment.expression, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.resolveFunctionPropertyAssignment = function (funcProp, isContextuallyTyped, context) {
            return this.resolveAnyFunctionExpression(funcProp, funcProp.callSignature.typeParameterList, funcProp.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(funcProp), funcProp.block, null, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.typeCheckFunctionPropertyAssignment = function (funcProp, isContextuallyTyped, context) {
            this.typeCheckAnyFunctionExpression(funcProp, funcProp.callSignature.typeParameterList, funcProp.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(funcProp), funcProp.block, null, isContextuallyTyped, context);
        };

        PullTypeResolver.prototype.resolveObjectLiteralExpression = function (expressionAST, isContextuallyTyped, context, additionalResults) {
            var symbol = this.getSymbolForAST(expressionAST, context);
            var hasResolvedSymbol = symbol && symbol.isResolved;

            if (!hasResolvedSymbol || additionalResults || this.canTypeCheckAST(expressionAST, context)) {
                if (this.canTypeCheckAST(expressionAST, context)) {
                    this.setTypeChecked(expressionAST, context);
                }
                symbol = this.computeObjectLiteralExpression(expressionAST, isContextuallyTyped, context, additionalResults);
                this.setSymbolForAST(expressionAST, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.bindObjectLiteralMembers = function (objectLiteralDeclaration, objectLiteralTypeSymbol, objectLiteralMembers, isUsingExistingSymbol, pullTypeContext) {
            var boundMemberSymbols = [];
            var memberSymbol;
            for (var i = 0, len = objectLiteralMembers.length; i < len; i++) {
                var propertyAssignment = objectLiteralMembers[i];

                var id = this.getPropertyAssignmentName(propertyAssignment);
                var assignmentText = getPropertyAssignmentNameTextFromIdentifier(id);

                var isAccessor = propertyAssignment.kind() === 140 /* GetAccessor */ || propertyAssignment.kind() === 141 /* SetAccessor */;
                var decl = this.semanticInfoChain.getDeclForAST(propertyAssignment);
                TypeScript.Debug.assert(decl);

                if (propertyAssignment.kind() === 241 /* SimplePropertyAssignment */) {
                    if (!isUsingExistingSymbol) {
                        memberSymbol = new TypeScript.PullSymbol(assignmentText.memberName, 4096 /* Property */, this.semanticInfoChain);
                        memberSymbol.addDeclaration(decl);
                        decl.setSymbol(memberSymbol, this.semanticInfoChain);
                    } else {
                        memberSymbol = decl.getSymbol(this.semanticInfoChain);
                    }
                } else if (propertyAssignment.kind() === 242 /* FunctionPropertyAssignment */) {
                    memberSymbol = decl.getSymbol(this.semanticInfoChain);
                } else {
                    TypeScript.Debug.assert(isAccessor);
                    memberSymbol = decl.getSymbol(this.semanticInfoChain);
                }

                if (!isUsingExistingSymbol && !isAccessor) {
                    var existingMember = objectLiteralTypeSymbol.findMember(memberSymbol.name, true);
                    if (existingMember) {
                        pullTypeContext.postDiagnostic(this.semanticInfoChain.duplicateIdentifierDiagnosticFromAST(propertyAssignment, assignmentText.actualText));
                    }

                    objectLiteralTypeSymbol.addMember(memberSymbol);
                }

                boundMemberSymbols.push(memberSymbol);
            }

            return boundMemberSymbols;
        };

        PullTypeResolver.prototype.resolveObjectLiteralMembers = function (objectLiteralDeclaration, objectLiteralTypeSymbol, objectLiteralContextualType, objectLiteralMembers, stringIndexerSignature, numericIndexerSignature, allMemberTypes, allNumericMemberTypes, boundMemberSymbols, isUsingExistingSymbol, pullTypeContext, additionalResults) {
            for (var i = 0, len = objectLiteralMembers.length; i < len; i++) {
                var propertyAssignment = objectLiteralMembers[i];

                var acceptedContextualType = false;
                var assigningSymbol = null;

                var id = this.getPropertyAssignmentName(propertyAssignment);
                var memberSymbol = boundMemberSymbols[i];
                var contextualMemberType = null;

                if (objectLiteralContextualType) {
                    assigningSymbol = this.getNamedPropertySymbol(memberSymbol.name, 68147712 /* SomeValue */, objectLiteralContextualType);

                    if (!assigningSymbol) {
                        if (numericIndexerSignature && TypeScript.PullHelpers.isNameNumeric(memberSymbol.name)) {
                            assigningSymbol = numericIndexerSignature;
                        } else if (stringIndexerSignature) {
                            assigningSymbol = stringIndexerSignature;
                        }
                    }

                    if (assigningSymbol) {
                        this.resolveDeclaredSymbol(assigningSymbol, pullTypeContext);

                        contextualMemberType = assigningSymbol.kind === 4194304 /* IndexSignature */ ? assigningSymbol.returnType : assigningSymbol.type;
                        pullTypeContext.propagateContextualType(contextualMemberType);

                        acceptedContextualType = true;

                        if (additionalResults) {
                            additionalResults.membersContextTypeSymbols[i] = contextualMemberType;
                        }
                    }
                }

                var memberSymbolType = this.resolveAST(propertyAssignment, contextualMemberType !== null, pullTypeContext).type;

                if (memberSymbolType) {
                    if (memberSymbolType.isGeneric()) {
                        objectLiteralTypeSymbol.setHasGenericMember();
                    }

                    if (stringIndexerSignature) {
                        allMemberTypes.push(memberSymbolType);
                    }
                    if (numericIndexerSignature && TypeScript.PullHelpers.isNameNumeric(memberSymbol.name)) {
                        allNumericMemberTypes.push(memberSymbolType);
                    }
                }

                if (acceptedContextualType) {
                    pullTypeContext.popAnyContextualType();
                }

                var isAccessor = propertyAssignment.kind() === 141 /* SetAccessor */ || propertyAssignment.kind() === 140 /* GetAccessor */;
                if (!memberSymbol.isResolved) {
                    if (isAccessor) {
                        this.setSymbolForAST(id, memberSymbolType, pullTypeContext);
                    } else {
                        pullTypeContext.setTypeInContext(memberSymbol, memberSymbolType);
                        memberSymbol.setResolved();

                        this.setSymbolForAST(id, memberSymbol, pullTypeContext);
                    }
                }
            }
        };

        PullTypeResolver.prototype.computeObjectLiteralExpression = function (objectLitAST, isContextuallyTyped, context, additionalResults) {
            var objectLitDecl = this.semanticInfoChain.getDeclForAST(objectLitAST);
            TypeScript.Debug.assert(objectLitDecl);

            var typeSymbol = this.getSymbolForAST(objectLitAST, context);
            var isUsingExistingSymbol = !!typeSymbol;

            if (!typeSymbol) {
                typeSymbol = new TypeScript.PullTypeSymbol("", 256 /* ObjectLiteral */, this.semanticInfoChain);
                typeSymbol.addDeclaration(objectLitDecl);
                this.setSymbolForAST(objectLitAST, typeSymbol, context);
                objectLitDecl.setSymbol(typeSymbol, this.semanticInfoChain);
            }

            var propertyAssignments = objectLitAST.propertyAssignments;
            var contextualType = null;

            if (isContextuallyTyped) {
                contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, context);
            }

            var stringIndexerSignature = null;
            var numericIndexerSignature = null;
            var allMemberTypes = null;
            var allNumericMemberTypes = null;

            if (contextualType) {
                var indexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(contextualType, context);

                stringIndexerSignature = indexSignatures.stringSignature;
                numericIndexerSignature = indexSignatures.numericSignature;

                if (stringIndexerSignature) {
                    allMemberTypes = [];
                }

                if (numericIndexerSignature) {
                    allNumericMemberTypes = [];
                }
            }

            if (propertyAssignments) {
                if (additionalResults) {
                    additionalResults.membersContextTypeSymbols = [];
                }

                var boundMemberSymbols = this.bindObjectLiteralMembers(objectLitDecl, typeSymbol, propertyAssignments, isUsingExistingSymbol, context);

                this.resolveObjectLiteralMembers(objectLitDecl, typeSymbol, contextualType, propertyAssignments, stringIndexerSignature, numericIndexerSignature, allMemberTypes, allNumericMemberTypes, boundMemberSymbols, isUsingExistingSymbol, context, additionalResults);

                if (!isUsingExistingSymbol) {
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allMemberTypes, stringIndexerSignature, context);
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allNumericMemberTypes, numericIndexerSignature, context);
                }
            }

            typeSymbol.setResolved();
            return typeSymbol;
        };

        PullTypeResolver.prototype.getPropertyAssignmentName = function (propertyAssignment) {
            if (propertyAssignment.kind() === 241 /* SimplePropertyAssignment */) {
                return propertyAssignment.propertyName;
            } else if (propertyAssignment.kind() === 242 /* FunctionPropertyAssignment */) {
                return propertyAssignment.propertyName;
            } else if (propertyAssignment.kind() === 140 /* GetAccessor */) {
                return propertyAssignment.propertyName;
            } else if (propertyAssignment.kind() === 141 /* SetAccessor */) {
                return propertyAssignment.propertyName;
            } else {
                TypeScript.Debug.assert(false);
            }
        };

        PullTypeResolver.prototype.stampObjectLiteralWithIndexSignature = function (objectLiteralSymbol, indexerTypeCandidates, contextualIndexSignature, context) {
            if (contextualIndexSignature) {
                var typeCollection = {
                    getLength: function () {
                        return indexerTypeCandidates.length;
                    },
                    getTypeAtIndex: function (index) {
                        return indexerTypeCandidates[index];
                    }
                };
                var decl = objectLiteralSymbol.getDeclarations()[0];
                var indexerReturnType = this.findBestCommonType(contextualIndexSignature.returnType, typeCollection, context).widenedType(this, null, context);
                if (indexerReturnType === contextualIndexSignature.returnType) {
                    objectLiteralSymbol.addIndexSignature(contextualIndexSignature);
                } else {
                    this.semanticInfoChain.addSyntheticIndexSignature(decl, objectLiteralSymbol, this.getASTForDecl(decl), contextualIndexSignature.parameters[0].name, contextualIndexSignature.parameters[0].type, indexerReturnType);
                }
            }
        };

        PullTypeResolver.prototype.resolveArrayLiteralExpression = function (arrayLit, isContextuallyTyped, context) {
            var symbol = this.getSymbolForAST(arrayLit, context);
            if (!symbol || this.canTypeCheckAST(arrayLit, context)) {
                if (this.canTypeCheckAST(arrayLit, context)) {
                    this.setTypeChecked(arrayLit, context);
                }
                symbol = this.computeArrayLiteralExpressionSymbol(arrayLit, isContextuallyTyped, context);
                this.setSymbolForAST(arrayLit, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeArrayLiteralExpressionSymbol = function (arrayLit, isContextuallyTyped, context) {
            var elements = arrayLit.expressions;
            var elementTypes = [];
            var contextualElementType = null;

            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, context);

                if (contextualType) {
                    var indexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(contextualType, context);
                    if (indexSignatures.numericSignature) {
                        contextualElementType = indexSignatures.numericSignature.returnType;
                    }
                }
            }

            if (elements) {
                if (contextualElementType) {
                    context.propagateContextualType(contextualElementType);
                }

                for (var i = 0, n = elements.length; i < n; i++) {
                    elementTypes.push(this.resolveAST(elements[i], contextualElementType !== null, context).type);
                }

                if (contextualElementType) {
                    context.popAnyContextualType();
                }
            }

            var elementTypesCollection = {
                getLength: function () {
                    return elements.length;
                },
                getTypeAtIndex: function (index) {
                    return elementTypes[index];
                }
            };

            contextualElementType = context.isInferentiallyTyping() ? null : contextualElementType;

            var elementType = contextualElementType === null && elements.length === 0 ? this.semanticInfoChain.undefinedTypeSymbol : this.findBestCommonType(contextualElementType, elementTypesCollection, context);

            return this.getArrayType(elementType);
        };

        PullTypeResolver.prototype.resolveElementAccessExpression = function (callEx, context) {
            var symbolAndDiagnostic = this.computeElementAccessExpressionSymbolAndDiagnostic(callEx, context);

            if (this.canTypeCheckAST(callEx, context)) {
                this.typeCheckElementAccessExpression(callEx, context, symbolAndDiagnostic);
            }

            return symbolAndDiagnostic.symbol;
        };

        PullTypeResolver.prototype.typeCheckElementAccessExpression = function (callEx, context, symbolAndDiagnostic) {
            this.setTypeChecked(callEx, context);
            context.postDiagnostic(symbolAndDiagnostic.diagnostic);
        };

        PullTypeResolver.prototype.computeElementAccessExpressionSymbolAndDiagnostic = function (callEx, context) {
            var targetSymbol = this.resolveAST(callEx.expression, false, context);
            var indexType = this.resolveAST(callEx.argumentExpression, false, context).type;

            var targetTypeSymbol = targetSymbol.type;

            targetTypeSymbol = this.getApparentType(targetTypeSymbol);

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                return { symbol: targetTypeSymbol };
            }

            var elementType = targetTypeSymbol.getElementType();

            var isNumberIndex = indexType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(indexType);

            if (elementType && isNumberIndex) {
                return { symbol: elementType };
            }

            if (callEx.argumentExpression.kind() === 14 /* StringLiteral */ || callEx.argumentExpression.kind() === 13 /* NumericLiteral */) {
                var memberName = callEx.argumentExpression.kind() === 14 /* StringLiteral */ ? TypeScript.stripStartAndEndQuotes(callEx.argumentExpression.text()) : TypeScript.tokenValueText(callEx.argumentExpression);

                var member = this._getNamedPropertySymbolOfAugmentedType(memberName, targetTypeSymbol);

                if (member) {
                    this.resolveDeclaredSymbol(member, context);

                    return { symbol: member.type };
                }
            }

            var signatures = this.getBothKindsOfIndexSignaturesIncludingAugmentedType(targetTypeSymbol, context);

            var stringSignature = signatures.stringSignature;
            var numberSignature = signatures.numericSignature;

            if (numberSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol)) {
                return { symbol: numberSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            } else if (stringSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol)) {
                return { symbol: stringSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            } else if (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol) {
                if (this.compilationSettings.noImplicitAny()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(callEx.argumentExpression, TypeScript.DiagnosticCode.Index_signature_of_object_type_implicitly_has_an_any_type));
                }
                return { symbol: this.semanticInfoChain.anyTypeSymbol };
            } else {
                return {
                    symbol: this.getNewErrorTypeSymbol(),
                    diagnostic: this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.An_index_expression_argument_must_be_string_number_or_any)
                };
            }
        };

        PullTypeResolver.prototype.getBothKindsOfIndexSignaturesIncludingAugmentedType = function (enclosingType, context) {
            return this._getBothKindsOfIndexSignatures(enclosingType, context, true);
        };

        PullTypeResolver.prototype.getBothKindsOfIndexSignaturesExcludingAugmentedType = function (enclosingType, context) {
            return this._getBothKindsOfIndexSignatures(enclosingType, context, false);
        };

        PullTypeResolver.prototype._getBothKindsOfIndexSignatures = function (enclosingType, context, includeAugmentedType) {
            var signatures = includeAugmentedType ? enclosingType.getIndexSignaturesOfAugmentedType(this, this.cachedFunctionInterfaceType(), this.cachedObjectInterfaceType()) : enclosingType.getIndexSignatures();

            var stringSignature = null;
            var numberSignature = null;
            var signature = null;
            var paramSymbols;
            var paramType;

            for (var i = 0; i < signatures.length; i++) {
                if (stringSignature && numberSignature) {
                    break;
                }

                signature = signatures[i];
                if (!signature.isResolved) {
                    this.resolveDeclaredSymbol(signature, context);
                }

                paramSymbols = signature.parameters;

                if (paramSymbols.length) {
                    paramType = paramSymbols[0].type;

                    if (!stringSignature && paramType === this.semanticInfoChain.stringTypeSymbol) {
                        stringSignature = signature;
                        continue;
                    } else if (!numberSignature && paramType === this.semanticInfoChain.numberTypeSymbol) {
                        numberSignature = signature;
                        continue;
                    }
                }
            }

            return {
                numericSignature: numberSignature,
                stringSignature: stringSignature
            };
        };

        PullTypeResolver.prototype._addUnhiddenSignaturesFromBaseType = function (derivedTypeSignatures, baseTypeSignatures, signaturesBeingAggregated) {
            var _this = this;
            if (!derivedTypeSignatures) {
                signaturesBeingAggregated.push.apply(signaturesBeingAggregated, baseTypeSignatures);
                return;
            }

            var context = new TypeScript.PullTypeResolutionContext(this);
            for (var i = 0; i < baseTypeSignatures.length; i++) {
                var baseSignature = baseTypeSignatures[i];

                var signatureIsHidden = TypeScript.ArrayUtilities.any(derivedTypeSignatures, function (sig) {
                    return _this.signaturesAreIdenticalWithNewEnclosingTypes(baseSignature, sig, context, false);
                });

                if (!signatureIsHidden) {
                    signaturesBeingAggregated.push(baseSignature);
                }
            }
        };

        PullTypeResolver.prototype.resolveBinaryAdditionOperation = function (binaryExpression, context) {
            var lhsExpression = this.resolveAST(binaryExpression.left, false, context);
            var lhsType = lhsExpression.type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;

            if (TypeScript.PullHelpers.symbolIsEnum(lhsType)) {
                lhsType = this.semanticInfoChain.numberTypeSymbol;
            }

            if (TypeScript.PullHelpers.symbolIsEnum(rhsType)) {
                rhsType = this.semanticInfoChain.numberTypeSymbol;
            }

            var isLhsTypeNullOrUndefined = lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol;
            var isRhsTypeNullOrUndefined = rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol;

            if (isLhsTypeNullOrUndefined) {
                if (isRhsTypeNullOrUndefined) {
                    lhsType = rhsType = this.semanticInfoChain.anyTypeSymbol;
                } else {
                    lhsType = rhsType;
                }
            } else if (isRhsTypeNullOrUndefined) {
                rhsType = lhsType;
            }

            var exprType = null;

            if (lhsType === this.semanticInfoChain.stringTypeSymbol || rhsType === this.semanticInfoChain.stringTypeSymbol) {
                exprType = this.semanticInfoChain.stringTypeSymbol;
            } else if (this.isAnyOrEquivalent(lhsType) || this.isAnyOrEquivalent(rhsType)) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            } else if (rhsType === this.semanticInfoChain.numberTypeSymbol && lhsType === this.semanticInfoChain.numberTypeSymbol) {
                exprType = this.semanticInfoChain.numberTypeSymbol;
            }

            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.setTypeChecked(binaryExpression, context);

                if (exprType) {
                    if (binaryExpression.kind() === 176 /* AddAssignmentExpression */) {
                        if (!this.isReference(binaryExpression.left, lhsExpression)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                        }

                        this.checkAssignability(binaryExpression.left, exprType, lhsType, context);
                    }
                } else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_expression_types_not_known_to_support_the_addition_operator));
                }
            }

            if (!exprType) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }

            return exprType;
        };

        PullTypeResolver.prototype.bestCommonTypeOfTwoTypesWithOrWithoutContextualType = function (contextualType, type1, type2, context) {
            return this.findBestCommonType(contextualType, {
                getLength: function () {
                    return 2;
                },
                getTypeAtIndex: function (index) {
                    switch (index) {
                        case 0: return type1;
                        case 1: return type2;
                    }
                }
            }, context);
        };

        PullTypeResolver.prototype.resolveLogicalOrExpression = function (binex, isContextuallyTyped, context) {
            if (this.canTypeCheckAST(binex, context)) {
                this.setTypeChecked(binex, context);
            }

            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();
                var leftType = this.resolveAST(binex.left, isContextuallyTyped, context).type;
                var rightType = this.resolveAST(binex.right, isContextuallyTyped, context).type;

                return this.bestCommonTypeOfTwoTypesWithOrWithoutContextualType(contextualType, leftType, rightType, context);
            } else {
                var leftType = this.resolveAST(binex.left, false, context).type;

                context.pushNewContextualType(leftType);
                var rightType = this.resolveAST(binex.right, true, context).type;
                context.popAnyContextualType();

                return this.bestCommonTypeOfTwoTypesWithOrWithoutContextualType(null, leftType, rightType, context);
            }
        };

        PullTypeResolver.prototype.resolveLogicalAndExpression = function (binex, context) {
            if (this.canTypeCheckAST(binex, context)) {
                this.setTypeChecked(binex, context);

                this.resolveAST(binex.left, false, context);
            }

            return this.resolveAST(binex.right, false, context).type;
        };

        PullTypeResolver.prototype.computeTypeOfConditionalExpression = function (leftType, rightType, isContextuallyTyped, context) {
            var contextualType = isContextuallyTyped ? context.getContextualType() : null;
            return this.bestCommonTypeOfTwoTypesWithOrWithoutContextualType(contextualType, leftType, rightType, context);
        };

        PullTypeResolver.prototype.resolveConditionalExpression = function (trinex, isContextuallyTyped, context) {
            var leftType = this.resolveAST(trinex.whenTrue, isContextuallyTyped, context).type;
            var rightType = this.resolveAST(trinex.whenFalse, isContextuallyTyped, context).type;

            var expressionType = this.computeTypeOfConditionalExpression(leftType, rightType, isContextuallyTyped, context);

            var conditionalTypesAreValid = this.conditionExpressionTypesAreValid(leftType, rightType, expressionType, isContextuallyTyped, context);

            if (this.canTypeCheckAST(trinex, context)) {
                this.setTypeChecked(trinex, context);
                this.resolveAST(trinex.condition, false, context);

                if (!this.conditionExpressionTypesAreValid(leftType, rightType, expressionType, isContextuallyTyped, context)) {
                    if (isContextuallyTyped) {
                        var contextualType = context.getContextualType();
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(trinex, TypeScript.DiagnosticCode.No_best_common_type_exists_between_0_1_and_2, [contextualType.toString(), leftType.toString(), rightType.toString()]));
                    } else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(trinex, TypeScript.DiagnosticCode.No_best_common_type_exists_between_0_and_1, [leftType.toString(), rightType.toString()]));
                    }
                }
            }

            if (!conditionalTypesAreValid) {
                return this.getNewErrorTypeSymbol();
            }

            return expressionType;
        };

        PullTypeResolver.prototype.conditionExpressionTypesAreValid = function (leftType, rightType, expressionType, isContextuallyTyped, context) {
            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();
                if (this.typesAreIdentical(expressionType, leftType, context) || this.typesAreIdentical(expressionType, rightType, context) || this.typesAreIdentical(expressionType, contextualType, context)) {
                    return true;
                }
            } else {
                if (this.typesAreIdentical(expressionType, leftType, context) || this.typesAreIdentical(expressionType, rightType, context)) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.resolveParenthesizedExpression = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
            }

            return this.resolveAST(ast.expression, false, context);
        };

        PullTypeResolver.prototype.resolveExpressionStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveInvocationExpression = function (callEx, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx, context);

            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeInvocationExpressionSymbol(callEx, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                if (symbol !== this.semanticInfoChain.anyTypeSymbol) {
                    this.setSymbolForAST(callEx, symbol, context);
                }
                this.semanticInfoChain.setCallResolutionDataForAST(callEx, additionalResults);
            } else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckInvocationExpression(callEx, context);
                }

                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData !== additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.typeCheckInvocationExpression = function (callEx, context) {
            this.setTypeChecked(callEx, context);
            var targetSymbol = this.resolveAST(callEx.expression, false, context);

            if (callEx.argumentList.arguments) {
                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);

                var len = callEx.argumentList.arguments.length;
                for (var i = 0; i < len; i++) {
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols ? callResolutionData.actualParametersContextTypeSymbols[i] : null;
                    if (contextualType) {
                        context.pushNewContextualType(contextualType);
                    }

                    this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                    if (contextualType) {
                        context.popAnyContextualType();
                        contextualType = null;
                    }
                }
            }

            for (var i = 0; i < callResolutionData.diagnosticsFromOverloadResolution.length; i++) {
                context.postDiagnostic(callResolutionData.diagnosticsFromOverloadResolution[i]);
            }
        };

        PullTypeResolver.prototype.computeInvocationExpressionSymbol = function (callEx, context, additionalResults) {
            var targetSymbol = this.resolveAST(callEx.expression, false, context);
            var targetAST = this.getCallTargetErrorSpanAST(callEx);

            var targetTypeSymbol = targetSymbol.type;
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.resolveAST(callEx.argumentList.arguments, false, context);

                if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length) {
                    if (targetTypeSymbol === this.semanticInfoChain.anyTypeSymbol) {
                        this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Untyped_function_calls_may_not_accept_type_arguments), additionalResults, context);
                        return this.getNewErrorTypeSymbol();
                    }
                }

                return this.semanticInfoChain.anyTypeSymbol;
            }

            var isSuperCall = false;

            if (callEx.expression.kind() === 50 /* SuperKeyword */) {
                isSuperCall = true;

                if (targetTypeSymbol.isClass()) {
                    targetSymbol = targetTypeSymbol.getConstructorMethod();
                    this.resolveDeclaredSymbol(targetSymbol, context);
                    targetTypeSymbol = targetSymbol.type;
                } else {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Calls_to_super_are_only_valid_inside_a_class), additionalResults, context);
                    this.resolveAST(callEx.argumentList.arguments, false, context);

                    return this.getNewErrorTypeSymbol();
                }
            }

            var signatures = isSuperCall ? targetTypeSymbol.getConstructSignatures() : targetTypeSymbol.getCallSignatures();

            if (!signatures.length && (targetTypeSymbol.kind === 33554432 /* ConstructorType */)) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, [targetTypeSymbol.toString()]), additionalResults, context);
            }

            var explicitTypeArgs = null;
            var couldNotFindGenericOverload = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var typeArgumentCountDiagnostic = null;
            var diagnostics = [];

            if (callEx.argumentList.typeArgumentList) {
                explicitTypeArgs = [];

                if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length) {
                    for (var i = 0; i < callEx.argumentList.typeArgumentList.typeArguments.length; i++) {
                        explicitTypeArgs[i] = this.resolveTypeReference(callEx.argumentList.typeArgumentList.typeArguments[i], context);
                    }
                }
            }

            var triedToInferTypeArgs = false;

            var resolvedSignatures = [];
            var inferredOrExplicitTypeArgs;
            var specializedSignature;
            var typeParameters;
            var typeConstraint = null;
            var beforeResolutionSignatures = signatures;
            var targetTypeReplacementMap = targetTypeSymbol.getTypeParameterSubstitutionMap();

            for (var i = 0; i < signatures.length; i++) {
                typeParameters = signatures[i].getTypeParameters();
                couldNotAssignToConstraint = false;

                if (signatures[i].isGeneric() && typeParameters.length) {
                    if (isSuperCall && targetTypeSymbol.isGeneric() && !callEx.argumentList.typeArgumentList) {
                        explicitTypeArgs = signatures[i].returnType.getTypeArguments();
                    }

                    if (explicitTypeArgs) {
                        if (explicitTypeArgs.length === typeParameters.length) {
                            inferredOrExplicitTypeArgs = explicitTypeArgs;
                        } else {
                            typeArgumentCountDiagnostic = typeArgumentCountDiagnostic || this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [typeParameters.length, explicitTypeArgs.length]);
                            continue;
                        }
                    } else {
                        TypeScript.Debug.assert(callEx.argumentList);
                        var typeArgumentInferenceContext = new TypeScript.InvocationTypeArgumentInferenceContext(this, context, signatures[i], callEx.argumentList);
                        inferredOrExplicitTypeArgs = this.inferArgumentTypesForSignature(typeArgumentInferenceContext, new TypeComparisonInfo(), context);
                        triedToInferTypeArgs = true;
                    }

                    TypeScript.Debug.assert(inferredOrExplicitTypeArgs && inferredOrExplicitTypeArgs.length == typeParameters.length);

                    var mutableTypeReplacementMap = new TypeScript.PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(targetTypeReplacementMap ? targetTypeReplacementMap : []);
                    TypeScript.PullInstantiationHelpers.updateMutableTypeParameterSubstitutionMap(typeParameters, inferredOrExplicitTypeArgs, mutableTypeReplacementMap);
                    var typeReplacementMap = mutableTypeReplacementMap.typeParameterSubstitutionMap;

                    if (explicitTypeArgs) {
                        for (var j = 0; j < typeParameters.length; j++) {
                            typeConstraint = typeParameters[j].getConstraint();

                            if (typeConstraint) {
                                if (typeConstraint.isGeneric()) {
                                    typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                }

                                if (!this.sourceIsAssignableToTarget(inferredOrExplicitTypeArgs[j], typeConstraint, targetAST, context, null, true)) {
                                    var enclosingSymbol = this.getEnclosingSymbolForAST(targetAST);
                                    constraintDiagnostic = this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1, [inferredOrExplicitTypeArgs[j].toString(enclosingSymbol, true), typeConstraint.toString(enclosingSymbol, true)]);
                                    couldNotAssignToConstraint = true;
                                }

                                if (couldNotAssignToConstraint) {
                                    break;
                                }
                            }
                        }
                    }

                    if (couldNotAssignToConstraint) {
                        continue;
                    }

                    specializedSignature = this.instantiateSignature(signatures[i], typeReplacementMap);

                    if (specializedSignature) {
                        resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                    }
                } else {
                    if (!(callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length)) {
                        resolvedSignatures[resolvedSignatures.length] = signatures[i];
                    }
                }
            }

            if (signatures.length && !resolvedSignatures.length) {
                couldNotFindGenericOverload = true;
            }

            signatures = resolvedSignatures;

            var errorCondition = null;
            if (!signatures.length) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures && beforeResolutionSignatures.length ? beforeResolutionSignatures[0] : null;

                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

                this.resolveAST(callEx.argumentList.arguments, false, context);

                if (!couldNotFindGenericOverload) {
                    if (this.cachedFunctionInterfaceType() && this.sourceIsAssignableToTarget(targetTypeSymbol, this.cachedFunctionInterfaceType(), targetAST, context)) {
                        if (callEx.argumentList.typeArgumentList) {
                            this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments), additionalResults, context);
                        }
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature), additionalResults, context);
                } else if (constraintDiagnostic) {
                    this.postOverloadResolutionDiagnostics(constraintDiagnostic, additionalResults, context);
                } else if (typeArgumentCountDiagnostic) {
                    this.postOverloadResolutionDiagnostics(typeArgumentCountDiagnostic, additionalResults, context);
                } else {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression), additionalResults, context);
                }

                return this.getNewErrorTypeSymbol();
            }

            var signature = this.resolveOverloads(callEx, signatures, callEx.argumentList.typeArgumentList !== null, context, diagnostics);
            var useBeforeResolutionSignatures = signature == null;

            if (!signature) {
                for (var i = 0; i < diagnostics.length; i++) {
                    this.postOverloadResolutionDiagnostics(diagnostics[i], additionalResults, context);
                }

                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression), additionalResults, context);

                errorCondition = this.getNewErrorTypeSymbol();

                if (!signatures.length) {
                    return errorCondition;
                }

                signature = signatures[0];
            }

            var rootSignature = signature.getRootSymbol();
            if (!rootSignature.isGeneric() && callEx.argumentList.typeArgumentList) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments), additionalResults, context);
            } else if (rootSignature.isGeneric() && callEx.argumentList.typeArgumentList && rootSignature.getTypeParameters() && (callEx.argumentList.typeArgumentList.typeArguments.length !== rootSignature.getTypeParameters().length)) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [rootSignature.getTypeParameters().length, callEx.argumentList.typeArgumentList.typeArguments.length]), additionalResults, context);
            }

            var returnType = isSuperCall ? this.semanticInfoChain.voidTypeSymbol : signature.returnType;

            var actualParametersContextTypeSymbols = [];
            if (callEx.argumentList.arguments) {
                var len = callEx.argumentList.arguments.length;
                var params = signature.parameters;
                var contextualType = null;
                var signatureDecl = signature.getDeclarations()[0];

                for (var i = 0; i < len; i++) {
                    if (params.length) {
                        if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                            this.resolveDeclaredSymbol(params[i], context);
                            contextualType = params[i].type;
                        } else if (signature.hasVarArgs) {
                            contextualType = params[params.length - 1].type;
                            if (contextualType.isArrayNamedTypeReference()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                    }

                    if (contextualType) {
                        context.pushNewContextualType(contextualType);
                        actualParametersContextTypeSymbols[i] = contextualType;
                    }

                    this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                    if (contextualType) {
                        context.popAnyContextualType();
                        contextualType = null;
                    }
                }
            }

            additionalResults.targetSymbol = targetSymbol;
            if (useBeforeResolutionSignatures && beforeResolutionSignatures) {
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures[0];
            } else {
                additionalResults.resolvedSignatures = signatures;
                additionalResults.candidateSignature = signature;
            }
            additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

            if (errorCondition) {
                return errorCondition;
            }

            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }

            return returnType;
        };

        PullTypeResolver.prototype.resolveObjectCreationExpression = function (callEx, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx, context);

            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeObjectCreationExpressionSymbol(callEx, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                this.setSymbolForAST(callEx, symbol, context);
                this.semanticInfoChain.setCallResolutionDataForAST(callEx, additionalResults);
            } else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckObjectCreationExpression(callEx, context);
                }

                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData !== additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.typeCheckObjectCreationExpression = function (callEx, context) {
            this.setTypeChecked(callEx, context);
            this.resolveAST(callEx.expression, false, context);
            var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
            if (callEx.argumentList) {
                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                var len = callEx.argumentList.arguments.length;

                for (var i = 0; i < len; i++) {
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols ? callResolutionData.actualParametersContextTypeSymbols[i] : null;
                    if (contextualType) {
                        context.pushNewContextualType(contextualType);
                    }

                    this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                    if (contextualType) {
                        context.popAnyContextualType();
                        contextualType = null;
                    }
                }
            }

            for (var i = 0; i < callResolutionData.diagnosticsFromOverloadResolution.length; i++) {
                context.postDiagnostic(callResolutionData.diagnosticsFromOverloadResolution[i]);
            }
        };

        PullTypeResolver.prototype.postOverloadResolutionDiagnostics = function (diagnostic, additionalResults, context) {
            if (!context.inProvisionalResolution()) {
                additionalResults.diagnosticsFromOverloadResolution.push(diagnostic);
            }
            context.postDiagnostic(diagnostic);
        };

        PullTypeResolver.prototype.computeObjectCreationExpressionSymbol = function (callEx, context, additionalResults) {
            var _this = this;
            var returnType = null;

            var targetSymbol = this.resolveAST(callEx.expression, false, context);
            var targetTypeSymbol = targetSymbol.isType() ? targetSymbol : targetSymbol.type;

            var targetAST = this.getCallTargetErrorSpanAST(callEx);

            var constructSignatures = targetTypeSymbol.getConstructSignatures();

            var explicitTypeArgs = null;
            var usedCallSignaturesInstead = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var typeArgumentCountDiagnostic = null;
            var diagnostics = [];

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                if (callEx.argumentList) {
                    this.resolveAST(callEx.argumentList.arguments, false, context);
                }

                return targetTypeSymbol;
            }

            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;

                if (this.compilationSettings.noImplicitAny()) {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, TypeScript.DiagnosticCode.new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type), additionalResults, context);
                }
            }

            if (constructSignatures.length) {
                if (callEx.argumentList && callEx.argumentList.typeArgumentList) {
                    explicitTypeArgs = [];

                    if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length) {
                        for (var i = 0; i < callEx.argumentList.typeArgumentList.typeArguments.length; i++) {
                            explicitTypeArgs[i] = this.resolveTypeReference(callEx.argumentList.typeArgumentList.typeArguments[i], context);
                        }
                    }
                }

                if (targetTypeSymbol.isGeneric()) {
                    var resolvedSignatures = [];
                    var inferredOrExplicitTypeArgs;
                    var specializedSignature;
                    var typeParameters;
                    var typeConstraint = null;
                    var triedToInferTypeArgs;
                    var targetTypeReplacementMap = targetTypeSymbol.getTypeParameterSubstitutionMap();

                    for (var i = 0; i < constructSignatures.length; i++) {
                        couldNotAssignToConstraint = false;

                        if (constructSignatures[i].isGeneric()) {
                            typeParameters = constructSignatures[i].getTypeParameters();

                            if (explicitTypeArgs) {
                                if (explicitTypeArgs.length === typeParameters.length) {
                                    inferredOrExplicitTypeArgs = explicitTypeArgs;
                                } else {
                                    typeArgumentCountDiagnostic = typeArgumentCountDiagnostic || this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [typeParameters.length, explicitTypeArgs.length]);
                                    continue;
                                }
                            } else if (callEx.argumentList) {
                                var typeArgumentInferenceContext = new TypeScript.InvocationTypeArgumentInferenceContext(this, context, constructSignatures[i], callEx.argumentList);
                                inferredOrExplicitTypeArgs = this.inferArgumentTypesForSignature(typeArgumentInferenceContext, new TypeComparisonInfo(), context);
                                triedToInferTypeArgs = true;
                            } else {
                                inferredOrExplicitTypeArgs = TypeScript.ArrayUtilities.select(typeParameters, function (typeParameter) {
                                    return typeParameter.getDefaultConstraint(_this.semanticInfoChain);
                                });
                            }

                            TypeScript.Debug.assert(inferredOrExplicitTypeArgs && inferredOrExplicitTypeArgs.length == typeParameters.length);

                            var mutableTypeReplacementMap = new TypeScript.PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(targetTypeReplacementMap ? targetTypeReplacementMap : []);
                            TypeScript.PullInstantiationHelpers.updateMutableTypeParameterSubstitutionMap(typeParameters, inferredOrExplicitTypeArgs, mutableTypeReplacementMap);
                            var typeReplacementMap = mutableTypeReplacementMap.typeParameterSubstitutionMap;

                            if (explicitTypeArgs) {
                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeConstraint = typeParameters[j].getConstraint();

                                    if (typeConstraint) {
                                        if (typeConstraint.isGeneric()) {
                                            typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                        }

                                        if (!this.sourceIsAssignableToTarget(inferredOrExplicitTypeArgs[j], typeConstraint, targetAST, context, null, true)) {
                                            var enclosingSymbol = this.getEnclosingSymbolForAST(targetAST);
                                            constraintDiagnostic = this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1, [inferredOrExplicitTypeArgs[j].toString(enclosingSymbol, true), typeConstraint.toString(enclosingSymbol, true)]);
                                            couldNotAssignToConstraint = true;
                                        }

                                        if (couldNotAssignToConstraint) {
                                            break;
                                        }
                                    }
                                }
                            }

                            if (couldNotAssignToConstraint) {
                                continue;
                            }

                            specializedSignature = this.instantiateSignature(constructSignatures[i], typeReplacementMap);

                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        } else {
                            if (!(callEx.argumentList && callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length)) {
                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                            }
                        }
                    }

                    constructSignatures = resolvedSignatures;
                }

                var signature = this.resolveOverloads(callEx, constructSignatures, callEx.argumentList && callEx.argumentList.typeArgumentList !== null, context, diagnostics);

                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = [];

                if (!constructSignatures.length) {
                    if (constraintDiagnostic) {
                        this.postOverloadResolutionDiagnostics(constraintDiagnostic, additionalResults, context);
                    } else if (typeArgumentCountDiagnostic) {
                        this.postOverloadResolutionDiagnostics(typeArgumentCountDiagnostic, additionalResults, context);
                    }

                    return this.getNewErrorTypeSymbol();
                }

                var errorCondition = null;

                if (!signature) {
                    for (var i = 0; i < diagnostics.length; i++) {
                        this.postOverloadResolutionDiagnostics(diagnostics[i], additionalResults, context);
                    }

                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Could_not_select_overload_for_new_expression), additionalResults, context);

                    errorCondition = this.getNewErrorTypeSymbol();

                    if (!constructSignatures.length) {
                        return errorCondition;
                    }

                    signature = constructSignatures[0];
                }

                returnType = signature.returnType;

                if (returnType && !signature.isGeneric() && returnType.isGeneric() && !returnType.getIsSpecialized()) {
                    if (explicitTypeArgs && explicitTypeArgs.length) {
                        returnType = this.createInstantiatedType(returnType, explicitTypeArgs);
                    } else {
                        returnType = this.instantiateTypeToAny(returnType, context);
                    }
                }

                if (usedCallSignaturesInstead) {
                    if (returnType !== this.semanticInfoChain.voidTypeSymbol) {
                        this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Only_a_void_function_can_be_called_with_the_new_keyword), additionalResults, context);

                        return this.getNewErrorTypeSymbol();
                    } else {
                        returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (!returnType) {
                    returnType = signature.returnType;

                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }

                var actualParametersContextTypeSymbols = [];
                if (callEx.argumentList && callEx.argumentList.arguments) {
                    var len = callEx.argumentList.arguments.length;
                    var params = signature.parameters;
                    var contextualType = null;
                    var signatureDecl = signature.getDeclarations()[0];

                    for (var i = 0; i < len; i++) {
                        if (params.length) {
                            if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                                this.resolveDeclaredSymbol(params[i], context);
                                contextualType = params[i].type;
                            } else if (signature.hasVarArgs) {
                                contextualType = params[params.length - 1].type;
                                if (contextualType.isArrayNamedTypeReference()) {
                                    contextualType = contextualType.getElementType();
                                }
                            }
                        }

                        if (contextualType) {
                            context.pushNewContextualType(contextualType);
                            actualParametersContextTypeSymbols[i] = contextualType;
                        }

                        this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                        if (contextualType) {
                            context.popAnyContextualType();
                            contextualType = null;
                        }
                    }
                }

                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

                if (errorCondition) {
                    return errorCondition;
                }

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return returnType;
            } else if (callEx.argumentList) {
                this.resolveAST(callEx.argumentList.arguments, false, context);
            }

            this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, TypeScript.DiagnosticCode.Cannot_use_new_with_an_expression_whose_type_lacks_a_signature), additionalResults, context);

            return this.getNewErrorTypeSymbol();
        };

        PullTypeResolver.prototype.instantiateSignatureInContext = function (signatureAToInstantiate, contextualSignatureB, context, shouldFixContextualSignatureParameterTypes) {
            var typeReplacementMap = [];
            var inferredTypeArgs;
            var specializedSignature;
            var typeParameters = signatureAToInstantiate.getTypeParameters();
            var typeConstraint = null;

            var typeArgumentInferenceContext = new TypeScript.ContextualSignatureInstantiationTypeArgumentInferenceContext(this, context, signatureAToInstantiate, contextualSignatureB, shouldFixContextualSignatureParameterTypes);
            inferredTypeArgs = this.inferArgumentTypesForSignature(typeArgumentInferenceContext, new TypeComparisonInfo(), context);

            var functionTypeA = signatureAToInstantiate.functionType;
            var functionTypeB = contextualSignatureB.functionType;
            var enclosingTypeParameterMap;

            if (functionTypeA) {
                enclosingTypeParameterMap = functionTypeA.getTypeParameterSubstitutionMap();

                for (var id in enclosingTypeParameterMap) {
                    typeReplacementMap[id] = enclosingTypeParameterMap[id];
                }
            }

            if (functionTypeB) {
                enclosingTypeParameterMap = functionTypeB.getTypeParameterSubstitutionMap();

                for (var id in enclosingTypeParameterMap) {
                    typeReplacementMap[id] = enclosingTypeParameterMap[id];
                }
            }

            TypeScript.PullInstantiationHelpers.updateTypeParameterSubstitutionMap(typeParameters, inferredTypeArgs, typeReplacementMap);

            return this.instantiateSignature(signatureAToInstantiate, typeReplacementMap);
        };

        PullTypeResolver.prototype.resolveCastExpression = function (assertionExpression, context) {
            var typeAssertionType = this.resolveTypeReference(assertionExpression.type, context).type;

            if (this.canTypeCheckAST(assertionExpression, context)) {
                this.typeCheckCastExpression(assertionExpression, context, typeAssertionType);
            }

            return typeAssertionType;
        };

        PullTypeResolver.prototype.typeCheckCastExpression = function (assertionExpression, context, typeAssertionType) {
            this.setTypeChecked(assertionExpression, context);

            context.pushNewContextualType(typeAssertionType);
            var exprType = this.resolveAST(assertionExpression.expression, true, context).type;
            context.popAnyContextualType();

            this.resolveDeclaredSymbol(typeAssertionType, context);
            this.resolveDeclaredSymbol(exprType, context);

            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.sourceIsAssignableToTarget(exprType, typeAssertionType, assertionExpression, context, comparisonInfo);

            if (!isAssignable) {
                var widenedExprType = exprType.widenedType(this, assertionExpression.expression, context);
                isAssignable = this.sourceIsAssignableToTarget(typeAssertionType, widenedExprType, assertionExpression, context, comparisonInfo);
            }

            if (!isAssignable) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(assertionExpression);
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(assertionExpression, TypeScript.DiagnosticCode.Neither_type_0_nor_type_1_is_assignable_to_the_other_NL_2, [exprType.toString(enclosingSymbol), typeAssertionType.toString(enclosingSymbol), comparisonInfo.message]));
                } else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(assertionExpression, TypeScript.DiagnosticCode.Neither_type_0_nor_type_1_is_assignable_to_the_other, [exprType.toString(enclosingSymbol), typeAssertionType.toString(enclosingSymbol)]));
                }
            }
        };

        PullTypeResolver.prototype.resolveAssignmentExpression = function (binaryExpression, context) {
            var leftExpr = this.resolveAST(binaryExpression.left, false, context);
            var leftType = leftExpr.type;

            context.pushNewContextualType(leftType);
            var rightType = this.resolveAST(binaryExpression.right, true, context).type;
            context.popAnyContextualType();

            rightType = this.getInstanceTypeForAssignment(binaryExpression.left, rightType, context);

            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.setTypeChecked(binaryExpression, context);

                if (!this.isReference(binaryExpression.left, leftExpr)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                } else {
                    this.checkAssignability(binaryExpression.left, rightType, leftExpr.type, context);
                }
            }

            return rightType;
        };

        PullTypeResolver.prototype.getInstanceTypeForAssignment = function (lhs, type, context) {
            var typeToReturn = type;
            if (typeToReturn && typeToReturn.isAlias()) {
                typeToReturn = typeToReturn.getExportAssignedTypeSymbol();
            }

            if (typeToReturn && typeToReturn.isContainer() && !typeToReturn.isEnum()) {
                var instanceTypeSymbol = typeToReturn.getInstanceType();

                if (!instanceTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(lhs, TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [type.toString()]));
                    typeToReturn = null;
                } else {
                    typeToReturn = instanceTypeSymbol;
                }
            }

            return typeToReturn;
        };

        PullTypeResolver.prototype.widenType = function (type, ast, context) {
            if (type === this.semanticInfoChain.undefinedTypeSymbol || type === this.semanticInfoChain.nullTypeSymbol || type.isError()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (type.isArrayNamedTypeReference()) {
                return this.widenArrayType(type, ast, context);
            } else if (type.kind === 256 /* ObjectLiteral */) {
                return this.widenObjectLiteralType(type, ast, context);
            }

            return type;
        };

        PullTypeResolver.prototype.widenArrayType = function (type, ast, context) {
            var elementType = type.getElementType().widenedType(this, ast, context);

            if (this.compilationSettings.noImplicitAny() && ast) {
                if (elementType === this.semanticInfoChain.anyTypeSymbol && type.getElementType() !== this.semanticInfoChain.anyTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Array_Literal_implicitly_has_an_any_type_from_widening));
                }
            }

            return this.getArrayType(elementType);
        };

        PullTypeResolver.prototype.widenObjectLiteralType = function (type, ast, context) {
            if (!this.needsToWidenObjectLiteralType(type, ast, context)) {
                return type;
            }

            TypeScript.Debug.assert(type.name === "");
            var newObjectTypeSymbol = new TypeScript.PullTypeSymbol(type.name, type.kind, this.semanticInfoChain);
            var declsOfObjectType = type.getDeclarations();
            TypeScript.Debug.assert(declsOfObjectType.length === 1);
            newObjectTypeSymbol.addDeclaration(declsOfObjectType[0]);
            var members = type.getMembers();

            for (var i = 0; i < members.length; i++) {
                var memberType = members[i].type;

                var widenedMemberType = members[i].type.widenedType(this, ast, context);
                var newMember = new TypeScript.PullSymbol(members[i].name, members[i].kind, this.semanticInfoChain);

                var declsOfMember = members[i].getDeclarations();

                newMember.addDeclaration(declsOfMember[0]);
                newMember.type = widenedMemberType;
                newObjectTypeSymbol.addMember(newMember);
                newMember.setResolved();

                if (this.compilationSettings.noImplicitAny() && ast && widenedMemberType === this.semanticInfoChain.anyTypeSymbol && memberType !== this.semanticInfoChain.anyTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Object_literal_s_property_0_implicitly_has_an_any_type_from_widening, [members[i].name]));
                }
            }

            var indexers = type.getIndexSignatures();
            for (var i = 0; i < indexers.length; i++) {
                var newIndexer = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */, this.semanticInfoChain);
                var parameter = indexers[i].parameters[0];
                var newParameter = new TypeScript.PullSymbol(parameter.name, parameter.kind, this.semanticInfoChain);
                newParameter.type = parameter.type;
                newIndexer.addParameter(newParameter);
                newIndexer.returnType = indexers[i].returnType;
                newObjectTypeSymbol.addIndexSignature(newIndexer);
            }

            return newObjectTypeSymbol;
        };

        PullTypeResolver.prototype.needsToWidenObjectLiteralType = function (type, ast, context) {
            var members = type.getMembers();
            for (var i = 0; i < members.length; i++) {
                var memberType = members[i].type;
                if (memberType !== memberType.widenedType(this, ast, context)) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.findBestCommonType = function (contextualType, nonContextualCandidates, context) {
            var len = nonContextualCandidates.getLength();

            if (contextualType !== null && !context.isInferentiallyTyping() && this.typeIsBestCommonTypeCandidate(contextualType, nonContextualCandidates, context)) {
                return contextualType;
            }

            for (var i = 0; i < len; i++) {
                var candidateType = nonContextualCandidates.getTypeAtIndex(i);
                if (this.typeIsBestCommonTypeCandidate(candidateType, nonContextualCandidates, context)) {
                    return candidateType;
                }
            }

            return this.semanticInfoChain.emptyTypeSymbol;
        };

        PullTypeResolver.prototype.typeIsBestCommonTypeCandidate = function (candidateType, collection, context) {
            for (var i = 0; i < collection.getLength(); i++) {
                var otherType = collection.getTypeAtIndex(i);
                if (candidateType === otherType) {
                    continue;
                }

                if (!this.sourceIsSubtypeOfTarget(otherType, candidateType, null, context)) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.typesAreIdenticalInEnclosingTypes = function (t1, t2, context) {
            t1 = this.getSymbolForRelationshipCheck(t1);
            t2 = this.getSymbolForRelationshipCheck(t2);

            if (t1 === t2) {
                return true;
            }

            if (t1 && t2) {
                if (context.oneOfClassificationsIsInfinitelyExpanding()) {
                    return this.infinitelyExpandingTypesAreIdentical(t1, t2, context);
                }
            }

            return this.typesAreIdentical(t1, t2, context);
        };

        PullTypeResolver.prototype.typesAreIdenticalWithNewEnclosingTypes = function (t1, t2, context) {
            var enclosingTypeWalkerStates = context.resetEnclosingTypeWalkerStates();
            var areTypesIdentical = this.typesAreIdentical(t1, t2, context);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areTypesIdentical;
        };

        PullTypeResolver.prototype.typesAreIdentical = function (t1, t2, context) {
            t1 = this.getSymbolForRelationshipCheck(t1);
            t2 = this.getSymbolForRelationshipCheck(t2);

            if (t1 === t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (TypeScript.hasFlag(t1.kind, 64 /* Enum */) || TypeScript.hasFlag(t2.kind, 64 /* Enum */)) {
                return false;
            }

            if (t1.isPrimitive() && t1.isStringConstant() && t2.isPrimitive() && t2.isStringConstant()) {
                return TypeScript.stripStartAndEndQuotes(t1.name) === TypeScript.stripStartAndEndQuotes(t2.name);
            }

            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }

            if (t1.isError() && t2.isError()) {
                return true;
            }

            var isIdentical = this.identicalCache.valueAt(t1.pullSymbolID, t2.pullSymbolID);
            if (isIdentical != undefined) {
                return isIdentical;
            }

            if (t1.isTypeParameter() !== t2.isTypeParameter()) {
                return false;
            } else if (t1.isTypeParameter()) {
                var t1ParentDeclaration = t1.getDeclarations()[0].getParentDecl();
                var t2ParentDeclaration = t2.getDeclarations()[0].getParentDecl();

                if (t1ParentDeclaration === t2ParentDeclaration) {
                    return this.symbolsShareDeclaration(t1, t2);
                } else {
                    return false;
                }
            }

            if (t1.isPrimitive() !== t2.isPrimitive()) {
                return false;
            }

            this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, true);
            var statesWhenStartedWalkingTypes = context.startWalkingTypes(t1, t2);
            isIdentical = this.typesAreIdenticalWorker(t1, t2, context);
            context.endWalkingTypes(statesWhenStartedWalkingTypes);
            this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, isIdentical);

            return isIdentical;
        };

        PullTypeResolver.prototype.typesAreIdenticalWorker = function (t1, t2, context) {
            if (t1.getIsSpecialized() && t2.getIsSpecialized()) {
                if (TypeScript.PullHelpers.getRootType(t1) === TypeScript.PullHelpers.getRootType(t2) && TypeScript.PullHelpers.getRootType(t1).isNamedTypeSymbol()) {
                    var t1TypeArguments = t1.getTypeArguments();
                    var t2TypeArguments = t2.getTypeArguments();

                    if (t1TypeArguments && t2TypeArguments) {
                        for (var i = 0; i < t1TypeArguments.length; i++) {
                            if (!this.typesAreIdenticalWithNewEnclosingTypes(t1TypeArguments[i], t2TypeArguments[i], context)) {
                                return false;
                            }
                        }
                    }

                    return true;
                }
            }

            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getAllMembers(68147712 /* SomeValue */, 0 /* all */);
                var t2Members = t2.getAllMembers(68147712 /* SomeValue */, 0 /* all */);

                if (t1Members.length !== t2Members.length) {
                    return false;
                }

                var t1MemberSymbol = null;
                var t2MemberSymbol = null;

                var t1MemberType = null;
                var t2MemberType = null;

                for (var iMember = 0; iMember < t1Members.length; iMember++) {
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = this.getNamedPropertySymbol(t1MemberSymbol.name, 68147712 /* SomeValue */, t2);

                    if (!this.propertiesAreIdentical(t1MemberSymbol, t2MemberSymbol, context)) {
                        return false;
                    }
                }
            } else if (t1.hasMembers() || t2.hasMembers()) {
                return false;
            }

            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();

            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();

            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();

            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs, context)) {
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs, context)) {
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs, context)) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.propertiesAreIdentical = function (propertySymbol1, propertySymbol2, context) {
            if (!propertySymbol2 || (propertySymbol1.isOptional !== propertySymbol2.isOptional)) {
                return false;
            }

            var t1MemberSymbolIsPrivate = propertySymbol1.anyDeclHasFlag(2 /* Private */);
            var t2MemberSymbolIsPrivate = propertySymbol2.anyDeclHasFlag(2 /* Private */);

            if (t1MemberSymbolIsPrivate !== t2MemberSymbolIsPrivate) {
                return false;
            } else if (t2MemberSymbolIsPrivate && t1MemberSymbolIsPrivate) {
                var t1MemberSymbolDecl = propertySymbol1.getDeclarations()[0];
                var sourceDecl = propertySymbol2.getDeclarations()[0];
                if (t1MemberSymbolDecl !== sourceDecl) {
                    return false;
                }
            }

            var t1MemberType = propertySymbol1.type;
            var t2MemberType = propertySymbol2.type;

            context.walkMemberTypes(propertySymbol1.name);
            var areMemberTypesIdentical = this.typesAreIdenticalInEnclosingTypes(t1MemberType, t2MemberType, context);
            context.postWalkMemberTypes();
            return areMemberTypesIdentical;
        };

        PullTypeResolver.prototype.propertiesAreIdenticalWithNewEnclosingTypes = function (type1, type2, property1, property2, context) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(type1, type2);
            var arePropertiesIdentical = this.propertiesAreIdentical(property1, property2, context);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return arePropertiesIdentical;
        };

        PullTypeResolver.prototype.signatureGroupsAreIdentical = function (sg1, sg2, context) {
            if (sg1 === sg2) {
                return true;
            }

            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.length !== sg2.length) {
                return false;
            }

            for (var i = 0; i < sg1.length; i++) {
                context.walkSignatures(sg1[i].kind, i);
                var areSignaturesIdentical = this.signaturesAreIdentical(sg1[i], sg2[i], context, true);
                context.postWalkSignatures();
                if (!areSignaturesIdentical) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.constraintsAreIdentical = function (tp1, tp2, context) {
            TypeScript.Debug.assert(tp1 && tp2);
            if (tp1.length !== tp2.length) {
                return false;
            }

            for (var i = 0; i < tp1.length; i++) {
                context.walkTypeParameterConstraints(i);
                var areConstraintsIdentical = this.typesAreIdentical(tp1[i].getConstraint(), tp2[i].getConstraint(), context);
                context.postWalkTypeParameterConstraints();
                if (!areConstraintsIdentical) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.setTypeParameterIdentity = function (tp1, tp2, val) {
            if (tp1 && tp2 && tp1.length === tp2.length) {
                for (var i = 0; i < tp1.length; i++) {
                    this.identicalCache.setValueAt(tp1[i].pullSymbolID, tp2[i].pullSymbolID, val);
                }
            }
        };

        PullTypeResolver.prototype.signaturesAreIdenticalWithNewEnclosingTypes = function (s1, s2, context, includingReturnType) {
            if (typeof includingReturnType === "undefined") { includingReturnType = true; }
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(s1, s2);
            var areSignaturesIdentical = this.signaturesAreIdentical(s1, s2, context, includingReturnType);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSignaturesIdentical;
        };

        PullTypeResolver.prototype.signaturesAreIdentical = function (s1, s2, context, includingReturnType) {
            if (typeof includingReturnType === "undefined") { includingReturnType = true; }
            if (s1 === s2) {
                return true;
            }

            var signaturesIdentical = this.identicalCache.valueAt(s1.pullSymbolID, s2.pullSymbolID);
            if (signaturesIdentical || (signaturesIdentical != undefined && includingReturnType)) {
                return signaturesIdentical;
            }

            var oldValue = signaturesIdentical;
            this.identicalCache.setValueAt(s1.pullSymbolID, s2.pullSymbolID, true);

            signaturesIdentical = this.signaturesAreIdenticalWorker(s1, s2, context, includingReturnType);

            if (includingReturnType) {
                this.identicalCache.setValueAt(s1.pullSymbolID, s2.pullSymbolID, signaturesIdentical);
            } else {
                this.identicalCache.setValueAt(s1.pullSymbolID, s2.pullSymbolID, oldValue);
            }

            return signaturesIdentical;
        };

        PullTypeResolver.prototype.signaturesAreIdenticalWorker = function (s1, s2, context, includingReturnType) {
            if (typeof includingReturnType === "undefined") { includingReturnType = true; }
            if (s1.hasVarArgs !== s2.hasVarArgs) {
                return false;
            }

            if (s1.nonOptionalParamCount !== s2.nonOptionalParamCount) {
                return false;
            }

            if (s1.parameters.length !== s2.parameters.length) {
                return false;
            }

            return this.signatureConstraints_Parameters_AndReturnTypesAreIdenticalAfterInstantiationToAny(s1, s2, context, includingReturnType);
        };

        PullTypeResolver.prototype.signatureConstraints_Parameters_AndReturnTypesAreIdenticalAfterInstantiationToAny = function (s1, s2, context, includingReturnType) {
            if (!this.constraintsAreIdentical(s1.getTypeParameters(), s2.getTypeParameters(), context)) {
                return false;
            }

            s1 = this.instantiateSignatureToAny(s1);
            s2 = this.instantiateSignatureToAny(s2);

            if (includingReturnType) {
                TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(s1);
                TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(s2);
                context.walkReturnTypes();
                var areReturnTypesIdentical = this.typesAreIdenticalInEnclosingTypes(s1.returnType, s2.returnType, context);
                context.postWalkReturnTypes();
                if (!areReturnTypesIdentical) {
                    return false;
                }
            }

            var s1Params = s1.parameters;
            var s2Params = s2.parameters;

            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(s1Params[iParam]);
                TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(s2Params[iParam]);
                context.walkParameterTypes(iParam);
                var areParameterTypesIdentical = this.typesAreIdenticalInEnclosingTypes(s1Params[iParam].type, s2Params[iParam].type, context);
                context.postWalkParameterTypes();

                if (!areParameterTypesIdentical) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.signatureReturnTypesAreIdentical = function (s1, s2, context) {
            var s1TypeParameters = s1.getTypeParameters();
            var s2TypeParameters = s2.getTypeParameters();
            this.setTypeParameterIdentity(s1TypeParameters, s2TypeParameters, true);

            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(s1, s2);
            context.walkReturnTypes();
            var returnTypeIsIdentical = this.typesAreIdenticalInEnclosingTypes(s1.returnType, s2.returnType, context);

            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);

            this.setTypeParameterIdentity(s1TypeParameters, s2TypeParameters, undefined);

            return returnTypeIsIdentical;
        };

        PullTypeResolver.prototype.symbolsShareDeclaration = function (symbol1, symbol2) {
            var decls1 = symbol1.getDeclarations();
            var decls2 = symbol2.getDeclarations();

            if (decls1.length && decls2.length) {
                return decls1[0] === decls2[0];
            }

            return false;
        };

        PullTypeResolver.prototype.sourceIsSubtypeOfTarget = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };

        PullTypeResolver.prototype.sourceMembersAreAssignableToTargetMembers = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceMembersAreAssignableToTargetMembers = this.sourceMembersAreRelatableToTargetMembers(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceMembersAreAssignableToTargetMembers;
        };

        PullTypeResolver.prototype.sourcePropertyIsAssignableToTargetProperty = function (source, target, sourceProp, targetProp, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var isSourcePropertyIsAssignableToTargetProperty = this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return isSourcePropertyIsAssignableToTargetProperty;
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreAssignableToTargetCallSignatures = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceCallSignaturesAssignableToTargetCallSignatures = this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceCallSignaturesAssignableToTargetCallSignatures;
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreAssignableToTargetConstructSignatures = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceConstructSignaturesAssignableToTargetConstructSignatures = this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceConstructSignaturesAssignableToTargetConstructSignatures;
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreAssignableToTargetIndexSignatures = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceIndexSignaturesAssignableToTargetIndexSignatures = this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceIndexSignaturesAssignableToTargetIndexSignatures;
        };

        PullTypeResolver.prototype.typeIsAssignableToFunction = function (source, ast, context) {
            if (source.isFunctionType()) {
                return true;
            }

            return this.cachedFunctionInterfaceType() && this.sourceIsAssignableToTarget(source, this.cachedFunctionInterfaceType(), ast, context);
        };

        PullTypeResolver.prototype.signatureIsAssignableToTarget = function (s1, s2, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(s1, s2);
            var isSignatureIsAssignableToTarget = this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return isSignatureIsAssignableToTarget;
        };

        PullTypeResolver.prototype.sourceIsAssignableToTarget = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };

        PullTypeResolver.prototype.sourceIsAssignableToTargetWithNewEnclosingTypes = function (source, target, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            return this.sourceIsRelatableToTargetWithNewEnclosingTypes(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };

        PullTypeResolver.prototype.getSymbolForRelationshipCheck = function (symbol) {
            if (symbol && symbol.isTypeReference()) {
                return symbol.getReferencedTypeSymbol();
            }

            return symbol;
        };

        PullTypeResolver.prototype.sourceIsRelatableToTargetInEnclosingTypes = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            source = this.getSymbolForRelationshipCheck(source);
            target = this.getSymbolForRelationshipCheck(target);

            if (source === target) {
                return true;
            }

            if (source && target) {
                if (context.oneOfClassificationsIsInfinitelyExpanding()) {
                    return this.infinitelyExpandingSourceTypeIsRelatableToTargetType(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                }
            }

            return this.sourceIsRelatableToTarget(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        };

        PullTypeResolver.prototype.sourceIsRelatableToTargetWithNewEnclosingTypes = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var enclosingTypeWalkerStates = context.resetEnclosingTypeWalkerStates();
            var isSourceRelatable = this.sourceIsRelatableToTarget(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return isSourceRelatable;
        };

        PullTypeResolver.prototype.sourceIsRelatableToTargetInCache = function (source, target, comparisonCache, comparisonInfo) {
            var isRelatable = comparisonCache.valueAt(source.pullSymbolID, target.pullSymbolID);

            if (isRelatable) {
                return { isRelatable: isRelatable };
            }

            if (isRelatable != undefined && !comparisonInfo) {
                return { isRelatable: isRelatable };
            }

            return null;
        };

        PullTypeResolver.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            source = this.getSymbolForRelationshipCheck(source);
            target = this.getSymbolForRelationshipCheck(target);

            if (source === target) {
                return true;
            }

            if (!(source && target)) {
                return true;
            }

            var sourceApparentType = this.getApparentType(source);

            var isRelatableInfo = this.sourceIsRelatableToTargetInCache(source, target, comparisonCache, comparisonInfo);
            if (isRelatableInfo) {
                return isRelatableInfo.isRelatable;
            }

            if (source === this.semanticInfoChain.stringTypeSymbol && target.isPrimitive() && target.isStringConstant()) {
                return comparisonInfo && comparisonInfo.stringConstantVal && (comparisonInfo.stringConstantVal.kind() === 14 /* StringLiteral */) && (TypeScript.stripStartAndEndQuotes(comparisonInfo.stringConstantVal.text()) === TypeScript.stripStartAndEndQuotes(target.name));
            }

            if (assignableTo) {
                if (this.isAnyOrEquivalent(source) || this.isAnyOrEquivalent(target)) {
                    return true;
                }
            } else {
                if (this.isAnyOrEquivalent(target)) {
                    return true;
                }
            }

            if (target === this.semanticInfoChain.stringTypeSymbol && source.isPrimitive() && source.isStringConstant()) {
                return true;
            }

            if (source.isPrimitive() && source.isStringConstant() && target.isPrimitive() && target.isStringConstant()) {
                return TypeScript.stripStartAndEndQuotes(source.name) === TypeScript.stripStartAndEndQuotes(target.name);
            }

            if (source === this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }

            if ((source === this.semanticInfoChain.nullTypeSymbol) && (target !== this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }

            if (target === this.semanticInfoChain.voidTypeSymbol) {
                if (source === this.semanticInfoChain.undefinedTypeSymbol || source == this.semanticInfoChain.nullTypeSymbol) {
                    return true;
                }

                return false;
            } else if (source === this.semanticInfoChain.voidTypeSymbol) {
                if (target === this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }

                return false;
            }

            if (target === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return true;
            }

            if (source === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(target)) {
                return assignableTo;
            }

            if (TypeScript.PullHelpers.symbolIsEnum(target) && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return this.symbolsShareDeclaration(target, source);
            }

            if ((source.kind & 64 /* Enum */) || (target.kind & 64 /* Enum */)) {
                return false;
            }

            if (source.getIsSpecialized() && target.getIsSpecialized()) {
                if (TypeScript.PullHelpers.getRootType(source) === TypeScript.PullHelpers.getRootType(target) && TypeScript.PullHelpers.getRootType(source).isNamedTypeSymbol()) {
                    var sourceTypeArguments = source.getTypeArguments();
                    var targetTypeArguments = target.getTypeArguments();

                    if (sourceTypeArguments && targetTypeArguments) {
                        comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, true);

                        for (var i = 0; i < sourceTypeArguments.length; i++) {
                            if (!this.sourceIsRelatableToTargetWithNewEnclosingTypes(sourceTypeArguments[i], targetTypeArguments[i], assignableTo, comparisonCache, ast, context, null, isComparingInstantiatedSignatures)) {
                                break;
                            }
                        }

                        if (i === sourceTypeArguments.length) {
                            return true;
                        } else {
                            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, undefined);
                        }
                    }
                }
            }

            if (target.isTypeParameter()) {
                if (source.isTypeParameter()) {
                    if (!source.getConstraint()) {
                        return this.typesAreIdentical(target, source, context);
                    } else {
                        return this.isSourceTypeParameterConstrainedToTargetTypeParameter(source, target);
                    }
                } else {
                    if (isComparingInstantiatedSignatures) {
                        target = target.getBaseConstraint(this.semanticInfoChain);
                    } else {
                        return this.typesAreIdentical(target, sourceApparentType, context);
                    }
                }
            }

            if (sourceApparentType.isPrimitive() || target.isPrimitive()) {
                return false;
            }

            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, true);

            var symbolsWhenStartedWalkingTypes = context.startWalkingTypes(sourceApparentType, target);
            var isRelatable = this.sourceIsRelatableToTargetWorker(sourceApparentType, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.endWalkingTypes(symbolsWhenStartedWalkingTypes);

            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, isRelatable);
            return isRelatable;
        };

        PullTypeResolver.prototype.isSourceTypeParameterConstrainedToTargetTypeParameter = function (source, target) {
            var current = source;
            while (current && current.isTypeParameter()) {
                if (current === target) {
                    return true;
                }

                current = current.getConstraint();
            }
            return false;
        };

        PullTypeResolver.prototype.sourceIsRelatableToTargetWorker = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            if (target.hasMembers() && !this.sourceMembersAreRelatableToTargetMembers(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            if (!this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            if (!this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            if (!this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.sourceMembersAreRelatableToTargetMembers = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetProps = target.getAllMembers(68147712 /* SomeValue */, 0 /* all */);

            for (var itargetProp = 0; itargetProp < targetProps.length; itargetProp++) {
                var targetProp = targetProps[itargetProp];

                var sourceProp = this._getNamedPropertySymbolOfAugmentedType(targetProp.name, source);

                this.resolveDeclaredSymbol(targetProp, context);

                var targetPropType = targetProp.type;

                if (!sourceProp) {
                    if (!(targetProp.isOptional)) {
                        if (comparisonInfo) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                            comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_is_missing_property_1_from_type_2, [source.toString(enclosingSymbol), targetProp.getScopedNameEx().toString(), target.toString(enclosingSymbol)]));
                        }
                        return false;
                    }
                    continue;
                }

                if (!this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.infinitelyExpandingSourceTypeIsRelatableToTargetType = function (sourceType, targetType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var widenedTargetType = targetType.widenedType(this, null, context);
            var widenedSourceType = sourceType.widenedType(this, null, context);

            if ((widenedSourceType !== this.semanticInfoChain.anyTypeSymbol) && (widenedTargetType !== this.semanticInfoChain.anyTypeSymbol)) {
                var sourceTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(sourceType);
                var targetTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(targetType);

                if (sourceTypeNamedTypeReference !== targetTypeNamedTypeReference) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_do_not_refer_to_same_named_type, [sourceType.getScopedNameEx(enclosingSymbol).toString(), targetType.toString(enclosingSymbol)]));
                    }
                    return false;
                }

                var sourceTypeArguments = sourceType.getTypeArguments();
                var targetTypeArguments = targetType.getTypeArguments();

                if (!sourceTypeArguments && !targetTypeArguments) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
                    return true;
                }

                if (!(sourceTypeArguments && targetTypeArguments) || sourceTypeArguments.length !== targetTypeArguments.length) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments, [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol)]));
                    }
                    return false;
                }

                var comparisonInfoTypeArgumentsCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoTypeArgumentsCheck = new TypeComparisonInfo(comparisonInfo);
                }
                var isRelatable = true;
                for (var i = 0; i < sourceTypeArguments.length && isRelatable; i++) {
                    context.walkTypeArgument(i);

                    if (!this.sourceIsRelatableToTargetInEnclosingTypes(sourceTypeArguments[i], targetTypeArguments[i], assignableTo, comparisonCache, ast, context, comparisonInfoTypeArgumentsCheck, isComparingInstantiatedSignatures)) {
                        isRelatable = false;
                        if (comparisonInfo) {
                            var message;
                            var enclosingSymbol = this.getEnclosingSymbolForAST(ast);

                            if (comparisonInfoTypeArgumentsCheck && comparisonInfoTypeArgumentsCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2, [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol), comparisonInfoTypeArgumentsCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments, [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol)]);
                            }
                            comparisonInfo.addMessage(message);
                        }
                    }

                    context.postWalkTypeArgument();
                }
            }

            comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, isRelatable);
            return isRelatable;
        };

        PullTypeResolver.prototype.infinitelyExpandingTypesAreIdentical = function (sourceType, targetType, context) {
            var widenedTargetType = targetType.widenedType(this, null, null);
            var widenedSourceType = sourceType.widenedType(this, null, null);

            if ((widenedSourceType !== this.semanticInfoChain.anyTypeSymbol) && (widenedTargetType !== this.semanticInfoChain.anyTypeSymbol)) {
                var sourceTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(sourceType);
                var targetTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(targetType);
                if (sourceTypeNamedTypeReference !== targetTypeNamedTypeReference) {
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    return false;
                }

                var sourceTypeArguments = sourceType.getTypeArguments();
                var targetTypeArguments = targetType.getTypeArguments();

                if (!sourceTypeArguments && !targetTypeArguments) {
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
                    return true;
                }

                if (!(sourceTypeArguments && targetTypeArguments) || sourceTypeArguments.length !== targetTypeArguments.length) {
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    return false;
                }

                for (var i = 0; i < sourceTypeArguments.length; i++) {
                    context.walkTypeArgument(i);
                    var areIdentical = this.typesAreIdenticalInEnclosingTypes(sourceTypeArguments[i], targetTypeArguments[i], context);
                    context.postWalkTypeArgument();

                    if (!areIdentical) {
                        this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                        return false;
                    }
                }
            }

            this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
            return true;
        };

        PullTypeResolver.prototype.sourcePropertyIsRelatableToTargetProperty = function (source, target, sourceProp, targetProp, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var _this = this;
            var sourceAndTargetAreConstructors = source.isConstructor() && target.isConstructor();

            var getNames = function (takeTypesFromPropertyContainers) {
                var enclosingSymbol = _this.getEnclosingSymbolForAST(ast);
                var sourceType = takeTypesFromPropertyContainers ? sourceProp.getContainer() : source;
                var targetType = takeTypesFromPropertyContainers ? targetProp.getContainer() : target;
                if (sourceAndTargetAreConstructors) {
                    sourceType = sourceType.getAssociatedContainerType();
                    targetType = targetType.getAssociatedContainerType();
                }
                return {
                    propertyName: targetProp.getScopedNameEx().toString(),
                    sourceTypeName: sourceType.toString(enclosingSymbol),
                    targetTypeName: targetType.toString(enclosingSymbol)
                };
            };

            var targetPropIsPrivate = targetProp.anyDeclHasFlag(2 /* Private */);
            var sourcePropIsPrivate = sourceProp.anyDeclHasFlag(2 /* Private */);

            if (targetPropIsPrivate !== sourcePropIsPrivate) {
                if (comparisonInfo) {
                    var names = getNames(true);
                    var code;
                    if (targetPropIsPrivate) {
                        code = sourceAndTargetAreConstructors ? TypeScript.DiagnosticCode.Static_property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2 : TypeScript.DiagnosticCode.Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2;
                    } else {
                        code = sourceAndTargetAreConstructors ? TypeScript.DiagnosticCode.Static_property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2 : TypeScript.DiagnosticCode.Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2;
                    }
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(code, [names.propertyName, names.sourceTypeName, names.targetTypeName]));
                }
                return false;
            } else if (sourcePropIsPrivate && targetPropIsPrivate) {
                var targetDecl = targetProp.getDeclarations()[0];
                var sourceDecl = sourceProp.getDeclarations()[0];

                if (targetDecl !== sourceDecl) {
                    if (comparisonInfo) {
                        var names = getNames(true);

                        var code = sourceAndTargetAreConstructors ? TypeScript.DiagnosticCode.Types_0_and_1_define_static_property_2_as_private : TypeScript.DiagnosticCode.Types_0_and_1_define_property_2_as_private;
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(code, [names.sourceTypeName, names.targetTypeName, names.propertyName]));
                    }

                    return false;
                }
            }

            if (sourceProp.isOptional && !targetProp.isOptional) {
                if (comparisonInfo) {
                    var names = getNames(true);
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2, [names.propertyName, names.sourceTypeName, names.targetTypeName]));
                }
                return false;
            }

            this.resolveDeclaredSymbol(sourceProp, context);

            var sourcePropType = sourceProp.type;
            var targetPropType = targetProp.type;

            var isRelatableInfo = this.sourceIsRelatableToTargetInCache(sourcePropType, targetPropType, comparisonCache, comparisonInfo);
            if (isRelatableInfo) {
                return isRelatableInfo.isRelatable;
            }

            var comparisonInfoPropertyTypeCheck = null;
            if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                comparisonInfoPropertyTypeCheck = new TypeComparisonInfo(comparisonInfo);
            }

            context.walkMemberTypes(targetProp.name);
            var isSourcePropertyRelatableToTargetProperty = this.sourceIsRelatableToTargetInEnclosingTypes(sourcePropType, targetPropType, assignableTo, comparisonCache, ast, context, comparisonInfoPropertyTypeCheck, isComparingInstantiatedSignatures);
            context.postWalkMemberTypes();

            if (!isSourcePropertyRelatableToTargetProperty && comparisonInfo) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                var message;
                var names = getNames(false);
                if (comparisonInfoPropertyTypeCheck && comparisonInfoPropertyTypeCheck.message) {
                    var code = sourceAndTargetAreConstructors ? TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3 : TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3;
                    message = TypeScript.getDiagnosticMessage(code, [names.propertyName, names.sourceTypeName, names.targetTypeName, comparisonInfoPropertyTypeCheck.message]);
                } else {
                    var code = sourceAndTargetAreConstructors ? TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible : TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible;
                    message = TypeScript.getDiagnosticMessage(code, [names.propertyName, names.sourceTypeName, names.targetTypeName]);
                }
                comparisonInfo.addMessage(message);
            }

            return isSourcePropertyRelatableToTargetProperty;
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreRelatableToTargetCallSignatures = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetCallSigs = target.getCallSignatures();

            if (targetCallSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceCallSigs = source.getCallSignatures();
                if (!this.signatureGroupIsRelatableToTarget(source, target, sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures)) {
                    if (comparisonInfo) {
                        var message;
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                            }
                        } else {
                            var hasSig = targetCallSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            var lacksSig = !targetCallSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_call_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreRelatableToTargetConstructSignatures = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetConstructSigs = target.getConstructSignatures();
            if (targetConstructSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceConstructSigs = source.getConstructSignatures();
                if (!this.signatureGroupIsRelatableToTarget(source, target, sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures)) {
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        var message;
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                            }
                        } else {
                            var hasSig = targetConstructSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            var lacksSig = !targetConstructSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_construct_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreRelatableToTargetIndexSignatures = function (source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var targetIndexSigs = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(target, context);
            var targetStringSig = targetIndexSigs.stringSignature;
            var targetNumberSig = targetIndexSigs.numericSignature;

            if (targetStringSig || targetNumberSig) {
                var sourceIndexSigs = this.getBothKindsOfIndexSignaturesIncludingAugmentedType(source, context);
                var enclosingTypeIndexSigs = context.getBothKindOfIndexSignatures(true, false);
                var sourceStringSig = sourceIndexSigs.stringSignature;
                var sourceNumberSig = sourceIndexSigs.numericSignature;

                var comparable = true;
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                if (targetStringSig) {
                    if (sourceStringSig) {
                        context.walkIndexSignatureReturnTypes(enclosingTypeIndexSigs, true, true);
                        comparable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceStringSig.returnType, targetStringSig.returnType, assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                        context.postWalkIndexSignatureReturnTypes();
                    } else {
                        comparable = false;
                    }
                }

                if (comparable && targetNumberSig) {
                    if (sourceNumberSig) {
                        context.walkIndexSignatureReturnTypes(enclosingTypeIndexSigs, false, false);
                        comparable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceNumberSig.returnType, targetNumberSig.returnType, assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                        context.postWalkIndexSignatureReturnTypes();
                    } else if (sourceStringSig) {
                        context.walkIndexSignatureReturnTypes(enclosingTypeIndexSigs, true, false);
                        comparable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceStringSig.returnType, targetNumberSig.returnType, assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                        context.postWalkIndexSignatureReturnTypes();
                    } else {
                        comparable = false;
                    }
                }

                if (!comparable) {
                    if (comparisonInfo) {
                        var message;
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                        } else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                        }
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.signatureGroupIsRelatableToTarget = function (source, target, sourceSG, targetSG, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            if (sourceSG === targetSG) {
                return true;
            }

            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }

            var foundMatch = false;

            var targetExcludeDefinition = targetSG.length > 1;
            var sourceExcludeDefinition = sourceSG.length > 1;
            var sigsCompared = 0;
            var comparisonInfoSignatuesTypeCheck = null;
            if (comparisonInfo) {
                comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo, true);
                comparisonInfoSignatuesTypeCheck.message = comparisonInfo.message;
            }
            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                var mSig = targetSG[iMSig];

                if (mSig.isStringConstantOverloadSignature() || (targetExcludeDefinition && mSig.isDefinition())) {
                    continue;
                }

                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    var nSig = sourceSG[iNSig];

                    if (nSig.isStringConstantOverloadSignature() || (sourceExcludeDefinition && nSig.isDefinition())) {
                        continue;
                    }

                    context.walkSignatures(nSig.kind, iNSig, iMSig);
                    var isSignatureRelatableToTarget = this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, ast, context, sigsCompared == 0 ? comparisonInfoSignatuesTypeCheck : null, isComparingInstantiatedSignatures);
                    context.postWalkSignatures();

                    sigsCompared++;

                    if (isSignatureRelatableToTarget) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }

                if (comparisonInfo && sigsCompared == 1) {
                    comparisonInfo.message = comparisonInfoSignatuesTypeCheck.message;
                }

                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var isRelatableInfo = this.sourceIsRelatableToTargetInCache(sourceSig, targetSig, comparisonCache, comparisonInfo);
            if (isRelatableInfo) {
                return isRelatableInfo.isRelatable;
            }

            comparisonCache.setValueAt(sourceSig.pullSymbolID, targetSig.pullSymbolID, true);
            var isRelatable = this.signatureIsRelatableToTargetWorker(sourceSig, targetSig, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            comparisonCache.setValueAt(sourceSig.pullSymbolID, targetSig.pullSymbolID, isRelatable);
            return isRelatable;
        };

        PullTypeResolver.prototype.signatureIsRelatableToTargetWorker = function (sourceSig, targetSig, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures) {
            var _this = this;
            var sourceParameters = sourceSig.parameters;
            var targetParameters = targetSig.parameters;

            if (!sourceParameters || !targetParameters) {
                return false;
            }

            var targetNonOptionalParamCount = targetSig.nonOptionalParamCount;
            var sourceNonOptionalParamCount = sourceSig.nonOptionalParamCount;

            if (!targetSig.hasVarArgs && sourceNonOptionalParamCount > targetParameters.length) {
                if (comparisonInfo) {
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signature_expects_0_or_fewer_parameters, [targetParameters.length]));
                }
                return false;
            }

            if (this.signaturesAreIdentical(sourceSig, targetSig, context)) {
                return true;
            }

            targetSig = this.instantiateSignatureToAny(targetSig);
            sourceSig = this.instantiateSignatureToAny(sourceSig);

            var sourceReturnType = sourceSig.returnType;
            var targetReturnType = targetSig.returnType;

            if (targetReturnType !== this.semanticInfoChain.voidTypeSymbol) {
                context.walkReturnTypes();
                var returnTypesAreRelatable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceReturnType, targetReturnType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                context.postWalkReturnTypes();
                if (!returnTypesAreRelatable) {
                    return false;
                }
            }

            return targetSig.forAllCorrespondingParameterTypesInThisAndOtherSignature(sourceSig, function (targetParamType, sourceParamType, iParam) {
                context.walkParameterTypes(iParam);
                var areParametersRelatable = _this.sourceIsRelatableToTargetInEnclosingTypes(sourceParamType, targetParamType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                if (!areParametersRelatable) {
                    context.swapEnclosingTypeWalkers();
                    areParametersRelatable = _this.sourceIsRelatableToTargetInEnclosingTypes(targetParamType, sourceParamType, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                    context.swapEnclosingTypeWalkers();
                }
                context.postWalkParameterTypes();

                return areParametersRelatable;
            });
        };

        PullTypeResolver.prototype.resolveOverloads = function (application, group, haveTypeArgumentsAtCallSite, context, diagnostics) {
            var _this = this;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args = application.argumentList ? application.argumentList.arguments : null;

            var initialCandidates = TypeScript.ArrayUtilities.where(group, function (signature) {
                if (hasOverloads && signature.isDefinition()) {
                    return false;
                }

                var rootSignature = signature.getRootSymbol();
                if (haveTypeArgumentsAtCallSite && !rootSignature.isGeneric()) {
                    return false;
                }

                return _this.overloadHasCorrectArity(signature, args);
            });

            var firstAssignableButNotSupertypeSignature = null;
            var firstAssignableWithProvisionalErrorsSignature = null;

            for (var i = 0; i < initialCandidates.length; i++) {
                var applicability = this.overloadIsApplicable(initialCandidates[i], args, context, comparisonInfo);
                if (applicability === 3 /* Subtype */) {
                    return initialCandidates[i];
                } else if (applicability === 2 /* AssignableWithNoProvisionalErrors */ && !firstAssignableButNotSupertypeSignature) {
                    firstAssignableButNotSupertypeSignature = initialCandidates[i];
                } else if (applicability === 1 /* AssignableButWithProvisionalErrors */ && !firstAssignableWithProvisionalErrorsSignature) {
                    firstAssignableWithProvisionalErrorsSignature = initialCandidates[i];
                }
            }

            if (firstAssignableButNotSupertypeSignature || firstAssignableWithProvisionalErrorsSignature) {
                return firstAssignableButNotSupertypeSignature || firstAssignableWithProvisionalErrorsSignature;
            } else {
                var target = this.getCallTargetErrorSpanAST(application);
                if (comparisonInfo.message) {
                    diagnostics.push(this.semanticInfoChain.diagnosticFromAST(target, TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0, [comparisonInfo.message]));
                } else {
                    diagnostics.push(this.semanticInfoChain.diagnosticFromAST(target, TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target, null));
                }
            }

            return null;
        };

        PullTypeResolver.prototype.getCallTargetErrorSpanAST = function (callEx) {
            if (callEx.expression.kind() === 213 /* MemberAccessExpression */) {
                var memberAccessExpression = callEx.expression;
                if (memberAccessExpression.name.fullWidth() > 0) {
                    return memberAccessExpression.name;
                }
            }

            return callEx.expression;
        };

        PullTypeResolver.prototype.overloadHasCorrectArity = function (signature, args) {
            if (args == null) {
                return signature.nonOptionalParamCount === 0;
            }

            var numberOfArgs = (args.length && args.length === args.separatorCount()) ? args.separatorCount() + 1 : args.length;
            if (numberOfArgs < signature.nonOptionalParamCount) {
                return false;
            }
            if (!signature.hasVarArgs && numberOfArgs > signature.parameters.length) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.overloadIsApplicable = function (signature, args, context, comparisonInfo) {
            if (args === null) {
                return 3 /* Subtype */;
            }

            var isInVarArg = false;
            var parameters = signature.parameters;
            var paramType = null;

            var overloadApplicability = 3 /* Subtype */;

            for (var i = 0; i < args.length; i++) {
                if (!isInVarArg) {
                    this.resolveDeclaredSymbol(parameters[i], context);

                    if (parameters[i].isVarArg) {
                        paramType = parameters[i].type.getElementType() || this.getNewErrorTypeSymbol(parameters[i].type.getName());
                        isInVarArg = true;
                    } else {
                        paramType = parameters[i].type;
                    }
                }

                var statusOfCurrentArgument = this.overloadIsApplicableForArgument(paramType, args[i], i, context, comparisonInfo);

                if (statusOfCurrentArgument === 0 /* NotAssignable */) {
                    return 0 /* NotAssignable */;
                } else if (statusOfCurrentArgument === 1 /* AssignableButWithProvisionalErrors */) {
                    overloadApplicability = 1 /* AssignableButWithProvisionalErrors */;
                } else if (overloadApplicability !== 1 /* AssignableButWithProvisionalErrors */ && statusOfCurrentArgument === 2 /* AssignableWithNoProvisionalErrors */) {
                    overloadApplicability = 2 /* AssignableWithNoProvisionalErrors */;
                }
            }

            return overloadApplicability;
        };

        PullTypeResolver.prototype.overloadIsApplicableForArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            if (paramType.isAny()) {
                return 3 /* Subtype */;
            } else if (paramType.isError()) {
                return 1 /* AssignableButWithProvisionalErrors */;
            } else if (arg.kind() === 220 /* SimpleArrowFunctionExpression */) {
                var simpleArrowFunction = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, null, [simpleArrowFunction.parameter], null, simpleArrowFunction.block, simpleArrowFunction.expression, argIndex, context, comparisonInfo);
            } else if (arg.kind() === 219 /* ParenthesizedArrowFunctionExpression */) {
                var arrowFunction = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, arrowFunction.callSignature.typeParameterList, arrowFunction.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(arrowFunction), arrowFunction.block, arrowFunction.expression, argIndex, context, comparisonInfo);
            } else if (arg.kind() === 223 /* FunctionExpression */) {
                var functionExpression = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, functionExpression.callSignature.typeParameterList, functionExpression.callSignature.parameterList.parameters, TypeScript.ASTHelpers.getType(functionExpression), functionExpression.block, null, argIndex, context, comparisonInfo);
            } else if (arg.kind() === 216 /* ObjectLiteralExpression */) {
                return this.overloadIsApplicableForObjectLiteralArgument(paramType, arg, argIndex, context, comparisonInfo);
            } else if (arg.kind() === 215 /* ArrayLiteralExpression */) {
                return this.overloadIsApplicableForArrayLiteralArgument(paramType, arg, argIndex, context, comparisonInfo);
            } else {
                return this.overloadIsApplicableForOtherArgument(paramType, arg, argIndex, context, comparisonInfo);
            }
        };

        PullTypeResolver.prototype.overloadIsApplicableForAnyFunctionExpressionArgument = function (paramType, arg, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, argIndex, context, comparisonInfo) {
            if (this.cachedFunctionInterfaceType() && paramType === this.cachedFunctionInterfaceType()) {
                return 2 /* AssignableWithNoProvisionalErrors */;
            }

            context.pushProvisionalType(paramType);

            var argSym = this.resolveAnyFunctionExpression(arg, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, true, context);

            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);

            context.popAnyContextualType();

            return applicabilityStatus;
        };

        PullTypeResolver.prototype.overloadIsApplicableForObjectLiteralArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            if (this.cachedObjectInterfaceType() && paramType === this.cachedObjectInterfaceType()) {
                return 2 /* AssignableWithNoProvisionalErrors */;
            }

            context.pushProvisionalType(paramType);
            var argSym = this.resolveObjectLiteralExpression(arg, true, context);

            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);

            context.popAnyContextualType();

            return applicabilityStatus;
        };

        PullTypeResolver.prototype.overloadIsApplicableForArrayLiteralArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            if (paramType === this.cachedArrayInterfaceType()) {
                return 2 /* AssignableWithNoProvisionalErrors */;
            }

            context.pushProvisionalType(paramType);
            var argSym = this.resolveArrayLiteralExpression(arg, true, context);

            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);

            context.popAnyContextualType();

            return applicabilityStatus;
        };

        PullTypeResolver.prototype.overloadIsApplicableForOtherArgument = function (paramType, arg, argIndex, context, comparisonInfo) {
            var argSym = this.resolveAST(arg, false, context);

            if (argSym.type.isAlias()) {
                var aliasSym = argSym.type;
                argSym = aliasSym.getExportAssignedTypeSymbol();
            }

            comparisonInfo.stringConstantVal = arg;
            return this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);
        };

        PullTypeResolver.prototype.overloadIsApplicableForArgumentHelper = function (paramType, argSym, argumentIndex, comparisonInfo, arg, context) {
            var tempComparisonInfo = new TypeComparisonInfo();
            tempComparisonInfo.stringConstantVal = comparisonInfo.stringConstantVal;
            if (!context.hasProvisionalErrors() && this.sourceIsSubtypeOfTarget(argSym.type, paramType, arg, context, tempComparisonInfo)) {
                return 3 /* Subtype */;
            }

            if (this.sourceIsAssignableToTarget(argSym.type, paramType, arg, context, comparisonInfo.message ? tempComparisonInfo : comparisonInfo)) {
                return context.hasProvisionalErrors() ? 1 /* AssignableButWithProvisionalErrors */ : 2 /* AssignableWithNoProvisionalErrors */;
            }

            if (!comparisonInfo.message) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(arg);
                comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type_0_to_argument_1_which_is_of_type_2, [paramType.toString(enclosingSymbol), (argumentIndex + 1), argSym.getTypeName(enclosingSymbol)]));
            }

            return 0 /* NotAssignable */;
        };

        PullTypeResolver.prototype.inferArgumentTypesForSignature = function (argContext, comparisonInfo, context) {
            var inferenceResultTypes = argContext.inferTypeArguments();
            var typeParameters = argContext.signatureBeingInferred.getTypeParameters();
            TypeScript.Debug.assert(typeParameters.length == inferenceResultTypes.length);

            var typeReplacementMapForConstraints = null;
            for (var i = 0; i < inferenceResultTypes.length; i++) {
                if (typeParameters[i].getConstraint()) {
                    typeReplacementMapForConstraints = typeReplacementMapForConstraints || TypeScript.PullInstantiationHelpers.createTypeParameterSubstitutionMap(typeParameters, inferenceResultTypes);
                    var associatedConstraint = this.instantiateType(typeParameters[i].getConstraint(), typeReplacementMapForConstraints);
                    if (!this.sourceIsAssignableToTargetWithNewEnclosingTypes(inferenceResultTypes[i], associatedConstraint, null, context, null, false)) {
                        inferenceResultTypes[i] = associatedConstraint;
                    }
                }
            }

            if (argContext.isInvocationInferenceContext()) {
                var invocationContext = argContext;
                if (!this.typeParametersAreInScopeAtArgumentList(typeParameters, invocationContext.argumentList)) {
                    for (var i = 0; i < inferenceResultTypes.length; i++) {
                        if (inferenceResultTypes[i].wrapsSomeTypeParameter(argContext.candidateCache)) {
                            inferenceResultTypes[i] = this.semanticInfoChain.anyTypeSymbol;
                        }
                    }
                }
            }

            return inferenceResultTypes;
        };

        PullTypeResolver.prototype.typeParametersAreInScopeAtArgumentList = function (typeParameters, args) {
            var enclosingDecl = this.getEnclosingDeclForAST(args);
            var typeParameterParentDecl = typeParameters[0].getDeclarations()[0].getParentDecl();
            return enclosingDecl.getParentPath().indexOf(typeParameterParentDecl) > -1;
        };

        PullTypeResolver.prototype.relateTypeToTypeParametersInEnclosingType = function (expressionType, parameterType, argContext, context) {
            if (expressionType && parameterType) {
                if (context.oneOfClassificationsIsInfinitelyExpanding()) {
                    this.relateInifinitelyExpandingTypeToTypeParameters(expressionType, parameterType, argContext, context);
                    return;
                }
            }
            this.relateTypeToTypeParameters(expressionType, parameterType, argContext, context);
        };

        PullTypeResolver.prototype.relateTypeToTypeParametersWithNewEnclosingTypes = function (expressionType, parameterType, argContext, context) {
            var enclosingTypeWalkerStates = context.resetEnclosingTypeWalkerStates();
            this.relateTypeToTypeParameters(expressionType, parameterType, argContext, context);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
        };

        PullTypeResolver.prototype.relateTypeToTypeParameters = function (expressionType, parameterType, argContext, context) {
            if (!expressionType || !parameterType) {
                return;
            }

            if (expressionType.isError()) {
                expressionType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (parameterType.isTypeParameter()) {
                var typeParameter = parameterType;
                argContext.addCandidateForInference(typeParameter, expressionType);
                return;
            }

            if (parameterType.isNamedTypeSymbol() && !parameterType.isGeneric() && !parameterType.getTypeArguments()) {
                return;
            }

            if (TypeScript.PullInstantiationHelpers.twoTypesAreInstantiationsOfSameNamedGenericType(expressionType, parameterType)) {
                this.relateTypeArgumentsOfTypeToTypeParameters(expressionType, parameterType, argContext, context);
            } else {
                var symbolsWhenStartedWalkingTypes = context.startWalkingTypes(expressionType, parameterType);
                this.relateObjectTypeToTypeParameters(expressionType, parameterType, argContext, context);
                context.endWalkingTypes(symbolsWhenStartedWalkingTypes);
            }
        };

        PullTypeResolver.prototype.relateTypeArgumentsOfTypeToTypeParameters = function (expressionType, parameterType, argContext, context) {
            var parameterSideTypeArguments = parameterType.getTypeArguments();
            var argumentSideTypeArguments = expressionType.getTypeArguments();

            TypeScript.Debug.assert(parameterSideTypeArguments && argumentSideTypeArguments && parameterSideTypeArguments.length === argumentSideTypeArguments.length);
            for (var i = 0; i < parameterSideTypeArguments.length; i++) {
                this.relateTypeToTypeParametersWithNewEnclosingTypes(argumentSideTypeArguments[i], parameterSideTypeArguments[i], argContext, context);
            }
        };

        PullTypeResolver.prototype.relateInifinitelyExpandingTypeToTypeParameters = function (expressionType, parameterType, argContext, context) {
            if (!expressionType || !parameterType) {
                return;
            }

            var expressionTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(expressionType);
            var parameterTypeNamedTypeReference = TypeScript.PullHelpers.getRootType(parameterType);
            if (expressionTypeNamedTypeReference !== parameterTypeNamedTypeReference) {
                return;
            }

            var expressionTypeTypeArguments = expressionType.getTypeArguments();
            var parameterTypeArguments = parameterType.getTypeArguments();

            if (expressionTypeTypeArguments && parameterTypeArguments && expressionTypeTypeArguments.length === parameterTypeArguments.length) {
                for (var i = 0; i < expressionTypeTypeArguments.length; i++) {
                    this.relateTypeArgumentsOfTypeToTypeParameters(expressionType, parameterType, argContext, context);
                }
            }
        };

        PullTypeResolver.prototype.relateFunctionSignatureToTypeParameters = function (expressionSignature, parameterSignature, argContext, context) {
            var _this = this;
            var expressionReturnType = expressionSignature.returnType;
            var parameterReturnType = parameterSignature.returnType;

            parameterSignature.forAllCorrespondingParameterTypesInThisAndOtherSignature(expressionSignature, function (parameterSignatureParameterType, expressionSignatureParameterType, i) {
                context.walkParameterTypes(i);
                _this.relateTypeToTypeParametersInEnclosingType(expressionSignatureParameterType, parameterSignatureParameterType, argContext, context);
                context.postWalkParameterTypes();
                return true;
            });

            context.walkReturnTypes();
            this.relateTypeToTypeParametersInEnclosingType(expressionReturnType, parameterReturnType, argContext, context);
            context.postWalkReturnTypes();
        };

        PullTypeResolver.prototype.relateObjectTypeToTypeParameters = function (objectType, parameterType, argContext, context) {
            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures;

            var objectMember;
            var objectSignatures;

            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }

            for (var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = this.getNamedPropertySymbol(parameterTypeMembers[i].name, 68147712 /* SomeValue */, objectType);
                if (objectMember) {
                    this.resolveDeclaredSymbol(objectMember);
                    this.resolveDeclaredSymbol(parameterTypeMembers[i]);
                    context.walkMemberTypes(parameterTypeMembers[i].name);
                    this.relateTypeToTypeParametersInEnclosingType(objectMember.type, parameterTypeMembers[i].type, argContext, context);
                    context.postWalkMemberTypes();
                }
            }

            this.relateSignatureGroupToTypeParameters(objectType.getCallSignatures(), parameterType.getCallSignatures(), 1048576 /* CallSignature */, argContext, context);

            this.relateSignatureGroupToTypeParameters(objectType.getConstructSignatures(), parameterType.getConstructSignatures(), 2097152 /* ConstructSignature */, argContext, context);

            var parameterIndexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(parameterType, context);
            var objectIndexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(objectType, context);
            var indexSigInfo = context.getBothKindOfIndexSignatures(false, false);

            if (parameterIndexSignatures.stringSignature && objectIndexSignatures.stringSignature) {
                context.walkIndexSignatureReturnTypes(indexSigInfo, true, true, true);
                this.relateFunctionSignatureToTypeParameters(objectIndexSignatures.stringSignature, parameterIndexSignatures.stringSignature, argContext, context);
                context.postWalkIndexSignatureReturnTypes(true);
            }
            if (parameterIndexSignatures.numericSignature && objectIndexSignatures.numericSignature) {
                context.walkIndexSignatureReturnTypes(indexSigInfo, false, false, true);
                this.relateFunctionSignatureToTypeParameters(objectIndexSignatures.numericSignature, parameterIndexSignatures.numericSignature, argContext, context);
                context.postWalkIndexSignatureReturnTypes(true);
            }
        };

        PullTypeResolver.prototype.relateSignatureGroupToTypeParameters = function (argumentSignatures, parameterSignatures, signatureKind, argContext, context) {
            for (var i = 0; i < parameterSignatures.length; i++) {
                var paramSignature = parameterSignatures[i];
                if (argumentSignatures.length > 0) {
                    paramSignature = this.instantiateSignatureToAny(paramSignature);
                }
                for (var j = 0; j < argumentSignatures.length; j++) {
                    var argumentSignature = argumentSignatures[j];
                    if (argumentSignature.nonOptionalParamCount > paramSignature.nonOptionalParamCount) {
                        continue;
                    }

                    argumentSignature = this.instantiateSignatureToAny(argumentSignature);

                    context.walkSignatures(signatureKind, j, i);
                    this.relateFunctionSignatureToTypeParameters(argumentSignature, paramSignature, argContext, context);
                    context.postWalkSignatures();
                }
            }
        };

        PullTypeResolver.prototype.alterPotentialGenericFunctionTypeToInstantiatedFunctionTypeForTypeArgumentInference = function (expressionSymbol, context) {
            var inferentialType = context.getContextualType();
            TypeScript.Debug.assert(inferentialType);
            var expressionType = expressionSymbol.type;
            if (this.isFunctionTypeWithExactlyOneCallSignatureAndNoOtherMembers(expressionType, true) && this.isFunctionTypeWithExactlyOneCallSignatureAndNoOtherMembers(inferentialType, false)) {
                var genericExpressionSignature = expressionType.getCallSignatures()[0];
                var contextualSignature = inferentialType.getCallSignatures()[0];

                var instantiatedSignature = this.instantiateSignatureInContext(genericExpressionSignature, contextualSignature, context, true);
                if (instantiatedSignature === null) {
                    return expressionSymbol;
                }

                var newType = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */, this.semanticInfoChain);
                newType.appendCallSignature(instantiatedSignature);
                return newType;
            }

            return expressionSymbol;
        };

        PullTypeResolver.prototype.isFunctionTypeWithExactlyOneCallSignatureAndNoOtherMembers = function (type, callSignatureShouldBeGeneric) {
            TypeScript.Debug.assert(type);
            if (type.getCallSignatures().length !== 1) {
                return false;
            }

            var callSignatureIsGeneric = type.getCallSignatures()[0].isGeneric();
            if (callSignatureIsGeneric !== callSignatureShouldBeGeneric) {
                return false;
            }

            var typeHasOtherMembers = type.getConstructSignatures().length || type.getIndexSignatures().length || type.getAllMembers(68147712 /* SomeValue */, 0 /* all */).length;
            if (typeHasOtherMembers) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.instantiateTypeToAny = function (typeToSpecialize, context) {
            var typeParameters = typeToSpecialize.getTypeParameters();

            if (!typeParameters.length) {
                return typeToSpecialize;
            }

            var typeArguments = null;

            if (!this._cachedAnyTypeArgs) {
                this._cachedAnyTypeArgs = [
                    [this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol]
                ];
            }

            if (typeParameters.length < this._cachedAnyTypeArgs.length) {
                typeArguments = this._cachedAnyTypeArgs[typeParameters.length - 1];
            } else {
                typeArguments = [];

                for (var i = 0; i < typeParameters.length; i++) {
                    typeArguments[typeArguments.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            var type = this.createInstantiatedType(typeToSpecialize, typeArguments);

            return type;
        };

        PullTypeResolver.prototype.instantiateSignatureToAny = function (signature) {
            if (!signature.isGeneric()) {
                return signature;
            }

            var typeParameters = signature.getTypeParameters();
            if (!this._cachedAnyTypeArgs) {
                this._cachedAnyTypeArgs = [
                    [this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol]
                ];
            }

            if (typeParameters.length < this._cachedAnyTypeArgs.length) {
                var typeArguments = this._cachedAnyTypeArgs[typeParameters.length - 1];
            } else {
                var typeArguments = [];

                for (var i = 0; i < typeParameters.length; i++) {
                    typeArguments[typeArguments.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            var typeParameterArgumentMap = TypeScript.PullInstantiationHelpers.createTypeParameterSubstitutionMap(typeParameters, typeArguments);
            return this.instantiateSignature(signature, typeParameterArgumentMap);
        };

        PullTypeResolver.typeCheck = function (compilationSettings, semanticInfoChain, document) {
            var sourceUnit = document.sourceUnit();

            var resolver = semanticInfoChain.getResolver();
            var context = new TypeScript.PullTypeResolutionContext(resolver, true, TypeScript.syntaxTree(sourceUnit).fileName());

            if (resolver.canTypeCheckAST(sourceUnit, context)) {
                resolver.resolveAST(sourceUnit, false, context);
                resolver.validateVariableDeclarationGroups(semanticInfoChain.getDeclForAST(sourceUnit), context);

                while (resolver.typeCheckCallBacks.length) {
                    var callBack = resolver.typeCheckCallBacks.pop();
                    callBack(context);
                }

                resolver.processPostTypeCheckWorkItems(context);
            }
        };

        PullTypeResolver.prototype.validateVariableDeclarationGroups = function (enclosingDecl, context) {
            var _this = this;
            this.scanVariableDeclarationGroups(enclosingDecl, function (_) {
            }, function (subsequentDecl, firstSymbol) {
                if (TypeScript.hasFlag(subsequentDecl.kind, 2048 /* Parameter */) || TypeScript.hasFlag(subsequentDecl.flags, 8388608 /* PropertyParameter */)) {
                    return;
                }

                var boundDeclAST = _this.semanticInfoChain.getASTForDecl(subsequentDecl);

                var symbol = subsequentDecl.getSymbol(_this.semanticInfoChain);
                var symbolType = symbol.type;
                var firstSymbolType = firstSymbol.type;

                if (symbolType && firstSymbolType && symbolType !== firstSymbolType && !_this.typesAreIdentical(symbolType, firstSymbolType, context)) {
                    context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(boundDeclAST, TypeScript.DiagnosticCode.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, [symbol.getScopedName(), firstSymbolType.toString(firstSymbol), symbolType.toString(symbol)]));
                }
            });
        };

        PullTypeResolver.prototype.typeCheckFunctionOverloads = function (funcDecl, context, signature, allSignatures) {
            if (!signature) {
                var functionSignatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(this.semanticInfoChain.getDeclForAST(funcDecl), this.semanticInfoChain);
                signature = functionSignatureInfo.signature;
                allSignatures = functionSignatureInfo.allSignatures;
            }
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSymbol = functionDeclaration.getSymbol(this.semanticInfoChain);

            var definitionSignature = null;
            for (var i = allSignatures.length - 1; i >= 0; i--) {
                if (allSignatures[i].isDefinition()) {
                    definitionSignature = allSignatures[i];
                    break;
                }
            }

            var isConstantOverloadSignature = signature.isStringConstantOverloadSignature();
            if (isConstantOverloadSignature) {
                if (signature.isDefinition()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Overload_signature_implementation_cannot_use_specialized_type));
                } else {
                    var foundSubtypeSignature = false;
                    for (var i = 0; i < allSignatures.length; i++) {
                        if (allSignatures[i].isDefinition() || allSignatures[i] === signature) {
                            continue;
                        }

                        if (!allSignatures[i].isResolved) {
                            this.resolveDeclaredSymbol(allSignatures[i], context);
                        }

                        if (allSignatures[i].isStringConstantOverloadSignature()) {
                            continue;
                        }

                        if (this.signatureIsAssignableToTarget(signature, allSignatures[i], null, context)) {
                            foundSubtypeSignature = true;
                            break;
                        }
                    }

                    if (!foundSubtypeSignature) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature));
                    }
                }
            } else if (definitionSignature && definitionSignature !== signature) {
                var comparisonInfo = new TypeComparisonInfo();

                if (!definitionSignature.isResolved) {
                    this.resolveDeclaredSymbol(definitionSignature, context);
                }

                if (!this.signatureIsAssignableToTarget(definitionSignature, signature, funcDecl, context, comparisonInfo)) {
                    if (comparisonInfo.message) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition_NL_0, [comparisonInfo.message]));
                    } else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition));
                    }
                }
            }

            var signatureForVisibilityCheck = definitionSignature;
            if (!definitionSignature) {
                if (allSignatures[0] === signature) {
                    return;
                }
                signatureForVisibilityCheck = allSignatures[0];
            }

            if (funcDecl.kind() !== 138 /* ConstructorDeclaration */ && functionDeclaration.kind !== 2097152 /* ConstructSignature */ && signatureForVisibilityCheck && signature !== signatureForVisibilityCheck) {
                var errorCode;

                if (signatureForVisibilityCheck.anyDeclHasFlag(2 /* Private */) !== signature.anyDeclHasFlag(2 /* Private */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_public_or_private;
                } else if (signatureForVisibilityCheck.anyDeclHasFlag(1 /* Exported */) !== signature.anyDeclHasFlag(1 /* Exported */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_exported_or_not_exported;
                } else if (signatureForVisibilityCheck.anyDeclHasFlag(8 /* Ambient */) !== signature.anyDeclHasFlag(8 /* Ambient */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_ambient_or_non_ambient;
                } else if (signatureForVisibilityCheck.anyDeclHasFlag(128 /* Optional */) !== signature.anyDeclHasFlag(128 /* Optional */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_optional_or_required;
                }

                if (errorCode) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, errorCode));
                }
            }
        };

        PullTypeResolver.prototype.checkSymbolPrivacy = function (declSymbol, symbol, privacyErrorReporter) {
            if (!symbol || symbol.kind === 2 /* Primitive */) {
                return;
            }

            if (symbol.isType()) {
                var typeSymbol = symbol;
                var isNamedType = typeSymbol.isNamedTypeSymbol();

                if (typeSymbol.isArrayNamedTypeReference()) {
                    this.checkSymbolPrivacy(declSymbol, typeSymbol.getElementType(), privacyErrorReporter);
                    return;
                }

                if (!isNamedType) {
                    var typeOfSymbol = typeSymbol.getTypeOfSymbol();
                    if (typeOfSymbol) {
                        this.checkSymbolPrivacy(declSymbol, typeOfSymbol, privacyErrorReporter);
                        return;
                    }
                }

                if (typeSymbol.inSymbolPrivacyCheck) {
                    return;
                }

                typeSymbol.inSymbolPrivacyCheck = true;

                var typars = typeSymbol.getTypeArgumentsOrTypeParameters();
                if (typars) {
                    for (var i = 0; i < typars.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, typars[i], privacyErrorReporter);
                    }
                }

                if (!isNamedType) {
                    var members = typeSymbol.getMembers();
                    for (var i = 0; i < members.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, members[i].type, privacyErrorReporter);
                    }

                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getCallSignatures(), privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getConstructSignatures(), privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getIndexSignatures(), privacyErrorReporter);
                } else if (typeSymbol.kind === 8192 /* TypeParameter */) {
                    this.checkSymbolPrivacy(declSymbol, typeSymbol.getConstraint(), privacyErrorReporter);
                }

                typeSymbol.inSymbolPrivacyCheck = false;

                if (!isNamedType) {
                    return;
                }
            }

            if (declSymbol.isExternallyVisible()) {
                var symbolIsVisible = symbol.isExternallyVisible();

                if (symbolIsVisible && symbol.kind !== 8192 /* TypeParameter */) {
                    var symbolPath = symbol.pathToRoot();
                    var declSymbolPath = declSymbol.pathToRoot();

                    if (symbolPath[symbolPath.length - 1].kind === 32 /* DynamicModule */ && declSymbolPath[declSymbolPath.length - 1].kind === 32 /* DynamicModule */ && declSymbolPath[declSymbolPath.length - 1] !== symbolPath[symbolPath.length - 1]) {
                        symbolIsVisible = false;
                        var declSymbolScope = declSymbolPath[declSymbolPath.length - 1];
                        for (var i = symbolPath.length - 1; i >= 0; i--) {
                            var aliasSymbols = symbolPath[i].getExternalAliasedSymbols(declSymbolScope);
                            if (aliasSymbols) {
                                symbolIsVisible = true;
                                aliasSymbols[0].setTypeUsedExternally();
                                break;
                            }
                        }
                        symbol = symbolPath[symbolPath.length - 1];
                    }
                } else if (symbol.kind === 128 /* TypeAlias */) {
                    var aliasSymbol = symbol;
                    symbolIsVisible = true;
                    aliasSymbol.setTypeUsedExternally();
                }

                if (!symbolIsVisible) {
                    privacyErrorReporter(symbol);
                }
            }
        };

        PullTypeResolver.prototype.checkTypePrivacyOfSignatures = function (declSymbol, signatures, privacyErrorReporter) {
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (signatures.length > 1 && signature.isDefinition()) {
                    continue;
                }

                var typeParams = signature.getTypeParameters();
                for (var j = 0; j < typeParams.length; j++) {
                    this.checkSymbolPrivacy(declSymbol, typeParams[j], privacyErrorReporter);
                }

                var params = signature.parameters;
                for (var j = 0; j < params.length; j++) {
                    var paramType = params[j].type;
                    this.checkSymbolPrivacy(declSymbol, paramType, privacyErrorReporter);
                }

                var returnType = signature.returnType;
                this.checkSymbolPrivacy(declSymbol, returnType, privacyErrorReporter);
            }
        };

        PullTypeResolver.prototype.typeParameterOfTypeDeclarationPrivacyErrorReporter = function (classOrInterface, typeParameterAST, typeParameter, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;
            var messageCode;

            var typeParameters = classOrInterface.kind() === 132 /* ClassDeclaration */ ? classOrInterface.typeParameterList : classOrInterface.typeParameterList;

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.kind() === 132 /* ClassDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_class_is_using_inaccessible_module_1;
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1;
                }
            } else {
                if (classOrInterface.kind() === 132 /* ClassDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_class_has_or_is_using_private_type_1;
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1;
                }
            }

            var messageArguments = [typeParameter.getScopedName(enclosingSymbol, false, true), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeParameterAST, messageCode, messageArguments));
        };

        PullTypeResolver.prototype.baseListPrivacyErrorReporter = function (classOrInterface, declSymbol, baseAst, isExtendedType, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;
            var messageCode;

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.kind() === 132 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_class_from_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_interface_from_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_interface_from_inaccessible_module_1;
                }
            } else {
                if (classOrInterface.kind() === 132 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_private_class_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_private_interface_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_private_interface_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseAst, messageCode, messageArguments));
        };

        PullTypeResolver.prototype.variablePrivacyErrorReporter = function (declAST, declSymbol, symbol, context) {
            var typeSymbol = symbol;
            var enclosingDecl = this.getEnclosingDecl(declSymbol.getDeclarations()[0]);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;

            var isProperty = declSymbol.kind === 4096 /* Property */;
            var isPropertyOfClass = false;
            var declParent = declSymbol.getContainer();
            if (declParent && (declParent.kind === 8 /* Class */ || declParent.kind === 32768 /* ConstructorMethod */)) {
                isPropertyOfClass = true;
            }

            var messageCode;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declSymbol.anyDeclHasFlag(16 /* Static */)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_is_using_inaccessible_module_1;
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_is_using_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_is_using_inaccessible_module_1;
                }
            } else {
                if (declSymbol.anyDeclHasFlag(16 /* Static */)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_has_or_is_using_private_type_1;
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_has_or_is_using_private_type_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_has_or_is_using_private_type_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declAST, messageCode, messageArguments));
        };

        PullTypeResolver.prototype.checkFunctionTypePrivacy = function (funcDeclAST, isStatic, typeParameters, parameters, returnTypeAnnotation, block, context) {
            var _this = this;
            if (funcDeclAST.kind() === 223 /* FunctionExpression */ || funcDeclAST.kind() === 242 /* FunctionPropertyAssignment */ || (funcDeclAST.kind() === 140 /* GetAccessor */ && funcDeclAST.parent.parent.kind() === 216 /* ObjectLiteralExpression */) || (funcDeclAST.kind() === 141 /* SetAccessor */ && funcDeclAST.parent.parent.kind() === 216 /* ObjectLiteralExpression */)) {
                return;
            }

            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var functionSymbol = functionDecl.getSymbol(this.semanticInfoChain);
            ;
            var functionSignature;

            var isGetter = funcDeclAST.kind() === 140 /* GetAccessor */;
            var isSetter = funcDeclAST.kind() === 141 /* SetAccessor */;
            var isIndexSignature = functionDecl.kind === 4194304 /* IndexSignature */;

            if (isGetter || isSetter) {
                var accessorSymbol = functionSymbol;
                functionSignature = (isGetter ? accessorSymbol.getGetter() : accessorSymbol.getSetter()).type.getCallSignatures()[0];
            } else {
                if (!functionSymbol) {
                    var parentDecl = functionDecl.getParentDecl();
                    functionSymbol = parentDecl.getSymbol(this.semanticInfoChain);
                    if (functionSymbol && functionSymbol.isType() && !functionSymbol.isNamedTypeSymbol()) {
                        return;
                    }
                } else if (functionSymbol.kind === 65536 /* Method */ && !isStatic && !functionSymbol.getContainer().isNamedTypeSymbol()) {
                    return;
                }
                functionSignature = functionDecl.getSignatureSymbol(this.semanticInfoChain);
            }

            if (typeParameters && !isGetter && !isSetter && !isIndexSignature && funcDeclAST.kind() !== 138 /* ConstructorDeclaration */) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    var typeParameterAST = typeParameters.typeParameters[i];
                    var typeParameter = this.resolveTypeParameterDeclaration(typeParameterAST, context);
                    this.checkSymbolPrivacy(functionSymbol, typeParameter, function (symbol) {
                        return _this.functionTypeArgumentArgumentTypePrivacyErrorReporter(funcDeclAST, isStatic, typeParameterAST, typeParameter, symbol, context);
                    });
                }
            }

            if (!isGetter && !isIndexSignature) {
                var funcParams = functionSignature.parameters;
                for (var i = 0; i < funcParams.length; i++) {
                    this.checkSymbolPrivacy(functionSymbol, funcParams[i].type, function (symbol) {
                        return _this.functionArgumentTypePrivacyErrorReporter(funcDeclAST, isStatic, parameters, i, funcParams[i], symbol, context);
                    });
                }
            }

            if (!isSetter) {
                this.checkSymbolPrivacy(functionSymbol, functionSignature.returnType, function (symbol) {
                    return _this.functionReturnTypePrivacyErrorReporter(funcDeclAST, isStatic, returnTypeAnnotation, block, functionSignature.returnType, symbol, context);
                });
            }
        };

        PullTypeResolver.prototype.functionTypeArgumentArgumentTypePrivacyErrorReporter = function (declAST, isStatic, typeParameterAST, typeParameter, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;

            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || isStatic)) {
                isMethodOfClass = true;
            }

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (decl.kind === 2097152 /* ConstructSignature */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (decl.kind === 1048576 /* CallSignature */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            } else {
                if (decl.kind === 2097152 /* ConstructSignature */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (decl.kind === 1048576 /* CallSignature */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }

            if (messageCode) {
                var messageArgs = [typeParameter.getScopedName(enclosingSymbol, false, true), typeSymbolName];
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeParameterAST, messageCode, messageArgs));
            }
        };

        PullTypeResolver.prototype.functionArgumentTypePrivacyErrorReporter = function (declAST, isStatic, parameters, argIndex, paramSymbol, symbol, context) {
            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;

            var isGetter = declAST.kind() === 140 /* GetAccessor */;
            var isSetter = declAST.kind() === 141 /* SetAccessor */;
            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || isStatic)) {
                isMethodOfClass = true;
            }

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declAST.kind() === 138 /* ConstructorDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1;
                } else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    }
                } else if (decl.kind === 2097152 /* ConstructSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (decl.kind === 1048576 /* CallSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                } else if (!isGetter) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            } else {
                if (declAST.kind() === 138 /* ConstructorDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1;
                } else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    }
                } else if (decl.kind === 2097152 /* ConstructSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (decl.kind === 1048576 /* CallSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                } else if (!isGetter && decl.kind !== 4194304 /* IndexSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }

            if (messageCode) {
                var parameter = parameters[argIndex];

                var messageArgs = [paramSymbol.getScopedName(enclosingSymbol), typeSymbolName];
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(parameter, messageCode, messageArgs));
            }
        };

        PullTypeResolver.prototype.functionReturnTypePrivacyErrorReporter = function (declAST, isStatic, returnTypeAnnotation, block, funcReturnType, symbol, context) {
            var _this = this;
            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);

            var isGetter = declAST.kind() === 140 /* GetAccessor */;
            var isSetter = declAST.kind() === 141 /* SetAccessor */;
            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || isStatic)) {
                isMethodOfClass = true;
            }

            var messageCode = null;
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    }
                } else if (decl.kind === 2097152 /* ConstructSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (decl.kind === 1048576 /* CallSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (decl.kind === 4194304 /* IndexSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0;
                    }
                } else if (!isSetter && declAST.kind() !== 138 /* ConstructorDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_is_using_inaccessible_module_0;
                }
            } else {
                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    }
                } else if (decl.kind === 2097152 /* ConstructSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (decl.kind === 1048576 /* CallSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (decl.kind === 4194304 /* IndexSignature */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0;
                    }
                } else if (!isSetter && declAST.kind() !== 138 /* ConstructorDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_has_or_is_using_private_type_0;
                }
            }

            if (messageCode) {
                var messageArguments = [typeSymbolName];
                var reportOnFuncDecl = false;

                if (returnTypeAnnotation) {
                    var returnExpressionSymbol = this.resolveTypeReference(returnTypeAnnotation, context);

                    if (TypeScript.PullHelpers.typeSymbolsAreIdentical(returnExpressionSymbol, funcReturnType)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, messageCode, messageArguments));
                    }
                }

                if (block) {
                    var reportErrorOnReturnExpressions = function (ast, walker) {
                        var go = true;
                        if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(ast)) {
                            go = false;
                        } else if (ast.kind() === 151 /* ReturnStatement */) {
                            var returnStatement = ast;
                            var returnExpressionSymbol = _this.resolveAST(returnStatement.expression, false, context).type;

                            if (TypeScript.PullHelpers.typeSymbolsAreIdentical(returnExpressionSymbol, funcReturnType)) {
                                context.postDiagnostic(_this.semanticInfoChain.diagnosticFromAST(returnStatement, messageCode, messageArguments));
                            } else {
                                reportOnFuncDecl = true;
                            }
                            go = false;
                        }

                        walker.options.goChildren = go;
                        return ast;
                    };

                    TypeScript.getAstWalkerFactory().walk(block, reportErrorOnReturnExpressions);
                }

                if (reportOnFuncDecl) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declAST, messageCode, messageArguments));
                }
            }
        };

        PullTypeResolver.prototype.enclosingClassIsDerived = function (classDecl) {
            TypeScript.Debug.assert(classDecl.kind === 8 /* Class */);

            var classSymbol = classDecl.getSymbol(this.semanticInfoChain);
            return classSymbol.getExtendedTypes().length > 0;
        };

        PullTypeResolver.prototype.isSuperInvocationExpression = function (ast) {
            if (ast.kind() === 214 /* InvocationExpression */) {
                var invocationExpression = ast;
                if (invocationExpression.expression.kind() === 50 /* SuperKeyword */) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.isSuperInvocationExpressionStatement = function (node) {
            if (node && node.kind() === 150 /* ExpressionStatement */) {
                var expressionStatement = node;
                if (this.isSuperInvocationExpression(expressionStatement.expression)) {
                    return true;
                }
            }
            return false;
        };

        PullTypeResolver.prototype.getFirstStatementOfBlockOrNull = function (block) {
            if (block && block.statements && block.statements.length > 0) {
                return block.statements[0];
            }

            return null;
        };

        PullTypeResolver.prototype.superCallMustBeFirstStatementInConstructor = function (constructorDecl) {
            TypeScript.Debug.assert(constructorDecl.kind === 32768 /* ConstructorMethod */);

            if (constructorDecl) {
                var enclosingClass = constructorDecl.getParentDecl();

                var classSymbol = enclosingClass.getSymbol(this.semanticInfoChain);
                if (classSymbol.getExtendedTypes().length === 0) {
                    return false;
                }

                var classMembers = classSymbol.getMembers();
                for (var i = 0, n1 = classMembers.length; i < n1; i++) {
                    var member = classMembers[i];

                    if (member.kind === 4096 /* Property */) {
                        var declarations = member.getDeclarations();
                        for (var j = 0, n2 = declarations.length; j < n2; j++) {
                            var declaration = declarations[j];
                            var ast = this.semanticInfoChain.getASTForDecl(declaration);
                            if (ast.kind() === 243 /* Parameter */) {
                                return true;
                            }

                            if (ast.kind() === 137 /* MemberVariableDeclaration */) {
                                var variableDeclarator = ast;
                                if (variableDeclarator.variableDeclarator.equalsValueClause) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkForThisCaptureInArrowFunction = function (expression) {
            var enclosingDecl = this.getEnclosingDeclForAST(expression);

            var declPath = enclosingDecl.getParentPath();

            if (declPath.length) {
                var inArrowFunction = false;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;

                    if (declKind === 131072 /* FunctionExpression */ && TypeScript.hasFlag(declFlags, 8192 /* ArrowFunction */)) {
                        inArrowFunction = true;
                        continue;
                    }

                    if (inArrowFunction) {
                        if (declKind === 16384 /* Function */ || declKind === 65536 /* Method */ || declKind === 32768 /* ConstructorMethod */ || declKind === 262144 /* GetAccessor */ || declKind === 524288 /* SetAccessor */ || declKind === 131072 /* FunctionExpression */ || declKind === 8 /* Class */ || declKind === 4 /* Container */ || declKind === 32 /* DynamicModule */ || declKind === 1 /* Script */) {
                            decl.setFlags(decl.flags | 262144 /* MustCaptureThis */);

                            if (declKind === 8 /* Class */) {
                                var constructorSymbol = decl.getSymbol(this.semanticInfoChain).getConstructorMethod();
                                var constructorDecls = constructorSymbol.getDeclarations();
                                for (var i = 0; i < constructorDecls.length; i++) {
                                    constructorDecls[i].flags = constructorDecls[i].flags | 262144 /* MustCaptureThis */;
                                }
                            }
                            break;
                        }
                    } else if (declKind === 16384 /* Function */ || declKind === 131072 /* FunctionExpression */) {
                        break;
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckMembersAgainstIndexer = function (containerType, containerTypeDecl, context) {
            var indexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(containerType, context);
            var stringSignature = indexSignatures.stringSignature;
            var numberSignature = indexSignatures.numericSignature;

            if (stringSignature || numberSignature) {
                var members = containerTypeDecl.getChildDecls();
                for (var i = 0; i < members.length; i++) {
                    var member = members[i];
                    if ((member.name || (member.kind === 4096 /* Property */ && member.name === "")) && member.kind !== 32768 /* ConstructorMethod */ && !TypeScript.hasFlag(member.flags, 16 /* Static */)) {
                        var memberSymbol = member.getSymbol(this.semanticInfoChain);
                        var relevantSignature = this.determineRelevantIndexerForMember(memberSymbol, numberSignature, stringSignature);
                        if (relevantSignature) {
                            var comparisonInfo = new TypeComparisonInfo();
                            if (!this.sourceIsAssignableToTarget(memberSymbol.type, relevantSignature.returnType, member.ast(), context, comparisonInfo)) {
                                this.reportErrorThatMemberIsNotSubtypeOfIndexer(memberSymbol, relevantSignature, member.ast(), context, comparisonInfo);
                            }
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.determineRelevantIndexerForMember = function (member, numberIndexSignature, stringIndexSignature) {
            if (numberIndexSignature && TypeScript.PullHelpers.isNameNumeric(member.name)) {
                return numberIndexSignature;
            } else if (stringIndexSignature) {
                return stringIndexSignature;
            }

            return null;
        };

        PullTypeResolver.prototype.reportErrorThatMemberIsNotSubtypeOfIndexer = function (member, indexSignature, astForError, context, comparisonInfo) {
            var enclosingSymbol = this.getEnclosingSymbolForAST(astForError);

            if (indexSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol) {
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0_NL_1, [indexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                } else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0, [indexSignature.returnType.toString(enclosingSymbol)]));
                }
            } else {
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_named_properties_must_be_assignable_to_string_indexer_type_0_NL_1, [indexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                } else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, TypeScript.DiagnosticCode.All_named_properties_must_be_assignable_to_string_indexer_type_0, [indexSignature.returnType.toString(enclosingSymbol)]));
                }
            }
        };

        PullTypeResolver.prototype.typeCheckIfTypeMemberPropertyOkToOverride = function (typeSymbol, extendedType, typeMember, extendedTypeMember, enclosingDecl, comparisonInfo) {
            if (!typeSymbol.isClass()) {
                return true;
            }

            var typeMemberKind = typeMember.kind;
            var extendedMemberKind = extendedTypeMember.kind;

            if (typeMemberKind === extendedMemberKind) {
                return true;
            }

            var errorCode;
            if (typeMemberKind === 4096 /* Property */) {
                if (typeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
            } else if (typeMemberKind === 65536 /* Method */) {
                if (extendedTypeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                }
            }

            var message = TypeScript.getDiagnosticMessage(errorCode, [typeSymbol.toString(), typeMember.getScopedNameEx().toString(), extendedType.toString()]);
            comparisonInfo.addMessage(message);
            return false;
        };

        PullTypeResolver.prototype.typeCheckIfTypeExtendsType = function (classOrInterface, name, typeSymbol, extendedType, enclosingDecl, context) {
            var typeMembers = typeSymbol.getMembers();

            var comparisonInfo = new TypeComparisonInfo();
            var foundError = false;
            var foundError1 = false;
            var foundError2 = false;

            for (var i = 0; i < typeMembers.length; i++) {
                var propName = typeMembers[i].name;
                var extendedTypeProp = extendedType.findMember(propName, true);
                if (extendedTypeProp) {
                    this.resolveDeclaredSymbol(extendedTypeProp, context);
                    foundError1 = !this.typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, enclosingDecl, comparisonInfo);

                    if (!foundError1) {
                        foundError2 = !this.sourcePropertyIsAssignableToTargetProperty(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, classOrInterface, context, comparisonInfo);
                    }

                    if (foundError1 || foundError2) {
                        foundError = true;
                        break;
                    }
                }
            }

            if (!foundError && typeSymbol.hasOwnCallSignatures()) {
                foundError = !this.sourceCallSignaturesAreAssignableToTargetCallSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnConstructSignatures()) {
                foundError = !this.sourceConstructSignaturesAreAssignableToTargetConstructSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnIndexSignatures()) {
                foundError = !this.sourceIndexSignaturesAreAssignableToTargetIndexSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }

            if (!foundError && typeSymbol.isClass()) {
                var typeConstructorType = typeSymbol.getConstructorMethod().type;
                var typeConstructorTypeMembers = typeConstructorType.getMembers();
                if (typeConstructorTypeMembers.length) {
                    var extendedConstructorType = extendedType.getConstructorMethod().type;
                    var comparisonInfoForPropTypeCheck = new TypeComparisonInfo(comparisonInfo);

                    for (var i = 0; i < typeConstructorTypeMembers.length; i++) {
                        var propName = typeConstructorTypeMembers[i].name;
                        var extendedConstructorTypeProp = extendedConstructorType.findMember(propName, true);
                        if (extendedConstructorTypeProp) {
                            if (!extendedConstructorTypeProp.isResolved) {
                                this.resolveDeclaredSymbol(extendedConstructorTypeProp, context);
                            }

                            if (!this.sourcePropertyIsAssignableToTargetProperty(typeConstructorType, extendedConstructorType, typeConstructorTypeMembers[i], extendedConstructorTypeProp, classOrInterface, context, comparisonInfo)) {
                                foundError = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (foundError) {
                var errorCode;
                if (typeSymbol.isClass()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_cannot_extend_class_1_NL_2;
                } else {
                    if (extendedType.isClass()) {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_class_1_NL_2;
                    } else {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_interface_1_NL_2;
                    }
                }

                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, errorCode, [typeSymbol.getScopedName(), extendedType.getScopedName(), comparisonInfo.message]));
            }
        };

        PullTypeResolver.prototype.typeCheckIfClassImplementsType = function (classDecl, classSymbol, implementedType, enclosingDecl, context) {
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = !this.sourceMembersAreAssignableToTargetMembers(classSymbol, implementedType, classDecl, context, comparisonInfo);
            if (!foundError) {
                foundError = !this.sourceCallSignaturesAreAssignableToTargetCallSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                if (!foundError) {
                    foundError = !this.sourceConstructSignaturesAreAssignableToTargetConstructSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.sourceIndexSignaturesAreAssignableToTargetIndexSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                    }
                }
            }

            if (foundError) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(classDecl);
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(classDecl.identifier, TypeScript.DiagnosticCode.Class_0_declares_interface_1_but_does_not_implement_it_NL_2, [classSymbol.getScopedName(enclosingSymbol), implementedType.getScopedName(enclosingSymbol), comparisonInfo.message]));
            }
        };

        PullTypeResolver.prototype.computeValueSymbolFromAST = function (valueDeclAST, context) {
            var prevInTypeCheck = context.inTypeCheck;
            context.inTypeCheck = false;

            var typeSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(valueDeclAST);

            if (valueDeclAST.kind() == 11 /* IdentifierName */) {
                var valueSymbol = this.computeNameExpression(valueDeclAST, context);
            } else {
                TypeScript.Debug.assert(valueDeclAST.kind() == 121 /* QualifiedName */);
                var qualifiedName = valueDeclAST;

                var lhs = this.computeValueSymbolFromAST(qualifiedName.left, context);
                var valueSymbol = this.computeDottedNameExpressionFromLHS(lhs.symbol, qualifiedName.left, qualifiedName.right, context, false);
            }
            var valueSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(valueDeclAST);

            this.semanticInfoChain.setAliasSymbolForAST(valueDeclAST, typeSymbolAlias);
            context.inTypeCheck = prevInTypeCheck;

            return { symbol: valueSymbol, alias: valueSymbolAlias };
        };

        PullTypeResolver.prototype.hasClassTypeSymbolConflictAsValue = function (baseDeclAST, typeSymbol, enclosingDecl, context) {
            var typeSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(baseDeclAST);

            var valueDeclAST = baseDeclAST.kind() == 126 /* GenericType */ ? baseDeclAST.name : baseDeclAST;
            var valueSymbolInfo = this.computeValueSymbolFromAST(valueDeclAST, context);
            var valueSymbol = valueSymbolInfo.symbol;
            var valueSymbolAlias = valueSymbolInfo.alias;

            if (typeSymbolAlias && valueSymbolAlias) {
                return typeSymbolAlias !== valueSymbolAlias;
            }

            if (!valueSymbol.anyDeclHasFlag(16384 /* ClassConstructorVariable */)) {
                return true;
            }

            var associatedContainerType = valueSymbol.type ? valueSymbol.type.getAssociatedContainerType() : null;

            if (associatedContainerType) {
                return associatedContainerType !== typeSymbol.getRootSymbol();
            }

            return true;
        };

        PullTypeResolver.prototype.typeCheckBase = function (classOrInterface, name, typeSymbol, baseDeclAST, isExtendedType, enclosingDecl, context) {
            var _this = this;
            var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);

            var baseType = this.resolveTypeReference(baseDeclAST, context).type;

            if (!baseType) {
                return;
            }

            var typeDeclIsClass = typeSymbol.isClass();

            if (!typeSymbol.isValidBaseKind(baseType, isExtendedType)) {
                if (!baseType.isError()) {
                    if (isExtendedType) {
                        if (typeDeclIsClass) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.A_class_may_only_extend_another_class));
                        } else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.An_interface_may_only_extend_a_class_or_another_interface));
                        }
                    } else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.A_class_may_only_implement_another_class_or_interface));
                    }
                }
                return;
            } else if (typeDeclIsClass && isExtendedType) {
                if (this.hasClassTypeSymbolConflictAsValue(baseDeclAST, baseType, enclosingDecl, context)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, TypeScript.DiagnosticCode.Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_1, [TypeScript.ASTHelpers.getNameOfIdenfierOrQualifiedName(baseDeclAST.kind() == 126 /* GenericType */ ? baseDeclAST.name : baseDeclAST), baseType.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                }
            }

            if (baseType.hasBase(typeSymbol)) {
                typeSymbol.setHasBaseTypeConflict();
                baseType.setHasBaseTypeConflict();

                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode.Type_0_recursively_references_itself_as_a_base_type, [typeSymbol.getScopedName()]));
                return;
            }

            if (isExtendedType) {
                this.typeCheckCallBacks.push(function (context) {
                    return _this.typeCheckIfTypeExtendsType(classOrInterface, name, typeSymbol, baseType, enclosingDecl, context);
                });
            } else {
                TypeScript.Debug.assert(classOrInterface.kind() === 132 /* ClassDeclaration */);

                this.typeCheckCallBacks.push(function (context) {
                    return _this.typeCheckIfClassImplementsType(classOrInterface, typeSymbol, baseType, enclosingDecl, context);
                });
            }

            this.checkSymbolPrivacy(typeSymbol, baseType, function (errorSymbol) {
                return _this.baseListPrivacyErrorReporter(classOrInterface, typeSymbol, baseDeclAST, isExtendedType, errorSymbol, context);
            });
        };

        PullTypeResolver.prototype.typeCheckBases = function (classOrInterface, name, heritageClauses, typeSymbol, enclosingDecl, context) {
            var _this = this;
            var extendsClause = TypeScript.ASTHelpers.getExtendsHeritageClause(heritageClauses);
            var implementsClause = TypeScript.ASTHelpers.getImplementsHeritageClause(heritageClauses);
            if (!extendsClause && !implementsClause) {
                return;
            }

            if (extendsClause) {
                for (var i = 0; i < extendsClause.typeNames.length; i++) {
                    this.typeCheckBase(classOrInterface, name, typeSymbol, extendsClause.typeNames[i], true, enclosingDecl, context);
                }
            }

            if (typeSymbol.isClass()) {
                if (implementsClause) {
                    for (var i = 0; i < implementsClause.typeNames.length; i++) {
                        this.typeCheckBase(classOrInterface, name, typeSymbol, implementsClause.typeNames[i], false, enclosingDecl, context);
                    }
                }
            } else if (extendsClause && !typeSymbol.hasBaseTypeConflict() && typeSymbol.getExtendedTypes().length > 1) {
                var firstInterfaceASTWithExtendsClause = TypeScript.ArrayUtilities.firstOrDefault(typeSymbol.getDeclarations(), function (decl) {
                    return decl.ast().heritageClauses !== null;
                }).ast();
                if (classOrInterface === firstInterfaceASTWithExtendsClause) {
                    this.typeCheckCallBacks.push(function (context) {
                        _this.checkTypeCompatibilityBetweenBases(classOrInterface.identifier, typeSymbol, context);
                    });
                }
            }
        };

        PullTypeResolver.prototype.checkTypeCompatibilityBetweenBases = function (name, typeSymbol, context) {
            var derivedIndexSignatures = typeSymbol.getOwnIndexSignatures();

            var inheritedMembersMap = TypeScript.createIntrinsicsObject();
            var inheritedIndexSignatures = new InheritedIndexSignatureInfo();

            var typeHasOwnNumberIndexer = false;
            var typeHasOwnStringIndexer = false;

            if (typeSymbol.hasOwnIndexSignatures()) {
                var ownIndexSignatures = typeSymbol.getOwnIndexSignatures();
                for (var i = 0; i < ownIndexSignatures.length; i++) {
                    if (ownIndexSignatures[i].parameters[0].type === this.semanticInfoChain.numberTypeSymbol) {
                        typeHasOwnNumberIndexer = true;
                    } else {
                        typeHasOwnStringIndexer = true;
                    }
                }
            }
            var baseTypes = typeSymbol.getExtendedTypes();
            for (var i = 0; i < baseTypes.length; i++) {
                if (this.checkNamedPropertyIdentityBetweenBases(name, typeSymbol, baseTypes[i], inheritedMembersMap, context) || this.checkIndexSignatureIdentityBetweenBases(name, typeSymbol, baseTypes[i], inheritedIndexSignatures, typeHasOwnNumberIndexer, typeHasOwnStringIndexer, context)) {
                    return;
                }
            }

            if (this.checkThatInheritedNumberSignatureIsSubtypeOfInheritedStringSignature(name, typeSymbol, inheritedIndexSignatures, context)) {
                return;
            }

            this.checkInheritedMembersAgainstInheritedIndexSignatures(name, typeSymbol, inheritedIndexSignatures, inheritedMembersMap, context);
        };

        PullTypeResolver.prototype.checkNamedPropertyIdentityBetweenBases = function (interfaceName, interfaceSymbol, baseTypeSymbol, inheritedMembersMap, context) {
            var baseMembers = baseTypeSymbol.getAllMembers(4096 /* Property */ | 65536 /* Method */, 0 /* all */);
            for (var i = 0; i < baseMembers.length; i++) {
                var member = baseMembers[i];
                var memberName = member.name;

                if (interfaceSymbol.findMember(memberName, false)) {
                    continue;
                }

                this.resolveDeclaredSymbol(member, context);

                if (inheritedMembersMap[memberName]) {
                    var prevMember = inheritedMembersMap[memberName];
                    if (prevMember.baseOrigin !== baseTypeSymbol && !this.propertiesAreIdenticalWithNewEnclosingTypes(baseTypeSymbol, prevMember.baseOrigin, member, prevMember.memberSymbol, context)) {
                        var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Named_properties_0_of_types_1_and_2_are_not_identical, [memberName, prevMember.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(), prevMember.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                        return true;
                    }
                } else {
                    inheritedMembersMap[memberName] = new MemberWithBaseOrigin(member, baseTypeSymbol);
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkIndexSignatureIdentityBetweenBases = function (interfaceName, interfaceSymbol, baseTypeSymbol, allInheritedSignatures, derivedTypeHasOwnNumberSignature, derivedTypeHasOwnStringSignature, context) {
            if (derivedTypeHasOwnNumberSignature && derivedTypeHasOwnStringSignature) {
                return false;
            }

            var indexSignaturesFromThisBaseType = baseTypeSymbol.getIndexSignatures();
            for (var i = 0; i < indexSignaturesFromThisBaseType.length; i++) {
                var currentInheritedSignature = indexSignaturesFromThisBaseType[i];

                var parameterTypeIsString = currentInheritedSignature.parameters[0].type === this.semanticInfoChain.stringTypeSymbol;
                var parameterTypeIsNumber = currentInheritedSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol;

                if (parameterTypeIsString && derivedTypeHasOwnStringSignature || parameterTypeIsNumber && derivedTypeHasOwnNumberSignature) {
                    continue;
                }

                if (parameterTypeIsString) {
                    if (allInheritedSignatures.stringSignatureWithBaseOrigin) {
                        if (allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin !== baseTypeSymbol && !this.typesAreIdentical(allInheritedSignatures.stringSignatureWithBaseOrigin.signature.returnType, currentInheritedSignature.returnType, context)) {
                            var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_string_indexer_of_types_0_and_1_are_not_identical, [allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(), allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                            return true;
                        }
                    } else {
                        allInheritedSignatures.stringSignatureWithBaseOrigin = new SignatureWithBaseOrigin(currentInheritedSignature, baseTypeSymbol);
                    }
                } else if (parameterTypeIsNumber) {
                    if (allInheritedSignatures.numberSignatureWithBaseOrigin) {
                        if (allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin !== baseTypeSymbol && !this.typesAreIdentical(allInheritedSignatures.numberSignatureWithBaseOrigin.signature.returnType, currentInheritedSignature.returnType, context)) {
                            var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_number_indexer_of_types_0_and_1_are_not_identical, [allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(), allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                            return true;
                        }
                    } else {
                        allInheritedSignatures.numberSignatureWithBaseOrigin = new SignatureWithBaseOrigin(currentInheritedSignature, baseTypeSymbol);
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkInheritedMembersAgainstInheritedIndexSignatures = function (interfaceName, interfaceSymbol, inheritedIndexSignatures, inheritedMembers, context) {
            if (!inheritedIndexSignatures.stringSignatureWithBaseOrigin && !inheritedIndexSignatures.numberSignatureWithBaseOrigin) {
                return false;
            }

            var comparisonInfo = new TypeComparisonInfo();
            var stringSignature = inheritedIndexSignatures.stringSignatureWithBaseOrigin && inheritedIndexSignatures.stringSignatureWithBaseOrigin.signature;
            var numberSignature = inheritedIndexSignatures.numberSignatureWithBaseOrigin && inheritedIndexSignatures.numberSignatureWithBaseOrigin.signature;
            for (var memberName in inheritedMembers) {
                var memberWithBaseOrigin = inheritedMembers[memberName];
                if (!memberWithBaseOrigin) {
                    continue;
                }

                var relevantSignature = this.determineRelevantIndexerForMember(memberWithBaseOrigin.memberSymbol, numberSignature, stringSignature);
                if (!relevantSignature) {
                    continue;
                }

                var relevantSignatureIsNumberSignature = relevantSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol;
                var signatureBaseOrigin = relevantSignatureIsNumberSignature ? inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin : inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin;

                if (signatureBaseOrigin === memberWithBaseOrigin.baseOrigin) {
                    continue;
                }

                var memberIsSubtype = this.sourceIsAssignableToTarget(memberWithBaseOrigin.memberSymbol.type, relevantSignature.returnType, interfaceName, context, comparisonInfo);

                if (!memberIsSubtype) {
                    var enclosingSymbol = this.getEnclosingSymbolForAST(interfaceName);
                    if (relevantSignatureIsNumberSignature) {
                        var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_property_0_in_type_1_is_not_assignable_to_number_indexer_type_in_type_2_NL_3, [memberName, memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);

                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(enclosingSymbol), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    } else {
                        var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_property_0_in_type_1_is_not_assignable_to_string_indexer_type_in_type_2_NL_3, [memberName, memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);

                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [interfaceSymbol.getDisplayName(enclosingSymbol), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    }
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkThatInheritedNumberSignatureIsSubtypeOfInheritedStringSignature = function (interfaceName, interfaceSymbol, inheritedIndexSignatures, context) {
            if (inheritedIndexSignatures.numberSignatureWithBaseOrigin && inheritedIndexSignatures.stringSignatureWithBaseOrigin) {
                if (inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin === inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin) {
                    return false;
                }

                var comparisonInfo = new TypeComparisonInfo();
                var signatureIsSubtype = this.sourceIsAssignableToTarget(inheritedIndexSignatures.numberSignatureWithBaseOrigin.signature.returnType, inheritedIndexSignatures.stringSignatureWithBaseOrigin.signature.returnType, interfaceName, context, comparisonInfo);

                if (!signatureIsSubtype) {
                    var enclosingSymbol = this.getEnclosingSymbolForAST(interfaceName);
                    var innerDiagnostic = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_number_indexer_in_type_0_is_not_assignable_to_string_indexer_type_in_type_1_NL_2, [
                        inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol),
                        inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3, [
                        interfaceSymbol.getDisplayName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(),
                        inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkAssignability = function (ast, source, target, context) {
            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.sourceIsAssignableToTarget(source, target, ast, context, comparisonInfo);

            if (!isAssignable) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfo.message]));
                } else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Type_0_is_not_assignable_to_type_1, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]));
                }
            }
        };

        PullTypeResolver.prototype.isReference = function (ast, astSymbol) {
            if (ast.kind() === 218 /* ParenthesizedExpression */) {
                return this.isReference(ast.expression, astSymbol);
            }

            if (ast.kind() !== 11 /* IdentifierName */ && ast.kind() !== 213 /* MemberAccessExpression */ && ast.kind() !== 222 /* ElementAccessExpression */) {
                return false;
            }

            if (ast.kind() === 11 /* IdentifierName */) {
                if (astSymbol.kind === 512 /* Variable */ && astSymbol.anyDeclHasFlag(4096 /* Enum */)) {
                    return false;
                }

                if (astSymbol.kind === 512 /* Variable */ && astSymbol.anyDeclHasFlag(102400 /* SomeInitializedModule */)) {
                    return false;
                }

                if (astSymbol.kind === 32768 /* ConstructorMethod */ || astSymbol.kind === 16384 /* Function */) {
                    return false;
                }
            }

            if (ast.kind() === 213 /* MemberAccessExpression */ && astSymbol.kind === 67108864 /* EnumMember */) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.checkForSuperMemberAccess = function (expression, name, resolvedName, context) {
            if (resolvedName) {
                if (expression.kind() === 50 /* SuperKeyword */ && !resolvedName.isError() && resolvedName.kind !== 65536 /* Method */) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode.Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword));
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.getEnclosingDeclForAST = function (ast) {
            return this.semanticInfoChain.getEnclosingDecl(ast);
        };

        PullTypeResolver.prototype.getEnclosingSymbolForAST = function (ast) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            return enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;
        };

        PullTypeResolver.prototype.checkForPrivateMemberAccess = function (name, expressionType, resolvedName, context) {
            if (resolvedName) {
                if (resolvedName.anyDeclHasFlag(2 /* Private */)) {
                    var memberContainer = resolvedName.getContainer();
                    if (memberContainer && memberContainer.kind === 33554432 /* ConstructorType */) {
                        memberContainer = memberContainer.getAssociatedContainerType();
                    }

                    if (memberContainer && memberContainer.isClass()) {
                        var memberClass = memberContainer.getDeclarations()[0].ast();
                        TypeScript.Debug.assert(memberClass);

                        var containingClass = this.getEnclosingClassDeclaration(name);

                        if (!containingClass || containingClass !== memberClass) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, TypeScript.DiagnosticCode._0_1_is_inaccessible, [memberContainer.toString(null, false), name.text()]));
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.instantiateType = function (type, typeParameterArgumentMap) {
            if (type.isPrimitive()) {
                return type;
            }

            if (type.isError()) {
                return type;
            }

            if (typeParameterArgumentMap[type.pullSymbolID]) {
                return typeParameterArgumentMap[type.pullSymbolID];
            }

            type._resolveDeclaredSymbol();

            if (type.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                return TypeScript.InstantiatedTypeReferenceSymbol.create(this, type, typeParameterArgumentMap);
            }

            return type;
        };

        PullTypeResolver.prototype.instantiateSignature = function (signature, typeParameterSubstitutionMap) {
            return this.getOrCreateSignatureWithSubstitutionOrInstantiation(signature, typeParameterSubstitutionMap, true);
        };

        PullTypeResolver.prototype.getOrCreateSignatureWithSubstitution = function (signature, typeParameterSubstitutionMap) {
            return this.getOrCreateSignatureWithSubstitutionOrInstantiation(signature, typeParameterSubstitutionMap, false);
        };

        PullTypeResolver.prototype.getOrCreateSignatureWithSubstitutionOrInstantiation = function (signature, typeParameterSubstitutionMap, isInstantiation) {
            if (!signature.wrapsSomeTypeParameter(typeParameterSubstitutionMap)) {
                return signature;
            }

            var rootSignature = signature.getRootSymbol();
            var mutableTypeParameterMap = new TypeScript.PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(typeParameterSubstitutionMap);
            TypeScript.PullInstantiationHelpers.instantiateTypeArgument(this, signature, mutableTypeParameterMap);

            var instantiatedSignatureOrSignatureWithSubstitution = rootSignature.getSpecialization(mutableTypeParameterMap.typeParameterSubstitutionMap);
            if (instantiatedSignatureOrSignatureWithSubstitution) {
                var symbolFromCacheIsInstantiatedSignature = instantiatedSignatureOrSignatureWithSubstitution.getIsInstantiated();
                TypeScript.Debug.assert(symbolFromCacheIsInstantiatedSignature === isInstantiation);
                return instantiatedSignatureOrSignatureWithSubstitution;
            }

            TypeScript.PullInstantiationHelpers.cleanUpTypeParameterSubstitutionMap(signature, mutableTypeParameterMap);
            typeParameterSubstitutionMap = mutableTypeParameterMap.typeParameterSubstitutionMap;

            instantiatedSignatureOrSignatureWithSubstitution = isInstantiation ? new TypeScript.InstantiatedSignatureSymbol(rootSignature, typeParameterSubstitutionMap) : new TypeScript.SignatureSymbolWithSubstitution(rootSignature, typeParameterSubstitutionMap);

            instantiatedSignatureOrSignatureWithSubstitution.returnType = this.instantiateType((rootSignature.returnType || this.semanticInfoChain.anyTypeSymbol), typeParameterSubstitutionMap);
            instantiatedSignatureOrSignatureWithSubstitution.functionType = this.instantiateType(rootSignature.functionType, typeParameterSubstitutionMap);

            var parameters = rootSignature.parameters;
            var parameter = null;

            if (parameters) {
                for (var j = 0; j < parameters.length; j++) {
                    parameter = new TypeScript.PullSymbol(parameters[j].name, 2048 /* Parameter */, this.semanticInfoChain);
                    parameter.setRootSymbol(parameters[j]);

                    if (parameters[j].isOptional) {
                        parameter.isOptional = true;
                    }
                    if (parameters[j].isVarArg) {
                        parameter.isVarArg = true;
                        instantiatedSignatureOrSignatureWithSubstitution.hasVarArgs = true;
                    }
                    instantiatedSignatureOrSignatureWithSubstitution.addParameter(parameter, parameter.isOptional);

                    parameter.type = this.instantiateType(parameters[j].type, typeParameterSubstitutionMap);
                }
            }

            return instantiatedSignatureOrSignatureWithSubstitution;
        };

        PullTypeResolver.prototype.checkFunctionOverloadChains = function (parent, moduleElements) {
            var decl = this.getEnclosingDeclForAST(parent);
            if (!TypeScript.hasFlag(decl.flags, 8 /* Ambient */)) {
                var inFunctionOverloadChain = false;
                var functionOverloadChainName = null;

                for (var i = 0, n = moduleElements.length; i < n; i++) {
                    var moduleElement = moduleElements[i];
                    var lastElement = i === (n - 1);

                    if (inFunctionOverloadChain) {
                        if (moduleElement.kind() !== 130 /* FunctionDeclaration */) {
                            this.semanticInfoChain.addDiagnosticFromAST(TypeScript.firstToken(moduleElement), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return;
                        }

                        var functionDeclaration = moduleElement;
                        if (TypeScript.tokenValueText(functionDeclaration.identifier) !== functionOverloadChainName) {
                            this.semanticInfoChain.addDiagnosticFromAST(functionDeclaration.identifier, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return;
                        }
                    }

                    if (moduleElement.kind() === 130 /* FunctionDeclaration */) {
                        functionDeclaration = moduleElement;
                        if (!TypeScript.SyntaxUtilities.containsToken(functionDeclaration.modifiers, 63 /* DeclareKeyword */)) {
                            inFunctionOverloadChain = functionDeclaration.block === null;
                            functionOverloadChainName = TypeScript.tokenValueText(functionDeclaration.identifier);

                            if (inFunctionOverloadChain) {
                                if (lastElement) {
                                    this.semanticInfoChain.addDiagnosticFromAST(TypeScript.firstToken(moduleElement), TypeScript.DiagnosticCode.Function_implementation_expected);
                                    return;
                                } else {
                                    var nextElement = TypeScript.childAt(moduleElements, i + 1);
                                    if (nextElement.kind() === 130 /* FunctionDeclaration */) {
                                        var nextFunction = nextElement;

                                        if (TypeScript.tokenValueText(nextFunction.identifier) !== functionOverloadChainName && nextFunction.block === null) {
                                            this.semanticInfoChain.addDiagnosticFromAST(functionDeclaration.identifier, TypeScript.DiagnosticCode.Function_implementation_expected);
                                            return;
                                        }
                                    }
                                }
                            }
                        } else {
                            inFunctionOverloadChain = false;
                            functionOverloadChainName = "";
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.checkClassOverloadChains = function (node) {
            var decl = this.getEnclosingDeclForAST(node);
            if (!TypeScript.hasFlag(decl.flags, 8 /* Ambient */) && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                var inFunctionOverloadChain = false;
                var inConstructorOverloadChain = false;

                var functionOverloadChainName = null;
                var isInStaticOverloadChain = null;
                var memberFunctionDeclaration = null;

                for (var i = 0, n = node.classElements.length; i < n; i++) {
                    var classElement = node.classElements[i];
                    var lastElement = i === (n - 1);
                    var isStaticOverload = null;

                    if (inFunctionOverloadChain) {
                        if (classElement.kind() !== 136 /* MemberFunctionDeclaration */) {
                            this.semanticInfoChain.addDiagnosticFromAST(TypeScript.firstToken(classElement), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return;
                        }

                        memberFunctionDeclaration = classElement;
                        if (TypeScript.tokenValueText(memberFunctionDeclaration.propertyName) !== functionOverloadChainName) {
                            this.semanticInfoChain.addDiagnosticFromAST(memberFunctionDeclaration.propertyName, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return;
                        }

                        isStaticOverload = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, 58 /* StaticKeyword */);
                        if (isStaticOverload !== isInStaticOverloadChain) {
                            var diagnostic = isInStaticOverloadChain ? TypeScript.DiagnosticCode.Function_overload_must_be_static : TypeScript.DiagnosticCode.Function_overload_must_not_be_static;
                            this.semanticInfoChain.addDiagnosticFromAST(memberFunctionDeclaration.propertyName, diagnostic);
                            return;
                        }
                    } else if (inConstructorOverloadChain) {
                        if (classElement.kind() !== 138 /* ConstructorDeclaration */) {
                            this.semanticInfoChain.addDiagnosticFromAST(TypeScript.firstToken(classElement), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return;
                        }
                    }

                    if (classElement.kind() === 136 /* MemberFunctionDeclaration */) {
                        memberFunctionDeclaration = classElement;

                        inFunctionOverloadChain = memberFunctionDeclaration.block === null;
                        functionOverloadChainName = TypeScript.tokenValueText(memberFunctionDeclaration.propertyName);
                        isInStaticOverloadChain = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, 58 /* StaticKeyword */);

                        if (inFunctionOverloadChain) {
                            if (lastElement) {
                                this.semanticInfoChain.addDiagnosticFromAST(TypeScript.firstToken(classElement), TypeScript.DiagnosticCode.Function_implementation_expected);
                                return;
                            } else {
                                var nextElement = TypeScript.childAt(node.classElements, i + 1);
                                if (nextElement.kind() === 136 /* MemberFunctionDeclaration */) {
                                    var nextMemberFunction = nextElement;

                                    if (TypeScript.tokenValueText(nextMemberFunction.propertyName) !== functionOverloadChainName && nextMemberFunction.block === null) {
                                        this.semanticInfoChain.addDiagnosticFromAST(memberFunctionDeclaration.propertyName, TypeScript.DiagnosticCode.Function_implementation_expected);
                                        return;
                                    }
                                }
                            }
                        }
                    } else if (classElement.kind() === 138 /* ConstructorDeclaration */) {
                        var constructorDeclaration = classElement;

                        inConstructorOverloadChain = constructorDeclaration.block === null;
                        if (lastElement && inConstructorOverloadChain) {
                            this.semanticInfoChain.addDiagnosticFromAST(TypeScript.firstToken(classElement), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return;
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.checkForReservedName = function (parent, name, diagnosticKey) {
            switch (TypeScript.tokenValueText(name)) {
                case "any":
                case "number":
                case "boolean":
                case "string":
                case "void":
                    this.semanticInfoChain.addDiagnosticFromAST(name, diagnosticKey, [TypeScript.tokenValueText(name)]);
            }
        };

        PullTypeResolver.prototype.checkForMultipleExportAssignments = function (moduleElements) {
            var seenExportAssignment = false;
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var child = moduleElements[i];
                if (child.kind() === 135 /* ExportAssignment */) {
                    if (seenExportAssignment) {
                        this.semanticInfoChain.addDiagnosticFromAST(child, TypeScript.DiagnosticCode.A_module_cannot_have_multiple_export_assignments);
                    }
                    seenExportAssignment = true;
                }
            }
        };

        PullTypeResolver.prototype.checkForDisallowedExports = function (moduleElements) {
            var seenExportedElement = false;
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var child = moduleElements[i];

                if (TypeScript.SyntaxUtilities.hasExportKeyword(child)) {
                    seenExportedElement = true;
                    break;
                }
            }

            if (seenExportedElement) {
                for (var i = 0, n = moduleElements.length; i < n; i++) {
                    var child = moduleElements[i];

                    if (child.kind() === 135 /* ExportAssignment */) {
                        this.semanticInfoChain.addDiagnosticFromAST(child, TypeScript.DiagnosticCode.Export_assignment_not_allowed_in_module_with_exported_element);
                        return;
                    }
                }
            }
        };
        PullTypeResolver.globalTypeCheckPhase = 0;
        return PullTypeResolver;
    })();
    TypeScript.PullTypeResolver = PullTypeResolver;

    var TypeComparisonInfo = (function () {
        function TypeComparisonInfo(sourceComparisonInfo, useSameIndent) {
            this.onlyCaptureFirstError = false;
            this.message = "";
            this.stringConstantVal = null;
            this.indent = 1;
            if (sourceComparisonInfo) {
                this.onlyCaptureFirstError = sourceComparisonInfo.onlyCaptureFirstError;
                this.stringConstantVal = sourceComparisonInfo.stringConstantVal;
                this.indent = sourceComparisonInfo.indent;
                if (!useSameIndent) {
                    this.indent++;
                }
            }
        }
        TypeComparisonInfo.prototype.indentString = function () {
            var result = "";

            for (var i = 0; i < this.indent; i++) {
                result += "\t";
            }

            return result;
        };

        TypeComparisonInfo.prototype.addMessage = function (message) {
            if (!this.onlyCaptureFirstError && this.message) {
                this.message = this.message + TypeScript.newLine() + this.indentString() + message;
            } else {
                this.message = this.indentString() + message;
            }
        };
        return TypeComparisonInfo;
    })();
    TypeScript.TypeComparisonInfo = TypeComparisonInfo;

    function getPropertyAssignmentNameTextFromIdentifier(identifier) {
        if (identifier.kind() === 11 /* IdentifierName */) {
            return { actualText: identifier.text(), memberName: TypeScript.tokenValueText(identifier) };
        } else if (identifier.kind() === 14 /* StringLiteral */) {
            return { actualText: identifier.text(), memberName: TypeScript.tokenValueText(identifier) };
        } else if (identifier.kind() === 13 /* NumericLiteral */) {
            return { actualText: identifier.text(), memberName: TypeScript.tokenValueText(identifier) };
        } else {
            throw TypeScript.Errors.invalidOperation();
        }
    }
    TypeScript.getPropertyAssignmentNameTextFromIdentifier = getPropertyAssignmentNameTextFromIdentifier;

    function isTypesOnlyLocation(ast) {
        while (ast && ast.parent) {
            switch (ast.parent.kind()) {
                case 245 /* TypeAnnotation */:
                    return true;
                case 127 /* TypeQuery */:
                    return false;
                case 125 /* ConstructorType */:
                    var constructorType = ast.parent;
                    if (constructorType.type === ast) {
                        return true;
                    }
                    break;
                case 123 /* FunctionType */:
                    var functionType = ast.parent;
                    if (functionType.type === ast) {
                        return true;
                    }
                    break;
                case 240 /* Constraint */:
                    var constraint = ast.parent;
                    if (constraint.typeOrExpression === ast) {
                        return true;
                    }
                    break;
                case 221 /* CastExpression */:
                    var castExpression = ast.parent;
                    return castExpression.type === ast;
                case 231 /* ExtendsHeritageClause */:
                case 232 /* ImplementsHeritageClause */:
                    return true;
                case 229 /* TypeArgumentList */:
                    return true;
                case 132 /* ClassDeclaration */:
                case 129 /* InterfaceDeclaration */:
                case 131 /* ModuleDeclaration */:
                case 130 /* FunctionDeclaration */:
                case 146 /* MethodSignature */:
                case 213 /* MemberAccessExpression */:
                case 243 /* Parameter */:
                    return false;
            }

            ast = ast.parent;
        }

        return false;
    }
    TypeScript.isTypesOnlyLocation = isTypesOnlyLocation;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.declCacheHit = 0;
    TypeScript.declCacheMiss = 0;
    TypeScript.symbolCacheHit = 0;
    TypeScript.symbolCacheMiss = 0;

    var sentinalEmptyArray = [];

    var SemanticInfoChain = (function () {
        function SemanticInfoChain(compiler, logger) {
            this.compiler = compiler;
            this.logger = logger;
            this.documents = [];
            this.fileNameToDocument = TypeScript.createIntrinsicsObject();
            this.anyTypeDecl = null;
            this.booleanTypeDecl = null;
            this.numberTypeDecl = null;
            this.stringTypeDecl = null;
            this.nullTypeDecl = null;
            this.undefinedTypeDecl = null;
            this.voidTypeDecl = null;
            this.undefinedValueDecl = null;
            this.anyTypeSymbol = null;
            this.booleanTypeSymbol = null;
            this.numberTypeSymbol = null;
            this.stringTypeSymbol = null;
            this.nullTypeSymbol = null;
            this.undefinedTypeSymbol = null;
            this.voidTypeSymbol = null;
            this.undefinedValueSymbol = null;
            this.emptyTypeSymbol = null;
            this.astSymbolMap = [];
            this.astAliasSymbolMap = [];
            this.astCallResolutionDataMap = [];
            this.declSymbolMap = [];
            this.declSignatureSymbolMap = [];
            this.declCache = null;
            this.symbolCache = null;
            this.fileNameToDiagnostics = null;
            this._binder = null;
            this._resolver = null;
            this._topLevelDecls = null;
            this._fileNames = null;
            var globalDecl = new TypeScript.RootPullDecl(SemanticInfoChain.EmptyASTToDeclMap, "", "", 0 /* Global */, 0 /* None */, false);
            this.documents[0] = new TypeScript.Document(this.compiler.compilationSettings(), "", [], null, 0 /* None */, 0, false, null, globalDecl);

            this.anyTypeDecl = new TypeScript.NormalPullDecl("any", "any", 2 /* Primitive */, 0 /* None */, globalDecl);
            this.booleanTypeDecl = new TypeScript.NormalPullDecl("boolean", "boolean", 2 /* Primitive */, 0 /* None */, globalDecl);
            this.numberTypeDecl = new TypeScript.NormalPullDecl("number", "number", 2 /* Primitive */, 0 /* None */, globalDecl);
            this.stringTypeDecl = new TypeScript.NormalPullDecl("string", "string", 2 /* Primitive */, 0 /* None */, globalDecl);
            this.voidTypeDecl = new TypeScript.NormalPullDecl("void", "void", 2 /* Primitive */, 0 /* None */, globalDecl);

            this.nullTypeDecl = new TypeScript.RootPullDecl(SemanticInfoChain.EmptyASTToDeclMap, "null", "", 2 /* Primitive */, 0 /* None */, false);
            this.undefinedTypeDecl = new TypeScript.RootPullDecl(SemanticInfoChain.EmptyASTToDeclMap, "undefined", "", 2 /* Primitive */, 0 /* None */, false);
            this.undefinedValueDecl = new TypeScript.NormalPullDecl("undefined", "undefined", 512 /* Variable */, 8 /* Ambient */, globalDecl);

            this.invalidate();
        }
        SemanticInfoChain.prototype.getDocument = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = this.fileNameToDocument[fileName];
            return document || null;
        };

        SemanticInfoChain.prototype.lineMap = function (fileName) {
            return this.getDocument(fileName).lineMap();
        };

        SemanticInfoChain.prototype.fileNames = function () {
            if (this._fileNames === null) {
                this._fileNames = this.documents.slice(1).map(function (s) {
                    return s.fileName;
                });
            }

            return this._fileNames;
        };

        SemanticInfoChain.prototype.bindPrimitiveSymbol = function (decl, newSymbol) {
            newSymbol.addDeclaration(decl);
            this.setSymbolForDecl(decl, newSymbol);
            newSymbol.setResolved();

            return newSymbol;
        };

        SemanticInfoChain.prototype.addPrimitiveTypeSymbol = function (decl) {
            var newSymbol = new TypeScript.PullPrimitiveTypeSymbol(decl.name, this);
            return this.bindPrimitiveSymbol(decl, newSymbol);
        };

        SemanticInfoChain.prototype.addPrimitiveValueSymbol = function (decl, type) {
            var newSymbol = new TypeScript.PullSymbol(decl.name, 512 /* Variable */, this);
            newSymbol.type = type;
            return this.bindPrimitiveSymbol(decl, newSymbol);
        };

        SemanticInfoChain.prototype.resetGlobalSymbols = function () {
            this.anyTypeSymbol = this.addPrimitiveTypeSymbol(this.anyTypeDecl);
            this.booleanTypeSymbol = this.addPrimitiveTypeSymbol(this.booleanTypeDecl);
            this.numberTypeSymbol = this.addPrimitiveTypeSymbol(this.numberTypeDecl);
            this.stringTypeSymbol = this.addPrimitiveTypeSymbol(this.stringTypeDecl);
            this.voidTypeSymbol = this.addPrimitiveTypeSymbol(this.voidTypeDecl);
            this.nullTypeSymbol = this.addPrimitiveTypeSymbol(this.nullTypeDecl);
            this.undefinedTypeSymbol = this.addPrimitiveTypeSymbol(this.undefinedTypeDecl);
            this.undefinedValueSymbol = this.addPrimitiveValueSymbol(this.undefinedValueDecl, this.undefinedTypeSymbol);

            var emptyTypeDecl = new TypeScript.PullSynthesizedDecl("{}", "{}", 8388608 /* ObjectType */, 0 /* None */, null);
            var emptyTypeSymbol = new TypeScript.PullTypeSymbol("{}", 8388608 /* ObjectType */, this);
            this.setSymbolForDecl(emptyTypeDecl, emptyTypeSymbol);
            emptyTypeSymbol.addDeclaration(emptyTypeDecl);
            emptyTypeSymbol.setResolved();
            this.emptyTypeSymbol = emptyTypeSymbol;
        };

        SemanticInfoChain.prototype.addDocument = function (document) {
            var fileName = document.fileName;
            fileName = TypeScript.switchToForwardSlashes(fileName);

            var existingIndex = TypeScript.ArrayUtilities.indexOf(this.documents, function (u) {
                return u.fileName === fileName;
            });
            if (existingIndex < 0) {
                this.documents.push(document);
            } else {
                this.documents[existingIndex] = document;
            }

            this.fileNameToDocument[fileName] = document;

            this.invalidate();
        };

        SemanticInfoChain.prototype.removeDocument = function (fileName) {
            TypeScript.Debug.assert(fileName !== "", "Can't remove the semantic info for the global decl.");
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var index = TypeScript.ArrayUtilities.indexOf(this.documents, function (u) {
                return u.fileName === fileName;
            });
            if (index > 0) {
                this.fileNameToDocument[fileName] = undefined;
                this.documents.splice(index, 1);
                this.invalidate();
            }
        };

        SemanticInfoChain.prototype.getDeclPathCacheID = function (declPath, declKind) {
            var cacheID = "";

            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }

            return cacheID + "#" + declKind.toString();
        };

        SemanticInfoChain.prototype.findTopLevelSymbol = function (name, kind, doNotGoPastThisDecl) {
            var cacheID = this.getDeclPathCacheID([name], kind);

            var symbol = this.symbolCache[cacheID];

            if (!symbol) {
                for (var i = 0, n = this.documents.length; i < n; i++) {
                    var topLevelDecl = this.documents[i].topLevelDecl();

                    var symbol = this.findTopLevelSymbolInDecl(topLevelDecl, name, kind, doNotGoPastThisDecl);
                    if (symbol) {
                        break;
                    }

                    if (doNotGoPastThisDecl && topLevelDecl.name === doNotGoPastThisDecl.fileName()) {
                        return null;
                    }
                }

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                }
            }

            return symbol;
        };

        SemanticInfoChain.prototype.findTopLevelSymbolInDecl = function (topLevelDecl, name, kind, doNotGoPastThisDecl) {
            var _syntaxTree = TypeScript.syntaxTree(topLevelDecl.ast());
            var doNotGoPastThisPosition = doNotGoPastThisDecl && doNotGoPastThisDecl.fileName() === topLevelDecl.fileName() ? TypeScript.start(doNotGoPastThisDecl.ast(), _syntaxTree.text) : -1;

            var foundDecls = topLevelDecl.searchChildDecls(name, kind);

            for (var j = 0; j < foundDecls.length; j++) {
                var foundDecl = foundDecls[j];

                if (doNotGoPastThisPosition !== -1 && foundDecl.ast() && TypeScript.start(foundDecl.ast(), _syntaxTree.text) > doNotGoPastThisPosition) {
                    break;
                }

                var symbol = foundDecls[j].getSymbol(this);
                if (symbol) {
                    return symbol;
                }
            }

            return null;
        };

        SemanticInfoChain.prototype.findExternalModule = function (id) {
            id = TypeScript.normalizePath(id);

            var tsFile = id + ".ts";
            var tsCacheID = this.getDeclPathCacheID([tsFile], 32 /* DynamicModule */);
            symbol = this.symbolCache[tsCacheID];
            if (symbol != undefined) {
                return symbol;
            }

            var dtsFile = id + ".d.ts";
            var dtsCacheID = this.getDeclPathCacheID([dtsFile], 32 /* DynamicModule */);
            var symbol = this.symbolCache[dtsCacheID];
            if (symbol) {
                return symbol;
            }

            var dtsSymbol;
            for (var i = 0; i < this.documents.length; i++) {
                var document = this.documents[i];
                var topLevelDecl = document.topLevelDecl();

                if (topLevelDecl.isExternalModule()) {
                    var isTsFile = document.fileName === tsFile;
                    if (isTsFile || document.fileName === dtsFile) {
                        var dynamicModuleDecl = topLevelDecl.getChildDecls()[0];
                        symbol = dynamicModuleDecl.getSymbol(this);

                        if (isTsFile) {
                            this.symbolCache[tsCacheID] = symbol;

                            return symbol;
                        } else {
                            dtsSymbol = symbol;
                        }
                    }
                }
            }

            if (dtsSymbol) {
                this.symbolCache[dtsCacheID] = symbol;
                return dtsSymbol;
            }

            this.symbolCache[dtsCacheID] = null;
            this.symbolCache[tsCacheID] = null;

            return null;
        };

        SemanticInfoChain.prototype.findAmbientExternalModuleInGlobalContext = function (id) {
            var cacheID = this.getDeclPathCacheID([id], 32 /* DynamicModule */);

            var symbol = this.symbolCache[cacheID];
            if (symbol == undefined) {
                symbol = null;
                for (var i = 0; i < this.documents.length; i++) {
                    var document = this.documents[i];
                    var topLevelDecl = document.topLevelDecl();

                    if (!topLevelDecl.isExternalModule()) {
                        var dynamicModules = topLevelDecl.searchChildDecls(id, 32 /* DynamicModule */);
                        if (dynamicModules.length) {
                            symbol = dynamicModules[0].getSymbol(this);
                            break;
                        }
                    }
                }

                this.symbolCache[cacheID] = symbol;
            }

            return symbol;
        };

        SemanticInfoChain.prototype.findDecls = function (declPath, declKind) {
            var cacheID = this.getDeclPathCacheID(declPath, declKind);

            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];

                if (cachedDecls && cachedDecls.length) {
                    TypeScript.declCacheHit++;
                    return cachedDecls;
                }
            }

            TypeScript.declCacheMiss++;

            var declsToSearch = this.topLevelDecls();

            var decls = TypeScript.sentinelEmptyArray;
            var path;
            var foundDecls = TypeScript.sentinelEmptyArray;

            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = TypeScript.sentinelEmptyArray;

                var kind = (i === declPath.length - 1) ? declKind : 164 /* SomeContainer */;
                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].searchChildDecls(path, kind);

                    for (var k = 0; k < foundDecls.length; k++) {
                        if (decls === TypeScript.sentinelEmptyArray) {
                            decls = [];
                        }
                        decls[decls.length] = foundDecls[k];
                    }
                }

                declsToSearch = decls;

                if (!declsToSearch) {
                    break;
                }
            }

            if (decls.length) {
                this.declCache[cacheID] = decls;
            }

            return decls;
        };

        SemanticInfoChain.prototype.findDeclsFromPath = function (declPath, declKind) {
            var declString = [];

            for (var i = 0, n = declPath.length; i < n; i++) {
                if (declPath[i].kind & 1 /* Script */) {
                    continue;
                }

                declString.push(declPath[i].name);
            }

            return this.findDecls(declString, declKind);
        };

        SemanticInfoChain.prototype.findSymbol = function (declPath, declType) {
            var cacheID = this.getDeclPathCacheID(declPath, declType);

            if (declPath.length) {
                var cachedSymbol = this.symbolCache[cacheID];

                if (cachedSymbol) {
                    TypeScript.symbolCacheHit++;
                    return cachedSymbol;
                }
            }

            TypeScript.symbolCacheMiss++;

            var decls = this.findDecls(declPath, declType);
            var symbol = null;

            if (decls.length) {
                var decl = decls[0];
                if (TypeScript.hasFlag(decl.kind, 164 /* SomeContainer */)) {
                    var valueDecl = decl.getValueDecl();
                    if (valueDecl) {
                        valueDecl.ensureSymbolIsBound(this);
                    }
                }
                symbol = decl.getSymbol(this);

                if (symbol) {
                    for (var i = 1; i < decls.length; i++) {
                        decls[i].ensureSymbolIsBound(this);
                    }

                    this.symbolCache[cacheID] = symbol;
                }
            }

            return symbol;
        };

        SemanticInfoChain.prototype.cacheGlobalSymbol = function (symbol, kind) {
            var cacheID1 = this.getDeclPathCacheID([symbol.name], kind);
            var cacheID2 = this.getDeclPathCacheID([symbol.name], symbol.kind);

            if (!this.symbolCache[cacheID1]) {
                this.symbolCache[cacheID1] = symbol;
            }

            if (!this.symbolCache[cacheID2]) {
                this.symbolCache[cacheID2] = symbol;
            }
        };

        SemanticInfoChain.prototype.invalidate = function (oldSettings, newSettings) {
            if (typeof oldSettings === "undefined") { oldSettings = null; }
            if (typeof newSettings === "undefined") { newSettings = null; }
            TypeScript.PullTypeResolver.globalTypeCheckPhase++;

            var cleanStart = new Date().getTime();

            this.astSymbolMap.length = 0;
            this.astAliasSymbolMap.length = 0;
            this.astCallResolutionDataMap.length = 0;

            this.declCache = TypeScript.createIntrinsicsObject();
            this.symbolCache = TypeScript.createIntrinsicsObject();
            this.fileNameToDiagnostics = TypeScript.createIntrinsicsObject();
            this._binder = null;
            this._resolver = null;
            this._topLevelDecls = null;
            this._fileNames = null;

            this.declSymbolMap.length = 0;
            this.declSignatureSymbolMap.length = 0;

            TypeScript.pullSymbolID = 0;

            this.resetGlobalSymbols();

            var cleanEnd = new Date().getTime();
        };

        SemanticInfoChain.prototype.setSymbolForAST = function (ast, symbol) {
            TypeScript.Debug.assert(!TypeScript.isShared(ast));
            this.astSymbolMap[TypeScript.syntaxID(ast)] = symbol;
        };

        SemanticInfoChain.prototype.getSymbolForAST = function (ast) {
            return this.astSymbolMap[TypeScript.syntaxID(ast)] || null;
        };

        SemanticInfoChain.prototype.setAliasSymbolForAST = function (ast, symbol) {
            TypeScript.Debug.assert(!TypeScript.isShared(ast));
            this.astAliasSymbolMap[TypeScript.syntaxID(ast)] = symbol;
        };

        SemanticInfoChain.prototype.getAliasSymbolForAST = function (ast) {
            return TypeScript.isShared(ast) ? null : this.astAliasSymbolMap[TypeScript.syntaxID(ast)];
        };

        SemanticInfoChain.prototype.getCallResolutionDataForAST = function (ast) {
            return TypeScript.isShared(ast) ? null : this.astCallResolutionDataMap[TypeScript.syntaxID(ast)];
        };

        SemanticInfoChain.prototype.setCallResolutionDataForAST = function (ast, callResolutionData) {
            TypeScript.Debug.assert(!TypeScript.isShared(ast));
            if (callResolutionData) {
                this.astCallResolutionDataMap[TypeScript.syntaxID(ast)] = callResolutionData;
            }
        };

        SemanticInfoChain.prototype.setSymbolForDecl = function (decl, symbol) {
            this.declSymbolMap[decl.declID] = symbol;
        };

        SemanticInfoChain.prototype.getSymbolForDecl = function (decl) {
            return this.declSymbolMap[decl.declID];
        };

        SemanticInfoChain.prototype.setSignatureSymbolForDecl = function (decl, signatureSymbol) {
            this.declSignatureSymbolMap[decl.declID] = signatureSymbol;
        };

        SemanticInfoChain.prototype.getSignatureSymbolForDecl = function (decl) {
            return this.declSignatureSymbolMap[decl.declID];
        };

        SemanticInfoChain.prototype.addDiagnostic = function (diagnostic) {
            var fileName = diagnostic.fileName();
            var diagnostics = this.fileNameToDiagnostics[fileName];
            if (!diagnostics) {
                diagnostics = [];
                this.fileNameToDiagnostics[fileName] = diagnostics;
            }

            diagnostics.push(diagnostic);
        };

        SemanticInfoChain.prototype.getDiagnostics = function (fileName) {
            var diagnostics = this.fileNameToDiagnostics[fileName];
            return diagnostics || [];
        };

        SemanticInfoChain.prototype.getBinder = function () {
            if (!this._binder) {
                this._binder = new TypeScript.PullSymbolBinder(this);
            }

            return this._binder;
        };

        SemanticInfoChain.prototype.getResolver = function () {
            if (!this._resolver) {
                this._resolver = new TypeScript.PullTypeResolver(this.compiler.compilationSettings(), this);
            }

            return this._resolver;
        };

        SemanticInfoChain.prototype.addSyntheticIndexSignature = function (containingDecl, containingSymbol, ast, indexParamName, indexParamType, returnType) {
            var indexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */, this);
            var indexParameterSymbol = new TypeScript.PullSymbol(indexParamName, 2048 /* Parameter */, this);
            indexParameterSymbol.type = indexParamType;
            indexSignature.addParameter(indexParameterSymbol);
            indexSignature.returnType = returnType;
            indexSignature.setResolved();
            indexParameterSymbol.setResolved();

            containingSymbol.addIndexSignature(indexSignature);

            var indexSigDecl = new TypeScript.PullSynthesizedDecl("", "", 4194304 /* IndexSignature */, 2048 /* Signature */, containingDecl);
            var indexParamDecl = new TypeScript.PullSynthesizedDecl(indexParamName, indexParamName, 2048 /* Parameter */, 0 /* None */, indexSigDecl);
            indexSigDecl.setSignatureSymbol(indexSignature, this);
            this.setSymbolForDecl(indexParamDecl, indexParameterSymbol);
            indexSignature.addDeclaration(indexSigDecl);
            indexParameterSymbol.addDeclaration(indexParamDecl);
        };

        SemanticInfoChain.prototype.getDeclForAST = function (ast) {
            var document = this.getDocument(TypeScript.syntaxTree(ast).fileName());

            if (document) {
                return document._getDeclForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.getEnclosingDecl = function (ast) {
            return this.getDocument(TypeScript.syntaxTree(ast).fileName()).getEnclosingDecl(ast);
        };

        SemanticInfoChain.prototype.setDeclForAST = function (ast, decl) {
            this.getDocument(decl.fileName())._setDeclForAST(ast, decl);
        };

        SemanticInfoChain.prototype.getASTForDecl = function (decl) {
            var document = this.getDocument(decl.fileName());
            if (document) {
                return document._getASTForDecl(decl);
            }

            return null;
        };

        SemanticInfoChain.prototype.setASTForDecl = function (decl, ast) {
            this.getDocument(decl.fileName())._setASTForDecl(decl, ast);
        };

        SemanticInfoChain.prototype.topLevelDecl = function (fileName) {
            var document = this.getDocument(fileName);
            if (document) {
                return document.topLevelDecl();
            }

            return null;
        };

        SemanticInfoChain.prototype.topLevelDecls = function () {
            if (!this._topLevelDecls) {
                this._topLevelDecls = TypeScript.ArrayUtilities.select(this.documents, function (u) {
                    return u.topLevelDecl();
                });
            }

            return this._topLevelDecls;
        };

        SemanticInfoChain.prototype.addDiagnosticFromAST = function (ast, diagnosticKey, _arguments) {
            if (typeof _arguments === "undefined") { _arguments = null; }
            this.addDiagnostic(this.diagnosticFromAST(ast, diagnosticKey, _arguments));
        };

        SemanticInfoChain.prototype.diagnosticFromAST = function (ast, diagnosticKey, _arguments) {
            if (typeof _arguments === "undefined") { _arguments = null; }
            var syntaxTree = TypeScript.syntaxTree(ast);
            return new TypeScript.Diagnostic(syntaxTree.fileName(), syntaxTree.lineMap(), TypeScript.start(ast, syntaxTree.text), TypeScript.width(ast, syntaxTree.text), diagnosticKey, _arguments);
        };

        SemanticInfoChain.prototype.diagnosticFromDecl = function (decl, diagnosticKey, _arguments) {
            if (typeof _arguments === "undefined") { _arguments = null; }
            return this.diagnosticFromAST(decl.ast(), diagnosticKey, _arguments);
        };

        SemanticInfoChain.prototype.locationFromAST = function (ast) {
            var syntaxTree = TypeScript.syntaxTree(ast);
            return new TypeScript.Location(syntaxTree.fileName(), syntaxTree.lineMap(), TypeScript.start(ast, syntaxTree.text), TypeScript.width(ast, syntaxTree.text));
        };

        SemanticInfoChain.prototype.duplicateIdentifierDiagnosticFromAST = function (ast, identifier) {
            return this.diagnosticFromAST(ast, TypeScript.DiagnosticCode.Duplicate_identifier_0, [identifier]);
        };

        SemanticInfoChain.prototype.addDuplicateIdentifierDiagnosticFromAST = function (ast, identifier) {
            this.addDiagnostic(this.duplicateIdentifierDiagnosticFromAST(ast, identifier));
        };
        SemanticInfoChain.EmptyASTToDeclMap = {
            _getASTForDecl: function (decl) {
                return null;
            }
        };
        return SemanticInfoChain;
    })();
    TypeScript.SemanticInfoChain = SemanticInfoChain;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclCollectionContext = (function () {
        function DeclCollectionContext(document, propagateEnumConstants) {
            this.document = document;
            this.propagateEnumConstants = propagateEnumConstants;
            this.isDeclareFile = false;
            this.parentChain = [];
        }
        DeclCollectionContext.prototype.getParent = function () {
            return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
        };

        DeclCollectionContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
            }
        };

        DeclCollectionContext.prototype.popParent = function () {
            this.parentChain.length--;
        };

        DeclCollectionContext.prototype.setDeclForAST = function (ast, decl) {
            TypeScript.Debug.assert(decl.fileName() === this.document.fileName);
            this.document._setDeclForAST(ast, decl);
        };

        DeclCollectionContext.prototype.setASTForDecl = function (decl, ast) {
            TypeScript.Debug.assert(decl.fileName() === this.document.fileName);
            this.document._setASTForDecl(decl, ast);
        };
        return DeclCollectionContext;
    })();

    function moduleElementsHasExportAssignment(moduleElements) {
        for (var i = 0, n = moduleElements.length; i < n; i++) {
            if (moduleElements[i].kind() === 135 /* ExportAssignment */) {
                return true;
            }
        }

        return false;
    }

    function containingModuleHasExportAssignment(ast) {
        ast = ast.parent;
        while (ast) {
            if (ast.kind() === 131 /* ModuleDeclaration */) {
                var moduleDecl = ast;
                return moduleElementsHasExportAssignment(moduleDecl.moduleElements);
            } else if (ast.kind() === 120 /* SourceUnit */) {
                var sourceUnit = ast;
                return moduleElementsHasExportAssignment(sourceUnit.moduleElements);
            }

            ast = ast.parent;
        }

        return false;
    }

    function isParsingAmbientModule(ast, context) {
        ast = ast.parent;
        while (ast) {
            if (ast.kind() === 131 /* ModuleDeclaration */) {
                if (TypeScript.hasModifier(ast.modifiers, 8 /* Ambient */)) {
                    return true;
                }
            }

            ast = ast.parent;
        }

        return false;
    }

    function preCollectImportDecls(ast, context) {
        var importDecl = ast;
        var declFlags = 0 /* None */;

        var parent = context.getParent();

        if (TypeScript.hasModifier(importDecl.modifiers, 1 /* Exported */) && !containingModuleHasExportAssignment(ast)) {
            declFlags |= 1 /* Exported */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(importDecl.identifier), importDecl.identifier.text(), 128 /* TypeAlias */, declFlags, parent);
        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);
    }

    function preCollectScriptDecls(sourceUnit, context) {
        var fileName = TypeScript.syntaxTree(sourceUnit).fileName();

        var isExternalModule = context.document.syntaxTree().isExternalModule();

        var decl = new TypeScript.RootPullDecl(context.document, fileName, fileName, 1 /* Script */, 0 /* None */, isExternalModule);
        context.setDeclForAST(sourceUnit, decl);
        context.setASTForDecl(decl, sourceUnit);

        context.isDeclareFile = context.document.isDeclareFile();

        context.pushParent(decl);

        if (isExternalModule) {
            var declFlags = 1 /* Exported */;
            if (TypeScript.isDTSFile(fileName)) {
                declFlags |= 8 /* Ambient */;
            }

            var moduleContainsExecutableCode = containsExecutableCode(sourceUnit.moduleElements);
            var kind = 32 /* DynamicModule */;
            var valueText = TypeScript.quoteStr(fileName);

            var decl = new TypeScript.NormalPullDecl(valueText, fileName, kind, declFlags, context.getParent());

            context.setASTForDecl(decl, sourceUnit);

            context.setDeclForAST(sourceUnit, decl);

            if (!moduleElementsHasExportAssignment(sourceUnit.moduleElements) || moduleContainsExecutableCode) {
                createModuleVariableDecl(decl, sourceUnit, context);
            }

            context.pushParent(decl);
        }
    }

    function preCollectEnumDecls(enumDecl, context) {
        var declFlags = 0 /* None */;
        var enumName = TypeScript.tokenValueText(enumDecl.identifier);

        if ((TypeScript.hasModifier(enumDecl.modifiers, 1 /* Exported */) || isParsingAmbientModule(enumDecl, context)) && !containingModuleHasExportAssignment(enumDecl)) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasModifier(enumDecl.modifiers, 8 /* Ambient */) || isParsingAmbientModule(enumDecl, context) || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        declFlags |= 4096 /* Enum */;
        var kind = 64 /* Enum */;

        var enumDeclaration = new TypeScript.NormalPullDecl(enumName, enumDecl.identifier.text(), kind, declFlags, context.getParent());
        context.setDeclForAST(enumDecl, enumDeclaration);
        context.setASTForDecl(enumDeclaration, enumDecl);

        var valueDecl = new TypeScript.NormalPullDecl(enumDeclaration.name, enumDeclaration.getDisplayName(), 512 /* Variable */, enumDeclaration.flags, context.getParent());
        enumDeclaration.setValueDecl(valueDecl);
        context.setASTForDecl(valueDecl, enumDecl);

        context.pushParent(enumDeclaration);
    }

    function createEnumElementDecls(propertyDecl, context) {
        var parent = context.getParent();

        var decl = new TypeScript.PullEnumElementDecl(TypeScript.tokenValueText(propertyDecl.propertyName), propertyDecl.propertyName.text(), parent);
        context.setDeclForAST(propertyDecl, decl);
        context.setASTForDecl(decl, propertyDecl);
    }

    function preCollectModuleDecls(moduleDecl, context) {
        var declFlags = 0 /* None */;

        var moduleContainsExecutableCode = containsExecutableCode(moduleDecl.moduleElements);

        var isDynamic = moduleDecl.stringLiteral !== null;

        if ((TypeScript.hasModifier(moduleDecl.modifiers, 1 /* Exported */) || isParsingAmbientModule(moduleDecl, context)) && !containingModuleHasExportAssignment(moduleDecl)) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasModifier(moduleDecl.modifiers, 8 /* Ambient */) || isParsingAmbientModule(moduleDecl, context) || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        var kind = isDynamic ? 32 /* DynamicModule */ : 4 /* Container */;

        if (moduleDecl.stringLiteral) {
            var valueText = TypeScript.quoteStr(TypeScript.tokenValueText(moduleDecl.stringLiteral));
            var text = moduleDecl.stringLiteral.text();

            var decl = new TypeScript.NormalPullDecl(valueText, text, kind, declFlags, context.getParent());

            context.setDeclForAST(moduleDecl, decl);
            context.setDeclForAST(moduleDecl.stringLiteral, decl);
            context.setASTForDecl(decl, moduleDecl.stringLiteral);

            if (!moduleElementsHasExportAssignment(moduleDecl.moduleElements) || moduleContainsExecutableCode) {
                createModuleVariableDecl(decl, moduleDecl.stringLiteral, context);
            }

            context.pushParent(decl);
        } else {
            var moduleNames = TypeScript.ASTHelpers.getModuleNames(moduleDecl.name);
            for (var i = 0, n = moduleNames.length; i < n; i++) {
                var moduleName = moduleNames[i];

                var specificFlags = declFlags;
                if (i > 0) {
                    specificFlags |= 1 /* Exported */;
                }

                var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(moduleName), moduleName.text(), kind, specificFlags, context.getParent());

                context.setDeclForAST(moduleDecl, decl);
                context.setDeclForAST(moduleName, decl);
                context.setASTForDecl(decl, moduleName);

                if (moduleContainsExecutableCode) {
                    createModuleVariableDecl(decl, moduleName, context);
                }

                context.pushParent(decl);
            }
        }
    }

    function createModuleVariableDecl(decl, moduleNameAST, context) {
        decl.setFlags(decl.flags | getInitializationFlag(decl));

        var valueDecl = new TypeScript.NormalPullDecl(decl.name, decl.getDisplayName(), 512 /* Variable */, decl.flags, context.getParent());
        decl.setValueDecl(valueDecl);
        context.setASTForDecl(valueDecl, moduleNameAST);
    }

    function containsExecutableCode(members) {
        for (var i = 0, n = members.length; i < n; i++) {
            var member = members[i];

            if (member.kind() === 131 /* ModuleDeclaration */) {
                var moduleDecl = member;

                if (containsExecutableCode(moduleDecl.moduleElements)) {
                    return true;
                }
            } else if (member.kind() === 134 /* ImportDeclaration */) {
                if (TypeScript.hasModifier(member.modifiers, 1 /* Exported */)) {
                    return true;
                }
            } else if (member.kind() !== 129 /* InterfaceDeclaration */ && member.kind() !== 135 /* ExportAssignment */) {
                return true;
            }
        }

        return false;
    }

    function preCollectClassDecls(classDecl, context) {
        var declFlags = 0 /* None */;

        if ((TypeScript.hasModifier(classDecl.modifiers, 1 /* Exported */) || isParsingAmbientModule(classDecl, context)) && !containingModuleHasExportAssignment(classDecl)) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasModifier(classDecl.modifiers, 8 /* Ambient */) || isParsingAmbientModule(classDecl, context) || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        var parent = context.getParent();

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(classDecl.identifier), classDecl.identifier.text(), 8 /* Class */, declFlags, parent);

        var constructorDecl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(classDecl.identifier), classDecl.identifier.text(), 512 /* Variable */, declFlags | 16384 /* ClassConstructorVariable */, parent);

        decl.setValueDecl(constructorDecl);

        context.setDeclForAST(classDecl, decl);
        context.setASTForDecl(decl, classDecl);
        context.setASTForDecl(constructorDecl, classDecl);

        context.pushParent(decl);
    }

    function preCollectObjectTypeDecls(objectType, context) {
        if (objectType.parent.kind() === 129 /* InterfaceDeclaration */) {
            return;
        }

        var declFlags = 0 /* None */;

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl("", "", 8388608 /* ObjectType */, declFlags, parent);
        context.setDeclForAST(objectType, decl);
        context.setASTForDecl(decl, objectType);

        context.pushParent(decl);
    }

    function preCollectInterfaceDecls(interfaceDecl, context) {
        var declFlags = 0 /* None */;

        if ((TypeScript.hasModifier(interfaceDecl.modifiers, 1 /* Exported */) || isParsingAmbientModule(interfaceDecl, context)) && !containingModuleHasExportAssignment(interfaceDecl)) {
            declFlags |= 1 /* Exported */;
        }

        var parent = context.getParent();

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(interfaceDecl.identifier), interfaceDecl.identifier.text(), 16 /* Interface */, declFlags, parent);
        context.setDeclForAST(interfaceDecl, decl);
        context.setASTForDecl(decl, interfaceDecl);

        context.pushParent(decl);
    }

    function preCollectParameterDecl(argDecl, context) {
        var declFlags = 0 /* None */;

        if (TypeScript.hasModifier(argDecl.modifiers, 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (argDecl.questionToken !== null || argDecl.equalsValueClause !== null || argDecl.dotDotDotToken !== null) {
            declFlags |= 128 /* Optional */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(argDecl.identifier), argDecl.identifier.text(), 2048 /* Parameter */, declFlags, parent);

        if (argDecl.equalsValueClause) {
            parent.flags |= 33554432 /* HasDefaultArgs */;
        }

        if (parent.kind === 32768 /* ConstructorMethod */) {
            decl.setFlag(67108864 /* ConstructorParameter */);
        }

        var isPublicOrPrivate = TypeScript.hasModifier(argDecl.modifiers, 4 /* Public */) || TypeScript.hasModifier(argDecl.modifiers, 2 /* Private */);
        var isInConstructor = parent.kind === 32768 /* ConstructorMethod */;
        if (isPublicOrPrivate && isInConstructor) {
            var parentsParent = context.parentChain[context.parentChain.length - 2];

            var propDeclFlags = declFlags & ~128 /* Optional */;
            var propDecl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(argDecl.identifier), argDecl.identifier.text(), 4096 /* Property */, propDeclFlags, parentsParent);
            propDecl.setValueDecl(decl);
            decl.setFlag(8388608 /* PropertyParameter */);
            propDecl.setFlag(8388608 /* PropertyParameter */);

            if (parent.kind === 32768 /* ConstructorMethod */) {
                propDecl.setFlag(67108864 /* ConstructorParameter */);
            }

            context.setASTForDecl(decl, argDecl);
            context.setASTForDecl(propDecl, argDecl);
            context.setDeclForAST(argDecl, propDecl);
        } else {
            context.setASTForDecl(decl, argDecl);
            context.setDeclForAST(argDecl, decl);
        }

        parent.addVariableDeclToGroup(decl);
    }

    function preCollectTypeParameterDecl(typeParameterDecl, context) {
        var declFlags = 0 /* None */;

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(typeParameterDecl.identifier), typeParameterDecl.identifier.text(), 8192 /* TypeParameter */, declFlags, parent);
        context.setASTForDecl(decl, typeParameterDecl);
        context.setDeclForAST(typeParameterDecl, decl);
    }

    function createPropertySignature(propertyDecl, context) {
        var declFlags = 4 /* Public */;
        var parent = context.getParent();
        var declType = 4096 /* Property */;

        if (propertyDecl.questionToken !== null) {
            declFlags |= 128 /* Optional */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(propertyDecl.propertyName), propertyDecl.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(propertyDecl, decl);
        context.setASTForDecl(decl, propertyDecl);
    }

    function createMemberVariableDeclaration(memberDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 4096 /* Property */;

        if (TypeScript.hasModifier(memberDecl.modifiers, 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (TypeScript.hasModifier(memberDecl.modifiers, 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        var parent = context.getParent();

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(memberDecl.variableDeclarator.propertyName), memberDecl.variableDeclarator.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(memberDecl, decl);
        context.setDeclForAST(memberDecl.variableDeclarator, decl);
        context.setASTForDecl(decl, memberDecl);
    }

    function createVariableDeclaration(varDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 512 /* Variable */;

        var modifiers = TypeScript.ASTHelpers.getVariableDeclaratorModifiers(varDecl);
        if ((TypeScript.hasModifier(modifiers, 1 /* Exported */) || isParsingAmbientModule(varDecl, context)) && !containingModuleHasExportAssignment(varDecl)) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasModifier(modifiers, 8 /* Ambient */) || isParsingAmbientModule(varDecl, context) || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(varDecl.propertyName), varDecl.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(varDecl, decl);
        context.setASTForDecl(decl, varDecl);

        if (parent) {
            parent.addVariableDeclToGroup(decl);
        }
    }

    function preCollectVarDecls(ast, context) {
        if (ast.parent.kind() === 137 /* MemberVariableDeclaration */) {
            return;
        }

        var varDecl = ast;
        createVariableDeclaration(varDecl, context);
    }

    function createFunctionTypeDeclaration(functionTypeDeclAST, context) {
        var declFlags = 2048 /* Signature */;
        var declType = 16777216 /* FunctionType */;

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(functionTypeDeclAST, decl);
        context.setASTForDecl(decl, functionTypeDeclAST);

        context.pushParent(decl);
    }

    function createConstructorTypeDeclaration(constructorTypeDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 33554432 /* ConstructorType */;

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(constructorTypeDeclAST, decl);
        context.setASTForDecl(decl, constructorTypeDeclAST);

        context.pushParent(decl);
    }

    function createFunctionDeclaration(funcDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 16384 /* Function */;

        if ((TypeScript.hasModifier(funcDeclAST.modifiers, 1 /* Exported */) || isParsingAmbientModule(funcDeclAST, context)) && !containingModuleHasExportAssignment(funcDeclAST)) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasModifier(funcDeclAST.modifiers, 8 /* Ambient */) || isParsingAmbientModule(funcDeclAST, context) || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        if (!funcDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(funcDeclAST.identifier), funcDeclAST.identifier.text(), declType, declFlags, parent);
        context.setDeclForAST(funcDeclAST, decl);
        context.setASTForDecl(decl, funcDeclAST);

        context.pushParent(decl);
    }

    function createAnyFunctionExpressionDeclaration(functionExpressionDeclAST, id, context, displayName) {
        if (typeof displayName === "undefined") { displayName = null; }
        var declFlags = 0 /* None */;

        if (functionExpressionDeclAST.kind() === 220 /* SimpleArrowFunctionExpression */ || functionExpressionDeclAST.kind() === 219 /* ParenthesizedArrowFunctionExpression */) {
            declFlags |= 8192 /* ArrowFunction */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var name = id ? id.text() : "";
        var displayNameText = displayName ? displayName.text() : "";
        var decl = new TypeScript.PullFunctionExpressionDecl(name, declFlags, parent, displayNameText);
        context.setDeclForAST(functionExpressionDeclAST, decl);
        context.setASTForDecl(decl, functionExpressionDeclAST);

        context.pushParent(decl);
    }

    function createMemberFunctionDeclaration(funcDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 65536 /* Method */;

        if (TypeScript.hasModifier(funcDecl.modifiers, 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasModifier(funcDecl.modifiers, 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (!funcDecl.block) {
            declFlags |= 2048 /* Signature */;
        }

        var parent = context.getParent();

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(funcDecl.propertyName), funcDecl.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(funcDecl, decl);
        context.setASTForDecl(decl, funcDecl);

        context.pushParent(decl);
    }

    function createIndexSignatureDeclaration(indexSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */;
        var declType = 4194304 /* IndexSignature */;

        var parent = context.getParent();

        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(indexSignatureDeclAST, decl);
        context.setASTForDecl(decl, indexSignatureDeclAST);

        context.pushParent(decl);
    }

    function createCallSignatureDeclaration(callSignature, context) {
        var isChildOfObjectType = callSignature.parent && callSignature.parent.parent && callSignature.parent.kind() === 2 /* SeparatedList */ && callSignature.parent.parent.kind() === 122 /* ObjectType */;

        if (!isChildOfObjectType) {
            return;
        }

        var declFlags = 2048 /* Signature */;
        var declType = 1048576 /* CallSignature */;

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(callSignature, decl);
        context.setASTForDecl(decl, callSignature);

        context.pushParent(decl);
    }

    function createMethodSignatureDeclaration(method, context) {
        var declFlags = 0 /* None */;
        var declType = 65536 /* Method */;

        declFlags |= 4 /* Public */;
        declFlags |= 2048 /* Signature */;

        if (method.questionToken !== null) {
            declFlags |= 128 /* Optional */;
        }

        var parent = context.getParent();

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(method.propertyName), method.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(method, decl);
        context.setASTForDecl(decl, method);

        context.pushParent(decl);
    }

    function createConstructSignatureDeclaration(constructSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */;
        var declType = 2097152 /* ConstructSignature */;

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(constructSignatureDeclAST, decl);
        context.setASTForDecl(decl, constructSignatureDeclAST);

        context.pushParent(decl);
    }

    function createClassConstructorDeclaration(constructorDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 32768 /* ConstructorMethod */;

        if (!constructorDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var parent = context.getParent();

        if (parent) {
            var parentFlags = parent.flags;

            if (parentFlags & 1 /* Exported */) {
                declFlags |= 1 /* Exported */;
            }
        }

        var decl = new TypeScript.NormalPullDecl(parent.name, parent.getDisplayName(), declType, declFlags, parent);
        context.setDeclForAST(constructorDeclAST, decl);
        context.setASTForDecl(decl, constructorDeclAST);

        context.pushParent(decl);
    }

    function createGetAccessorDeclaration(getAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 262144 /* GetAccessor */;

        if (TypeScript.hasModifier(getAccessorDeclAST.modifiers, 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasModifier(getAccessorDeclAST.modifiers, 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(getAccessorDeclAST.propertyName), getAccessorDeclAST.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(getAccessorDeclAST, decl);
        context.setASTForDecl(decl, getAccessorDeclAST);

        context.pushParent(decl);
    }

    function createFunctionExpressionDeclaration(expression, context) {
        createAnyFunctionExpressionDeclaration(expression, expression.identifier, context);
    }

    function createSetAccessorDeclaration(setAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 524288 /* SetAccessor */;

        if (TypeScript.hasModifier(setAccessorDeclAST.modifiers, 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasModifier(setAccessorDeclAST.modifiers, 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(setAccessorDeclAST.propertyName), setAccessorDeclAST.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(setAccessorDeclAST, decl);
        context.setASTForDecl(decl, setAccessorDeclAST);

        context.pushParent(decl);
    }

    function preCollectCatchDecls(ast, context) {
        var declFlags = 0 /* None */;
        var declType = 268435456 /* CatchBlock */;

        var parent = context.getParent();

        if (parent && (parent.kind === 134217728 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);

        context.pushParent(decl);

        var declFlags = 0 /* None */;
        var declType = 1024 /* CatchVariable */;

        var parent = context.getParent();

        if (TypeScript.hasFlag(parent.flags, 2097152 /* DeclaredInAWithBlock */)) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.NormalPullDecl(TypeScript.tokenValueText(ast.identifier), ast.identifier.text(), declType, declFlags, parent);
        context.setDeclForAST(ast.identifier, decl);
        context.setASTForDecl(decl, ast.identifier);

        if (parent) {
            parent.addVariableDeclToGroup(decl);
        }
    }

    function preCollectWithDecls(ast, context) {
        var declFlags = 0 /* None */;
        var declType = 134217728 /* WithBlock */;

        var parent = context.getParent();

        var decl = new TypeScript.NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);

        context.pushParent(decl);
    }

    function preCollectObjectLiteralDecls(ast, context) {
        var decl = new TypeScript.NormalPullDecl("", "", 256 /* ObjectLiteral */, 0 /* None */, context.getParent());

        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);

        context.pushParent(decl);
    }

    function preCollectSimplePropertyAssignmentDecls(propertyAssignment, context) {
        var assignmentText = TypeScript.getPropertyAssignmentNameTextFromIdentifier(propertyAssignment.propertyName);

        var decl = new TypeScript.NormalPullDecl(assignmentText.memberName, assignmentText.actualText, 4096 /* Property */, 4 /* Public */, context.getParent());

        context.setDeclForAST(propertyAssignment, decl);
        context.setASTForDecl(decl, propertyAssignment);
    }

    function preCollectFunctionPropertyAssignmentDecls(propertyAssignment, context) {
        var assignmentText = TypeScript.getPropertyAssignmentNameTextFromIdentifier(propertyAssignment.propertyName);

        var decl = new TypeScript.NormalPullDecl(assignmentText.memberName, assignmentText.actualText, 4096 /* Property */, 4 /* Public */, context.getParent());

        context.setDeclForAST(propertyAssignment, decl);
        context.setASTForDecl(decl, propertyAssignment);

        createAnyFunctionExpressionDeclaration(propertyAssignment, propertyAssignment.propertyName, context, propertyAssignment.propertyName);
    }

    function preCollectDecls(ast, context) {
        switch (ast.kind()) {
            case 120 /* SourceUnit */:
                preCollectScriptDecls(ast, context);
                break;
            case 133 /* EnumDeclaration */:
                preCollectEnumDecls(ast, context);
                break;
            case 244 /* EnumElement */:
                createEnumElementDecls(ast, context);
                break;
            case 131 /* ModuleDeclaration */:
                preCollectModuleDecls(ast, context);
                break;
            case 132 /* ClassDeclaration */:
                preCollectClassDecls(ast, context);
                break;
            case 129 /* InterfaceDeclaration */:
                preCollectInterfaceDecls(ast, context);
                break;
            case 122 /* ObjectType */:
                preCollectObjectTypeDecls(ast, context);
                break;
            case 243 /* Parameter */:
                preCollectParameterDecl(ast, context);
                break;
            case 137 /* MemberVariableDeclaration */:
                createMemberVariableDeclaration(ast, context);
                break;
            case 142 /* PropertySignature */:
                createPropertySignature(ast, context);
                break;
            case 226 /* VariableDeclarator */:
                preCollectVarDecls(ast, context);
                break;
            case 138 /* ConstructorDeclaration */:
                createClassConstructorDeclaration(ast, context);
                break;
            case 140 /* GetAccessor */:
                createGetAccessorDeclaration(ast, context);
                break;
            case 141 /* SetAccessor */:
                createSetAccessorDeclaration(ast, context);
                break;
            case 223 /* FunctionExpression */:
                createFunctionExpressionDeclaration(ast, context);
                break;
            case 136 /* MemberFunctionDeclaration */:
                createMemberFunctionDeclaration(ast, context);
                break;
            case 145 /* IndexSignature */:
                createIndexSignatureDeclaration(ast, context);
                break;
            case 123 /* FunctionType */:
                createFunctionTypeDeclaration(ast, context);
                break;
            case 125 /* ConstructorType */:
                createConstructorTypeDeclaration(ast, context);
                break;
            case 143 /* CallSignature */:
                createCallSignatureDeclaration(ast, context);
                break;
            case 144 /* ConstructSignature */:
                createConstructSignatureDeclaration(ast, context);
                break;
            case 146 /* MethodSignature */:
                createMethodSignatureDeclaration(ast, context);
                break;
            case 130 /* FunctionDeclaration */:
                createFunctionDeclaration(ast, context);
                break;
            case 220 /* SimpleArrowFunctionExpression */:
            case 219 /* ParenthesizedArrowFunctionExpression */:
                createAnyFunctionExpressionDeclaration(ast, null, context);
                break;
            case 134 /* ImportDeclaration */:
                preCollectImportDecls(ast, context);
                break;
            case 239 /* TypeParameter */:
                preCollectTypeParameterDecl(ast, context);
                break;
            case 237 /* CatchClause */:
                preCollectCatchDecls(ast, context);
                break;
            case 164 /* WithStatement */:
                preCollectWithDecls(ast, context);
                break;
            case 216 /* ObjectLiteralExpression */:
                preCollectObjectLiteralDecls(ast, context);
                break;
            case 241 /* SimplePropertyAssignment */:
                preCollectSimplePropertyAssignmentDecls(ast, context);
                break;
            case 242 /* FunctionPropertyAssignment */:
                preCollectFunctionPropertyAssignmentDecls(ast, context);
                break;
        }
    }

    function isContainer(decl) {
        return decl.kind === 4 /* Container */ || decl.kind === 32 /* DynamicModule */ || decl.kind === 64 /* Enum */;
    }

    function getInitializationFlag(decl) {
        if (decl.kind & 4 /* Container */) {
            return 32768 /* InitializedModule */;
        } else if (decl.kind & 32 /* DynamicModule */) {
            return 65536 /* InitializedDynamicModule */;
        }

        return 0 /* None */;
    }

    function hasInitializationFlag(decl) {
        var kind = decl.kind;

        if (kind & 4 /* Container */) {
            return (decl.flags & 32768 /* InitializedModule */) !== 0;
        } else if (kind & 32 /* DynamicModule */) {
            return (decl.flags & 65536 /* InitializedDynamicModule */) !== 0;
        }

        return false;
    }

    function postCollectDecls(ast, context) {
        var currentDecl = context.getParent();

        if (ast.kind() === 11 /* IdentifierName */ || ast.kind() === 14 /* StringLiteral */) {
            if (currentDecl.kind === 4 /* Container */ || currentDecl.kind === 32 /* DynamicModule */) {
                return;
            }
        }

        if (ast.kind() === 131 /* ModuleDeclaration */) {
            var moduleDeclaration = ast;
            if (moduleDeclaration.stringLiteral) {
                TypeScript.Debug.assert(currentDecl.ast() === moduleDeclaration.stringLiteral);
                context.popParent();
            } else {
                var moduleNames = TypeScript.ASTHelpers.getModuleNames(moduleDeclaration.name);
                for (var i = moduleNames.length - 1; i >= 0; i--) {
                    var moduleName = moduleNames[i];
                    TypeScript.Debug.assert(currentDecl.ast() === moduleName);
                    context.popParent();
                    currentDecl = context.getParent();
                }
            }
        }

        if (ast.kind() === 133 /* EnumDeclaration */) {
            computeEnumElementConstantValues(ast, currentDecl, context);
        }

        while (currentDecl.getParentDecl() && currentDecl.ast() === ast) {
            context.popParent();
            currentDecl = context.getParent();
        }
    }

    function computeEnumElementConstantValues(ast, enumDecl, context) {
        TypeScript.Debug.assert(enumDecl.kind === 64 /* Enum */);

        var isAmbientEnum = TypeScript.hasFlag(enumDecl.flags, 8 /* Ambient */);
        var inConstantSection = !isAmbientEnum;
        var currentConstantValue = 0;
        var enumMemberDecls = enumDecl.getChildDecls();

        for (var i = 0, n = ast.enumElements.length; i < n; i++) {
            var enumElement = ast.enumElements[i];
            var enumElementDecl = TypeScript.ArrayUtilities.first(enumMemberDecls, function (d) {
                return d.ast() === enumElement;
            });

            TypeScript.Debug.assert(enumElementDecl.kind === 67108864 /* EnumMember */);

            if (enumElement.equalsValueClause === null) {
                if (inConstantSection) {
                    enumElementDecl.constantValue = currentConstantValue;
                    currentConstantValue++;
                }
            } else {
                enumElementDecl.constantValue = computeEnumElementConstantValue(enumElement.equalsValueClause.value, enumMemberDecls, context);
                if (enumElementDecl.constantValue !== null && !isAmbientEnum) {
                    inConstantSection = true;
                    currentConstantValue = enumElementDecl.constantValue + 1;
                } else {
                    inConstantSection = false;
                }
            }

            TypeScript.Debug.assert(enumElementDecl.constantValue !== undefined);
        }
    }

    function computeEnumElementConstantValue(expression, enumMemberDecls, context) {
        TypeScript.Debug.assert(expression);

        if (TypeScript.ASTHelpers.isIntegerLiteralAST(expression)) {
            var token;
            switch (expression.kind()) {
                case 165 /* PlusExpression */:
                case 166 /* NegateExpression */:
                    token = expression.operand;
                    break;
                default:
                    token = expression;
            }

            var value = TypeScript.tokenValue(token);
            return value && expression.kind() === 166 /* NegateExpression */ ? -value : value;
        } else if (context.propagateEnumConstants) {
            switch (expression.kind()) {
                case 11 /* IdentifierName */:
                    var name = expression;
                    var matchingEnumElement = TypeScript.ArrayUtilities.firstOrDefault(enumMemberDecls, function (d) {
                        return d.name === TypeScript.tokenValueText(name);
                    });

                    return matchingEnumElement ? matchingEnumElement.constantValue : null;

                case 203 /* LeftShiftExpression */:
                    var binaryExpression = expression;
                    var left = computeEnumElementConstantValue(binaryExpression.left, enumMemberDecls, context);
                    var right = computeEnumElementConstantValue(binaryExpression.right, enumMemberDecls, context);
                    if (left === null || right === null) {
                        return null;
                    }

                    return left << right;

                case 190 /* BitwiseOrExpression */:
                    var binaryExpression = expression;
                    var left = computeEnumElementConstantValue(binaryExpression.left, enumMemberDecls, context);
                    var right = computeEnumElementConstantValue(binaryExpression.right, enumMemberDecls, context);
                    if (left === null || right === null) {
                        return null;
                    }

                    return left | right;
            }

            return null;
        } else {
            return null;
        }
    }

    (function (DeclarationCreator) {
        function create(document, compilationSettings) {
            var start = new Date().getTime();
            var declCollectionContext = new DeclCollectionContext(document, compilationSettings.propagateEnumConstants());

            TypeScript.getAstWalkerFactory().simpleWalk(document.sourceUnit(), preCollectDecls, postCollectDecls, declCollectionContext);
            TypeScript.createDeclarationsTime += new Date().getTime() - start;
            return declCollectionContext.getParent();
        }
        DeclarationCreator.create = create;
    })(TypeScript.DeclarationCreator || (TypeScript.DeclarationCreator = {}));
    var DeclarationCreator = TypeScript.DeclarationCreator;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBinder = (function () {
        function PullSymbolBinder(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.declsBeingBound = [];
            this.inBindingOtherDeclsWalker = new TypeScript.PullHelpers.OtherPullDeclsWalker();
        }
        PullSymbolBinder.prototype.getParent = function (decl, returnInstanceType) {
            if (typeof returnInstanceType === "undefined") { returnInstanceType = false; }
            var parentDecl = decl.getParentDecl();

            if (parentDecl.kind === 1 /* Script */) {
                return null;
            }

            var parent = parentDecl.getSymbol(this.semanticInfoChain);

            if (!parent && parentDecl && !parentDecl.hasBeenBound(this.semanticInfoChain)) {
                this.bindDeclToPullSymbol(parentDecl);
            }

            parent = parentDecl.getSymbol(this.semanticInfoChain);
            if (parent) {
                var parentDeclKind = parentDecl.kind;
                if (parentDeclKind === 262144 /* GetAccessor */) {
                    parent = parent.getGetter();
                } else if (parentDeclKind === 524288 /* SetAccessor */) {
                    parent = parent.getSetter();
                }
            }

            if (parent) {
                if (returnInstanceType && parent.isType() && parent.isContainer()) {
                    var instanceSymbol = parent.getInstanceSymbol();

                    if (instanceSymbol) {
                        return instanceSymbol.type;
                    }
                }

                return parent.type;
            }

            return null;
        };

        PullSymbolBinder.prototype.findDeclsInContext = function (startingDecl, declKind, searchGlobally) {
            if (!searchGlobally) {
                var parentDecl = startingDecl.getParentDecl();
                return parentDecl.searchChildDecls(startingDecl.name, declKind);
            }

            var contextSymbolPath = startingDecl.getParentPath();

            if (contextSymbolPath.length) {
                var copyOfContextSymbolPath = [];

                for (var i = 0; i < contextSymbolPath.length; i++) {
                    if (contextSymbolPath[i].kind & 1 /* Script */) {
                        continue;
                    }
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i].name;
                }

                return this.semanticInfoChain.findDecls(copyOfContextSymbolPath, declKind);
            }
        };

        PullSymbolBinder.prototype.getExistingSymbol = function (decl, searchKind, parent) {
            var lookingForValue = (searchKind & 68147712 /* SomeValue */) !== 0;
            var lookingForType = (searchKind & 58728795 /* SomeType */) !== 0;
            var lookingForContainer = (searchKind & 164 /* SomeContainer */) !== 0;
            var name = decl.name;
            if (parent) {
                var isExported = (decl.flags & 1 /* Exported */) !== 0;

                var prevSymbol = null;
                if (lookingForValue) {
                    prevSymbol = parent.findContainedNonMember(name);
                } else if (lookingForType) {
                    prevSymbol = parent.findContainedNonMemberType(name, searchKind);
                } else if (lookingForContainer) {
                    prevSymbol = parent.findContainedNonMemberContainer(name, searchKind);
                }
                var prevIsExported = !prevSymbol;
                if (!prevSymbol) {
                    if (lookingForValue) {
                        prevSymbol = parent.findMember(name, false);
                    } else if (lookingForType) {
                        prevSymbol = parent.findNestedType(name, searchKind);
                    } else if (lookingForContainer) {
                        prevSymbol = parent.findNestedContainer(name, searchKind);
                    }
                }

                if (isExported && prevIsExported) {
                    return prevSymbol;
                }
                if (prevSymbol) {
                    var prevDecls = prevSymbol.getDeclarations();
                    var lastPrevDecl = prevDecls[prevDecls.length - 1];
                    var parentDecl = decl.getParentDecl();
                    var prevParentDecl = lastPrevDecl && lastPrevDecl.getParentDecl();
                    if (parentDecl !== prevParentDecl) {
                        return null;
                    }

                    return prevSymbol;
                }
            } else {
                var parentDecl = decl.getParentDecl();
                if (parentDecl && parentDecl.kind === 1 /* Script */) {
                    return this.semanticInfoChain.findTopLevelSymbol(name, searchKind, decl);
                } else {
                    var prevDecls = parentDecl && parentDecl.searchChildDecls(name, searchKind);
                    return prevDecls[0] && prevDecls[0].getSymbol(this.semanticInfoChain);
                }
            }

            return null;
        };

        PullSymbolBinder.prototype.checkThatExportsMatch = function (decl, prevSymbol, reportError) {
            if (typeof reportError === "undefined") { reportError = true; }
            var isExported = (decl.flags & 1 /* Exported */) !== 0;
            var prevDecls = prevSymbol.getDeclarations();
            var prevIsExported = (prevDecls[prevDecls.length - 1].flags & 1 /* Exported */) !== 0;
            if ((isExported !== prevIsExported) && !prevSymbol.isSignature() && (decl.kind & 7340032 /* SomeSignature */) === 0) {
                if (reportError) {
                    var ast = this.semanticInfoChain.getASTForDecl(decl);
                    this.semanticInfoChain.addDiagnosticFromAST(ast, TypeScript.DiagnosticCode.All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported, [decl.getDisplayName()]);
                }
                return false;
            }

            return true;
        };

        PullSymbolBinder.prototype.getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList = function (signature, currentSignatures) {
            var signatureDecl = signature.getDeclarations()[0];
            TypeScript.Debug.assert(signatureDecl);
            var enclosingDecl = signatureDecl.getParentDecl();
            var indexToInsert = TypeScript.ArrayUtilities.indexOf(currentSignatures, function (someSignature) {
                return someSignature.getDeclarations()[0].getParentDecl() !== enclosingDecl;
            });
            return indexToInsert < 0 ? currentSignatures.length : indexToInsert;
        };

        PullSymbolBinder.prototype.bindEnumDeclarationToPullSymbol = function (enumContainerDecl) {
            var enumName = enumContainerDecl.name;

            var enumContainerSymbol = null;
            var enumInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;

            var enumInstanceDecl = enumContainerDecl.getValueDecl();

            var enumDeclKind = enumContainerDecl.kind;

            var parent = this.getParent(enumContainerDecl);
            var parentInstanceSymbol = this.getParent(enumContainerDecl, true);
            var parentDecl = enumContainerDecl.getParentDecl();
            var enumAST = this.semanticInfoChain.getASTForDecl(enumContainerDecl);

            var isExported = enumContainerDecl.flags & 1 /* Exported */;

            var createdNewSymbol = false;

            enumContainerSymbol = this.getExistingSymbol(enumContainerDecl, 64 /* Enum */, parent);

            if (enumContainerSymbol) {
                if (enumContainerSymbol.kind !== enumDeclKind) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(enumAST.identifier, enumContainerDecl.getDisplayName());
                    enumContainerSymbol = null;
                } else if (!this.checkThatExportsMatch(enumContainerDecl, enumContainerSymbol)) {
                    enumContainerSymbol = null;
                }
            }

            if (enumContainerSymbol) {
                enumInstanceSymbol = enumContainerSymbol.getInstanceSymbol();
            } else {
                enumContainerSymbol = new TypeScript.PullContainerSymbol(enumName, enumDeclKind, this.semanticInfoChain);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(enumContainerSymbol, 64 /* Enum */);
                }
            }

            enumContainerSymbol.addDeclaration(enumContainerDecl);
            enumContainerDecl.setSymbol(enumContainerSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(enumAST.identifier, enumContainerSymbol);
            this.semanticInfoChain.setSymbolForAST(enumAST, enumContainerSymbol);

            if (!enumInstanceSymbol) {
                var variableSymbol = null;
                if (parentInstanceSymbol) {
                    if (isExported) {
                        variableSymbol = parentInstanceSymbol.findMember(enumName, false);

                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findContainedNonMember(enumName);
                        }
                    } else {
                        variableSymbol = parentInstanceSymbol.findContainedNonMember(enumName);

                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findMember(enumName, false);
                        }
                    }

                    if (variableSymbol) {
                        var declarations = variableSymbol.getDeclarations();

                        if (declarations.length) {
                            var variableSymbolParentDecl = declarations[0].getParentDecl();

                            if (parentDecl !== variableSymbolParentDecl) {
                                variableSymbol = null;
                            }
                        }
                    }
                } else if (!(enumContainerDecl.flags & 1 /* Exported */)) {
                    var siblingDecls = parentDecl.getChildDecls();
                    var augmentedDecl = null;

                    for (var i = 0; i < siblingDecls.length; i++) {
                        if (siblingDecls[i] === enumContainerDecl) {
                            break;
                        }

                        if ((siblingDecls[i].name === enumName) && (siblingDecls[i].kind & 68147712 /* SomeValue */)) {
                            augmentedDecl = siblingDecls[i];
                            break;
                        }
                    }

                    if (augmentedDecl) {
                        variableSymbol = augmentedDecl.getSymbol(this.semanticInfoChain);

                        if (variableSymbol) {
                            if (variableSymbol.isContainer()) {
                                variableSymbol = variableSymbol.getInstanceSymbol();
                            } else if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = variableSymbol.getConstructorMethod();
                            }
                        }
                    }
                }

                if (variableSymbol) {
                    enumInstanceSymbol = variableSymbol;
                    moduleInstanceTypeSymbol = variableSymbol.type;
                } else {
                    enumInstanceSymbol = new TypeScript.PullSymbol(enumName, 512 /* Variable */, this.semanticInfoChain);
                }

                enumContainerSymbol.setInstanceSymbol(enumInstanceSymbol);

                if (!moduleInstanceTypeSymbol) {
                    moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */, this.semanticInfoChain);
                    enumInstanceSymbol.type = moduleInstanceTypeSymbol;
                }

                moduleInstanceTypeSymbol.addDeclaration(enumContainerDecl);

                if (!moduleInstanceTypeSymbol.getAssociatedContainerType()) {
                    moduleInstanceTypeSymbol.setAssociatedContainerType(enumContainerSymbol);
                }
            }

            if (createdNewSymbol && parent) {
                if (enumContainerDecl.flags & 1 /* Exported */) {
                    parent.addEnclosedMemberType(enumContainerSymbol);
                } else {
                    parent.addEnclosedNonMemberType(enumContainerSymbol);
                }
            }

            if (createdNewSymbol) {
                this.bindEnumIndexerDeclsToPullSymbols(enumContainerSymbol);
            }
            var valueDecl = enumContainerDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound(this.semanticInfoChain);
            }
        };

        PullSymbolBinder.prototype.bindEnumIndexerDeclsToPullSymbols = function (enumContainerSymbol) {
            var enumContainerInstanceTypeSymbol = enumContainerSymbol.getInstanceSymbol().type;

            var syntheticIndexerParameterSymbol = new TypeScript.PullSymbol("x", 2048 /* Parameter */, this.semanticInfoChain);
            syntheticIndexerParameterSymbol.type = this.semanticInfoChain.numberTypeSymbol;
            syntheticIndexerParameterSymbol.setResolved();
            syntheticIndexerParameterSymbol.setIsSynthesized();

            var syntheticIndexerSignatureSymbol = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */, this.semanticInfoChain);
            syntheticIndexerSignatureSymbol.addParameter(syntheticIndexerParameterSymbol);
            syntheticIndexerSignatureSymbol.returnType = this.semanticInfoChain.stringTypeSymbol;
            syntheticIndexerSignatureSymbol.setResolved();
            syntheticIndexerSignatureSymbol.setIsSynthesized();

            enumContainerInstanceTypeSymbol.addIndexSignature(syntheticIndexerSignatureSymbol);
        };

        PullSymbolBinder.prototype.findExistingVariableSymbolForModuleValueDecl = function (decl) {
            var isExported = TypeScript.hasFlag(decl.flags, 1 /* Exported */);
            var modName = decl.name;
            var parentInstanceSymbol = this.getParent(decl, true);
            var parentDecl = decl.getParentDecl();

            var variableSymbol = null;

            if (parentInstanceSymbol) {
                if (isExported) {
                    variableSymbol = parentInstanceSymbol.findMember(modName, false);

                    if (!variableSymbol) {
                        variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);
                    }
                } else {
                    variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);

                    if (!variableSymbol) {
                        variableSymbol = parentInstanceSymbol.findMember(modName, false);
                    }
                }

                if (variableSymbol) {
                    var declarations = variableSymbol.getDeclarations();

                    if (declarations.length) {
                        var variableSymbolParentDecl = declarations[0].getParentDecl();
                        var isExportedOrHasTheSameParent = isExported || (parentDecl === variableSymbolParentDecl);

                        var canReuseVariableSymbol = isExportedOrHasTheSameParent && this.checkThatExportsMatch(decl, variableSymbol, false);

                        if (!canReuseVariableSymbol) {
                            variableSymbol = null;
                        }
                    }
                }
            } else if (!isExported) {
                var siblingDecls = parentDecl.getChildDecls();

                for (var i = 0; i < siblingDecls.length; i++) {
                    var sibling = siblingDecls[i];

                    var siblingIsSomeValue = TypeScript.hasFlag(sibling.kind, 68147712 /* SomeValue */);
                    var siblingIsFunctionOrHasImplictVarFlag = TypeScript.hasFlag(sibling.kind, 1032192 /* SomeFunction */) || TypeScript.hasFlag(sibling.flags, 118784 /* ImplicitVariable */);

                    var isSiblingAnAugmentableVariable = sibling !== decl && sibling !== decl.getValueDecl() && sibling.name === modName && siblingIsSomeValue && siblingIsFunctionOrHasImplictVarFlag;

                    if (isSiblingAnAugmentableVariable) {
                        if (sibling.hasSymbol(this.semanticInfoChain)) {
                            variableSymbol = sibling.getSymbol(this.semanticInfoChain);
                            if (variableSymbol.isContainer()) {
                                variableSymbol = variableSymbol.getInstanceSymbol();
                            } else if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = variableSymbol.getConstructorMethod();
                            }

                            break;
                        }
                    }
                }
            }
            return variableSymbol;
        };

        PullSymbolBinder.prototype.bindModuleDeclarationToPullSymbol = function (moduleContainerDecl) {
            var modName = moduleContainerDecl.name;

            var moduleContainerTypeSymbol = null;
            var moduleKind = moduleContainerDecl.kind;

            var parent = this.getParent(moduleContainerDecl);
            var parentInstanceSymbol = this.getParent(moduleContainerDecl, true);
            var parentDecl = moduleContainerDecl.getParentDecl();
            var moduleNameAST = this.semanticInfoChain.getASTForDecl(moduleContainerDecl);
            var moduleDeclAST = TypeScript.ASTHelpers.getEnclosingModuleDeclaration(moduleNameAST);

            if (!moduleDeclAST) {
                TypeScript.Debug.assert(moduleKind === 32 /* DynamicModule */);
                TypeScript.Debug.assert(moduleNameAST.kind() === 120 /* SourceUnit */);

                moduleDeclAST = moduleNameAST;
            }

            var isExported = TypeScript.hasFlag(moduleContainerDecl.flags, 1 /* Exported */);
            var searchKind = 164 /* SomeContainer */;
            var isInitializedModule = (moduleContainerDecl.flags & 102400 /* SomeInitializedModule */) !== 0;

            if (parent && moduleKind === 32 /* DynamicModule */) {
                this.semanticInfoChain.addDiagnosticFromAST(moduleNameAST, TypeScript.DiagnosticCode.Ambient_external_module_declaration_must_be_defined_in_global_context, null);
            }

            var createdNewSymbol = false;

            moduleContainerTypeSymbol = this.getExistingSymbol(moduleContainerDecl, searchKind, parent);

            if (moduleContainerTypeSymbol) {
                if (moduleContainerTypeSymbol.kind !== moduleKind) {
                    if (isInitializedModule) {
                        this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(moduleNameAST, moduleContainerDecl.getDisplayName());
                    }

                    moduleContainerTypeSymbol = null;
                } else if (moduleKind === 32 /* DynamicModule */) {
                    this.semanticInfoChain.addDiagnosticFromAST(moduleNameAST, TypeScript.DiagnosticCode.Ambient_external_module_declaration_cannot_be_reopened);
                } else if (!this.checkThatExportsMatch(moduleContainerDecl, moduleContainerTypeSymbol)) {
                    moduleContainerTypeSymbol = null;
                }
            }

            if (!moduleContainerTypeSymbol) {
                moduleContainerTypeSymbol = new TypeScript.PullContainerSymbol(modName, moduleKind, this.semanticInfoChain);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(moduleContainerTypeSymbol, searchKind);
                }
            }

            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(moduleNameAST, moduleContainerTypeSymbol);
            this.semanticInfoChain.setSymbolForAST(moduleDeclAST, moduleContainerTypeSymbol);

            var currentModuleValueDecl = moduleContainerDecl.getValueDecl();

            var moduleDeclarations = moduleContainerTypeSymbol.getDeclarations();

            if (createdNewSymbol) {
                if (parent) {
                    if (moduleContainerDecl.flags & 1 /* Exported */) {
                        parent.addEnclosedMemberContainer(moduleContainerTypeSymbol);
                    } else {
                        parent.addEnclosedNonMemberContainer(moduleContainerTypeSymbol);
                    }
                }
            }

            if (currentModuleValueDecl) {
                currentModuleValueDecl.ensureSymbolIsBound(this.semanticInfoChain);

                var instanceSymbol = null;
                var instanceTypeSymbol = null;
                if (currentModuleValueDecl.hasSymbol(this.semanticInfoChain)) {
                    instanceSymbol = currentModuleValueDecl.getSymbol(this.semanticInfoChain);
                } else {
                    instanceSymbol = new TypeScript.PullSymbol(modName, 512 /* Variable */, this.semanticInfoChain);
                    currentModuleValueDecl.setSymbol(instanceSymbol, this.semanticInfoChain);
                    if (!instanceSymbol.hasDeclaration(currentModuleValueDecl)) {
                        instanceSymbol.addDeclaration(currentModuleValueDecl);
                    }
                }

                if (!instanceSymbol.type) {
                    instanceSymbol.type = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */, this.semanticInfoChain);
                }

                moduleContainerTypeSymbol.setInstanceSymbol(instanceSymbol);

                if (!instanceSymbol.type.getAssociatedContainerType()) {
                    instanceSymbol.type.setAssociatedContainerType(moduleContainerTypeSymbol);
                }
            }
        };

        PullSymbolBinder.prototype.bindImportDeclaration = function (importDeclaration) {
            var declFlags = importDeclaration.flags;
            var declKind = importDeclaration.kind;
            var importDeclAST = this.semanticInfoChain.getASTForDecl(importDeclaration);

            var isExported = false;
            var importSymbol = null;
            var declName = importDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(importDeclaration);

            importSymbol = this.getExistingSymbol(importDeclaration, 164 /* SomeContainer */, parent);

            if (importSymbol) {
                parentHadSymbol = true;
            }

            if (importSymbol) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(importDeclAST, importDeclaration.getDisplayName());
                importSymbol = null;
            }

            if (!importSymbol) {
                importSymbol = new TypeScript.PullTypeAliasSymbol(declName, this.semanticInfoChain);

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(importSymbol, 164 /* SomeContainer */);
                }
            }

            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(importDeclAST, importSymbol);

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addEnclosedMemberContainer(importSymbol);
                } else {
                    parent.addEnclosedNonMemberContainer(importSymbol);
                }
            }
        };

        PullSymbolBinder.prototype.ensurePriorDeclarationsAreBound = function (container, currentDecl) {
            if (!container) {
                return;
            }

            var parentDecls = container.getDeclarations();
            for (var i = 0; i < parentDecls.length; ++i) {
                var parentDecl = parentDecls[i];
                var childDecls = parentDecl.getChildDecls();
                for (var j = 0; j < childDecls.length; ++j) {
                    var childDecl = childDecls[j];
                    if (childDecl === currentDecl) {
                        return;
                    }

                    if (childDecl.name === currentDecl.name) {
                        childDecl.ensureSymbolIsBound(this.semanticInfoChain);
                    }
                }
            }
        };

        PullSymbolBinder.prototype.bindClassDeclarationToPullSymbol = function (classDecl) {
            var className = classDecl.name;
            var classSymbol = null;

            var constructorSymbol = null;
            var constructorTypeSymbol = null;

            var classAST = this.semanticInfoChain.getASTForDecl(classDecl);

            var parent = this.getParent(classDecl);

            this.ensurePriorDeclarationsAreBound(parent, classDecl);

            var parentDecl = classDecl.getParentDecl();
            var isExported = classDecl.flags & 1 /* Exported */;
            var isGeneric = false;

            classSymbol = this.getExistingSymbol(classDecl, 58728795 /* SomeType */, parent);

            if (classSymbol && classSymbol.kind === 16 /* Interface */) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(classAST.identifier, classDecl.getDisplayName());
                classSymbol = null;
            }

            classSymbol = new TypeScript.PullTypeSymbol(className, 8 /* Class */, this.semanticInfoChain);

            if (!parent) {
                this.semanticInfoChain.cacheGlobalSymbol(classSymbol, 8 /* Class */);
            }

            classSymbol.addDeclaration(classDecl);
            classDecl.setSymbol(classSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(classAST.identifier, classSymbol);
            this.semanticInfoChain.setSymbolForAST(classAST, classSymbol);

            if (parent) {
                if (classDecl.flags & 1 /* Exported */) {
                    parent.addEnclosedMemberType(classSymbol);
                } else {
                    parent.addEnclosedNonMemberType(classSymbol);
                }
            }

            var typeParameterDecls = classDecl.getTypeParameters();

            for (var i = 0; i < typeParameterDecls.length; i++) {
                var typeParameterSymbol = classSymbol.findTypeParameter(typeParameterDecls[i].name);

                if (typeParameterSymbol) {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterSymbol.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameterSymbol.getName()]);
                }

                typeParameterSymbol = new TypeScript.PullTypeParameterSymbol(typeParameterDecls[i].name, this.semanticInfoChain);

                classSymbol.addTypeParameter(typeParameterSymbol);
                typeParameterSymbol.addDeclaration(typeParameterDecls[i]);
                typeParameterDecls[i].setSymbol(typeParameterSymbol, this.semanticInfoChain);
            }

            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = constructorSymbol ? constructorSymbol.type : null;

            if (!constructorSymbol) {
                var siblingValueDecls = null;
                if (parentDecl) {
                    siblingValueDecls = parentDecl.searchChildDecls(className, 68147712 /* SomeValue */);

                    if (siblingValueDecls && siblingValueDecls[0] && siblingValueDecls[0].hasSymbol(this.semanticInfoChain)) {
                        constructorSymbol = siblingValueDecls[0].getSymbol(this.semanticInfoChain);
                    }
                }

                if (constructorSymbol) {
                    constructorTypeSymbol = constructorSymbol.type;
                } else {
                    constructorSymbol = new TypeScript.PullSymbol(className, 32768 /* ConstructorMethod */, this.semanticInfoChain);
                    constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */, this.semanticInfoChain);
                    constructorSymbol.setIsSynthesized();
                    constructorSymbol.type = constructorTypeSymbol;
                }

                classSymbol.setConstructorMethod(constructorSymbol);
                classSymbol.setHasDefaultConstructor();
            }

            if (constructorSymbol.getIsSynthesized()) {
                constructorSymbol.addDeclaration(classDecl.getValueDecl());
                constructorTypeSymbol.addDeclaration(classDecl);
            } else {
                classSymbol.setHasDefaultConstructor(false);
            }

            constructorTypeSymbol.setAssociatedContainerType(classSymbol);

            var valueDecl = classDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound(this.semanticInfoChain);
            }

            this.bindStaticPrototypePropertyOfClass(classAST, classSymbol, constructorTypeSymbol);
        };

        PullSymbolBinder.prototype.bindInterfaceDeclarationToPullSymbol = function (interfaceDecl) {
            var interfaceName = interfaceDecl.name;
            var interfaceSymbol = null;

            var interfaceAST = this.semanticInfoChain.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent(interfaceDecl);

            var acceptableSharedKind = 16 /* Interface */;

            interfaceSymbol = this.getExistingSymbol(interfaceDecl, 58728795 /* SomeType */, parent);

            if (interfaceSymbol) {
                if (!(interfaceSymbol.kind & acceptableSharedKind)) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(interfaceAST.identifier, interfaceDecl.getDisplayName());
                    interfaceSymbol = null;
                } else if (!this.checkThatExportsMatch(interfaceDecl, interfaceSymbol)) {
                    interfaceSymbol = null;
                }
            }

            if (!interfaceSymbol) {
                interfaceSymbol = new TypeScript.PullTypeSymbol(interfaceName, 16 /* Interface */, this.semanticInfoChain);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(interfaceSymbol, acceptableSharedKind);
                }
            }

            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol, this.semanticInfoChain);

            if (createdNewSymbol) {
                if (parent) {
                    if (interfaceDecl.flags & 1 /* Exported */) {
                        parent.addEnclosedMemberType(interfaceSymbol);
                    } else {
                        parent.addEnclosedNonMemberType(interfaceSymbol);
                    }
                }
            }

            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    interfaceSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        var typeParameterDeclParent = typeParameterDecls[j].getParentDecl();

                        if (typeParameterDeclParent && typeParameterDeclParent === interfaceDecl) {
                            var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                            this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);

                            break;
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }
        };

        PullSymbolBinder.prototype.bindObjectTypeDeclarationToPullSymbol = function (objectDecl) {
            var objectSymbolAST = this.semanticInfoChain.getASTForDecl(objectDecl);

            var objectSymbol = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */, this.semanticInfoChain);

            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(objectSymbolAST, objectSymbol);

            var childDecls = objectDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
        };

        PullSymbolBinder.prototype.bindConstructorTypeDeclarationToPullSymbol = function (constructorTypeDeclaration) {
            var declKind = constructorTypeDeclaration.kind;
            var declFlags = constructorTypeDeclaration.flags;
            var constructorTypeAST = this.semanticInfoChain.getASTForDecl(constructorTypeDeclaration);

            var constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */, this.semanticInfoChain);

            constructorTypeDeclaration.setSymbol(constructorTypeSymbol, this.semanticInfoChain);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfoChain.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);

            var signature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */, this.semanticInfoChain);

            var funcDecl = this.semanticInfoChain.getASTForDecl(constructorTypeDeclaration);
            if (TypeScript.lastParameterIsRest(funcDecl.parameterList.parameters)) {
                signature.hasVarArgs = true;
            }

            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcDecl, funcDecl.parameterList.parameters, constructorTypeSymbol, signature);

            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            constructorTypeSymbol.appendConstructSignature(signature);
        };

        PullSymbolBinder.prototype.bindVariableDeclarationToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;

            var varDeclAST = this.semanticInfoChain.getASTForDecl(variableDeclaration);
            var nameAST = varDeclAST.kind() === 132 /* ClassDeclaration */ ? varDeclAST.identifier : varDeclAST.kind() === 226 /* VariableDeclarator */ ? varDeclAST.propertyName : varDeclAST.kind() === 133 /* EnumDeclaration */ ? varDeclAST.identifier : varDeclAST;

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var variableSymbol = null;

            var declName = variableDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(variableDeclaration, true);

            var parentDecl = variableDeclaration.getParentDecl();

            var isImplicit = (declFlags & 118784 /* ImplicitVariable */) !== 0;
            var isModuleValue = (declFlags & (32768 /* InitializedModule */)) !== 0;
            var isEnumValue = (declFlags & 4096 /* Enum */) !== 0;
            var isClassConstructorVariable = (declFlags & 16384 /* ClassConstructorVariable */) !== 0;
            variableSymbol = this.getExistingSymbol(variableDeclaration, 68147712 /* SomeValue */, parent);

            if (!variableSymbol && isModuleValue) {
                variableSymbol = this.findExistingVariableSymbolForModuleValueDecl(variableDeclaration.getContainerDecl());
            }

            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }

            var decl;
            var decls;
            var ast;
            var members;

            if (variableSymbol) {
                var prevKind = variableSymbol.kind;
                var prevIsEnum = variableSymbol.anyDeclHasFlag(4096 /* Enum */);
                var prevIsClassConstructorVariable = variableSymbol.anyDeclHasFlag(16384 /* ClassConstructorVariable */);
                var prevIsModuleValue = variableSymbol.allDeclsHaveFlag(32768 /* InitializedModule */);
                var prevIsImplicit = variableSymbol.anyDeclHasFlag(118784 /* ImplicitVariable */);
                var prevIsFunction = TypeScript.ArrayUtilities.any(variableSymbol.getDeclarations(), function (decl) {
                    return decl.kind === 16384 /* Function */;
                });
                var prevIsAmbient = variableSymbol.allDeclsHaveFlag(8 /* Ambient */);
                var isAmbientOrPrevIsAmbient = prevIsAmbient || (variableDeclaration.flags & 8 /* Ambient */) !== 0;
                var prevDecl = variableSymbol.getDeclarations()[0];
                var prevParentDecl = prevDecl.getParentDecl();
                var bothAreGlobal = parentDecl && (parentDecl.kind === 1 /* Script */) && (prevParentDecl.kind === 1 /* Script */);
                var shareParent = bothAreGlobal || prevDecl.getParentDecl() === variableDeclaration.getParentDecl();
                var prevIsParam = shareParent && prevKind === 2048 /* Parameter */ && declKind == 512 /* Variable */;

                var acceptableRedeclaration = prevIsParam || (isImplicit && ((!isEnumValue && !isClassConstructorVariable && prevIsFunction) || ((isModuleValue || isEnumValue) && (prevIsModuleValue || prevIsEnum)) || (isClassConstructorVariable && prevIsModuleValue && isAmbientOrPrevIsAmbient) || (isModuleValue && prevIsClassConstructorVariable)));

                if (acceptableRedeclaration && (prevIsClassConstructorVariable || prevIsFunction) && !isAmbientOrPrevIsAmbient) {
                    if (prevDecl.fileName() !== variableDeclaration.fileName()) {
                        this.semanticInfoChain.addDiagnostic(this.semanticInfoChain.diagnosticFromDecl(variableDeclaration, TypeScript.DiagnosticCode.Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2, [declName, declName, prevDecl.fileName()]));
                        variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                    }
                }

                if (!acceptableRedeclaration || prevIsParam) {
                    if (!prevIsParam && (isImplicit || prevIsImplicit || TypeScript.hasFlag(prevKind, 1032192 /* SomeFunction */)) || !shareParent) {
                        this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(nameAST, variableDeclaration.getDisplayName());
                        variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                    } else {
                        this.checkThatExportsMatch(variableDeclaration, variableSymbol);
                        variableSymbol = null;
                        parentHadSymbol = false;
                    }
                }

                if (variableSymbol && !(variableSymbol.type && variableSymbol.type.isError()) && !this.checkThatExportsMatch(variableDeclaration, variableSymbol, !(isModuleValue && prevIsModuleValue))) {
                    variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                }
            }

            if ((declFlags & 118784 /* ImplicitVariable */) === 0) {
                if (!variableSymbol) {
                    variableSymbol = new TypeScript.PullSymbol(declName, declKind, this.semanticInfoChain);
                    if (!parent && parentDecl.kind === 1 /* Script */) {
                        this.semanticInfoChain.cacheGlobalSymbol(variableSymbol, declKind);
                    }
                }

                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

                this.semanticInfoChain.setSymbolForAST(nameAST, variableSymbol);
                this.semanticInfoChain.setSymbolForAST(varDeclAST, variableSymbol);
            } else if (!parentHadSymbol) {
                if (isClassConstructorVariable) {
                    var classTypeSymbol = variableSymbol;

                    if (parent) {
                        members = parent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].kind === 8 /* Class */)) {
                                classTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!classTypeSymbol) {
                        var containerDecl = variableDeclaration.getContainerDecl();
                        classTypeSymbol = containerDecl.getSymbol(this.semanticInfoChain);
                        if (!classTypeSymbol) {
                            classTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, 58728795 /* SomeType */, variableDeclaration);
                        }
                    }

                    if (classTypeSymbol && (classTypeSymbol.kind !== 8 /* Class */)) {
                        classTypeSymbol = null;
                    }

                    if (classTypeSymbol && classTypeSymbol.isClass()) {
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

                        decls = classTypeSymbol.getDeclarations();

                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfoChain.getASTForDecl(decl);
                        }
                    } else {
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind, this.semanticInfoChain);
                        }

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

                        variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }
                } else if (declFlags & 102400 /* SomeInitializedModule */) {
                    var moduleContainerTypeSymbol = null;
                    var moduleParent = this.getParent(variableDeclaration);

                    if (moduleParent) {
                        members = moduleParent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!moduleContainerTypeSymbol) {
                        var containerDecl = variableDeclaration.getContainerDecl();
                        moduleContainerTypeSymbol = containerDecl.getSymbol(this.semanticInfoChain);
                        if (!moduleContainerTypeSymbol) {
                            moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, 164 /* SomeContainer */, variableDeclaration);

                            if (!moduleContainerTypeSymbol) {
                                moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, 64 /* Enum */, variableDeclaration);
                            }
                        }
                    }

                    if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                        moduleContainerTypeSymbol = null;
                    }

                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind, this.semanticInfoChain);
                            variableSymbol.type = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */, this.semanticInfoChain);
                        }

                        if (!variableSymbol.hasDeclaration(variableDeclaration)) {
                            variableSymbol.addDeclaration(variableDeclaration);
                        }
                        variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);
                    } else {
                        TypeScript.Debug.assert(false, "Attempted to bind invalid implicit variable symbol");
                    }
                }
            } else {
                if (!variableSymbol.hasDeclaration(variableDeclaration)) {
                    variableSymbol.addDeclaration(variableDeclaration);
                }
                variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);
            }

            var containerDecl = variableDeclaration.getContainerDecl();
            if (variableSymbol && variableSymbol.type && containerDecl && !variableSymbol.type.hasDeclaration(containerDecl)) {
                variableSymbol.type.addDeclaration(containerDecl);
            }

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addMember(variableSymbol);
                } else {
                    parent.addEnclosedNonMember(variableSymbol);
                }
            }
        };

        PullSymbolBinder.prototype.bindCatchVariableToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;
            var identifier = this.semanticInfoChain.getASTForDecl(variableDeclaration);

            var declName = variableDeclaration.name;

            var variableSymbol = new TypeScript.PullSymbol(declName, declKind, this.semanticInfoChain);

            variableSymbol.addDeclaration(variableDeclaration);
            variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

            variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;

            this.semanticInfoChain.setSymbolForAST(identifier, variableSymbol);
        };

        PullSymbolBinder.prototype.bindEnumMemberDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;
            var propDeclAST = this.semanticInfoChain.getASTForDecl(propertyDeclaration);

            var declName = propertyDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(propertyDeclaration, true);

            var propertySymbol = parent.findMember(declName, false);

            if (propertySymbol) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(propDeclAST.propertyName, propertyDeclaration.getDisplayName());
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            if (!parentHadSymbol) {
                propertySymbol = new TypeScript.PullSymbol(declName, declKind, this.semanticInfoChain);
            }

            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(propDeclAST.propertyName, propertySymbol);
            this.semanticInfoChain.setSymbolForAST(propDeclAST, propertySymbol);

            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        };

        PullSymbolBinder.prototype.bindPropertyDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;

            var ast = this.semanticInfoChain.getASTForDecl(propertyDeclaration);
            var astName = ast.kind() === 137 /* MemberVariableDeclaration */ ? ast.variableDeclarator.propertyName : ast.kind() === 142 /* PropertySignature */ ? ast.propertyName : ast.kind() === 243 /* Parameter */ ? ast.identifier : ast.propertyName;

            var isStatic = false;
            var isOptional = false;

            var propertySymbol = null;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            if (TypeScript.hasFlag(declFlags, 128 /* Optional */)) {
                isOptional = true;
            }

            var declName = propertyDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(propertyDeclaration, true);

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            propertySymbol = parent.findMember(declName, false);

            if (propertySymbol) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(astName, propertyDeclaration.getDisplayName());
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            var classTypeSymbol;

            if (!parentHadSymbol) {
                propertySymbol = new TypeScript.PullSymbol(declName, declKind, this.semanticInfoChain);
            }

            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(astName, propertySymbol);
            this.semanticInfoChain.setSymbolForAST(ast, propertySymbol);

            if (isOptional) {
                propertySymbol.isOptional = true;
            }

            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        };

        PullSymbolBinder.prototype.bindParameterSymbols = function (functionDeclaration, parameterList, funcType, signatureSymbol) {
            var parameters = [];
            var params = TypeScript.createIntrinsicsObject();
            var funcDecl = this.semanticInfoChain.getDeclForAST(functionDeclaration);

            if (parameterList) {
                for (var i = 0, n = parameterList.length; i < n; i++) {
                    var argDecl = parameterList[i];
                    var id = argDecl.identifier;
                    var decl = this.semanticInfoChain.getDeclForAST(argDecl);
                    var isProperty = TypeScript.hasFlag(decl.flags, 8388608 /* PropertyParameter */);
                    var parameterSymbol = new TypeScript.PullSymbol(TypeScript.tokenValueText(id), 2048 /* Parameter */, this.semanticInfoChain);

                    if ((i === (n - 1)) && TypeScript.lastParameterIsRest(parameterList)) {
                        parameterSymbol.isVarArg = true;
                    }

                    if (params[TypeScript.tokenValueText(id)]) {
                        this.semanticInfoChain.addDiagnosticFromAST(argDecl, TypeScript.DiagnosticCode.Duplicate_identifier_0, [id.text()]);
                    } else {
                        params[TypeScript.tokenValueText(id)] = true;
                    }

                    if (decl) {
                        var isParameterOptional = false;

                        if (isProperty) {
                            decl.ensureSymbolIsBound(this.semanticInfoChain);
                            var valDecl = decl.getValueDecl();

                            if (valDecl) {
                                isParameterOptional = TypeScript.hasFlag(valDecl.flags, 128 /* Optional */);

                                valDecl.setSymbol(parameterSymbol, this.semanticInfoChain);
                                parameterSymbol.addDeclaration(valDecl);
                            }
                        } else {
                            isParameterOptional = TypeScript.hasFlag(decl.flags, 128 /* Optional */);

                            parameterSymbol.addDeclaration(decl);
                            decl.setSymbol(parameterSymbol, this.semanticInfoChain);
                        }

                        parameterSymbol.isOptional = isParameterOptional;
                    }

                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.isOptional);

                    if (signatureSymbol.isDefinition()) {
                        funcType.addEnclosedNonMember(parameterSymbol);
                    }
                }
            }
        };

        PullSymbolBinder.prototype.bindFunctionDeclarationToPullSymbol = function (functionDeclaration) {
            var declKind = functionDeclaration.kind;
            var declFlags = functionDeclaration.flags;
            var funcDeclAST = this.semanticInfoChain.getASTForDecl(functionDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = functionDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(functionDeclaration, true);

            var parentDecl = functionDeclaration.getParentDecl();
            var parentHadSymbol = false;

            var functionSymbol = null;
            var functionTypeSymbol = null;

            functionSymbol = this.getExistingSymbol(functionDeclaration, 68147712 /* SomeValue */, parent);

            if (functionSymbol) {
                if (functionSymbol.kind === 16384 /* Function */) {
                    var acceptableRedeclaration = isSignature || functionSymbol.allDeclsHaveFlag(2048 /* Signature */);
                    if (!acceptableRedeclaration) {
                        this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST.identifier, TypeScript.DiagnosticCode.Duplicate_function_implementation);
                    }
                } else {
                    var isCurrentDeclAmbient = TypeScript.hasFlag(functionDeclaration.flags, 8 /* Ambient */);
                    var acceptableRedeclaration = TypeScript.ArrayUtilities.all(functionSymbol.getDeclarations(), function (decl) {
                        var isInitializedModuleOrAmbientDecl = TypeScript.hasFlag(decl.flags, 32768 /* InitializedModule */) && (isCurrentDeclAmbient || TypeScript.hasFlag(decl.flags, 8 /* Ambient */));
                        var isSignature = TypeScript.hasFlag(decl.flags, 2048 /* Signature */);
                        return isInitializedModuleOrAmbientDecl || isSignature;
                    });

                    if (!acceptableRedeclaration) {
                        this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(funcDeclAST.identifier, functionDeclaration.getDisplayName());
                        functionSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(funcName);
                    }
                }
            }

            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.type;
                parentHadSymbol = true;
            }

            if (!functionSymbol) {
                functionSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */, this.semanticInfoChain);
            }

            if (!functionTypeSymbol) {
                functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */, this.semanticInfoChain);
                functionSymbol.type = functionTypeSymbol;
                functionTypeSymbol.setFunctionSymbol(functionSymbol);
            }

            functionDeclaration.setSymbol(functionSymbol, this.semanticInfoChain);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);

            this.semanticInfoChain.setSymbolForAST(funcDeclAST.identifier, functionSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, functionSymbol);

            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol);
                } else {
                    parent.addEnclosedNonMember(functionSymbol);
                }
            }

            var signature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */, this.semanticInfoChain, !isSignature);

            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            if (TypeScript.lastParameterIsRest(funcDeclAST.callSignature.parameterList.parameters)) {
                signature.hasVarArgs = true;
            }

            var funcDecl = this.semanticInfoChain.getASTForDecl(functionDeclaration);
            this.bindParameterSymbols(funcDecl, funcDecl.callSignature.parameterList.parameters, functionTypeSymbol, signature);

            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            functionTypeSymbol.appendCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindFunctionExpressionToPullSymbol = function (functionExpressionDeclaration) {
            var declKind = functionExpressionDeclaration.kind;
            var declFlags = functionExpressionDeclaration.flags;
            var ast = this.semanticInfoChain.getASTForDecl(functionExpressionDeclaration);

            var parameters = ast.kind() === 220 /* SimpleArrowFunctionExpression */ ? [ast.parameter] : TypeScript.ASTHelpers.getParameterList(ast).parameters;
            var funcExpAST = ast;

            var functionName = declKind === 131072 /* FunctionExpression */ ? functionExpressionDeclaration.getFunctionExpressionName() : functionExpressionDeclaration.name;
            var functionSymbol = new TypeScript.PullSymbol(functionName, declKind, this.semanticInfoChain);
            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */, this.semanticInfoChain);
            functionTypeSymbol.setFunctionSymbol(functionSymbol);

            functionSymbol.type = functionTypeSymbol;

            functionExpressionDeclaration.setSymbol(functionSymbol, this.semanticInfoChain);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            functionTypeSymbol.addDeclaration(functionExpressionDeclaration);

            var name = funcExpAST.kind() === 223 /* FunctionExpression */ ? funcExpAST.identifier : funcExpAST.kind() === 242 /* FunctionPropertyAssignment */ ? funcExpAST.propertyName : null;
            if (name) {
                this.semanticInfoChain.setSymbolForAST(name, functionSymbol);
            }

            this.semanticInfoChain.setSymbolForAST(funcExpAST, functionSymbol);

            var signature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */, this.semanticInfoChain, true);

            if (TypeScript.lastParameterIsRest(parameters)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcExpAST, parameters, functionTypeSymbol, signature);

            functionTypeSymbol.appendCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindFunctionTypeDeclarationToPullSymbol = function (functionTypeDeclaration) {
            var declKind = functionTypeDeclaration.kind;
            var declFlags = functionTypeDeclaration.flags;
            var funcTypeAST = this.semanticInfoChain.getASTForDecl(functionTypeDeclaration);

            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */, this.semanticInfoChain);

            functionTypeDeclaration.setSymbol(functionTypeSymbol, this.semanticInfoChain);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfoChain.setSymbolForAST(funcTypeAST, functionTypeSymbol);

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var signature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */, this.semanticInfoChain, !isSignature);

            if (TypeScript.lastParameterIsRest(funcTypeAST.parameterList.parameters)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcTypeAST, funcTypeAST.parameterList.parameters, functionTypeSymbol, signature);

            functionTypeSymbol.appendCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindMethodDeclarationToPullSymbol = function (methodDeclaration) {
            var declKind = methodDeclaration.kind;
            var declFlags = methodDeclaration.flags;
            var methodAST = this.semanticInfoChain.getASTForDecl(methodDeclaration);

            var isPrivate = (declFlags & 2 /* Private */) !== 0;
            var isStatic = (declFlags & 16 /* Static */) !== 0;
            var isOptional = (declFlags & 128 /* Optional */) !== 0;

            var methodName = methodDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(methodDeclaration, true);
            var parentHadSymbol = false;

            var methodSymbol = null;
            var methodTypeSymbol = null;

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            methodSymbol = parent.findMember(methodName, false);

            if (methodSymbol && (methodSymbol.kind !== 65536 /* Method */ || (!isSignature && !methodSymbol.allDeclsHaveFlag(2048 /* Signature */)))) {
                if (methodSymbol.kind === 65536 /* Method */) {
                    this.semanticInfoChain.addDiagnosticFromAST(methodAST, TypeScript.DiagnosticCode.Duplicate_function_implementation);
                } else {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(methodAST, methodDeclaration.getDisplayName());
                }
                methodSymbol = null;
            }

            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.type;
                parentHadSymbol = true;
            }

            if (!methodSymbol) {
                methodSymbol = new TypeScript.PullSymbol(methodName, 65536 /* Method */, this.semanticInfoChain);
            }

            if (!methodTypeSymbol) {
                methodTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */, this.semanticInfoChain);
                methodSymbol.type = methodTypeSymbol;
                methodTypeSymbol.setFunctionSymbol(methodSymbol);
            }

            methodDeclaration.setSymbol(methodSymbol, this.semanticInfoChain);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);

            var nameAST = methodAST.kind() === 136 /* MemberFunctionDeclaration */ ? methodAST.propertyName : methodAST.propertyName;

            TypeScript.Debug.assert(nameAST);

            this.semanticInfoChain.setSymbolForAST(nameAST, methodSymbol);
            this.semanticInfoChain.setSymbolForAST(methodAST, methodSymbol);

            if (isOptional) {
                methodSymbol.isOptional = true;
            }

            if (!parentHadSymbol) {
                parent.addMember(methodSymbol);
            }

            var sigKind = 1048576 /* CallSignature */;

            var signature = new TypeScript.PullSignatureSymbol(sigKind, this.semanticInfoChain, !isSignature);

            var parameterList = TypeScript.ASTHelpers.getParameterList(methodAST);
            if (TypeScript.lastParameterIsRest(parameterList.parameters)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterName;
            var typeParameterAST;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterName = typeParameters[i].name;
                typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameters[i]);

                typeParameter = signature.findTypeParameter(typeParameterName);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameterName, this.semanticInfoChain);
                    signature.addTypeParameter(typeParameter);
                } else {
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            var funcDecl = this.semanticInfoChain.getASTForDecl(methodDeclaration);
            this.bindParameterSymbols(funcDecl, TypeScript.ASTHelpers.getParameterList(funcDecl).parameters, methodTypeSymbol, signature);

            var signatureIndex = this.getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(signature, methodTypeSymbol.getOwnCallSignatures());
            methodTypeSymbol.insertCallSignatureAtIndex(signature, signatureIndex);
        };

        PullSymbolBinder.prototype.bindStaticPrototypePropertyOfClass = function (classAST, classTypeSymbol, constructorTypeSymbol) {
            var prototypeStr = "prototype";

            var prototypeSymbol = constructorTypeSymbol.findMember(prototypeStr, false);
            if (prototypeSymbol && !prototypeSymbol.getIsSynthesized()) {
                this.semanticInfoChain.addDiagnostic(this.semanticInfoChain.diagnosticFromDecl(prototypeSymbol.getDeclarations()[0], TypeScript.DiagnosticCode.Duplicate_identifier_0, [prototypeSymbol.getDisplayName()]));
            }

            if (!prototypeSymbol || !prototypeSymbol.getIsSynthesized()) {
                var prototypeDecl = new TypeScript.PullSynthesizedDecl(prototypeStr, prototypeStr, 4096 /* Property */, 4 /* Public */ | 16 /* Static */, constructorTypeSymbol.getDeclarations()[0]);

                prototypeSymbol = new TypeScript.PullSymbol(prototypeStr, 4096 /* Property */, this.semanticInfoChain);
                prototypeSymbol.setIsSynthesized();
                prototypeSymbol.addDeclaration(prototypeDecl);
                prototypeSymbol.type = classTypeSymbol;
                constructorTypeSymbol.addMember(prototypeSymbol);

                if (prototypeSymbol.type && prototypeSymbol.type.isGeneric()) {
                    var resolver = this.semanticInfoChain.getResolver();
                    prototypeSymbol.type = resolver.instantiateTypeToAny(prototypeSymbol.type, new TypeScript.PullTypeResolutionContext(resolver));
                }
                prototypeSymbol.setResolved();
            }
        };

        PullSymbolBinder.prototype.bindConstructorDeclarationToPullSymbol = function (constructorDeclaration) {
            var declKind = constructorDeclaration.kind;
            var declFlags = constructorDeclaration.flags;
            var constructorAST = this.semanticInfoChain.getASTForDecl(constructorDeclaration);

            var constructorName = constructorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(constructorDeclaration, true);

            var parentHadSymbol = false;

            var constructorSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol = null;

            if (constructorSymbol && (constructorSymbol.kind !== 32768 /* ConstructorMethod */ || (!isSignature && constructorSymbol.type && constructorSymbol.type.hasOwnConstructSignatures()))) {
                var hasDefinitionSignature = false;
                var constructorSigs = constructorSymbol.type.getOwnDeclaredConstructSignatures();

                for (var i = 0; i < constructorSigs.length; i++) {
                    if (!constructorSigs[i].anyDeclHasFlag(2048 /* Signature */)) {
                        hasDefinitionSignature = true;
                        break;
                    }
                }

                if (hasDefinitionSignature) {
                    this.semanticInfoChain.addDiagnosticFromAST(constructorAST, TypeScript.DiagnosticCode.Multiple_constructor_implementations_are_not_allowed);

                    constructorSymbol = null;
                }
            }

            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.type;
            } else {
                constructorSymbol = new TypeScript.PullSymbol(constructorName, 32768 /* ConstructorMethod */, this.semanticInfoChain);
                constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */, this.semanticInfoChain);
            }

            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.type = constructorTypeSymbol;

            constructorDeclaration.setSymbol(constructorSymbol, this.semanticInfoChain);
            constructorSymbol.addDeclaration(constructorDeclaration);
            constructorTypeSymbol.addDeclaration(constructorDeclaration);
            constructorSymbol.setIsSynthesized(false);
            this.semanticInfoChain.setSymbolForAST(constructorAST, constructorSymbol);

            var constructSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */, this.semanticInfoChain, !isSignature);
            constructSignature.returnType = parent;
            constructSignature.addTypeParametersFromReturnType();

            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature, this.semanticInfoChain);

            this.bindParameterSymbols(constructorAST, constructorAST.callSignature.parameterList.parameters, constructorTypeSymbol, constructSignature);

            if (TypeScript.lastParameterIsRest(constructorAST.callSignature.parameterList.parameters)) {
                constructSignature.hasVarArgs = true;
            }

            constructorTypeSymbol.appendConstructSignature(constructSignature);
        };

        PullSymbolBinder.prototype.bindConstructSignatureDeclarationToPullSymbol = function (constructSignatureDeclaration) {
            var parent = this.getParent(constructSignatureDeclaration, true);
            var constructorAST = this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration);

            var constructSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */, this.semanticInfoChain);

            if (TypeScript.lastParameterIsRest(constructorAST.callSignature.parameterList.parameters)) {
                constructSignature.hasVarArgs = true;
            }

            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    constructSignature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature, this.semanticInfoChain);

            var funcDecl = this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, TypeScript.ASTHelpers.getParameterList(funcDecl).parameters, null, constructSignature);

            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration), constructSignature);

            var signatureIndex = this.getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(constructSignature, parent.getOwnDeclaredConstructSignatures());
            parent.insertConstructSignatureAtIndex(constructSignature, signatureIndex);
        };

        PullSymbolBinder.prototype.bindCallSignatureDeclarationToPullSymbol = function (callSignatureDeclaration) {
            var parent = this.getParent(callSignatureDeclaration, true);
            var callSignatureAST = this.semanticInfoChain.getASTForDecl(callSignatureDeclaration);

            var callSignature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */, this.semanticInfoChain);

            if (TypeScript.lastParameterIsRest(callSignatureAST.parameterList.parameters)) {
                callSignature.hasVarArgs = true;
            }

            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = callSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    callSignature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature, this.semanticInfoChain);

            var funcDecl = this.semanticInfoChain.getASTForDecl(callSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, funcDecl.parameterList.parameters, null, callSignature);

            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(callSignatureDeclaration), callSignature);

            var signatureIndex = this.getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(callSignature, parent.getOwnCallSignatures());
            parent.insertCallSignatureAtIndex(callSignature, signatureIndex);
        };

        PullSymbolBinder.prototype.bindIndexSignatureDeclarationToPullSymbol = function (indexSignatureDeclaration) {
            var indexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */, this.semanticInfoChain);

            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature, this.semanticInfoChain);

            var funcDecl = this.semanticInfoChain.getASTForDecl(indexSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, funcDecl.parameters, null, indexSignature);

            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(indexSignatureDeclaration), indexSignature);

            var parent = this.getParent(indexSignatureDeclaration);
            parent.addIndexSignature(indexSignature);
            indexSignature.setContainer(parent);
        };

        PullSymbolBinder.prototype.bindGetAccessorDeclarationToPullSymbol = function (getAccessorDeclaration) {
            var declKind = getAccessorDeclaration.kind;
            var declFlags = getAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfoChain.getASTForDecl(getAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = getAccessorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            var parent = this.getParent(getAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol = null;
            var getterSymbol = null;
            var getterTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(funcDeclAST.propertyName, getAccessorDeclaration.getDisplayName());
                    accessorSymbol = null;
                } else {
                    getterSymbol = accessorSymbol.getGetter();

                    if (getterSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Getter_0_already_declared, [getAccessorDeclaration.getDisplayName()]);
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;
            }

            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = getterSymbol.type;
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName, this.semanticInfoChain);
            }

            if (!getterSymbol) {
                getterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */, this.semanticInfoChain);
                getterTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */, this.semanticInfoChain);
                getterTypeSymbol.setFunctionSymbol(getterSymbol);

                getterSymbol.type = getterTypeSymbol;

                accessorSymbol.setGetter(getterSymbol);
            }

            getAccessorDeclaration.setSymbol(accessorSymbol, this.semanticInfoChain);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);

            var nameAST = funcDeclAST.propertyName;
            this.semanticInfoChain.setSymbolForAST(nameAST, accessorSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, getterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */, this.semanticInfoChain, !isSignature);

            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcDeclAST, funcDeclAST.callSignature.parameterList.parameters, getterTypeSymbol, signature);

            getterTypeSymbol.appendCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindSetAccessorDeclarationToPullSymbol = function (setAccessorDeclaration) {
            var declKind = setAccessorDeclaration.kind;
            var declFlags = setAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfoChain.getASTForDecl(setAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = setAccessorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            var parent = this.getParent(setAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol = null;
            var setterSymbol = null;
            var setterTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(funcDeclAST.propertyName, setAccessorDeclaration.getDisplayName());
                    accessorSymbol = null;
                } else {
                    setterSymbol = accessorSymbol.getSetter();

                    if (setterSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, TypeScript.DiagnosticCode.Setter_0_already_declared, [setAccessorDeclaration.getDisplayName()]);
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;

                if (setterSymbol) {
                    setterTypeSymbol = setterSymbol.type;
                }
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName, this.semanticInfoChain);
            }

            if (!setterSymbol) {
                setterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */, this.semanticInfoChain);
                setterTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */, this.semanticInfoChain);
                setterTypeSymbol.setFunctionSymbol(setterSymbol);

                setterSymbol.type = setterTypeSymbol;

                accessorSymbol.setSetter(setterSymbol);
            }

            setAccessorDeclaration.setSymbol(accessorSymbol, this.semanticInfoChain);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);

            var nameAST = funcDeclAST.propertyName;
            this.semanticInfoChain.setSymbolForAST(nameAST, accessorSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, setterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */, this.semanticInfoChain, !isSignature);

            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcDeclAST, funcDeclAST.callSignature.parameterList.parameters, setterTypeSymbol, signature);

            setterTypeSymbol.appendCallSignature(signature);
        };

        PullSymbolBinder.prototype.getDeclsToBind = function (decl) {
            var decls;
            switch (decl.kind) {
                case 64 /* Enum */:
                case 32 /* DynamicModule */:
                case 4 /* Container */:
                case 16 /* Interface */:
                    decls = this.findDeclsInContext(decl, decl.kind, true);
                    break;

                case 512 /* Variable */:
                case 16384 /* Function */:
                case 65536 /* Method */:
                case 32768 /* ConstructorMethod */:
                    decls = this.findDeclsInContext(decl, decl.kind, false);
                    break;

                default:
                    decls = [decl];
            }
            TypeScript.Debug.assert(decls && decls.length > 0);
            TypeScript.Debug.assert(TypeScript.ArrayUtilities.contains(decls, decl));
            return decls;
        };

        PullSymbolBinder.prototype.shouldBindDeclaration = function (decl) {
            return !decl.hasBeenBound(this.semanticInfoChain) && this.declsBeingBound.indexOf(decl.declID) < 0;
        };

        PullSymbolBinder.prototype.bindDeclToPullSymbol = function (decl) {
            if (this.shouldBindDeclaration(decl)) {
                this.bindAllDeclsToPullSymbol(decl);
            }
        };

        PullSymbolBinder.prototype.bindAllDeclsToPullSymbol = function (askedDecl) {
            var allDecls = this.getDeclsToBind(askedDecl);
            for (var i = 0; i < allDecls.length; i++) {
                var decl = allDecls[i];

                if (this.shouldBindDeclaration(decl)) {
                    this.bindSingleDeclToPullSymbol(decl);
                }
            }
        };

        PullSymbolBinder.prototype.bindSingleDeclToPullSymbol = function (decl) {
            this.declsBeingBound.push(decl.declID);

            switch (decl.kind) {
                case 1 /* Script */:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;

                case 64 /* Enum */:
                    this.bindEnumDeclarationToPullSymbol(decl);
                    break;

                case 32 /* DynamicModule */:
                case 4 /* Container */:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;

                case 16 /* Interface */:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;

                case 8 /* Class */:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;

                case 16384 /* Function */:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;

                case 512 /* Variable */:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;

                case 1024 /* CatchVariable */:
                    this.bindCatchVariableToPullSymbol(decl);
                    break;

                case 67108864 /* EnumMember */:
                    this.bindEnumMemberDeclarationToPullSymbol(decl);
                    break;

                case 4096 /* Property */:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;

                case 65536 /* Method */:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;

                case 32768 /* ConstructorMethod */:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;

                case 1048576 /* CallSignature */:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;

                case 2097152 /* ConstructSignature */:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;

                case 4194304 /* IndexSignature */:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;

                case 262144 /* GetAccessor */:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 524288 /* SetAccessor */:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 8388608 /* ObjectType */:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;

                case 16777216 /* FunctionType */:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;

                case 33554432 /* ConstructorType */:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;

                case 131072 /* FunctionExpression */:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;

                case 128 /* TypeAlias */:
                    this.bindImportDeclaration(decl);
                    break;

                case 2048 /* Parameter */:
                case 8192 /* TypeParameter */:
                    decl.getParentDecl().getSymbol(this.semanticInfoChain);
                    break;

                case 268435456 /* CatchBlock */:
                case 134217728 /* WithBlock */:
                    break;
            }

            TypeScript.Debug.assert(TypeScript.ArrayUtilities.last(this.declsBeingBound) === decl.declID);
            this.declsBeingBound.pop();
        };
        return PullSymbolBinder;
    })();
    TypeScript.PullSymbolBinder = PullSymbolBinder;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullHelpers) {
        function resolveDeclaredSymbolToUseType(symbol) {
            if (symbol.isSignature()) {
                if (!symbol.returnType) {
                    symbol._resolveDeclaredSymbol();
                }
            } else if (!symbol.type) {
                symbol._resolveDeclaredSymbol();
            }
        }
        PullHelpers.resolveDeclaredSymbolToUseType = resolveDeclaredSymbolToUseType;

        function getSignatureForFuncDecl(functionDecl, semanticInfoChain) {
            var funcDecl = functionDecl.ast();
            var funcSymbol = functionDecl.getSymbol(semanticInfoChain);

            if (!funcSymbol) {
                funcSymbol = functionDecl.getSignatureSymbol(semanticInfoChain);
            }

            var functionSignature = null;
            var typeSymbolWithAllSignatures = null;
            if (funcSymbol.isSignature()) {
                functionSignature = funcSymbol;
                var parent = functionDecl.getParentDecl();
                typeSymbolWithAllSignatures = parent.getSymbol(semanticInfoChain).type;
            } else {
                functionSignature = functionDecl.getSignatureSymbol(semanticInfoChain);
                typeSymbolWithAllSignatures = funcSymbol.type;
            }
            var signatures;

            if (funcDecl.kind() === 138 /* ConstructorDeclaration */ || functionDecl.kind === 2097152 /* ConstructSignature */) {
                signatures = typeSymbolWithAllSignatures.getConstructSignatures();
            } else if (functionDecl.kind === 4194304 /* IndexSignature */) {
                signatures = typeSymbolWithAllSignatures.getIndexSignatures();
            } else {
                signatures = typeSymbolWithAllSignatures.getCallSignatures();
            }

            return {
                signature: functionSignature,
                allSignatures: signatures
            };
        }
        PullHelpers.getSignatureForFuncDecl = getSignatureForFuncDecl;

        function getAccessorSymbol(getterOrSetter, semanticInfoChain) {
            var functionDecl = semanticInfoChain.getDeclForAST(getterOrSetter);
            var getterOrSetterSymbol = functionDecl.getSymbol(semanticInfoChain);

            return getterOrSetterSymbol;
        }
        PullHelpers.getAccessorSymbol = getAccessorSymbol;

        function getGetterAndSetterFunction(funcDecl, semanticInfoChain) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain);
            var result = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = semanticInfoChain.getASTForDecl(getterDecl);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = semanticInfoChain.getASTForDecl(setterDecl);
            }

            return result;
        }
        PullHelpers.getGetterAndSetterFunction = getGetterAndSetterFunction;

        function symbolIsEnum(source) {
            return source && (source.kind & (64 /* Enum */ | 67108864 /* EnumMember */)) !== 0;
        }
        PullHelpers.symbolIsEnum = symbolIsEnum;

        function symbolIsModule(symbol) {
            return symbol && (symbol.kind === 4 /* Container */ || isOneDeclarationOfKind(symbol, 4 /* Container */));
        }
        PullHelpers.symbolIsModule = symbolIsModule;

        function isOneDeclarationOfKind(symbol, kind) {
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (decls[i].kind === kind) {
                    return true;
                }
            }

            return false;
        }

        function isInStaticMemberContext(ast, semanticInfoChain) {
            var memberDeclAST = TypeScript.ASTHelpers.getEnclosingMemberDeclaration(ast);

            if (!memberDeclAST) {
                return false;
            }

            var decl = semanticInfoChain.getDeclForAST(memberDeclAST);

            return decl && TypeScript.hasFlag(decl.flags, 16 /* Static */);
        }
        PullHelpers.isInStaticMemberContext = isInStaticMemberContext;

        function isNameNumeric(name) {
            return isFinite(+name);
        }
        PullHelpers.isNameNumeric = isNameNumeric;

        function typeSymbolsAreIdentical(a, b) {
            if (a.isTypeReference() && !a.getIsSpecialized()) {
                a = a.referencedTypeSymbol;
            }

            if (b.isTypeReference() && !b.getIsSpecialized()) {
                b = b.referencedTypeSymbol;
            }

            return a === b;
        }
        PullHelpers.typeSymbolsAreIdentical = typeSymbolsAreIdentical;

        function getRootType(type) {
            var rootType = type.getRootSymbol();

            while (true) {
                if (type === rootType) {
                    return type;
                }

                type = rootType;
                rootType = type.getRootSymbol();
            }
        }
        PullHelpers.getRootType = getRootType;

        function isSymbolLocal(symbol) {
            var container = symbol.getContainer();
            if (container) {
                var containerKind = container.kind;
                if (containerKind & (1032192 /* SomeFunction */ | 16777216 /* FunctionType */)) {
                    return true;
                }

                if (containerKind === 33554432 /* ConstructorType */ && !symbol.anyDeclHasFlag(16 /* Static */ | 1 /* Exported */)) {
                    return true;
                }
            }

            return false;
        }
        PullHelpers.isSymbolLocal = isSymbolLocal;

        function isExportedSymbolInClodule(symbol) {
            var container = symbol.getContainer();
            return container && container.kind === 33554432 /* ConstructorType */ && symbolIsModule(container) && symbol.anyDeclHasFlag(1 /* Exported */);
        }
        PullHelpers.isExportedSymbolInClodule = isExportedSymbolInClodule;

        function isSymbolDeclaredInScopeChain(symbol, scopeSymbol) {
            TypeScript.Debug.assert(symbol);
            var symbolDeclarationScope = symbol.getContainer();

            while (scopeSymbol) {
                if (scopeSymbol === symbolDeclarationScope) {
                    return true;
                }

                scopeSymbol = scopeSymbol.getContainer();
            }

            if (scopeSymbol === null && symbolDeclarationScope === null) {
                return true;
            }

            return false;
        }
        PullHelpers.isSymbolDeclaredInScopeChain = isSymbolDeclaredInScopeChain;

        

        function walkSignatureSymbol(signatureSymbol, walker) {
            var continueWalk = true;
            var parameters = signatureSymbol.parameters;
            if (parameters) {
                for (var i = 0; continueWalk && i < parameters.length; i++) {
                    continueWalk = walker.signatureParameterWalk(parameters[i]);
                }
            }

            if (continueWalk) {
                continueWalk = walker.signatureReturnTypeWalk(signatureSymbol.returnType);
            }

            return continueWalk;
        }

        function walkPullTypeSymbolStructure(typeSymbol, walker) {
            var continueWalk = true;

            var members = typeSymbol.getMembers();
            for (var i = 0; continueWalk && i < members.length; i++) {
                continueWalk = walker.memberSymbolWalk(members[i]);
            }

            if (continueWalk) {
                var callSigantures = typeSymbol.getCallSignatures();
                for (var i = 0; continueWalk && i < callSigantures.length; i++) {
                    continueWalk = walker.callSignatureWalk(callSigantures[i]);
                    if (continueWalk) {
                        continueWalk = walkSignatureSymbol(callSigantures[i], walker);
                    }
                }
            }

            if (continueWalk) {
                var constructSignatures = typeSymbol.getConstructSignatures();
                for (var i = 0; continueWalk && i < constructSignatures.length; i++) {
                    continueWalk = walker.constructSignatureWalk(constructSignatures[i]);
                    if (continueWalk) {
                        continueWalk = walkSignatureSymbol(constructSignatures[i], walker);
                    }
                }
            }

            if (continueWalk) {
                var indexSignatures = typeSymbol.getIndexSignatures();
                for (var i = 0; continueWalk && i < indexSignatures.length; i++) {
                    continueWalk = walker.indexSignatureWalk(indexSignatures[i]);
                    if (continueWalk) {
                        continueWalk = walkSignatureSymbol(indexSignatures[i], walker);
                    }
                }
            }
        }
        PullHelpers.walkPullTypeSymbolStructure = walkPullTypeSymbolStructure;

        var OtherPullDeclsWalker = (function () {
            function OtherPullDeclsWalker() {
                this.currentlyWalkingOtherDecls = [];
            }
            OtherPullDeclsWalker.prototype.walkOtherPullDecls = function (currentDecl, otherDecls, callBack) {
                if (otherDecls) {
                    var isAlreadyWalkingOtherDecl = TypeScript.ArrayUtilities.any(this.currentlyWalkingOtherDecls, function (inWalkingOtherDecl) {
                        return TypeScript.ArrayUtilities.contains(otherDecls, inWalkingOtherDecl);
                    });

                    if (!isAlreadyWalkingOtherDecl) {
                        this.currentlyWalkingOtherDecls.push(currentDecl);
                        for (var i = 0; i < otherDecls.length; i++) {
                            if (otherDecls[i] !== currentDecl) {
                                callBack(otherDecls[i]);
                            }
                        }
                        var currentlyWalkingOtherDeclsDecl = this.currentlyWalkingOtherDecls.pop();
                        TypeScript.Debug.assert(currentlyWalkingOtherDeclsDecl == currentDecl);
                    }
                }
            };
            return OtherPullDeclsWalker;
        })();
        PullHelpers.OtherPullDeclsWalker = OtherPullDeclsWalker;
    })(TypeScript.PullHelpers || (TypeScript.PullHelpers = {}));
    var PullHelpers = TypeScript.PullHelpers;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var WrapsTypeParameterCache = (function () {
        function WrapsTypeParameterCache() {
            this._wrapsTypeParameterCache = TypeScript.BitVector.getBitVector(true);
        }
        WrapsTypeParameterCache.prototype.getWrapsTypeParameter = function (typeParameterArgumentMap) {
            var someTypeParameterWasMissingFromCache = false;
            for (var typeParameterID in typeParameterArgumentMap) {
                if (typeParameterArgumentMap.hasOwnProperty(typeParameterID)) {
                    var cachedValue = this._wrapsTypeParameterCache.valueAt(typeParameterID);
                    if (cachedValue) {
                        return typeParameterID;
                    }
                    someTypeParameterWasMissingFromCache = someTypeParameterWasMissingFromCache || cachedValue === undefined;
                }
            }

            if (!someTypeParameterWasMissingFromCache) {
                return 0;
            }

            return undefined;
        };

        WrapsTypeParameterCache.prototype.setWrapsTypeParameter = function (typeParameterArgumentMap, wrappingTypeParameterID) {
            if (wrappingTypeParameterID) {
                this._wrapsTypeParameterCache.setValueAt(wrappingTypeParameterID, true);
            } else {
                for (var typeParameterID in typeParameterArgumentMap) {
                    if (typeParameterArgumentMap.hasOwnProperty(typeParameterID)) {
                        this._wrapsTypeParameterCache.setValueAt(typeParameterID, false);
                    }
                }
            }
        };
        return WrapsTypeParameterCache;
    })();
    TypeScript.WrapsTypeParameterCache = WrapsTypeParameterCache;

    (function (PullInstantiationHelpers) {
        var MutableTypeParameterSubstitutionMap = (function () {
            function MutableTypeParameterSubstitutionMap(typeParameterSubstitutionMap) {
                this.typeParameterSubstitutionMap = typeParameterSubstitutionMap;
                this.createdDuplicateTypeSubstitutionMap = false;
            }
            MutableTypeParameterSubstitutionMap.prototype.ensureCopyOfUnderlyingMap = function () {
                if (!this.createdDuplicateTypeSubstitutionMap) {
                    var passedInTypeArgumentMap = this.typeParameterSubstitutionMap;
                    this.typeParameterSubstitutionMap = [];
                    for (var typeParameterID in passedInTypeArgumentMap) {
                        if (passedInTypeArgumentMap.hasOwnProperty(typeParameterID)) {
                            this.typeParameterSubstitutionMap[typeParameterID] = passedInTypeArgumentMap[typeParameterID];
                        }
                    }
                    this.createdDuplicateTypeSubstitutionMap = true;
                }
            };
            return MutableTypeParameterSubstitutionMap;
        })();
        PullInstantiationHelpers.MutableTypeParameterSubstitutionMap = MutableTypeParameterSubstitutionMap;

        function instantiateTypeArgument(resolver, symbol, mutableTypeParameterMap) {
            if (symbol.getIsSpecialized()) {
                var rootTypeArgumentMap = symbol.getTypeParameterSubstitutionMap();
                var newTypeArgumentMap = [];
                var allowedTypeParameters = symbol.getAllowedToReferenceTypeParameters();
                for (var i = 0; i < allowedTypeParameters.length; i++) {
                    var typeParameterID = allowedTypeParameters[i].pullSymbolID;
                    var typeArg = rootTypeArgumentMap[typeParameterID];
                    if (typeArg) {
                        newTypeArgumentMap[typeParameterID] = resolver.instantiateType(typeArg, mutableTypeParameterMap.typeParameterSubstitutionMap);
                    }
                }

                for (var i = 0; i < allowedTypeParameters.length; i++) {
                    var typeParameterID = allowedTypeParameters[i].pullSymbolID;
                    if (newTypeArgumentMap[typeParameterID] && mutableTypeParameterMap.typeParameterSubstitutionMap[typeParameterID] != newTypeArgumentMap[typeParameterID]) {
                        mutableTypeParameterMap.ensureCopyOfUnderlyingMap();
                        mutableTypeParameterMap.typeParameterSubstitutionMap[typeParameterID] = newTypeArgumentMap[typeParameterID];
                    }
                }
            }
        }
        PullInstantiationHelpers.instantiateTypeArgument = instantiateTypeArgument;

        function cleanUpTypeParameterSubstitutionMap(symbol, mutableTypeParameterSubstitutionMap) {
            var allowedToReferenceTypeParameters = symbol.getAllowedToReferenceTypeParameters();
            for (var typeParameterID in mutableTypeParameterSubstitutionMap.typeParameterSubstitutionMap) {
                if (mutableTypeParameterSubstitutionMap.typeParameterSubstitutionMap.hasOwnProperty(typeParameterID)) {
                    if (!TypeScript.ArrayUtilities.any(allowedToReferenceTypeParameters, function (typeParameter) {
                        return typeParameter.pullSymbolID == typeParameterID;
                    })) {
                        mutableTypeParameterSubstitutionMap.ensureCopyOfUnderlyingMap();
                        delete mutableTypeParameterSubstitutionMap.typeParameterSubstitutionMap[typeParameterID];
                    }
                }
            }
        }
        PullInstantiationHelpers.cleanUpTypeParameterSubstitutionMap = cleanUpTypeParameterSubstitutionMap;

        function getAllowedToReferenceTypeParametersFromDecl(decl, semanticInfoChain) {
            var allowedToReferenceTypeParameters = [];

            var allowedToUseDeclTypeParameters = false;
            var getTypeParametersFromParentDecl = false;

            switch (decl.kind) {
                case 65536 /* Method */:
                    if (TypeScript.hasFlag(decl.flags, 16 /* Static */)) {
                        allowedToUseDeclTypeParameters = true;
                        break;
                    }

                case 16777216 /* FunctionType */:
                case 33554432 /* ConstructorType */:
                case 2097152 /* ConstructSignature */:
                case 1048576 /* CallSignature */:
                case 131072 /* FunctionExpression */:
                case 16384 /* Function */:
                    allowedToUseDeclTypeParameters = true;
                    getTypeParametersFromParentDecl = true;
                    break;

                case 4096 /* Property */:
                    if (TypeScript.hasFlag(decl.flags, 16 /* Static */)) {
                        break;
                    }

                case 2048 /* Parameter */:
                case 262144 /* GetAccessor */:
                case 524288 /* SetAccessor */:
                case 32768 /* ConstructorMethod */:
                case 4194304 /* IndexSignature */:
                case 8388608 /* ObjectType */:
                case 256 /* ObjectLiteral */:
                case 8192 /* TypeParameter */:
                    getTypeParametersFromParentDecl = true;
                    break;

                case 8 /* Class */:
                case 16 /* Interface */:
                    allowedToUseDeclTypeParameters = true;
                    break;
            }

            if (getTypeParametersFromParentDecl) {
                allowedToReferenceTypeParameters = allowedToReferenceTypeParameters.concat(getAllowedToReferenceTypeParametersFromDecl(decl.getParentDecl(), semanticInfoChain));
            }

            if (allowedToUseDeclTypeParameters) {
                var typeParameterDecls = decl.getTypeParameters();
                for (var i = 0; i < typeParameterDecls.length; i++) {
                    allowedToReferenceTypeParameters.push(typeParameterDecls[i].getSymbol(semanticInfoChain));
                }
            }

            return allowedToReferenceTypeParameters;
        }
        PullInstantiationHelpers.getAllowedToReferenceTypeParametersFromDecl = getAllowedToReferenceTypeParametersFromDecl;

        function createTypeParameterSubstitutionMap(typeParameters, typeArguments) {
            return updateTypeParameterSubstitutionMap(typeParameters, typeArguments, {});
        }
        PullInstantiationHelpers.createTypeParameterSubstitutionMap = createTypeParameterSubstitutionMap;

        function updateTypeParameterSubstitutionMap(typeParameters, typeArguments, typeParameterSubstitutionMap) {
            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterSubstitutionMap[typeParameters[i].getRootSymbol().pullSymbolID] = typeArguments[i];
            }
            return typeParameterSubstitutionMap;
        }
        PullInstantiationHelpers.updateTypeParameterSubstitutionMap = updateTypeParameterSubstitutionMap;

        function updateMutableTypeParameterSubstitutionMap(typeParameters, typeArguments, mutableMap) {
            for (var i = 0; i < typeParameters.length; i++) {
                var typeParameterId = typeParameters[i].getRootSymbol().pullSymbolID;
                if (mutableMap.typeParameterSubstitutionMap[typeParameterId] !== typeArguments[i]) {
                    mutableMap.ensureCopyOfUnderlyingMap();
                    mutableMap.typeParameterSubstitutionMap[typeParameterId] = typeArguments[i];
                }
            }
        }
        PullInstantiationHelpers.updateMutableTypeParameterSubstitutionMap = updateMutableTypeParameterSubstitutionMap;

        function twoTypesAreInstantiationsOfSameNamedGenericType(type1, type2) {
            var type1IsGeneric = type1.isGeneric() && type1.getTypeArguments() !== null;
            var type2IsGeneric = type2.isGeneric() && type2.getTypeArguments() !== null;

            if (type1IsGeneric && type2IsGeneric) {
                var type1Root = TypeScript.PullHelpers.getRootType(type1);
                var type2Root = TypeScript.PullHelpers.getRootType(type2);
                return type1Root === type2Root;
            }

            return false;
        }
        PullInstantiationHelpers.twoTypesAreInstantiationsOfSameNamedGenericType = twoTypesAreInstantiationsOfSameNamedGenericType;
    })(TypeScript.PullInstantiationHelpers || (TypeScript.PullInstantiationHelpers = {}));
    var PullInstantiationHelpers = TypeScript.PullInstantiationHelpers;
})(TypeScript || (TypeScript = {}));
if (Error)
    Error.stackTraceLimit = 1000;

var TypeScript;
(function (TypeScript) {
    TypeScript.fileResolutionTime = 0;
    TypeScript.fileResolutionIOTime = 0;
    TypeScript.fileResolutionScanImportsTime = 0;
    TypeScript.fileResolutionImportFileSearchTime = 0;
    TypeScript.fileResolutionGetDefaultLibraryTime = 0;
    TypeScript.sourceCharactersCompiled = 0;
    TypeScript.syntaxTreeParseTime = 0;
    TypeScript.typeCheckTime = 0;
    TypeScript.createDeclarationsTime = 0;

    TypeScript.compilerResolvePathTime = 0;
    TypeScript.compilerDirectoryNameTime = 0;
    TypeScript.compilerDirectoryExistsTime = 0;
    TypeScript.compilerFileExistsTime = 0;

    TypeScript.emitTime = 0;
    TypeScript.emitWriteFileTime = 0;

    TypeScript.declarationEmitTime = 0;
    TypeScript.declarationEmitIsExternallyVisibleTime = 0;
    TypeScript.declarationEmitTypeSignatureTime = 0;
    TypeScript.declarationEmitGetBoundDeclTypeTime = 0;
    TypeScript.declarationEmitIsOverloadedCallSignatureTime = 0;
    TypeScript.declarationEmitFunctionDeclarationGetSymbolTime = 0;
    TypeScript.declarationEmitGetBaseTypeTime = 0;
    TypeScript.declarationEmitGetAccessorFunctionTime = 0;
    TypeScript.declarationEmitGetTypeParameterSymbolTime = 0;
    TypeScript.declarationEmitGetImportDeclarationSymbolTime = 0;

    TypeScript.ioHostResolvePathTime = 0;
    TypeScript.ioHostDirectoryNameTime = 0;
    TypeScript.ioHostCreateDirectoryStructureTime = 0;
    TypeScript.ioHostWriteFileTime = 0;

    (function (EmitOutputResult) {
        EmitOutputResult[EmitOutputResult["Succeeded"] = 0] = "Succeeded";
        EmitOutputResult[EmitOutputResult["FailedBecauseOfSyntaxErrors"] = 1] = "FailedBecauseOfSyntaxErrors";
        EmitOutputResult[EmitOutputResult["FailedBecauseOfCompilerOptionsErrors"] = 2] = "FailedBecauseOfCompilerOptionsErrors";
        EmitOutputResult[EmitOutputResult["FailedToGenerateDeclarationsBecauseOfSemanticErrors"] = 3] = "FailedToGenerateDeclarationsBecauseOfSemanticErrors";
    })(TypeScript.EmitOutputResult || (TypeScript.EmitOutputResult = {}));
    var EmitOutputResult = TypeScript.EmitOutputResult;

    var EmitOutput = (function () {
        function EmitOutput(emitOutputResult) {
            if (typeof emitOutputResult === "undefined") { emitOutputResult = 0 /* Succeeded */; }
            this.outputFiles = [];
            this.emitOutputResult = emitOutputResult;
        }
        return EmitOutput;
    })();
    TypeScript.EmitOutput = EmitOutput;

    (function (OutputFileType) {
        OutputFileType[OutputFileType["JavaScript"] = 0] = "JavaScript";
        OutputFileType[OutputFileType["SourceMap"] = 1] = "SourceMap";
        OutputFileType[OutputFileType["Declaration"] = 2] = "Declaration";
    })(TypeScript.OutputFileType || (TypeScript.OutputFileType = {}));
    var OutputFileType = TypeScript.OutputFileType;

    var OutputFile = (function () {
        function OutputFile(name, writeByteOrderMark, text, fileType, sourceMapEntries) {
            if (typeof sourceMapEntries === "undefined") { sourceMapEntries = []; }
            this.name = name;
            this.writeByteOrderMark = writeByteOrderMark;
            this.text = text;
            this.fileType = fileType;
            this.sourceMapEntries = sourceMapEntries;
        }
        return OutputFile;
    })();
    TypeScript.OutputFile = OutputFile;

    var CompileResult = (function () {
        function CompileResult() {
            this.diagnostics = [];
            this.outputFiles = [];
        }
        CompileResult.fromDiagnostics = function (diagnostics) {
            var result = new CompileResult();
            result.diagnostics = diagnostics;
            return result;
        };

        CompileResult.fromOutputFiles = function (outputFiles) {
            var result = new CompileResult();
            result.outputFiles = outputFiles;
            return result;
        };
        return CompileResult;
    })();
    TypeScript.CompileResult = CompileResult;

    var OperationCanceledException = (function () {
        function OperationCanceledException() {
        }
        return OperationCanceledException;
    })();
    TypeScript.OperationCanceledException = OperationCanceledException;

    var CancellationToken = (function () {
        function CancellationToken(cancellationToken) {
            this.cancellationToken = cancellationToken;
        }
        CancellationToken.prototype.isCancellationRequested = function () {
            return this.cancellationToken && this.cancellationToken.isCancellationRequested();
        };

        CancellationToken.prototype.throwIfCancellationRequested = function () {
            if (this.isCancellationRequested()) {
                throw new OperationCanceledException();
            }
        };
        CancellationToken.None = new CancellationToken(null);
        return CancellationToken;
    })();
    TypeScript.CancellationToken = CancellationToken;

    var DocumentRegistryEntry = (function () {
        function DocumentRegistryEntry(document) {
            this.document = document;
            this.refCount = 0;
            this.owners = [];
        }
        return DocumentRegistryEntry;
    })();

    var NonCachingDocumentRegistry = (function () {
        function NonCachingDocumentRegistry() {
        }
        NonCachingDocumentRegistry.prototype.acquireDocument = function (fileName, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            return TypeScript.Document.create(compilationSettings, fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles);
        };

        NonCachingDocumentRegistry.prototype.updateDocument = function (document, fileName, compilationSettings, scriptSnapshot, version, isOpen, textChangeRange) {
            return document.update(scriptSnapshot, version, isOpen, textChangeRange);
        };

        NonCachingDocumentRegistry.prototype.releaseDocument = function (fileName, compilationSettings) {
        };
        NonCachingDocumentRegistry.Instance = new NonCachingDocumentRegistry();
        return NonCachingDocumentRegistry;
    })();
    TypeScript.NonCachingDocumentRegistry = NonCachingDocumentRegistry;

    var DocumentRegistry = (function () {
        function DocumentRegistry() {
            this.buckets = {};
        }
        DocumentRegistry.prototype.getKeyFromCompilationSettings = function (settings) {
            return "_" + settings.propagateEnumConstants().toString() + "|" + settings.allowAutomaticSemicolonInsertion().toString() + "|" + TypeScript.LanguageVersion[settings.codeGenTarget()];
        };

        DocumentRegistry.prototype.getBucketForCompilationSettings = function (settings, createIfMissing) {
            var key = this.getKeyFromCompilationSettings(settings);
            var bucket = this.buckets[key];
            if (!bucket && createIfMissing) {
                this.buckets[key] = bucket = new TypeScript.StringHashTable();
            }
            return bucket;
        };

        DocumentRegistry.prototype.reportStats = function () {
            var _this = this;
            var bucketInfoArray = Object.keys(this.buckets).filter(function (name) {
                return name && name.charAt(0) === '_';
            }).map(function (name) {
                var entries = _this.buckets[name];
                var documents = entries.getAllKeys().map(function (name) {
                    var entry = entries.lookup(name);
                    return {
                        name: name,
                        refCount: entry.refCount,
                        references: entry.owners.slice(0)
                    };
                });
                documents.sort(function (x, y) {
                    return y.refCount - x.refCount;
                });
                return { bucket: name, documents: documents };
            });
            return JSON.stringify(bucketInfoArray, null, 2);
        };

        DocumentRegistry.prototype.acquireDocument = function (fileName, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            var bucket = this.getBucketForCompilationSettings(compilationSettings, true);
            var entry = bucket.lookup(fileName);
            if (!entry) {
                var document = TypeScript.Document.create(compilationSettings, fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles);

                entry = new DocumentRegistryEntry(document);
                bucket.add(fileName, entry);
            }
            entry.refCount++;

            return entry.document;
        };

        DocumentRegistry.prototype.updateDocument = function (document, fileName, compilationSettings, scriptSnapshot, version, isOpen, textChangeRange) {
            var bucket = this.getBucketForCompilationSettings(compilationSettings, false);
            TypeScript.Debug.assert(bucket);
            var entry = bucket.lookup(fileName);
            TypeScript.Debug.assert(entry);

            if (entry.document.isOpen === isOpen && entry.document.version === version) {
                return entry.document;
            }

            entry.document = entry.document.update(scriptSnapshot, version, isOpen, textChangeRange);
            return entry.document;
        };

        DocumentRegistry.prototype.releaseDocument = function (fileName, compilationSettings) {
            var bucket = this.getBucketForCompilationSettings(compilationSettings, false);
            TypeScript.Debug.assert(bucket);

            var entry = bucket.lookup(fileName);
            entry.refCount--;

            TypeScript.Debug.assert(entry.refCount >= 0);
            if (entry.refCount === 0) {
                bucket.remove(fileName);
            }
        };
        return DocumentRegistry;
    })();
    TypeScript.DocumentRegistry = DocumentRegistry;

    var TypeScriptCompiler = (function () {
        function TypeScriptCompiler(logger, _settings) {
            if (typeof logger === "undefined") { logger = new TypeScript.NullLogger(); }
            if (typeof _settings === "undefined") { _settings = TypeScript.ImmutableCompilationSettings.defaultSettings(); }
            this.logger = logger;
            this._settings = _settings;
            this.semanticInfoChain = null;
            this.semanticInfoChain = new TypeScript.SemanticInfoChain(this, logger);
        }
        TypeScriptCompiler.prototype.getSemanticInfoChain = function () {
            return this.semanticInfoChain;
        };

        TypeScriptCompiler.prototype.compilationSettings = function () {
            return this._settings;
        };

        TypeScriptCompiler.prototype.setCompilationSettings = function (newSettings) {
            var oldSettings = this._settings;
            this._settings = newSettings;

            if (!compareDataObjects(oldSettings, newSettings)) {
                this.semanticInfoChain.invalidate(oldSettings, newSettings);
            }
        };

        TypeScriptCompiler.prototype.getDocument = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            return this.semanticInfoChain.getDocument(fileName);
        };

        TypeScriptCompiler.prototype.cleanupSemanticCache = function () {
            this.semanticInfoChain.invalidate();
        };

        TypeScriptCompiler.prototype.addOrUpdateFile = function (document) {
            this.semanticInfoChain.addDocument(document);
        };

        TypeScriptCompiler.prototype.addFile = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = TypeScript.Document.create(this.compilationSettings(), fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles);
            this.addOrUpdateFile(document);
        };

        TypeScriptCompiler.prototype.updateFile = function (fileName, scriptSnapshot, version, isOpen, textChangeRange) {
            fileName = TypeScript.switchToForwardSlashes(fileName);

            var document = this.getDocument(fileName);
            var updatedDocument = document.update(scriptSnapshot, version, isOpen, textChangeRange);

            this.addOrUpdateFile(updatedDocument);
        };

        TypeScriptCompiler.prototype.removeFile = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            this.semanticInfoChain.removeDocument(fileName);
        };

        TypeScriptCompiler.prototype.mapOutputFileName = function (document, emitOptions, extensionChanger) {
            if (document.emitToOwnOutputFile()) {
                var updatedFileName = document.fileName;
                if (emitOptions.outputDirectory() !== "") {
                    updatedFileName = document.fileName.replace(emitOptions.commonDirectoryPath(), "");
                    updatedFileName = emitOptions.outputDirectory() + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(emitOptions.sharedOutputFile(), true);
            }
        };

        TypeScriptCompiler.prototype.writeByteOrderMarkForDocument = function (document) {
            var printReason = false;

            if (document.emitToOwnOutputFile()) {
                var result = document.byteOrderMark !== 0 /* None */;
                if (printReason) {
                    TypeScript.Environment.standardOut.WriteLine("Emitting byte order mark because of: " + document.fileName);
                }
                return result;
            } else {
                var fileNames = this.fileNames();

                var result = false;
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var document = this.getDocument(fileNames[i]);

                    if (document.syntaxTree().isExternalModule()) {
                        continue;
                    }

                    if (document.byteOrderMark !== 0 /* None */) {
                        if (printReason) {
                            TypeScript.Environment.standardOut.WriteLine("Emitting byte order mark because of: " + document.fileName);
                            result = true;
                        } else {
                            return true;
                        }
                    }
                }

                return result;
            }
        };

        TypeScriptCompiler.mapToDTSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScript.getDeclareFilePath(fileName);
        };

        TypeScriptCompiler.prototype._shouldEmit = function (document) {
            return !document.isDeclareFile();
        };

        TypeScriptCompiler.prototype._shouldEmitDeclarations = function (document) {
            if (!this.compilationSettings().generateDeclarationFiles()) {
                return false;
            }

            return this._shouldEmit(document);
        };

        TypeScriptCompiler.prototype.emitDocumentDeclarationsWorker = function (document, emitOptions, declarationEmitter) {
            var sourceUnit = document.sourceUnit();
            TypeScript.Debug.assert(this._shouldEmitDeclarations(document));

            if (declarationEmitter) {
                declarationEmitter.document = document;
            } else {
                var declareFileName = this.mapOutputFileName(document, emitOptions, TypeScriptCompiler.mapToDTSFileName);
                declarationEmitter = new TypeScript.DeclarationEmitter(declareFileName, document, this, emitOptions, this.semanticInfoChain);
            }

            declarationEmitter.emitDeclarations(sourceUnit);
            return declarationEmitter;
        };

        TypeScriptCompiler.prototype._emitDocumentDeclarations = function (document, emitOptions, onSingleFileEmitComplete, sharedEmitter) {
            var start = new Date().getTime();
            if (this._shouldEmitDeclarations(document)) {
                if (document.emitToOwnOutputFile()) {
                    var singleEmitter = this.emitDocumentDeclarationsWorker(document, emitOptions);
                    if (singleEmitter) {
                        onSingleFileEmitComplete(singleEmitter.getOutputFile());
                    }
                } else {
                    sharedEmitter = this.emitDocumentDeclarationsWorker(document, emitOptions, sharedEmitter);
                }
            }

            TypeScript.declarationEmitTime += new Date().getTime() - start;
            return sharedEmitter;
        };

        TypeScriptCompiler.prototype.emitAllDeclarations = function (resolvePath) {
            var emitOutput = new EmitOutput();

            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = 2 /* FailedBecauseOfCompilerOptionsErrors */;
                return emitOutput;
            }

            var sharedEmitter = null;
            var fileNames = this.fileNames();

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var document = this.getDocument(fileNames[i]);

                sharedEmitter = this._emitDocumentDeclarations(document, emitOptions, function (file) {
                    return emitOutput.outputFiles.push(file);
                }, sharedEmitter);
            }

            if (sharedEmitter) {
                emitOutput.outputFiles.push(sharedEmitter.getOutputFile());
            }

            return emitOutput;
        };

        TypeScriptCompiler.prototype.emitDeclarations = function (fileName, resolvePath) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var emitOutput = new EmitOutput();

            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = 2 /* FailedBecauseOfCompilerOptionsErrors */;
                return emitOutput;
            }

            var document = this.getDocument(fileName);

            if (document.emitToOwnOutputFile()) {
                this._emitDocumentDeclarations(document, emitOptions, function (file) {
                    return emitOutput.outputFiles.push(file);
                }, null);
                return emitOutput;
            } else {
                return this.emitAllDeclarations(resolvePath);
            }
        };

        TypeScriptCompiler.prototype.canEmitDeclarations = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = this.getDocument(fileName);
            return this._shouldEmitDeclarations(document);
        };

        TypeScriptCompiler.mapToFileNameExtension = function (extension, fileName, wholeFileNameReplaced) {
            if (wholeFileNameReplaced) {
                return fileName;
            } else {
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        };

        TypeScriptCompiler.mapToJSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        };

        TypeScriptCompiler.prototype.emitDocumentWorker = function (document, emitOptions, emitter) {
            var sourceUnit = document.sourceUnit();
            TypeScript.Debug.assert(this._shouldEmit(document));

            var typeScriptFileName = document.fileName;
            if (!emitter) {
                var javaScriptFileName = this.mapOutputFileName(document, emitOptions, TypeScriptCompiler.mapToJSFileName);
                var outFile = new TypeScript.TextWriter(javaScriptFileName, this.writeByteOrderMarkForDocument(document), 0 /* JavaScript */);

                emitter = new TypeScript.Emitter(javaScriptFileName, outFile, emitOptions, this.semanticInfoChain);

                if (this.compilationSettings().mapSourceFiles()) {
                    var sourceMapFile = new TypeScript.TextWriter(javaScriptFileName + TypeScript.SourceMapper.MapFileExtension, false, 1 /* SourceMap */);
                    emitter.createSourceMapper(document, javaScriptFileName, outFile, sourceMapFile, emitOptions.resolvePath);
                }
            } else if (this.compilationSettings().mapSourceFiles()) {
                emitter.setSourceMapperNewSourceFile(document);
            }

            emitter.setDocument(document);
            emitter.emitJavascript(sourceUnit, false);

            return emitter;
        };

        TypeScriptCompiler.prototype._emitDocument = function (document, emitOptions, onSingleFileEmitComplete, sharedEmitter) {
            var start = new Date().getTime();

            if (this._shouldEmit(document)) {
                if (document.emitToOwnOutputFile()) {
                    var singleEmitter = this.emitDocumentWorker(document, emitOptions);
                    if (singleEmitter) {
                        onSingleFileEmitComplete(singleEmitter.getOutputFiles());
                    }
                } else {
                    sharedEmitter = this.emitDocumentWorker(document, emitOptions, sharedEmitter);
                }
            }

            TypeScript.emitTime += new Date().getTime() - start;
            return sharedEmitter;
        };

        TypeScriptCompiler.prototype.emitAll = function (resolvePath) {
            var emitOutput = new EmitOutput();

            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = 2 /* FailedBecauseOfCompilerOptionsErrors */;
                return emitOutput;
            }

            var fileNames = this.fileNames();
            var sharedEmitter = null;

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var document = this.getDocument(fileName);

                sharedEmitter = this._emitDocument(document, emitOptions, function (files) {
                    return emitOutput.outputFiles.push.apply(emitOutput.outputFiles, files);
                }, sharedEmitter);
            }

            if (sharedEmitter) {
                emitOutput.outputFiles.push.apply(emitOutput.outputFiles, sharedEmitter.getOutputFiles());
            }

            return emitOutput;
        };

        TypeScriptCompiler.prototype.emit = function (fileName, resolvePath) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var emitOutput = new EmitOutput();

            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = 2 /* FailedBecauseOfCompilerOptionsErrors */;
                return emitOutput;
            }

            var document = this.getDocument(fileName);

            if (document.emitToOwnOutputFile()) {
                this._emitDocument(document, emitOptions, function (files) {
                    return emitOutput.outputFiles.push.apply(emitOutput.outputFiles, files);
                }, null);
                return emitOutput;
            } else {
                return this.emitAll(resolvePath);
            }
        };

        TypeScriptCompiler.prototype.compile = function (resolvePath, continueOnDiagnostics) {
            if (typeof continueOnDiagnostics === "undefined") { continueOnDiagnostics = false; }
            return new CompilerIterator(this, resolvePath, continueOnDiagnostics);
        };

        TypeScriptCompiler.prototype.getSyntacticDiagnostics = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            return this.getDocument(fileName).diagnostics();
        };

        TypeScriptCompiler.prototype.getSyntaxTree = function (fileName) {
            return this.getDocument(fileName).syntaxTree();
        };

        TypeScriptCompiler.prototype.getSourceUnit = function (fileName) {
            return this.getDocument(fileName).sourceUnit();
        };

        TypeScriptCompiler.prototype.getSemanticDiagnostics = function (fileName) {
            fileName = TypeScript.switchToForwardSlashes(fileName);

            var document = this.getDocument(fileName);

            var startTime = (new Date()).getTime();
            TypeScript.PullTypeResolver.typeCheck(this.compilationSettings(), this.semanticInfoChain, document);
            var endTime = (new Date()).getTime();

            TypeScript.typeCheckTime += endTime - startTime;

            var errors = this.semanticInfoChain.getDiagnostics(fileName);

            errors = TypeScript.ArrayUtilities.distinct(errors, TypeScript.Diagnostic.equals);
            errors.sort(function (d1, d2) {
                if (d1.fileName() < d2.fileName()) {
                    return -1;
                } else if (d1.fileName() > d2.fileName()) {
                    return 1;
                }

                if (d1.start() < d2.start()) {
                    return -1;
                } else if (d1.start() > d2.start()) {
                    return 1;
                }

                var code1 = TypeScript.diagnosticInformationMap[d1.diagnosticKey()].code;
                var code2 = TypeScript.diagnosticInformationMap[d2.diagnosticKey()].code;
                if (code1 < code2) {
                    return -1;
                } else if (code1 > code2) {
                    return 1;
                }

                return 0;
            });

            return errors;
        };

        TypeScriptCompiler.prototype.getCompilerOptionsDiagnostics = function (resolvePath) {
            var emitOptions = new TypeScript.EmitOptions(this, resolvePath);
            var emitDiagnostic = emitOptions.diagnostic();
            if (emitDiagnostic) {
                return [emitDiagnostic];
            }
            return TypeScript.sentinelEmptyArray;
        };

        TypeScriptCompiler.prototype.resolveAllFiles = function () {
            var fileNames = this.fileNames();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                this.getSemanticDiagnostics(fileNames[i]);
            }
        };

        TypeScriptCompiler.prototype.getSymbolOfDeclaration = function (decl) {
            if (!decl) {
                return null;
            }

            var resolver = this.semanticInfoChain.getResolver();
            var ast = this.semanticInfoChain.getASTForDecl(decl);
            if (!ast) {
                return null;
            }

            var enclosingDecl = resolver.getEnclosingDecl(decl);
            if (ast.kind() === 140 /* GetAccessor */ || ast.kind() === 141 /* SetAccessor */) {
                return this.getSymbolOfDeclaration(enclosingDecl);
            }

            return resolver.resolveAST(ast, false, new TypeScript.PullTypeResolutionContext(resolver));
        };

        TypeScriptCompiler.prototype.extractResolutionContextFromAST = function (resolver, ast, document, propagateContextualTypes) {
            var scriptName = document.fileName;

            var enclosingDecl = null;
            var enclosingDeclAST = null;
            var inContextuallyTypedAssignment = false;
            var inWithBlock = false;

            var resolutionContext = new TypeScript.PullTypeResolutionContext(resolver);

            if (!ast) {
                return null;
            }

            var path = this.getASTPath(ast);

            for (var i = 0, n = path.length; i < n; i++) {
                var current = path[i];

                switch (current.kind()) {
                    case 223 /* FunctionExpression */:
                    case 220 /* SimpleArrowFunctionExpression */:
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                        if (propagateContextualTypes) {
                            resolver.resolveAST(current, true, resolutionContext);
                        }
                        break;

                    case 137 /* MemberVariableDeclaration */:
                        var memberVariable = current;
                        inContextuallyTypedAssignment = memberVariable.variableDeclarator.typeAnnotation !== null;

                        this.extractResolutionContextForVariable(inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, memberVariable, memberVariable.variableDeclarator.equalsValueClause);
                        break;

                    case 226 /* VariableDeclarator */:
                        var variableDeclarator = current;
                        inContextuallyTypedAssignment = variableDeclarator.typeAnnotation !== null;

                        this.extractResolutionContextForVariable(inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, variableDeclarator, variableDeclarator.equalsValueClause);
                        break;

                    case 214 /* InvocationExpression */:
                    case 217 /* ObjectCreationExpression */:
                        if (propagateContextualTypes) {
                            var isNew = current.kind() === 217 /* ObjectCreationExpression */;
                            var callExpression = current;
                            var contextualType = null;

                            if ((i + 2 < n) && callExpression.argumentList === path[i + 1] && callExpression.argumentList.arguments === path[i + 2]) {
                                var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                                if (isNew) {
                                    resolver.resolveObjectCreationExpression(callExpression, resolutionContext, callResolutionResults);
                                } else {
                                    resolver.resolveInvocationExpression(callExpression, resolutionContext, callResolutionResults);
                                }

                                if (callResolutionResults.actualParametersContextTypeSymbols) {
                                    var argExpression = path[i + 3];
                                    if (argExpression) {
                                        for (var j = 0, m = callExpression.argumentList.arguments.length; j < m; j++) {
                                            if (callExpression.argumentList.arguments[j] === argExpression) {
                                                var callContextualType = callResolutionResults.actualParametersContextTypeSymbols[j];
                                                if (callContextualType) {
                                                    contextualType = callContextualType;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (isNew) {
                                    resolver.resolveObjectCreationExpression(callExpression, resolutionContext);
                                } else {
                                    resolver.resolveInvocationExpression(callExpression, resolutionContext);
                                }
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case 215 /* ArrayLiteralExpression */:
                        if (propagateContextualTypes) {
                            var contextualType = null;
                            var currentContextualType = resolutionContext.getContextualType();
                            if (currentContextualType && currentContextualType.isArrayNamedTypeReference()) {
                                contextualType = currentContextualType.getElementType();
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case 216 /* ObjectLiteralExpression */:
                        if (propagateContextualTypes) {
                            var objectLiteralExpression = current;
                            var objectLiteralResolutionContext = new TypeScript.PullAdditionalObjectLiteralResolutionData();
                            resolver.resolveObjectLiteralExpression(objectLiteralExpression, inContextuallyTypedAssignment, resolutionContext, objectLiteralResolutionContext);

                            var memeberAST = (path[i + 1] && path[i + 1].kind() === 2 /* SeparatedList */) ? path[i + 2] : path[i + 1];
                            if (memeberAST) {
                                var contextualType = null;
                                var memberDecls = objectLiteralExpression.propertyAssignments;
                                if (memberDecls && objectLiteralResolutionContext.membersContextTypeSymbols) {
                                    for (var j = 0, m = memberDecls.length; j < m; j++) {
                                        if (memberDecls[j] === memeberAST) {
                                            var memberContextualType = objectLiteralResolutionContext.membersContextTypeSymbols[j];
                                            if (memberContextualType) {
                                                contextualType = memberContextualType;
                                                break;
                                            }
                                        }
                                    }
                                }

                                resolutionContext.pushNewContextualType(contextualType);
                            }
                        }

                        break;

                    case 175 /* AssignmentExpression */:
                        if (propagateContextualTypes) {
                            var assignmentExpression = current;
                            var contextualType = null;

                            if (path[i + 1] && path[i + 1] === assignmentExpression.right) {
                                var leftType = resolver.resolveAST(assignmentExpression.left, inContextuallyTypedAssignment, resolutionContext).type;
                                if (leftType) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = leftType;
                                }
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case 221 /* CastExpression */:
                        var castExpression = current;
                        if (!(i + 1 < n && path[i + 1] === castExpression.type)) {
                            if (propagateContextualTypes) {
                                var contextualType = null;
                                var typeSymbol = resolver.resolveAST(castExpression, inContextuallyTypedAssignment, resolutionContext).type;

                                if (typeSymbol) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = typeSymbol;
                                }

                                resolutionContext.pushNewContextualType(contextualType);
                            }
                        }

                        break;

                    case 151 /* ReturnStatement */:
                        if (propagateContextualTypes) {
                            var returnStatement = current;
                            var contextualType = null;

                            if (enclosingDecl && (enclosingDecl.kind & 1032192 /* SomeFunction */)) {
                                var typeAnnotation = TypeScript.ASTHelpers.getType(enclosingDeclAST);
                                if (typeAnnotation) {
                                    var returnTypeSymbol = resolver.resolveTypeReference(typeAnnotation, resolutionContext);
                                    if (returnTypeSymbol) {
                                        inContextuallyTypedAssignment = true;
                                        contextualType = returnTypeSymbol;
                                    }
                                } else {
                                    var currentContextualType = resolutionContext.getContextualType();
                                    if (currentContextualType && currentContextualType.isFunction()) {
                                        var contextualSignatures = currentContextualType.kind == 33554432 /* ConstructorType */ ? currentContextualType.getConstructSignatures() : currentContextualType.getCallSignatures();
                                        var currentContextualTypeSignatureSymbol = contextualSignatures[0];
                                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                                        if (currentContextualTypeReturnTypeSymbol) {
                                            inContextuallyTypedAssignment = true;
                                            contextualType = currentContextualTypeReturnTypeSymbol;
                                        }
                                    }
                                }
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case 122 /* ObjectType */:
                        if (propagateContextualTypes && TypeScript.isTypesOnlyLocation(current)) {
                            resolver.resolveAST(current, false, resolutionContext);
                        }

                        break;

                    case 164 /* WithStatement */:
                        inWithBlock = true;
                        break;

                    case 147 /* Block */:
                        inContextuallyTypedAssignment = false;
                        break;
                }

                var decl = this.semanticInfoChain.getDeclForAST(current);
                if (decl) {
                    enclosingDecl = decl;
                    enclosingDeclAST = current;
                }
            }

            if (ast && ast.parent && ast.kind() === 11 /* IdentifierName */) {
                if (ast.parent.kind() === 213 /* MemberAccessExpression */) {
                    if (ast.parent.name === ast) {
                        ast = ast.parent;
                    }
                } else if (ast.parent.kind() === 121 /* QualifiedName */) {
                    if (ast.parent.right === ast) {
                        ast = ast.parent;
                    }
                }
            }

            return {
                ast: ast,
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                inContextuallyTypedAssignment: inContextuallyTypedAssignment,
                inWithBlock: inWithBlock
            };
        };

        TypeScriptCompiler.prototype.extractResolutionContextForVariable = function (inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, assigningAST, init) {
            if (inContextuallyTypedAssignment) {
                if (propagateContextualTypes) {
                    resolver.resolveAST(assigningAST, false, resolutionContext);
                    var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST);

                    var contextualType = null;
                    if (varSymbol && inContextuallyTypedAssignment) {
                        contextualType = varSymbol.type;
                    }

                    resolutionContext.pushNewContextualType(contextualType);

                    if (init) {
                        resolver.resolveAST(init, inContextuallyTypedAssignment, resolutionContext);
                    }
                }
            }
        };

        TypeScriptCompiler.prototype.getASTPath = function (ast) {
            var result = [];

            while (ast) {
                result.unshift(ast);
                ast = ast.parent;
            }

            return result;
        };

        TypeScriptCompiler.prototype.pullGetSymbolInformationFromAST = function (ast, document) {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }

            ast = context.ast;
            var symbol = resolver.resolveAST(ast, context.inContextuallyTypedAssignment, context.resolutionContext);

            if (!symbol) {
                TypeScript.Debug.assert(ast.kind() === 120 /* SourceUnit */, "No symbol was found for ast and ast was not source unit. Ast Kind: " + TypeScript.SyntaxKind[ast.kind()]);
                return null;
            }

            if (symbol.isTypeReference()) {
                symbol = symbol.getReferencedTypeSymbol();
            }

            var aliasSymbol = this.semanticInfoChain.getAliasSymbolForAST(ast);

            return {
                symbol: symbol,
                aliasSymbol: aliasSymbol,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetCallInformationFromAST = function (ast, document) {
            if (ast.kind() !== 214 /* InvocationExpression */ && ast.kind() !== 217 /* ObjectCreationExpression */) {
                return null;
            }

            var isNew = ast.kind() === 217 /* ObjectCreationExpression */;

            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();

            if (isNew) {
                resolver.resolveObjectCreationExpression(ast, context.resolutionContext, callResolutionResults);
            } else {
                resolver.resolveInvocationExpression(ast, context.resolutionContext, callResolutionResults);
            }

            return {
                targetSymbol: callResolutionResults.targetSymbol,
                resolvedSignatures: callResolutionResults.resolvedSignatures,
                candidateSignature: callResolutionResults.candidateSignature,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl),
                isConstructorCall: isNew
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleMemberSymbolsFromAST = function (ast, document) {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var symbols = resolver.getVisibleMembersFromExpression(ast, context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }

            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleDeclsFromAST = function (ast, document) {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, false);
            if (!context || context.inWithBlock) {
                return null;
            }

            return resolver.getVisibleDecls(context.enclosingDecl);
        };

        TypeScriptCompiler.prototype.pullGetContextualMembersFromAST = function (ast, document) {
            if (ast.kind() !== 216 /* ObjectLiteralExpression */) {
                return null;
            }

            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var members = resolver.getVisibleContextSymbols(context.enclosingDecl, context.resolutionContext);

            return {
                symbols: members,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetDeclInformation = function (decl, ast, document) {
            var resolver = this.semanticInfoChain.getResolver();

            var context = this.extractResolutionContextFromAST(resolver, ast, document, true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var astForDecl = decl.ast();
            if (!astForDecl) {
                return null;
            }

            var astForDeclContext = this.extractResolutionContextFromAST(resolver, astForDecl, this.getDocument(TypeScript.syntaxTree(astForDecl).fileName()), true);
            if (!astForDeclContext) {
                return null;
            }

            var symbol = decl.getSymbol(this.semanticInfoChain);
            resolver.resolveDeclaredSymbol(symbol, context.resolutionContext);
            symbol.setUnresolved();

            return {
                symbol: symbol,
                aliasSymbol: null,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.topLevelDeclaration = function (fileName) {
            return this.semanticInfoChain.topLevelDecl(fileName);
        };

        TypeScriptCompiler.prototype.getDeclForAST = function (ast) {
            return this.semanticInfoChain.getDeclForAST(ast);
        };

        TypeScriptCompiler.prototype.fileNames = function () {
            return this.semanticInfoChain.fileNames();
        };

        TypeScriptCompiler.prototype.topLevelDecl = function (fileName) {
            return this.semanticInfoChain.topLevelDecl(fileName);
        };

        TypeScriptCompiler.getLocationText = function (location, resolvePath) {
            return resolvePath(location.fileName()) + "(" + (location.line() + 1) + "," + (location.character() + 1) + ")";
        };

        TypeScriptCompiler.getFullDiagnosticText = function (diagnostic, resolvePath) {
            var result = "";
            if (diagnostic.fileName()) {
                result += this.getLocationText(diagnostic, resolvePath) + ": ";
            }

            result += diagnostic.message();

            var additionalLocations = diagnostic.additionalLocations();
            if (additionalLocations.length > 0) {
                result += " " + TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Additional_locations, null) + TypeScript.Environment.newLine;

                for (var i = 0, n = additionalLocations.length; i < n; i++) {
                    result += "\t" + this.getLocationText(additionalLocations[i], resolvePath) + TypeScript.Environment.newLine;
                }
            } else {
                result += TypeScript.Environment.newLine;
            }

            return result;
        };
        return TypeScriptCompiler;
    })();
    TypeScript.TypeScriptCompiler = TypeScriptCompiler;

    var CompilerPhase;
    (function (CompilerPhase) {
        CompilerPhase[CompilerPhase["Syntax"] = 0] = "Syntax";
        CompilerPhase[CompilerPhase["Semantics"] = 1] = "Semantics";
        CompilerPhase[CompilerPhase["EmitOptionsValidation"] = 2] = "EmitOptionsValidation";
        CompilerPhase[CompilerPhase["Emit"] = 3] = "Emit";
        CompilerPhase[CompilerPhase["DeclarationEmit"] = 4] = "DeclarationEmit";
    })(CompilerPhase || (CompilerPhase = {}));

    var CompilerIterator = (function () {
        function CompilerIterator(compiler, resolvePath, continueOnDiagnostics, startingPhase) {
            if (typeof startingPhase === "undefined") { startingPhase = 0 /* Syntax */; }
            this.compiler = compiler;
            this.resolvePath = resolvePath;
            this.continueOnDiagnostics = continueOnDiagnostics;
            this.index = -1;
            this.fileNames = null;
            this._current = null;
            this._emitOptions = null;
            this._sharedEmitter = null;
            this._sharedDeclarationEmitter = null;
            this.hadSyntacticDiagnostics = false;
            this.hadSemanticDiagnostics = false;
            this.hadEmitDiagnostics = false;
            this.fileNames = compiler.fileNames();
            this.compilerPhase = startingPhase;
        }
        CompilerIterator.prototype.current = function () {
            return this._current;
        };

        CompilerIterator.prototype.moveNext = function () {
            this._current = null;

            while (this.moveNextInternal()) {
                if (this._current) {
                    return true;
                }
            }

            return false;
        };

        CompilerIterator.prototype.moveNextInternal = function () {
            this.index++;

            while (this.shouldMoveToNextPhase()) {
                this.index = 0;
                this.compilerPhase++;
            }

            if (this.compilerPhase > 4 /* DeclarationEmit */) {
                return false;
            }

            switch (this.compilerPhase) {
                case 0 /* Syntax */:
                    return this.moveNextSyntaxPhase();
                case 1 /* Semantics */:
                    return this.moveNextSemanticsPhase();
                case 2 /* EmitOptionsValidation */:
                    return this.moveNextEmitOptionsValidationPhase();
                case 3 /* Emit */:
                    return this.moveNextEmitPhase();
                case 4 /* DeclarationEmit */:
                    return this.moveNextDeclarationEmitPhase();
            }
        };

        CompilerIterator.prototype.shouldMoveToNextPhase = function () {
            switch (this.compilerPhase) {
                case 2 /* EmitOptionsValidation */:
                    return this.index === 1;

                case 0 /* Syntax */:
                case 1 /* Semantics */:
                    return this.index === this.fileNames.length;

                case 3 /* Emit */:
                case 4 /* DeclarationEmit */:
                    return this.index === (this.fileNames.length + 1);
            }

            return false;
        };

        CompilerIterator.prototype.moveNextSyntaxPhase = function () {
            TypeScript.Debug.assert(this.index >= 0 && this.index < this.fileNames.length);
            var fileName = this.fileNames[this.index];

            var diagnostics = this.compiler.getSyntacticDiagnostics(fileName);
            if (diagnostics.length) {
                if (!this.continueOnDiagnostics) {
                    this.hadSyntacticDiagnostics = true;
                }

                this._current = CompileResult.fromDiagnostics(diagnostics);
            }

            return true;
        };

        CompilerIterator.prototype.moveNextSemanticsPhase = function () {
            if (this.hadSyntacticDiagnostics) {
                return false;
            }

            TypeScript.Debug.assert(this.index >= 0 && this.index < this.fileNames.length);
            var fileName = this.fileNames[this.index];
            var diagnostics = this.compiler.getSemanticDiagnostics(fileName);
            if (diagnostics.length) {
                if (!this.continueOnDiagnostics) {
                    this.hadSemanticDiagnostics = true;
                }

                this._current = CompileResult.fromDiagnostics(diagnostics);
            }

            return true;
        };

        CompilerIterator.prototype.moveNextEmitOptionsValidationPhase = function () {
            TypeScript.Debug.assert(!this.hadSyntacticDiagnostics);

            if (!this._emitOptions) {
                this._emitOptions = new TypeScript.EmitOptions(this.compiler, this.resolvePath);
            }

            if (this._emitOptions.diagnostic()) {
                if (!this.continueOnDiagnostics) {
                    this.hadEmitDiagnostics = true;
                }

                this._current = CompileResult.fromDiagnostics([this._emitOptions.diagnostic()]);
            }

            return true;
        };

        CompilerIterator.prototype.moveNextEmitPhase = function () {
            var _this = this;
            TypeScript.Debug.assert(!this.hadSyntacticDiagnostics);
            TypeScript.Debug.assert(this._emitOptions);

            if (this.hadEmitDiagnostics) {
                return false;
            }

            TypeScript.Debug.assert(this.index >= 0 && this.index <= this.fileNames.length);
            if (this.index < this.fileNames.length) {
                var fileName = this.fileNames[this.index];
                var document = this.compiler.getDocument(fileName);

                this._sharedEmitter = this.compiler._emitDocument(document, this._emitOptions, function (outputFiles) {
                    _this._current = CompileResult.fromOutputFiles(outputFiles);
                }, this._sharedEmitter);
                return true;
            }

            if (this.index === this.fileNames.length && this._sharedEmitter) {
                this._current = CompileResult.fromOutputFiles(this._sharedEmitter.getOutputFiles());
            }

            return true;
        };

        CompilerIterator.prototype.moveNextDeclarationEmitPhase = function () {
            var _this = this;
            TypeScript.Debug.assert(!this.hadSyntacticDiagnostics);
            TypeScript.Debug.assert(!this.hadEmitDiagnostics);
            if (this.hadSemanticDiagnostics) {
                return false;
            }

            if (!this.compiler.compilationSettings().generateDeclarationFiles()) {
                return false;
            }

            TypeScript.Debug.assert(this.index >= 0 && this.index <= this.fileNames.length);
            if (this.index < this.fileNames.length) {
                var fileName = this.fileNames[this.index];
                var document = this.compiler.getDocument(fileName);

                this._sharedDeclarationEmitter = this.compiler._emitDocumentDeclarations(document, this._emitOptions, function (file) {
                    _this._current = CompileResult.fromOutputFiles([file]);
                }, this._sharedDeclarationEmitter);
                return true;
            }

            if (this.index === this.fileNames.length && this._sharedDeclarationEmitter) {
                this._current = CompileResult.fromOutputFiles([this._sharedDeclarationEmitter.getOutputFile()]);
            }

            return true;
        };
        return CompilerIterator;
    })();

    function compareDataObjects(dst, src) {
        for (var e in dst) {
            if (typeof dst[e] === "object") {
                if (!compareDataObjects(dst[e], src[e]))
                    return false;
            } else if (typeof dst[e] !== "function") {
                if (dst[e] !== src[e])
                    return false;
            }
        }
        return true;
    }
    TypeScript.compareDataObjects = compareDataObjects;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (GenerativeTypeClassification) {
        GenerativeTypeClassification[GenerativeTypeClassification["Unknown"] = 0] = "Unknown";
        GenerativeTypeClassification[GenerativeTypeClassification["Open"] = 1] = "Open";
        GenerativeTypeClassification[GenerativeTypeClassification["Closed"] = 2] = "Closed";
        GenerativeTypeClassification[GenerativeTypeClassification["InfinitelyExpanding"] = 3] = "InfinitelyExpanding";
    })(TypeScript.GenerativeTypeClassification || (TypeScript.GenerativeTypeClassification = {}));
    var GenerativeTypeClassification = TypeScript.GenerativeTypeClassification;

    var TypeReferenceSymbol = (function (_super) {
        __extends(TypeReferenceSymbol, _super);
        function TypeReferenceSymbol(referencedTypeSymbol) {
            _super.call(this, referencedTypeSymbol.name, referencedTypeSymbol.kind, referencedTypeSymbol.semanticInfoChain);
            this.referencedTypeSymbol = referencedTypeSymbol;
            this.isResolved = true;

            TypeScript.Debug.assert(referencedTypeSymbol !== null, "Type root symbol may not be null");

            this.setRootSymbol(referencedTypeSymbol);

            this.typeReference = this;
        }
        TypeReferenceSymbol.createTypeReference = function (type) {
            if (type.isTypeReference()) {
                return type;
            }

            var typeReference = type.typeReference;

            if (!typeReference) {
                typeReference = new TypeReferenceSymbol(type);
                type.typeReference = typeReference;
            }

            return typeReference;
        };

        TypeReferenceSymbol.prototype.isTypeReference = function () {
            return true;
        };

        TypeReferenceSymbol.prototype.setResolved = function () {
        };

        TypeReferenceSymbol.prototype.setUnresolved = function () {
        };
        TypeReferenceSymbol.prototype.invalidate = function () {
        };

        TypeReferenceSymbol.prototype.ensureReferencedTypeIsResolved = function () {
            this._getResolver().resolveDeclaredSymbol(this.referencedTypeSymbol);
        };

        TypeReferenceSymbol.prototype.getReferencedTypeSymbol = function () {
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol;
        };

        TypeReferenceSymbol.prototype._getResolver = function () {
            return this.referencedTypeSymbol._getResolver();
        };

        TypeReferenceSymbol.prototype.hasMembers = function () {
            return this.referencedTypeSymbol.hasMembers();
        };

        TypeReferenceSymbol.prototype.setAssociatedContainerType = function (type) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": setAssociatedContainerType");
        };

        TypeReferenceSymbol.prototype.getAssociatedContainerType = function () {
            return this.referencedTypeSymbol.getAssociatedContainerType();
        };

        TypeReferenceSymbol.prototype.getFunctionSymbol = function () {
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.getFunctionSymbol();
        };
        TypeReferenceSymbol.prototype.setFunctionSymbol = function (symbol) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": setFunctionSymbol");
        };

        TypeReferenceSymbol.prototype.addContainedNonMember = function (nonMember) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addContainedNonMember");
        };
        TypeReferenceSymbol.prototype.findContainedNonMemberContainer = function (containerName, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findContainedNonMemberContainer(containerName, kind);
        };

        TypeReferenceSymbol.prototype.addMember = function (memberSymbol) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addMember");
        };
        TypeReferenceSymbol.prototype.addEnclosedMemberType = function (enclosedType) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedMemberType");
        };
        TypeReferenceSymbol.prototype.addEnclosedMemberContainer = function (enclosedContainer) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedMemberContainer");
        };
        TypeReferenceSymbol.prototype.addEnclosedNonMember = function (enclosedNonMember) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMember");
        };
        TypeReferenceSymbol.prototype.addEnclosedNonMemberType = function (enclosedNonMemberType) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMemberType");
        };
        TypeReferenceSymbol.prototype.addEnclosedNonMemberContainer = function (enclosedNonMemberContainer) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMemberContainer");
        };
        TypeReferenceSymbol.prototype.addTypeParameter = function (typeParameter) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addTypeParameter");
        };
        TypeReferenceSymbol.prototype.addConstructorTypeParameter = function (typeParameter) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addConstructorTypeParameter");
        };

        TypeReferenceSymbol.prototype.findContainedNonMember = function (name) {
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findContainedNonMember(name);
        };

        TypeReferenceSymbol.prototype.findContainedNonMemberType = function (typeName, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findContainedNonMemberType(typeName, kind);
        };

        TypeReferenceSymbol.prototype.getMembers = function () {
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.getMembers();
        };

        TypeReferenceSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (typeof hasOne === "undefined") { hasOne = true; }
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ":setHasDefaultConstructor");
        };
        TypeReferenceSymbol.prototype.getHasDefaultConstructor = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getHasDefaultConstructor();
        };
        TypeReferenceSymbol.prototype.getConstructorMethod = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getConstructorMethod();
        };
        TypeReferenceSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": setConstructorMethod");
        };
        TypeReferenceSymbol.prototype.getTypeParameters = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeParameters();
        };

        TypeReferenceSymbol.prototype.isGeneric = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.isGeneric();
        };

        TypeReferenceSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.addSpecialization(specializedVersionOfThisType, substitutingTypes);
        };
        TypeReferenceSymbol.prototype.getSpecialization = function (substitutingTypes) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getSpecialization(substitutingTypes);
        };
        TypeReferenceSymbol.prototype.getKnownSpecializations = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getKnownSpecializations();
        };
        TypeReferenceSymbol.prototype.getTypeArguments = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeArguments();
        };
        TypeReferenceSymbol.prototype.getTypeArgumentsOrTypeParameters = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeArgumentsOrTypeParameters();
        };

        TypeReferenceSymbol.prototype.appendCallSignature = function (callSignature) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": appendCallSignature");
        };
        TypeReferenceSymbol.prototype.insertCallSignatureAtIndex = function (callSignature, index) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": insertCallSignatureAtIndex");
        };
        TypeReferenceSymbol.prototype.appendConstructSignature = function (callSignature) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": appendConstructSignature");
        };
        TypeReferenceSymbol.prototype.insertConstructSignatureAtIndex = function (callSignature, index) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": insertConstructSignatureAtIndex");
        };
        TypeReferenceSymbol.prototype.addIndexSignature = function (indexSignature) {
            TypeScript.Debug.fail("Reference symbol " + this.pullSymbolID + ": addIndexSignature");
        };

        TypeReferenceSymbol.prototype.hasOwnCallSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnCallSignatures();
        };
        TypeReferenceSymbol.prototype.getCallSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getCallSignatures();
        };
        TypeReferenceSymbol.prototype.hasOwnConstructSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnConstructSignatures();
        };
        TypeReferenceSymbol.prototype.getConstructSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getConstructSignatures();
        };
        TypeReferenceSymbol.prototype.hasOwnIndexSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnIndexSignatures();
        };
        TypeReferenceSymbol.prototype.getIndexSignatures = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getIndexSignatures();
        };

        TypeReferenceSymbol.prototype.addImplementedType = function (implementedType) {
            this.referencedTypeSymbol.addImplementedType(implementedType);
        };
        TypeReferenceSymbol.prototype.getImplementedTypes = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getImplementedTypes();
        };
        TypeReferenceSymbol.prototype.addExtendedType = function (extendedType) {
            this.referencedTypeSymbol.addExtendedType(extendedType);
        };
        TypeReferenceSymbol.prototype.getExtendedTypes = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getExtendedTypes();
        };
        TypeReferenceSymbol.prototype.addTypeThatExtendsThisType = function (type) {
            this.referencedTypeSymbol.addTypeThatExtendsThisType(type);
        };
        TypeReferenceSymbol.prototype.getTypesThatExtendThisType = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypesThatExtendThisType();
        };
        TypeReferenceSymbol.prototype.addTypeThatExplicitlyImplementsThisType = function (type) {
            this.referencedTypeSymbol.addTypeThatExplicitlyImplementsThisType(type);
        };
        TypeReferenceSymbol.prototype.getTypesThatExplicitlyImplementThisType = function () {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypesThatExplicitlyImplementThisType();
        };

        TypeReferenceSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.isValidBaseKind(baseType, isExtendedType);
        };

        TypeReferenceSymbol.prototype.findMember = function (name, lookInParent) {
            if (typeof lookInParent === "undefined") { lookInParent = true; }
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findMember(name, lookInParent);
        };
        TypeReferenceSymbol.prototype.findNestedType = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findNestedType(name, kind);
        };
        TypeReferenceSymbol.prototype.findNestedContainer = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findNestedContainer(name, kind);
        };
        TypeReferenceSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisiblity) {
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);
        };

        TypeReferenceSymbol.prototype.findTypeParameter = function (name) {
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findTypeParameter(name);
        };

        TypeReferenceSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            return this.referencedTypeSymbol.hasOnlyOverloadCallSignatures();
        };
        return TypeReferenceSymbol;
    })(TypeScript.PullTypeSymbol);
    TypeScript.TypeReferenceSymbol = TypeReferenceSymbol;

    TypeScript.nSpecializationsCreated = 0;
    TypeScript.nSpecializedSignaturesCreated = 0;
    TypeScript.nSpecializedTypeParameterCreated = 0;

    var InstantiatedTypeReferenceSymbol = (function (_super) {
        __extends(InstantiatedTypeReferenceSymbol, _super);
        function InstantiatedTypeReferenceSymbol(referencedTypeSymbol, _typeParameterSubstitutionMap, isInstanceReferenceType) {
            _super.call(this, referencedTypeSymbol);
            this.referencedTypeSymbol = referencedTypeSymbol;
            this._typeParameterSubstitutionMap = _typeParameterSubstitutionMap;
            this.isInstanceReferenceType = isInstanceReferenceType;
            this._instantiatedMembers = null;
            this._allInstantiatedMemberNameCache = null;
            this._instantiatedMemberNameCache = TypeScript.createIntrinsicsObject();
            this._instantiatedCallSignatures = null;
            this._instantiatedConstructSignatures = null;
            this._instantiatedIndexSignatures = null;
            this._typeArgumentReferences = undefined;
            this._instantiatedConstructorMethod = null;
            this._instantiatedAssociatedContainerType = null;
            this._isArray = undefined;
            this._generativeTypeClassification = [];

            TypeScript.nSpecializationsCreated++;
        }
        InstantiatedTypeReferenceSymbol.prototype.getIsSpecialized = function () {
            return !this.isInstanceReferenceType;
        };

        InstantiatedTypeReferenceSymbol.prototype.getGenerativeTypeClassification = function (enclosingType) {
            if (!this.isNamedTypeSymbol()) {
                return 0 /* Unknown */;
            }

            var generativeTypeClassification = this._generativeTypeClassification[enclosingType.pullSymbolID] || 0 /* Unknown */;
            if (generativeTypeClassification === 0 /* Unknown */) {
                var typeParameters = enclosingType.getTypeParameters();
                var enclosingTypeParameterMap = [];
                for (var i = 0; i < typeParameters.length; i++) {
                    enclosingTypeParameterMap[typeParameters[i].pullSymbolID] = typeParameters[i];
                }

                var typeArguments = this.getTypeArguments();
                for (var i = 0; i < typeArguments.length; i++) {
                    if (typeArguments[i].wrapsSomeTypeParameter(enclosingTypeParameterMap, true)) {
                        generativeTypeClassification = 1 /* Open */;
                        break;
                    }
                }

                if (generativeTypeClassification === 1 /* Open */) {
                    if (this.wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType)) {
                        generativeTypeClassification = 3 /* InfinitelyExpanding */;
                    }
                } else {
                    generativeTypeClassification = 2 /* Closed */;
                }

                this._generativeTypeClassification[enclosingType.pullSymbolID] = generativeTypeClassification;
            }

            return generativeTypeClassification;
        };

        InstantiatedTypeReferenceSymbol.prototype.isArrayNamedTypeReference = function () {
            if (this._isArray === undefined) {
                this._isArray = this.getRootSymbol().isArrayNamedTypeReference() || (this.getRootSymbol() === this._getResolver().getArrayNamedType());
            }
            return this._isArray;
        };

        InstantiatedTypeReferenceSymbol.prototype.getElementType = function () {
            if (!this.isArrayNamedTypeReference()) {
                return null;
            }

            var typeArguments = this.getTypeArguments();
            return typeArguments ? typeArguments[0] : null;
        };

        InstantiatedTypeReferenceSymbol.prototype.getReferencedTypeSymbol = function () {
            this.ensureReferencedTypeIsResolved();

            if (this.getIsSpecialized()) {
                return this;
            }

            return this.referencedTypeSymbol;
        };

        InstantiatedTypeReferenceSymbol.create = function (resolver, type, typeParameterSubstitutionMap) {
            TypeScript.Debug.assert(resolver);

            var mutableTypeParameterMap = new TypeScript.PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(typeParameterSubstitutionMap);

            TypeScript.PullInstantiationHelpers.instantiateTypeArgument(resolver, type, mutableTypeParameterMap);

            var rootType = type.getRootSymbol();
            var instantiation = rootType.getSpecialization(mutableTypeParameterMap.typeParameterSubstitutionMap);
            if (instantiation) {
                return instantiation;
            }

            TypeScript.PullInstantiationHelpers.cleanUpTypeParameterSubstitutionMap(type, mutableTypeParameterMap);
            typeParameterSubstitutionMap = mutableTypeParameterMap.typeParameterSubstitutionMap;

            var isInstanceReferenceType = (type.kind & 8216 /* SomeInstantiatableType */) != 0;
            var resolvedTypeParameterArgumentMap = typeParameterSubstitutionMap;
            if (isInstanceReferenceType) {
                var typeParameters = rootType.getTypeParameters();
                for (var i = 0; i < typeParameters.length; i++) {
                    if (!TypeScript.PullHelpers.typeSymbolsAreIdentical(typeParameters[i], typeParameterSubstitutionMap[typeParameters[i].pullSymbolID])) {
                        isInstanceReferenceType = false;
                        break;
                    }
                }

                if (isInstanceReferenceType) {
                    typeParameterSubstitutionMap = [];
                }
            }

            instantiation = new InstantiatedTypeReferenceSymbol(rootType, typeParameterSubstitutionMap, isInstanceReferenceType);

            rootType.addSpecialization(instantiation, resolvedTypeParameterArgumentMap);

            return instantiation;
        };

        InstantiatedTypeReferenceSymbol.prototype.isGeneric = function () {
            return this.getRootSymbol().isGeneric();
        };

        InstantiatedTypeReferenceSymbol.prototype.getTypeParameterSubstitutionMap = function () {
            return this._typeParameterSubstitutionMap;
        };

        InstantiatedTypeReferenceSymbol.prototype.getTypeArguments = function () {
            if (this.isInstanceReferenceType) {
                return this.getTypeParameters();
            }

            if (this._typeArgumentReferences === undefined) {
                var typeParameters = this.referencedTypeSymbol.getTypeParameters();

                if (typeParameters.length) {
                    var typeArgument = null;
                    var typeArguments = [];

                    for (var i = 0; i < typeParameters.length; i++) {
                        typeArgument = this._typeParameterSubstitutionMap[typeParameters[i].pullSymbolID];

                        if (!typeArgument) {
                            TypeScript.Debug.fail("type argument count mismatch");
                        }

                        if (typeArgument) {
                            typeArguments[typeArguments.length] = typeArgument;
                        }
                    }

                    this._typeArgumentReferences = typeArguments;
                } else {
                    this._typeArgumentReferences = null;
                }
            }

            return this._typeArgumentReferences;
        };

        InstantiatedTypeReferenceSymbol.prototype.getTypeArgumentsOrTypeParameters = function () {
            return this.getTypeArguments();
        };

        InstantiatedTypeReferenceSymbol.prototype.populateInstantiatedMemberFromReferencedMember = function (referencedMember) {
            var instantiatedMember;
            TypeScript.PullHelpers.resolveDeclaredSymbolToUseType(referencedMember);

            if (!referencedMember.type.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                instantiatedMember = referencedMember;
            } else {
                instantiatedMember = new TypeScript.PullSymbol(referencedMember.name, referencedMember.kind, referencedMember.semanticInfoChain);
                instantiatedMember.setRootSymbol(referencedMember);
                instantiatedMember.type = this._getResolver().instantiateType(referencedMember.type, this._typeParameterSubstitutionMap);
                instantiatedMember.isOptional = referencedMember.isOptional;
            }
            this._instantiatedMemberNameCache[instantiatedMember.name] = instantiatedMember;
        };

        InstantiatedTypeReferenceSymbol.prototype.getMembers = function () {
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getMembers();
            }

            if (!this._instantiatedMembers) {
                var referencedMembers = this.referencedTypeSymbol.getMembers();
                var referencedMember = null;
                var instantiatedMember = null;

                this._instantiatedMembers = [];

                for (var i = 0; i < referencedMembers.length; i++) {
                    referencedMember = referencedMembers[i];

                    this._getResolver().resolveDeclaredSymbol(referencedMember);

                    if (!this._instantiatedMemberNameCache[referencedMember.name]) {
                        this.populateInstantiatedMemberFromReferencedMember(referencedMember);
                    }

                    this._instantiatedMembers[this._instantiatedMembers.length] = this._instantiatedMemberNameCache[referencedMember.name];
                }
            }

            return this._instantiatedMembers;
        };

        InstantiatedTypeReferenceSymbol.prototype.findMember = function (name, lookInParent) {
            if (typeof lookInParent === "undefined") { lookInParent = true; }
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.findMember(name, lookInParent);
            }

            var memberSymbol = this._instantiatedMemberNameCache[name];

            if (!memberSymbol) {
                var referencedMemberSymbol = this.referencedTypeSymbol.findMember(name, lookInParent);

                if (referencedMemberSymbol) {
                    this.populateInstantiatedMemberFromReferencedMember(referencedMemberSymbol);
                    memberSymbol = this._instantiatedMemberNameCache[name];
                } else {
                    memberSymbol = null;
                }
            }

            return memberSymbol;
        };

        InstantiatedTypeReferenceSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisiblity) {
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);
            }

            var requestedMembers = [];
            var allReferencedMembers = this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);

            if (!this._allInstantiatedMemberNameCache) {
                this._allInstantiatedMemberNameCache = TypeScript.createIntrinsicsObject();

                var members = this.getMembers();

                for (var i = 0; i < members.length; i++) {
                    this._allInstantiatedMemberNameCache[members[i].name] = members[i];
                }
            }

            var referencedMember = null;
            var requestedMember = null;

            for (var i = 0; i < allReferencedMembers.length; i++) {
                referencedMember = allReferencedMembers[i];

                this._getResolver().resolveDeclaredSymbol(referencedMember);

                if (this._allInstantiatedMemberNameCache[referencedMember.name]) {
                    requestedMembers[requestedMembers.length] = this._allInstantiatedMemberNameCache[referencedMember.name];
                } else {
                    if (!referencedMember.type.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                        this._allInstantiatedMemberNameCache[referencedMember.name] = referencedMember;
                        requestedMembers[requestedMembers.length] = referencedMember;
                    } else {
                        requestedMember = new TypeScript.PullSymbol(referencedMember.name, referencedMember.kind, referencedMember.semanticInfoChain);
                        requestedMember.setRootSymbol(referencedMember);

                        requestedMember.type = this._getResolver().instantiateType(referencedMember.type, this._typeParameterSubstitutionMap);
                        requestedMember.isOptional = referencedMember.isOptional;

                        this._allInstantiatedMemberNameCache[requestedMember.name] = requestedMember;
                        requestedMembers[requestedMembers.length] = requestedMember;
                    }
                }
            }

            return requestedMembers;
        };

        InstantiatedTypeReferenceSymbol.prototype.getConstructorMethod = function () {
            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getConstructorMethod();
            }

            if (!this._instantiatedConstructorMethod) {
                var referencedConstructorMethod = this.referencedTypeSymbol.getConstructorMethod();
                this._instantiatedConstructorMethod = new TypeScript.PullSymbol(referencedConstructorMethod.name, referencedConstructorMethod.kind, referencedConstructorMethod.semanticInfoChain);
                this._instantiatedConstructorMethod.setRootSymbol(referencedConstructorMethod);
                this._instantiatedConstructorMethod.setResolved();

                this._instantiatedConstructorMethod.type = InstantiatedTypeReferenceSymbol.create(this._getResolver(), referencedConstructorMethod.type, this._typeParameterSubstitutionMap);
            }

            return this._instantiatedConstructorMethod;
        };

        InstantiatedTypeReferenceSymbol.prototype.getAssociatedContainerType = function () {
            if (!this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getAssociatedContainerType();
            }

            if (!this._instantiatedAssociatedContainerType) {
                var referencedAssociatedContainerType = this.referencedTypeSymbol.getAssociatedContainerType();

                if (referencedAssociatedContainerType) {
                    this._instantiatedAssociatedContainerType = InstantiatedTypeReferenceSymbol.create(this._getResolver(), referencedAssociatedContainerType, this._typeParameterSubstitutionMap);
                }
            }

            return this._instantiatedAssociatedContainerType;
        };

        InstantiatedTypeReferenceSymbol.prototype.getCallSignatures = function () {
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getCallSignatures();
            }

            if (this._instantiatedCallSignatures) {
                return this._instantiatedCallSignatures;
            }

            var referencedCallSignatures = this.referencedTypeSymbol.getCallSignatures();
            this._instantiatedCallSignatures = [];

            for (var i = 0; i < referencedCallSignatures.length; i++) {
                var referencedSignature = referencedCallSignatures[i];
                this._getResolver().resolveDeclaredSymbol(referencedSignature);

                if (!referencedSignature.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length] = referencedSignature;
                } else {
                    var signatureTypeParameterSubstitutionMap = this.augmentSignatureSubstitutionMapWithSynthesizedTypeParameters(referencedSignature);
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length] = this._getResolver().getOrCreateSignatureWithSubstitution(referencedSignature, signatureTypeParameterSubstitutionMap);
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length - 1].functionType = this;
                }
            }

            return this._instantiatedCallSignatures;
        };

        InstantiatedTypeReferenceSymbol.prototype.getConstructSignatures = function () {
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getConstructSignatures();
            }

            if (this._instantiatedConstructSignatures) {
                return this._instantiatedConstructSignatures;
            }

            var referencedConstructSignatures = this.referencedTypeSymbol.getConstructSignatures();
            this._instantiatedConstructSignatures = [];

            for (var i = 0; i < referencedConstructSignatures.length; i++) {
                var referencedSignature = referencedConstructSignatures[i];
                this._getResolver().resolveDeclaredSymbol(referencedSignature);

                if (!referencedSignature.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                    this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = referencedSignature;
                } else {
                    if (this.isConstructor()) {
                        var signatureTypeParameterArgumentMap = this._typeParameterSubstitutionMap;
                        this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = this._getResolver().instantiateSignature(referencedSignature, signatureTypeParameterArgumentMap);
                    } else {
                        var signatureTypeParameterArgumentMap = this.augmentSignatureSubstitutionMapWithSynthesizedTypeParameters(referencedSignature);
                        this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = this._getResolver().getOrCreateSignatureWithSubstitution(referencedSignature, signatureTypeParameterArgumentMap);
                    }
                    this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length - 1].functionType = this;
                }
            }

            return this._instantiatedConstructSignatures;
        };

        InstantiatedTypeReferenceSymbol.prototype.augmentSignatureSubstitutionMapWithSynthesizedTypeParameters = function (referencedSignature) {
            if (referencedSignature.isGeneric()) {
                var signaturesOwnTypeParameters = referencedSignature.getTypeParameters();
                var newOwnTypeParameters = new Array(signaturesOwnTypeParameters.length);
                for (var i = 0; i < signaturesOwnTypeParameters.length; i++) {
                    var ownRootTypeParameter = signaturesOwnTypeParameters[i];

                    TypeScript.Debug.assert(ownRootTypeParameter.getRootSymbol() === ownRootTypeParameter);
                    newOwnTypeParameters[i] = new SynthesizedTypeParameterSymbol(ownRootTypeParameter, this._typeParameterSubstitutionMap);
                }

                var signaturesOwnTypeArgumentMap = new TypeScript.PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(this._typeParameterSubstitutionMap);
                for (var i = 0; i < signaturesOwnTypeParameters.length; i++) {
                    signaturesOwnTypeArgumentMap.ensureCopyOfUnderlyingMap();
                    signaturesOwnTypeArgumentMap.typeParameterSubstitutionMap[signaturesOwnTypeParameters[i].pullSymbolID] = newOwnTypeParameters[i];
                }
                return signaturesOwnTypeArgumentMap.typeParameterSubstitutionMap;
            } else {
                return this._typeParameterSubstitutionMap;
            }
        };

        InstantiatedTypeReferenceSymbol.prototype.getIndexSignatures = function () {
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getIndexSignatures();
            }

            if (this._instantiatedIndexSignatures) {
                return this._instantiatedIndexSignatures;
            }

            var referencedIndexSignatures = this.referencedTypeSymbol.getIndexSignatures();
            this._instantiatedIndexSignatures = [];

            for (var i = 0; i < referencedIndexSignatures.length; i++) {
                this._getResolver().resolveDeclaredSymbol(referencedIndexSignatures[i]);

                if (!referencedIndexSignatures[i].wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length] = referencedIndexSignatures[i];
                } else {
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length] = this._getResolver().getOrCreateSignatureWithSubstitution(referencedIndexSignatures[i], this._typeParameterSubstitutionMap);
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length - 1].functionType = this;
                }
            }

            return this._instantiatedIndexSignatures;
        };
        return InstantiatedTypeReferenceSymbol;
    })(TypeReferenceSymbol);
    TypeScript.InstantiatedTypeReferenceSymbol = InstantiatedTypeReferenceSymbol;

    var InstantiatedSignatureSymbol = (function (_super) {
        __extends(InstantiatedSignatureSymbol, _super);
        function InstantiatedSignatureSymbol(rootSignature, _typeParameterSubstitutionMap) {
            _super.call(this, rootSignature.kind, rootSignature.semanticInfoChain, rootSignature.isDefinition());
            this._typeParameterSubstitutionMap = _typeParameterSubstitutionMap;
            this.setRootSymbol(rootSignature);
            TypeScript.nSpecializedSignaturesCreated++;

            rootSignature.addSpecialization(this, _typeParameterSubstitutionMap);
        }
        InstantiatedSignatureSymbol.prototype.getTypeParameterSubstitutionMap = function () {
            return this._typeParameterSubstitutionMap;
        };

        InstantiatedSignatureSymbol.prototype.getIsSpecialized = function () {
            return true;
        };

        InstantiatedSignatureSymbol.prototype.getIsInstantiated = function () {
            return true;
        };

        InstantiatedSignatureSymbol.prototype._getResolver = function () {
            return this.getRootSymbol()._getResolver();
        };

        InstantiatedSignatureSymbol.prototype.getTypeParameters = function () {
            return TypeScript.sentinelEmptyArray;
        };

        InstantiatedSignatureSymbol.prototype.getAllowedToReferenceTypeParameters = function () {
            var rootSymbol = this.getRootSymbol();
            return rootSymbol.getAllowedToReferenceTypeParameters();
        };
        return InstantiatedSignatureSymbol;
    })(TypeScript.PullSignatureSymbol);
    TypeScript.InstantiatedSignatureSymbol = InstantiatedSignatureSymbol;

    var SignatureSymbolWithSubstitution = (function (_super) {
        __extends(SignatureSymbolWithSubstitution, _super);
        function SignatureSymbolWithSubstitution(rootSignature, _typeParameterSubstitutionMap) {
            _super.call(this, rootSignature.kind, rootSignature.semanticInfoChain, rootSignature.isDefinition());
            this._typeParameterSubstitutionMap = _typeParameterSubstitutionMap;
            this.setRootSymbol(rootSignature);
            TypeScript.nSpecializedSignaturesCreated++;

            rootSignature.addSpecialization(this, _typeParameterSubstitutionMap);
        }
        SignatureSymbolWithSubstitution.prototype.getTypeParameterSubstitutionMap = function () {
            return this._typeParameterSubstitutionMap;
        };

        SignatureSymbolWithSubstitution.prototype.getIsSpecialized = function () {
            return true;
        };

        SignatureSymbolWithSubstitution.prototype._getResolver = function () {
            return this.getRootSymbol()._getResolver();
        };

        SignatureSymbolWithSubstitution.prototype.getTypeParameters = function () {
            if (!this._typeParameters) {
                var rootSymbol = this.getRootSymbol();
                var rootTypeParameters = rootSymbol.getTypeParameters();

                if (rootTypeParameters.length) {
                    this._typeParameters = [];
                    for (var i = 0; i < rootTypeParameters.length; i++) {
                        var typeParameterSubstitution = this._typeParameterSubstitutionMap[rootTypeParameters[i].pullSymbolID];
                        this._typeParameters[this._typeParameters.length] = typeParameterSubstitution || rootTypeParameters[i];
                    }
                } else {
                    this._typeParameters = TypeScript.sentinelEmptyArray;
                }
            }

            return this._typeParameters;
        };

        SignatureSymbolWithSubstitution.prototype.getAllowedToReferenceTypeParameters = function () {
            var rootSymbol = this.getRootSymbol();
            return rootSymbol.getAllowedToReferenceTypeParameters();
        };
        return SignatureSymbolWithSubstitution;
    })(TypeScript.PullSignatureSymbol);
    TypeScript.SignatureSymbolWithSubstitution = SignatureSymbolWithSubstitution;

    var SynthesizedTypeParameterSymbol = (function (_super) {
        __extends(SynthesizedTypeParameterSymbol, _super);
        function SynthesizedTypeParameterSymbol(originalTypeParameter, _typeParameterSubstitutionMapForConstraint) {
            _super.call(this, originalTypeParameter.name, originalTypeParameter.semanticInfoChain);
            this.originalTypeParameter = originalTypeParameter;
            this._typeParameterSubstitutionMapForConstraint = _typeParameterSubstitutionMapForConstraint;
            var originalTypeParameterDeclarations = originalTypeParameter.getDeclarations();
            for (var i = 0; i < originalTypeParameterDeclarations.length; i++) {
                this.addDeclaration(originalTypeParameterDeclarations[i]);
            }
        }
        SynthesizedTypeParameterSymbol.prototype._getResolver = function () {
            return this.originalTypeParameter._getResolver();
        };

        SynthesizedTypeParameterSymbol.prototype.getConstraint = function () {
            var constraint = _super.prototype.getConstraint.call(this);
            if (!constraint) {
                var originalConstraint = this.originalTypeParameter.getConstraint();
                if (originalConstraint) {
                    constraint = this._getResolver().instantiateType(originalConstraint, this._typeParameterSubstitutionMapForConstraint);
                    this.setConstraint(constraint);
                }
            }
            return constraint;
        };
        return SynthesizedTypeParameterSymbol;
    })(TypeScript.PullTypeParameterSymbol);
    TypeScript.SynthesizedTypeParameterSymbol = SynthesizedTypeParameterSymbol;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (IncrementalParser) {
        function createParserSource(oldSyntaxTree, textChangeRange, text) {
            var fileName = oldSyntaxTree.fileName();
            var languageVersion = oldSyntaxTree.languageVersion();

            var _scannerParserSource;

            var _changeRange;

            var _changeRangeNewSpan;

            var _changeDelta = 0;

            var _oldSourceUnitCursor = getSyntaxCursor();
            var oldSourceUnit = oldSyntaxTree.sourceUnit();

            var _outstandingRewindPointCount = 0;

            if (oldSourceUnit.moduleElements.length > 0) {
                _oldSourceUnitCursor.pushElement(TypeScript.childAt(oldSourceUnit.moduleElements, 0), 0);
            }

            _changeRange = extendToAffectedRange(textChangeRange, oldSourceUnit);
            _changeRangeNewSpan = _changeRange.newSpan();

            if (TypeScript.Debug.shouldAssert(2 /* Aggressive */)) {
                TypeScript.Debug.assert((TypeScript.fullWidth(oldSourceUnit) - _changeRange.span().length() + _changeRange.newLength()) === text.length());
            }

            _scannerParserSource = TypeScript.Scanner.createParserSource(oldSyntaxTree.fileName(), text, oldSyntaxTree.languageVersion());

            function release() {
                _scannerParserSource.release();
                _scannerParserSource = null;
                _oldSourceUnitCursor = null;
                _outstandingRewindPointCount = 0;
            }

            function extendToAffectedRange(changeRange, sourceUnit) {
                var maxLookahead = 1;

                var start = changeRange.span().start();

                for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                    var token = TypeScript.findToken(sourceUnit, start);

                    var position = token.fullStart();

                    start = Math.max(0, position - 1);
                }

                var finalSpan = TypeScript.TextSpan.fromBounds(start, changeRange.span().end());
                var finalLength = changeRange.newLength() + (changeRange.span().start() - start);

                return new TypeScript.TextChangeRange(finalSpan, finalLength);
            }

            function absolutePosition() {
                return _scannerParserSource.absolutePosition();
            }

            function tokenDiagnostics() {
                return _scannerParserSource.tokenDiagnostics();
            }

            function getRewindPoint() {
                var rewindPoint = _scannerParserSource.getRewindPoint();

                var oldSourceUnitCursorClone = cloneSyntaxCursor(_oldSourceUnitCursor);

                rewindPoint.changeDelta = _changeDelta;
                rewindPoint.changeRange = _changeRange;
                rewindPoint.oldSourceUnitCursor = _oldSourceUnitCursor;

                _oldSourceUnitCursor = oldSourceUnitCursorClone;

                _outstandingRewindPointCount++;
                return rewindPoint;
            }

            function rewind(rewindPoint) {
                _changeRange = rewindPoint.changeRange;
                _changeDelta = rewindPoint.changeDelta;

                returnSyntaxCursor(_oldSourceUnitCursor);
                _oldSourceUnitCursor = rewindPoint.oldSourceUnitCursor;

                rewindPoint.oldSourceUnitCursor = null;

                _scannerParserSource.rewind(rewindPoint);
            }

            function releaseRewindPoint(rewindPoint) {
                if (rewindPoint.oldSourceUnitCursor !== null) {
                    returnSyntaxCursor(rewindPoint.oldSourceUnitCursor);
                }

                _scannerParserSource.releaseRewindPoint(rewindPoint);
                _outstandingRewindPointCount--;
                TypeScript.Debug.assert(_outstandingRewindPointCount >= 0);
            }

            function isPinned() {
                return _outstandingRewindPointCount > 0;
            }

            function canReadFromOldSourceUnit() {
                if (isPinned()) {
                    return false;
                }

                if (_changeRange !== null && _changeRangeNewSpan.intersectsWithPosition(absolutePosition())) {
                    return false;
                }

                syncCursorToNewTextIfBehind();

                return _changeDelta === 0 && !_oldSourceUnitCursor.isFinished();
            }

            function updateTokens(nodeOrToken) {
                var position = absolutePosition();
                var tokenWasMoved = isPastChangeRange() && TypeScript.fullStart(nodeOrToken) !== position;

                if (tokenWasMoved) {
                    setTokenFullStartWalker.position = position;

                    TypeScript.visitNodeOrToken(setTokenFullStartWalker, nodeOrToken);
                }
            }

            function currentNode() {
                if (canReadFromOldSourceUnit()) {
                    var node = tryGetNodeFromOldSourceUnit();
                    if (node !== null) {
                        updateTokens(node);
                        return node;
                    }
                }

                return null;
            }

            function currentToken() {
                if (canReadFromOldSourceUnit()) {
                    var token = tryGetTokenFromOldSourceUnit();
                    if (token !== null) {
                        updateTokens(token);
                        return token;
                    }
                }

                return _scannerParserSource.currentToken();
            }

            function currentContextualToken() {
                return _scannerParserSource.currentContextualToken();
            }

            function syncCursorToNewTextIfBehind() {
                while (true) {
                    if (_oldSourceUnitCursor.isFinished()) {
                        break;
                    }

                    if (_changeDelta >= 0) {
                        break;
                    }

                    var currentNodeOrToken = _oldSourceUnitCursor.currentNodeOrToken();

                    if (TypeScript.isNode(currentNodeOrToken) && (TypeScript.fullWidth(currentNodeOrToken) > Math.abs(_changeDelta))) {
                        _oldSourceUnitCursor.moveToFirstChild();
                    } else {
                        _oldSourceUnitCursor.moveToNextSibling();

                        _changeDelta += TypeScript.fullWidth(currentNodeOrToken);
                    }
                }
            }

            function intersectsWithChangeRangeSpanInOriginalText(start, length) {
                return !isPastChangeRange() && _changeRange.span().intersectsWith(start, length);
            }

            function tryGetNodeFromOldSourceUnit() {
                while (true) {
                    var node = _oldSourceUnitCursor.currentNode();
                    if (node === null) {
                        return null;
                    }

                    if (!intersectsWithChangeRangeSpanInOriginalText(absolutePosition(), TypeScript.fullWidth(node))) {
                        var isIncrementallyUnusuable = TypeScript.isIncrementallyUnusable(node);
                        if (!isIncrementallyUnusuable) {
                            return node;
                        }
                    }

                    _oldSourceUnitCursor.moveToFirstChild();
                }
            }

            function canReuseTokenFromOldSourceUnit(position, token) {
                if (token !== null) {
                    if (!intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                        if (!token.isIncrementallyUnusable() && !TypeScript.Scanner.isContextualToken(token)) {
                            return true;
                        }
                    }
                }

                return false;
            }

            function tryGetTokenFromOldSourceUnit() {
                var token = _oldSourceUnitCursor.currentToken();

                return canReuseTokenFromOldSourceUnit(absolutePosition(), token) ? token : null;
            }

            function peekToken(n) {
                if (canReadFromOldSourceUnit()) {
                    var token = tryPeekTokenFromOldSourceUnit(n);
                    if (token !== null) {
                        return token;
                    }
                }

                return _scannerParserSource.peekToken(n);
            }

            function tryPeekTokenFromOldSourceUnit(n) {
                var cursorClone = cloneSyntaxCursor(_oldSourceUnitCursor);

                var token = tryPeekTokenFromOldSourceUnitWorker(n);

                returnSyntaxCursor(_oldSourceUnitCursor);
                _oldSourceUnitCursor = cursorClone;

                return token;
            }

            function tryPeekTokenFromOldSourceUnitWorker(n) {
                var currentPosition = absolutePosition();

                _oldSourceUnitCursor.moveToFirstToken();

                for (var i = 0; i < n; i++) {
                    var interimToken = _oldSourceUnitCursor.currentToken();

                    if (!canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                        return null;
                    }

                    currentPosition += interimToken.fullWidth();
                    _oldSourceUnitCursor.moveToNextSibling();
                }

                var token = _oldSourceUnitCursor.currentToken();
                return canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : null;
            }

            function consumeNode(node) {
                _oldSourceUnitCursor.moveToNextSibling();

                var _absolutePosition = absolutePosition() + TypeScript.fullWidth(node);
                _scannerParserSource.resetToPosition(_absolutePosition);
            }

            function consumeToken(currentToken) {
                if (_oldSourceUnitCursor.currentToken() === currentToken) {
                    _oldSourceUnitCursor.moveToNextSibling();

                    var _absolutePosition = absolutePosition() + currentToken.fullWidth();
                    _scannerParserSource.resetToPosition(_absolutePosition);
                } else {
                    _changeDelta -= currentToken.fullWidth();

                    _scannerParserSource.consumeToken(currentToken);

                    if (!isPastChangeRange()) {
                        if (absolutePosition() >= _changeRangeNewSpan.end()) {
                            _changeDelta += _changeRange.newLength() - _changeRange.span().length();

                            _changeRange = null;
                        }
                    }
                }
            }

            function isPastChangeRange() {
                return _changeRange === null;
            }

            return {
                text: text,
                fileName: fileName,
                languageVersion: languageVersion,
                currentNode: currentNode,
                currentToken: currentToken,
                currentContextualToken: currentContextualToken,
                peekToken: peekToken,
                consumeNode: consumeNode,
                consumeToken: consumeToken,
                getRewindPoint: getRewindPoint,
                rewind: rewind,
                releaseRewindPoint: releaseRewindPoint,
                tokenDiagnostics: tokenDiagnostics,
                release: release
            };
        }

        function createSyntaxCursorPiece(element, indexInParent) {
            return { element: element, indexInParent: indexInParent };
        }

        var syntaxCursorPool = [];
        var syntaxCursorPoolCount = 0;

        function returnSyntaxCursor(cursor) {
            cursor.clean();

            syntaxCursorPool[syntaxCursorPoolCount] = cursor;
            syntaxCursorPoolCount++;
        }

        function getSyntaxCursor() {
            var cursor = syntaxCursorPoolCount > 0 ? syntaxCursorPool[syntaxCursorPoolCount - 1] : createSyntaxCursor();

            if (syntaxCursorPoolCount > 0) {
                syntaxCursorPoolCount--;
                syntaxCursorPool[syntaxCursorPoolCount] = null;
            }

            return cursor;
        }

        function cloneSyntaxCursor(cursor) {
            var newCursor = getSyntaxCursor();

            newCursor.deepCopyFrom(cursor);

            return newCursor;
        }

        function createSyntaxCursor() {
            var pieces = [];
            var currentPieceIndex = -1;

            function clean() {
                for (var i = 0, n = pieces.length; i < n; i++) {
                    var piece = pieces[i];

                    if (piece.element === null) {
                        break;
                    }

                    piece.element = null;
                    piece.indexInParent = -1;
                }

                currentPieceIndex = -1;
            }

            function deepCopyFrom(other) {
                for (var i = 0, n = other.pieces.length; i < n; i++) {
                    var piece = other.pieces[i];

                    if (piece.element === null) {
                        break;
                    }

                    pushElement(piece.element, piece.indexInParent);
                }
            }

            function isFinished() {
                return currentPieceIndex < 0;
            }

            function currentNodeOrToken() {
                if (isFinished()) {
                    return null;
                }

                var result = pieces[currentPieceIndex].element;

                return result;
            }

            function currentNode() {
                var element = currentNodeOrToken();
                return TypeScript.isNode(element) ? element : null;
            }

            function moveToFirstChild() {
                var nodeOrToken = currentNodeOrToken();
                if (nodeOrToken === null) {
                    return;
                }

                if (TypeScript.isToken(nodeOrToken)) {
                    return;
                }

                for (var i = 0, n = TypeScript.childCount(nodeOrToken); i < n; i++) {
                    var child = TypeScript.childAt(nodeOrToken, i);
                    if (child !== null && !TypeScript.isShared(child)) {
                        pushElement(child, i);

                        moveToFirstChildIfList();
                        return;
                    }
                }

                moveToNextSibling();
            }

            function moveToNextSibling() {
                while (!isFinished()) {
                    var currentPiece = pieces[currentPieceIndex];
                    var parent = currentPiece.element.parent;

                    for (var i = currentPiece.indexInParent + 1, n = TypeScript.childCount(parent); i < n; i++) {
                        var sibling = TypeScript.childAt(parent, i);

                        if (sibling !== null && !TypeScript.isShared(sibling)) {
                            currentPiece.element = sibling;
                            currentPiece.indexInParent = i;

                            moveToFirstChildIfList();
                            return;
                        }
                    }

                    currentPiece.element = null;
                    currentPiece.indexInParent = -1;

                    currentPieceIndex--;
                }
            }

            function moveToFirstChildIfList() {
                var element = pieces[currentPieceIndex].element;

                if (TypeScript.isList(element) || TypeScript.isSeparatedList(element)) {
                    pushElement(TypeScript.childAt(element, 0), 0);
                }
            }

            function pushElement(element, indexInParent) {
                currentPieceIndex++;

                if (currentPieceIndex === pieces.length) {
                    pieces.push(createSyntaxCursorPiece(element, indexInParent));
                } else {
                    var piece = pieces[currentPieceIndex];
                    piece.element = element;
                    piece.indexInParent = indexInParent;
                }
            }

            function moveToFirstToken() {
                while (!isFinished()) {
                    var element = pieces[currentPieceIndex].element;
                    if (TypeScript.isNode(element)) {
                        moveToFirstChild();
                        continue;
                    }

                    return;
                }
            }

            function currentToken() {
                moveToFirstToken();

                var element = currentNodeOrToken();

                return element === null ? null : element;
            }

            return {
                pieces: pieces,
                clean: clean,
                isFinished: isFinished,
                moveToFirstChild: moveToFirstChild,
                moveToFirstToken: moveToFirstToken,
                moveToNextSibling: moveToNextSibling,
                currentNodeOrToken: currentNodeOrToken,
                currentNode: currentNode,
                currentToken: currentToken,
                pushElement: pushElement,
                deepCopyFrom: deepCopyFrom
            };
        }

        var SetTokenFullStartWalker = (function (_super) {
            __extends(SetTokenFullStartWalker, _super);
            function SetTokenFullStartWalker() {
                _super.apply(this, arguments);
            }
            SetTokenFullStartWalker.prototype.visitToken = function (token) {
                var position = this.position;
                token.setFullStart(position);

                this.position = position + token.fullWidth();
            };
            return SetTokenFullStartWalker;
        })(TypeScript.SyntaxWalker);

        var setTokenFullStartWalker = new SetTokenFullStartWalker();

        function parse(oldSyntaxTree, textChangeRange, newText) {
            TypeScript.Debug.assert(oldSyntaxTree.isConcrete(), "Can only incrementally parse a concrete syntax tree.");
            if (textChangeRange.isUnchanged()) {
                return oldSyntaxTree;
            }

            return TypeScript.Parser.parseSource(createParserSource(oldSyntaxTree, textChangeRange, newText), oldSyntaxTree.isDeclaration());
        }
        IncrementalParser.parse = parse;
    })(TypeScript.IncrementalParser || (TypeScript.IncrementalParser = {}));
    var IncrementalParser = TypeScript.IncrementalParser;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        TypeScript.Document.incrementalParse = TypeScript.IncrementalParser.parse;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function isSeparatedListTypeScriptSpecific(list) {
        for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
            if (isTypeScriptSpecific(TypeScript.childAt(list, i))) {
                return true;
            }
        }

        return false;
    }

    function isListTypeScriptSpecific(list) {
        for (var i = 0, n = list.length; i < n; i++) {
            if (isTypeScriptSpecific(list[i])) {
                return true;
            }
        }

        return false;
    }

    function isTypeScriptSpecific(element) {
        if (element === null) {
            return false;
        }
        if (TypeScript.isToken(element)) {
            return false;
        }
        if (TypeScript.isList(element)) {
            return isListTypeScriptSpecific(element);
        }
        if (TypeScript.isSeparatedList(element)) {
            return isSeparatedListTypeScriptSpecific(element);
        }

        switch (element.kind()) {
            case 121 /* QualifiedName */:
            case 122 /* ObjectType */:
            case 123 /* FunctionType */:
            case 124 /* ArrayType */:
            case 125 /* ConstructorType */:
            case 126 /* GenericType */:
            case 127 /* TypeQuery */:
            case 128 /* TupleType */:
            case 129 /* InterfaceDeclaration */:
            case 131 /* ModuleDeclaration */:
            case 132 /* ClassDeclaration */:
            case 133 /* EnumDeclaration */:
            case 134 /* ImportDeclaration */:
            case 135 /* ExportAssignment */:
            case 136 /* MemberFunctionDeclaration */:
            case 137 /* MemberVariableDeclaration */:
            case 138 /* ConstructorDeclaration */:
            case 139 /* IndexMemberDeclaration */:
            case 141 /* SetAccessor */:
            case 142 /* PropertySignature */:
            case 144 /* ConstructSignature */:
            case 145 /* IndexSignature */:
            case 219 /* ParenthesizedArrowFunctionExpression */:
            case 220 /* SimpleArrowFunctionExpression */:
            case 221 /* CastExpression */:
            case 229 /* TypeArgumentList */:
            case 230 /* TypeParameterList */:
            case 231 /* ExtendsHeritageClause */:
            case 232 /* ImplementsHeritageClause */:
            case 239 /* TypeParameter */:
            case 240 /* Constraint */:
            case 245 /* TypeAnnotation */:
            case 246 /* ExternalModuleReference */:
            case 247 /* ModuleNameModuleReference */:
                return true;
            case 153 /* BreakStatement */:
            case 154 /* ContinueStatement */:
            case 157 /* EmptyStatement */:
            case 163 /* DebuggerStatement */:
            case 224 /* OmittedExpression */:
                return false;
            case 120 /* SourceUnit */:
                return isSourceUnitTypeScriptSpecific(element);
            case 130 /* FunctionDeclaration */:
                return isFunctionDeclarationTypeScriptSpecific(element);
            case 140 /* GetAccessor */:
                return isGetAccessorTypeScriptSpecific(element);
            case 143 /* CallSignature */:
                return isCallSignatureTypeScriptSpecific(element);
            case 146 /* MethodSignature */:
                return isMethodSignatureTypeScriptSpecific(element);
            case 147 /* Block */:
                return isBlockTypeScriptSpecific(element);
            case 148 /* IfStatement */:
                return isIfStatementTypeScriptSpecific(element);
            case 149 /* VariableStatement */:
                return isVariableStatementTypeScriptSpecific(element);
            case 150 /* ExpressionStatement */:
                return isExpressionStatementTypeScriptSpecific(element);
            case 151 /* ReturnStatement */:
                return isReturnStatementTypeScriptSpecific(element);
            case 152 /* SwitchStatement */:
                return isSwitchStatementTypeScriptSpecific(element);
            case 155 /* ForStatement */:
                return isForStatementTypeScriptSpecific(element);
            case 156 /* ForInStatement */:
                return isForInStatementTypeScriptSpecific(element);
            case 158 /* ThrowStatement */:
                return isThrowStatementTypeScriptSpecific(element);
            case 159 /* WhileStatement */:
                return isWhileStatementTypeScriptSpecific(element);
            case 160 /* TryStatement */:
                return isTryStatementTypeScriptSpecific(element);
            case 161 /* LabeledStatement */:
                return isLabeledStatementTypeScriptSpecific(element);
            case 162 /* DoStatement */:
                return isDoStatementTypeScriptSpecific(element);
            case 164 /* WithStatement */:
                return isWithStatementTypeScriptSpecific(element);
            case 169 /* PreIncrementExpression */:
            case 170 /* PreDecrementExpression */:
            case 165 /* PlusExpression */:
            case 166 /* NegateExpression */:
            case 167 /* BitwiseNotExpression */:
            case 168 /* LogicalNotExpression */:
                return isPrefixUnaryExpressionTypeScriptSpecific(element);
            case 171 /* DeleteExpression */:
                return isDeleteExpressionTypeScriptSpecific(element);
            case 172 /* TypeOfExpression */:
                return isTypeOfExpressionTypeScriptSpecific(element);
            case 173 /* VoidExpression */:
                return isVoidExpressionTypeScriptSpecific(element);
            case 187 /* ConditionalExpression */:
                return isConditionalExpressionTypeScriptSpecific(element);
            case 206 /* MultiplyExpression */:
            case 207 /* DivideExpression */:
            case 208 /* ModuloExpression */:
            case 209 /* AddExpression */:
            case 210 /* SubtractExpression */:
            case 203 /* LeftShiftExpression */:
            case 204 /* SignedRightShiftExpression */:
            case 205 /* UnsignedRightShiftExpression */:
            case 197 /* LessThanExpression */:
            case 198 /* GreaterThanExpression */:
            case 199 /* LessThanOrEqualExpression */:
            case 200 /* GreaterThanOrEqualExpression */:
            case 201 /* InstanceOfExpression */:
            case 202 /* InExpression */:
            case 193 /* EqualsWithTypeConversionExpression */:
            case 194 /* NotEqualsWithTypeConversionExpression */:
            case 195 /* EqualsExpression */:
            case 196 /* NotEqualsExpression */:
            case 192 /* BitwiseAndExpression */:
            case 191 /* BitwiseExclusiveOrExpression */:
            case 190 /* BitwiseOrExpression */:
            case 189 /* LogicalAndExpression */:
            case 188 /* LogicalOrExpression */:
            case 183 /* OrAssignmentExpression */:
            case 181 /* AndAssignmentExpression */:
            case 182 /* ExclusiveOrAssignmentExpression */:
            case 184 /* LeftShiftAssignmentExpression */:
            case 185 /* SignedRightShiftAssignmentExpression */:
            case 186 /* UnsignedRightShiftAssignmentExpression */:
            case 176 /* AddAssignmentExpression */:
            case 177 /* SubtractAssignmentExpression */:
            case 178 /* MultiplyAssignmentExpression */:
            case 179 /* DivideAssignmentExpression */:
            case 180 /* ModuloAssignmentExpression */:
            case 175 /* AssignmentExpression */:
            case 174 /* CommaExpression */:
                return isBinaryExpressionTypeScriptSpecific(element);
            case 211 /* PostIncrementExpression */:
            case 212 /* PostDecrementExpression */:
                return isPostfixUnaryExpressionTypeScriptSpecific(element);
            case 213 /* MemberAccessExpression */:
                return isMemberAccessExpressionTypeScriptSpecific(element);
            case 214 /* InvocationExpression */:
                return isInvocationExpressionTypeScriptSpecific(element);
            case 215 /* ArrayLiteralExpression */:
                return isArrayLiteralExpressionTypeScriptSpecific(element);
            case 216 /* ObjectLiteralExpression */:
                return isObjectLiteralExpressionTypeScriptSpecific(element);
            case 217 /* ObjectCreationExpression */:
                return isObjectCreationExpressionTypeScriptSpecific(element);
            case 218 /* ParenthesizedExpression */:
                return isParenthesizedExpressionTypeScriptSpecific(element);
            case 222 /* ElementAccessExpression */:
                return isElementAccessExpressionTypeScriptSpecific(element);
            case 223 /* FunctionExpression */:
                return isFunctionExpressionTypeScriptSpecific(element);
            case 225 /* VariableDeclaration */:
                return isVariableDeclarationTypeScriptSpecific(element);
            case 226 /* VariableDeclarator */:
                return isVariableDeclaratorTypeScriptSpecific(element);
            case 227 /* ArgumentList */:
                return isArgumentListTypeScriptSpecific(element);
            case 228 /* ParameterList */:
                return isParameterListTypeScriptSpecific(element);
            case 233 /* EqualsValueClause */:
                return isEqualsValueClauseTypeScriptSpecific(element);
            case 234 /* CaseSwitchClause */:
                return isCaseSwitchClauseTypeScriptSpecific(element);
            case 235 /* DefaultSwitchClause */:
                return isDefaultSwitchClauseTypeScriptSpecific(element);
            case 236 /* ElseClause */:
                return isElseClauseTypeScriptSpecific(element);
            case 237 /* CatchClause */:
                return isCatchClauseTypeScriptSpecific(element);
            case 238 /* FinallyClause */:
                return isFinallyClauseTypeScriptSpecific(element);
            case 241 /* SimplePropertyAssignment */:
                return isSimplePropertyAssignmentTypeScriptSpecific(element);
            case 242 /* FunctionPropertyAssignment */:
                return isFunctionPropertyAssignmentTypeScriptSpecific(element);
            case 243 /* Parameter */:
                return isParameterTypeScriptSpecific(element);
            case 244 /* EnumElement */:
                return isEnumElementTypeScriptSpecific(element);
        }
    }
    TypeScript.isTypeScriptSpecific = isTypeScriptSpecific;

    function isSourceUnitTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.moduleElements);
    }

    function isFunctionDeclarationTypeScriptSpecific(node) {
        return node.modifiers.length > 0 || isTypeScriptSpecific(node.callSignature) || isTypeScriptSpecific(node.block);
    }

    function isGetAccessorTypeScriptSpecific(node) {
        return node.modifiers.length > 0 || isTypeScriptSpecific(node.callSignature) || isTypeScriptSpecific(node.block);
    }

    function isCallSignatureTypeScriptSpecific(node) {
        return node.typeParameterList !== null || isTypeScriptSpecific(node.parameterList) || node.typeAnnotation !== null;
    }

    function isMethodSignatureTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.callSignature);
    }

    function isBlockTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.statements);
    }

    function isIfStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.condition) || isTypeScriptSpecific(node.statement) || isTypeScriptSpecific(node.elseClause);
    }

    function isVariableStatementTypeScriptSpecific(node) {
        return node.modifiers.length > 0 || isTypeScriptSpecific(node.variableDeclaration);
    }

    function isExpressionStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isReturnStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isSwitchStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression) || isTypeScriptSpecific(node.switchClauses);
    }

    function isForStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.variableDeclaration) || isTypeScriptSpecific(node.initializer) || isTypeScriptSpecific(node.condition) || isTypeScriptSpecific(node.incrementor) || isTypeScriptSpecific(node.statement);
    }

    function isForInStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.variableDeclaration) || isTypeScriptSpecific(node.left) || isTypeScriptSpecific(node.expression) || isTypeScriptSpecific(node.statement);
    }

    function isThrowStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isWhileStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.condition) || isTypeScriptSpecific(node.statement);
    }

    function isTryStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.block) || isTypeScriptSpecific(node.catchClause) || isTypeScriptSpecific(node.finallyClause);
    }

    function isLabeledStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.statement);
    }

    function isDoStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.statement) || isTypeScriptSpecific(node.condition);
    }

    function isWithStatementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.condition) || isTypeScriptSpecific(node.statement);
    }

    function isPrefixUnaryExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.operand);
    }

    function isDeleteExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isTypeOfExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isVoidExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isConditionalExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.condition) || isTypeScriptSpecific(node.whenTrue) || isTypeScriptSpecific(node.whenFalse);
    }

    function isBinaryExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.left) || isTypeScriptSpecific(node.right);
    }

    function isPostfixUnaryExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.operand);
    }

    function isMemberAccessExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isInvocationExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression) || isTypeScriptSpecific(node.argumentList);
    }

    function isArrayLiteralExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expressions);
    }

    function isObjectLiteralExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.propertyAssignments);
    }

    function isObjectCreationExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression) || isTypeScriptSpecific(node.argumentList);
    }

    function isParenthesizedExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isElementAccessExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression) || isTypeScriptSpecific(node.argumentExpression);
    }

    function isFunctionExpressionTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.callSignature) || isTypeScriptSpecific(node.block);
    }

    function isVariableDeclarationTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.variableDeclarators);
    }

    function isVariableDeclaratorTypeScriptSpecific(node) {
        return node.typeAnnotation !== null || isTypeScriptSpecific(node.equalsValueClause);
    }

    function isArgumentListTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.typeArgumentList) || isTypeScriptSpecific(node.arguments);
    }

    function isParameterListTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.parameters);
    }

    function isEqualsValueClauseTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.value);
    }

    function isCaseSwitchClauseTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression) || isTypeScriptSpecific(node.statements);
    }

    function isDefaultSwitchClauseTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.statements);
    }

    function isElseClauseTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.statement);
    }

    function isCatchClauseTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.typeAnnotation) || isTypeScriptSpecific(node.block);
    }

    function isFinallyClauseTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.block);
    }

    function isSimplePropertyAssignmentTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.expression);
    }

    function isFunctionPropertyAssignmentTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.callSignature) || isTypeScriptSpecific(node.block);
    }

    function isParameterTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.modifiers) || node.typeAnnotation !== null || node.equalsValueClause !== null;
    }

    function isEnumElementTypeScriptSpecific(node) {
        return isTypeScriptSpecific(node.equalsValueClause);
    }
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (EndOfLineState) {
            EndOfLineState[EndOfLineState["Start"] = 0] = "Start";
            EndOfLineState[EndOfLineState["InMultiLineCommentTrivia"] = 1] = "InMultiLineCommentTrivia";
            EndOfLineState[EndOfLineState["InSingleQuoteStringLiteral"] = 2] = "InSingleQuoteStringLiteral";
            EndOfLineState[EndOfLineState["InDoubleQuoteStringLiteral"] = 3] = "InDoubleQuoteStringLiteral";
        })(Services.EndOfLineState || (Services.EndOfLineState = {}));
        var EndOfLineState = Services.EndOfLineState;

        (function (TokenClass) {
            TokenClass[TokenClass["Punctuation"] = 0] = "Punctuation";
            TokenClass[TokenClass["Keyword"] = 1] = "Keyword";
            TokenClass[TokenClass["Operator"] = 2] = "Operator";
            TokenClass[TokenClass["Comment"] = 3] = "Comment";
            TokenClass[TokenClass["Whitespace"] = 4] = "Whitespace";
            TokenClass[TokenClass["Identifier"] = 5] = "Identifier";
            TokenClass[TokenClass["NumberLiteral"] = 6] = "NumberLiteral";
            TokenClass[TokenClass["StringLiteral"] = 7] = "StringLiteral";
            TokenClass[TokenClass["RegExpLiteral"] = 8] = "RegExpLiteral";
        })(Services.TokenClass || (Services.TokenClass = {}));
        var TokenClass = Services.TokenClass;

        var noRegexTable = [];
        noRegexTable[11 /* IdentifierName */] = true;
        noRegexTable[14 /* StringLiteral */] = true;
        noRegexTable[13 /* NumericLiteral */] = true;
        noRegexTable[12 /* RegularExpressionLiteral */] = true;
        noRegexTable[35 /* ThisKeyword */] = true;
        noRegexTable[93 /* PlusPlusToken */] = true;
        noRegexTable[94 /* MinusMinusToken */] = true;
        noRegexTable[73 /* CloseParenToken */] = true;
        noRegexTable[75 /* CloseBracketToken */] = true;
        noRegexTable[71 /* CloseBraceToken */] = true;
        noRegexTable[37 /* TrueKeyword */] = true;
        noRegexTable[24 /* FalseKeyword */] = true;

        var Classifier = (function () {
            function Classifier(host) {
                var _this = this;
                this.host = host;
                this.lastDiagnosticKey = null;
                this.reportDiagnostic = function (position, fullWidth, key, args) {
                    _this.lastDiagnosticKey = key;
                };
            }
            Classifier.prototype.getClassificationsForLine = function (text, lexState) {
                var offset = 0;
                if (lexState !== 0 /* Start */) {
                    if (lexState === 3 /* InDoubleQuoteStringLiteral */) {
                        text = '"\\\n' + text;
                    } else if (lexState === 2 /* InSingleQuoteStringLiteral */) {
                        text = "'\\\n" + text;
                    } else if (lexState === 1 /* InMultiLineCommentTrivia */) {
                        text = "/*\n" + text;
                    }

                    offset = 3;
                }

                var result = new ClassificationResult();
                var simpleText = TypeScript.SimpleText.fromString(text);
                this.scanner = TypeScript.Scanner.createScanner(1 /* EcmaScript5 */, simpleText, this.reportDiagnostic);

                var lastTokenKind = 0 /* None */;
                var token = null;
                do {
                    this.lastDiagnosticKey = null;

                    token = this.scanner.scan(!noRegexTable[lastTokenKind]);
                    lastTokenKind = token.kind();

                    this.processToken(text, simpleText, offset, token, result);
                } while(token.kind() !== 10 /* EndOfFileToken */);

                this.lastDiagnosticKey = null;
                return result;
            };

            Classifier.prototype.processToken = function (text, simpleText, offset, token, result) {
                this.processTriviaList(text, offset, token.leadingTrivia(simpleText), result);
                this.addResult(text, offset, result, TypeScript.width(token), token.kind());
                this.processTriviaList(text, offset, token.trailingTrivia(simpleText), result);

                if (TypeScript.fullEnd(token) >= text.length) {
                    if (this.lastDiagnosticKey === TypeScript.DiagnosticCode.AsteriskSlash_expected) {
                        result.finalLexState = 1 /* InMultiLineCommentTrivia */;
                        return;
                    }

                    if (token.kind() === 14 /* StringLiteral */) {
                        var tokenText = token.text();
                        if (tokenText.length > 0 && tokenText.charCodeAt(tokenText.length - 1) === 92 /* backslash */) {
                            var quoteChar = tokenText.charCodeAt(0);
                            result.finalLexState = quoteChar === 34 /* doubleQuote */ ? 3 /* InDoubleQuoteStringLiteral */ : 2 /* InSingleQuoteStringLiteral */;
                            return;
                        }
                    }
                }
            };

            Classifier.prototype.processTriviaList = function (text, offset, triviaList, result) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    this.addResult(text, offset, result, trivia.fullWidth(), trivia.kind());
                }
            };

            Classifier.prototype.addResult = function (text, offset, result, length, kind) {
                if (length > 0) {
                    if (result.entries.length === 0) {
                        length -= offset;
                    }

                    result.entries.push(new ClassificationInfo(length, this.classFromKind(kind)));
                }
            };

            Classifier.prototype.classFromKind = function (kind) {
                if (TypeScript.SyntaxFacts.isAnyKeyword(kind)) {
                    return 1 /* Keyword */;
                } else if (TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(kind) || TypeScript.SyntaxFacts.isPrefixUnaryExpressionOperatorToken(kind)) {
                    return 2 /* Operator */;
                } else if (TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
                    return 0 /* Punctuation */;
                }

                switch (kind) {
                    case 4 /* WhitespaceTrivia */:
                        return 4 /* Whitespace */;
                    case 6 /* MultiLineCommentTrivia */:
                    case 7 /* SingleLineCommentTrivia */:
                        return 3 /* Comment */;
                    case 13 /* NumericLiteral */:
                        return 6 /* NumberLiteral */;
                    case 14 /* StringLiteral */:
                        return 7 /* StringLiteral */;
                    case 12 /* RegularExpressionLiteral */:
                        return 8 /* RegExpLiteral */;
                    case 11 /* IdentifierName */:
                    default:
                        return 5 /* Identifier */;
                }
            };
            return Classifier;
        })();
        Services.Classifier = Classifier;

        var ClassificationResult = (function () {
            function ClassificationResult() {
                this.finalLexState = 0 /* Start */;
                this.entries = [];
            }
            return ClassificationResult;
        })();
        Services.ClassificationResult = ClassificationResult;

        var ClassificationInfo = (function () {
            function ClassificationInfo(length, classification) {
                this.length = length;
                this.classification = classification;
            }
            return ClassificationInfo;
        })();
        Services.ClassificationInfo = ClassificationInfo;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        

        

        function logInternalError(logger, err) {
            logger.log("*INTERNAL ERROR* - Exception in typescript services: " + err.message);
        }
        Services.logInternalError = logInternalError;

        var ReferenceEntry = (function () {
            function ReferenceEntry(fileName, minChar, limChar, isWriteAccess) {
                this.fileName = "";
                this.minChar = -1;
                this.limChar = -1;
                this.isWriteAccess = false;
                this.fileName = fileName;
                this.minChar = minChar;
                this.limChar = limChar;
                this.isWriteAccess = isWriteAccess;
            }
            return ReferenceEntry;
        })();
        Services.ReferenceEntry = ReferenceEntry;

        var NavigateToItem = (function () {
            function NavigateToItem() {
                this.name = "";
                this.kind = "";
                this.kindModifiers = "";
                this.matchKind = "";
                this.fileName = "";
                this.minChar = -1;
                this.limChar = -1;
                this.additionalSpans = null;
                this.containerName = "";
                this.containerKind = "";
            }
            return NavigateToItem;
        })();
        Services.NavigateToItem = NavigateToItem;

        var TextEdit = (function () {
            function TextEdit(minChar, limChar, text) {
                this.minChar = minChar;
                this.limChar = limChar;
                this.text = text;
            }
            TextEdit.createInsert = function (pos, text) {
                return new TextEdit(pos, pos, text);
            };
            TextEdit.createDelete = function (minChar, limChar) {
                return new TextEdit(minChar, limChar, "");
            };
            TextEdit.createReplace = function (minChar, limChar, text) {
                return new TextEdit(minChar, limChar, text);
            };
            return TextEdit;
        })();
        Services.TextEdit = TextEdit;

        var EditorOptions = (function () {
            function EditorOptions() {
                this.IndentSize = 4;
                this.TabSize = 4;
                this.NewLineCharacter = "\r\n";
                this.ConvertTabsToSpaces = true;
            }
            EditorOptions.clone = function (objectToClone) {
                var editorOptions = new EditorOptions();
                editorOptions.IndentSize = objectToClone.IndentSize;
                editorOptions.TabSize = objectToClone.TabSize;
                editorOptions.NewLineCharacter = objectToClone.NewLineCharacter;
                editorOptions.ConvertTabsToSpaces = objectToClone.ConvertTabsToSpaces;
                return editorOptions;
            };
            return EditorOptions;
        })();
        Services.EditorOptions = EditorOptions;

        var FormatCodeOptions = (function (_super) {
            __extends(FormatCodeOptions, _super);
            function FormatCodeOptions() {
                _super.apply(this, arguments);
                this.InsertSpaceAfterCommaDelimiter = true;
                this.InsertSpaceAfterSemicolonInForStatements = true;
                this.InsertSpaceBeforeAndAfterBinaryOperators = true;
                this.InsertSpaceAfterKeywordsInControlFlowStatements = true;
                this.InsertSpaceAfterFunctionKeywordForAnonymousFunctions = false;
                this.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis = false;
                this.PlaceOpenBraceOnNewLineForFunctions = false;
                this.PlaceOpenBraceOnNewLineForControlBlocks = false;
            }
            FormatCodeOptions.clone = function (objectToClone) {
                var formatCodeOptions = EditorOptions.clone(objectToClone);
                formatCodeOptions.InsertSpaceAfterCommaDelimiter = objectToClone.InsertSpaceAfterCommaDelimiter;
                formatCodeOptions.InsertSpaceAfterSemicolonInForStatements = objectToClone.InsertSpaceAfterSemicolonInForStatements;
                formatCodeOptions.InsertSpaceBeforeAndAfterBinaryOperators = objectToClone.InsertSpaceBeforeAndAfterBinaryOperators;
                formatCodeOptions.InsertSpaceAfterKeywordsInControlFlowStatements = objectToClone.InsertSpaceAfterKeywordsInControlFlowStatements;
                formatCodeOptions.InsertSpaceAfterFunctionKeywordForAnonymousFunctions = objectToClone.InsertSpaceAfterFunctionKeywordForAnonymousFunctions;
                formatCodeOptions.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis = objectToClone.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis;
                formatCodeOptions.PlaceOpenBraceOnNewLineForFunctions = objectToClone.PlaceOpenBraceOnNewLineForFunctions;
                formatCodeOptions.PlaceOpenBraceOnNewLineForControlBlocks = objectToClone.PlaceOpenBraceOnNewLineForControlBlocks;
                return formatCodeOptions;
            };
            return FormatCodeOptions;
        })(EditorOptions);
        Services.FormatCodeOptions = FormatCodeOptions;

        var DefinitionInfo = (function () {
            function DefinitionInfo(fileName, minChar, limChar, kind, name, containerKind, containerName) {
                this.fileName = fileName;
                this.minChar = minChar;
                this.limChar = limChar;
                this.kind = kind;
                this.name = name;
                this.containerKind = containerKind;
                this.containerName = containerName;
            }
            return DefinitionInfo;
        })();
        Services.DefinitionInfo = DefinitionInfo;

        var TypeInfo = (function () {
            function TypeInfo(memberName, docComment, fullSymbolName, kind, minChar, limChar) {
                this.memberName = memberName;
                this.docComment = docComment;
                this.fullSymbolName = fullSymbolName;
                this.kind = kind;
                this.minChar = minChar;
                this.limChar = limChar;
            }
            return TypeInfo;
        })();
        Services.TypeInfo = TypeInfo;

        var SpanInfo = (function () {
            function SpanInfo(minChar, limChar, text) {
                if (typeof text === "undefined") { text = null; }
                this.minChar = minChar;
                this.limChar = limChar;
                this.text = text;
            }
            return SpanInfo;
        })();
        Services.SpanInfo = SpanInfo;

        var SignatureInfo = (function () {
            function SignatureInfo() {
                this.formal = [];
            }
            return SignatureInfo;
        })();
        Services.SignatureInfo = SignatureInfo;

        var FormalSignatureItemInfo = (function () {
            function FormalSignatureItemInfo() {
                this.typeParameters = [];
                this.parameters = [];
            }
            return FormalSignatureItemInfo;
        })();
        Services.FormalSignatureItemInfo = FormalSignatureItemInfo;

        var FormalTypeParameterInfo = (function () {
            function FormalTypeParameterInfo() {
            }
            return FormalTypeParameterInfo;
        })();
        Services.FormalTypeParameterInfo = FormalTypeParameterInfo;

        var FormalParameterInfo = (function () {
            function FormalParameterInfo() {
            }
            return FormalParameterInfo;
        })();
        Services.FormalParameterInfo = FormalParameterInfo;

        var ActualSignatureInfo = (function () {
            function ActualSignatureInfo() {
            }
            return ActualSignatureInfo;
        })();
        Services.ActualSignatureInfo = ActualSignatureInfo;

        var CompletionInfo = (function () {
            function CompletionInfo() {
                this.maybeInaccurate = false;
                this.isMemberCompletion = false;
                this.entries = [];
            }
            return CompletionInfo;
        })();
        Services.CompletionInfo = CompletionInfo;

        var ScriptElementKind = (function () {
            function ScriptElementKind() {
            }
            ScriptElementKind.unknown = "";

            ScriptElementKind.keyword = "keyword";

            ScriptElementKind.scriptElement = "script";

            ScriptElementKind.moduleElement = "module";

            ScriptElementKind.classElement = "class";

            ScriptElementKind.interfaceElement = "interface";

            ScriptElementKind.enumElement = "enum";

            ScriptElementKind.variableElement = "var";

            ScriptElementKind.localVariableElement = "local var";

            ScriptElementKind.functionElement = "function";

            ScriptElementKind.localFunctionElement = "local function";

            ScriptElementKind.memberFunctionElement = "method";

            ScriptElementKind.memberGetAccessorElement = "getter";
            ScriptElementKind.memberSetAccessorElement = "setter";

            ScriptElementKind.memberVariableElement = "property";

            ScriptElementKind.constructorImplementationElement = "constructor";

            ScriptElementKind.callSignatureElement = "call";

            ScriptElementKind.indexSignatureElement = "index";

            ScriptElementKind.constructSignatureElement = "construct";

            ScriptElementKind.parameterElement = "parameter";

            ScriptElementKind.typeParameterElement = "type parameter";

            ScriptElementKind.primitiveType = "primitive type";
            return ScriptElementKind;
        })();
        Services.ScriptElementKind = ScriptElementKind;

        var ScriptElementKindModifier = (function () {
            function ScriptElementKindModifier() {
            }
            ScriptElementKindModifier.none = "";
            ScriptElementKindModifier.publicMemberModifier = "public";
            ScriptElementKindModifier.privateMemberModifier = "private";
            ScriptElementKindModifier.exportedModifier = "export";
            ScriptElementKindModifier.ambientModifier = "declare";
            ScriptElementKindModifier.staticModifier = "static";
            return ScriptElementKindModifier;
        })();
        Services.ScriptElementKindModifier = ScriptElementKindModifier;

        var MatchKind = (function () {
            function MatchKind() {
            }
            MatchKind.none = null;
            MatchKind.exact = "exact";
            MatchKind.subString = "substring";
            MatchKind.prefix = "prefix";
            return MatchKind;
        })();
        Services.MatchKind = MatchKind;

        var DiagnosticCategory = (function () {
            function DiagnosticCategory() {
            }
            DiagnosticCategory.none = "";
            DiagnosticCategory.error = "error";
            DiagnosticCategory.warning = "warning";
            DiagnosticCategory.message = "message";
            return DiagnosticCategory;
        })();
        Services.DiagnosticCategory = DiagnosticCategory;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        function copyDataObject(dst, src) {
            for (var e in dst) {
                if (typeof dst[e] == "object") {
                    copyDataObject(dst[e], src[e]);
                } else if (typeof dst[e] != "function") {
                    dst[e] = src[e];
                }
            }
            return dst;
        }
        Services.copyDataObject = copyDataObject;

        var TypeScriptServicesFactory = (function () {
            function TypeScriptServicesFactory() {
                this._shims = [];
                this.documentRegistry = new TypeScript.DocumentRegistry();
            }
            TypeScriptServicesFactory.prototype.createPullLanguageService = function (host) {
                try  {
                    return new TypeScript.Services.LanguageService(host, this.documentRegistry);
                } catch (err) {
                    TypeScript.Services.logInternalError(host, err);
                    throw err;
                }
            };

            TypeScriptServicesFactory.prototype.createLanguageServiceShim = function (host) {
                try  {
                    var hostAdapter = new Services.LanguageServiceShimHostAdapter(host);
                    var pullLanguageService = this.createPullLanguageService(hostAdapter);
                    return new Services.LanguageServiceShim(this, host, pullLanguageService);
                } catch (err) {
                    TypeScript.Services.logInternalError(host, err);
                    throw err;
                }
            };

            TypeScriptServicesFactory.prototype.createClassifier = function (host) {
                try  {
                    return new TypeScript.Services.Classifier(host);
                } catch (err) {
                    TypeScript.Services.logInternalError(host, err);
                    throw err;
                }
            };

            TypeScriptServicesFactory.prototype.createClassifierShim = function (host) {
                try  {
                    return new Services.ClassifierShim(this, host);
                } catch (err) {
                    TypeScript.Services.logInternalError(host, err);
                    throw err;
                }
            };

            TypeScriptServicesFactory.prototype.createCoreServices = function (host) {
                try  {
                    return new TypeScript.Services.CoreServices(host);
                } catch (err) {
                    TypeScript.Services.logInternalError(host.logger, err);
                    throw err;
                }
            };

            TypeScriptServicesFactory.prototype.createCoreServicesShim = function (host) {
                try  {
                    return new Services.CoreServicesShim(this, host);
                } catch (err) {
                    TypeScript.Services.logInternalError(host.logger, err);
                    throw err;
                }
            };

            TypeScriptServicesFactory.prototype.close = function () {
                this._shims = [];
                this.documentRegistry = new TypeScript.DocumentRegistry();
            };

            TypeScriptServicesFactory.prototype.registerShim = function (shim) {
                this._shims.push(shim);
            };

            TypeScriptServicesFactory.prototype.unregisterShim = function (shim) {
                for (var i = 0, n = this._shims.length; i < n; i++) {
                    if (this._shims[i] === shim) {
                        delete this._shims[i];
                        return;
                    }
                }

                throw TypeScript.Errors.invalidOperation();
            };
            return TypeScriptServicesFactory;
        })();
        Services.TypeScriptServicesFactory = TypeScriptServicesFactory;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var TextSnapshot = (function () {
                function TextSnapshot(snapshot) {
                    this.snapshot = snapshot;
                    this.lines = [];
                }
                TextSnapshot.prototype.getText = function (span) {
                    return this.snapshot.substr(span.start(), span.length());
                };

                TextSnapshot.prototype.getLineNumberFromPosition = function (position) {
                    return this.snapshot.lineMap().getLineNumberFromPosition(position);
                };

                TextSnapshot.prototype.getLineFromPosition = function (position) {
                    var lineNumber = this.getLineNumberFromPosition(position);
                    return this.getLineFromLineNumber(lineNumber);
                };

                TextSnapshot.prototype.getLineFromLineNumber = function (lineNumber) {
                    var line = this.lines[lineNumber];
                    if (line === undefined) {
                        line = this.getLineFromLineNumberWorker(lineNumber);
                        this.lines[lineNumber] = line;
                    }
                    return line;
                };

                TextSnapshot.prototype.getLineFromLineNumberWorker = function (lineNumber) {
                    var lineMap = this.snapshot.lineMap().lineStarts();
                    var lineMapIndex = lineNumber;
                    if (lineMapIndex < 0 || lineMapIndex >= lineMap.length)
                        throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_line_number_0, [lineMapIndex]));
                    var start = lineMap[lineMapIndex];

                    var end;
                    var endIncludingLineBreak;
                    var lineBreak = "";
                    if (lineMapIndex == lineMap.length) {
                        end = endIncludingLineBreak = this.snapshot.length();
                    } else {
                        endIncludingLineBreak = (lineMapIndex >= lineMap.length - 1 ? this.snapshot.length() : lineMap[lineMapIndex + 1]);
                        for (var p = endIncludingLineBreak - 1; p >= start; p--) {
                            var c = this.snapshot.substr(p, 1);

                            if (c != "\r" && c != "\n") {
                                break;
                            }
                        }
                        end = p + 1;
                        lineBreak = this.snapshot.substr(end, endIncludingLineBreak - end);
                    }
                    var result = new Formatting.TextSnapshotLine(this, lineNumber, start, end, lineBreak);
                    return result;
                };
                return TextSnapshot;
            })();
            Formatting.TextSnapshot = TextSnapshot;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var TextSnapshotLine = (function () {
                function TextSnapshotLine(_snapshot, _lineNumber, _start, _end, _lineBreak) {
                    this._snapshot = _snapshot;
                    this._lineNumber = _lineNumber;
                    this._start = _start;
                    this._end = _end;
                    this._lineBreak = _lineBreak;
                }
                TextSnapshotLine.prototype.snapshot = function () {
                    return this._snapshot;
                };

                TextSnapshotLine.prototype.start = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._start);
                };

                TextSnapshotLine.prototype.startPosition = function () {
                    return this._start;
                };

                TextSnapshotLine.prototype.end = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._end);
                };

                TextSnapshotLine.prototype.endPosition = function () {
                    return this._end;
                };

                TextSnapshotLine.prototype.endIncludingLineBreak = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._end + this._lineBreak.length);
                };

                TextSnapshotLine.prototype.endIncludingLineBreakPosition = function () {
                    return this._end + this._lineBreak.length;
                };

                TextSnapshotLine.prototype.length = function () {
                    return this._end - this._start;
                };

                TextSnapshotLine.prototype.lineNumber = function () {
                    return this._lineNumber;
                };

                TextSnapshotLine.prototype.getText = function () {
                    return this._snapshot.getText(TypeScript.TextSpan.fromBounds(this._start, this._end));
                };
                return TextSnapshotLine;
            })();
            Formatting.TextSnapshotLine = TextSnapshotLine;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var SnapshotPoint = (function () {
                function SnapshotPoint(snapshot, position) {
                    this.snapshot = snapshot;
                    this.position = position;
                }
                SnapshotPoint.prototype.getContainingLine = function () {
                    return this.snapshot.getLineFromPosition(this.position);
                };
                SnapshotPoint.prototype.add = function (offset) {
                    return new SnapshotPoint(this.snapshot, this.position + offset);
                };
                return SnapshotPoint;
            })();
            Formatting.SnapshotPoint = SnapshotPoint;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var FormattingContext = (function () {
                function FormattingContext(snapshot, formattingRequestKind) {
                    this.snapshot = snapshot;
                    this.formattingRequestKind = formattingRequestKind;
                    this.currentTokenSpan = null;
                    this.nextTokenSpan = null;
                    this.contextNode = null;
                    this.currentTokenParent = null;
                    this.nextTokenParent = null;
                    this.contextNodeAllOnSameLine = null;
                    this.nextNodeAllOnSameLine = null;
                    this.tokensAreOnSameLine = null;
                    this.contextNodeBlockIsOnOneLine = null;
                    this.nextNodeBlockIsOnOneLine = null;
                    TypeScript.Debug.assert(this.snapshot != null, "snapshot is null");
                }
                FormattingContext.prototype.updateContext = function (currentTokenSpan, currentTokenParent, nextTokenSpan, nextTokenParent, commonParent) {
                    TypeScript.Debug.assert(currentTokenSpan != null, "currentTokenSpan is null");
                    TypeScript.Debug.assert(currentTokenParent != null, "currentTokenParent is null");
                    TypeScript.Debug.assert(nextTokenSpan != null, "nextTokenSpan is null");
                    TypeScript.Debug.assert(nextTokenParent != null, "nextTokenParent is null");
                    TypeScript.Debug.assert(commonParent != null, "commonParent is null");

                    this.currentTokenSpan = currentTokenSpan;
                    this.currentTokenParent = currentTokenParent;
                    this.nextTokenSpan = nextTokenSpan;
                    this.nextTokenParent = nextTokenParent;
                    this.contextNode = commonParent;

                    this.contextNodeAllOnSameLine = null;
                    this.nextNodeAllOnSameLine = null;
                    this.tokensAreOnSameLine = null;
                    this.contextNodeBlockIsOnOneLine = null;
                    this.nextNodeBlockIsOnOneLine = null;
                };

                FormattingContext.prototype.ContextNodeAllOnSameLine = function () {
                    if (this.contextNodeAllOnSameLine === null) {
                        this.contextNodeAllOnSameLine = this.NodeIsOnOneLine(this.contextNode);
                    }

                    return this.contextNodeAllOnSameLine;
                };

                FormattingContext.prototype.NextNodeAllOnSameLine = function () {
                    if (this.nextNodeAllOnSameLine === null) {
                        this.nextNodeAllOnSameLine = this.NodeIsOnOneLine(this.nextTokenParent);
                    }

                    return this.nextNodeAllOnSameLine;
                };

                FormattingContext.prototype.TokensAreOnSameLine = function () {
                    if (this.tokensAreOnSameLine === null) {
                        var startLine = this.snapshot.getLineNumberFromPosition(this.currentTokenSpan.start());
                        var endLine = this.snapshot.getLineNumberFromPosition(this.nextTokenSpan.start());

                        this.tokensAreOnSameLine = (startLine == endLine);
                    }

                    return this.tokensAreOnSameLine;
                };

                FormattingContext.prototype.ContextNodeBlockIsOnOneLine = function () {
                    if (this.contextNodeBlockIsOnOneLine === null) {
                        this.contextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.contextNode);
                    }

                    return this.contextNodeBlockIsOnOneLine;
                };

                FormattingContext.prototype.NextNodeBlockIsOnOneLine = function () {
                    if (this.nextNodeBlockIsOnOneLine === null) {
                        this.nextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.nextTokenParent);
                    }

                    return this.nextNodeBlockIsOnOneLine;
                };

                FormattingContext.prototype.NodeIsOnOneLine = function (node) {
                    var startLine = this.snapshot.getLineNumberFromPosition(node.start());
                    var endLine = this.snapshot.getLineNumberFromPosition(node.end());

                    return startLine == endLine;
                };

                FormattingContext.prototype.BlockIsOnOneLine = function (node) {
                    var block = node.node();

                    return this.snapshot.getLineNumberFromPosition(TypeScript.end(block.openBraceToken)) === this.snapshot.getLineNumberFromPosition(TypeScript.start(block.closeBraceToken));
                };
                return FormattingContext;
            })();
            Formatting.FormattingContext = FormattingContext;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var FormattingManager = (function () {
                function FormattingManager(syntaxTree, snapshot, rulesProvider, editorOptions) {
                    this.syntaxTree = syntaxTree;
                    this.snapshot = snapshot;
                    this.rulesProvider = rulesProvider;
                    this.options = new TypeScript.FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);
                }
                FormattingManager.prototype.formatSelection = function (minChar, limChar) {
                    var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                    return this.formatSpan(span, 1 /* FormatSelection */);
                };

                FormattingManager.prototype.formatDocument = function (minChar, limChar) {
                    var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                    return this.formatSpan(span, 0 /* FormatDocument */);
                };

                FormattingManager.prototype.formatOnPaste = function (minChar, limChar) {
                    var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                    return this.formatSpan(span, 5 /* FormatOnPaste */);
                };

                FormattingManager.prototype.formatOnSemicolon = function (caretPosition) {
                    var sourceUnit = this.syntaxTree.sourceUnit();
                    var semicolonPositionedToken = TypeScript.findToken(sourceUnit, caretPosition - 1);

                    if (semicolonPositionedToken.kind() === 78 /* SemicolonToken */) {
                        var current = semicolonPositionedToken;
                        while (current.parent !== null && TypeScript.end(current.parent) === TypeScript.end(semicolonPositionedToken) && current.parent.kind() !== 1 /* List */) {
                            current = current.parent;
                        }

                        var span = new TypeScript.TextSpan(TypeScript.fullStart(current), TypeScript.fullWidth(current));

                        return this.formatSpan(span, 3 /* FormatOnSemicolon */);
                    }

                    return [];
                };

                FormattingManager.prototype.formatOnClosingCurlyBrace = function (caretPosition) {
                    var sourceUnit = this.syntaxTree.sourceUnit();
                    var closeBracePositionedToken = TypeScript.findToken(sourceUnit, caretPosition - 1);

                    if (closeBracePositionedToken.kind() === 71 /* CloseBraceToken */) {
                        var current = closeBracePositionedToken;
                        while (current.parent !== null && TypeScript.end(current.parent) === TypeScript.end(closeBracePositionedToken) && current.parent.kind() !== 1 /* List */) {
                            current = current.parent;
                        }

                        var span = new TypeScript.TextSpan(TypeScript.fullStart(current), TypeScript.fullWidth(current));

                        return this.formatSpan(span, 4 /* FormatOnClosingCurlyBrace */);
                    }

                    return [];
                };

                FormattingManager.prototype.formatOnEnter = function (caretPosition) {
                    var lineNumber = this.snapshot.getLineNumberFromPosition(caretPosition);

                    if (lineNumber > 0) {
                        var prevLine = this.snapshot.getLineFromLineNumber(lineNumber - 1);
                        var currentLine = this.snapshot.getLineFromLineNumber(lineNumber);
                        var span = TypeScript.TextSpan.fromBounds(prevLine.startPosition(), currentLine.endPosition());

                        return this.formatSpan(span, 2 /* FormatOnEnter */);
                    }

                    return [];
                };

                FormattingManager.prototype.formatSpan = function (span, formattingRequestKind) {
                    var startLine = this.snapshot.getLineFromPosition(span.start());
                    span = TypeScript.TextSpan.fromBounds(startLine.startPosition(), span.end());

                    var result = [];

                    var formattingEdits = Formatting.Formatter.getEdits(span, this.syntaxTree.sourceUnit(), this.options, true, this.snapshot, this.rulesProvider, formattingRequestKind);

                    formattingEdits.forEach(function (item) {
                        var edit = new TypeScript.Services.TextEdit(item.position, item.position + item.length, item.replaceWith);
                        result.push(edit);
                    });

                    return result;
                };
                return FormattingManager;
            })();
            Formatting.FormattingManager = FormattingManager;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            (function (FormattingRequestKind) {
                FormattingRequestKind[FormattingRequestKind["FormatDocument"] = 0] = "FormatDocument";
                FormattingRequestKind[FormattingRequestKind["FormatSelection"] = 1] = "FormatSelection";
                FormattingRequestKind[FormattingRequestKind["FormatOnEnter"] = 2] = "FormatOnEnter";
                FormattingRequestKind[FormattingRequestKind["FormatOnSemicolon"] = 3] = "FormatOnSemicolon";
                FormattingRequestKind[FormattingRequestKind["FormatOnClosingCurlyBrace"] = 4] = "FormatOnClosingCurlyBrace";
                FormattingRequestKind[FormattingRequestKind["FormatOnPaste"] = 5] = "FormatOnPaste";
            })(Formatting.FormattingRequestKind || (Formatting.FormattingRequestKind = {}));
            var FormattingRequestKind = Formatting.FormattingRequestKind;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var Rule = (function () {
                function Rule(Descriptor, Operation, Flag) {
                    if (typeof Flag === "undefined") { Flag = 0 /* None */; }
                    this.Descriptor = Descriptor;
                    this.Operation = Operation;
                    this.Flag = Flag;
                }
                Rule.prototype.toString = function () {
                    return "[desc=" + this.Descriptor + "," + "operation=" + this.Operation + "," + "flag=" + this.Flag + "]";
                };
                return Rule;
            })();
            Formatting.Rule = Rule;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            (function (RuleAction) {
                RuleAction[RuleAction["Ignore"] = 0] = "Ignore";
                RuleAction[RuleAction["Space"] = 1] = "Space";
                RuleAction[RuleAction["NewLine"] = 2] = "NewLine";
                RuleAction[RuleAction["Delete"] = 3] = "Delete";
            })(Formatting.RuleAction || (Formatting.RuleAction = {}));
            var RuleAction = Formatting.RuleAction;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var RuleDescriptor = (function () {
                function RuleDescriptor(LeftTokenRange, RightTokenRange) {
                    this.LeftTokenRange = LeftTokenRange;
                    this.RightTokenRange = RightTokenRange;
                }
                RuleDescriptor.prototype.toString = function () {
                    return "[leftRange=" + this.LeftTokenRange + "," + "rightRange=" + this.RightTokenRange + "]";
                };

                RuleDescriptor.create1 = function (left, right) {
                    return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), Formatting.Shared.TokenRange.FromToken(right));
                };

                RuleDescriptor.create2 = function (left, right) {
                    return RuleDescriptor.create4(left, Formatting.Shared.TokenRange.FromToken(right));
                };

                RuleDescriptor.create3 = function (left, right) {
                    return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), right);
                };

                RuleDescriptor.create4 = function (left, right) {
                    return new RuleDescriptor(left, right);
                };
                return RuleDescriptor;
            })();
            Formatting.RuleDescriptor = RuleDescriptor;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            (function (RuleFlags) {
                RuleFlags[RuleFlags["None"] = 0] = "None";
                RuleFlags[RuleFlags["CanDeleteNewLines"] = 1] = "CanDeleteNewLines";
            })(Formatting.RuleFlags || (Formatting.RuleFlags = {}));
            var RuleFlags = Formatting.RuleFlags;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var RuleOperation = (function () {
                function RuleOperation() {
                    this.Context = null;
                    this.Action = null;
                }
                RuleOperation.prototype.toString = function () {
                    return "[context=" + this.Context + "," + "action=" + this.Action + "]";
                };

                RuleOperation.create1 = function (action) {
                    return RuleOperation.create2(Formatting.RuleOperationContext.Any, action);
                };

                RuleOperation.create2 = function (context, action) {
                    var result = new RuleOperation();
                    result.Context = context;
                    result.Action = action;
                    return result;
                };
                return RuleOperation;
            })();
            Formatting.RuleOperation = RuleOperation;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var RuleOperationContext = (function () {
                function RuleOperationContext() {
                    var funcs = [];
                    for (var _i = 0; _i < (arguments.length - 0); _i++) {
                        funcs[_i] = arguments[_i + 0];
                    }
                    this.customContextChecks = funcs;
                }
                RuleOperationContext.prototype.IsAny = function () {
                     {
                        return this == RuleOperationContext.Any;
                    }
                };

                RuleOperationContext.prototype.InContext = function (context) {
                    if (this.IsAny()) {
                        return true;
                    }

                    for (var i = 0, len = this.customContextChecks.length; i < len; i++) {
                        if (!this.customContextChecks[i](context)) {
                            return false;
                        }
                    }
                    return true;
                };
                RuleOperationContext.Any = new RuleOperationContext();
                return RuleOperationContext;
            })();
            Formatting.RuleOperationContext = RuleOperationContext;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var Rules = (function () {
                function Rules() {
                    this.IgnoreBeforeComment = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.Comments), Formatting.RuleOperation.create1(0 /* Ignore */));
                    this.IgnoreAfterLineComment = new Formatting.Rule(Formatting.RuleDescriptor.create3(7 /* SingleLineCommentTrivia */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create1(0 /* Ignore */));

                    this.NoSpaceBeforeSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 78 /* SemicolonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeColon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 106 /* ColonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceBeforeQMark = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 105 /* QuestionToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.SpaceAfterColon = new Formatting.Rule(Formatting.RuleDescriptor.create3(106 /* ColonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterQMark = new Formatting.Rule(Formatting.RuleDescriptor.create3(105 /* QuestionToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create3(78 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));

                    this.SpaceAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(71 /* CloseBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsAfterCodeBlockContext), 1 /* Space */));

                    this.SpaceBetweenCloseBraceAndElse = new Formatting.Rule(Formatting.RuleDescriptor.create1(71 /* CloseBraceToken */, 23 /* ElseKeyword */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBetweenCloseBraceAndWhile = new Formatting.Rule(Formatting.RuleDescriptor.create1(71 /* CloseBraceToken */, 42 /* WhileKeyword */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(71 /* CloseBraceToken */, Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 75 /* CloseBracketToken */, 79 /* CommaToken */, 78 /* SemicolonToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.NoSpaceBeforeDot = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 76 /* DotToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterDot = new Formatting.Rule(Formatting.RuleDescriptor.create3(76 /* DotToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 74 /* OpenBracketToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(74 /* OpenBracketToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 75 /* CloseBracketToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(75 /* CloseBracketToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.FunctionOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.AnyIncludingMultilineComments;
                    this.SpaceBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);

                    this.TypeScriptOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([11 /* IdentifierName */, 6 /* MultiLineCommentTrivia */]);
                    this.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);

                    this.ControlOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 6 /* MultiLineCommentTrivia */, 22 /* DoKeyword */, 38 /* TryKeyword */, 25 /* FinallyKeyword */, 23 /* ElseKeyword */]);
                    this.SpaceBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);

                    this.SpaceAfterOpenBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(70 /* OpenBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), 1 /* Space */));
                    this.SpaceBeforeCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), 1 /* Space */));
                    this.NoSpaceBetweenEmptyBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(70 /* OpenBraceToken */, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsObjectContext), 3 /* Delete */));

                    this.NewLineAfterOpenBraceInBlockContext = new Formatting.Rule(Formatting.RuleDescriptor.create3(70 /* OpenBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), 2 /* NewLine */));

                    this.NewLineBeforeCloseBraceInBlockContext = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.AnyIncludingMultilineComments, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), 2 /* NewLine */));

                    this.NoSpaceAfterUnaryPrefixOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.UnaryPrefixOperators, Formatting.Shared.TokenRange.UnaryPrefixExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceAfterUnaryPreincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(93 /* PlusPlusToken */, Formatting.Shared.TokenRange.UnaryPreincrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterUnaryPredecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(94 /* MinusMinusToken */, Formatting.Shared.TokenRange.UnaryPredecrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeUnaryPostincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostincrementExpressions, 93 /* PlusPlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeUnaryPostdecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostdecrementExpressions, 94 /* MinusMinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.SpaceAfterPostincrementWhenFollowedByAdd = new Formatting.Rule(Formatting.RuleDescriptor.create1(93 /* PlusPlusToken */, 89 /* PlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterAddWhenFollowedByUnaryPlus = new Formatting.Rule(Formatting.RuleDescriptor.create1(89 /* PlusToken */, 89 /* PlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterAddWhenFollowedByPreincrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(89 /* PlusToken */, 93 /* PlusPlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterPostdecrementWhenFollowedBySubtract = new Formatting.Rule(Formatting.RuleDescriptor.create1(94 /* MinusMinusToken */, 90 /* MinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSubtractWhenFollowedByUnaryMinus = new Formatting.Rule(Formatting.RuleDescriptor.create1(90 /* MinusToken */, 90 /* MinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSubtractWhenFollowedByPredecrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(90 /* MinusToken */, 94 /* MinusMinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));

                    this.NoSpaceBeforeComma = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 79 /* CommaToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.SpaceAfterCertainKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([40 /* VarKeyword */, 36 /* ThrowKeyword */, 31 /* NewKeyword */, 21 /* DeleteKeyword */, 33 /* ReturnKeyword */, 39 /* TypeOfKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceBeforeOpenParenInFuncCall = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionCallOrNewContext), 3 /* Delete */));
                    this.SpaceAfterFunctionInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create3(27 /* FunctionKeyword */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    this.NoSpaceBeforeOpenParenInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionDeclContext), 3 /* Delete */));
                    this.SpaceAfterVoidOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(41 /* VoidKeyword */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsVoidOpContext), 1 /* Space */));

                    this.NoSpaceBetweenReturnAndSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create1(33 /* ReturnKeyword */, 78 /* SemicolonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.SpaceBetweenStatements = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 22 /* DoKeyword */, 23 /* ElseKeyword */, 16 /* CaseKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotForContext), 1 /* Space */));

                    this.SpaceAfterTryFinally = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([38 /* TryKeyword */, 25 /* FinallyKeyword */]), 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));

                    this.SpaceAfterGetSetInMember = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([64 /* GetKeyword */, 68 /* SetKeyword */]), 11 /* IdentifierName */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));

                    this.SpaceBeforeBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryKeywordOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryKeywordOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));

                    this.NoSpaceAfterConstructor = new Formatting.Rule(Formatting.RuleDescriptor.create1(62 /* ConstructorKeyword */, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.NoSpaceAfterModuleImport = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([65 /* ModuleKeyword */, 66 /* RequireKeyword */]), 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.SpaceAfterCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([44 /* ClassKeyword */, 63 /* DeclareKeyword */, 46 /* EnumKeyword */, 47 /* ExportKeyword */, 48 /* ExtendsKeyword */, 64 /* GetKeyword */, 51 /* ImplementsKeyword */, 49 /* ImportKeyword */, 52 /* InterfaceKeyword */, 65 /* ModuleKeyword */, 55 /* PrivateKeyword */, 57 /* PublicKeyword */, 68 /* SetKeyword */, 58 /* StaticKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBeforeCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.FromTokens([48 /* ExtendsKeyword */, 51 /* ImplementsKeyword */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));

                    this.SpaceAfterModuleName = new Formatting.Rule(Formatting.RuleDescriptor.create1(14 /* StringLiteral */, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsModuleDeclContext), 1 /* Space */));

                    this.SpaceAfterArrow = new Formatting.Rule(Formatting.RuleDescriptor.create3(85 /* EqualsGreaterThanToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));

                    this.NoSpaceAfterEllipsis = new Formatting.Rule(Formatting.RuleDescriptor.create1(77 /* DotDotDotToken */, 11 /* IdentifierName */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOptionalParameters = new Formatting.Rule(Formatting.RuleDescriptor.create3(105 /* QuestionToken */, Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 79 /* CommaToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));

                    this.NoSpaceBeforeOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.TypeNames, 80 /* LessThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceBetweenCloseParenAndAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create1(73 /* CloseParenToken */, 80 /* LessThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(80 /* LessThanToken */, Formatting.Shared.TokenRange.TypeNames), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 81 /* GreaterThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceAfterCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(81 /* GreaterThanToken */, Formatting.Shared.TokenRange.FromTokens([72 /* OpenParenToken */, 74 /* OpenBracketToken */, 81 /* GreaterThanToken */, 79 /* CommaToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));

                    this.NoSpaceBetweenEmptyInterfaceBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(70 /* OpenBraceToken */, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsObjectTypeContext), 3 /* Delete */));

                    this.HighPriorityCommonRules = [
                        this.IgnoreBeforeComment, this.IgnoreAfterLineComment,
                        this.NoSpaceBeforeColon, this.SpaceAfterColon, this.NoSpaceBeforeQMark, this.SpaceAfterQMark,
                        this.NoSpaceBeforeDot, this.NoSpaceAfterDot,
                        this.NoSpaceAfterUnaryPrefixOperator,
                        this.NoSpaceAfterUnaryPreincrementOperator, this.NoSpaceAfterUnaryPredecrementOperator,
                        this.NoSpaceBeforeUnaryPostincrementOperator, this.NoSpaceBeforeUnaryPostdecrementOperator,
                        this.SpaceAfterPostincrementWhenFollowedByAdd,
                        this.SpaceAfterAddWhenFollowedByUnaryPlus, this.SpaceAfterAddWhenFollowedByPreincrement,
                        this.SpaceAfterPostdecrementWhenFollowedBySubtract,
                        this.SpaceAfterSubtractWhenFollowedByUnaryMinus, this.SpaceAfterSubtractWhenFollowedByPredecrement,
                        this.NoSpaceAfterCloseBrace,
                        this.SpaceAfterOpenBrace, this.SpaceBeforeCloseBrace, this.NewLineBeforeCloseBraceInBlockContext,
                        this.SpaceAfterCloseBrace, this.SpaceBetweenCloseBraceAndElse, this.SpaceBetweenCloseBraceAndWhile, this.NoSpaceBetweenEmptyBraceBrackets,
                        this.SpaceAfterFunctionInFuncDecl, this.NewLineAfterOpenBraceInBlockContext, this.SpaceAfterGetSetInMember,
                        this.NoSpaceBetweenReturnAndSemicolon,
                        this.SpaceAfterCertainKeywords,
                        this.NoSpaceBeforeOpenParenInFuncCall,
                        this.SpaceBeforeBinaryKeywordOperator, this.SpaceAfterBinaryKeywordOperator,
                        this.SpaceAfterVoidOperator,
                        this.NoSpaceAfterConstructor, this.NoSpaceAfterModuleImport,
                        this.SpaceAfterCertainTypeScriptKeywords, this.SpaceBeforeCertainTypeScriptKeywords,
                        this.SpaceAfterModuleName,
                        this.SpaceAfterArrow,
                        this.NoSpaceAfterEllipsis,
                        this.NoSpaceAfterOptionalParameters,
                        this.NoSpaceBetweenEmptyInterfaceBraceBrackets,
                        this.NoSpaceBeforeOpenAngularBracket,
                        this.NoSpaceBetweenCloseParenAndAngularBracket,
                        this.NoSpaceAfterOpenAngularBracket,
                        this.NoSpaceBeforeCloseAngularBracket,
                        this.NoSpaceAfterCloseAngularBracket
                    ];

                    this.LowPriorityCommonRules = [
                        this.NoSpaceBeforeSemicolon,
                        this.SpaceBeforeOpenBraceInControl, this.SpaceBeforeOpenBraceInFunction, this.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock,
                        this.NoSpaceBeforeComma,
                        this.NoSpaceBeforeOpenBracket, this.NoSpaceAfterOpenBracket,
                        this.NoSpaceBeforeCloseBracket, this.NoSpaceAfterCloseBracket,
                        this.SpaceAfterSemicolon,
                        this.NoSpaceBeforeOpenParenInFuncDecl,
                        this.SpaceBetweenStatements, this.SpaceAfterTryFinally
                    ];

                    this.SpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(79 /* CommaToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(79 /* CommaToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.SpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.NoSpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 3 /* Delete */));

                    this.SpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), 1 /* Space */));
                    this.NoSpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), 3 /* Delete */));

                    this.NewLineBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);

                    this.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);

                    this.NewLineBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);

                    this.SpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(78 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), 1 /* Space */));
                    this.NoSpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(78 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), 3 /* Delete */));

                    this.SpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(72 /* OpenParenToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 73 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceBetweenParens = new Formatting.Rule(Formatting.RuleDescriptor.create1(72 /* OpenParenToken */, 73 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(72 /* OpenParenToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 73 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));

                    this.SpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(27 /* FunctionKeyword */, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    this.NoSpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(27 /* FunctionKeyword */, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 3 /* Delete */));
                }
                Rules.prototype.getRuleName = function (rule) {
                    var o = this;
                    for (var name in o) {
                        if (o[name] === rule) {
                            return name;
                        }
                    }
                    throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unknown_rule, null));
                };

                Rules.IsForContext = function (context) {
                    return context.contextNode.kind() === 155 /* ForStatement */;
                };

                Rules.IsNotForContext = function (context) {
                    return !Rules.IsForContext(context);
                };

                Rules.IsBinaryOpContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 175 /* AssignmentExpression */:
                        case 176 /* AddAssignmentExpression */:
                        case 177 /* SubtractAssignmentExpression */:
                        case 178 /* MultiplyAssignmentExpression */:
                        case 179 /* DivideAssignmentExpression */:
                        case 180 /* ModuloAssignmentExpression */:
                        case 181 /* AndAssignmentExpression */:
                        case 182 /* ExclusiveOrAssignmentExpression */:
                        case 183 /* OrAssignmentExpression */:
                        case 184 /* LeftShiftAssignmentExpression */:
                        case 185 /* SignedRightShiftAssignmentExpression */:
                        case 186 /* UnsignedRightShiftAssignmentExpression */:
                        case 187 /* ConditionalExpression */:
                        case 188 /* LogicalOrExpression */:
                        case 189 /* LogicalAndExpression */:
                        case 190 /* BitwiseOrExpression */:
                        case 191 /* BitwiseExclusiveOrExpression */:
                        case 192 /* BitwiseAndExpression */:
                        case 193 /* EqualsWithTypeConversionExpression */:
                        case 194 /* NotEqualsWithTypeConversionExpression */:
                        case 195 /* EqualsExpression */:
                        case 196 /* NotEqualsExpression */:
                        case 197 /* LessThanExpression */:
                        case 198 /* GreaterThanExpression */:
                        case 199 /* LessThanOrEqualExpression */:
                        case 200 /* GreaterThanOrEqualExpression */:
                        case 201 /* InstanceOfExpression */:
                        case 202 /* InExpression */:
                        case 203 /* LeftShiftExpression */:
                        case 204 /* SignedRightShiftExpression */:
                        case 205 /* UnsignedRightShiftExpression */:
                        case 206 /* MultiplyExpression */:
                        case 207 /* DivideExpression */:
                        case 208 /* ModuloExpression */:
                        case 209 /* AddExpression */:
                        case 210 /* SubtractExpression */:
                            return true;

                        case 134 /* ImportDeclaration */:

                        case 226 /* VariableDeclarator */:
                        case 233 /* EqualsValueClause */:
                            return context.currentTokenSpan.kind === 107 /* EqualsToken */ || context.nextTokenSpan.kind === 107 /* EqualsToken */;

                        case 156 /* ForInStatement */:
                            return context.currentTokenSpan.kind === 29 /* InKeyword */ || context.nextTokenSpan.kind === 29 /* InKeyword */;
                    }
                    return false;
                };

                Rules.IsNotBinaryOpContext = function (context) {
                    return !Rules.IsBinaryOpContext(context);
                };

                Rules.IsSameLineTokenOrBeforeMultilineBlockContext = function (context) {
                    return context.TokensAreOnSameLine() || Rules.IsBeforeMultilineBlockContext(context);
                };

                Rules.IsBeforeMultilineBlockContext = function (context) {
                    return Rules.IsBeforeBlockContext(context) && !(context.NextNodeAllOnSameLine() || context.NextNodeBlockIsOnOneLine());
                };

                Rules.IsMultilineBlockContext = function (context) {
                    return Rules.IsBlockContext(context) && !(context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
                };

                Rules.IsSingleLineBlockContext = function (context) {
                    return Rules.IsBlockContext(context) && (context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
                };

                Rules.IsBlockContext = function (context) {
                    return Rules.NodeIsBlockContext(context.contextNode);
                };

                Rules.IsBeforeBlockContext = function (context) {
                    return Rules.NodeIsBlockContext(context.nextTokenParent);
                };

                Rules.NodeIsBlockContext = function (node) {
                    if (Rules.NodeIsTypeScriptDeclWithBlockContext(node)) {
                        return true;
                    }

                    switch (node.kind()) {
                        case 147 /* Block */:
                        case 152 /* SwitchStatement */:
                        case 216 /* ObjectLiteralExpression */:
                            return true;
                    }

                    return false;
                };

                Rules.IsFunctionDeclContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 130 /* FunctionDeclaration */:
                        case 136 /* MemberFunctionDeclaration */:
                        case 140 /* GetAccessor */:
                        case 141 /* SetAccessor */:
                        case 146 /* MethodSignature */:
                        case 143 /* CallSignature */:
                        case 223 /* FunctionExpression */:
                        case 138 /* ConstructorDeclaration */:
                        case 220 /* SimpleArrowFunctionExpression */:
                        case 219 /* ParenthesizedArrowFunctionExpression */:
                        case 129 /* InterfaceDeclaration */:
                            return true;
                    }

                    return false;
                };

                Rules.IsTypeScriptDeclWithBlockContext = function (context) {
                    return Rules.NodeIsTypeScriptDeclWithBlockContext(context.contextNode);
                };

                Rules.NodeIsTypeScriptDeclWithBlockContext = function (node) {
                    switch (node.kind()) {
                        case 132 /* ClassDeclaration */:
                        case 133 /* EnumDeclaration */:
                        case 122 /* ObjectType */:
                        case 131 /* ModuleDeclaration */:
                            return true;
                    }

                    return false;
                };

                Rules.IsAfterCodeBlockContext = function (context) {
                    switch (context.currentTokenParent.kind()) {
                        case 132 /* ClassDeclaration */:
                        case 131 /* ModuleDeclaration */:
                        case 133 /* EnumDeclaration */:
                        case 147 /* Block */:
                        case 152 /* SwitchStatement */:
                            return true;
                    }
                    return false;
                };

                Rules.IsControlDeclContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 148 /* IfStatement */:
                        case 152 /* SwitchStatement */:
                        case 155 /* ForStatement */:
                        case 156 /* ForInStatement */:
                        case 159 /* WhileStatement */:
                        case 160 /* TryStatement */:
                        case 162 /* DoStatement */:
                        case 164 /* WithStatement */:
                        case 236 /* ElseClause */:
                        case 237 /* CatchClause */:
                        case 238 /* FinallyClause */:
                            return true;

                        default:
                            return false;
                    }
                };

                Rules.IsObjectContext = function (context) {
                    return context.contextNode.kind() === 216 /* ObjectLiteralExpression */;
                };

                Rules.IsFunctionCallContext = function (context) {
                    return context.contextNode.kind() === 214 /* InvocationExpression */;
                };

                Rules.IsNewContext = function (context) {
                    return context.contextNode.kind() === 217 /* ObjectCreationExpression */;
                };

                Rules.IsFunctionCallOrNewContext = function (context) {
                    return Rules.IsFunctionCallContext(context) || Rules.IsNewContext(context);
                };

                Rules.IsSameLineTokenContext = function (context) {
                    return context.TokensAreOnSameLine();
                };

                Rules.IsNotFormatOnEnter = function (context) {
                    return context.formattingRequestKind != 2 /* FormatOnEnter */;
                };

                Rules.IsModuleDeclContext = function (context) {
                    return context.contextNode.kind() === 131 /* ModuleDeclaration */;
                };

                Rules.IsObjectTypeContext = function (context) {
                    return context.contextNode.kind() === 122 /* ObjectType */ && context.contextNode.parent().kind() !== 129 /* InterfaceDeclaration */;
                };

                Rules.IsTypeArgumentOrParameter = function (tokenKind, parentKind) {
                    return ((tokenKind === 80 /* LessThanToken */ || tokenKind === 81 /* GreaterThanToken */) && (parentKind === 230 /* TypeParameterList */ || parentKind === 229 /* TypeArgumentList */));
                };

                Rules.IsTypeArgumentOrParameterContext = function (context) {
                    return Rules.IsTypeArgumentOrParameter(context.currentTokenSpan.kind, context.currentTokenParent.kind()) || Rules.IsTypeArgumentOrParameter(context.nextTokenSpan.kind, context.nextTokenParent.kind());
                };

                Rules.IsVoidOpContext = function (context) {
                    return context.currentTokenSpan.kind === 41 /* VoidKeyword */ && context.currentTokenParent.kind() === 173 /* VoidExpression */;
                };
                return Rules;
            })();
            Formatting.Rules = Rules;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var RulesMap = (function () {
                function RulesMap() {
                    this.map = [];
                    this.mapRowLength = 0;
                }
                RulesMap.create = function (rules) {
                    var result = new RulesMap();
                    result.Initialize(rules);
                    return result;
                };

                RulesMap.prototype.Initialize = function (rules) {
                    this.mapRowLength = 119 /* LastToken */ + 1;
                    this.map = new Array(this.mapRowLength * this.mapRowLength);

                    var rulesBucketConstructionStateList = new Array(this.map.length);

                    this.FillRules(rules, rulesBucketConstructionStateList);
                    return this.map;
                };

                RulesMap.prototype.FillRules = function (rules, rulesBucketConstructionStateList) {
                    var _this = this;
                    rules.forEach(function (rule) {
                        _this.FillRule(rule, rulesBucketConstructionStateList);
                    });
                };

                RulesMap.prototype.GetRuleBucketIndex = function (row, column) {
                    var rulesBucketIndex = (row * this.mapRowLength) + column;

                    return rulesBucketIndex;
                };

                RulesMap.prototype.FillRule = function (rule, rulesBucketConstructionStateList) {
                    var _this = this;
                    var specificRule = rule.Descriptor.LeftTokenRange != Formatting.Shared.TokenRange.Any && rule.Descriptor.RightTokenRange != Formatting.Shared.TokenRange.Any;

                    rule.Descriptor.LeftTokenRange.GetTokens().forEach(function (left) {
                        rule.Descriptor.RightTokenRange.GetTokens().forEach(function (right) {
                            var rulesBucketIndex = _this.GetRuleBucketIndex(left, right);

                            var rulesBucket = _this.map[rulesBucketIndex];
                            if (rulesBucket == undefined) {
                                rulesBucket = _this.map[rulesBucketIndex] = new RulesBucket();
                            }

                            rulesBucket.AddRule(rule, specificRule, rulesBucketConstructionStateList, rulesBucketIndex);
                        });
                    });
                };

                RulesMap.prototype.GetRule = function (context) {
                    var bucketIndex = this.GetRuleBucketIndex(context.currentTokenSpan.kind, context.nextTokenSpan.kind);
                    var bucket = this.map[bucketIndex];
                    if (bucket != null) {
                        for (var i = 0, len = bucket.Rules().length; i < len; i++) {
                            var rule = bucket.Rules()[i];
                            if (rule.Operation.Context.InContext(context))
                                return rule;
                        }
                    }
                    return null;
                };
                return RulesMap;
            })();
            Formatting.RulesMap = RulesMap;

            var MaskBitSize = 5;
            var Mask = 0x1f;

            (function (RulesPosition) {
                RulesPosition[RulesPosition["IgnoreRulesSpecific"] = 0] = "IgnoreRulesSpecific";
                RulesPosition[RulesPosition["IgnoreRulesAny"] = MaskBitSize * 1] = "IgnoreRulesAny";
                RulesPosition[RulesPosition["ContextRulesSpecific"] = MaskBitSize * 2] = "ContextRulesSpecific";
                RulesPosition[RulesPosition["ContextRulesAny"] = MaskBitSize * 3] = "ContextRulesAny";
                RulesPosition[RulesPosition["NoContextRulesSpecific"] = MaskBitSize * 4] = "NoContextRulesSpecific";
                RulesPosition[RulesPosition["NoContextRulesAny"] = MaskBitSize * 5] = "NoContextRulesAny";
            })(Formatting.RulesPosition || (Formatting.RulesPosition = {}));
            var RulesPosition = Formatting.RulesPosition;

            var RulesBucketConstructionState = (function () {
                function RulesBucketConstructionState() {
                    this.rulesInsertionIndexBitmap = 0;
                }
                RulesBucketConstructionState.prototype.GetInsertionIndex = function (maskPosition) {
                    var index = 0;

                    var pos = 0;
                    var indexBitmap = this.rulesInsertionIndexBitmap;

                    while (pos <= maskPosition) {
                        index += (indexBitmap & Mask);
                        indexBitmap >>= MaskBitSize;
                        pos += MaskBitSize;
                    }

                    return index;
                };

                RulesBucketConstructionState.prototype.IncreaseInsertionIndex = function (maskPosition) {
                    var value = (this.rulesInsertionIndexBitmap >> maskPosition) & Mask;
                    value++;
                    TypeScript.Debug.assert((value & Mask) == value, "Adding more rules into the sub-bucket than allowed. Maximum allowed is 32 rules.");

                    var temp = this.rulesInsertionIndexBitmap & ~(Mask << maskPosition);
                    temp |= value << maskPosition;

                    this.rulesInsertionIndexBitmap = temp;
                };
                return RulesBucketConstructionState;
            })();
            Formatting.RulesBucketConstructionState = RulesBucketConstructionState;

            var RulesBucket = (function () {
                function RulesBucket() {
                    this.rules = [];
                }
                RulesBucket.prototype.Rules = function () {
                    return this.rules;
                };

                RulesBucket.prototype.AddRule = function (rule, specificTokens, constructionState, rulesBucketIndex) {
                    var position;

                    if (rule.Operation.Action == 0 /* Ignore */) {
                        position = specificTokens ? 0 /* IgnoreRulesSpecific */ : RulesPosition.IgnoreRulesAny;
                    } else if (!rule.Operation.Context.IsAny()) {
                        position = specificTokens ? RulesPosition.ContextRulesSpecific : RulesPosition.ContextRulesAny;
                    } else {
                        position = specificTokens ? RulesPosition.NoContextRulesSpecific : RulesPosition.NoContextRulesAny;
                    }

                    var state = constructionState[rulesBucketIndex];
                    if (state === undefined) {
                        state = constructionState[rulesBucketIndex] = new RulesBucketConstructionState();
                    }
                    var index = state.GetInsertionIndex(position);
                    this.rules.splice(index, 0, rule);
                    state.IncreaseInsertionIndex(position);
                };
                return RulesBucket;
            })();
            Formatting.RulesBucket = RulesBucket;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var RulesProvider = (function () {
                function RulesProvider(logger) {
                    this.logger = logger;
                    this.globalRules = new Formatting.Rules();
                }
                RulesProvider.prototype.getRuleName = function (rule) {
                    return this.globalRules.getRuleName(rule);
                };

                RulesProvider.prototype.getRuleByName = function (name) {
                    return this.globalRules[name];
                };

                RulesProvider.prototype.getRulesMap = function () {
                    return this.rulesMap;
                };

                RulesProvider.prototype.ensureUpToDate = function (options) {
                    var _this = this;
                    if (this.options == null || !TypeScript.compareDataObjects(this.options, options)) {
                        var activeRules = TypeScript.timeFunction(this.logger, "RulesProvider: createActiveRules()", function () {
                            return _this.createActiveRules(options);
                        });
                        var rulesMap = TypeScript.timeFunction(this.logger, "RulesProvider: RulesMap.create()", function () {
                            return Formatting.RulesMap.create(activeRules);
                        });

                        this.activeRules = activeRules;
                        this.rulesMap = rulesMap;
                        this.options = TypeScript.Services.FormatCodeOptions.clone(options);
                    }
                };

                RulesProvider.prototype.createActiveRules = function (options) {
                    var rules = this.globalRules.HighPriorityCommonRules.slice(0);

                    if (options.InsertSpaceAfterCommaDelimiter) {
                        rules.push(this.globalRules.SpaceAfterComma);
                    } else {
                        rules.push(this.globalRules.NoSpaceAfterComma);
                    }

                    if (options.InsertSpaceAfterFunctionKeywordForAnonymousFunctions) {
                        rules.push(this.globalRules.SpaceAfterAnonymousFunctionKeyword);
                    } else {
                        rules.push(this.globalRules.NoSpaceAfterAnonymousFunctionKeyword);
                    }

                    if (options.InsertSpaceAfterKeywordsInControlFlowStatements) {
                        rules.push(this.globalRules.SpaceAfterKeywordInControl);
                    } else {
                        rules.push(this.globalRules.NoSpaceAfterKeywordInControl);
                    }

                    if (options.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis) {
                        rules.push(this.globalRules.SpaceAfterOpenParen);
                        rules.push(this.globalRules.SpaceBeforeCloseParen);
                        rules.push(this.globalRules.NoSpaceBetweenParens);
                    } else {
                        rules.push(this.globalRules.NoSpaceAfterOpenParen);
                        rules.push(this.globalRules.NoSpaceBeforeCloseParen);
                        rules.push(this.globalRules.NoSpaceBetweenParens);
                    }

                    if (options.InsertSpaceAfterSemicolonInForStatements) {
                        rules.push(this.globalRules.SpaceAfterSemicolonInFor);
                    } else {
                        rules.push(this.globalRules.NoSpaceAfterSemicolonInFor);
                    }

                    if (options.InsertSpaceBeforeAndAfterBinaryOperators) {
                        rules.push(this.globalRules.SpaceBeforeBinaryOperator);
                        rules.push(this.globalRules.SpaceAfterBinaryOperator);
                    } else {
                        rules.push(this.globalRules.NoSpaceBeforeBinaryOperator);
                        rules.push(this.globalRules.NoSpaceAfterBinaryOperator);
                    }

                    if (options.PlaceOpenBraceOnNewLineForControlBlocks) {
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInControl);
                    }

                    if (options.PlaceOpenBraceOnNewLineForFunctions) {
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInFunction);
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock);
                    }

                    rules = rules.concat(this.globalRules.LowPriorityCommonRules);

                    return rules;
                };
                return RulesProvider;
            })();
            Formatting.RulesProvider = RulesProvider;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var TextEditInfo = (function () {
                function TextEditInfo(position, length, replaceWith) {
                    this.position = position;
                    this.length = length;
                    this.replaceWith = replaceWith;
                }
                TextEditInfo.prototype.toString = function () {
                    return "[ position: " + this.position + ", length: " + this.length + ", replaceWith: '" + this.replaceWith + "' ]";
                };
                return TextEditInfo;
            })();
            Formatting.TextEditInfo = TextEditInfo;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            (function (Shared) {
                var TokenRangeAccess = (function () {
                    function TokenRangeAccess(from, to, except) {
                        this.tokens = [];
                        for (var token = from; token <= to; token++) {
                            if (except.indexOf(token) < 0) {
                                this.tokens.push(token);
                            }
                        }
                    }
                    TokenRangeAccess.prototype.GetTokens = function () {
                        return this.tokens;
                    };

                    TokenRangeAccess.prototype.Contains = function (token) {
                        return this.tokens.indexOf(token) >= 0;
                    };

                    TokenRangeAccess.prototype.toString = function () {
                        return "[tokenRangeStart=" + TypeScript.SyntaxKind[this.tokens[0]] + "," + "tokenRangeEnd=" + TypeScript.SyntaxKind[this.tokens[this.tokens.length - 1]] + "]";
                    };
                    return TokenRangeAccess;
                })();
                Shared.TokenRangeAccess = TokenRangeAccess;

                var TokenValuesAccess = (function () {
                    function TokenValuesAccess(tks) {
                        this.tokens = tks && tks.length ? tks : [];
                    }
                    TokenValuesAccess.prototype.GetTokens = function () {
                        return this.tokens;
                    };

                    TokenValuesAccess.prototype.Contains = function (token) {
                        return this.tokens.indexOf(token) >= 0;
                    };
                    return TokenValuesAccess;
                })();
                Shared.TokenValuesAccess = TokenValuesAccess;

                var TokenSingleValueAccess = (function () {
                    function TokenSingleValueAccess(token) {
                        this.token = token;
                    }
                    TokenSingleValueAccess.prototype.GetTokens = function () {
                        return [this.token];
                    };

                    TokenSingleValueAccess.prototype.Contains = function (tokenValue) {
                        return tokenValue == this.token;
                    };

                    TokenSingleValueAccess.prototype.toString = function () {
                        return "[singleTokenKind=" + TypeScript.SyntaxKind[this.token] + "]";
                    };
                    return TokenSingleValueAccess;
                })();
                Shared.TokenSingleValueAccess = TokenSingleValueAccess;

                var TokenAllAccess = (function () {
                    function TokenAllAccess() {
                    }
                    TokenAllAccess.prototype.GetTokens = function () {
                        var result = [];
                        for (var token = 9 /* FirstToken */; token <= 119 /* LastToken */; token++) {
                            result.push(token);
                        }
                        return result;
                    };

                    TokenAllAccess.prototype.Contains = function (tokenValue) {
                        return true;
                    };

                    TokenAllAccess.prototype.toString = function () {
                        return "[allTokens]";
                    };
                    return TokenAllAccess;
                })();
                Shared.TokenAllAccess = TokenAllAccess;

                var TokenRange = (function () {
                    function TokenRange(tokenAccess) {
                        this.tokenAccess = tokenAccess;
                    }
                    TokenRange.FromToken = function (token) {
                        return new TokenRange(new TokenSingleValueAccess(token));
                    };

                    TokenRange.FromTokens = function (tokens) {
                        return new TokenRange(new TokenValuesAccess(tokens));
                    };

                    TokenRange.FromRange = function (f, to, except) {
                        if (typeof except === "undefined") { except = []; }
                        return new TokenRange(new TokenRangeAccess(f, to, except));
                    };

                    TokenRange.AllTokens = function () {
                        return new TokenRange(new TokenAllAccess());
                    };

                    TokenRange.prototype.GetTokens = function () {
                        return this.tokenAccess.GetTokens();
                    };

                    TokenRange.prototype.Contains = function (token) {
                        return this.tokenAccess.Contains(token);
                    };

                    TokenRange.prototype.toString = function () {
                        return this.tokenAccess.toString();
                    };

                    TokenRange.Any = TokenRange.AllTokens();
                    TokenRange.AnyIncludingMultilineComments = TokenRange.FromTokens(TokenRange.Any.GetTokens().concat([6 /* MultiLineCommentTrivia */]));
                    TokenRange.Keywords = TokenRange.FromRange(15 /* FirstKeyword */, 69 /* LastKeyword */);
                    TokenRange.Operators = TokenRange.FromRange(78 /* SemicolonToken */, 119 /* SlashEqualsToken */);
                    TokenRange.BinaryOperators = TokenRange.FromRange(80 /* LessThanToken */, 119 /* SlashEqualsToken */);
                    TokenRange.BinaryKeywordOperators = TokenRange.FromTokens([29 /* InKeyword */, 30 /* InstanceOfKeyword */]);
                    TokenRange.ReservedKeywords = TokenRange.FromRange(51 /* FirstFutureReservedStrictKeyword */, 59 /* LastFutureReservedStrictKeyword */);
                    TokenRange.UnaryPrefixOperators = TokenRange.FromTokens([93 /* PlusPlusToken */, 94 /* MinusMinusToken */, 102 /* TildeToken */, 101 /* ExclamationToken */]);
                    TokenRange.UnaryPrefixExpressions = TokenRange.FromTokens([13 /* NumericLiteral */, 11 /* IdentifierName */, 72 /* OpenParenToken */, 74 /* OpenBracketToken */, 70 /* OpenBraceToken */, 35 /* ThisKeyword */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPreincrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 72 /* OpenParenToken */, 35 /* ThisKeyword */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPostincrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 73 /* CloseParenToken */, 75 /* CloseBracketToken */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPredecrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 72 /* OpenParenToken */, 35 /* ThisKeyword */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPostdecrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 73 /* CloseParenToken */, 75 /* CloseBracketToken */, 31 /* NewKeyword */]);
                    TokenRange.Comments = TokenRange.FromTokens([7 /* SingleLineCommentTrivia */, 6 /* MultiLineCommentTrivia */]);
                    TokenRange.TypeNames = TokenRange.FromTokens([11 /* IdentifierName */, 67 /* NumberKeyword */, 69 /* StringKeyword */, 61 /* BooleanKeyword */, 41 /* VoidKeyword */, 60 /* AnyKeyword */]);
                    return TokenRange;
                })();
                Shared.TokenRange = TokenRange;
            })(Formatting.Shared || (Formatting.Shared = {}));
            var Shared = Formatting.Shared;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var TokenSpan = (function (_super) {
                __extends(TokenSpan, _super);
                function TokenSpan(kind, start, length) {
                    _super.call(this, start, length);
                    this.kind = kind;
                }
                return TokenSpan;
            })(TypeScript.TextSpan);
            Formatting.TokenSpan = TokenSpan;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var IndentationNodeContext = (function () {
                function IndentationNodeContext(parent, node, fullStart, indentationAmount, childIndentationAmountDelta) {
                    this.update(parent, node, fullStart, indentationAmount, childIndentationAmountDelta);
                }
                IndentationNodeContext.prototype.parent = function () {
                    return this._parent;
                };

                IndentationNodeContext.prototype.node = function () {
                    return this._node;
                };

                IndentationNodeContext.prototype.fullStart = function () {
                    return this._fullStart;
                };

                IndentationNodeContext.prototype.fullWidth = function () {
                    return TypeScript.fullWidth(this._node);
                };

                IndentationNodeContext.prototype.start = function () {
                    return this._fullStart + TypeScript.leadingTriviaWidth(this._node);
                };

                IndentationNodeContext.prototype.end = function () {
                    return this._fullStart + TypeScript.leadingTriviaWidth(this._node) + TypeScript.width(this._node);
                };

                IndentationNodeContext.prototype.indentationAmount = function () {
                    return this._indentationAmount;
                };

                IndentationNodeContext.prototype.childIndentationAmountDelta = function () {
                    return this._childIndentationAmountDelta;
                };

                IndentationNodeContext.prototype.depth = function () {
                    return this._depth;
                };

                IndentationNodeContext.prototype.kind = function () {
                    return this._node.kind();
                };

                IndentationNodeContext.prototype.hasSkippedOrMissingTokenChild = function () {
                    if (this._hasSkippedOrMissingTokenChild === null) {
                        this._hasSkippedOrMissingTokenChild = TypeScript.Syntax.nodeHasSkippedOrMissingTokens(this._node);
                    }
                    return this._hasSkippedOrMissingTokenChild;
                };

                IndentationNodeContext.prototype.clone = function (pool) {
                    var parent = null;
                    if (this._parent) {
                        parent = this._parent.clone(pool);
                    }
                    return pool.getNode(parent, this._node, this._fullStart, this._indentationAmount, this._childIndentationAmountDelta);
                };

                IndentationNodeContext.prototype.update = function (parent, node, fullStart, indentationAmount, childIndentationAmountDelta) {
                    this._parent = parent;
                    this._node = node;
                    this._fullStart = fullStart;
                    this._indentationAmount = indentationAmount;
                    this._childIndentationAmountDelta = childIndentationAmountDelta;
                    this._hasSkippedOrMissingTokenChild = null;

                    if (parent) {
                        this._depth = parent.depth() + 1;
                    } else {
                        this._depth = 0;
                    }
                };
                return IndentationNodeContext;
            })();
            Formatting.IndentationNodeContext = IndentationNodeContext;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var IndentationNodeContextPool = (function () {
                function IndentationNodeContextPool() {
                    this.nodes = [];
                }
                IndentationNodeContextPool.prototype.getNode = function (parent, node, fullStart, indentationLevel, childIndentationLevelDelta) {
                    if (this.nodes.length > 0) {
                        var cachedNode = this.nodes.pop();
                        cachedNode.update(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
                        return cachedNode;
                    }

                    return new Formatting.IndentationNodeContext(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
                };

                IndentationNodeContextPool.prototype.releaseNode = function (node, recursive) {
                    if (typeof recursive === "undefined") { recursive = false; }
                    this.nodes.push(node);

                    if (recursive) {
                        var parent = node.parent();
                        if (parent) {
                            this.releaseNode(parent, recursive);
                        }
                    }
                };
                return IndentationNodeContextPool;
            })();
            Formatting.IndentationNodeContextPool = IndentationNodeContextPool;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var IndentationTrackingWalker = (function (_super) {
                __extends(IndentationTrackingWalker, _super);
                function IndentationTrackingWalker(textSpan, sourceUnit, snapshot, indentFirstToken, options) {
                    _super.call(this);
                    this.options = options;
                    this._position = 0;
                    this._parent = null;

                    this._indentationNodeContextPool = new Formatting.IndentationNodeContextPool();

                    this._textSpan = textSpan;
                    this._text = sourceUnit.syntaxTree.text;
                    this._snapshot = snapshot;
                    this._parent = this._indentationNodeContextPool.getNode(null, sourceUnit, 0, 0, 0);

                    this._lastTriviaWasNewLine = indentFirstToken;
                }
                IndentationTrackingWalker.prototype.position = function () {
                    return this._position;
                };

                IndentationTrackingWalker.prototype.parent = function () {
                    return this._parent;
                };

                IndentationTrackingWalker.prototype.textSpan = function () {
                    return this._textSpan;
                };

                IndentationTrackingWalker.prototype.snapshot = function () {
                    return this._snapshot;
                };

                IndentationTrackingWalker.prototype.indentationNodeContextPool = function () {
                    return this._indentationNodeContextPool;
                };

                IndentationTrackingWalker.prototype.forceIndentNextToken = function (tokenStart) {
                    this._lastTriviaWasNewLine = true;
                    this.forceRecomputeIndentationOfParent(tokenStart, true);
                };

                IndentationTrackingWalker.prototype.forceSkipIndentingNextToken = function (tokenStart) {
                    this._lastTriviaWasNewLine = false;
                    this.forceRecomputeIndentationOfParent(tokenStart, false);
                };

                IndentationTrackingWalker.prototype.indentToken = function (token, indentationAmount, commentIndentationAmount) {
                    throw TypeScript.Errors.abstract();
                };

                IndentationTrackingWalker.prototype.visitTokenInSpan = function (token) {
                    if (this._lastTriviaWasNewLine) {
                        var indentationAmount = this.getTokenIndentationAmount(token);
                        var commentIndentationAmount = this.getCommentIndentationAmount(token);

                        this.indentToken(token, indentationAmount, commentIndentationAmount);
                    }
                };

                IndentationTrackingWalker.prototype.visitToken = function (token) {
                    var tokenSpan = new TypeScript.TextSpan(this._position, token.fullWidth());

                    if (tokenSpan.intersectsWithTextSpan(this._textSpan)) {
                        this.visitTokenInSpan(token);

                        var trivia = token.trailingTrivia();
                        this._lastTriviaWasNewLine = trivia.hasNewLine() && trivia.syntaxTriviaAt(trivia.count() - 1).kind() == 5 /* NewLineTrivia */;
                    }

                    this._position += token.fullWidth();
                };

                IndentationTrackingWalker.prototype.visitNode = function (node) {
                    var nodeSpan = new TypeScript.TextSpan(this._position, TypeScript.fullWidth(node));

                    if (nodeSpan.intersectsWithTextSpan(this._textSpan)) {
                        var indentation = this.getNodeIndentation(node);

                        var currentParent = this._parent;
                        this._parent = this._indentationNodeContextPool.getNode(currentParent, node, this._position, indentation.indentationAmount, indentation.indentationAmountDelta);

                        TypeScript.visitNodeOrToken(this, node);

                        this._indentationNodeContextPool.releaseNode(this._parent);
                        this._parent = currentParent;
                    } else {
                        this._position += TypeScript.fullWidth(node);
                    }
                };

                IndentationTrackingWalker.prototype.getTokenIndentationAmount = function (token) {
                    if (TypeScript.firstToken(this._parent.node()) === token || token.kind() === 70 /* OpenBraceToken */ || token.kind() === 71 /* CloseBraceToken */ || token.kind() === 74 /* OpenBracketToken */ || token.kind() === 75 /* CloseBracketToken */ || (token.kind() === 42 /* WhileKeyword */ && this._parent.node().kind() == 162 /* DoStatement */)) {
                        return this._parent.indentationAmount();
                    }

                    return (this._parent.indentationAmount() + this._parent.childIndentationAmountDelta());
                };

                IndentationTrackingWalker.prototype.getCommentIndentationAmount = function (token) {
                    if (token.kind() === 71 /* CloseBraceToken */ || token.kind() === 75 /* CloseBracketToken */) {
                        return (this._parent.indentationAmount() + this._parent.childIndentationAmountDelta());
                    }
                    return this._parent.indentationAmount();
                };

                IndentationTrackingWalker.prototype.getNodeIndentation = function (node, newLineInsertedByFormatting) {
                    var parent = this._parent;

                    var parentIndentationAmount;
                    if (this._textSpan.containsPosition(parent.start())) {
                        parentIndentationAmount = parent.indentationAmount();
                    } else {
                        if (parent.kind() === 147 /* Block */ && !this.shouldIndentBlockInParent(this._parent.parent())) {
                            parent = this._parent.parent();
                        }

                        var line = this._snapshot.getLineFromPosition(parent.start()).getText();
                        var firstNonWhiteSpacePosition = TypeScript.Indentation.firstNonWhitespacePosition(line);
                        parentIndentationAmount = TypeScript.Indentation.columnForPositionInString(line, firstNonWhiteSpacePosition, this.options);
                    }
                    var parentIndentationAmountDelta = parent.childIndentationAmountDelta();

                    var indentationAmount;

                    var indentationAmountDelta;
                    var parentNode = parent.node();

                    switch (node.kind()) {
                        default:
                            indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            indentationAmountDelta = 0;
                            break;

                        case 132 /* ClassDeclaration */:
                        case 131 /* ModuleDeclaration */:
                        case 122 /* ObjectType */:
                        case 133 /* EnumDeclaration */:
                        case 152 /* SwitchStatement */:
                        case 216 /* ObjectLiteralExpression */:
                        case 138 /* ConstructorDeclaration */:
                        case 130 /* FunctionDeclaration */:
                        case 223 /* FunctionExpression */:
                        case 136 /* MemberFunctionDeclaration */:
                        case 140 /* GetAccessor */:
                        case 141 /* SetAccessor */:
                        case 139 /* IndexMemberDeclaration */:
                        case 237 /* CatchClause */:

                        case 215 /* ArrayLiteralExpression */:
                        case 124 /* ArrayType */:
                        case 222 /* ElementAccessExpression */:
                        case 145 /* IndexSignature */:

                        case 155 /* ForStatement */:
                        case 156 /* ForInStatement */:
                        case 159 /* WhileStatement */:
                        case 162 /* DoStatement */:
                        case 164 /* WithStatement */:
                        case 234 /* CaseSwitchClause */:
                        case 235 /* DefaultSwitchClause */:
                        case 151 /* ReturnStatement */:
                        case 158 /* ThrowStatement */:
                        case 220 /* SimpleArrowFunctionExpression */:
                        case 219 /* ParenthesizedArrowFunctionExpression */:
                        case 225 /* VariableDeclaration */:
                        case 135 /* ExportAssignment */:

                        case 214 /* InvocationExpression */:
                        case 217 /* ObjectCreationExpression */:
                        case 143 /* CallSignature */:
                        case 144 /* ConstructSignature */:
                            indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            indentationAmountDelta = this.options.indentSpaces;
                            break;

                        case 148 /* IfStatement */:
                            if (parent.kind() === 236 /* ElseClause */ && !TypeScript.SyntaxUtilities.isLastTokenOnLine(parentNode.elseKeyword, this._text)) {
                                indentationAmount = parentIndentationAmount;
                            } else {
                                indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            }
                            indentationAmountDelta = this.options.indentSpaces;
                            break;

                        case 236 /* ElseClause */:
                            indentationAmount = parentIndentationAmount;
                            indentationAmountDelta = this.options.indentSpaces;
                            break;

                        case 147 /* Block */:
                            if (this.shouldIndentBlockInParent(parent)) {
                                indentationAmount = parentIndentationAmount + parentIndentationAmountDelta;
                            } else {
                                indentationAmount = parentIndentationAmount;
                            }

                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                    }

                    if (parentNode) {
                        if (!newLineInsertedByFormatting) {
                            var parentStartLine = this._snapshot.getLineNumberFromPosition(parent.start());
                            var currentNodeStartLine = this._snapshot.getLineNumberFromPosition(this._position + TypeScript.leadingTriviaWidth(node));
                            if (parentStartLine === currentNodeStartLine || newLineInsertedByFormatting === false) {
                                indentationAmount = parentIndentationAmount;
                                indentationAmountDelta = Math.min(this.options.indentSpaces, parentIndentationAmountDelta + indentationAmountDelta);
                            }
                        }
                    }

                    return {
                        indentationAmount: indentationAmount,
                        indentationAmountDelta: indentationAmountDelta
                    };
                };

                IndentationTrackingWalker.prototype.shouldIndentBlockInParent = function (parent) {
                    switch (parent.kind()) {
                        case 120 /* SourceUnit */:
                        case 131 /* ModuleDeclaration */:
                        case 147 /* Block */:
                        case 234 /* CaseSwitchClause */:
                        case 235 /* DefaultSwitchClause */:
                            return true;

                        default:
                            return false;
                    }
                };

                IndentationTrackingWalker.prototype.forceRecomputeIndentationOfParent = function (tokenStart, newLineAdded) {
                    var parent = this._parent;
                    if (parent.fullStart() === tokenStart) {
                        this._parent = parent.parent();
                        var indentation = this.getNodeIndentation(parent.node(), newLineAdded);
                        parent.update(parent.parent(), parent.node(), parent.fullStart(), indentation.indentationAmount, indentation.indentationAmountDelta);
                        this._parent = parent;
                    }
                };
                return IndentationTrackingWalker;
            })(TypeScript.SyntaxWalker);
            Formatting.IndentationTrackingWalker = IndentationTrackingWalker;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var MultipleTokenIndenter = (function (_super) {
                __extends(MultipleTokenIndenter, _super);
                function MultipleTokenIndenter(textSpan, sourceUnit, snapshot, indentFirstToken, options) {
                    _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken, options);
                    this._edits = [];
                }
                MultipleTokenIndenter.prototype.indentToken = function (token, indentationAmount, commentIndentationAmount) {
                    if (token.fullWidth() === 0) {
                        return;
                    }

                    if (this.parent().hasSkippedOrMissingTokenChild()) {
                        return;
                    }

                    var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), TypeScript.width(token));
                    if (!this.textSpan().containsTextSpan(tokenSpan)) {
                        return;
                    }

                    var indentationString = TypeScript.Indentation.indentationString(indentationAmount, this.options);

                    var commentIndentationString = TypeScript.Indentation.indentationString(commentIndentationAmount, this.options);

                    this.recordIndentationEditsForToken(token, indentationString, commentIndentationString);
                };

                MultipleTokenIndenter.prototype.edits = function () {
                    return this._edits;
                };

                MultipleTokenIndenter.prototype.recordEdit = function (position, length, replaceWith) {
                    this._edits.push(new Formatting.TextEditInfo(position, length, replaceWith));
                };

                MultipleTokenIndenter.prototype.recordIndentationEditsForToken = function (token, indentationString, commentIndentationString) {
                    var position = this.position();
                    var indentNextTokenOrTrivia = true;
                    var leadingWhiteSpace = "";

                    var triviaList = token.leadingTrivia();
                    if (triviaList) {
                        for (var i = 0, length = triviaList.count(); i < length; i++, position += trivia.fullWidth()) {
                            var trivia = triviaList.syntaxTriviaAt(i);

                            if (!this.textSpan().containsTextSpan(new TypeScript.TextSpan(position, trivia.fullWidth()))) {
                                continue;
                            }

                            switch (trivia.kind()) {
                                case 6 /* MultiLineCommentTrivia */:
                                    this.recordIndentationEditsForMultiLineComment(trivia, position, commentIndentationString, leadingWhiteSpace, !indentNextTokenOrTrivia);
                                    indentNextTokenOrTrivia = false;
                                    leadingWhiteSpace = "";
                                    break;

                                case 7 /* SingleLineCommentTrivia */:
                                case 8 /* SkippedTokenTrivia */:
                                    if (indentNextTokenOrTrivia) {
                                        this.recordIndentationEditsForSingleLineOrSkippedText(trivia, position, commentIndentationString);
                                        indentNextTokenOrTrivia = false;
                                    }
                                    break;

                                case 4 /* WhitespaceTrivia */:
                                    var nextTrivia = length > i + 1 && triviaList.syntaxTriviaAt(i + 1);
                                    var whiteSpaceIndentationString = nextTrivia && nextTrivia.isComment() ? commentIndentationString : indentationString;
                                    if (indentNextTokenOrTrivia) {
                                        if (!(nextTrivia && nextTrivia.isNewLine())) {
                                            this.recordIndentationEditsForWhitespace(trivia, position, whiteSpaceIndentationString);
                                        }
                                        indentNextTokenOrTrivia = false;
                                    }
                                    leadingWhiteSpace += trivia.fullText();
                                    break;

                                case 5 /* NewLineTrivia */:
                                    indentNextTokenOrTrivia = true;
                                    leadingWhiteSpace = "";
                                    break;

                                default:
                                    throw TypeScript.Errors.invalidOperation();
                            }
                        }
                    }

                    if (token.kind() !== 10 /* EndOfFileToken */ && indentNextTokenOrTrivia) {
                        if (indentationString.length > 0) {
                            this.recordEdit(position, 0, indentationString);
                        }
                    }
                };

                MultipleTokenIndenter.prototype.recordIndentationEditsForSingleLineOrSkippedText = function (trivia, fullStart, indentationString) {
                    if (indentationString.length > 0) {
                        this.recordEdit(fullStart, 0, indentationString);
                    }
                };

                MultipleTokenIndenter.prototype.recordIndentationEditsForWhitespace = function (trivia, fullStart, indentationString) {
                    var text = trivia.fullText();

                    if (indentationString === text) {
                        return;
                    }

                    this.recordEdit(fullStart, text.length, indentationString);
                };

                MultipleTokenIndenter.prototype.recordIndentationEditsForMultiLineComment = function (trivia, fullStart, indentationString, leadingWhiteSpace, firstLineAlreadyIndented) {
                    var position = fullStart;
                    var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);

                    if (segments.length <= 1) {
                        if (!firstLineAlreadyIndented) {
                            this.recordIndentationEditsForSingleLineOrSkippedText(trivia, fullStart, indentationString);
                        }
                        return;
                    }

                    var whiteSpaceColumnsInFirstSegment = TypeScript.Indentation.columnForPositionInString(leadingWhiteSpace, leadingWhiteSpace.length, this.options);

                    var indentationColumns = TypeScript.Indentation.columnForPositionInString(indentationString, indentationString.length, this.options);
                    var startIndex = 0;
                    if (firstLineAlreadyIndented) {
                        startIndex = 1;
                        position += segments[0].length;
                    }
                    for (var i = startIndex; i < segments.length; i++) {
                        var segment = segments[i];
                        this.recordIndentationEditsForSegment(segment, position, indentationColumns, whiteSpaceColumnsInFirstSegment);
                        position += segment.length;
                    }
                };

                MultipleTokenIndenter.prototype.recordIndentationEditsForSegment = function (segment, fullStart, indentationColumns, whiteSpaceColumnsInFirstSegment) {
                    var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
                    var leadingWhiteSpaceColumns = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
                    var deltaFromFirstSegment = leadingWhiteSpaceColumns - whiteSpaceColumnsInFirstSegment;
                    var finalColumns = indentationColumns + deltaFromFirstSegment;
                    if (finalColumns < 0) {
                        finalColumns = 0;
                    }
                    var indentationString = TypeScript.Indentation.indentationString(finalColumns, this.options);

                    if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                        return;
                    }

                    if (indentationString === segment.substring(0, firstNonWhitespacePosition)) {
                        return;
                    }

                    this.recordEdit(fullStart, firstNonWhitespacePosition, indentationString);
                };
                return MultipleTokenIndenter;
            })(Formatting.IndentationTrackingWalker);
            Formatting.MultipleTokenIndenter = MultipleTokenIndenter;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var SingleTokenIndenter = (function (_super) {
                __extends(SingleTokenIndenter, _super);
                function SingleTokenIndenter(indentationPosition, sourceUnit, snapshot, indentFirstToken, options) {
                    _super.call(this, new TypeScript.TextSpan(indentationPosition, 1), sourceUnit, snapshot, indentFirstToken, options);
                    this.indentationAmount = null;

                    this.indentationPosition = indentationPosition;
                }
                SingleTokenIndenter.getIndentationAmount = function (position, sourceUnit, snapshot, options) {
                    var walker = new SingleTokenIndenter(position, sourceUnit, snapshot, true, options);
                    TypeScript.visitNodeOrToken(walker, sourceUnit);
                    return walker.indentationAmount;
                };

                SingleTokenIndenter.prototype.indentToken = function (token, indentationAmount, commentIndentationAmount) {
                    if (token.fullWidth() === 0 || (this.indentationPosition - this.position() < token.leadingTriviaWidth())) {
                        this.indentationAmount = commentIndentationAmount;
                    } else {
                        this.indentationAmount = indentationAmount;
                    }
                };
                return SingleTokenIndenter;
            })(Formatting.IndentationTrackingWalker);
            Formatting.SingleTokenIndenter = SingleTokenIndenter;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Formatting) {
            var Formatter = (function (_super) {
                __extends(Formatter, _super);
                function Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind) {
                    _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken, options);
                    this.previousTokenSpan = null;
                    this.previousTokenParent = null;
                    this.scriptHasErrors = false;

                    this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());

                    this.rulesProvider = rulesProvider;
                    this.formattingRequestKind = formattingRequestKind;
                    this.formattingContext = new Formatting.FormattingContext(this.snapshot(), this.formattingRequestKind);
                }
                Formatter.getEdits = function (textSpan, sourceUnit, options, indentFirstToken, snapshot, rulesProvider, formattingRequestKind) {
                    var walker = new Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind);
                    TypeScript.visitNodeOrToken(walker, sourceUnit);
                    return walker.edits();
                };

                Formatter.prototype.visitTokenInSpan = function (token) {
                    if (token.fullWidth() !== 0) {
                        var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), TypeScript.width(token));
                        if (this.textSpan().containsTextSpan(tokenSpan)) {
                            this.processToken(token);
                        }
                    }

                    _super.prototype.visitTokenInSpan.call(this, token);
                };

                Formatter.prototype.processToken = function (token) {
                    var position = this.position();

                    if (token.leadingTriviaWidth() !== 0) {
                        this.processTrivia(token.leadingTrivia(), position);
                        position += token.leadingTriviaWidth();
                    }

                    var currentTokenSpan = new Formatting.TokenSpan(token.kind(), position, TypeScript.width(token));
                    if (!this.parent().hasSkippedOrMissingTokenChild()) {
                        if (this.previousTokenSpan) {
                            this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                        } else {
                            this.trimWhitespaceInLineRange(this.getLineNumber(this.textSpan()), this.getLineNumber(currentTokenSpan));
                        }
                    }
                    this.previousTokenSpan = currentTokenSpan;
                    if (this.previousTokenParent) {
                        this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                    }
                    this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                    position += TypeScript.width(token);

                    if (token.trailingTriviaWidth() !== 0) {
                        this.processTrivia(token.trailingTrivia(), position);
                    }
                };

                Formatter.prototype.processTrivia = function (triviaList, fullStart) {
                    var position = fullStart;

                    for (var i = 0, n = triviaList.count(); i < n; i++) {
                        var trivia = triviaList.syntaxTriviaAt(i);

                        if (trivia.isComment() || trivia.isSkippedToken()) {
                            var currentTokenSpan = new Formatting.TokenSpan(trivia.kind(), position, trivia.fullWidth());
                            if (this.textSpan().containsTextSpan(currentTokenSpan)) {
                                if (trivia.isComment() && this.previousTokenSpan) {
                                    this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                                } else {
                                    var startLine = this.getLineNumber(this.previousTokenSpan || this.textSpan());
                                    this.trimWhitespaceInLineRange(startLine, this.getLineNumber(currentTokenSpan));
                                }
                                this.previousTokenSpan = currentTokenSpan;
                                if (this.previousTokenParent) {
                                    this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                                }
                                this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                            }
                        }

                        position += trivia.fullWidth();
                    }
                };

                Formatter.prototype.findCommonParents = function (parent1, parent2) {
                    var shallowParent;
                    var shallowParentDepth;
                    var deepParent;
                    var deepParentDepth;

                    if (parent1.depth() < parent2.depth()) {
                        shallowParent = parent1;
                        shallowParentDepth = parent1.depth();
                        deepParent = parent2;
                        deepParentDepth = parent2.depth();
                    } else {
                        shallowParent = parent2;
                        shallowParentDepth = parent2.depth();
                        deepParent = parent1;
                        deepParentDepth = parent1.depth();
                    }

                    TypeScript.Debug.assert(shallowParentDepth >= 0, "Expected shallowParentDepth >= 0");
                    TypeScript.Debug.assert(deepParentDepth >= 0, "Expected deepParentDepth >= 0");
                    TypeScript.Debug.assert(deepParentDepth >= shallowParentDepth, "Expected deepParentDepth >= shallowParentDepth");

                    while (deepParentDepth > shallowParentDepth) {
                        deepParent = deepParent.parent();
                        deepParentDepth--;
                    }

                    TypeScript.Debug.assert(deepParentDepth === shallowParentDepth, "Expected deepParentDepth === shallowParentDepth");

                    while (deepParent.node() && shallowParent.node()) {
                        if (deepParent.node() === shallowParent.node()) {
                            return deepParent;
                        }
                        deepParent = deepParent.parent();
                        shallowParent = shallowParent.parent();
                    }

                    throw TypeScript.Errors.invalidOperation();
                };

                Formatter.prototype.formatPair = function (t1, t1Parent, t2, t2Parent) {
                    var token1Line = this.getLineNumber(t1);
                    var token2Line = this.getLineNumber(t2);

                    var commonParent = this.findCommonParents(t1Parent, t2Parent);

                    this.formattingContext.updateContext(t1, t1Parent, t2, t2Parent, commonParent);

                    var rule = this.rulesProvider.getRulesMap().GetRule(this.formattingContext);

                    if (rule != null) {
                        this.RecordRuleEdits(rule, t1, t2);

                        if ((rule.Operation.Action == 1 /* Space */ || rule.Operation.Action == 3 /* Delete */) && token1Line != token2Line) {
                            this.forceSkipIndentingNextToken(t2.start());
                        }

                        if (rule.Operation.Action == 2 /* NewLine */ && token1Line == token2Line) {
                            this.forceIndentNextToken(t2.start());
                        }
                    }

                    if (token1Line != token2Line && (!rule || (rule.Operation.Action != 3 /* Delete */ && rule.Flag != 1 /* CanDeleteNewLines */))) {
                        this.trimWhitespaceInLineRange(token1Line, token2Line, t1);
                    }
                };

                Formatter.prototype.getLineNumber = function (span) {
                    return this.snapshot().getLineNumberFromPosition(span.start());
                };

                Formatter.prototype.trimWhitespaceInLineRange = function (startLine, endLine, token) {
                    for (var lineNumber = startLine; lineNumber < endLine; ++lineNumber) {
                        var line = this.snapshot().getLineFromLineNumber(lineNumber);

                        this.trimWhitespace(line, token);
                    }
                };

                Formatter.prototype.trimWhitespace = function (line, token) {
                    if (token && (token.kind == 6 /* MultiLineCommentTrivia */ || token.kind == 7 /* SingleLineCommentTrivia */) && token.start() <= line.endPosition() && token.end() >= line.endPosition())
                        return;

                    var text = line.getText();
                    var index = 0;

                    for (index = text.length - 1; index >= 0; --index) {
                        if (!TypeScript.CharacterInfo.isWhitespace(text.charCodeAt(index))) {
                            break;
                        }
                    }

                    ++index;

                    if (index < text.length) {
                        this.recordEdit(line.startPosition() + index, line.length() - index, "");
                    }
                };

                Formatter.prototype.RecordRuleEdits = function (rule, t1, t2) {
                    if (rule.Operation.Action == 0 /* Ignore */) {
                        return;
                    }

                    var betweenSpan;

                    switch (rule.Operation.Action) {
                        case 3 /* Delete */:
                             {
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());

                                if (betweenSpan.length() > 0) {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), "");
                                    return;
                                }
                            }
                            break;

                        case 2 /* NewLine */:
                             {
                                if (!(rule.Flag == 1 /* CanDeleteNewLines */ || this.getLineNumber(t1) == this.getLineNumber(t2))) {
                                    return;
                                }

                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());

                                var doEdit = false;
                                var betweenText = this.snapshot().getText(betweenSpan);

                                var lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter);
                                if (lineFeedLoc < 0) {
                                    doEdit = true;
                                } else {
                                    lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter, lineFeedLoc + 1);
                                    if (lineFeedLoc >= 0) {
                                        doEdit = true;
                                    }
                                }

                                if (doEdit) {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), this.options.newLineCharacter);
                                    return;
                                }
                            }
                            break;

                        case 1 /* Space */:
                             {
                                if (!(rule.Flag == 1 /* CanDeleteNewLines */ || this.getLineNumber(t1) == this.getLineNumber(t2))) {
                                    return;
                                }

                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());

                                if (betweenSpan.length() > 1 || this.snapshot().getText(betweenSpan) != " ") {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), " ");
                                    return;
                                }
                            }
                            break;
                    }
                };
                return Formatter;
            })(Formatting.MultipleTokenIndenter);
            Formatting.Formatter = Formatter;
        })(Services.Formatting || (Services.Formatting = {}));
        var Formatting = Services.Formatting;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var debugObjectHost = this;

var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var CoreServices = (function () {
            function CoreServices(host) {
                this.host = host;
            }
            CoreServices.prototype.getPreProcessedFileInfo = function (fileName, sourceText) {
                return TypeScript.preProcessFile(fileName, sourceText);
            };

            CoreServices.prototype.getDefaultCompilationSettings = function () {
                var settings = new TypeScript.CompilationSettings();
                settings.codeGenTarget = 1 /* EcmaScript5 */;
                return settings;
            };

            CoreServices.prototype.dumpMemory = function () {
                if (!debugObjectHost || !debugObjectHost.Debug || !debugObjectHost.Debug.dumpHeap) {
                    throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.This_version_of_the_Javascript_runtime_does_not_support_the_0_function, ['Debug.dumpHeap()']));
                }

                var objects = debugObjectHost.Debug.dumpHeap(2);
                var totalSize = 0;
                for (var i = 0; i < objects.length; i++) {
                    totalSize += objects[i].size;
                }

                return "There are " + objects.length + " object(s) accessible from 'global', for a total of " + totalSize + " byte(s).";
            };

            CoreServices.prototype.getMemoryInfo = function () {
                if (!debugObjectHost || !debugObjectHost.Debug || !debugObjectHost.Debug.getMemoryInfo) {
                    throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.This_version_of_the_Javascript_runtime_does_not_support_the_0_function, ['Debug.getMemoryInfo()']));
                }

                return debugObjectHost.Debug.getMemoryInfo();
            };

            CoreServices.prototype.collectGarbage = function () {
                if (!debugObjectHost || !debugObjectHost.CollectGarbage) {
                    throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.This_version_of_the_Javascript_runtime_does_not_support_the_0_function, ['collectGarbage()']));
                }

                debugObjectHost.CollectGarbage();
            };
            return CoreServices;
        })();
        Services.CoreServices = CoreServices;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var HostFileInformation = (function () {
            function HostFileInformation(fileName, host, version, isOpen, byteOrderMark) {
                this.fileName = fileName;
                this.host = host;
                this.version = version;
                this.isOpen = isOpen;
                this.byteOrderMark = byteOrderMark;
                this._sourceText = null;
            }
            HostFileInformation.prototype.getScriptSnapshot = function () {
                if (this._sourceText === null) {
                    this._sourceText = this.host.getScriptSnapshot(this.fileName);
                }

                return this._sourceText;
            };
            return HostFileInformation;
        })();

        var HostCache = (function () {
            function HostCache(host) {
                this._fileNameToEntry = new TypeScript.StringHashTable();

                var fileNames = host.getScriptFileNames();
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];
                    this._fileNameToEntry.add(TypeScript.switchToForwardSlashes(fileName), new HostFileInformation(fileName, host, host.getScriptVersion(fileName), host.getScriptIsOpen(fileName), host.getScriptByteOrderMark(fileName)));
                }

                var settings = host.getCompilationSettings();
                if (!settings) {
                    settings = new TypeScript.CompilationSettings();
                    settings.codeGenTarget = 1 /* EcmaScript5 */;
                }

                this._compilationSettings = TypeScript.ImmutableCompilationSettings.fromCompilationSettings(settings);
            }
            HostCache.prototype.compilationSettings = function () {
                return this._compilationSettings;
            };

            HostCache.prototype.contains = function (fileName) {
                return this._fileNameToEntry.lookup(TypeScript.switchToForwardSlashes(fileName)) !== null;
            };

            HostCache.prototype.getHostFileName = function (fileName) {
                var hostCacheEntry = this._fileNameToEntry.lookup(TypeScript.switchToForwardSlashes(fileName));
                if (hostCacheEntry) {
                    return hostCacheEntry.fileName;
                }
                return fileName;
            };

            HostCache.prototype.getFileNames = function () {
                return this._fileNameToEntry.getAllKeys();
            };

            HostCache.prototype.getVersion = function (fileName) {
                return this._fileNameToEntry.lookup(TypeScript.switchToForwardSlashes(fileName)).version;
            };

            HostCache.prototype.isOpen = function (fileName) {
                return this._fileNameToEntry.lookup(TypeScript.switchToForwardSlashes(fileName)).isOpen;
            };

            HostCache.prototype.getByteOrderMark = function (fileName) {
                return this._fileNameToEntry.lookup(TypeScript.switchToForwardSlashes(fileName)).byteOrderMark;
            };

            HostCache.prototype.getScriptSnapshot = function (fileName) {
                return this._fileNameToEntry.lookup(TypeScript.switchToForwardSlashes(fileName)).getScriptSnapshot();
            };

            HostCache.prototype.getScriptTextChangeRangeSinceVersion = function (fileName, lastKnownVersion) {
                var currentVersion = this.getVersion(fileName);
                if (lastKnownVersion === currentVersion) {
                    return TypeScript.TextChangeRange.unchanged;
                }

                var scriptSnapshot = this.getScriptSnapshot(fileName);
                return scriptSnapshot.getTextChangeRangeSinceVersion(lastKnownVersion);
            };
            return HostCache;
        })();

        var SyntaxTreeCache = (function () {
            function SyntaxTreeCache(_host) {
                this._host = _host;
                this._currentFileName = "";
                this._currentFileVersion = -1;
                this._currentFileSyntaxTree = null;
                this._currentFileScriptSnapshot = null;
                this._hostCache = new HostCache(_host);
            }
            SyntaxTreeCache.prototype.getCurrentFileSyntaxTree = function (fileName) {
                this._hostCache = new HostCache(this._host);

                var version = this._hostCache.getVersion(fileName);
                var syntaxTree = null;

                if (this._currentFileSyntaxTree === null || this._currentFileName !== fileName) {
                    var scriptSnapshot = this._hostCache.getScriptSnapshot(fileName);
                    syntaxTree = this.createSyntaxTree(fileName, scriptSnapshot);
                } else if (this._currentFileVersion !== version) {
                    var scriptSnapshot = this._hostCache.getScriptSnapshot(fileName);
                    syntaxTree = this.updateSyntaxTree(fileName, scriptSnapshot, this._currentFileSyntaxTree, this._currentFileVersion);
                }

                if (syntaxTree !== null) {
                    this._currentFileScriptSnapshot = scriptSnapshot;
                    this._currentFileVersion = version;
                    this._currentFileName = fileName;
                    this._currentFileSyntaxTree = syntaxTree;
                }

                return this._currentFileSyntaxTree;
            };

            SyntaxTreeCache.prototype.createSyntaxTree = function (fileName, scriptSnapshot) {
                var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);

                var syntaxTree = TypeScript.Parser.parse(fileName, text, TypeScript.ImmutableCompilationSettings.defaultSettings().codeGenTarget(), TypeScript.isDTSFile(fileName));

                return syntaxTree;
            };

            SyntaxTreeCache.prototype.updateSyntaxTree = function (fileName, scriptSnapshot, previousSyntaxTree, previousFileVersion) {
                var editRange = this._hostCache.getScriptTextChangeRangeSinceVersion(fileName, previousFileVersion);

                if (editRange === null) {
                    return this.createSyntaxTree(fileName, scriptSnapshot);
                }

                var nextSyntaxTree = TypeScript.IncrementalParser.parse(previousSyntaxTree, editRange, TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot));

                this.ensureInvariants(fileName, editRange, nextSyntaxTree, this._currentFileScriptSnapshot, scriptSnapshot);

                return nextSyntaxTree;
            };

            SyntaxTreeCache.prototype.ensureInvariants = function (fileName, editRange, incrementalTree, oldScriptSnapshot, newScriptSnapshot) {
                var expectedNewLength = oldScriptSnapshot.getLength() - editRange.span().length() + editRange.newLength();
                var actualNewLength = newScriptSnapshot.getLength();

                function provideMoreDebugInfo() {
                    var debugInformation = ["expected length:", expectedNewLength, "and actual length:", actualNewLength, "are not equal\r\n"];

                    var oldSpan = editRange.span();

                    function prettyPrintString(s) {
                        return '"' + s.replace(/\r/g, '\\r').replace(/\n/g, '\\n') + '"';
                    }

                    debugInformation.push('Edit range (old text) (start: ' + oldSpan.start() + ', end: ' + oldSpan.end() + ') \r\n');
                    debugInformation.push('Old text edit range contents: ' + prettyPrintString(oldScriptSnapshot.getText(oldSpan.start(), oldSpan.end())));

                    var newSpan = editRange.newSpan();

                    debugInformation.push('Edit range (new text) (start: ' + newSpan.start() + ', end: ' + newSpan.end() + ') \r\n');
                    debugInformation.push('New text edit range contents: ' + prettyPrintString(newScriptSnapshot.getText(newSpan.start(), newSpan.end())));

                    return debugInformation.join(' ');
                }

                TypeScript.Debug.assert(expectedNewLength === actualNewLength, "Expected length is different from actual!", provideMoreDebugInfo);

                if (TypeScript.Debug.shouldAssert(3 /* VeryAggressive */)) {
                    var oldPrefixText = oldScriptSnapshot.getText(0, editRange.span().start());
                    var newPrefixText = newScriptSnapshot.getText(0, editRange.span().start());
                    TypeScript.Debug.assert(oldPrefixText === newPrefixText, 'Expected equal prefix texts!');

                    var oldSuffixText = oldScriptSnapshot.getText(editRange.span().end(), oldScriptSnapshot.getLength());
                    var newSuffixText = newScriptSnapshot.getText(editRange.newSpan().end(), newScriptSnapshot.getLength());
                    TypeScript.Debug.assert(oldSuffixText === newSuffixText, 'Expected equal suffix texts!');

                    var incrementalTreeText = TypeScript.fullText(incrementalTree.sourceUnit());
                    var actualSnapshotText = newScriptSnapshot.getText(0, newScriptSnapshot.getLength());
                    TypeScript.Debug.assert(incrementalTreeText === actualSnapshotText, 'Expected full texts to be equal');
                }
            };
            return SyntaxTreeCache;
        })();
        Services.SyntaxTreeCache = SyntaxTreeCache;

        var LanguageServiceCompiler = (function () {
            function LanguageServiceCompiler(host, documentRegistry, cancellationToken) {
                this.host = host;
                this.documentRegistry = documentRegistry;
                this.cancellationToken = cancellationToken;
                this.compiler = null;
                this.hostCache = null;
                this.logger = this.host;
            }
            LanguageServiceCompiler.prototype.synchronizeHostData = function () {
                var _this = this;
                TypeScript.timeFunction(this.logger, "synchronizeHostData()", function () {
                    _this.synchronizeHostDataWorker();
                });
            };

            LanguageServiceCompiler.prototype.synchronizeHostDataWorker = function () {
                this.hostCache = new HostCache(this.host);

                var compilationSettings = this.hostCache.compilationSettings();

                if (this.compiler === null) {
                    this.compiler = new TypeScript.TypeScriptCompiler(this.logger, compilationSettings);
                }

                var oldSettings = this.compiler.compilationSettings();

                var changesInCompilationSettingsAffectSyntax = oldSettings && compilationSettings && !TypeScript.compareDataObjects(oldSettings, compilationSettings) && TypeScript.settingsChangeAffectsSyntax(oldSettings, compilationSettings);

                this.compiler.setCompilationSettings(compilationSettings);

                var compilerFileNames = this.compiler.fileNames();

                for (var i = 0, n = compilerFileNames.length; i < n; i++) {
                    this.cancellationToken.throwIfCancellationRequested();

                    var fileName = compilerFileNames[i];

                    if (!this.hostCache.contains(fileName) || changesInCompilationSettingsAffectSyntax) {
                        this.compiler.removeFile(fileName);
                        this.documentRegistry.releaseDocument(fileName, oldSettings);
                    }
                }

                var hostFileNames = this.hostCache.getFileNames();

                for (var i = 0, n = hostFileNames.length; i < n; i++) {
                    var fileName = hostFileNames[i];

                    var version = this.hostCache.getVersion(fileName);
                    var isOpen = this.hostCache.isOpen(fileName);
                    var scriptSnapshot = this.hostCache.getScriptSnapshot(fileName);

                    var document = this.compiler.getDocument(fileName);
                    if (document) {
                        if (document.version === version && document.isOpen === isOpen) {
                            continue;
                        }

                        var textChangeRange = null;
                        if (document.isOpen && isOpen) {
                            textChangeRange = this.hostCache.getScriptTextChangeRangeSinceVersion(fileName, document.version);
                        }

                        document = this.documentRegistry.updateDocument(document, fileName, compilationSettings, scriptSnapshot, version, isOpen, textChangeRange);
                    } else {
                        document = this.documentRegistry.acquireDocument(fileName, compilationSettings, scriptSnapshot, this.hostCache.getByteOrderMark(fileName), version, isOpen, []);
                    }

                    this.compiler.addOrUpdateFile(document);
                }
            };

            LanguageServiceCompiler.prototype.getScriptSnapshot = function (fileName) {
                this.synchronizeHostData();
                return this.hostCache.getScriptSnapshot(fileName);
            };

            LanguageServiceCompiler.prototype.getCachedHostFileName = function (fileName) {
                if (!this.hostCache) {
                    this.synchronizeHostData();
                }

                return this.hostCache.getHostFileName(fileName);
            };

            LanguageServiceCompiler.prototype.getCachedTopLevelDeclaration = function (fileName) {
                if (!this.hostCache) {
                    this.synchronizeHostData();
                }

                return this.compiler.topLevelDeclaration(fileName);
            };

            LanguageServiceCompiler.prototype.compilationSettings = function () {
                this.synchronizeHostData();
                return this.compiler.compilationSettings();
            };

            LanguageServiceCompiler.prototype.fileNames = function () {
                this.synchronizeHostData();
                return this.compiler.fileNames();
            };

            LanguageServiceCompiler.prototype.cleanupSemanticCache = function () {
                this.compiler.cleanupSemanticCache();
            };

            LanguageServiceCompiler.prototype.getDocument = function (fileName) {
                this.synchronizeHostData();
                return this.compiler.getDocument(fileName);
            };

            LanguageServiceCompiler.prototype.getSemanticInfoChain = function () {
                this.synchronizeHostData();
                return this.compiler.getSemanticInfoChain();
            };

            LanguageServiceCompiler.prototype.getSyntacticDiagnostics = function (fileName) {
                this.synchronizeHostData();
                return this.compiler.getSyntacticDiagnostics(fileName);
            };

            LanguageServiceCompiler.prototype.getSemanticDiagnostics = function (fileName) {
                this.synchronizeHostData();
                return this.compiler.getSemanticDiagnostics(fileName);
            };

            LanguageServiceCompiler.prototype.getCompilerOptionsDiagnostics = function (resolvePath) {
                this.synchronizeHostData();
                return this.compiler.getCompilerOptionsDiagnostics(resolvePath);
            };

            LanguageServiceCompiler.prototype.getSymbolInformationFromAST = function (ast, document) {
                this.synchronizeHostData();
                return this.compiler.pullGetSymbolInformationFromAST(ast, document);
            };

            LanguageServiceCompiler.prototype.getCallInformationFromAST = function (ast, document) {
                this.synchronizeHostData();
                return this.compiler.pullGetCallInformationFromAST(ast, document);
            };

            LanguageServiceCompiler.prototype.getVisibleMemberSymbolsFromAST = function (ast, document) {
                this.synchronizeHostData();
                return this.compiler.pullGetVisibleMemberSymbolsFromAST(ast, document);
            };

            LanguageServiceCompiler.prototype.getVisibleDeclsFromAST = function (ast, document) {
                this.synchronizeHostData();
                return this.compiler.pullGetVisibleDeclsFromAST(ast, document);
            };

            LanguageServiceCompiler.prototype.getContextualMembersFromAST = function (ast, document) {
                this.synchronizeHostData();
                return this.compiler.pullGetContextualMembersFromAST(ast, document);
            };

            LanguageServiceCompiler.prototype.pullGetDeclInformation = function (decl, ast, document) {
                this.synchronizeHostData();
                return this.compiler.pullGetDeclInformation(decl, ast, document);
            };

            LanguageServiceCompiler.prototype.topLevelDeclaration = function (fileName) {
                this.synchronizeHostData();
                return this.compiler.topLevelDeclaration(fileName);
            };

            LanguageServiceCompiler.prototype.getDeclForAST = function (ast) {
                this.synchronizeHostData();
                return this.compiler.getDeclForAST(ast);
            };

            LanguageServiceCompiler.prototype.emit = function (fileName, resolvePath) {
                this.synchronizeHostData();
                return this.compiler.emit(fileName, resolvePath);
            };

            LanguageServiceCompiler.prototype.emitDeclarations = function (fileName, resolvePath) {
                this.synchronizeHostData();
                return this.compiler.emitDeclarations(fileName, resolvePath);
            };

            LanguageServiceCompiler.prototype.canEmitDeclarations = function (fileName) {
                this.synchronizeHostData();
                return this.compiler.canEmitDeclarations(fileName);
            };

            LanguageServiceCompiler.prototype.dispose = function () {
                if (this.compiler) {
                    var fileNames = this.compiler.fileNames();
                    for (var i = 0; i < fileNames.length; ++i) {
                        this.documentRegistry.releaseDocument(fileNames[i], this.compiler.compilationSettings());
                    }
                }
            };
            return LanguageServiceCompiler;
        })();
        Services.LanguageServiceCompiler = LanguageServiceCompiler;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Indentation) {
        function columnForEndOfTokenAtPosition(syntaxTree, position, options) {
            var token = TypeScript.findToken(syntaxTree.sourceUnit(), position);
            return columnForStartOfTokenAtPosition(syntaxTree, position, options) + TypeScript.width(token);
        }
        Indentation.columnForEndOfTokenAtPosition = columnForEndOfTokenAtPosition;

        function columnForStartOfTokenAtPosition(syntaxTree, position, options) {
            var token = TypeScript.findToken(syntaxTree.sourceUnit(), position);

            var firstTokenInLine = TypeScript.Syntax.firstTokenInLineContainingPosition(syntaxTree, token.fullStart());
            var leadingTextInReverse = [];

            var current = token;
            while (current !== firstTokenInLine) {
                current = TypeScript.previousToken(current);

                if (current === firstTokenInLine) {
                    leadingTextInReverse.push(current.trailingTrivia().fullText());
                    leadingTextInReverse.push(current.text());
                } else {
                    leadingTextInReverse.push(current.fullText());
                }
            }

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfTokenAtPosition = columnForStartOfTokenAtPosition;

        function columnForStartOfFirstTokenInLineContainingPosition(syntaxTree, position, options) {
            var firstTokenInLine = TypeScript.Syntax.firstTokenInLineContainingPosition(syntaxTree, position);
            var leadingTextInReverse = [];

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfFirstTokenInLineContainingPosition = columnForStartOfFirstTokenInLineContainingPosition;

        function collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse) {
            var leadingTrivia = firstTokenInLine.leadingTrivia();

            for (var i = leadingTrivia.count() - 1; i >= 0; i--) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    break;
                }

                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    var lineSegments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    leadingTextInReverse.push(TypeScript.ArrayUtilities.last(lineSegments));

                    if (lineSegments.length > 0) {
                        break;
                    }
                }

                leadingTextInReverse.push(trivia.fullText());
            }
        }

        function columnForLeadingTextInReverse(leadingTextInReverse, options) {
            var column = 0;

            for (var i = leadingTextInReverse.length - 1; i >= 0; i--) {
                var text = leadingTextInReverse[i];
                column = columnForPositionInStringWorker(text, text.length, column, options);
            }

            return column;
        }

        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;

        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;

            for (var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);

                if (ch === 9 /* tab */) {
                    column += spacesPerTab - column % spacesPerTab;
                } else {
                    column++;
                }
            }

            return column;
        }

        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = Math.max(0, column);

            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }

            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) + TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;

        function firstNonWhitespacePosition(value) {
            for (var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }

            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(TypeScript.Indentation || (TypeScript.Indentation = {}));
    var Indentation = TypeScript.Indentation;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var CompletionHelpers = (function () {
            function CompletionHelpers() {
            }
            CompletionHelpers.getSpan = function (ast) {
                return new TypeScript.TextSpan(TypeScript.start(ast), TypeScript.width(ast));
            };

            CompletionHelpers.symbolDeclarationIntersectsPosition = function (symbol, fileName, position) {
                var decl = symbol.getDeclarations()[0];
                if (decl.fileName() === fileName && this.getSpan(decl.ast()).intersectsWithPosition(position)) {
                    return true;
                }

                return false;
            };

            CompletionHelpers.filterContextualMembersList = function (contextualMemberSymbols, existingMembers, fileName, position) {
                if (!existingMembers || !existingMembers.symbols || existingMembers.symbols.length === 0) {
                    return contextualMemberSymbols;
                }

                var existingMemberSymbols = existingMembers.symbols;
                var existingMemberNames = TypeScript.createIntrinsicsObject();
                for (var i = 0, n = existingMemberSymbols.length; i < n; i++) {
                    if (this.symbolDeclarationIntersectsPosition(existingMemberSymbols[i], fileName, position)) {
                        continue;
                    }

                    existingMemberNames[TypeScript.stripStartAndEndQuotes(existingMemberSymbols[i].getDisplayName())] = true;
                }

                var filteredMembers = [];
                for (var j = 0, m = contextualMemberSymbols.length; j < m; j++) {
                    var contextualMemberSymbol = contextualMemberSymbols[j];
                    if (!existingMemberNames[TypeScript.stripStartAndEndQuotes(contextualMemberSymbol.getDisplayName())]) {
                        if (this.symbolDeclarationIntersectsPosition(contextualMemberSymbol, fileName, position)) {
                            continue;
                        }
                        filteredMembers.push(contextualMemberSymbol);
                    }
                }

                return filteredMembers;
            };

            CompletionHelpers.isCompletionListBlocker = function (sourceUnit, position) {
                if (position < 0 || position > TypeScript.fullWidth(sourceUnit)) {
                    return true;
                }

                return TypeScript.Syntax.isEntirelyInsideComment(sourceUnit, position) || TypeScript.Syntax.isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) || CompletionHelpers.isIdentifierDefinitionLocation(sourceUnit, position) || CompletionHelpers.isRightOfIllegalDot(sourceUnit, position);
            };

            CompletionHelpers.getContainingObjectLiteralApplicableForCompletion = function (sourceUnit, position) {
                var previousToken = CompletionHelpers.getNonIdentifierCompleteTokenOnLeft(sourceUnit, position);

                if (previousToken) {
                    var parent = previousToken.parent;

                    switch (previousToken.kind()) {
                        case 70 /* OpenBraceToken */:
                        case 79 /* CommaToken */:
                            if (parent && parent.kind() === 2 /* SeparatedList */) {
                                parent = parent.parent;
                            }

                            if (parent && parent.kind() === 216 /* ObjectLiteralExpression */) {
                                return parent;
                            }

                            break;
                    }
                }

                return null;
            };

            CompletionHelpers.isIdentifierDefinitionLocation = function (sourceUnit, position) {
                var positionedToken = CompletionHelpers.getNonIdentifierCompleteTokenOnLeft(sourceUnit, position);

                if (positionedToken) {
                    var containingNodeKind = TypeScript.Syntax.containingNode(positionedToken) && TypeScript.Syntax.containingNode(positionedToken).kind();
                    switch (positionedToken.kind()) {
                        case 79 /* CommaToken */:
                            return containingNodeKind === 228 /* ParameterList */ || containingNodeKind === 225 /* VariableDeclaration */ || containingNodeKind === 133 /* EnumDeclaration */;

                        case 72 /* OpenParenToken */:
                            return containingNodeKind === 228 /* ParameterList */ || containingNodeKind === 237 /* CatchClause */;

                        case 70 /* OpenBraceToken */:
                            return containingNodeKind === 133 /* EnumDeclaration */;

                        case 57 /* PublicKeyword */:
                        case 55 /* PrivateKeyword */:
                        case 58 /* StaticKeyword */:
                        case 77 /* DotDotDotToken */:
                            return containingNodeKind === 243 /* Parameter */;

                        case 44 /* ClassKeyword */:
                        case 65 /* ModuleKeyword */:
                        case 46 /* EnumKeyword */:
                        case 52 /* InterfaceKeyword */:
                        case 27 /* FunctionKeyword */:
                        case 40 /* VarKeyword */:
                        case 64 /* GetKeyword */:
                        case 68 /* SetKeyword */:
                            return true;
                    }

                    switch (positionedToken.text()) {
                        case "class":
                        case "interface":
                        case "enum":
                        case "module":
                            return true;
                    }
                }

                return false;
            };

            CompletionHelpers.getNonIdentifierCompleteTokenOnLeft = function (sourceUnit, position) {
                var positionedToken = TypeScript.Syntax.findCompleteTokenOnLeft(sourceUnit, position, true);

                if (positionedToken && position === TypeScript.end(positionedToken) && positionedToken.kind() == 10 /* EndOfFileToken */) {
                    positionedToken = TypeScript.previousToken(positionedToken, true);
                }

                if (positionedToken && position === TypeScript.end(positionedToken) && positionedToken.kind() === 11 /* IdentifierName */) {
                    positionedToken = TypeScript.previousToken(positionedToken, true);
                }

                return positionedToken;
            };

            CompletionHelpers.isRightOfIllegalDot = function (sourceUnit, position) {
                var positionedToken = CompletionHelpers.getNonIdentifierCompleteTokenOnLeft(sourceUnit, position);

                if (positionedToken) {
                    switch (positionedToken.kind()) {
                        case 76 /* DotToken */:
                            var leftOfDotPositionedToken = TypeScript.previousToken(positionedToken, true);
                            return leftOfDotPositionedToken && leftOfDotPositionedToken.kind() === 13 /* NumericLiteral */;

                        case 13 /* NumericLiteral */:
                            var text = positionedToken.text();
                            return text.charAt(text.length - 1) === ".";
                    }
                }

                return false;
            };

            CompletionHelpers.getValidCompletionEntryDisplayName = function (displayName) {
                if (displayName && displayName.length > 0) {
                    var firstChar = displayName.charCodeAt(0);
                    if (firstChar === 39 /* singleQuote */ || firstChar === 34 /* doubleQuote */) {
                        displayName = TypeScript.stripStartAndEndQuotes(displayName);
                    }

                    if (TypeScript.Scanner.isValidIdentifier(TypeScript.SimpleText.fromString(displayName), 1 /* EcmaScript5 */)) {
                        return displayName;
                    }
                }

                return null;
            };
            return CompletionHelpers;
        })();
        Services.CompletionHelpers = CompletionHelpers;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var KeywordCompletions = (function () {
            function KeywordCompletions() {
            }
            KeywordCompletions.getKeywordCompltions = function () {
                if (KeywordCompletions.keywordCompletions === null) {
                    var completions = [];
                    for (var i = 0, n = KeywordCompletions.keywords.length; i < n; i++) {
                        var keyword = KeywordCompletions.keywords[i];
                        var entry = new Services.ResolvedCompletionEntry(keyword, Services.ScriptElementKind.keyword, Services.ScriptElementKindModifier.none, null, keyword, null);
                        completions.push(entry);
                    }

                    KeywordCompletions.keywordCompletions = completions;
                }

                return KeywordCompletions.keywordCompletions;
            };
            KeywordCompletions.keywords = [
                "break",
                "case",
                "catch",
                "class",
                "constructor",
                "continue",
                "debugger",
                "declare",
                "default",
                "delete",
                "do",
                "else",
                "enum",
                "export",
                "extends",
                "false",
                "finally",
                "for",
                "function",
                "get",
                "if",
                "implements",
                "import",
                "in",
                "instanceof",
                "interface",
                "module",
                "new",
                "null",
                "private",
                "public",
                "require",
                "return",
                "set",
                "static",
                "super",
                "switch",
                "this",
                "throw",
                "true",
                "try",
                "typeof",
                "var",
                "while",
                "with"
            ];

            KeywordCompletions.keywordCompletions = null;
            return KeywordCompletions;
        })();
        Services.KeywordCompletions = KeywordCompletions;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var SignatureInfoHelpers = (function () {
            function SignatureInfoHelpers() {
            }
            SignatureInfoHelpers.isInPartiallyWrittenTypeArgumentList = function (syntaxTree, position) {
                var token = TypeScript.Syntax.findTokenOnLeft(syntaxTree.sourceUnit(), position, true);

                if (token && TypeScript.Syntax.hasAncestorOfKind(token, 230 /* TypeParameterList */)) {
                    return null;
                }

                var stack = 0;
                var argumentIndex = 0;

                whileLoop:
                while (token) {
                    switch (token.kind()) {
                        case 80 /* LessThanToken */:
                            if (stack === 0) {
                                var lessThanToken = token;
                                token = TypeScript.previousToken(token, true);
                                if (!token || token.kind() !== 11 /* IdentifierName */) {
                                    break whileLoop;
                                }

                                return {
                                    genericIdentifer: token,
                                    lessThanToken: lessThanToken,
                                    argumentIndex: argumentIndex
                                };
                            } else if (stack < 0) {
                                break whileLoop;
                            } else {
                                stack--;
                            }

                            break;

                        case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                            stack++;

                        case 81 /* GreaterThanToken */:
                            stack++;
                            break;

                        case 79 /* CommaToken */:
                            if (stack == 0) {
                                argumentIndex++;
                            }

                            break;

                        case 71 /* CloseBraceToken */:
                            var unmatchedOpenBraceTokens = 0;

                            token = SignatureInfoHelpers.moveBackUpTillMatchingTokenKind(token, 71 /* CloseBraceToken */, 70 /* OpenBraceToken */);
                            if (!token) {
                                break whileLoop;
                            }

                            break;

                        case 85 /* EqualsGreaterThanToken */:
                            token = TypeScript.previousToken(token, true);

                            if (token && token.kind() === 73 /* CloseParenToken */) {
                                token = SignatureInfoHelpers.moveBackUpTillMatchingTokenKind(token, 73 /* CloseParenToken */, 72 /* OpenParenToken */);

                                if (token && token.kind() === 81 /* GreaterThanToken */) {
                                    token = SignatureInfoHelpers.moveBackUpTillMatchingTokenKind(token, 81 /* GreaterThanToken */, 80 /* LessThanToken */);
                                }

                                if (token && token.kind() === 31 /* NewKeyword */) {
                                    token = TypeScript.previousToken(token, true);
                                }

                                if (!token) {
                                    break whileLoop;
                                }
                            } else {
                                break whileLoop;
                            }

                            break;

                        case 11 /* IdentifierName */:
                        case 60 /* AnyKeyword */:
                        case 67 /* NumberKeyword */:
                        case 69 /* StringKeyword */:
                        case 41 /* VoidKeyword */:
                        case 61 /* BooleanKeyword */:
                        case 76 /* DotToken */:
                        case 74 /* OpenBracketToken */:
                        case 75 /* CloseBracketToken */:
                            break;

                        default:
                            break whileLoop;
                    }

                    token = TypeScript.previousToken(token, true);
                }

                return null;
            };

            SignatureInfoHelpers.getSignatureInfoFromSignatureSymbol = function (symbol, signatures, enclosingScopeSymbol, compilerState) {
                var signatureGroup = [];

                var hasOverloads = signatures.length > 1;

                for (var i = 0, n = signatures.length; i < n; i++) {
                    var signature = signatures[i];

                    if (hasOverloads && signature.isDefinition()) {
                        continue;
                    }

                    var signatureGroupInfo = new Services.FormalSignatureItemInfo();
                    var paramIndexInfo = [];
                    var functionName = signature.getScopedNameEx(enclosingScopeSymbol).toString();
                    if (!functionName && (!symbol.isType() || symbol.isNamedTypeSymbol())) {
                        functionName = symbol.getScopedNameEx(enclosingScopeSymbol).toString();
                    }

                    var signatureMemberName = signature.getSignatureTypeNameEx(functionName, false, false, enclosingScopeSymbol, true, true);
                    signatureGroupInfo.signatureInfo = TypeScript.MemberName.memberNameToString(signatureMemberName, paramIndexInfo);
                    signatureGroupInfo.docComment = signature.docComments();

                    var parameterMarkerIndex = 0;

                    if (signature.isGeneric()) {
                        var typeParameters = signature.getTypeParameters();
                        for (var j = 0, m = typeParameters.length; j < m; j++) {
                            var typeParameter = typeParameters[j];
                            var signatureTypeParameterInfo = new Services.FormalTypeParameterInfo();
                            signatureTypeParameterInfo.name = typeParameter.getDisplayName();
                            signatureTypeParameterInfo.docComment = typeParameter.docComments();
                            signatureTypeParameterInfo.minChar = paramIndexInfo[2 * parameterMarkerIndex];
                            signatureTypeParameterInfo.limChar = paramIndexInfo[2 * parameterMarkerIndex + 1];
                            parameterMarkerIndex++;
                            signatureGroupInfo.typeParameters.push(signatureTypeParameterInfo);
                        }
                    }

                    var parameters = signature.parameters;
                    for (var j = 0, m = parameters.length; j < m; j++) {
                        var parameter = parameters[j];
                        var signatureParameterInfo = new Services.FormalParameterInfo();
                        signatureParameterInfo.isVariable = signature.hasVarArgs && (j === parameters.length - 1);
                        signatureParameterInfo.name = parameter.getDisplayName();
                        signatureParameterInfo.docComment = parameter.docComments();
                        signatureParameterInfo.minChar = paramIndexInfo[2 * parameterMarkerIndex];
                        signatureParameterInfo.limChar = paramIndexInfo[2 * parameterMarkerIndex + 1];
                        parameterMarkerIndex++;
                        signatureGroupInfo.parameters.push(signatureParameterInfo);
                    }

                    signatureGroup.push(signatureGroupInfo);
                }

                return signatureGroup;
            };

            SignatureInfoHelpers.getSignatureInfoFromGenericSymbol = function (symbol, enclosingScopeSymbol, compilerState) {
                var signatureGroupInfo = new Services.FormalSignatureItemInfo();

                var paramIndexInfo = [];
                var symbolName = symbol.getScopedNameEx(enclosingScopeSymbol, false, true, false, true);

                signatureGroupInfo.signatureInfo = TypeScript.MemberName.memberNameToString(symbolName, paramIndexInfo);
                signatureGroupInfo.docComment = symbol.docComments();

                var parameterMarkerIndex = 0;

                var typeSymbol = symbol.type;

                var typeParameters = typeSymbol.getTypeParameters();
                for (var i = 0, n = typeParameters.length; i < n; i++) {
                    var typeParameter = typeParameters[i];
                    var signatureTypeParameterInfo = new Services.FormalTypeParameterInfo();
                    signatureTypeParameterInfo.name = typeParameter.getDisplayName();
                    signatureTypeParameterInfo.docComment = typeParameter.docComments();
                    signatureTypeParameterInfo.minChar = paramIndexInfo[2 * i];
                    signatureTypeParameterInfo.limChar = paramIndexInfo[2 * i + 1];
                    signatureGroupInfo.typeParameters.push(signatureTypeParameterInfo);
                }

                return [signatureGroupInfo];
            };

            SignatureInfoHelpers.getActualSignatureInfoFromCallExpression = function (ast, caretPosition, typeParameterInformation) {
                if (!ast) {
                    return null;
                }

                var result = new Services.ActualSignatureInfo();

                var parameterMinChar = caretPosition;
                var parameterLimChar = caretPosition;

                if (ast.argumentList.typeArgumentList) {
                    parameterMinChar = Math.min(TypeScript.start(ast.argumentList.typeArgumentList));
                    parameterLimChar = Math.max(Math.max(TypeScript.start(ast.argumentList.typeArgumentList), TypeScript.end(ast.argumentList.typeArgumentList) + TypeScript.trailingTriviaWidth(ast.argumentList.typeArgumentList)));
                }

                if (ast.argumentList.arguments) {
                    parameterMinChar = Math.min(parameterMinChar, TypeScript.end(ast.argumentList.openParenToken));
                    parameterLimChar = Math.max(parameterLimChar, ast.argumentList.closeParenToken.fullWidth() > 0 ? TypeScript.start(ast.argumentList.closeParenToken) : TypeScript.fullEnd(ast.argumentList));
                }

                result.parameterMinChar = parameterMinChar;
                result.parameterLimChar = parameterLimChar;
                result.currentParameterIsTypeParameter = false;
                result.currentParameter = -1;

                if (typeParameterInformation) {
                    result.currentParameterIsTypeParameter = true;
                    result.currentParameter = typeParameterInformation.argumentIndex;
                } else if (ast.argumentList.arguments && ast.argumentList.arguments.length > 0) {
                    result.currentParameter = 0;
                    for (var index = 0; index < ast.argumentList.arguments.length; index++) {
                        if (caretPosition > TypeScript.end(ast.argumentList.arguments[index]) + TypeScript.lastToken(ast.argumentList.arguments[index]).trailingTriviaWidth()) {
                            result.currentParameter++;
                        }
                    }
                }

                return result;
            };

            SignatureInfoHelpers.getActualSignatureInfoFromPartiallyWritenGenericExpression = function (caretPosition, typeParameterInformation) {
                var result = new Services.ActualSignatureInfo();

                result.parameterMinChar = TypeScript.start(typeParameterInformation.lessThanToken);
                result.parameterLimChar = Math.max(TypeScript.fullEnd(typeParameterInformation.lessThanToken), caretPosition);
                result.currentParameterIsTypeParameter = true;
                result.currentParameter = typeParameterInformation.argumentIndex;

                return result;
            };

            SignatureInfoHelpers.isSignatureHelpBlocker = function (sourceUnit, position) {
                if (position < 0 || position > TypeScript.fullWidth(sourceUnit)) {
                    return true;
                }

                return TypeScript.Syntax.isEntirelyInsideComment(sourceUnit, position);
            };

            SignatureInfoHelpers.isTargetOfObjectCreationExpression = function (positionedToken) {
                var positionedParent = TypeScript.Syntax.getAncestorOfKind(positionedToken, 217 /* ObjectCreationExpression */);
                if (positionedParent) {
                    var objectCreationExpression = positionedParent;
                    var expressionRelativeStart = objectCreationExpression.newKeyword.fullWidth();
                    var tokenRelativeStart = positionedToken.fullStart() - TypeScript.fullStart(positionedParent);
                    return tokenRelativeStart >= expressionRelativeStart && tokenRelativeStart <= (expressionRelativeStart + TypeScript.fullWidth(objectCreationExpression.expression));
                }

                return false;
            };

            SignatureInfoHelpers.moveBackUpTillMatchingTokenKind = function (token, tokenKind, matchingTokenKind) {
                if (!token || token.kind() !== tokenKind) {
                    throw TypeScript.Errors.invalidOperation();
                }

                token = TypeScript.previousToken(token, true);

                var stack = 0;

                while (token) {
                    if (token.kind() === matchingTokenKind) {
                        if (stack === 0) {
                            return token;
                        } else if (stack < 0) {
                            break;
                        } else {
                            stack--;
                        }
                    } else if (token.kind() === tokenKind) {
                        stack++;
                    }

                    token = TypeScript.previousToken(token, true);
                }

                return null;
            };
            return SignatureInfoHelpers;
        })();
        Services.SignatureInfoHelpers = SignatureInfoHelpers;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var ResolvedCompletionEntry = (function () {
            function ResolvedCompletionEntry(name, kind, kindModifiers, type, fullSymbolName, docComment) {
                this.name = name;
                this.kind = kind;
                this.kindModifiers = kindModifiers;
                this.type = type;
                this.fullSymbolName = fullSymbolName;
                this.docComment = docComment;
            }
            ResolvedCompletionEntry.prototype.isResolved = function () {
                return true;
            };
            return ResolvedCompletionEntry;
        })();
        Services.ResolvedCompletionEntry = ResolvedCompletionEntry;

        var DeclReferenceCompletionEntry = (function () {
            function DeclReferenceCompletionEntry(name, kind, kindModifiers, decl) {
                this.name = name;
                this.kind = kind;
                this.kindModifiers = kindModifiers;
                this.decl = decl;
                this.type = null;
                this.fullSymbolName = null;
                this.docComment = null;
                this.hasBeenResolved = false;
            }
            DeclReferenceCompletionEntry.prototype.isResolved = function () {
                return this.hasBeenResolved;
            };

            DeclReferenceCompletionEntry.prototype.resolve = function (type, fullSymbolName, docComments) {
                this.type = type;
                this.fullSymbolName = fullSymbolName;
                this.docComment = docComments;
                this.hasBeenResolved = true;
            };
            return DeclReferenceCompletionEntry;
        })();
        Services.DeclReferenceCompletionEntry = DeclReferenceCompletionEntry;

        var CompletionSession = (function () {
            function CompletionSession(fileName, position, entries) {
                this.fileName = fileName;
                this.position = position;
                this.entries = entries;
            }
            return CompletionSession;
        })();
        Services.CompletionSession = CompletionSession;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var LanguageService = (function () {
            function LanguageService(host, documentRegistry) {
                this.host = host;
                this.activeCompletionSession = null;
                this.logger = this.host;
                this.cancellationToken = new TypeScript.CancellationToken(this.host.getCancellationToken());
                this.compiler = new Services.LanguageServiceCompiler(this.host, documentRegistry, this.cancellationToken);
                this._syntaxTreeCache = new Services.SyntaxTreeCache(this.host);

                if (!TypeScript.LocalizedDiagnosticMessages) {
                    TypeScript.LocalizedDiagnosticMessages = this.host.getLocalizedDiagnosticMessages();
                }
            }
            LanguageService.prototype.dispose = function () {
                this.compiler.dispose();
            };

            LanguageService.prototype.cleanupSemanticCache = function () {
                this.compiler.cleanupSemanticCache();
            };

            LanguageService.prototype.refresh = function () {
            };

            LanguageService.prototype.getSemanticInfoChain = function () {
                return this.compiler.getSemanticInfoChain();
            };

            LanguageService.prototype.getSymbolInfoAtPosition = function (fileName, pos, requireName) {
                var document = this.compiler.getDocument(fileName);
                var sourceUnit = document.sourceUnit();

                var topNode = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, pos);
                return this.getSymbolInfoAtAST(document, topNode, pos, requireName);
            };

            LanguageService.prototype.getSymbolInfoAtAST = function (document, topNode, pos, requireName) {
                if (topNode === null || (requireName && topNode.kind() !== 11 /* IdentifierName */)) {
                    this.logger.log("No name found at the given position");
                    return null;
                }

                var symbolInfoAtPosition = this.compiler.getSymbolInformationFromAST(topNode, document);
                if (symbolInfoAtPosition === null || (symbolInfoAtPosition.symbol === null && symbolInfoAtPosition.aliasSymbol)) {
                    this.logger.log("No symbol found at the given position");

                    return { symbol: null, containingASTOpt: null };
                }

                var symbol = symbolInfoAtPosition.aliasSymbol || symbolInfoAtPosition.symbol;
                var symbolName = symbol.getName();

                if (requireName) {
                    var actualNameAtPosition = TypeScript.tokenValueText(topNode);

                    if ((symbol.isError() || symbol.isAny()) && actualNameAtPosition !== symbolName) {
                        this.logger.log("Unknown symbol found at the given position");

                        return { symbol: null, containingASTOpt: null };
                    }
                }

                var containingASTOpt = this.getSymbolScopeAST(symbol, topNode);

                return { symbol: symbol, containingASTOpt: containingASTOpt };
            };

            LanguageService.prototype.getReferencesAtPosition = function (fileName, pos) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var symbolAndContainingAST = this.getSymbolInfoAtPosition(fileName, pos, true);
                if (symbolAndContainingAST === null) {
                    return [];
                }

                if (symbolAndContainingAST.symbol === null) {
                    return this.getSingleNodeReferenceAtPosition(fileName, pos);
                }

                var result = [];
                var symbol = symbolAndContainingAST.symbol;
                var symbolName = symbol.getName();
                var containingASTOpt = symbolAndContainingAST.containingASTOpt;

                var fileNames = this.compiler.fileNames();
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    this.cancellationToken.throwIfCancellationRequested();

                    var tempFileName = fileNames[i];

                    if (containingASTOpt && fileName != tempFileName) {
                        continue;
                    }

                    var tempDocument = this.compiler.getDocument(tempFileName);
                    var filter = tempDocument.bloomFilter();

                    if (filter.probablyContains(symbolName)) {
                        result = result.concat(this.getReferencesInFile(tempFileName, symbol, containingASTOpt));
                    }
                }

                return result;
            };

            LanguageService.prototype.getSymbolScopeAST = function (symbol, ast) {
                if (symbol.kind === 8192 /* TypeParameter */ && symbol.getDeclarations().length > 0 && symbol.getDeclarations()[0].getParentDecl() && symbol.getDeclarations()[0].getParentDecl().kind === 65536 /* Method */) {
                    while (ast) {
                        if (ast.kind() === 130 /* FunctionDeclaration */ || ast.kind() === 136 /* MemberFunctionDeclaration */) {
                            return ast;
                        }

                        ast = ast.parent;
                    }
                }

                return null;
            };

            LanguageService.prototype.getOccurrencesAtPosition = function (fileName, pos) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var symbolAndContainingAST = this.getSymbolInfoAtPosition(fileName, pos, true);
                if (symbolAndContainingAST === null) {
                    return [];
                }

                if (symbolAndContainingAST.symbol === null) {
                    return this.getSingleNodeReferenceAtPosition(fileName, pos);
                }

                var symbol = symbolAndContainingAST.symbol;
                var containingASTOpt = symbolAndContainingAST.containingASTOpt;

                return this.getReferencesInFile(fileName, symbol, containingASTOpt);
            };

            LanguageService.prototype.getSingleNodeReferenceAtPosition = function (fileName, position) {
                var document = this.compiler.getDocument(fileName);
                var sourceUnit = document.sourceUnit();

                var node = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, position);
                if (node === null || node.kind() !== 11 /* IdentifierName */) {
                    return [];
                }

                var isWriteAccess = this.isWriteAccess(node);
                return [new Services.ReferenceEntry(this._getHostFileName(fileName), TypeScript.start(node), TypeScript.end(node), isWriteAccess)];
            };

            LanguageService.prototype.getImplementorsAtPosition = function (fileName, pos) {
                var _this = this;
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var result = [];

                var document = this.compiler.getDocument(fileName);
                var sourceUnit = document.sourceUnit();

                var ast = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, pos);
                if (ast === null || ast.kind() !== 11 /* IdentifierName */) {
                    this.logger.log("No identifier at the specified location.");
                    return result;
                }

                var actualNameAtPosition = TypeScript.tokenValueText(ast);

                var symbolInfoAtPosition = this.compiler.getSymbolInformationFromAST(ast, document);
                var symbol = symbolInfoAtPosition.symbol;

                if (symbol === null) {
                    this.logger.log("No symbol annotation on the identifier ISyntaxElement.");
                    return result;
                }

                var symbolName = symbol.getName();

                if ((symbol.isError() || symbol.isAny()) && actualNameAtPosition !== symbolName) {
                    this.logger.log("Unknown symbol found at the given position");
                    return result;
                }

                var typeSymbol = symbol.type;
                var typesToSearch;

                if (typeSymbol.isClass() || typeSymbol.isInterface()) {
                    typesToSearch = typeSymbol.getTypesThatExtendThisType();
                } else if (symbol.kind == 4096 /* Property */ || typeSymbol.isMethod() || typeSymbol.isProperty()) {
                    var declaration = symbol.getDeclarations()[0];
                    var classSymbol = declaration.getParentDecl().getSymbol(symbol.semanticInfoChain).type;

                    typesToSearch = [];
                    var extendingTypes = classSymbol.getTypesThatExtendThisType();
                    var extendedTypes = classSymbol.getExtendedTypes();
                    extendingTypes.forEach(function (type) {
                        var overrides = _this.getOverrides(type, symbol);
                        overrides.forEach(function (override) {
                            typesToSearch.push(override);
                        });
                    });
                    extendedTypes.forEach(function (type) {
                        var overrides = _this.getOverrides(type, symbol);
                        overrides.forEach(function (override) {
                            typesToSearch.push(override);
                        });
                    });
                }

                if (typesToSearch) {
                    var fileNames = this.compiler.fileNames();
                    for (var i = 0, n = fileNames.length; i < n; i++) {
                        var tempFileName = fileNames[i];

                        var tempDocument = this.compiler.getDocument(tempFileName);
                        var filter = tempDocument.bloomFilter();

                        typesToSearch.forEach(function (typeToSearch) {
                            var symbolName = typeToSearch.getName();
                            if (filter.probablyContains(symbolName)) {
                                result = result.concat(_this.getImplementorsInFile(tempFileName, typeToSearch));
                            }
                        });
                    }
                }
                return result;
            };

            LanguageService.prototype.getOverrides = function (container, memberSym) {
                var result = [];
                var members;
                if (container.isClass()) {
                    members = container.getMembers();
                } else if (container.isInterface()) {
                    members = container.getMembers();
                }

                if (members == null)
                    return null;

                members.forEach(function (member) {
                    var typeMember = member;
                    if (typeMember.getName() === memberSym.getName()) {
                        result.push(typeMember);
                    }
                });

                return result;
            };

            LanguageService.prototype.getImplementorsInFile = function (fileName, symbol) {
                var _this = this;
                var result = [];
                var symbolName = symbol.getDisplayName();

                var possiblePositions = this.getPossibleSymbolReferencePositions(fileName, symbolName);
                if (possiblePositions && possiblePositions.length > 0) {
                    var document = this.compiler.getDocument(fileName);
                    var sourceUnit = document.sourceUnit();

                    possiblePositions.forEach(function (p) {
                        var nameAST = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, p);
                        if (nameAST === null || nameAST.kind() !== 11 /* IdentifierName */) {
                            return;
                        }
                        var searchSymbolInfoAtPosition = _this.compiler.getSymbolInformationFromAST(nameAST, document);
                        if (searchSymbolInfoAtPosition !== null) {
                            var normalizedSymbol;
                            if (symbol.kind === 8 /* Class */ || symbol.kind === 16 /* Interface */) {
                                normalizedSymbol = searchSymbolInfoAtPosition.symbol.type;
                            } else {
                                var declaration = searchSymbolInfoAtPosition.symbol.getDeclarations()[0];
                                normalizedSymbol = declaration.getSymbol(symbol.semanticInfoChain);
                            }

                            if (normalizedSymbol === symbol) {
                                var isWriteAccess = _this.isWriteAccess(nameAST);

                                result.push(new Services.ReferenceEntry(_this._getHostFileName(fileName), TypeScript.start(nameAST), TypeScript.end(nameAST), isWriteAccess));
                            }
                        }
                    });
                }

                return result;
            };

            LanguageService.prototype.getReferencesInFile = function (fileName, symbol, containingASTOpt) {
                var _this = this;
                var result = [];
                var symbolName = symbol.getDisplayName();

                var possiblePositions = this.getPossibleSymbolReferencePositions(fileName, symbolName);
                if (possiblePositions && possiblePositions.length > 0) {
                    var document = this.compiler.getDocument(fileName);
                    var sourceUnit = document.sourceUnit();

                    possiblePositions.forEach(function (p) {
                        _this.cancellationToken.throwIfCancellationRequested();

                        if (containingASTOpt && (p < TypeScript.start(containingASTOpt) || p > TypeScript.end(containingASTOpt))) {
                            return;
                        }

                        var nameAST = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, p, false);

                        if (nameAST === null || nameAST.kind() !== 11 /* IdentifierName */ || (TypeScript.end(nameAST) - TypeScript.start(nameAST) !== symbolName.length)) {
                            return;
                        }

                        var symbolInfoAtPosition = _this.compiler.getSymbolInformationFromAST(nameAST, document);
                        if (symbolInfoAtPosition !== null) {
                            var searchSymbol = symbolInfoAtPosition.aliasSymbol || symbolInfoAtPosition.symbol;

                            if (Services.FindReferenceHelpers.compareSymbolsForLexicalIdentity(searchSymbol, symbol)) {
                                var isWriteAccess = _this.isWriteAccess(nameAST);
                                result.push(new Services.ReferenceEntry(_this._getHostFileName(fileName), TypeScript.start(nameAST), TypeScript.end(nameAST), isWriteAccess));
                            }
                        }
                    });
                }

                return result;
            };

            LanguageService.prototype.isWriteAccess = function (current) {
                var parent = current.parent;
                if (parent !== null) {
                    var parentNodeType = parent.kind();
                    switch (parentNodeType) {
                        case 132 /* ClassDeclaration */:
                            return parent.identifier === current;

                        case 129 /* InterfaceDeclaration */:
                            return parent.identifier === current;

                        case 131 /* ModuleDeclaration */:
                            return parent.name === current || parent.stringLiteral === current;

                        case 130 /* FunctionDeclaration */:
                            return parent.identifier === current;

                        case 134 /* ImportDeclaration */:
                            return parent.identifier === current;

                        case 226 /* VariableDeclarator */:
                            var varDeclarator = parent;
                            return !!(varDeclarator.equalsValueClause && varDeclarator.propertyName === current);

                        case 243 /* Parameter */:
                            return true;

                        case 175 /* AssignmentExpression */:
                        case 176 /* AddAssignmentExpression */:
                        case 177 /* SubtractAssignmentExpression */:
                        case 178 /* MultiplyAssignmentExpression */:
                        case 179 /* DivideAssignmentExpression */:
                        case 180 /* ModuloAssignmentExpression */:
                        case 183 /* OrAssignmentExpression */:
                        case 181 /* AndAssignmentExpression */:
                        case 182 /* ExclusiveOrAssignmentExpression */:
                        case 184 /* LeftShiftAssignmentExpression */:
                        case 186 /* UnsignedRightShiftAssignmentExpression */:
                        case 185 /* SignedRightShiftAssignmentExpression */:
                            return parent.left === current;

                        case 169 /* PreIncrementExpression */:
                        case 211 /* PostIncrementExpression */:
                            return true;

                        case 170 /* PreDecrementExpression */:
                        case 212 /* PostDecrementExpression */:
                            return true;
                    }
                }

                return false;
            };

            LanguageService.prototype.isLetterOrDigit = function (char) {
                return (char >= 97 /* a */ && char <= 122 /* z */) || (char >= 65 /* A */ && char <= 90 /* Z */) || (char >= 48 /* _0 */ && char <= 57 /* _9 */) || char === 95 /* _ */ || char === 36 /* $ */ || (char > 127 && TypeScript.Unicode.isIdentifierPart(char, 1 /* EcmaScript5 */));
            };

            LanguageService.prototype.getPossibleSymbolReferencePositions = function (fileName, symbolName) {
                var positions = [];

                if (!symbolName || !symbolName.length) {
                    return positions;
                }

                var sourceText = this.compiler.getScriptSnapshot(fileName);

                var sourceLength = sourceText.getLength();
                var text = sourceText.getText(0, sourceLength);
                var symbolNameLength = symbolName.length;

                var position = text.indexOf(symbolName);
                while (position >= 0) {
                    this.cancellationToken.throwIfCancellationRequested();

                    var endPosition = position + symbolNameLength;

                    if ((position <= 0 || !this.isLetterOrDigit(text.charCodeAt(position - 1))) && (endPosition >= sourceLength || !this.isLetterOrDigit(text.charCodeAt(endPosition)))) {
                        positions.push(position);
                    }

                    position = text.indexOf(symbolName, position + symbolNameLength + 1);
                }

                return positions;
            };

            LanguageService.prototype.getSignatureAtPosition = function (fileName, position) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var document = this.compiler.getDocument(fileName);

                if (Services.SignatureInfoHelpers.isSignatureHelpBlocker(document.syntaxTree().sourceUnit(), position)) {
                    this.logger.log("position is not a valid singature help location");
                    return null;
                }

                var genericTypeArgumentListInfo = Services.SignatureInfoHelpers.isInPartiallyWrittenTypeArgumentList(document.syntaxTree(), position);
                if (genericTypeArgumentListInfo) {
                    return this.getTypeParameterSignatureFromPartiallyWrittenExpression(document, position, genericTypeArgumentListInfo);
                }

                var sourceUnit = document.sourceUnit();
                var node = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, position);
                if (!node) {
                    return null;
                }

                while (node) {
                    if (node.kind() === 214 /* InvocationExpression */ || node.kind() === 217 /* ObjectCreationExpression */ || (isSignatureHelpBlocker(node) && position > TypeScript.start(node))) {
                        break;
                    }

                    node = node.parent;
                }

                if (!node) {
                    return null;
                }

                if (node.kind() !== 214 /* InvocationExpression */ && node.kind() !== 217 /* ObjectCreationExpression */) {
                    this.logger.log("No call expression or generic arguments found for the given position");
                    return null;
                }

                var callExpression = node;
                var isNew = (callExpression.kind() === 217 /* ObjectCreationExpression */);

                if (isNew && callExpression.argumentList === null) {
                    this.logger.log("No signature help for a object creation expression without arguments");
                    return null;
                }

                TypeScript.Debug.assert(callExpression.argumentList.arguments !== null, "Expected call expression to have arguments, but it did not");

                var argumentsStart = TypeScript.end(callExpression.argumentList.openParenToken);
                var argumentsEnd = callExpression.argumentList.closeParenToken.fullWidth() > 0 ? TypeScript.start(callExpression.argumentList.closeParenToken) : TypeScript.fullEnd(callExpression.argumentList);

                if (position < argumentsStart || position > argumentsEnd) {
                    this.logger.log("Outside argument list");
                    return null;
                }

                var callSymbolInfo = this.compiler.getCallInformationFromAST(node, document);
                if (!callSymbolInfo || !callSymbolInfo.targetSymbol || !callSymbolInfo.resolvedSignatures) {
                    this.logger.log("Could not find symbol for call expression");
                    return null;
                }

                var result = new Services.SignatureInfo();

                result.formal = Services.SignatureInfoHelpers.getSignatureInfoFromSignatureSymbol(callSymbolInfo.targetSymbol, callSymbolInfo.resolvedSignatures, callSymbolInfo.enclosingScopeSymbol, this.compiler);
                result.actual = Services.SignatureInfoHelpers.getActualSignatureInfoFromCallExpression(callExpression, position, genericTypeArgumentListInfo);
                result.activeFormal = (callSymbolInfo.resolvedSignatures && callSymbolInfo.candidateSignature) ? callSymbolInfo.resolvedSignatures.indexOf(callSymbolInfo.candidateSignature) : -1;

                if (result.actual === null || result.formal === null || result.activeFormal === null) {
                    this.logger.log("Can't compute actual and/or formal signature of the call expression");
                    return null;
                }

                return result;
            };

            LanguageService.prototype.getTypeParameterSignatureFromPartiallyWrittenExpression = function (document, position, genericTypeArgumentListInfo) {
                var sourceUnit = document.sourceUnit();

                var ast = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, TypeScript.start(genericTypeArgumentListInfo.genericIdentifer));
                if (ast === null || ast.kind() !== 11 /* IdentifierName */) {
                    this.logger.log(["getTypeParameterSignatureAtPosition: Unexpected ast found at position:", position, ast === null ? "ast was null" : "ast kind: " + TypeScript.SyntaxKind[ast.kind()]].join(' '));
                    return null;
                }

                var symbolInformation = this.compiler.getSymbolInformationFromAST(ast, document);

                if (!symbolInformation.symbol) {
                    return null;
                }

                var isNew = Services.SignatureInfoHelpers.isTargetOfObjectCreationExpression(genericTypeArgumentListInfo.genericIdentifer);

                var typeSymbol = symbolInformation.symbol.type;

                if (typeSymbol.kind === 16777216 /* FunctionType */ || (isNew && typeSymbol.kind === 33554432 /* ConstructorType */)) {
                    var signatures = isNew ? typeSymbol.getConstructSignatures() : typeSymbol.getCallSignatures();

                    var result = new Services.SignatureInfo();

                    result.formal = Services.SignatureInfoHelpers.getSignatureInfoFromSignatureSymbol(symbolInformation.symbol, signatures, symbolInformation.enclosingScopeSymbol, this.compiler);
                    result.actual = Services.SignatureInfoHelpers.getActualSignatureInfoFromPartiallyWritenGenericExpression(position, genericTypeArgumentListInfo);
                    result.activeFormal = 0;

                    return result;
                } else if (typeSymbol.isGeneric()) {
                    if (typeSymbol.kind === 33554432 /* ConstructorType */) {
                        typeSymbol = typeSymbol.getAssociatedContainerType();
                    }

                    var result = new Services.SignatureInfo();

                    result.formal = Services.SignatureInfoHelpers.getSignatureInfoFromGenericSymbol(typeSymbol, symbolInformation.enclosingScopeSymbol, this.compiler);
                    result.actual = Services.SignatureInfoHelpers.getActualSignatureInfoFromPartiallyWritenGenericExpression(position, genericTypeArgumentListInfo);
                    result.activeFormal = 0;

                    return result;
                }

                return null;
            };

            LanguageService.prototype.getDefinitionAtPosition = function (fileName, position) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var document = this.compiler.getDocument(fileName);
                var sourceUnit = document.sourceUnit();
                var currentNode = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, position);

                var callExpressionTarget = TypeScript.ASTHelpers.getCallExpressionTarget(currentNode);
                var callInformation = callExpressionTarget && callExpressionTarget.parent && this.compiler.getCallInformationFromAST(callExpressionTarget.parent, document);
                var symbol = callInformation && callInformation.candidateSignature;

                if (!symbol) {
                    var symbolInfo = this.getSymbolInfoAtAST(document, currentNode, position, false);
                    if (symbolInfo === null || symbolInfo.symbol === null) {
                        return null;
                    }

                    var symbol = symbolInfo.symbol;

                    TypeScript.Debug.assert(symbol.kind !== 0 /* None */ && symbol.kind !== 0 /* Global */ && symbol.kind !== 1 /* Script */, "getDefinitionAtPosition - Invalid symbol kind");

                    if (symbol.kind === 2 /* Primitive */) {
                        return null;
                    }
                }

                var declarations = symbol.getDeclarations();
                var symbolName = symbol.getDisplayName();
                var symbolKind = this.mapPullElementKind(symbol.kind, symbol);
                var container = symbol.getContainer();
                var containerName = container ? container.fullName() : "";
                var containerKind = container ? this.mapPullElementKind(container.kind, container) : "";

                var result = [];

                if (!this.tryAddDefinition(symbolKind, symbolName, containerKind, containerName, declarations, result) && !this.tryAddSignatures(symbolKind, symbolName, containerKind, containerName, declarations, result) && !this.tryAddConstructor(symbolKind, symbolName, containerKind, containerName, declarations, result)) {
                    this.addDeclarations(symbolKind, symbolName, containerKind, containerName, declarations, result);
                }

                return result;
            };

            LanguageService.prototype.addDeclarations = function (symbolKind, symbolName, containerKind, containerName, declarations, result) {
                for (var i = 0, n = declarations.length; i < n; i++) {
                    this.addDeclaration(symbolKind, symbolName, containerKind, containerName, declarations[i], result);
                }
            };

            LanguageService.prototype.addDeclaration = function (symbolKind, symbolName, containerKind, containerName, declaration, result) {
                var ast = declaration.ast();
                result.push(new Services.DefinitionInfo(this._getHostFileName(declaration.fileName()), TypeScript.start(ast), TypeScript.end(ast), symbolKind, symbolName, containerKind, containerName));
            };

            LanguageService.prototype.tryAddDefinition = function (symbolKind, symbolName, containerKind, containerName, declarations, result) {
                var _this = this;
                var definitionDeclaration = TypeScript.ArrayUtilities.firstOrDefault(declarations, function (d) {
                    var signature = d.getSignatureSymbol(_this.getSemanticInfoChain());
                    return signature && signature.isDefinition();
                });

                if (!definitionDeclaration) {
                    return false;
                }

                this.addDeclaration(symbolKind, symbolName, containerKind, containerName, definitionDeclaration, result);
                return true;
            };

            LanguageService.prototype.tryAddSignatures = function (symbolKind, symbolName, containerKind, containerName, declarations, result) {
                var _this = this;
                var signatureDeclarations = TypeScript.ArrayUtilities.where(declarations, function (d) {
                    var signature = d.getSignatureSymbol(_this.getSemanticInfoChain());
                    return signature && !signature.isDefinition();
                });

                if (signatureDeclarations.length === 0) {
                    return false;
                }

                this.addDeclaration(symbolKind, symbolName, containerKind, containerName, TypeScript.ArrayUtilities.last(signatureDeclarations), result);
                return true;
            };

            LanguageService.prototype.tryAddConstructor = function (symbolKind, symbolName, containerKind, containerName, declarations, result) {
                var constructorDeclarations = TypeScript.ArrayUtilities.where(declarations, function (d) {
                    return d.kind === 32768 /* ConstructorMethod */;
                });

                if (constructorDeclarations.length === 0) {
                    return false;
                }

                this.addDeclaration(symbolKind, symbolName, containerKind, containerName, TypeScript.ArrayUtilities.last(constructorDeclarations), result);
                return true;
            };

            LanguageService.prototype.getNavigateToItems = function (searchValue) {
                var _this = this;
                TypeScript.Debug.assert(searchValue !== null && searchValue !== undefined, "The searchValue argument was not supplied or null");

                var terms = searchValue.split(" ");

                var searchTerms = terms.map(function (t) {
                    return ({ caseSensitive: _this.hasAnyUpperCaseCharacter(t), term: t });
                });

                var items = [];

                var fileNames = this.compiler.fileNames();
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];
                    var declaration = this.compiler.getCachedTopLevelDeclaration(fileName);
                    this.findSearchValueInPullDecl(fileName, [declaration], items, searchTerms);
                }
                return items;
            };

            LanguageService.prototype.hasAnyUpperCaseCharacter = function (s) {
                for (var i = 0; i < s.length; ++i) {
                    if (s.charAt(i).toLocaleLowerCase() !== s.charAt(i)) {
                        return true;
                    }
                }

                return false;
            };

            LanguageService.prototype.findSearchValueInPullDecl = function (fileName, declarations, results, searchTerms, parentName, parentkindName) {
                var item;
                var declaration;
                var declName;
                var kindName;
                var matchKind;
                var fullName;

                for (var i = 0, declLength = declarations.length; i < declLength; ++i) {
                    declaration = declarations[i];
                    declName = declaration.getDisplayName();
                    kindName = this.mapPullElementKind(declaration.kind);
                    matchKind = null;

                    for (var j = 0, termsLength = searchTerms.length; j < termsLength; ++j) {
                        var searchTerm = searchTerms[j];
                        var declNameToSearch = searchTerm.caseSensitive ? declName : declName.toLocaleLowerCase();

                        var index = declNameToSearch.indexOf(searchTerm.term);

                        if (index !== -1) {
                            if (index === 0) {
                                matchKind = declName.length === searchTerm.term.length ? Services.MatchKind.exact : Services.MatchKind.prefix;
                            } else {
                                matchKind = Services.MatchKind.subString;
                            }
                        }
                    }

                    if (this.shouldIncludeDeclarationInNavigationItems(declaration)) {
                        fullName = parentName ? parentName + "." + declName : declName;
                        var ast = declaration.ast();
                        if (matchKind) {
                            item = new Services.NavigateToItem();
                            item.name = declName;
                            item.matchKind = matchKind;
                            item.kind = this.mapPullElementKind(declaration.kind);
                            item.kindModifiers = this.getScriptElementKindModifiersFromDecl(declaration);
                            item.fileName = this._getHostFileName(fileName);
                            item.minChar = TypeScript.start(ast);
                            item.limChar = TypeScript.end(ast);
                            item.containerName = parentName || "";
                            item.containerKind = parentkindName || "";
                            results.push(item);
                        }
                    }
                    if (this.isContainerDeclaration(declaration)) {
                        this.findSearchValueInPullDecl(fileName, declaration.getChildDecls(), results, searchTerms, fullName, kindName);
                    }
                }
            };

            LanguageService.prototype.getScriptElementKindModifiersFromDecl = function (decl) {
                var result = [];
                var flags = decl.flags;

                if (flags & 1 /* Exported */) {
                    result.push(Services.ScriptElementKindModifier.exportedModifier);
                }

                if (flags & 8 /* Ambient */) {
                    result.push(Services.ScriptElementKindModifier.ambientModifier);
                }

                if (flags & 4 /* Public */) {
                    result.push(Services.ScriptElementKindModifier.publicMemberModifier);
                }

                if (flags & 2 /* Private */) {
                    result.push(Services.ScriptElementKindModifier.privateMemberModifier);
                }

                if (flags & 16 /* Static */) {
                    result.push(Services.ScriptElementKindModifier.staticModifier);
                }

                return result.length > 0 ? result.join(',') : Services.ScriptElementKindModifier.none;
            };

            LanguageService.prototype.isContainerDeclaration = function (declaration) {
                switch (declaration.kind) {
                    case 1 /* Script */:
                    case 4 /* Container */:
                    case 8 /* Class */:
                    case 16 /* Interface */:
                    case 32 /* DynamicModule */:
                    case 64 /* Enum */:
                        return true;
                }

                return false;
            };

            LanguageService.prototype.shouldIncludeDeclarationInNavigationItems = function (declaration) {
                switch (declaration.kind) {
                    case 1 /* Script */:
                        return false;
                    case 512 /* Variable */:
                    case 4096 /* Property */:
                        return (declaration.flags & (16384 /* ClassConstructorVariable */ | 32768 /* InitializedModule */ | 65536 /* InitializedDynamicModule */ | 4096 /* Enum */)) === 0;
                    case 67108864 /* EnumMember */:
                        return true;
                    case 131072 /* FunctionExpression */:
                    case 16384 /* Function */:
                        return declaration.name !== "";
                    case 32768 /* ConstructorMethod */:
                        return false;
                }

                if (this.isContainerDeclaration(declaration)) {
                    return true;
                }

                return true;
            };

            LanguageService.prototype.getSyntacticDiagnostics = function (fileName) {
                fileName = TypeScript.switchToForwardSlashes(fileName);
                return this.compiler.getSyntacticDiagnostics(fileName);
            };

            LanguageService.prototype.getSemanticDiagnostics = function (fileName) {
                fileName = TypeScript.switchToForwardSlashes(fileName);
                return this.compiler.getSemanticDiagnostics(fileName);
            };

            LanguageService.prototype._getHostSpecificDiagnosticWithFileName = function (diagnostic) {
                return new TypeScript.Diagnostic(this._getHostFileName(diagnostic.fileName()), diagnostic.lineMap(), diagnostic.start(), diagnostic.length(), diagnostic.diagnosticKey(), diagnostic.arguments(), diagnostic.additionalLocations());
            };

            LanguageService.prototype.getCompilerOptionsDiagnostics = function () {
                var _this = this;
                var resolvePath = function (fileName) {
                    return _this.host.resolveRelativePath(fileName, null);
                };
                var compilerOptionsDiagnostics = this.compiler.getCompilerOptionsDiagnostics(resolvePath);
                return compilerOptionsDiagnostics.map(function (d) {
                    return _this._getHostSpecificDiagnosticWithFileName(d);
                });
            };

            LanguageService.prototype._getHostFileName = function (fileName) {
                if (fileName) {
                    return this.compiler.getCachedHostFileName(fileName);
                }
                return fileName;
            };

            LanguageService.prototype.getEmitOutput = function (fileName) {
                var _this = this;
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var resolvePath = function (fileName) {
                    return _this.host.resolveRelativePath(fileName, null);
                };

                var document = this.compiler.getDocument(fileName);
                var emitToSingleFile = document.emitToOwnOutputFile();

                var syntacticDiagnostics = emitToSingleFile ? this.getSyntacticDiagnostics(fileName) : this.getAllSyntacticDiagnostics();
                if (this.containErrors(syntacticDiagnostics)) {
                    return new TypeScript.EmitOutput(1 /* FailedBecauseOfSyntaxErrors */);
                }

                var semanticDiagnostics = emitToSingleFile ? this.getSemanticDiagnostics(fileName) : this.getAllSemanticDiagnostics();

                var emitResult = this.compiler.emit(fileName, resolvePath);
                if (emitResult.emitOutputResult == 0 /* Succeeded */) {
                    if (!this.containErrors(semanticDiagnostics)) {
                        var declarationEmitOutput = this.compiler.emitDeclarations(fileName, resolvePath);
                        emitResult.outputFiles.push.apply(emitResult.outputFiles, declarationEmitOutput.outputFiles);
                        TypeScript.Debug.assert(declarationEmitOutput.emitOutputResult == 0 /* Succeeded */);
                    } else if (this.compiler.canEmitDeclarations(fileName)) {
                        emitResult.emitOutputResult = 3 /* FailedToGenerateDeclarationsBecauseOfSemanticErrors */;
                    }
                }

                return emitResult;
            };

            LanguageService.prototype.getAllSyntacticDiagnostics = function () {
                var _this = this;
                var diagnostics = [];

                this.compiler.fileNames().forEach(function (fileName) {
                    return diagnostics.push.apply(diagnostics, _this.compiler.getSyntacticDiagnostics(fileName));
                });

                return diagnostics;
            };

            LanguageService.prototype.getAllSemanticDiagnostics = function () {
                var _this = this;
                var diagnostics = [];

                this.compiler.fileNames().map(function (fileName) {
                    return diagnostics.push.apply(diagnostics, _this.compiler.getSemanticDiagnostics(fileName));
                });

                return diagnostics;
            };

            LanguageService.prototype.containErrors = function (diagnostics) {
                if (diagnostics && diagnostics.length > 0) {
                    for (var i = 0; i < diagnostics.length; i++) {
                        var diagnosticInfo = diagnostics[i].info();
                        if (diagnosticInfo.category === 1 /* Error */) {
                            return true;
                        }
                    }
                }

                return false;
            };

            LanguageService.prototype.getFullNameOfSymbol = function (symbol, enclosingScopeSymbol) {
                var container = symbol.getContainer();
                if (TypeScript.PullHelpers.isSymbolLocal(symbol) || symbol.kind == 2048 /* Parameter */) {
                    return symbol.getScopedName(enclosingScopeSymbol, false, true);
                }

                var symbolKind = symbol.kind;
                if (symbol.kind == 2 /* Primitive */) {
                    return "";
                }

                if (symbolKind == 33554432 /* ConstructorType */) {
                    symbol = symbol.getAssociatedContainerType();
                }

                if (symbolKind != 4096 /* Property */ && symbolKind != 67108864 /* EnumMember */ && symbolKind != 65536 /* Method */ && symbolKind != 8192 /* TypeParameter */ && !symbol.anyDeclHasFlag(1 /* Exported */)) {
                    return symbol.getScopedName(enclosingScopeSymbol, false, true);
                }

                return symbol.fullName(enclosingScopeSymbol);
            };

            LanguageService.prototype.getTypeInfoEligiblePath = function (fileName, position, isConstructorValidPosition) {
                var document = this.compiler.getDocument(fileName);
                var sourceUnit = document.sourceUnit();

                var ast = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, position, false, true);
                if (ast === null) {
                    return null;
                }

                if (ast.kind() === 228 /* ParameterList */ && ast.parent.kind() === 143 /* CallSignature */ && ast.parent.parent.kind() === 138 /* ConstructorDeclaration */) {
                    ast = ast.parent.parent;
                }

                switch (ast.kind()) {
                    default:
                        return null;
                    case 138 /* ConstructorDeclaration */:
                        var constructorAST = ast;
                        if (!isConstructorValidPosition || !(position >= TypeScript.start(constructorAST) && position <= TypeScript.start(constructorAST) + "constructor".length)) {
                            return null;
                        } else {
                            return ast;
                        }

                    case 130 /* FunctionDeclaration */:
                        return null;

                    case 213 /* MemberAccessExpression */:
                    case 121 /* QualifiedName */:
                    case 50 /* SuperKeyword */:
                    case 14 /* StringLiteral */:
                    case 35 /* ThisKeyword */:
                    case 11 /* IdentifierName */:
                        return ast;
                }
            };

            LanguageService.prototype.getTypeAtPosition = function (fileName, position) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var node = this.getTypeInfoEligiblePath(fileName, position, true);
                if (!node) {
                    return null;
                }

                var document = this.compiler.getDocument(fileName);
                var ast;
                var symbol;
                var typeSymbol;
                var enclosingScopeSymbol;
                var _isCallExpression = false;
                var resolvedSignatures;
                var candidateSignature;
                var isConstructorCall;

                if (TypeScript.ASTHelpers.isDeclarationASTOrDeclarationNameAST(node)) {
                    var declarationInformation = this.compiler.getSymbolInformationFromAST(node, document);
                    if (!declarationInformation) {
                        return null;
                    }

                    ast = declarationInformation.ast;
                    symbol = declarationInformation.symbol;
                    enclosingScopeSymbol = declarationInformation.enclosingScopeSymbol;

                    if (node.kind() === 138 /* ConstructorDeclaration */ || node.kind() === 130 /* FunctionDeclaration */ || node.kind() === 219 /* ParenthesizedArrowFunctionExpression */ || node.kind() === 220 /* SimpleArrowFunctionExpression */ || node.kind() === 136 /* MemberFunctionDeclaration */ || TypeScript.ASTHelpers.isNameOfFunction(node) || TypeScript.ASTHelpers.isNameOfMemberFunction(node)) {
                        var funcDecl = node.kind() === 11 /* IdentifierName */ ? node.parent : node;
                        if (symbol && symbol.kind != 4096 /* Property */) {
                            var signatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(this.compiler.getDeclForAST(funcDecl), symbol.semanticInfoChain);
                            _isCallExpression = true;
                            candidateSignature = signatureInfo.signature;
                            resolvedSignatures = signatureInfo.allSignatures;
                        }
                    }
                } else if (TypeScript.ASTHelpers.isCallExpression(node) || TypeScript.ASTHelpers.isCallExpressionTarget(node)) {
                    while (!TypeScript.ASTHelpers.isCallExpression(node)) {
                        node = node.parent;
                    }

                    var callExpressionInformation = this.compiler.getCallInformationFromAST(node, document);

                    if (!callExpressionInformation || !callExpressionInformation.targetSymbol) {
                        return null;
                    }

                    ast = callExpressionInformation.ast;
                    symbol = callExpressionInformation.targetSymbol;
                    enclosingScopeSymbol = callExpressionInformation.enclosingScopeSymbol;

                    var isPropertyOrVar = symbol.kind == 4096 /* Property */ || symbol.kind == 512 /* Variable */;
                    typeSymbol = symbol.type;
                    if (isPropertyOrVar) {
                        if (typeSymbol.getName() != "") {
                            symbol = typeSymbol;
                        }
                        isPropertyOrVar = (typeSymbol.kind != 16 /* Interface */ && typeSymbol.kind != 8388608 /* ObjectType */) || typeSymbol.getName() == "";
                    }

                    if (!isPropertyOrVar) {
                        _isCallExpression = true;
                        resolvedSignatures = callExpressionInformation.resolvedSignatures;
                        candidateSignature = callExpressionInformation.candidateSignature;
                        isConstructorCall = callExpressionInformation.isConstructorCall;
                    }
                } else {
                    var symbolInformation = this.compiler.getSymbolInformationFromAST(node, document);

                    if (!symbolInformation || !symbolInformation.symbol) {
                        return null;
                    }

                    ast = symbolInformation.ast;
                    symbol = symbolInformation.symbol;
                    enclosingScopeSymbol = symbolInformation.enclosingScopeSymbol;

                    if (symbol.kind === 65536 /* Method */ || symbol.kind == 16384 /* Function */) {
                        typeSymbol = symbol.type;
                        if (typeSymbol) {
                            _isCallExpression = true;
                            resolvedSignatures = typeSymbol.getCallSignatures();
                        }
                    }
                }

                if (resolvedSignatures && (!candidateSignature || candidateSignature.isDefinition())) {
                    for (var i = 0, len = resolvedSignatures.length; i < len; i++) {
                        if (len > 1 && resolvedSignatures[i].isDefinition()) {
                            continue;
                        }

                        candidateSignature = resolvedSignatures[i];
                        break;
                    }
                }

                var memberName = _isCallExpression ? TypeScript.PullSignatureSymbol.getSignatureTypeMemberName(candidateSignature, resolvedSignatures, enclosingScopeSymbol) : symbol.getTypeNameEx(enclosingScopeSymbol, true);
                var kind = this.mapPullElementKind(symbol.kind, symbol, !_isCallExpression, _isCallExpression, isConstructorCall);

                var docCommentSymbol = candidateSignature || symbol;
                var docComment = docCommentSymbol.docComments(!_isCallExpression);
                var symbolName = this.getFullNameOfSymbol(symbol, enclosingScopeSymbol);
                var minChar = ast ? TypeScript.start(ast) : -1;
                var limChar = ast ? TypeScript.end(ast) : -1;

                return new Services.TypeInfo(memberName, docComment, symbolName, kind, minChar, limChar);
            };

            LanguageService.prototype.getCompletionsAtPosition = function (fileName, position, isMemberCompletion) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var document = this.compiler.getDocument(fileName);
                var sourceUnit = document.sourceUnit();

                if (Services.CompletionHelpers.isCompletionListBlocker(document.syntaxTree().sourceUnit(), position)) {
                    this.logger.log("Returning an empty list because completion was blocked.");
                    return null;
                }

                var node = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, position, true, true);

                if (node && node.kind() === 11 /* IdentifierName */ && TypeScript.start(node) === TypeScript.end(node)) {
                    node = node.parent;
                }

                var isRightOfDot = false;
                if (node && node.kind() === 213 /* MemberAccessExpression */ && TypeScript.end(node.expression) < position) {
                    isRightOfDot = true;
                    node = node.expression;
                } else if (node && node.kind() === 121 /* QualifiedName */ && TypeScript.end(node.left) < position) {
                    isRightOfDot = true;
                    node = node.left;
                } else if (node && node.parent && node.kind() === 11 /* IdentifierName */ && node.parent.kind() === 213 /* MemberAccessExpression */ && node.parent.name === node) {
                    isRightOfDot = true;
                    node = node.parent.expression;
                } else if (node && node.parent && node.kind() === 11 /* IdentifierName */ && node.parent.kind() === 121 /* QualifiedName */ && node.parent.right === node) {
                    isRightOfDot = true;
                    node = node.parent.left;
                }

                var entries = new TypeScript.IdentiferNameHashTable();

                if (isRightOfDot) {
                    var members = this.compiler.getVisibleMemberSymbolsFromAST(node, document);
                    if (!members) {
                        return null;
                    }

                    isMemberCompletion = true;
                    this.getCompletionEntriesFromSymbols(members, entries);
                } else {
                    var containingObjectLiteral = Services.CompletionHelpers.getContainingObjectLiteralApplicableForCompletion(document.syntaxTree().sourceUnit(), position);

                    if (containingObjectLiteral) {
                        var searchPosition = Math.min(position, TypeScript.end(containingObjectLiteral));
                        var path = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, searchPosition);

                        while (node && node.kind() !== 216 /* ObjectLiteralExpression */) {
                            node = node.parent;
                        }

                        if (!node || node.kind() !== 216 /* ObjectLiteralExpression */) {
                            return null;
                        }

                        isMemberCompletion = true;

                        var contextualMembers = this.compiler.getContextualMembersFromAST(node, document);
                        if (contextualMembers && contextualMembers.symbols && contextualMembers.symbols.length > 0) {
                            var existingMembers = this.compiler.getVisibleMemberSymbolsFromAST(node, document);

                            this.getCompletionEntriesFromSymbols({
                                symbols: Services.CompletionHelpers.filterContextualMembersList(contextualMembers.symbols, existingMembers, fileName, position),
                                enclosingScopeSymbol: contextualMembers.enclosingScopeSymbol
                            }, entries);
                        }
                    } else {
                        isMemberCompletion = false;
                        var decls = this.compiler.getVisibleDeclsFromAST(node, document);
                        this.getCompletionEntriesFromDecls(decls, entries);
                    }
                }

                if (!isMemberCompletion) {
                    this.getCompletionEntriesForKeywords(Services.KeywordCompletions.getKeywordCompltions(), entries);
                }

                var completions = new Services.CompletionInfo();
                completions.isMemberCompletion = isMemberCompletion;
                completions.entries = [];
                entries.map(function (key, value) {
                    completions.entries.push({
                        name: value.name,
                        kind: value.kind,
                        kindModifiers: value.kindModifiers
                    });
                }, null);

                this.activeCompletionSession = new Services.CompletionSession(fileName, position, entries);

                return completions;
            };

            LanguageService.prototype.getCompletionEntriesFromSymbols = function (symbolInfo, result) {
                for (var i = 0, n = symbolInfo.symbols.length; i < n; i++) {
                    var symbol = symbolInfo.symbols[i];

                    var symbolDisplayName = Services.CompletionHelpers.getValidCompletionEntryDisplayName(symbol.getDisplayName());
                    if (!symbolDisplayName) {
                        continue;
                    }

                    var symbolKind = symbol.kind;

                    var exitingEntry = result.lookup(symbolDisplayName);

                    if (exitingEntry && (symbolKind & 68147712 /* SomeValue */)) {
                        continue;
                    }

                    var entry;
                    var kindName = this.mapPullElementKind(symbolKind, symbol, true);
                    var kindModifiersName = this.getScriptElementKindModifiers(symbol);

                    if (symbol.isResolved) {
                        var completionInfo = this.getResolvedCompletionEntryDetailsFromSymbol(symbol, symbolInfo.enclosingScopeSymbol);

                        entry = new Services.ResolvedCompletionEntry(symbolDisplayName, kindName, kindModifiersName, completionInfo.typeName, completionInfo.fullSymbolName, completionInfo.docComments);
                    } else {
                        entry = new Services.DeclReferenceCompletionEntry(symbolDisplayName, kindName, kindModifiersName, symbol.getDeclarations()[0]);
                    }

                    result.addOrUpdate(symbolDisplayName, entry);
                }
            };

            LanguageService.prototype.getCompletionEntriesFromDecls = function (decls, result) {
                var semanticInfoChain = this.getSemanticInfoChain();
                for (var i = 0, n = decls ? decls.length : 0; i < n; i++) {
                    var decl = decls[i];

                    var declDisplaylName = Services.CompletionHelpers.getValidCompletionEntryDisplayName(decl.getDisplayName());
                    if (!declDisplaylName) {
                        continue;
                    }

                    var declKind = decl.kind;

                    var exitingEntry = result.lookup(declDisplaylName);

                    if (exitingEntry && (declKind & 68147712 /* SomeValue */)) {
                        continue;
                    }

                    var kindName = this.mapPullElementKind(declKind, null, true);
                    var kindModifiersName = this.getScriptElementKindModifiersFromFlags(decl.flags);

                    var entry = null;

                    var symbol = decl.hasSymbol(semanticInfoChain) && decl.getSymbol(semanticInfoChain);

                    var enclosingDecl = decl.getEnclosingDecl();
                    var enclosingScopeSymbol = (enclosingDecl && enclosingDecl.hasSymbol(semanticInfoChain)) ? enclosingDecl.getSymbol(semanticInfoChain) : null;

                    if (symbol && symbol.isResolved && enclosingScopeSymbol && enclosingScopeSymbol.isResolved) {
                        var completionInfo = this.getResolvedCompletionEntryDetailsFromSymbol(symbol, enclosingScopeSymbol);
                        entry = new Services.ResolvedCompletionEntry(declDisplaylName, kindName, kindModifiersName, completionInfo.typeName, completionInfo.fullSymbolName, completionInfo.docComments);
                    } else {
                        entry = new Services.DeclReferenceCompletionEntry(declDisplaylName, kindName, kindModifiersName, decl);
                    }

                    result.addOrUpdate(declDisplaylName, entry);
                }
            };

            LanguageService.prototype.getResolvedCompletionEntryDetailsFromSymbol = function (symbol, enclosingScopeSymbol) {
                var typeName = symbol.getTypeName(enclosingScopeSymbol, true);
                var fullSymbolName = this.getFullNameOfSymbol(symbol, enclosingScopeSymbol);

                var type = symbol.type;
                var symbolForDocComments = symbol;
                if (type && type.hasOnlyOverloadCallSignatures()) {
                    symbolForDocComments = type.getCallSignatures()[0];
                }

                var docComments = symbolForDocComments.docComments(true);
                return {
                    typeName: typeName,
                    fullSymbolName: fullSymbolName,
                    docComments: docComments
                };
            };

            LanguageService.prototype.getCompletionEntriesForKeywords = function (keywords, result) {
                for (var i = 0, n = keywords.length; i < n; i++) {
                    var keyword = keywords[i];
                    result.addOrUpdate(keyword.name, keyword);
                }
            };

            LanguageService.prototype.getCompletionEntryDetails = function (fileName, position, entryName) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                if (!this.activeCompletionSession || this.activeCompletionSession.fileName !== fileName || this.activeCompletionSession.position !== position) {
                    return null;
                }

                var entry = this.activeCompletionSession.entries.lookup(entryName);
                if (!entry) {
                    return null;
                }

                if (!entry.isResolved()) {
                    var decl = entry.decl;

                    var document = this.compiler.getDocument(fileName);
                    if (decl.fileName() === TypeScript.switchToForwardSlashes(fileName)) {
                        decl = this.tryFindDeclFromPreviousCompilerVersion(decl);

                        if (decl) {
                            var declDisplaylName = Services.CompletionHelpers.getValidCompletionEntryDisplayName(decl.getDisplayName());
                            var declKind = decl.kind;
                            var kindName = this.mapPullElementKind(declKind, null, true);
                            var kindModifiersName = this.getScriptElementKindModifiersFromFlags(decl.flags);

                            entry = new Services.DeclReferenceCompletionEntry(declDisplaylName, kindName, kindModifiersName, decl);
                            this.activeCompletionSession.entries.addOrUpdate(entryName, entry);
                        }
                    }

                    if (decl) {
                        var node = TypeScript.ASTHelpers.getAstAtPosition(document.sourceUnit(), position);
                        var symbolInfo = this.compiler.pullGetDeclInformation(decl, node, document);

                        if (!symbolInfo) {
                            return null;
                        }

                        var symbol = symbolInfo.symbol;
                        var completionInfo = this.getResolvedCompletionEntryDetailsFromSymbol(symbol, symbolInfo.enclosingScopeSymbol);

                        entry.resolve(completionInfo.typeName, completionInfo.fullSymbolName, completionInfo.docComments);
                    }
                }

                return {
                    name: entry.name,
                    kind: entry.kind,
                    kindModifiers: entry.kindModifiers,
                    type: entry.type,
                    fullSymbolName: entry.fullSymbolName,
                    docComment: entry.docComment
                };
            };

            LanguageService.prototype.tryFindDeclFromPreviousCompilerVersion = function (invalidatedDecl) {
                var fileName = invalidatedDecl.fileName();

                var declsInPath = [];
                var current = invalidatedDecl;
                while (current) {
                    if (current.kind !== 1 /* Script */) {
                        declsInPath.unshift(current);
                    }

                    current = current.getParentDecl();
                }

                var topLevelDecl = this.compiler.topLevelDeclaration(fileName);
                if (!topLevelDecl) {
                    return null;
                }

                var declsToSearch = [topLevelDecl];
                var foundDecls = [];
                var keepSearching = (invalidatedDecl.kind & 4 /* Container */) || (invalidatedDecl.kind & 16 /* Interface */) || (invalidatedDecl.kind & 8 /* Class */) || (invalidatedDecl.kind & 64 /* Enum */);

                for (var i = 0; i < declsInPath.length; i++) {
                    var declInPath = declsInPath[i];
                    var decls = [];

                    for (var j = 0; j < declsToSearch.length; j++) {
                        foundDecls = declsToSearch[j].searchChildDecls(declInPath.name, declInPath.kind);

                        decls.push.apply(decls, foundDecls);

                        if (foundDecls.length && !keepSearching) {
                            break;
                        }
                    }

                    declsToSearch = decls;

                    if (declsToSearch.length == 0) {
                        break;
                    }
                }

                return declsToSearch.length === 0 ? null : declsToSearch[0];
            };

            LanguageService.prototype.getModuleOrEnumKind = function (symbol) {
                if (symbol) {
                    var declarations = symbol.getDeclarations();
                    for (var i = 0; i < declarations.length; i++) {
                        var declKind = declarations[i].kind;
                        if (declKind == 4 /* Container */) {
                            return Services.ScriptElementKind.moduleElement;
                        } else if (declKind == 64 /* Enum */) {
                            return Services.ScriptElementKind.enumElement;
                        } else if (declKind == 512 /* Variable */) {
                            var declFlags = declarations[i].flags;
                            if (declFlags & 32768 /* InitializedModule */) {
                                return Services.ScriptElementKind.moduleElement;
                            } else if (declFlags & 4096 /* Enum */) {
                                return Services.ScriptElementKind.enumElement;
                            }
                        }
                    }
                }
                return Services.ScriptElementKind.unknown;
            };

            LanguageService.prototype.mapPullElementKind = function (kind, symbol, useConstructorAsClass, varIsFunction, functionIsConstructor) {
                if (functionIsConstructor) {
                    return Services.ScriptElementKind.constructorImplementationElement;
                }

                if (varIsFunction) {
                    switch (kind) {
                        case 4 /* Container */:
                        case 32 /* DynamicModule */:
                        case 128 /* TypeAlias */:
                        case 16 /* Interface */:
                        case 8 /* Class */:
                        case 2048 /* Parameter */:
                            return Services.ScriptElementKind.functionElement;
                        case 512 /* Variable */:
                            return (symbol && TypeScript.PullHelpers.isSymbolLocal(symbol)) ? Services.ScriptElementKind.localFunctionElement : Services.ScriptElementKind.functionElement;
                        case 4096 /* Property */:
                            return Services.ScriptElementKind.memberFunctionElement;
                        case 16384 /* Function */:
                            return (symbol && TypeScript.PullHelpers.isSymbolLocal(symbol)) ? Services.ScriptElementKind.localFunctionElement : Services.ScriptElementKind.functionElement;
                        case 32768 /* ConstructorMethod */:
                            return Services.ScriptElementKind.constructorImplementationElement;
                        case 65536 /* Method */:
                            return Services.ScriptElementKind.memberFunctionElement;
                        case 131072 /* FunctionExpression */:
                            return Services.ScriptElementKind.localFunctionElement;
                        case 262144 /* GetAccessor */:
                            return Services.ScriptElementKind.memberGetAccessorElement;
                        case 524288 /* SetAccessor */:
                            return Services.ScriptElementKind.memberSetAccessorElement;
                        case 1048576 /* CallSignature */:
                            return Services.ScriptElementKind.callSignatureElement;
                        case 2097152 /* ConstructSignature */:
                            return Services.ScriptElementKind.constructSignatureElement;
                        case 4194304 /* IndexSignature */:
                            return Services.ScriptElementKind.indexSignatureElement;
                        case 8192 /* TypeParameter */:
                            return Services.ScriptElementKind.typeParameterElement;
                        case 2 /* Primitive */:
                            return Services.ScriptElementKind.primitiveType;
                    }
                } else {
                    switch (kind) {
                        case 1 /* Script */:
                            return Services.ScriptElementKind.scriptElement;
                        case 4 /* Container */:
                        case 32 /* DynamicModule */:
                        case 128 /* TypeAlias */:
                            return Services.ScriptElementKind.moduleElement;
                        case 16 /* Interface */:
                            return Services.ScriptElementKind.interfaceElement;
                        case 8 /* Class */:
                            return Services.ScriptElementKind.classElement;
                        case 64 /* Enum */:
                            return Services.ScriptElementKind.enumElement;
                        case 512 /* Variable */:
                            var scriptElementKind = this.getModuleOrEnumKind(symbol);
                            if (scriptElementKind != Services.ScriptElementKind.unknown) {
                                return scriptElementKind;
                            }
                            return (symbol && TypeScript.PullHelpers.isSymbolLocal(symbol)) ? Services.ScriptElementKind.localVariableElement : Services.ScriptElementKind.variableElement;
                        case 2048 /* Parameter */:
                            return Services.ScriptElementKind.parameterElement;
                        case 4096 /* Property */:
                            return Services.ScriptElementKind.memberVariableElement;
                        case 16384 /* Function */:
                            return (symbol && TypeScript.PullHelpers.isSymbolLocal(symbol)) ? Services.ScriptElementKind.localFunctionElement : Services.ScriptElementKind.functionElement;
                        case 32768 /* ConstructorMethod */:
                            return useConstructorAsClass ? Services.ScriptElementKind.classElement : Services.ScriptElementKind.constructorImplementationElement;
                        case 65536 /* Method */:
                            return Services.ScriptElementKind.memberFunctionElement;
                        case 131072 /* FunctionExpression */:
                            return Services.ScriptElementKind.localFunctionElement;
                        case 262144 /* GetAccessor */:
                            return Services.ScriptElementKind.memberGetAccessorElement;
                        case 524288 /* SetAccessor */:
                            return Services.ScriptElementKind.memberSetAccessorElement;
                        case 1048576 /* CallSignature */:
                            return Services.ScriptElementKind.callSignatureElement;
                        case 2097152 /* ConstructSignature */:
                            return Services.ScriptElementKind.constructSignatureElement;
                        case 4194304 /* IndexSignature */:
                            return Services.ScriptElementKind.indexSignatureElement;
                        case 67108864 /* EnumMember */:
                            return Services.ScriptElementKind.memberVariableElement;
                        case 8192 /* TypeParameter */:
                            return Services.ScriptElementKind.typeParameterElement;
                        case 2 /* Primitive */:
                            return Services.ScriptElementKind.primitiveType;
                    }
                }

                return Services.ScriptElementKind.unknown;
            };

            LanguageService.prototype.getScriptElementKindModifiers = function (symbol) {
                var result = [];

                if (symbol.anyDeclHasFlag(1 /* Exported */)) {
                    result.push(Services.ScriptElementKindModifier.exportedModifier);
                }
                if (symbol.anyDeclHasFlag(8 /* Ambient */)) {
                    result.push(Services.ScriptElementKindModifier.ambientModifier);
                }
                if (symbol.anyDeclHasFlag(4 /* Public */)) {
                    result.push(Services.ScriptElementKindModifier.publicMemberModifier);
                }
                if (symbol.anyDeclHasFlag(2 /* Private */)) {
                    result.push(Services.ScriptElementKindModifier.privateMemberModifier);
                }
                if (symbol.anyDeclHasFlag(16 /* Static */)) {
                    result.push(Services.ScriptElementKindModifier.staticModifier);
                }

                return result.length > 0 ? result.join(',') : Services.ScriptElementKindModifier.none;
            };

            LanguageService.prototype.getScriptElementKindModifiersFromFlags = function (flags) {
                var result = [];

                if (flags & 1 /* Exported */) {
                    result.push(Services.ScriptElementKindModifier.exportedModifier);
                }

                if (flags & 8 /* Ambient */) {
                    result.push(Services.ScriptElementKindModifier.ambientModifier);
                }

                if (flags & 4 /* Public */) {
                    result.push(Services.ScriptElementKindModifier.publicMemberModifier);
                }

                if (flags & 2 /* Private */) {
                    result.push(Services.ScriptElementKindModifier.privateMemberModifier);
                }

                if (flags & 16 /* Static */) {
                    result.push(Services.ScriptElementKindModifier.staticModifier);
                }

                return result.length > 0 ? result.join(',') : Services.ScriptElementKindModifier.none;
            };

            LanguageService.prototype.getNameOrDottedNameSpan = function (fileName, startPos, endPos) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var node = this.getTypeInfoEligiblePath(fileName, startPos, false);

                if (!node) {
                    return null;
                }

                while (node) {
                    if (TypeScript.ASTHelpers.isNameOfMemberAccessExpression(node) || TypeScript.ASTHelpers.isRightSideOfQualifiedName(node)) {
                        node = node.parent;
                    } else {
                        break;
                    }
                }

                var spanInfo = new Services.SpanInfo(TypeScript.start(node), TypeScript.end(node));
                return spanInfo;
            };

            LanguageService.prototype.getBreakpointStatementAtPosition = function (fileName, pos) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var syntaxtree = this.getSyntaxTree(fileName);
                return TypeScript.Services.Breakpoints.getBreakpointLocation(syntaxtree, pos);
            };

            LanguageService.prototype.getFormattingEditsForRange = function (fileName, minChar, limChar, options) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var manager = this.getFormattingManager(fileName, options);
                return manager.formatSelection(minChar, limChar);
            };

            LanguageService.prototype.getFormattingEditsForDocument = function (fileName, minChar, limChar, options) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var manager = this.getFormattingManager(fileName, options);
                return manager.formatDocument(minChar, limChar);
            };

            LanguageService.prototype.getFormattingEditsOnPaste = function (fileName, minChar, limChar, options) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var manager = this.getFormattingManager(fileName, options);
                return manager.formatOnPaste(minChar, limChar);
            };

            LanguageService.prototype.getFormattingEditsAfterKeystroke = function (fileName, position, key, options) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var manager = this.getFormattingManager(fileName, options);

                if (key === "}") {
                    return manager.formatOnClosingCurlyBrace(position);
                } else if (key === ";") {
                    return manager.formatOnSemicolon(position);
                } else if (key === "\n") {
                    return manager.formatOnEnter(position);
                }

                return [];
            };

            LanguageService.prototype.getFormattingManager = function (fileName, options) {
                if (this.formattingRulesProvider == null) {
                    this.formattingRulesProvider = new TypeScript.Services.Formatting.RulesProvider(this.logger);
                }

                this.formattingRulesProvider.ensureUpToDate(options);

                var syntaxTree = this.getSyntaxTree(fileName);

                var scriptSnapshot = this.compiler.getScriptSnapshot(fileName);
                var scriptText = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
                var textSnapshot = new TypeScript.Services.Formatting.TextSnapshot(scriptText);

                var manager = new TypeScript.Services.Formatting.FormattingManager(syntaxTree, textSnapshot, this.formattingRulesProvider, options);

                return manager;
            };

            LanguageService.prototype.getOutliningRegions = function (fileName) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var syntaxTree = this.getSyntaxTree(fileName);
                return Services.OutliningElementsCollector.collectElements(syntaxTree.sourceUnit());
            };

            LanguageService.prototype.getIndentationAtPosition = function (fileName, position, editorOptions) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var syntaxTree = this.getSyntaxTree(fileName);

                var scriptSnapshot = this.compiler.getScriptSnapshot(fileName);
                var scriptText = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
                var textSnapshot = new TypeScript.Services.Formatting.TextSnapshot(scriptText);
                var options = new TypeScript.FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);

                return TypeScript.Services.Formatting.SingleTokenIndenter.getIndentationAmount(position, syntaxTree.sourceUnit(), textSnapshot, options);
            };

            LanguageService.prototype.getBraceMatchingAtPosition = function (fileName, position) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var syntaxTree = this.getSyntaxTree(fileName);
                return Services.BraceMatcher.getMatchSpans(syntaxTree, position);
            };

            LanguageService.prototype.getScriptLexicalStructure = function (fileName) {
                fileName = TypeScript.switchToForwardSlashes(fileName);

                var syntaxTree = this.getSyntaxTree(fileName);
                var items = [];
                Services.GetScriptLexicalStructureWalker.getListsOfAllScriptLexicalStructure(items, fileName, syntaxTree.sourceUnit());

                return items;
            };

            LanguageService.prototype.getSyntaxTree = function (fileName) {
                fileName = TypeScript.switchToForwardSlashes(fileName);
                return this._syntaxTreeCache.getCurrentFileSyntaxTree(fileName);
            };
            return LanguageService;
        })();
        Services.LanguageService = LanguageService;

        function isSignatureHelpBlocker(ast) {
            if (ast) {
                switch (ast.kind()) {
                    case 132 /* ClassDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 138 /* ConstructorDeclaration */:
                    case 130 /* FunctionDeclaration */:
                    case 226 /* VariableDeclarator */:
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                    case 220 /* SimpleArrowFunctionExpression */:
                        return true;
                }
            }

            return false;
        }
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var FindReferenceHelpers = (function () {
            function FindReferenceHelpers() {
            }
            FindReferenceHelpers.compareSymbolsForLexicalIdentity = function (firstSymbol, secondSymbol) {
                if (!firstSymbol.isAlias() && firstSymbol.isContainer()) {
                    var containerForFirstSymbol = firstSymbol;
                    if (containerForFirstSymbol.getInstanceSymbol()) {
                        firstSymbol = containerForFirstSymbol.getInstanceSymbol();
                    }
                }

                if (!secondSymbol.isAlias() && secondSymbol.isContainer()) {
                    var containerForSecondSymbol = secondSymbol;
                    if (containerForSecondSymbol.getInstanceSymbol()) {
                        secondSymbol = containerForSecondSymbol.getInstanceSymbol();
                    }
                }

                if (firstSymbol.kind === secondSymbol.kind) {
                    if (firstSymbol === secondSymbol) {
                        return true;
                    }

                    if (firstSymbol.kind === 512 /* Variable */ && firstSymbol.name === secondSymbol.name && firstSymbol.getDeclarations() && firstSymbol.getDeclarations().length >= 1 && secondSymbol.getDeclarations() && secondSymbol.getDeclarations().length >= 1) {
                        var firstSymbolDecl = firstSymbol.getDeclarations()[0];
                        var secondSymbolDecl = secondSymbol.getDeclarations()[0];

                        return firstSymbolDecl.getParentDecl() === secondSymbolDecl.getParentDecl();
                    }

                    if (firstSymbol.kind === 4096 /* Property */ && firstSymbol.name === secondSymbol.name && firstSymbol.getDeclarations() && firstSymbol.getDeclarations().length >= 1 && secondSymbol.getDeclarations() && secondSymbol.getDeclarations().length >= 1) {
                        var firstSymbolDecl = firstSymbol.getDeclarations()[0];
                        var secondSymbolDecl = secondSymbol.getDeclarations()[0];

                        var firstParentDecl = firstSymbolDecl.getParentDecl();
                        var secondParentDecl = secondSymbolDecl.getParentDecl();

                        if (firstParentDecl.kind === 256 /* ObjectLiteral */ && secondParentDecl.kind === 256 /* ObjectLiteral */) {
                            return firstParentDecl.ast() === secondParentDecl.ast();
                        }
                    }

                    if (firstSymbol.name === secondSymbol.name) {
                        switch (firstSymbol.kind) {
                            case 4096 /* Property */:
                            case 65536 /* Method */:
                            case 262144 /* GetAccessor */:
                            case 524288 /* SetAccessor */:
                                var t1 = firstSymbol.getContainer();
                                var t2 = secondSymbol.getContainer();
                                t1._resolveDeclaredSymbol();
                                t2._resolveDeclaredSymbol();

                                return t1.hasBase(t2) || t2.hasBase(t1);
                                break;
                        }
                    }

                    return false;
                } else {
                    switch (firstSymbol.kind) {
                        case 8 /* Class */: {
                            return this.checkSymbolsForDeclarationEquality(firstSymbol, secondSymbol);
                        }
                        case 4096 /* Property */: {
                            if (firstSymbol.isAccessor()) {
                                var getterSymbol = firstSymbol.getGetter();
                                var setterSymbol = firstSymbol.getSetter();

                                if (getterSymbol && getterSymbol === secondSymbol) {
                                    return true;
                                }

                                if (setterSymbol && setterSymbol === secondSymbol) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        case 16384 /* Function */: {
                            if (secondSymbol.isAccessor()) {
                                var getterSymbol = secondSymbol.getGetter();
                                var setterSymbol = secondSymbol.getSetter();

                                if (getterSymbol && getterSymbol === firstSymbol) {
                                    return true;
                                }

                                if (setterSymbol && setterSymbol === firstSymbol) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        case 32768 /* ConstructorMethod */: {
                            return this.checkSymbolsForDeclarationEquality(firstSymbol, secondSymbol);
                        }
                    }
                }

                return firstSymbol === secondSymbol;
            };

            FindReferenceHelpers.checkSymbolsForDeclarationEquality = function (firstSymbol, secondSymbol) {
                var firstSymbolDeclarations = firstSymbol.getDeclarations();
                var secondSymbolDeclarations = secondSymbol.getDeclarations();
                for (var i = 0, iLen = firstSymbolDeclarations.length; i < iLen; i++) {
                    for (var j = 0, jLen = secondSymbolDeclarations.length; j < jLen; j++) {
                        if (this.declarationsAreSameOrParents(firstSymbolDeclarations[i], secondSymbolDeclarations[j])) {
                            return true;
                        }
                    }
                }
                return false;
            };

            FindReferenceHelpers.declarationsAreSameOrParents = function (firstDecl, secondDecl) {
                var firstParent = firstDecl.getParentDecl();
                var secondParent = secondDecl.getParentDecl();
                if (firstDecl === secondDecl || firstDecl === secondParent || firstParent === secondDecl || firstParent === secondParent) {
                    return true;
                }
                return false;
            };
            return FindReferenceHelpers;
        })();
        Services.FindReferenceHelpers = FindReferenceHelpers;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        

        

        var ShimBase = (function () {
            function ShimBase(factory) {
                this.factory = factory;
                factory.registerShim(this);
            }
            ShimBase.prototype.dispose = function (dummy) {
                this.factory.unregisterShim(this);
            };
            return ShimBase;
        })();
        Services.ShimBase = ShimBase;

        var ScriptSnapshotShimAdapter = (function () {
            function ScriptSnapshotShimAdapter(scriptSnapshotShim) {
                this.scriptSnapshotShim = scriptSnapshotShim;
                this.lineStartPositions = null;
            }
            ScriptSnapshotShimAdapter.prototype.getText = function (start, end) {
                return this.scriptSnapshotShim.getText(start, end);
            };

            ScriptSnapshotShimAdapter.prototype.getLength = function () {
                return this.scriptSnapshotShim.getLength();
            };

            ScriptSnapshotShimAdapter.prototype.getLineStartPositions = function () {
                if (this.lineStartPositions == null) {
                    this.lineStartPositions = JSON.parse(this.scriptSnapshotShim.getLineStartPositions());
                }

                return this.lineStartPositions;
            };

            ScriptSnapshotShimAdapter.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
                var encoded = this.scriptSnapshotShim.getTextChangeRangeSinceVersion(scriptVersion);
                if (encoded == null) {
                    return null;
                }

                var decoded = JSON.parse(encoded);
                return new TypeScript.TextChangeRange(new TypeScript.TextSpan(decoded.span.start, decoded.span.length), decoded.newLength);
            };
            return ScriptSnapshotShimAdapter;
        })();

        var LanguageServiceShimHostAdapter = (function () {
            function LanguageServiceShimHostAdapter(shimHost) {
                this.shimHost = shimHost;
            }
            LanguageServiceShimHostAdapter.prototype.information = function () {
                return this.shimHost.information();
            };

            LanguageServiceShimHostAdapter.prototype.debug = function () {
                return this.shimHost.debug();
            };

            LanguageServiceShimHostAdapter.prototype.warning = function () {
                return this.shimHost.warning();
            };

            LanguageServiceShimHostAdapter.prototype.error = function () {
                return this.shimHost.error();
            };

            LanguageServiceShimHostAdapter.prototype.fatal = function () {
                return this.shimHost.fatal();
            };

            LanguageServiceShimHostAdapter.prototype.log = function (s) {
                this.shimHost.log(s);
            };

            LanguageServiceShimHostAdapter.prototype.getCompilationSettings = function () {
                var settingsJson = this.shimHost.getCompilationSettings();
                if (settingsJson == null || settingsJson == "") {
                    return null;
                }
                var settings = JSON.parse(settingsJson);
                return settings;
            };

            LanguageServiceShimHostAdapter.prototype.getScriptFileNames = function () {
                var encoded = this.shimHost.getScriptFileNames();
                return JSON.parse(encoded);
            };

            LanguageServiceShimHostAdapter.prototype.getScriptSnapshot = function (fileName) {
                return new ScriptSnapshotShimAdapter(this.shimHost.getScriptSnapshot(fileName));
            };

            LanguageServiceShimHostAdapter.prototype.getScriptVersion = function (fileName) {
                return this.shimHost.getScriptVersion(fileName);
            };

            LanguageServiceShimHostAdapter.prototype.getScriptIsOpen = function (fileName) {
                return this.shimHost.getScriptIsOpen(fileName);
            };

            LanguageServiceShimHostAdapter.prototype.getScriptByteOrderMark = function (fileName) {
                return this.shimHost.getScriptByteOrderMark(fileName);
            };

            LanguageServiceShimHostAdapter.prototype.getDiagnosticsObject = function () {
                return this.shimHost.getDiagnosticsObject();
            };

            LanguageServiceShimHostAdapter.prototype.getLocalizedDiagnosticMessages = function () {
                var diagnosticMessagesJson = this.shimHost.getLocalizedDiagnosticMessages();
                if (diagnosticMessagesJson == null || diagnosticMessagesJson == "") {
                    return null;
                }
                try  {
                    return JSON.parse(diagnosticMessagesJson);
                } catch (e) {
                    this.log(e.description || "diagnosticMessages.generated.json has invalid JSON format");
                    return null;
                }
            };

            LanguageServiceShimHostAdapter.prototype.getCancellationToken = function () {
                return this.shimHost.getCancellationToken();
            };

            LanguageServiceShimHostAdapter.prototype.resolveRelativePath = function (path, directory) {
                return this.shimHost.resolveRelativePath(path, directory);
            };

            LanguageServiceShimHostAdapter.prototype.fileExists = function (path) {
                return this.shimHost.fileExists(path);
            };

            LanguageServiceShimHostAdapter.prototype.directoryExists = function (path) {
                return this.shimHost.directoryExists(path);
            };

            LanguageServiceShimHostAdapter.prototype.getParentDirectory = function (path) {
                return this.shimHost.getParentDirectory(path);
            };
            return LanguageServiceShimHostAdapter;
        })();
        Services.LanguageServiceShimHostAdapter = LanguageServiceShimHostAdapter;

        function simpleForwardCall(logger, actionDescription, action) {
            logger.log(actionDescription);
            var start = Date.now();
            var result = action();
            var end = Date.now();
            logger.log(actionDescription + " completed in " + (end - start) + " msec");
            if (typeof (result) === "string") {
                var str = result;
                if (str.length > 128) {
                    str = str.substring(0, 128) + "...";
                }
                logger.log("  result.length=" + str.length + ", result='" + JSON.stringify(str) + "'");
            }
            return result;
        }
        Services.simpleForwardCall = simpleForwardCall;

        function forwardJSONCall(logger, actionDescription, action) {
            try  {
                var result = simpleForwardCall(logger, actionDescription, action);
                return JSON.stringify({ result: result });
            } catch (err) {
                if (err instanceof TypeScript.OperationCanceledException) {
                    return JSON.stringify({ canceled: true });
                }
                TypeScript.Services.logInternalError(logger, err);
                err.description = actionDescription;
                return JSON.stringify({ error: err });
            }
        }
        Services.forwardJSONCall = forwardJSONCall;

        var LanguageServiceShim = (function (_super) {
            __extends(LanguageServiceShim, _super);
            function LanguageServiceShim(factory, host, languageService) {
                _super.call(this, factory);
                this.host = host;
                this.languageService = languageService;
                this.logger = this.host;
            }
            LanguageServiceShim.prototype.forwardJSONCall = function (actionDescription, action) {
                return TypeScript.Services.forwardJSONCall(this.logger, actionDescription, action);
            };

            LanguageServiceShim.prototype.dispose = function (dummy) {
                this.logger.log("dispose()");
                this.languageService.dispose();
                this.languageService = null;

                if (debugObjectHost && debugObjectHost.CollectGarbage) {
                    debugObjectHost.CollectGarbage();
                    this.logger.log("CollectGarbage()");
                }

                this.logger = null;

                _super.prototype.dispose.call(this, dummy);
            };

            LanguageServiceShim.prototype.refresh = function (throwOnError) {
                var _this = this;
                this.forwardJSONCall("refresh(" + throwOnError + ")", function () {
                    _this.languageService.refresh();
                    return null;
                });
            };

            LanguageServiceShim.prototype.cleanupSemanticCache = function () {
                var _this = this;
                this.forwardJSONCall("cleanupSemanticCache()", function () {
                    _this.languageService.cleanupSemanticCache();
                    return null;
                });
            };

            LanguageServiceShim.realizeDiagnosticCategory = function (category) {
                switch (category) {
                    case 1 /* Error */:
                        return Services.DiagnosticCategory.error;
                    case 0 /* Warning */:
                        return Services.DiagnosticCategory.warning;
                    case 2 /* Message */:
                        return Services.DiagnosticCategory.message;
                    default:
                        return Services.DiagnosticCategory.none;
                }
            };

            LanguageServiceShim.realizeDiagnostic = function (diagnostic) {
                return {
                    message: diagnostic.text(),
                    start: diagnostic.start(),
                    length: diagnostic.length(),
                    category: LanguageServiceShim.realizeDiagnosticCategory(diagnostic.info().category)
                };
            };

            LanguageServiceShim.prototype.realizeDiagnosticWithFileName = function (diagnostic) {
                return {
                    fileName: diagnostic.fileName(),
                    message: diagnostic.text(),
                    start: diagnostic.start(),
                    length: diagnostic.length(),
                    category: LanguageServiceShim.realizeDiagnosticCategory(diagnostic.info().category)
                };
            };

            LanguageServiceShim.prototype.getSyntacticDiagnostics = function (fileName) {
                var _this = this;
                return this.forwardJSONCall("getSyntacticDiagnostics(\"" + fileName + "\")", function () {
                    var errors = _this.languageService.getSyntacticDiagnostics(fileName);
                    return errors.map(LanguageServiceShim.realizeDiagnostic);
                });
            };

            LanguageServiceShim.prototype.getSemanticDiagnostics = function (fileName) {
                var _this = this;
                return this.forwardJSONCall("getSemanticDiagnostics(\"" + fileName + "\")", function () {
                    var errors = _this.languageService.getSemanticDiagnostics(fileName);
                    return errors.map(LanguageServiceShim.realizeDiagnostic);
                });
            };

            LanguageServiceShim.prototype.getCompilerOptionsDiagnostics = function () {
                var _this = this;
                return this.forwardJSONCall("getCompilerOptionsDiagnostics()", function () {
                    var errors = _this.languageService.getCompilerOptionsDiagnostics();
                    return errors.map(function (d) {
                        return _this.realizeDiagnosticWithFileName(d);
                    });
                });
            };

            LanguageServiceShim.prototype.getTypeAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getTypeAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    var typeInfo = _this.languageService.getTypeAtPosition(fileName, position);
                    return typeInfo;
                });
            };

            LanguageServiceShim.prototype.getNameOrDottedNameSpan = function (fileName, startPos, endPos) {
                var _this = this;
                return this.forwardJSONCall("getNameOrDottedNameSpan(\"" + fileName + "\", " + startPos + ", " + endPos + ")", function () {
                    var spanInfo = _this.languageService.getNameOrDottedNameSpan(fileName, startPos, endPos);
                    return spanInfo;
                });
            };

            LanguageServiceShim.prototype.getBreakpointStatementAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getBreakpointStatementAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    var spanInfo = _this.languageService.getBreakpointStatementAtPosition(fileName, position);
                    return spanInfo;
                });
            };

            LanguageServiceShim.prototype.getSignatureAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getSignatureAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    var signatureInfo = _this.languageService.getSignatureAtPosition(fileName, position);
                    return signatureInfo;
                });
            };

            LanguageServiceShim.prototype.getDefinitionAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getDefinitionAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    return _this.languageService.getDefinitionAtPosition(fileName, position);
                });
            };

            LanguageServiceShim.prototype.getBraceMatchingAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getBraceMatchingAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    var textRanges = _this.languageService.getBraceMatchingAtPosition(fileName, position);
                    return textRanges;
                });
            };

            LanguageServiceShim.prototype.getIndentationAtPosition = function (fileName, position, options) {
                var _this = this;
                return this.forwardJSONCall("getIndentationAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    var localOptions = JSON.parse(options);
                    var columnOffset = _this.languageService.getIndentationAtPosition(fileName, position, localOptions);
                    return { value: columnOffset };
                });
            };

            LanguageServiceShim.prototype.getReferencesAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getReferencesAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    return _this.languageService.getReferencesAtPosition(fileName, position);
                });
            };

            LanguageServiceShim.prototype.getOccurrencesAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getOccurrencesAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    return _this.languageService.getOccurrencesAtPosition(fileName, position);
                });
            };

            LanguageServiceShim.prototype.getImplementorsAtPosition = function (fileName, position) {
                var _this = this;
                return this.forwardJSONCall("getImplementorsAtPosition(\"" + fileName + "\", " + position + ")", function () {
                    return _this.languageService.getImplementorsAtPosition(fileName, position);
                });
            };

            LanguageServiceShim.prototype.getCompletionsAtPosition = function (fileName, position, isMemberCompletion) {
                var _this = this;
                return this.forwardJSONCall("getCompletionsAtPosition(\"" + fileName + "\", " + position + ", " + isMemberCompletion + ")", function () {
                    var completion = _this.languageService.getCompletionsAtPosition(fileName, position, isMemberCompletion);
                    return completion;
                });
            };

            LanguageServiceShim.prototype.getCompletionEntryDetails = function (fileName, position, entryName) {
                var _this = this;
                return this.forwardJSONCall("getCompletionEntryDetails(\"" + fileName + "\", " + position + ", " + entryName + ")", function () {
                    var details = _this.languageService.getCompletionEntryDetails(fileName, position, entryName);
                    return details;
                });
            };

            LanguageServiceShim.prototype.getFormattingEditsForRange = function (fileName, minChar, limChar, options) {
                var _this = this;
                return this.forwardJSONCall("getFormattingEditsForRange(\"" + fileName + "\", " + minChar + ", " + limChar + ")", function () {
                    var localOptions = JSON.parse(options);
                    var edits = _this.languageService.getFormattingEditsForRange(fileName, minChar, limChar, localOptions);
                    return edits;
                });
            };

            LanguageServiceShim.prototype.getFormattingEditsForDocument = function (fileName, minChar, limChar, options) {
                var _this = this;
                return this.forwardJSONCall("getFormattingEditsForDocument(\"" + fileName + "\", " + minChar + ", " + limChar + ")", function () {
                    var localOptions = JSON.parse(options);
                    var edits = _this.languageService.getFormattingEditsForDocument(fileName, minChar, limChar, localOptions);
                    return edits;
                });
            };

            LanguageServiceShim.prototype.getFormattingEditsOnPaste = function (fileName, minChar, limChar, options) {
                var _this = this;
                return this.forwardJSONCall("getFormattingEditsOnPaste(\"" + fileName + "\", " + minChar + ", " + limChar + ")", function () {
                    var localOptions = JSON.parse(options);
                    var edits = _this.languageService.getFormattingEditsOnPaste(fileName, minChar, limChar, localOptions);
                    return edits;
                });
            };

            LanguageServiceShim.prototype.getFormattingEditsAfterKeystroke = function (fileName, position, key, options) {
                var _this = this;
                return this.forwardJSONCall("getFormattingEditsAfterKeystroke(\"" + fileName + "\", " + position + ", \"" + key + "\")", function () {
                    var localOptions = JSON.parse(options);
                    var edits = _this.languageService.getFormattingEditsAfterKeystroke(fileName, position, key, localOptions);
                    return edits;
                });
            };

            LanguageServiceShim.prototype.getNavigateToItems = function (searchValue) {
                var _this = this;
                return this.forwardJSONCall("getNavigateToItems(\"" + searchValue + "\")", function () {
                    var items = _this.languageService.getNavigateToItems(searchValue);
                    var result = _this._navigateToItemsToString(items);
                    return result;
                });
            };

            LanguageServiceShim.prototype.getScriptLexicalStructure = function (fileName) {
                var _this = this;
                return this.forwardJSONCall("getScriptLexicalStructure(\"" + fileName + "\")", function () {
                    var items = _this.languageService.getScriptLexicalStructure(fileName);
                    var result = _this._navigateToItemsToString(items);
                    return result;
                });
            };

            LanguageServiceShim.prototype.getOutliningRegions = function (fileName) {
                var _this = this;
                return this.forwardJSONCall("getOutliningRegions(\"" + fileName + "\")", function () {
                    var items = _this.languageService.getOutliningRegions(fileName);
                    return items;
                });
            };

            LanguageServiceShim.prototype.getEmitOutput = function (fileName) {
                var _this = this;
                return this.forwardJSONCall("getEmitOutput(\"" + fileName + "\")", function () {
                    var output = _this.languageService.getEmitOutput(fileName);
                    return output;
                });
            };

            LanguageServiceShim.prototype._navigateToItemsToString = function (items) {
                var result = [];

                for (var i = 0; i < items.length; i++) {
                    var item = items[i];

                    result.push({
                        name: item.name,
                        kind: item.kind,
                        kindModifiers: item.kindModifiers,
                        containerName: item.containerName,
                        containerKind: item.containerKind,
                        matchKind: item.matchKind,
                        fileName: item.fileName,
                        minChar: item.minChar,
                        limChar: item.limChar,
                        additionalSpans: item.additionalSpans ? item.additionalSpans.map(function (i) {
                            return { start: i.minChar, end: i.limChar };
                        }) : undefined
                    });
                }

                return result;
            };
            return LanguageServiceShim;
        })(ShimBase);
        Services.LanguageServiceShim = LanguageServiceShim;

        var ClassifierShim = (function (_super) {
            __extends(ClassifierShim, _super);
            function ClassifierShim(factory, host) {
                _super.call(this, factory);
                this.host = host;
                this.classifier = new TypeScript.Services.Classifier(this.host);
            }
            ClassifierShim.prototype.getClassificationsForLine = function (text, lexState) {
                var classification = this.classifier.getClassificationsForLine(text, lexState);
                var items = classification.entries;
                var result = "";
                for (var i = 0; i < items.length; i++) {
                    result += items[i].length + "\n";
                    result += items[i].classification + "\n";
                }
                result += classification.finalLexState;
                return result;
            };
            return ClassifierShim;
        })(ShimBase);
        Services.ClassifierShim = ClassifierShim;

        var CoreServicesShim = (function (_super) {
            __extends(CoreServicesShim, _super);
            function CoreServicesShim(factory, host) {
                _super.call(this, factory);
                this.host = host;
                this.logger = this.host.logger;
                this.services = new TypeScript.Services.CoreServices(this.host);
            }
            CoreServicesShim.prototype.forwardJSONCall = function (actionDescription, action) {
                return TypeScript.Services.forwardJSONCall(this.logger, actionDescription, action);
            };

            CoreServicesShim.prototype.getPreProcessedFileInfo = function (fileName, sourceText) {
                var _this = this;
                return this.forwardJSONCall("getPreProcessedFileInfo(\"" + fileName + "\")", function () {
                    var result = _this.services.getPreProcessedFileInfo(fileName, sourceText);
                    return result;
                });
            };

            CoreServicesShim.prototype.getDefaultCompilationSettings = function () {
                var _this = this;
                return this.forwardJSONCall("getDefaultCompilationSettings()", function () {
                    var result = _this.services.getDefaultCompilationSettings();
                    return result;
                });
            };

            CoreServicesShim.prototype.dumpMemory = function (dummy) {
                var _this = this;
                return this.forwardJSONCall("dumpMemory()", function () {
                    return _this.services.dumpMemory();
                });
            };

            CoreServicesShim.prototype.getMemoryInfo = function (dummy) {
                var _this = this;
                return this.forwardJSONCall("getMemoryInfo()", function () {
                    var result = _this.services.getMemoryInfo();
                    return result;
                });
            };
            return CoreServicesShim;
        })(ShimBase);
        Services.CoreServicesShim = CoreServicesShim;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var OutliningElementsCollector = (function (_super) {
            __extends(OutliningElementsCollector, _super);
            function OutliningElementsCollector() {
                _super.call(this, OutliningElementsCollector.MaximumDepth);
                this.inObjectLiteralExpression = false;
                this.elements = [];
            }
            OutliningElementsCollector.prototype.visitClassDeclaration = function (node) {
                this.addOutlineRange(node, node.openBraceToken, node.closeBraceToken);
                _super.prototype.visitClassDeclaration.call(this, node);
            };

            OutliningElementsCollector.prototype.visitInterfaceDeclaration = function (node) {
                this.addOutlineRange(node, node.body.openBraceToken, node.body.closeBraceToken);
                _super.prototype.visitInterfaceDeclaration.call(this, node);
            };

            OutliningElementsCollector.prototype.visitModuleDeclaration = function (node) {
                this.addOutlineRange(node, node.openBraceToken, node.closeBraceToken);
                _super.prototype.visitModuleDeclaration.call(this, node);
            };

            OutliningElementsCollector.prototype.visitEnumDeclaration = function (node) {
                this.addOutlineRange(node, node.openBraceToken, node.closeBraceToken);
                _super.prototype.visitEnumDeclaration.call(this, node);
            };

            OutliningElementsCollector.prototype.visitFunctionDeclaration = function (node) {
                this.addOutlineRange(node, node.block, node.block);
                _super.prototype.visitFunctionDeclaration.call(this, node);
            };

            OutliningElementsCollector.prototype.visitFunctionExpression = function (node) {
                this.addOutlineRange(node, node.block, node.block);
                _super.prototype.visitFunctionExpression.call(this, node);
            };

            OutliningElementsCollector.prototype.visitConstructorDeclaration = function (node) {
                this.addOutlineRange(node, node.block, node.block);
                _super.prototype.visitConstructorDeclaration.call(this, node);
            };

            OutliningElementsCollector.prototype.visitMemberFunctionDeclaration = function (node) {
                this.addOutlineRange(node, node.block, node.block);
                _super.prototype.visitMemberFunctionDeclaration.call(this, node);
            };

            OutliningElementsCollector.prototype.visitGetAccessor = function (node) {
                if (!this.inObjectLiteralExpression) {
                    this.addOutlineRange(node, node.block, node.block);
                }
                _super.prototype.visitGetAccessor.call(this, node);
            };

            OutliningElementsCollector.prototype.visitSetAccessor = function (node) {
                if (!this.inObjectLiteralExpression) {
                    this.addOutlineRange(node, node.block, node.block);
                }
                _super.prototype.visitSetAccessor.call(this, node);
            };

            OutliningElementsCollector.prototype.visitObjectLiteralExpression = function (node) {
                var savedInObjectLiteralExpression = this.inObjectLiteralExpression;
                this.inObjectLiteralExpression = true;
                _super.prototype.visitObjectLiteralExpression.call(this, node);
                this.inObjectLiteralExpression = savedInObjectLiteralExpression;
            };

            OutliningElementsCollector.prototype.addOutlineRange = function (node, startElement, endElement) {
                if (startElement && endElement && !TypeScript.isShared(startElement) && !TypeScript.isShared(endElement)) {
                    var start = TypeScript.start(startElement);
                    var end = TypeScript.end(endElement);

                    this.elements.push(TypeScript.TextSpan.fromBounds(start, end));
                }
            };

            OutliningElementsCollector.collectElements = function (node) {
                var collector = new OutliningElementsCollector();
                TypeScript.visitNodeOrToken(collector, node);
                return collector.elements;
            };
            OutliningElementsCollector.MaximumDepth = 10;
            return OutliningElementsCollector;
        })(TypeScript.DepthLimitedWalker);
        Services.OutliningElementsCollector = OutliningElementsCollector;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var BraceMatcher = (function () {
            function BraceMatcher() {
            }
            BraceMatcher.getMatchSpans = function (syntaxTree, position) {
                var result = [];

                var currentToken = TypeScript.findToken(syntaxTree.sourceUnit(), position);

                BraceMatcher.getMatchingCloseBrace(currentToken, position, result);
                BraceMatcher.getMatchingOpenBrace(currentToken, position, result);

                return result;
            };

            BraceMatcher.getMatchingCloseBrace = function (currentToken, position, result) {
                if (TypeScript.start(currentToken) === position) {
                    var closingBraceKind = BraceMatcher.getMatchingCloseBraceTokenKind(currentToken);
                    if (closingBraceKind !== null) {
                        var parentElement = currentToken.parent;
                        var currentPosition = TypeScript.fullStart(currentToken.parent);
                        for (var i = 0, n = TypeScript.childCount(parentElement); i < n; i++) {
                            var element = TypeScript.childAt(parentElement, i);
                            if (element !== null && TypeScript.fullWidth(element) > 0) {
                                if (element.kind() === closingBraceKind) {
                                    var range1 = new TypeScript.TextSpan(position, TypeScript.width(currentToken));
                                    var range2 = new TypeScript.TextSpan(currentPosition + TypeScript.leadingTriviaWidth(element), TypeScript.width(element));
                                    result.push(range1, range2);
                                    break;
                                }

                                currentPosition += TypeScript.fullWidth(element);
                            }
                        }
                    }
                }
            };

            BraceMatcher.getMatchingOpenBrace = function (currentToken, position, result) {
                if (currentToken.fullStart() === position) {
                    currentToken = TypeScript.previousToken(currentToken);
                }

                if (currentToken !== null && TypeScript.start(currentToken) === (position - 1)) {
                    var openBraceKind = BraceMatcher.getMatchingOpenBraceTokenKind(currentToken);
                    if (openBraceKind !== null) {
                        var parentElement = currentToken.parent;
                        var currentPosition = TypeScript.fullStart(currentToken.parent) + TypeScript.fullWidth(parentElement);
                        for (var i = TypeScript.childCount(parentElement) - 1; i >= 0; i--) {
                            var element = TypeScript.childAt(parentElement, i);
                            if (element !== null && TypeScript.fullWidth(element) > 0) {
                                if (element.kind() === openBraceKind) {
                                    var range1 = new TypeScript.TextSpan(position - 1, TypeScript.width(currentToken));
                                    var range2 = new TypeScript.TextSpan(currentPosition - TypeScript.lastToken(element).trailingTriviaWidth() - TypeScript.width(element), TypeScript.width(element));
                                    result.push(range1, range2);
                                    break;
                                }

                                currentPosition -= TypeScript.fullWidth(element);
                            }
                        }
                    }
                }
            };

            BraceMatcher.getMatchingCloseBraceTokenKind = function (positionedElement) {
                var element = positionedElement !== null && positionedElement;
                switch (element.kind()) {
                    case 70 /* OpenBraceToken */:
                        return 71 /* CloseBraceToken */;
                    case 72 /* OpenParenToken */:
                        return 73 /* CloseParenToken */;
                    case 74 /* OpenBracketToken */:
                        return 75 /* CloseBracketToken */;
                    case 80 /* LessThanToken */:
                        return TypeScript.SyntaxUtilities.isAngleBracket(positionedElement) ? 81 /* GreaterThanToken */ : null;
                }
                return null;
            };

            BraceMatcher.getMatchingOpenBraceTokenKind = function (positionedElement) {
                var element = positionedElement !== null && positionedElement;
                switch (element.kind()) {
                    case 71 /* CloseBraceToken */:
                        return 70 /* OpenBraceToken */;
                    case 73 /* CloseParenToken */:
                        return 72 /* OpenParenToken */;
                    case 75 /* CloseBracketToken */:
                        return 74 /* OpenBracketToken */;
                    case 81 /* GreaterThanToken */:
                        return TypeScript.SyntaxUtilities.isAngleBracket(positionedElement) ? 80 /* LessThanToken */ : null;
                }
                return null;
            };
            return BraceMatcher;
        })();
        Services.BraceMatcher = BraceMatcher;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var Indenter = (function () {
            function Indenter() {
            }
            Indenter.getIndentation = function (node, soruceText, position, editorOptions) {
                var indentation = 0;
                var currentToken = TypeScript.findToken(node, position);
                var currentNode = currentToken;

                if (currentToken.kind() === 10 /* EndOfFileToken */) {
                    currentNode = TypeScript.previousToken(currentToken);
                } else if (Indenter.belongsToBracket(soruceText, currentToken, position)) {
                    currentNode = currentToken.parent;
                }

                if (currentNode === null) {
                    return indentation;
                }

                if (currentNode.kind() === 14 /* StringLiteral */ || currentNode.kind() === 12 /* RegularExpressionLiteral */) {
                    return indentation;
                }

                var currentElement = currentNode;
                var parent = currentNode.parent;

                while (parent !== null) {
                    if (TypeScript.fullStart(parent) !== TypeScript.fullStart(currentNode)) {
                        if (Indenter.isInContainerNode(parent, currentElement)) {
                            indentation += editorOptions.IndentSize;
                        } else {
                            var listIndentation = Indenter.getCustomListIndentation(parent, currentElement);
                            if (listIndentation !== -1) {
                                return indentation + listIndentation;
                            }
                        }
                    }
                    currentNode = parent;
                    currentElement = parent;
                    parent = parent.parent;
                }

                return indentation;
            };

            Indenter.belongsToBracket = function (sourceText, token, position) {
                switch (token.kind()) {
                    case 70 /* OpenBraceToken */:
                    case 71 /* CloseBraceToken */:
                    case 72 /* OpenParenToken */:
                    case 73 /* CloseParenToken */:
                    case 74 /* OpenBracketToken */:
                    case 75 /* CloseBracketToken */:
                        if (position < TypeScript.start(token)) {
                            var text = sourceText.getText(position, TypeScript.start(token));
                            for (var i = 0; i < text.length; i++) {
                                if (TypeScript.CharacterInfo.isLineTerminator(text.charCodeAt(i))) {
                                    return false;
                                }
                            }
                        }
                        return true;
                }
                return false;
            };

            Indenter.isInContainerNode = function (parent, element) {
                switch (parent.kind()) {
                    case 132 /* ClassDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 133 /* EnumDeclaration */:
                    case 134 /* ImportDeclaration */:
                    case 147 /* Block */:
                    case 152 /* SwitchStatement */:
                    case 234 /* CaseSwitchClause */:
                    case 235 /* DefaultSwitchClause */:
                        return true;

                    case 122 /* ObjectType */:
                        return true;

                    case 129 /* InterfaceDeclaration */:
                        return element.kind() !== 122 /* ObjectType */;

                    case 130 /* FunctionDeclaration */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                    case 223 /* FunctionExpression */:
                    case 237 /* CatchClause */:
                    case 238 /* FinallyClause */:
                    case 130 /* FunctionDeclaration */:
                    case 138 /* ConstructorDeclaration */:
                    case 155 /* ForStatement */:
                    case 156 /* ForInStatement */:
                    case 159 /* WhileStatement */:
                    case 162 /* DoStatement */:
                    case 164 /* WithStatement */:
                    case 148 /* IfStatement */:
                    case 236 /* ElseClause */:
                        return element.kind() !== 147 /* Block */;

                    case 160 /* TryStatement */:
                        return false;
                    default:
                        return TypeScript.isNode(parent) && TypeScript.SyntaxUtilities.isStatement(parent);
                }
            };

            Indenter.getCustomListIndentation = function (list, element) {
                switch (list.kind()) {
                    case 2 /* SeparatedList */:
                        for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                            var child = TypeScript.childAt(list, i);
                            if (child !== null && child === element)
                                return Indenter.getListItemIndentation(list, i - 1);
                        }
                        break;

                    case 227 /* ArgumentList */:
                        var argumentList = list;
                        var _arguments = argumentList.arguments;
                        if (_arguments !== null && argumentList.closeParenToken === element) {
                            return Indenter.getListItemIndentation(_arguments, TypeScript.childCount(_arguments) - 1);
                        }
                        break;

                    case 228 /* ParameterList */:
                        var parameterList = list;
                        var parameters = parameterList.parameters;
                        if (parameters !== null && parameterList.closeParenToken === element) {
                            return Indenter.getListItemIndentation(parameters, TypeScript.childCount(parameters) - 1);
                        }
                        break;

                    case 229 /* TypeArgumentList */:
                        var typeArgumentList = list;
                        var typeArguments = typeArgumentList.typeArguments;
                        if (typeArguments !== null && typeArgumentList.greaterThanToken === element) {
                            return Indenter.getListItemIndentation(typeArguments, TypeScript.childCount(typeArguments) - 1);
                        }
                        break;

                    case 230 /* TypeParameterList */:
                        var typeParameterList = list;
                        var typeParameters = typeParameterList.typeParameters;
                        if (typeParameters !== null && typeParameterList.greaterThanToken === element) {
                            return Indenter.getListItemIndentation(typeParameters, TypeScript.childCount(typeParameters) - 1);
                        }
                        break;
                }
                return -1;
            };

            Indenter.getListItemIndentation = function (list, elementIndex) {
                for (var i = elementIndex; i > 0; i--) {
                    var child = TypeScript.childAt(list, i);
                    var previousChild = TypeScript.childAt(list, i - 1);
                    if ((child !== null && TypeScript.firstToken(child).leadingTrivia().hasNewLine()) || (previousChild !== null && TypeScript.lastToken(previousChild).trailingTrivia().hasNewLine())) {
                        return TypeScript.leadingTriviaWidth(child);
                    }
                }
                return -1;
            };
            return Indenter;
        })();
        Services.Indenter = Indenter;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        (function (Breakpoints) {
            function createBreakpointSpanInfo(parentElement) {
                var childElements = [];
                for (var _i = 0; _i < (arguments.length - 1); _i++) {
                    childElements[_i] = arguments[_i + 1];
                }
                if (!parentElement) {
                    return null;
                }

                if (childElements.length == 0) {
                    return new Services.SpanInfo(TypeScript.start(parentElement), TypeScript.end(parentElement));
                }

                var start;
                var end;
                for (var i = 0; i < childElements.length; i++) {
                    var element = childElements[i];
                    if (element && !TypeScript.isShared(element)) {
                        if (start == undefined) {
                            start = TypeScript.start(element);
                        }
                        end = TypeScript.end(element);
                    }
                }

                return new Services.SpanInfo(start, end);
            }

            function createBreakpointSpanInfoWithLimChar(startElement, limChar) {
                return new Services.SpanInfo(TypeScript.start(startElement), limChar);
            }

            var BreakpointResolver = (function () {
                function BreakpointResolver(posLine, lineMap) {
                    this.posLine = posLine;
                    this.lineMap = lineMap;
                }
                BreakpointResolver.prototype.breakpointSpanOfToken = function (positionedToken) {
                    switch (positionedToken.kind()) {
                        case 70 /* OpenBraceToken */:
                            return this.breakpointSpanOfOpenBrace(positionedToken);

                        case 71 /* CloseBraceToken */:
                            return this.breakpointSpanOfCloseBrace(positionedToken);

                        case 79 /* CommaToken */:
                            return this.breakpointSpanOfComma(positionedToken);

                        case 78 /* SemicolonToken */:
                        case 10 /* EndOfFileToken */:
                            return this.breakpointSpanIfStartsOnSameLine(TypeScript.previousToken(positionedToken));

                        case 73 /* CloseParenToken */:
                            return this.breakpointSpanOfCloseParen(positionedToken);

                        case 22 /* DoKeyword */:
                            var parentElement = positionedToken.parent;
                            if (parentElement && parentElement.kind() == 162 /* DoStatement */) {
                                return this.breakpointSpanIfStartsOnSameLine(TypeScript.nextToken(positionedToken));
                            }
                            break;
                    }

                    return this.breakpointSpanOfContainingNode(positionedToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfOpenBrace = function (openBraceToken) {
                    var container = TypeScript.Syntax.containingNode(openBraceToken);
                    if (container) {
                        var originalContainer = container;
                        if (container && container.kind() == 147 /* Block */) {
                            container = TypeScript.Syntax.containingNode(container);
                            if (!container) {
                                container = originalContainer;
                            }
                        }

                        switch (container.kind()) {
                            case 147 /* Block */:
                                if (!this.canHaveBreakpointInBlock(container)) {
                                    return null;
                                }
                                return this.breakpointSpanOfFirstStatementInBlock(container);
                                break;

                            case 131 /* ModuleDeclaration */:
                            case 132 /* ClassDeclaration */:
                            case 130 /* FunctionDeclaration */:
                            case 138 /* ConstructorDeclaration */:
                            case 136 /* MemberFunctionDeclaration */:
                            case 140 /* GetAccessor */:
                            case 141 /* SetAccessor */:
                            case 223 /* FunctionExpression */:
                            case 219 /* ParenthesizedArrowFunctionExpression */:
                            case 220 /* SimpleArrowFunctionExpression */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstChildOfSyntaxList(this.getSyntaxListOfDeclarationWithElements(container));
                                } else {
                                    return this.breakpointSpanOf(container);
                                }

                            case 133 /* EnumDeclaration */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstEnumElement(container);
                                } else {
                                    return this.breakpointSpanOf(container);
                                }

                            case 148 /* IfStatement */:
                            case 156 /* ForInStatement */:
                            case 159 /* WhileStatement */:
                            case 237 /* CatchClause */:
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstStatementInBlock(originalContainer);
                                } else {
                                    return this.breakpointSpanOf(container);
                                }

                            case 162 /* DoStatement */:
                                return this.breakpointSpanOfFirstStatementInBlock(originalContainer);

                            case 155 /* ForStatement */:
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstStatementInBlock(originalContainer);
                                } else {
                                    return this.breakpointSpanOf(TypeScript.previousToken(openBraceToken));
                                }

                            case 236 /* ElseClause */:
                            case 234 /* CaseSwitchClause */:
                            case 235 /* DefaultSwitchClause */:
                            case 164 /* WithStatement */:
                            case 160 /* TryStatement */:
                            case 238 /* FinallyClause */:
                                return this.breakpointSpanOfFirstStatementInBlock(originalContainer);

                            case 152 /* SwitchStatement */:
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstStatementOfFirstCaseClause(container);
                                } else {
                                    return this.breakpointSpanOf(container);
                                }
                        }
                    }

                    return null;
                };

                BreakpointResolver.prototype.breakpointSpanOfCloseBrace = function (closeBraceToken) {
                    var container = TypeScript.Syntax.containingNode(closeBraceToken);
                    if (container) {
                        var originalContainer = container;
                        if (container.kind() == 147 /* Block */) {
                            container = TypeScript.Syntax.containingNode(container);
                            if (!container) {
                                container = originalContainer;
                            }
                        }

                        switch (container.kind()) {
                            case 147 /* Block */:
                                if (!this.canHaveBreakpointInBlock(container)) {
                                    return null;
                                }
                                return this.breakpointSpanOfLastStatementInBlock(container);
                                break;

                            case 131 /* ModuleDeclaration */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                var moduleSyntax = container;
                                if (moduleSyntax.moduleElements && moduleSyntax.moduleElements.length > 0) {
                                    return createBreakpointSpanInfo(closeBraceToken);
                                } else {
                                    return null;
                                }

                            case 132 /* ClassDeclaration */:
                            case 130 /* FunctionDeclaration */:
                            case 138 /* ConstructorDeclaration */:
                            case 136 /* MemberFunctionDeclaration */:
                            case 140 /* GetAccessor */:
                            case 141 /* SetAccessor */:
                            case 223 /* FunctionExpression */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                return createBreakpointSpanInfo(closeBraceToken);

                            case 133 /* EnumDeclaration */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                return createBreakpointSpanInfo(closeBraceToken);

                            case 148 /* IfStatement */:
                            case 236 /* ElseClause */:
                            case 156 /* ForInStatement */:
                            case 155 /* ForStatement */:
                            case 159 /* WhileStatement */:
                            case 162 /* DoStatement */:
                            case 234 /* CaseSwitchClause */:
                            case 235 /* DefaultSwitchClause */:
                            case 164 /* WithStatement */:
                            case 160 /* TryStatement */:
                            case 237 /* CatchClause */:
                            case 238 /* FinallyClause */:
                            case 219 /* ParenthesizedArrowFunctionExpression */:
                            case 220 /* SimpleArrowFunctionExpression */:
                                return this.breakpointSpanOfLastStatementInBlock(originalContainer);

                            case 152 /* SwitchStatement */:
                                return this.breakpointSpanOfLastStatementOfLastCaseClause(container);
                        }
                    }

                    return null;
                };

                BreakpointResolver.prototype.breakpointSpanOfComma = function (commaToken) {
                    var commaParent = commaToken.parent;
                    if (TypeScript.isSeparatedList(commaParent)) {
                        var grandParent = commaParent.parent;
                        if (grandParent) {
                            switch (grandParent.kind()) {
                                case 225 /* VariableDeclaration */:
                                case 133 /* EnumDeclaration */:
                                case 228 /* ParameterList */:
                                    var index = TypeScript.Syntax.childIndex(commaParent, commaToken);

                                    if (index > 0) {
                                        var child = TypeScript.childAt(commaParent, index - 1);
                                        return this.breakpointSpanOf(child);
                                    }

                                    if (grandParent.kind() == 133 /* EnumDeclaration */) {
                                        return null;
                                    }
                                    break;
                            }
                        }
                    }

                    return this.breakpointSpanOfContainingNode(commaToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfCloseParen = function (closeParenToken) {
                    var closeParenParent = closeParenToken.parent;
                    if (closeParenParent) {
                        switch (closeParenParent.kind()) {
                            case 155 /* ForStatement */:
                            case 228 /* ParameterList */:
                                return this.breakpointSpanOf(TypeScript.previousToken(closeParenToken));
                        }
                    }

                    return this.breakpointSpanOfContainingNode(closeParenToken);
                };

                BreakpointResolver.prototype.canHaveBreakpointInBlock = function (blockNode) {
                    if (!blockNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(blockNode)) {
                        return false;
                    }

                    var blockSyntax = blockNode;
                    return blockSyntax.statements && blockSyntax.statements.length != 0;
                };

                BreakpointResolver.prototype.breakpointSpanOfFirstStatementInBlock = function (blockNode) {
                    if (!blockNode) {
                        return null;
                    }

                    var blockSyntax = blockNode;
                    var statementsNode = blockSyntax.statements;
                    if (!statementsNode || statementsNode.length == 0) {
                        return null;
                    }

                    var firstStatement = TypeScript.childAt(statementsNode, 0);
                    if (firstStatement && firstStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(firstStatement)) {
                            return this.breakpointSpanOfFirstStatementInBlock(firstStatement);
                        }
                        return null;
                    } else {
                        return this.breakpointSpanOf(firstStatement);
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfLastStatementInBlock = function (blockNode) {
                    if (!blockNode) {
                        return null;
                    }

                    var blockSyntax = blockNode;
                    var statementsNode = blockSyntax.statements;
                    if (!statementsNode || statementsNode.length == 0) {
                        return null;
                    }

                    var lastStatement = TypeScript.childAt(statementsNode, statementsNode.length - 1);
                    if (lastStatement && lastStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(lastStatement)) {
                            return this.breakpointSpanOfLastStatementInBlock(lastStatement);
                        }
                        return null;
                    } else {
                        return this.breakpointSpanOf(lastStatement);
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfFirstChildOfSyntaxList = function (positionedList) {
                    if (!positionedList) {
                        return null;
                    }

                    var listSyntax = positionedList;
                    if (listSyntax.length == 0) {
                        return null;
                    }

                    var firstStatement = TypeScript.childAt(positionedList, 0);
                    if (firstStatement && firstStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(firstStatement)) {
                            return this.breakpointSpanOfFirstStatementInBlock(firstStatement);
                        }

                        return null;
                    } else {
                        return this.breakpointSpanOf(firstStatement);
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfLastChildOfSyntaxList = function (positionedList) {
                    if (!positionedList) {
                        return null;
                    }

                    var listSyntax = positionedList;
                    if (listSyntax.length == 0) {
                        return null;
                    }
                    var lastStatement = TypeScript.childAt(positionedList, 0);
                    if (lastStatement && lastStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(lastStatement)) {
                            return this.breakpointSpanOfLastStatementInBlock(lastStatement);
                        }
                        return null;
                    } else {
                        return this.breakpointSpanOf(lastStatement);
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfNode = function (positionedNode) {
                    var node = positionedNode;
                    switch (node.kind()) {
                        case 131 /* ModuleDeclaration */:
                        case 132 /* ClassDeclaration */:
                        case 130 /* FunctionDeclaration */:
                        case 138 /* ConstructorDeclaration */:
                        case 136 /* MemberFunctionDeclaration */:
                        case 140 /* GetAccessor */:
                        case 141 /* SetAccessor */:
                        case 223 /* FunctionExpression */:
                            return this.breakpointSpanOfDeclarationWithElements(positionedNode);

                        case 226 /* VariableDeclarator */:
                            return this.breakpointSpanOfVariableDeclarator(positionedNode);

                        case 225 /* VariableDeclaration */:
                            return this.breakpointSpanOfVariableDeclaration(positionedNode);

                        case 149 /* VariableStatement */:
                            return this.breakpointSpanOfVariableStatement(positionedNode);

                        case 243 /* Parameter */:
                            return this.breakpointSpanOfParameter(positionedNode);

                        case 137 /* MemberVariableDeclaration */:
                            return this.breakpointSpanOfMemberVariableDeclaration(positionedNode);

                        case 134 /* ImportDeclaration */:
                            return this.breakpointSpanOfImportDeclaration(positionedNode);

                        case 133 /* EnumDeclaration */:
                            return this.breakpointSpanOfEnumDeclaration(positionedNode);

                        case 244 /* EnumElement */:
                            return this.breakpointSpanOfEnumElement(positionedNode);

                        case 148 /* IfStatement */:
                            return this.breakpointSpanOfIfStatement(positionedNode);
                        case 236 /* ElseClause */:
                            return this.breakpointSpanOfElseClause(positionedNode);
                        case 156 /* ForInStatement */:
                            return this.breakpointSpanOfForInStatement(positionedNode);
                        case 155 /* ForStatement */:
                            return this.breakpointSpanOfForStatement(positionedNode);
                        case 159 /* WhileStatement */:
                            return this.breakpointSpanOfWhileStatement(positionedNode);
                        case 162 /* DoStatement */:
                            return this.breakpointSpanOfDoStatement(positionedNode);
                        case 152 /* SwitchStatement */:
                            return this.breakpointSpanOfSwitchStatement(positionedNode);
                        case 234 /* CaseSwitchClause */:
                            return this.breakpointSpanOfCaseSwitchClause(positionedNode);
                        case 235 /* DefaultSwitchClause */:
                            return this.breakpointSpanOfDefaultSwitchClause(positionedNode);
                        case 164 /* WithStatement */:
                            return this.breakpointSpanOfWithStatement(positionedNode);
                        case 160 /* TryStatement */:
                            return this.breakpointSpanOfTryStatement(positionedNode);
                        case 237 /* CatchClause */:
                            return this.breakpointSpanOfCatchClause(positionedNode);
                        case 238 /* FinallyClause */:
                            return this.breakpointSpanOfFinallyClause(positionedNode);

                        case 219 /* ParenthesizedArrowFunctionExpression */:
                            return this.breakpointSpanOfParenthesizedArrowFunctionExpression(positionedNode);

                        case 220 /* SimpleArrowFunctionExpression */:
                            return this.breakpointSpanOfSimpleArrowFunctionExpression(positionedNode);

                        default:
                            if (TypeScript.SyntaxUtilities.isStatement(node)) {
                                return this.breakpointSpanOfStatement(positionedNode);
                            } else {
                                return this.breakpointOfExpression(positionedNode);
                            }
                    }
                };

                BreakpointResolver.prototype.isExpressionOfArrowExpressions = function (expression) {
                    if (!expression) {
                        return false;
                    }

                    var expressionParent = expression.parent;
                    if (expressionParent) {
                        if (expressionParent.kind() == 219 /* ParenthesizedArrowFunctionExpression */) {
                            var parenthesizedArrowExpression = expressionParent;
                            var expressionOfParenthesizedArrowExpression = parenthesizedArrowExpression.expression;
                            return expressionOfParenthesizedArrowExpression == expression;
                        } else if (expressionParent.kind() == 220 /* SimpleArrowFunctionExpression */) {
                            var simpleArrowExpression = expressionParent;
                            var expressionOfSimpleArrowExpression = simpleArrowExpression.expression;
                            return expressionOfSimpleArrowExpression == expression;
                        } else if (expressionParent.kind() == 174 /* CommaExpression */) {
                            return this.isExpressionOfArrowExpressions(expressionParent);
                        }
                    }
                    return false;
                };

                BreakpointResolver.prototype.isInitializerOfForStatement = function (expressionNode) {
                    if (!expressionNode) {
                        return false;
                    }

                    var expressionParent = expressionNode.parent;
                    if (expressionParent && expressionParent.kind() == 155 /* ForStatement */) {
                        var expression = expressionNode;
                        var forStatement = expressionParent;
                        var initializer = forStatement.initializer;
                        return initializer === expression;
                    } else if (expressionParent && expressionParent.kind() == 174 /* CommaExpression */) {
                        return this.isInitializerOfForStatement(expressionParent);
                    }

                    return false;
                };

                BreakpointResolver.prototype.isConditionOfForStatement = function (expressionNode) {
                    if (!expressionNode) {
                        return false;
                    }

                    var expressionParent = expressionNode.parent;
                    if (expressionParent && expressionParent.kind() == 155 /* ForStatement */) {
                        var expression = expressionNode;
                        var forStatement = expressionParent;
                        var condition = forStatement.condition;
                        return condition === expression;
                    } else if (expressionParent && expressionParent.kind() == 174 /* CommaExpression */) {
                        return this.isConditionOfForStatement(expressionParent);
                    }

                    return false;
                };

                BreakpointResolver.prototype.isIncrememtorOfForStatement = function (expressionNode) {
                    if (!expressionNode) {
                        return false;
                    }

                    var expressionParent = expressionNode.parent;
                    if (expressionParent && expressionParent.kind() == 155 /* ForStatement */) {
                        var expression = expressionNode;
                        var forStatement = expressionParent;
                        var incrementor = forStatement.incrementor;
                        return incrementor === expression;
                    } else if (expressionParent && expressionParent.kind() == 174 /* CommaExpression */) {
                        return this.isIncrememtorOfForStatement(expressionParent);
                    }

                    return false;
                };

                BreakpointResolver.prototype.breakpointOfLeftOfCommaExpression = function (commaExpressionNode) {
                    var commaExpression = commaExpressionNode;
                    return this.breakpointSpanOf(commaExpression.left);
                };

                BreakpointResolver.prototype.breakpointOfExpression = function (expressionNode) {
                    if (this.isInitializerOfForStatement(expressionNode) || this.isConditionOfForStatement(expressionNode) || this.isIncrememtorOfForStatement(expressionNode)) {
                        if (expressionNode.kind() == 174 /* CommaExpression */) {
                            return this.breakpointOfLeftOfCommaExpression(expressionNode);
                        }
                        return createBreakpointSpanInfo(expressionNode);
                    }

                    if (this.isExpressionOfArrowExpressions(expressionNode)) {
                        if (expressionNode.kind() == 174 /* CommaExpression */) {
                            return this.breakpointOfLeftOfCommaExpression(expressionNode);
                        }
                        return createBreakpointSpanInfo(expressionNode);
                    }

                    if (expressionNode.kind() == 135 /* ExportAssignment */) {
                        var exportAssignmentSyntax = expressionNode;
                        return createBreakpointSpanInfo(expressionNode, exportAssignmentSyntax.exportKeyword, exportAssignmentSyntax.equalsToken, exportAssignmentSyntax.identifier);
                    }

                    return this.breakpointSpanOfContainingNode(expressionNode);
                };

                BreakpointResolver.prototype.breakpointSpanOfStatement = function (statementNode) {
                    var statement = statementNode;
                    if (statement.kind() == 157 /* EmptyStatement */) {
                        return null;
                    }

                    var containingNode = TypeScript.Syntax.containingNode(statementNode);
                    if (TypeScript.SyntaxUtilities.isStatement(containingNode)) {
                        var useNodeForBreakpoint = false;
                        switch (containingNode.kind()) {
                            case 131 /* ModuleDeclaration */:
                            case 132 /* ClassDeclaration */:
                            case 130 /* FunctionDeclaration */:
                            case 138 /* ConstructorDeclaration */:
                            case 136 /* MemberFunctionDeclaration */:
                            case 140 /* GetAccessor */:
                            case 141 /* SetAccessor */:
                            case 147 /* Block */:

                            case 148 /* IfStatement */:
                            case 236 /* ElseClause */:
                            case 156 /* ForInStatement */:
                            case 155 /* ForStatement */:
                            case 159 /* WhileStatement */:
                            case 162 /* DoStatement */:
                            case 152 /* SwitchStatement */:
                            case 234 /* CaseSwitchClause */:
                            case 235 /* DefaultSwitchClause */:
                            case 164 /* WithStatement */:
                            case 160 /* TryStatement */:
                            case 237 /* CatchClause */:
                            case 238 /* FinallyClause */:
                            case 147 /* Block */:
                                useNodeForBreakpoint = true;
                        }

                        if (!useNodeForBreakpoint) {
                            return this.breakpointSpanOfContainingNode(statementNode);
                        }
                    }

                    switch (statement.kind()) {
                        case 150 /* ExpressionStatement */:
                            var expressionSyntax = statement;
                            return createBreakpointSpanInfo(expressionSyntax.expression);

                        case 151 /* ReturnStatement */:
                            var returnStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, returnStatementSyntax.returnKeyword, returnStatementSyntax.expression);

                        case 158 /* ThrowStatement */:
                            var throwStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, throwStatementSyntax.throwKeyword, throwStatementSyntax.expression);

                        case 153 /* BreakStatement */:
                            var breakStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, breakStatementSyntax.breakKeyword, breakStatementSyntax.identifier);

                        case 154 /* ContinueStatement */:
                            var continueStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, continueStatementSyntax.continueKeyword, continueStatementSyntax.identifier);

                        case 163 /* DebuggerStatement */:
                            var debuggerStatementSyntax = statement;
                            return createBreakpointSpanInfo(debuggerStatementSyntax.debuggerKeyword);

                        case 161 /* LabeledStatement */:
                            var labeledStatementSyntax = statement;
                            return this.breakpointSpanOf(labeledStatementSyntax.statement);
                    }

                    return null;
                };

                BreakpointResolver.prototype.getSyntaxListOfDeclarationWithElements = function (positionedNode) {
                    var node = positionedNode;
                    var elementsList;
                    var block;

                    switch (node.kind()) {
                        case 131 /* ModuleDeclaration */:
                            elementsList = node.moduleElements;
                            break;

                        case 132 /* ClassDeclaration */:
                            elementsList = node.classElements;
                            break;

                        case 130 /* FunctionDeclaration */:
                            block = node.block;
                            break;

                        case 138 /* ConstructorDeclaration */:
                            block = node.block;
                            break;

                        case 136 /* MemberFunctionDeclaration */:
                            block = node.block;
                            break;

                        case 140 /* GetAccessor */:
                            block = node.block;
                            break;

                        case 141 /* SetAccessor */:
                            block = node.block;
                            break;

                        case 223 /* FunctionExpression */:
                            block = node.block;
                            break;

                        case 219 /* ParenthesizedArrowFunctionExpression */:
                            block = node.block;
                            break;

                        case 220 /* SimpleArrowFunctionExpression */:
                            block = node.block;
                            break;

                        default:
                            throw TypeScript.Errors.argument('positionNode', 'unknown node kind in getSyntaxListOfDeclarationWithElements');
                    }

                    var parentElement = positionedNode;
                    if (block) {
                        parentElement = block;
                        elementsList = block.statements;
                    }

                    return elementsList;
                };

                BreakpointResolver.prototype.canHaveBreakpointInDeclaration = function (positionedNode) {
                    return positionedNode && !TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(positionedNode);
                };

                BreakpointResolver.prototype.breakpointSpanOfDeclarationWithElements = function (positionedNode) {
                    if (!this.canHaveBreakpointInDeclaration(positionedNode)) {
                        return null;
                    }

                    var node = positionedNode;
                    var moduleSyntax = positionedNode;
                    if ((TypeScript.SyntaxUtilities.isModuleElement(node) && TypeScript.Syntax.containingNode(positionedNode).kind() != 120 /* SourceUnit */) || TypeScript.SyntaxUtilities.isClassElement(node) || (moduleSyntax.kind() == 131 /* ModuleDeclaration */ && moduleSyntax.name && moduleSyntax.name.kind() == 121 /* QualifiedName */)) {
                        return createBreakpointSpanInfo(positionedNode);
                    } else {
                        return this.breakpointSpanOfFirstChildOfSyntaxList(this.getSyntaxListOfDeclarationWithElements(positionedNode));
                    }
                };

                BreakpointResolver.prototype.canHaveBreakpointInVariableDeclarator = function (varDeclaratorNode) {
                    if (!varDeclaratorNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(varDeclaratorNode)) {
                        return false;
                    }

                    var varDeclaratorSyntax = varDeclaratorNode;
                    return !!varDeclaratorSyntax.equalsValueClause;
                };

                BreakpointResolver.prototype.breakpointSpanOfVariableDeclarator = function (varDeclaratorNode) {
                    if (!this.canHaveBreakpointInVariableDeclarator(varDeclaratorNode)) {
                        return null;
                    }

                    var container = TypeScript.Syntax.containingNode(varDeclaratorNode);
                    if (container && container.kind() == 225 /* VariableDeclaration */) {
                        var parentDeclaratorsList = varDeclaratorNode.parent;

                        if (parentDeclaratorsList && TypeScript.childAt(parentDeclaratorsList, 0) == varDeclaratorNode) {
                            return this.breakpointSpanOfVariableDeclaration(container);
                        }

                        if (this.canHaveBreakpointInVariableDeclarator(varDeclaratorNode)) {
                            return createBreakpointSpanInfo(varDeclaratorNode);
                        } else {
                            return null;
                        }
                    } else if (container) {
                        return this.breakpointSpanOfMemberVariableDeclaration(container);
                    }

                    return null;
                };

                BreakpointResolver.prototype.canHaveBreakpointInVariableDeclaration = function (varDeclarationNode) {
                    if (!varDeclarationNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(varDeclarationNode)) {
                        return false;
                    }

                    var varDeclarationSyntax = varDeclarationNode;
                    var containerChildren = varDeclarationSyntax.variableDeclarators;
                    if (!containerChildren || TypeScript.childCount(containerChildren) == 0) {
                        return false;
                    }

                    var child = TypeScript.childAt(containerChildren, 0);
                    if (TypeScript.isNode(child)) {
                        return this.canHaveBreakpointInVariableDeclarator(child);
                    }

                    return false;
                };

                BreakpointResolver.prototype.breakpointSpanOfVariableDeclaration = function (varDeclarationNode) {
                    if (!this.canHaveBreakpointInDeclaration(varDeclarationNode)) {
                        return null;
                    }

                    var container = TypeScript.Syntax.containingNode(varDeclarationNode);
                    var varDeclarationSyntax = varDeclarationNode;
                    var varDeclarators = varDeclarationSyntax.variableDeclarators;
                    var varDeclaratorsCount = TypeScript.childCount(varDeclarators);

                    if (container && container.kind() == 149 /* VariableStatement */) {
                        return this.breakpointSpanOfVariableStatement(container);
                    }

                    if (this.canHaveBreakpointInVariableDeclaration(varDeclarationNode)) {
                        return createBreakpointSpanInfoWithLimChar(varDeclarationNode, TypeScript.end(TypeScript.childAt(varDeclarators, 0)));
                    } else {
                        return null;
                    }
                };

                BreakpointResolver.prototype.canHaveBreakpointInVariableStatement = function (varStatementNode) {
                    if (!varStatementNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(varStatementNode)) {
                        return false;
                    }

                    var variableStatement = varStatementNode;
                    return this.canHaveBreakpointInVariableDeclaration(variableStatement.variableDeclaration);
                };

                BreakpointResolver.prototype.breakpointSpanOfVariableStatement = function (varStatementNode) {
                    if (!this.canHaveBreakpointInVariableStatement(varStatementNode)) {
                        return null;
                    }

                    var variableStatement = varStatementNode;
                    var variableDeclaration = variableStatement.variableDeclaration;
                    var varDeclarationSyntax = variableDeclaration;
                    var varDeclarators = varDeclarationSyntax.variableDeclarators;
                    return createBreakpointSpanInfoWithLimChar(varStatementNode, TypeScript.end(TypeScript.childAt(varDeclarators, 0)));
                };

                BreakpointResolver.prototype.breakpointSpanOfParameter = function (parameterNode) {
                    if (parameterNode.parent.kind() === 220 /* SimpleArrowFunctionExpression */) {
                        return this.breakpointSpanOfNode(parameterNode.parent);
                    }

                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(parameterNode)) {
                        return null;
                    }

                    var parameterSyntax = parameterNode;
                    if (parameterSyntax.dotDotDotToken || parameterSyntax.equalsValueClause || parameterSyntax.modifiers.length > 0) {
                        return createBreakpointSpanInfo(parameterNode);
                    } else {
                        return null;
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfMemberVariableDeclaration = function (memberVarDeclarationNode) {
                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(memberVarDeclarationNode)) {
                        return null;
                    }

                    var memberVariableDeclaration = memberVarDeclarationNode;
                    if (this.canHaveBreakpointInVariableDeclarator(memberVariableDeclaration.variableDeclarator)) {
                        return createBreakpointSpanInfo(memberVarDeclarationNode, memberVariableDeclaration.modifiers, memberVariableDeclaration.variableDeclarator);
                    } else {
                        return null;
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfImportDeclaration = function (importDeclarationNode) {
                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(importDeclarationNode)) {
                        return null;
                    }

                    var importSyntax = importDeclarationNode;
                    return createBreakpointSpanInfo(importDeclarationNode, importSyntax.modifiers, importSyntax.importKeyword, importSyntax.identifier, importSyntax.equalsToken, importSyntax.moduleReference);
                };

                BreakpointResolver.prototype.breakpointSpanOfEnumDeclaration = function (enumDeclarationNode) {
                    if (!this.canHaveBreakpointInDeclaration(enumDeclarationNode)) {
                        return null;
                    }

                    return createBreakpointSpanInfo(enumDeclarationNode);
                };

                BreakpointResolver.prototype.breakpointSpanOfFirstEnumElement = function (enumDeclarationNode) {
                    var enumDeclarationSyntax = enumDeclarationNode;
                    var enumElements = enumDeclarationSyntax.enumElements;
                    if (enumElements && TypeScript.childCount(enumElements)) {
                        return this.breakpointSpanOf(TypeScript.childAt(enumElements, 0));
                    }

                    return null;
                };

                BreakpointResolver.prototype.breakpointSpanOfEnumElement = function (enumElementNode) {
                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(enumElementNode)) {
                        return null;
                    }

                    return createBreakpointSpanInfo(enumElementNode);
                };

                BreakpointResolver.prototype.breakpointSpanOfIfStatement = function (ifStatementNode) {
                    var ifStatement = ifStatementNode;
                    return createBreakpointSpanInfo(ifStatementNode, ifStatement.ifKeyword, ifStatement.openParenToken, ifStatement.condition, ifStatement.closeParenToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfElseClause = function (elseClauseNode) {
                    var elseClause = elseClauseNode;
                    return this.breakpointSpanOf(elseClause.statement);
                };

                BreakpointResolver.prototype.breakpointSpanOfForInStatement = function (forInStatementNode) {
                    var forInStatement = forInStatementNode;
                    return createBreakpointSpanInfo(forInStatementNode, forInStatement.forKeyword, forInStatement.openParenToken, forInStatement.variableDeclaration, forInStatement.left, forInStatement.inKeyword, forInStatement.expression, forInStatement.closeParenToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfForStatement = function (forStatementNode) {
                    var forStatement = forStatementNode;
                    return this.breakpointSpanOf(forStatement.variableDeclaration ? forStatement.variableDeclaration : forStatement.initializer);
                };

                BreakpointResolver.prototype.breakpointSpanOfWhileStatement = function (whileStatementNode) {
                    var whileStatement = whileStatementNode;
                    return createBreakpointSpanInfo(whileStatementNode, whileStatement.whileKeyword, whileStatement.openParenToken, whileStatement.condition, whileStatement.closeParenToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfDoStatement = function (doStatementNode) {
                    var doStatement = doStatementNode;
                    return createBreakpointSpanInfo(doStatementNode, doStatement.whileKeyword, doStatement.openParenToken, doStatement.condition, doStatement.closeParenToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfSwitchStatement = function (switchStatementNode) {
                    var switchStatement = switchStatementNode;
                    return createBreakpointSpanInfo(switchStatementNode, switchStatement.switchKeyword, switchStatement.openParenToken, switchStatement.expression, switchStatement.closeParenToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfFirstStatementOfFirstCaseClause = function (switchStatementNode) {
                    var switchStatement = switchStatementNode;
                    if (switchStatement.switchClauses && switchStatement.switchClauses.length == 0) {
                        return null;
                    }

                    var switchClauses = switchStatement.switchClauses;
                    if (switchClauses.length == 0) {
                        return null;
                    }

                    var firstCaseClause = switchClauses[0];
                    var statements = firstCaseClause.statements;

                    return this.breakpointSpanOfFirstChildOfSyntaxList(statements);
                };

                BreakpointResolver.prototype.breakpointSpanOfLastStatementOfLastCaseClause = function (switchStatementNode) {
                    var switchStatement = switchStatementNode;
                    if (switchStatement.switchClauses && switchStatement.switchClauses.length == 0) {
                        return null;
                    }

                    var switchClauses = switchStatement.switchClauses;
                    if (switchClauses.length == 0) {
                        return null;
                    }

                    var lastClauseNode = switchClauses[switchClauses.length - 1];
                    var statements = lastClauseNode.statements;

                    return this.breakpointSpanOfLastChildOfSyntaxList(statements);
                };

                BreakpointResolver.prototype.breakpointSpanOfCaseSwitchClause = function (caseClauseNode) {
                    var caseSwitchClause = caseClauseNode;
                    return this.breakpointSpanOfFirstChildOfSyntaxList(caseSwitchClause.statements);
                };

                BreakpointResolver.prototype.breakpointSpanOfDefaultSwitchClause = function (defaultSwithClauseNode) {
                    var defaultSwitchClause = defaultSwithClauseNode;
                    return this.breakpointSpanOfFirstChildOfSyntaxList(defaultSwitchClause.statements);
                };

                BreakpointResolver.prototype.breakpointSpanOfWithStatement = function (withStatementNode) {
                    var withStatement = withStatementNode;
                    return this.breakpointSpanOf(withStatement.statement);
                };

                BreakpointResolver.prototype.breakpointSpanOfTryStatement = function (tryStatementNode) {
                    var tryStatement = tryStatementNode;
                    return this.breakpointSpanOfFirstStatementInBlock(tryStatement.block);
                };

                BreakpointResolver.prototype.breakpointSpanOfCatchClause = function (catchClauseNode) {
                    var catchClause = catchClauseNode;
                    return createBreakpointSpanInfo(catchClauseNode, catchClause.catchKeyword, catchClause.openParenToken, catchClause.identifier, catchClause.typeAnnotation, catchClause.closeParenToken);
                };

                BreakpointResolver.prototype.breakpointSpanOfFinallyClause = function (finallyClauseNode) {
                    var finallyClause = finallyClauseNode;
                    return this.breakpointSpanOfFirstStatementInBlock(finallyClause.block);
                };

                BreakpointResolver.prototype.breakpointSpanOfParenthesizedArrowFunctionExpression = function (arrowFunctionExpression) {
                    if (arrowFunctionExpression.block) {
                        return this.breakpointSpanOfFirstStatementInBlock(arrowFunctionExpression.block);
                    } else {
                        return this.breakpointSpanOf(arrowFunctionExpression.expression);
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfSimpleArrowFunctionExpression = function (arrowFunctionExpression) {
                    if (arrowFunctionExpression.block) {
                        return this.breakpointSpanOfFirstStatementInBlock(arrowFunctionExpression.block);
                    } else {
                        return this.breakpointSpanOf(arrowFunctionExpression.expression);
                    }
                };

                BreakpointResolver.prototype.breakpointSpanOfContainingNode = function (positionedElement) {
                    var current = positionedElement.parent;
                    while (!TypeScript.isNode(current)) {
                        current = current.parent;
                    }

                    return this.breakpointSpanOf(current);
                };

                BreakpointResolver.prototype.breakpointSpanIfStartsOnSameLine = function (positionedElement) {
                    if (positionedElement && this.posLine == this.lineMap.getLineNumberFromPosition(TypeScript.start(positionedElement))) {
                        return this.breakpointSpanOf(positionedElement);
                    }

                    return null;
                };

                BreakpointResolver.prototype.breakpointSpanOf = function (positionedElement) {
                    if (!positionedElement) {
                        return null;
                    }

                    for (var containingNode = TypeScript.Syntax.containingNode(positionedElement); containingNode != null; containingNode = TypeScript.Syntax.containingNode(containingNode)) {
                        if (containingNode.kind() == 245 /* TypeAnnotation */) {
                            return this.breakpointSpanIfStartsOnSameLine(containingNode);
                        }
                    }

                    var element = positionedElement;

                    if (TypeScript.isNode(element)) {
                        return this.breakpointSpanOfNode(positionedElement);
                    }

                    if (TypeScript.isToken(element)) {
                        return this.breakpointSpanOfToken(positionedElement);
                    }

                    return this.breakpointSpanOfContainingNode(positionedElement);
                };
                return BreakpointResolver;
            })();

            function getBreakpointLocation(syntaxTree, askedPos) {
                if (TypeScript.isDTSFile(syntaxTree.fileName())) {
                    return null;
                }

                var sourceUnit = syntaxTree.sourceUnit();
                var positionedToken = TypeScript.findToken(sourceUnit, askedPos);

                var lineMap = syntaxTree.lineMap();
                var posLine = lineMap.getLineNumberFromPosition(askedPos);
                var tokenStartLine = lineMap.getLineNumberFromPosition(TypeScript.start(positionedToken));
                if (posLine < tokenStartLine) {
                    return null;
                }

                var breakpointResolver = new BreakpointResolver(posLine, lineMap);
                return breakpointResolver.breakpointSpanOf(positionedToken);
            }
            Breakpoints.getBreakpointLocation = getBreakpointLocation;
        })(Services.Breakpoints || (Services.Breakpoints = {}));
        var Breakpoints = Services.Breakpoints;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Services) {
        var GetScriptLexicalStructureWalker = (function (_super) {
            __extends(GetScriptLexicalStructureWalker, _super);
            function GetScriptLexicalStructureWalker(fileName) {
                _super.call(this);
                this.fileName = fileName;
                this.nameStack = [];
                this.kindStack = [];
                this.parentScopes = [];
                this.currentScope = this.createScope();
            }
            GetScriptLexicalStructureWalker.prototype.createScope = function () {
                return {
                    items: TypeScript.createIntrinsicsObject(),
                    childScopes: TypeScript.createIntrinsicsObject(),
                    childScopeNames: [],
                    itemNames: []
                };
            };

            GetScriptLexicalStructureWalker.prototype.pushNewContainerScope = function (containerName, kind) {
                TypeScript.Debug.assert(containerName, "No scope name provided");

                var key = kind + "+" + containerName;
                this.nameStack.push(containerName);
                this.kindStack.push(kind);

                var parentScope = this.currentScope;
                this.parentScopes.push(parentScope);

                var scope = parentScope.childScopes[key];
                if (!scope) {
                    scope = this.createScope();
                    parentScope.childScopes[key] = scope;
                    parentScope.childScopeNames.push(key);
                }

                this.currentScope = scope;
                return parentScope;
            };

            GetScriptLexicalStructureWalker.prototype.popScope = function () {
                TypeScript.Debug.assert(this.parentScopes.length > 0, "No parent scopes to return to");
                this.currentScope = this.parentScopes.pop();
                this.kindStack.pop();
                this.nameStack.pop();
            };

            GetScriptLexicalStructureWalker.prototype.collectItems = function (items, scope) {
                var _this = this;
                if (typeof scope === "undefined") { scope = this.currentScope; }
                scope.itemNames.forEach(function (item) {
                    items.push(scope.items[item]);
                });

                scope.childScopeNames.forEach(function (childScope) {
                    _this.collectItems(items, scope.childScopes[childScope]);
                });
            };

            GetScriptLexicalStructureWalker.getListsOfAllScriptLexicalStructure = function (items, fileName, unit) {
                var visitor = new GetScriptLexicalStructureWalker(fileName);
                TypeScript.visitNodeOrToken(visitor, unit);
                visitor.collectItems(items);
            };

            GetScriptLexicalStructureWalker.prototype.createItem = function (node, modifiers, kind, name) {
                var key = kind + "+" + name;

                if (this.currentScope.items[key] !== undefined) {
                    this.addAdditionalSpan(node, key);
                    return;
                }

                var item = new Services.NavigateToItem();
                item.name = name;
                item.kind = kind;
                item.matchKind = Services.MatchKind.exact;
                item.fileName = this.fileName;
                item.kindModifiers = this.getKindModifiers(modifiers);
                item.minChar = TypeScript.start(node);
                item.limChar = TypeScript.end(node);
                item.containerName = this.nameStack.join(".");
                item.containerKind = this.kindStack.length === 0 ? "" : TypeScript.ArrayUtilities.last(this.kindStack);

                this.currentScope.items[key] = item;
                this.currentScope.itemNames.push(key);
            };

            GetScriptLexicalStructureWalker.prototype.addAdditionalSpan = function (node, key) {
                var item = this.currentScope.items[key];
                TypeScript.Debug.assert(item !== undefined);

                var start = TypeScript.start(node);
                var span = new Services.SpanInfo(start, start + TypeScript.width(node));

                if (item.additionalSpans) {
                    item.additionalSpans.push(span);
                } else {
                    item.additionalSpans = [span];
                }
            };

            GetScriptLexicalStructureWalker.prototype.getKindModifiers = function (modifiers) {
                var result = [];

                for (var i = 0, n = modifiers.length; i < n; i++) {
                    result.push(modifiers[i].text());
                }

                return result.length > 0 ? result.join(',') : Services.ScriptElementKindModifier.none;
            };

            GetScriptLexicalStructureWalker.prototype.visitModuleDeclaration = function (node) {
                var names = this.getModuleNames(node);
                this.visitModuleDeclarationWorker(node, names, 0);
            };

            GetScriptLexicalStructureWalker.prototype.visitModuleDeclarationWorker = function (node, names, nameIndex) {
                if (nameIndex === names.length) {
                    _super.prototype.visitModuleDeclaration.call(this, node);
                } else {
                    var name = names[nameIndex];
                    var kind = Services.ScriptElementKind.moduleElement;

                    this.createItem(node, node.modifiers, kind, name);

                    this.pushNewContainerScope(name, kind);

                    this.visitModuleDeclarationWorker(node, names, nameIndex + 1);

                    this.popScope();
                }
            };

            GetScriptLexicalStructureWalker.prototype.getModuleNames = function (node) {
                var result = [];

                if (node.stringLiteral) {
                    result.push(node.stringLiteral.text());
                } else {
                    this.getModuleNamesHelper(node.name, result);
                }

                return result;
            };

            GetScriptLexicalStructureWalker.prototype.getModuleNamesHelper = function (name, result) {
                if (name.kind() === 121 /* QualifiedName */) {
                    var qualifiedName = name;
                    this.getModuleNamesHelper(qualifiedName.left, result);
                    result.push(qualifiedName.right.text());
                } else {
                    result.push(name.text());
                }
            };

            GetScriptLexicalStructureWalker.prototype.visitClassDeclaration = function (node) {
                var name = node.identifier.text();
                var kind = Services.ScriptElementKind.classElement;

                this.createItem(node, node.modifiers, kind, name);

                this.pushNewContainerScope(name, kind);

                _super.prototype.visitClassDeclaration.call(this, node);

                this.popScope();
            };

            GetScriptLexicalStructureWalker.prototype.visitInterfaceDeclaration = function (node) {
                var name = node.identifier.text();
                var kind = Services.ScriptElementKind.interfaceElement;

                this.createItem(node, node.modifiers, kind, name);

                this.pushNewContainerScope(name, kind);

                _super.prototype.visitInterfaceDeclaration.call(this, node);

                this.popScope();
            };

            GetScriptLexicalStructureWalker.prototype.visitObjectType = function (node) {
                if (node.parent.kind() === 129 /* InterfaceDeclaration */) {
                    _super.prototype.visitObjectType.call(this, node);
                }
            };

            GetScriptLexicalStructureWalker.prototype.visitEnumDeclaration = function (node) {
                var name = node.identifier.text();
                var kind = Services.ScriptElementKind.enumElement;

                this.createItem(node, node.modifiers, kind, name);

                this.pushNewContainerScope(name, kind);

                _super.prototype.visitEnumDeclaration.call(this, node);

                this.popScope();
            };

            GetScriptLexicalStructureWalker.prototype.visitConstructorDeclaration = function (node) {
                this.createItem(node, TypeScript.Syntax.emptyList(), Services.ScriptElementKind.constructorImplementationElement, "constructor");

                var parameters = node.callSignature.parameterList.parameters;
                if (parameters) {
                    for (var i = 0, n = parameters.length; i < n; i++) {
                        var parameter = parameters[i];

                        TypeScript.Debug.assert(parameter.kind() === 243 /* Parameter */);

                        if (TypeScript.SyntaxUtilities.containsToken(parameter.modifiers, 57 /* PublicKeyword */) || TypeScript.SyntaxUtilities.containsToken(parameter.modifiers, 55 /* PrivateKeyword */)) {
                            this.createItem(node, parameter.modifiers, Services.ScriptElementKind.memberVariableElement, parameter.identifier.text());
                        }
                    }
                }
            };

            GetScriptLexicalStructureWalker.prototype.visitMemberFunctionDeclaration = function (node) {
                this.createItem(node, node.modifiers, Services.ScriptElementKind.memberFunctionElement, node.propertyName.text());
            };

            GetScriptLexicalStructureWalker.prototype.visitGetAccessor = function (node) {
                this.createItem(node, node.modifiers, Services.ScriptElementKind.memberGetAccessorElement, node.propertyName.text());
            };

            GetScriptLexicalStructureWalker.prototype.visitSetAccessor = function (node) {
                this.createItem(node, node.modifiers, Services.ScriptElementKind.memberSetAccessorElement, node.propertyName.text());
            };

            GetScriptLexicalStructureWalker.prototype.visitVariableDeclarator = function (node) {
                var modifiers = node.parent.kind() === 137 /* MemberVariableDeclaration */ ? node.parent.modifiers : TypeScript.Syntax.emptyList();
                var kind = node.parent.kind() === 137 /* MemberVariableDeclaration */ ? Services.ScriptElementKind.memberVariableElement : Services.ScriptElementKind.variableElement;
                this.createItem(node, modifiers, kind, node.propertyName.text());
            };

            GetScriptLexicalStructureWalker.prototype.visitIndexSignature = function (node) {
                this.createItem(node, TypeScript.Syntax.emptyList(), Services.ScriptElementKind.indexSignatureElement, "[]");
            };

            GetScriptLexicalStructureWalker.prototype.visitEnumElement = function (node) {
                this.createItem(node, TypeScript.Syntax.emptyList(), Services.ScriptElementKind.memberVariableElement, node.propertyName.text());
            };

            GetScriptLexicalStructureWalker.prototype.visitCallSignature = function (node) {
                this.createItem(node, TypeScript.Syntax.emptyList(), Services.ScriptElementKind.callSignatureElement, "()");
            };

            GetScriptLexicalStructureWalker.prototype.visitConstructSignature = function (node) {
                this.createItem(node, TypeScript.Syntax.emptyList(), Services.ScriptElementKind.constructSignatureElement, "new()");
            };

            GetScriptLexicalStructureWalker.prototype.visitMethodSignature = function (node) {
                this.createItem(node, TypeScript.Syntax.emptyList(), Services.ScriptElementKind.memberFunctionElement, node.propertyName.text());
            };

            GetScriptLexicalStructureWalker.prototype.visitPropertySignature = function (node) {
                this.createItem(node, TypeScript.Syntax.emptyList(), Services.ScriptElementKind.memberVariableElement, node.propertyName.text());
            };

            GetScriptLexicalStructureWalker.prototype.visitFunctionDeclaration = function (node) {
                if (TypeScript.width(node.identifier) > 0) {
                    this.createItem(node, node.modifiers, Services.ScriptElementKind.functionElement, node.identifier.text());
                }
            };

            GetScriptLexicalStructureWalker.prototype.visitBlock = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitIfStatement = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitExpressionStatement = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitThrowStatement = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitReturnStatement = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitSwitchStatement = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitWithStatement = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitTryStatement = function (node) {
            };

            GetScriptLexicalStructureWalker.prototype.visitLabeledStatement = function (node) {
            };
            return GetScriptLexicalStructureWalker;
        })(TypeScript.SyntaxWalker);
        Services.GetScriptLexicalStructureWalker = GetScriptLexicalStructureWalker;
    })(TypeScript.Services || (TypeScript.Services = {}));
    var Services = TypeScript.Services;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxElementsCollector = (function (_super) {
        __extends(SyntaxElementsCollector, _super);
        function SyntaxElementsCollector() {
            _super.apply(this, arguments);
            this.elements = [];
        }
        SyntaxElementsCollector.prototype.visitNode = function (node) {
            this.elements.push(node);
            _super.prototype.visitNode.call(this, node);
        };

        SyntaxElementsCollector.prototype.visitToken = function (token) {
            this.elements.push(token);
        };

        SyntaxElementsCollector.prototype.visitSyntaxList = function (list) {
            if (!TypeScript.isShared(list)) {
                this.elements.push(list);
            }
        };

        SyntaxElementsCollector.prototype.visitSeparatedSyntaxList = function (list) {
            if (!TypeScript.isShared(list)) {
                this.elements.push(list);
            }
        };

        SyntaxElementsCollector.collectElements = function (node) {
            var collector = new SyntaxElementsCollector();
            TypeScript.visitNodeOrToken(collector, node);
            return collector.elements;
        };
        return SyntaxElementsCollector;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxElementsCollector = SyntaxElementsCollector;

    function withChange(text, start, length, newText) {
        var contents = text.substr(0, text.length());
        var newContents = contents.substr(0, start) + newText + contents.substring(start + length);

        return { text: TypeScript.SimpleText.fromString(newContents), textChangeRange: new TypeScript.TextChangeRange(new TypeScript.TextSpan(start, length), newText.length) };
    }

    function withInsert(text, start, newText) {
        return withChange(text, start, 0, newText);
    }

    function withDelete(text, start, length) {
        return withChange(text, start, length, "");
    }

    function compareTrees(oldText, newText, textChangeRange, reusedElements) {
        if (typeof reusedElements === "undefined") { reusedElements = -1; }
        var oldTree = TypeScript.Parser.parse("", oldText, 1 /* EcmaScript5 */, false);
        TypeScript.visitNodeOrToken(new PositionValidatingWalker(), oldTree.sourceUnit());

        var newTree = TypeScript.Parser.parse("", newText, 1 /* EcmaScript5 */, false);
        TypeScript.visitNodeOrToken(new PositionValidatingWalker(), newTree.sourceUnit());

        var incrementalNewTree = TypeScript.IncrementalParser.parse(oldTree, textChangeRange, newText);
        TypeScript.visitNodeOrToken(new PositionValidatingWalker(), incrementalNewTree.sourceUnit());

        TypeScript.Debug.assert(TypeScript.treeStructuralEquals(newTree, incrementalNewTree, true));

        TypeScript.Debug.assert(IncrementalParserTests.reusedElements(oldTree.sourceUnit(), newTree.sourceUnit()) === 0);

        if (reusedElements !== -1) {
            var actualReusedCount = IncrementalParserTests.reusedElements(oldTree.sourceUnit(), incrementalNewTree.sourceUnit());
            TypeScript.Debug.assert(actualReusedCount === reusedElements, actualReusedCount + " !== " + reusedElements);
        }
    }

    var IncrementalParserTests = (function () {
        function IncrementalParserTests() {
        }
        IncrementalParserTests.runAllTests = function () {
            for (var name in IncrementalParserTests) {
                if (IncrementalParserTests.hasOwnProperty(name) && TypeScript.StringUtilities.startsWith(name, "test")) {
                    var o = IncrementalParserTests;
                    o[name]();
                }
            }
        };

        IncrementalParserTests.reusedElements = function (oldNode, newNode) {
            var allOldElements = SyntaxElementsCollector.collectElements(oldNode);
            var allNewElements = SyntaxElementsCollector.collectElements(newNode);

            return TypeScript.ArrayUtilities.where(allOldElements, function (v) {
                return TypeScript.ArrayUtilities.contains(allNewElements, v);
            }).length;
        };

        IncrementalParserTests.testIncremental1 = function () {
            var source = "class C {\r\n";
            source += "    public foo1() { }\r\n";
            source += "    public foo2() {\r\n";
            source += "        return 1;\r\n";
            source += "    }\r\n";
            source += "    public foo3() { }\r\n";
            source += "}";

            var semicolonIndex = source.indexOf(";");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, semicolonIndex, " + 1");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 31);
        };

        IncrementalParserTests.testIncremental2 = function () {
            var source = "class C {\r\n";
            source += "    public foo1() { }\r\n";
            source += "    public foo2() {\r\n";
            source += "        return 1 + 1;\r\n";
            source += "    }\r\n";
            source += "    public foo3() { }\r\n";
            source += "}";

            var index = source.indexOf("+ 1");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, index, 3);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 31);
        };

        IncrementalParserTests.testIncrementalRegex1 = function () {
            var source = "class C { public foo1() { /; } public foo2() { return 1;} public foo3() { } }";

            var semicolonIndex = source.indexOf(";}");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, semicolonIndex, "/");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 21);
        };

        IncrementalParserTests.testIncrementalRegex2 = function () {
            var source = "class C { public foo1() { ; } public foo2() { return 1/;} public foo3() { } }";

            var semicolonIndex = source.indexOf(";");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, semicolonIndex, "/");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 19);
        };

        IncrementalParserTests.testIncrementalComment1 = function () {
            var source = "class C { public foo1() { /; } public foo2() { return 1; } public foo3() { } }";

            var semicolonIndex = source.indexOf(";");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, semicolonIndex, "/");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 7);
        };

        IncrementalParserTests.testIncrementalComment2 = function () {
            var source = "class C { public foo1() { /; } public foo2() { return 1; } public foo3() { } }";

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, 0, "//");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 0);
        };

        IncrementalParserTests.testIncrementalComment3 = function () {
            var source = "//class C { public foo1() { /; } public foo2() { return 1; } public foo3() { } }";

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, 0, 2);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 0);
        };

        IncrementalParserTests.testIncrementalComment4 = function () {
            var source = "class C { public foo1() { /; } public foo2() { */ return 1; } public foo3() { } }";

            var index = source.indexOf(";");
            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index, "*");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 22);
        };

        IncrementalParserTests.testParameter1 = function () {
            var source = "class C {\r\n";
            source += "    public foo2(a, b, c, d) {\r\n";
            source += "        return 1;\r\n";
            source += "    }\r\n";
            source += "}";

            var semicolonIndex = source.indexOf(";");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, semicolonIndex, " + 1");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 22);
        };

        IncrementalParserTests.testTypeMember1 = function () {
            var source = "interface I { a: number; b: string; (c): d; new (e): f; g(): h }";

            var index = source.indexOf(": string");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index, "?");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 43);
        };

        IncrementalParserTests.testEnumElement1 = function () {
            var source = "enum E { a = 1, b = 1 << 1, c = 3, e = 4, f = 5, g = 7, h = 8, i = 9, j = 10 }";

            var index = source.indexOf("<<");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withChange(oldText, index, 2, "+");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 54);
        };

        IncrementalParserTests.testStrictMode1 = function () {
            var source = "foo1();\r\nfoo1();\r\nfoo1();\r\yield();";

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, 0, "'strict';\r\n");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 25);
        };

        IncrementalParserTests.testStrictMode2 = function () {
            var source = "foo1();\r\nfoo1();\r\nfoo1();\r\yield();";

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, 0, "'use strict';\r\n");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 14);
        };

        IncrementalParserTests.testStrictMode3 = function () {
            var source = "'strict';\r\nfoo1();\r\nfoo1();\r\nfoo1();\r\nyield();";

            var index = source.indexOf('f');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, 0, index);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 24);
        };

        IncrementalParserTests.testStrictMode4 = function () {
            var source = "'use strict';\r\nfoo1();\r\nfoo1();\r\nfoo1();\r\nyield();";

            var index = source.indexOf('f');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, 0, index);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 12);
        };

        IncrementalParserTests.testIncremental5 = function () {
            var source = "'use blahhh';\r\nfoo1();\r\nfoo2();\r\nfoo3();\r\nfoo4();\r\nfoo4();\r\nfoo6();\r\nfoo7();\r\nfoo8();\r\nfoo9();\r\n";

            var index = source.indexOf('b');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withChange(oldText, index, 6, "strict");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 37);
        };

        IncrementalParserTests.testIncremental6 = function () {
            var source = "'use strict';\r\nfoo1();\r\nfoo2();\r\nfoo3();\r\nfoo4();\r\nfoo4();\r\nfoo6();\r\nfoo7();\r\nfoo8();\r\nfoo9();\r\n";

            var index = source.indexOf('s');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withChange(oldText, index, 6, "blahhh");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 37);
        };

        IncrementalParserTests.testDelete1 = function () {
            var source = "'use blahhh';\r\nfoo1();\r\nfoo2();\r\nfoo3();\r\nfoo4();\r\nfoo4();\r\nfoo6();\r\nfoo7();\r\nfoo8();\r\nfoo9();\r\n";

            var index = source.indexOf('f');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, 0, index);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 59);
        };

        IncrementalParserTests.testIncremental3 = function () {
            var source = "var v = (a, b, c, d, e)";

            var index = source.indexOf('a');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index + 1, ":");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testIncremental4 = function () {
            var source = "var v = (a:, b, c, d, e)";

            var index = source.indexOf(':');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, index, 1);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testIncremental7 = function () {
            var source = "var v = F<b>e";

            var index = source.indexOf('b');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index + 1, ",x");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testIncremental8 = function () {
            var source = "var v = F<a,b>e";

            var index = source.indexOf('b');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index + 1, ",x");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testIncremental9 = function () {
            var source = "var v = F<a,b,c>e";

            var index = source.indexOf('b');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index + 1, ",x");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testIncremental10 = function () {
            var source = "var v = F<a,b,c,d>e";

            var index = source.indexOf('b');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index + 1, ",x");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testIncremental11 = function () {
            var source = "interface IFoo<T> { }\r\ninterface Array<T> extends IFoo<T> { }";

            var index = source.indexOf('extends');
            var repeat = "extends IFoo<T>".length;

            for (var i = 0; i < repeat; i++) {
                var oldText = TypeScript.SimpleText.fromString(source);
                var newTextAndChange = withDelete(oldText, index, 1);
                compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);

                source = newTextAndChange.text.substr(0, newTextAndChange.text.length());
            }
        };

        IncrementalParserTests.testGenerics1 = function () {
            var source = "var v = <T>(a);";

            var index = source.indexOf(';');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index, " => 1");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 4);
        };

        IncrementalParserTests.testGenerics2 = function () {
            var source = "var v = <T>(a) => 1;";

            var index = source.indexOf(' =>');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, index, " => 1".length);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 6);
        };

        IncrementalParserTests.testGenerics3 = function () {
            var source = "var v = 1 >> = 2";

            var index = source.indexOf('>> =');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, index + 2, 1);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testGenerics4 = function () {
            var source = "var v = 1 >>= 2";

            var index = source.indexOf('>>=');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index + 2, " ");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 3);
        };

        IncrementalParserTests.testGenerics5 = function () {
            var source = "var v = T>>(2)";

            var index = source.indexOf('T');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index, "Foo<Bar<");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 4);
        };

        IncrementalParserTests.testGenerics6 = function () {
            var source = "var v = Foo<Bar<T>>(2)";

            var index = source.indexOf('Foo<Bar<');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, index, "Foo<Bar<".length);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 5);
        };

        IncrementalParserTests.testGenerics7 = function () {
            var source = "var v = T>>=2;";

            var index = source.indexOf('=');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withChange(oldText, index, "= ".length, ": Foo<Bar<");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 3);
        };

        IncrementalParserTests.testGenerics8 = function () {
            var source = "var v : Foo<Bar<T>>=2;";

            var index = source.indexOf(':');

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withChange(oldText, index, ": Foo<Bar<".length, "= ");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 3);
        };

        IncrementalParserTests.testParenthesizedExpressionToLambda = function () {
            var source = "var v = (a, b) = c";

            var index = source.indexOf("= c") + 1;

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index, ">");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testLambdaToParenthesizedExpression = function () {
            var source = "var v = (a, b) => c";

            var index = source.indexOf(">");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, index, 1);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testGenericToArithmetic = function () {
            var source = "var v = new Dictionary<A, B>()";

            var index = source.indexOf("()");

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withDelete(oldText, index, 2);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testArithmeticToGeneric = function () {
            var source = "var v = new Dictionary<A, B>";

            var index = source.length;

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, index, "()");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.textComplexEdits1 = function () {
            var source = "if (typeParameterSymbol.isResolved() || typeParameterSymbol.isResolving()) {\
    return typeParameterSymbol;\
}\
else {\
    return null;\
}";

            var index = source.indexOf("||");

            var text1 = TypeScript.SimpleText.fromString(source);
            var textAndChange1 = withChange(text1, index, "|| typeParameterSymbol.isResolving()".length, "/*|| typeParameterSymbol.isResolving()*/");

            var text2 = textAndChange1.text;
            var start = text2.substr(0, text2.length()).indexOf("else");
            var end = text2.substr(0, text2.length()).lastIndexOf("}") + 1;

            var textAndChange2 = withDelete(text2, start, end - start);
            var text3 = textAndChange2.text;

            compareTrees(text1, text2, textAndChange1.textChangeRange, -1);
            compareTrees(text2, text3, textAndChange2.textChangeRange, -1);
            compareTrees(text1, text3, TypeScript.TextChangeRange.collapseChangesAcrossMultipleVersions([textAndChange1.textChangeRange, textAndChange2.textChangeRange]), -1);
        };

        IncrementalParserTests.testSemicolonDelete1 = function () {
            var source = "export class Foo {\r\n}\r\n\r\nexport var foo = new Foo();\r\n\r\n    export function test(foo: Foo) {\r\n        return true;\r\n    }\r\n";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.lastIndexOf(";");
            var newTextAndChange = withDelete(oldText, index, 1);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, 33);
        };

        IncrementalParserTests.testGenericError1 = function () {
            var source = "class Dictionary<> { }\r\nvar y;\r\n";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.length;
            var newTextAndChange = withInsert(oldText, index, "var x;");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testParameterDeleteAfterComment1 = function () {
            var source = "function fn(/* comment! */ a: number, c) { }";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.indexOf("a:");
            var newTextAndChange = withDelete(oldText, index, "a: number,".length);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testInsertModifierBeforeSetter1 = function () {
            var source = "class C {\
    set Bar(bar:string) {}\
}\
var o2 = { set Foo(val:number) { } };";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.indexOf("set");
            var newTextAndChange = withInsert(oldText, index, "public ");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testParameter2 = function () {
            var source = "alert(100);\
\
class OverloadedMonster {\
constructor();\
constructor(name) { }\
}";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.indexOf("100");
            var newTextAndChange = withInsert(oldText, index, "'1', ");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testInsertAboveComment = function () {
            var source = "\
// foo\
1;";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = 0;
            var newTextAndChange = withInsert(oldText, index, "var x;\r\n");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testInsertDeclareAboveModule = function () {
            var source = "module mAmbient {\
module m3 { }\
}";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = 0;
            var newTextAndChange = withInsert(oldText, index, "declare ");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testInsertFunctionAboveLambdaWithComment = function () {
            var source = "\
() =>\
   // do something\
0;";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = 0;
            var newTextAndChange = withInsert(oldText, index, "function Foo() { }");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testSlashToRegex1 = function () {
            var source = "while (true) /3; return;";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.length - 1;
            var newTextAndChange = withInsert(oldText, index, "/");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testRegex1 = function () {
            var source = "return;\r\nwhile (true) /3/g;";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.indexOf("while");
            var newTextAndChange = withDelete(oldText, index, "while ".length);

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testRegex2 = function () {
            var source = "return;\r\n(true) /3/g;";

            var oldText = TypeScript.SimpleText.fromString(source);
            var index = source.indexOf("(");
            var newTextAndChange = withInsert(oldText, index, "while ");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testKeywordAsIdentifier1 = function () {
            var source = "return; a.public /*";

            var oldText = TypeScript.SimpleText.fromString(source);
            var newTextAndChange = withInsert(oldText, 0, "");

            compareTrees(oldText, newTextAndChange.text, newTextAndChange.textChangeRange, -1);
        };

        IncrementalParserTests.testSkippedToken1 = function () {
            var source = "function foo() {\r\n" + "            function getOccurrencesAtPosition() {\r\n" + "            switch (node) {\r\n" + "                enum \r\n" + "            }\r\n" + "                \r\n" + "                return undefined;\r\n" + "                \r\n" + "                function keywordToReferenceEntry() {\r\n" + "                }\r\n" + "            }\r\n" + "                \r\n" + "            return {\r\n" + "                getEmitOutput: (filename): Bar => null,\r\n" + "            };\r\n" + "        }";

            var text1 = TypeScript.SimpleText.fromString(source);
            var tree1 = TypeScript.Parser.parse("", text1, 1 /* EcmaScript5 */, false);

            var index = source.indexOf("enum ") + "enum ".length;
            var textAndChange1 = withInsert(text1, index, "F");

            var incrementalTree1 = TypeScript.IncrementalParser.parse(tree1, textAndChange1.textChangeRange, textAndChange1.text);

            var textAndChange2 = withInsert(textAndChange1.text, index + 1, "o");

            var incrementalTree2 = TypeScript.IncrementalParser.parse(incrementalTree1, textAndChange2.textChangeRange, textAndChange2.text);
        };
        return IncrementalParserTests;
    })();
    TypeScript.IncrementalParserTests = IncrementalParserTests;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function assertParent(parent, child) {
        if (child && !TypeScript.isShared(child)) {
            return TypeScript.Debug.assert(parent === child.parent);
        }
    }

    function nodeStructuralEquals(node1, node2, checkParents, text1, text2) {
        if (node1 === node2) {
            return true;
        }
        if (node1 === null || node2 === null) {
            return false;
        }

        TypeScript.Debug.assert(node1.kind() === 120 /* SourceUnit */ || node1.parent);
        TypeScript.Debug.assert(node2.kind() === 120 /* SourceUnit */ || node2.parent);

        if (node1.kind() !== node2.kind()) {
            return false;
        }
        if (TypeScript.childCount(node1) !== TypeScript.childCount(node2)) {
            return false;
        }

        for (var i = 0, n = TypeScript.childCount(node1); i < n; i++) {
            var element1 = TypeScript.childAt(node1, i);
            var element2 = TypeScript.childAt(node2, i);

            if (checkParents) {
                assertParent(node1, element1);
                assertParent(node2, element2);
            }

            if (!elementStructuralEquals(element1, element2, checkParents, text1, text2)) {
                return false;
            }
        }

        return true;
    }
    TypeScript.nodeStructuralEquals = nodeStructuralEquals;

    function nodeOrTokenStructuralEquals(node1, node2, checkParents, text1, text2) {
        if (node1 === node2) {
            return true;
        }

        if (node1 === null || node2 === null) {
            return false;
        }

        TypeScript.Debug.assert(node1.kind() === 120 /* SourceUnit */ || node1.parent);
        TypeScript.Debug.assert(node2.kind() === 120 /* SourceUnit */ || node2.parent);

        if (TypeScript.isToken(node1)) {
            return TypeScript.isToken(node2) ? tokenStructuralEquals(node1, node2, text1, text2) : false;
        }

        return TypeScript.isNode(node2) ? nodeStructuralEquals(node1, node2, checkParents, text1, text2) : false;
    }
    TypeScript.nodeOrTokenStructuralEquals = nodeOrTokenStructuralEquals;

    function tokenStructuralEquals(token1, token2, text1, text2) {
        if (token1 === token2) {
            return true;
        }

        if (token1 === null || token2 === null) {
            return false;
        }

        TypeScript.Debug.assert(token1.parent);
        TypeScript.Debug.assert(token2.parent);

        return token1.kind() === token2.kind() && TypeScript.width(token1) === TypeScript.width(token2) && token1.fullWidth() === token2.fullWidth() && token1.fullStart() === token2.fullStart() && TypeScript.fullEnd(token1) === TypeScript.fullEnd(token2) && TypeScript.start(token1, text1) === TypeScript.start(token2, text2) && TypeScript.end(token1, text1) === TypeScript.end(token2, text2) && token1.text() === token2.text() && triviaListStructuralEquals(token1.leadingTrivia(text1), token2.leadingTrivia(text2)) && triviaListStructuralEquals(token1.trailingTrivia(text1), token2.trailingTrivia(text2));
    }
    TypeScript.tokenStructuralEquals = tokenStructuralEquals;

    function triviaListStructuralEquals(triviaList1, triviaList2) {
        TypeScript.Debug.assert(triviaList1.isShared() || triviaList1.parent);
        TypeScript.Debug.assert(triviaList1.isShared() || triviaList2.parent);

        if (triviaList1.count() !== triviaList2.count()) {
            return false;
        }

        for (var i = 0, n = triviaList1.count(); i < n; i++) {
            if (!triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                return false;
            }
        }

        return true;
    }
    TypeScript.triviaListStructuralEquals = triviaListStructuralEquals;

    function triviaStructuralEquals(trivia1, trivia2) {
        TypeScript.Debug.assert(trivia1.parent);
        TypeScript.Debug.assert(trivia2.parent);

        return trivia1.kind === trivia2.kind && trivia1.fullWidth() === trivia2.fullWidth() && trivia1.fullText() === trivia2.fullText();
    }
    TypeScript.triviaStructuralEquals = triviaStructuralEquals;

    function listStructuralEquals(list1, list2, checkParents, text1, text2) {
        TypeScript.Debug.assert(TypeScript.isShared(list1) || list1.parent);
        TypeScript.Debug.assert(TypeScript.isShared(list2) || list2.parent);

        if (TypeScript.childCount(list1) !== TypeScript.childCount(list2)) {
            return false;
        }

        for (var i = 0, n = TypeScript.childCount(list1); i < n; i++) {
            var child1 = TypeScript.childAt(list1, i);
            var child2 = TypeScript.childAt(list2, i);

            if (checkParents) {
                assertParent(list1, child1);
                assertParent(list2, child2);
            }

            if (!nodeOrTokenStructuralEquals(child1, child2, checkParents, text1, text2)) {
                return false;
            }
        }

        return true;
    }

    function separatedListStructuralEquals(list1, list2, checkParents, text1, text2) {
        TypeScript.Debug.assert(TypeScript.isShared(list1) || list1.parent);
        TypeScript.Debug.assert(TypeScript.isShared(list2) || list2.parent);

        if (TypeScript.childCount(list1) !== TypeScript.childCount(list2)) {
            return false;
        }

        for (var i = 0, n = TypeScript.childCount(list1); i < n; i++) {
            var element1 = TypeScript.childAt(list1, i);
            var element2 = TypeScript.childAt(list2, i);

            if (checkParents) {
                assertParent(list1, element1);
                assertParent(list2, element2);
            }

            if (!nodeOrTokenStructuralEquals(element1, element2, checkParents, text1, text2)) {
                return false;
            }
        }

        return true;
    }

    function elementStructuralEquals(element1, element2, checkParents, text1, text2) {
        if (element1 === element2) {
            return true;
        }

        if (element1 === null || element2 === null) {
            return false;
        }

        TypeScript.Debug.assert(element1.kind() === 120 /* SourceUnit */ || element1.parent);
        TypeScript.Debug.assert(element2.kind() === 120 /* SourceUnit */ || element2.parent);

        if (element2.kind() !== element2.kind()) {
            return false;
        }

        if (TypeScript.fullStart(element1) !== TypeScript.fullStart(element2)) {
            return false;
        }

        if (TypeScript.start(element1) !== TypeScript.start(element2)) {
            return false;
        }

        if (TypeScript.end(element1) !== TypeScript.end(element2)) {
            return false;
        }

        if (TypeScript.fullEnd(element1) !== TypeScript.fullEnd(element2)) {
            return false;
        }

        if (TypeScript.isToken(element1)) {
            return tokenStructuralEquals(element1, element2, text1, text2);
        } else if (TypeScript.isNode(element1)) {
            return nodeStructuralEquals(element1, element2, checkParents, text1, text2);
        } else if (TypeScript.isList(element1)) {
            return listStructuralEquals(element1, element2, checkParents, text1, text2);
        } else if (TypeScript.isSeparatedList(element1)) {
            return separatedListStructuralEquals(element1, element2, checkParents, text1, text2);
        }

        throw TypeScript.Errors.invalidOperation();
    }
    TypeScript.elementStructuralEquals = elementStructuralEquals;

    function treeStructuralEquals(tree1, tree2, checkParents) {
        if (!TypeScript.ArrayUtilities.sequenceEquals(tree1.diagnostics(), tree2.diagnostics(), TypeScript.Diagnostic.equals)) {
            return false;
        }

        return nodeStructuralEquals(tree1.sourceUnit(), tree2.sourceUnit(), checkParents, tree1.text, tree2.text);
    }
    TypeScript.treeStructuralEquals = treeStructuralEquals;
})(TypeScript || (TypeScript = {}));
var timer = new TypeScript.Timer();

var specificFile = undefined;

var generate = false;

var PositionValidatingWalker = (function (_super) {
    __extends(PositionValidatingWalker, _super);
    function PositionValidatingWalker() {
        _super.apply(this, arguments);
        this.position = 0;
    }
    PositionValidatingWalker.prototype.visitToken = function (token) {
        TypeScript.Debug.assert(this.position === token.fullStart());
        this.position += token.fullWidth();
    };
    return PositionValidatingWalker;
})(TypeScript.SyntaxWalker);

function tokenToJSON(token, text) {
    if (token === null) {
        return null;
    }

    var result = {};

    for (var name in TypeScript.SyntaxKind) {
        if (TypeScript.SyntaxKind[name] === token.kind()) {
            result.kind = name;
            break;
        }
    }

    result.fullStart = token.fullStart();
    result.fullEnd = TypeScript.fullEnd(token);

    result.start = TypeScript.start(token, text);
    result.end = TypeScript.end(token, text);

    result.fullWidth = token.fullWidth();
    result.width = TypeScript.width(token);

    result.text = token.text();

    var value = TypeScript.tokenValue(token);
    if (value !== null) {
        result.value = value;
        result.valueText = TypeScript.tokenValueText(token);
    }

    if (token.isKeywordConvertedToIdentifier()) {
        result.isKeywordConvertedToIdentifier = true;
    }

    var leadingTrivia = null;
    if (token.hasLeadingTrivia()) {
        result.hasLeadingTrivia = true;
        leadingTrivia = token.leadingTrivia(text);
    }

    if (token.hasLeadingComment()) {
        result.hasLeadingComment = true;

        TypeScript.Debug.assert(token.hasLeadingTrivia());
        TypeScript.Debug.assert(leadingTrivia.hasComment());
    }

    if (leadingTrivia) {
        if (leadingTrivia.hasNewLine()) {
            result.hasLeadingNewLine = true;
        }

        if (leadingTrivia.hasSkippedToken()) {
            result.hasLeadingSkippedText = true;
        }
    }

    var trailingTrivia = null;
    if (token.hasTrailingTrivia()) {
        result.hasTrailingTrivia = true;
        trailingTrivia = token.trailingTrivia(text);
    }

    if (token.hasTrailingComment()) {
        result.hasTrailingComment = true;

        TypeScript.Debug.assert(token.hasTrailingTrivia());
        TypeScript.Debug.assert(trailingTrivia.hasComment());
    }

    if (trailingTrivia) {
        if (trailingTrivia.hasNewLine()) {
            result.hasTrailingNewLine = true;
        }

        if (trailingTrivia.hasSkippedToken()) {
            result.hasTrailingSkippedText = true;
        }
    }

    if (leadingTrivia) {
        result.leadingTrivia = triviaListToJSON(leadingTrivia, text);
    }

    if (trailingTrivia) {
        result.trailingTrivia = triviaListToJSON(trailingTrivia, text);
    }

    return result;
}

function triviaListToJSON(trivia, text) {
    var result = [];

    for (var i = 0, n = trivia.count(); i < n; i++) {
        result.push(triviaToJSON(trivia.syntaxTriviaAt(i), text));
    }

    return result;
}

function triviaToJSON(trivia, text) {
    var result = {};

    for (var name in TypeScript.SyntaxKind) {
        if (TypeScript.SyntaxKind[name] === trivia.kind()) {
            result.kind = name;
            break;
        }
    }

    if (trivia.isSkippedToken()) {
        result.skippedToken = tokenToJSON(trivia.skippedToken(), text);
    } else {
        result.fullStart = trivia.fullStart();
        result.fullEnd = trivia.fullStart() + trivia.fullWidth();
        result.text = trivia.fullText();
    }

    return result;
}

function nodeToJSON(node, text) {
    var result = {};

    for (var name in TypeScript.SyntaxKind) {
        if (TypeScript.SyntaxKind[name] === node.kind()) {
            result.kind = name;
            break;
        }
    }

    result.fullStart = TypeScript.fullStart(node);
    result.fullEnd = TypeScript.fullEnd(node);

    result.start = TypeScript.start(node);
    result.end = TypeScript.end(node);

    result.fullWidth = TypeScript.fullWidth(node);
    result.width = TypeScript.width(node);

    if (TypeScript.isIncrementallyUnusable(node)) {
        result.isIncrementallyUnusable = true;
    }

    if (TypeScript.parsedInStrictMode(node)) {
        result.parsedInStrictMode = true;
    }

    var thisAsIndexable = node;
    for (var i = 0, n = TypeScript.childCount(node); i < n; i++) {
        var value = TypeScript.childAt(node, i);

        if (value) {
            for (var name in node) {
                if (value === thisAsIndexable[name]) {
                    result[name] = elementToJSON(value, text);
                    break;
                }
            }
        }
    }

    return result;
}

function elementToJSON(element, text) {
    if (TypeScript.isToken(element)) {
        return tokenToJSON(element, text);
    } else if (TypeScript.isList(element) || TypeScript.isSeparatedList(element)) {
        var result = [];

        for (var i = 0, n = TypeScript.childCount(element); i < n; i++) {
            result.push(elementToJSON(TypeScript.childAt(element, i), text));
        }

        return result;
    } else {
        return nodeToJSON(element, text);
    }
}

function syntaxTreeToJSON(tree) {
    var result = {};

    result.isDeclaration = tree.isDeclaration();
    result.languageVersion = TypeScript.LanguageVersion[tree.languageVersion()];

    if (tree.diagnostics().length > 0) {
        result.diagnostics = tree.diagnostics();
    }

    result.sourceUnit = elementToJSON(tree.sourceUnit(), tree.text);
    result.lineMap = tree.lineMap();

    return result;
}

function emptySourceUnit() {
    return TypeScript.Parser.parse("", TypeScript.SimpleText.fromString(""), 1 /* EcmaScript5 */, false).sourceUnit();
}

var Program = (function () {
    function Program() {
    }
    Program.prototype.runAllTests = function (verify) {
        var _this = this;
        TypeScript.Environment.standardOut.WriteLine("");

        if (generate) {
            TypeScript.Environment.standardOut.WriteLine("!!!!!!!!!! WARNING - GENERATING !!!!!!!!!");
            TypeScript.Environment.standardOut.WriteLine("");
        }

        TypeScript.Environment.standardOut.Write("Testing Incremental 1:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\parser\\ecmascript5", function (fileName) {
            return _this.runIncremental(fileName, 1 /* EcmaScript5 */);
        });

        if (specificFile === undefined) {
            TypeScript.Environment.standardOut.WriteLine("Testing Incremental 2.");
            TypeScript.IncrementalParserTests.runAllTests();
        }

        TypeScript.Environment.standardOut.Write("Testing scanner ES3:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\scanner\\ecmascript3", function (fileName) {
            return _this.runScanner(fileName, 0 /* EcmaScript3 */, verify, generate);
        });

        TypeScript.Environment.standardOut.Write("Testing scanner ES5:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\scanner\\ecmascript5", function (fileName) {
            return _this.runScanner(fileName, 1 /* EcmaScript5 */, verify, generate);
        });

        TypeScript.Environment.standardOut.Write("Testing findToken:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\findToken\\ecmascript5", function (fileName) {
            return _this.runFindToken(fileName, 1 /* EcmaScript5 */, verify, generate);
        });

        TypeScript.Environment.standardOut.Write("Testing trivia:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\trivia\\ecmascript5", function (fileName) {
            return _this.runTrivia(fileName, 1 /* EcmaScript5 */, verify, generate);
        });

        TypeScript.Environment.standardOut.Write("Testing parser ES5:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\parser\\ecmascript5", function (fileName) {
            return _this.runParser(fileName, 1 /* EcmaScript5 */, verify, generate);
        });

        TypeScript.Environment.standardOut.Write("Testing parser ES3:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\parser\\ecmascript3", function (fileName) {
            return _this.runParser(fileName, 0 /* EcmaScript3 */, verify, generate);
        });

        TypeScript.Environment.standardOut.Write("Testing emitter 2:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\emitter2\\ecmascript5", function (fileName) {
            return _this.runEmitter(fileName, 1 /* EcmaScript5 */, verify, generate, true);
        });

        TypeScript.Environment.standardOut.Write("Testing emitter 1:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\emitter\\ecmascript5", function (fileName) {
            return _this.runEmitter(fileName, 1 /* EcmaScript5 */, verify, generate, false);
        });

        TypeScript.Environment.standardOut.Write("Testing pretty printer:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\prettyPrinter\\ecmascript5", function (fileName) {
            return _this.runPrettyPrinter(fileName, 1 /* EcmaScript5 */, verify, generate);
        });

        if (specificFile === undefined) {
            this.testIncrementalSpeed(TypeScript.Environment.currentDirectory() + "\\src\\compiler\\syntax\\syntaxNodes.concrete.generated.ts");
        }

        TypeScript.Environment.standardOut.Write("Testing against 262:");
        this.runTests(TypeScript.Environment.currentDirectory() + "\\tests\\Fidelity\\test262", function (fileName) {
            return _this.runParser(fileName, 1 /* EcmaScript5 */, verify, generate);
        });
    };

    Program.reusedElements = function (oldNode, newNode, key) {
        var allOldElements = TypeScript.SyntaxElementsCollector.collectElements(oldNode);
        var allNewElements = TypeScript.SyntaxElementsCollector.collectElements(newNode);

        for (var i = 0; i < allOldElements.length; i++) {
            var oldElement = allOldElements[i];
            oldElement[key] = key;
        }

        var reused = 0;
        for (var j = 0; j < allNewElements.length; j++) {
            var newElement = allNewElements[j];
            if (newElement[key] === key) {
                reused++;
            }
        }

        return { originalElements: allOldElements.length, reusedElements: reused };
    };

    Program.prototype.testIncrementalSpeed = function (fileName) {
        var repeat = 500;
        TypeScript.Environment.standardOut.WriteLine("Incremental Perf - Changed Text.");
        this.testIncrementalSpeedChange(fileName, repeat);

        TypeScript.Environment.standardOut.WriteLine("");
        TypeScript.Environment.standardOut.WriteLine("Incremental Perf - No Changed Text.");
        this.testIncrementalSpeedNoChange(fileName, repeat);
    };

    Program.prototype.testIncrementalSpeedNoChange = function (fileName, repeat) {
        if (specificFile !== undefined) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        var text = TypeScript.SimpleText.fromString(contents);
        var tree = TypeScript.Parser.parse(fileName, text, 1 /* EcmaScript5 */, TypeScript.isDTSFile(fileName));
        var originalTree = tree;

        var totalIncrementalTime = 0;
        var timer = new TypeScript.Timer();

        for (var i = 0; i < repeat; i++) {
            var changeLength = i * 2;

            timer.start();
            var tree2 = TypeScript.IncrementalParser.parse(tree, new TypeScript.TextChangeRange(new TypeScript.TextSpan(((text.length() / 2) >> 0) - i, changeLength), changeLength), text);
            timer.end();
            totalIncrementalTime += timer.time;

            TypeScript.Debug.assert(TypeScript.treeStructuralEquals(tree, tree2, false));

            tree = tree2;
        }

        var rateBytesPerMillisecond = (contents.length * repeat) / totalIncrementalTime;
        var rateBytesPerSecond = rateBytesPerMillisecond * 1000;
        var rateMBPerSecond = rateBytesPerSecond / (1024 * 1024);

        TypeScript.Environment.standardOut.WriteLine("Incremental     rate: " + rateMBPerSecond + " MB/s");

        var allOldElements = TypeScript.SyntaxElementsCollector.collectElements(originalTree.sourceUnit());
        var allNewElements = TypeScript.SyntaxElementsCollector.collectElements(tree.sourceUnit());

        var reuse = TypeScript.ArrayUtilities.where(allNewElements, function (v) {
            return TypeScript.ArrayUtilities.contains(allOldElements, v);
        }).length;

        TypeScript.Environment.standardOut.WriteLine("Reuse: " + reuse / allNewElements.length);
    };

    Program.prototype.testIncrementalSpeedChange = function (fileName, repeat) {
        if (specificFile !== undefined) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        var text = TypeScript.SimpleText.fromString(contents);
        var tree = TypeScript.Parser.parse(fileName, text, 1 /* EcmaScript5 */, TypeScript.isDTSFile(fileName));
        var originalTree = tree;

        var totalIncrementalTime = 0;
        var totalIncrementalASTTime = 0;
        var timer = new TypeScript.Timer();

        for (var i = 0; i < repeat; i++) {
            var changeLength = i * 2;
            var changeSpan = new TypeScript.TextSpan(((text.length() / 2) >> 0) - i, changeLength);

            contents = text.substr(0, text.length());
            var contentsToReplace = contents.substr(changeSpan.start(), changeSpan.length());

            var first = true;
            var updatedText = contentsToReplace.replace(/[^a-zA-Z0-9][a-z]+[^a-zA-Z0-9]/, function (sub) {
                if (first && TypeScript.SyntaxFacts.getTokenKind(sub.substr(1, sub.length - 2)) === 0 /* None */) {
                    first = false;
                    return sub.substr(0, sub.length - 1) + "a" + sub.substr(sub.length - 1);
                }

                return sub;
            });

            text = TypeScript.SimpleText.fromString(contents.substr(0, changeSpan.start()) + updatedText + contents.substr(changeSpan.end()));
            var changeRange = new TypeScript.TextChangeRange(changeSpan, updatedText.length);

            timer.start();
            var tree2 = TypeScript.IncrementalParser.parse(tree, changeRange, text);
            timer.end();
            totalIncrementalTime += timer.time;

            tree = tree2;
        }

        var rateBytesPerMillisecond = (contents.length * repeat) / totalIncrementalTime;
        var rateBytesPerSecond = rateBytesPerMillisecond * 1000;
        var rateMBPerSecond = rateBytesPerSecond / (1024 * 1024);

        TypeScript.Environment.standardOut.WriteLine("Incremental     rate: " + rateMBPerSecond + " MB/s");

        rateBytesPerMillisecond = (contents.length * repeat) / totalIncrementalASTTime;
        rateBytesPerSecond = rateBytesPerMillisecond * 1000;
        rateMBPerSecond = rateBytesPerSecond / (1024 * 1024);

        var allOldElements = TypeScript.SyntaxElementsCollector.collectElements(originalTree.sourceUnit());
        var allNewElements = TypeScript.SyntaxElementsCollector.collectElements(tree.sourceUnit());

        var reuse = TypeScript.ArrayUtilities.where(allNewElements, function (v) {
            return TypeScript.ArrayUtilities.contains(allOldElements, v);
        }).length;

        TypeScript.Environment.standardOut.WriteLine("Reuse: " + reuse / allNewElements.length);
    };

    Program.prototype.handleException = function (fileName, e) {
        TypeScript.Environment.standardOut.WriteLine("");
        if (e.message.indexOf(fileName) < 0) {
            TypeScript.Environment.standardOut.WriteLine("Exception: " + fileName + ": " + e.message);
        } else {
            TypeScript.Environment.standardOut.WriteLine(e.message);
        }
    };

    Program.prototype.runTests = function (path, action) {
        var _this = this;
        var testFiles = TypeScript.Environment.listFiles(path, null, { recursive: true });
        var indexNum = 0;

        testFiles.forEach(function (fileName) {
            if (specificFile !== undefined && fileName.indexOf(specificFile) < 0) {
                return;
            }

            if (indexNum % 100 === 0) {
                TypeScript.Environment.standardOut.Write(".");
            }

            try  {
                action(fileName);
            } catch (e) {
                _this.handleException(fileName, e);
            }

            indexNum++;
        });

        TypeScript.Environment.standardOut.WriteLine("");
    };

    Program.prototype.checkResult = function (fileName, result, convert, verify, generateBaseline, justText) {
        var actualResult;

        var expectedFile = fileName + ".expected";
        var actualFile = fileName + ".actual";

        if (generateBaseline) {
            actualResult = justText ? result : JSON.stringify(convert(result), null, 4);
            expectedFile = fileName + ".expected";

            TypeScript.Environment.writeFile(expectedFile, actualResult, false);

            if (TypeScript.Environment.fileExists(actualFile)) {
                TypeScript.Environment.deleteFile(actualFile);
            }
        } else if (verify) {
            actualResult = justText ? result : JSON.stringify(convert(result), null, 4);

            var expectedResult = null;
            if (!TypeScript.Environment.fileExists(expectedFile)) {
                TypeScript.Environment.writeFile(expectedFile, "", false);
            } else {
                expectedResult = TypeScript.Environment.readFile(expectedFile, null).contents;
            }

            if (expectedResult !== actualResult) {
                TypeScript.Environment.standardOut.WriteLine(" ! Fail: " + actualFile);
                TypeScript.Environment.writeFile(actualFile, actualResult, false);
            } else {
                if (TypeScript.Environment.fileExists(actualFile)) {
                    TypeScript.Environment.deleteFile(actualFile);
                }
            }
        }
    };

    Program.prototype.runEmitter = function (fileName, languageVersion, verify, generateBaseline, justText) {
        if (true) {
            return;
        }

        if (!TypeScript.StringUtilities.endsWith(fileName, ".ts") && !TypeScript.StringUtilities.endsWith(fileName, ".js")) {
            return;
        }

        if (fileName.indexOf("RealSource") >= 0) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        totalSize += contents.length;

        var text = TypeScript.SimpleText.fromString(contents);

        var tree = TypeScript.Parser.parse(fileName, text, languageVersion, TypeScript.isDTSFile(fileName));
    };

    Program.prototype.runPrettyPrinter = function (fileName, languageVersion, verify, generateBaseline) {
        if (!TypeScript.StringUtilities.endsWith(fileName, ".ts") && !TypeScript.StringUtilities.endsWith(fileName, ".js")) {
            return;
        }

        if (fileName.indexOf("RealSource") >= 0) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        totalSize += contents.length;

        var text = TypeScript.SimpleText.fromString(contents);

        var tree = TypeScript.Parser.parse(fileName, text, languageVersion, TypeScript.isDTSFile(fileName));
        var result = TypeScript.PrettyPrinter.prettyPrint(tree.sourceUnit());

        this.checkResult(fileName, result, null, verify, generateBaseline, true);

        totalTime += timer.time;
    };

    Program.prototype.runParser = function (fileName, languageVersion, verify, generateBaseline, allowErrors) {
        if (typeof allowErrors === "undefined") { allowErrors = true; }
        if (!TypeScript.StringUtilities.endsWith(fileName, ".ts") && !TypeScript.StringUtilities.endsWith(fileName, ".js")) {
            return;
        }

        if (fileName.indexOf("RealSource") >= 0) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        totalSize += contents.length;

        var text = TypeScript.SimpleText.fromString(contents);

        timer.start();
        var tree = TypeScript.Parser.parse(fileName, text, languageVersion, TypeScript.isDTSFile(fileName));
        timer.end();

        cyrusTime += timer.time;

        if (!allowErrors) {
            var diagnostics = tree.diagnostics();
            if (diagnostics.length > 0) {
                TypeScript.Environment.standardOut.WriteLine(fileName);
                TypeScript.Environment.standardOut.WriteLine("\t" + diagnostics[0].message());
            }
        }

        if (verify) {
            TypeScript.Debug.assert(TypeScript.fullWidth(tree.sourceUnit()) === contents.length);
            TypeScript.visitNodeOrToken(new PositionValidatingWalker(), tree.sourceUnit());

            this.checkResult(fileName, tree, syntaxTreeToJSON, verify, generateBaseline, false);
        }
        totalTime += timer.time;
    };

    Program.prototype.runIncremental = function (fileName, languageVersion) {
        if (!TypeScript.StringUtilities.endsWith(fileName, ".ts") && !TypeScript.StringUtilities.endsWith(fileName, ".js")) {
            return;
        }

        if (fileName.indexOf("RealSource") >= 0) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        var text = TypeScript.SimpleText.fromString(contents);

        var tree1 = TypeScript.Parser.parse(fileName, text, languageVersion, TypeScript.isDTSFile(fileName));
        var tree2 = TypeScript.IncrementalParser.parse(new TypeScript.SyntaxTree(true, emptySourceUnit(), TypeScript.isDTSFile(fileName), [], fileName, text, tree1.languageVersion()), new TypeScript.TextChangeRange(new TypeScript.TextSpan(0, 0), text.length()), text);

        TypeScript.Debug.assert(TypeScript.treeStructuralEquals(tree1, tree2, true));
    };

    Program.prototype.runFindToken = function (fileName, languageVersion, verify, generateBaseline) {
        if (!TypeScript.StringUtilities.endsWith(fileName, ".ts") && !TypeScript.StringUtilities.endsWith(fileName, ".js")) {
            return;
        }

        if (fileName.indexOf("RealSource") >= 0) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        var text = TypeScript.SimpleText.fromString(contents);
        var tree = TypeScript.Parser.parse(fileName, text, languageVersion, TypeScript.isDTSFile(fileName));
        var sourceUnit = tree.sourceUnit();

        TypeScript.Debug.assert(TypeScript.fullWidth(tree.sourceUnit()) === contents.length);

        var tokens = {};
        var tokensOnLeft = {};
        var leftToRight = [];
        var rightToLeft = [];

        for (var i = 0; i <= contents.length; i++) {
            var token = TypeScript.findToken(sourceUnit, i);

            var left = TypeScript.Syntax.findTokenOnLeft(sourceUnit, i);
            var tokenOnLeft = left === null ? null : left;

            TypeScript.Debug.assert(TypeScript.isToken(token));
            if (i === contents.length) {
                TypeScript.Debug.assert(token.kind() === 10 /* EndOfFileToken */);
            } else {
                TypeScript.Debug.assert(TypeScript.width(token) > 0 || token.kind() === 10 /* EndOfFileToken */);
                TypeScript.Debug.assert(token.fullWidth() > 0);
            }

            tokens[i] = tokenToJSON(token, text);
            tokensOnLeft[i] = tokenToJSON(tokenOnLeft, text);
        }

        var positionedToken = TypeScript.findToken(sourceUnit, 0);
        while (positionedToken !== null) {
            leftToRight.push(tokenToJSON(positionedToken, text));
            positionedToken = TypeScript.nextToken(positionedToken);
        }

        positionedToken = TypeScript.findToken(sourceUnit, contents.length);
        while (positionedToken !== null) {
            rightToLeft.push(tokenToJSON(positionedToken, text));
            positionedToken = TypeScript.previousToken(positionedToken);
        }

        var result = {
            tokens: tokens,
            tokensOnLeft: tokensOnLeft,
            leftToRight: leftToRight,
            rightToLeft: rightToLeft
        };

        this.checkResult(fileName, result, function (a) {
            return a;
        }, verify, generateBaseline, false);
    };

    Program.prototype.runTrivia = function (fileName, languageVersion, verify, generateBaseline) {
        if (!TypeScript.StringUtilities.endsWith(fileName, ".ts")) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;
        var text = TypeScript.SimpleText.fromString(contents);
        var scanner = TypeScript.Scanner.createScanner(languageVersion, text, function () {
        });

        var tokens = [];
        var textArray = [];
        var diagnostics = [];

        while (true) {
            var token = scanner.scan(false);
            tokens.push(tokenToJSON(token, text));

            if (token.kind() === 10 /* EndOfFileToken */) {
                break;
            }
        }

        this.checkResult(fileName, tokens, function (a) {
            return a;
        }, verify, generateBaseline, false);
    };

    Program.prototype.runScanner = function (fileName, languageVersion, verify, generateBaseline) {
        if (!TypeScript.StringUtilities.endsWith(fileName, ".ts")) {
            return;
        }

        var contents = TypeScript.Environment.readFile(fileName, null).contents;

        var diagnostics = [];
        var reportDiagnostic = function (position, fullWidth, diagnosticKey, args) {
            diagnostics.push(new TypeScript.Diagnostic(fileName, text.lineMap(), position, fullWidth, diagnosticKey, args));
        };

        var text = TypeScript.SimpleText.fromString(contents);
        var scanner = TypeScript.Scanner.createScanner(languageVersion, text, reportDiagnostic);

        var tokens = [];
        var jsonTokens = [];
        var textArray = [];
        var position = 0;

        while (true) {
            var token = scanner.scan(false);
            jsonTokens.push(tokenToJSON(token, text));
            tokens.push(token);

            TypeScript.Debug.assert(position === token.fullStart());
            position += token.fullWidth();

            if (token.kind() === 10 /* EndOfFileToken */) {
                break;
            }
        }

        if (verify) {
            var tokenText = TypeScript.ArrayUtilities.select(tokens, function (t) {
                return t.fullText(text);
            }).join("");

            if (tokenText !== contents) {
                throw new Error("Token invariant broken!");
            }
        }

        var result = diagnostics.length === 0 ? jsonTokens : { diagnostics: diagnostics, tokens: jsonTokens };
        this.checkResult(fileName, result, function (a) {
            return a;
        }, verify, generateBaseline, false);
    };

    Program.prototype.parseArguments = function () {
        TypeScript.Environment.standardOut.WriteLine("Testing input files.");
        for (var index in TypeScript.Environment.arguments) {
            var fileName = TypeScript.Environment.arguments[index];
            if (specificFile !== undefined && fileName.indexOf(specificFile) < 0) {
                continue;
            }

            this.runParser(fileName, 1 /* EcmaScript5 */, false, false, false);
        }
    };

    Program.prototype.run262 = function () {
        var path = "C:\\temp\\test262\\suite";
        var testFiles = TypeScript.Environment.listFiles(path, null, { recursive: true });

        var testCount = 0;
        var failCount = 0;
        var skippedTests = [];

        for (var index in testFiles) {
            var fileName = testFiles[index];

            if (specificFile !== undefined && fileName.indexOf(specificFile) < 0) {
                continue;
            }

            var contents = TypeScript.Environment.readFile(fileName, null).contents;

            var isNegative = contents.indexOf("@negative") >= 0;

            testCount++;

            try  {
                var stringText = TypeScript.SimpleText.fromString(contents);
                var tree = TypeScript.Parser.parse(fileName, stringText, 1 /* EcmaScript5 */, TypeScript.isDTSFile(fileName));

                if (isNegative) {
                    var nameOnly = fileName.substr(fileName.lastIndexOf("\\") + 1);
                    var canParseSuccessfully = negative262ExpectedResults[nameOnly];

                    if (canParseSuccessfully) {
                        if (tree.diagnostics() && tree.diagnostics().length > 0) {
                            TypeScript.Environment.standardOut.WriteLine("Negative test. Unexpected failure: " + fileName);
                            failCount++;
                        }
                    } else {
                        if (tree.diagnostics() === null || tree.diagnostics().length === 0) {
                            TypeScript.Environment.standardOut.WriteLine("Negative test. Unexpected success: " + fileName);
                            failCount++;
                        }
                    }
                } else {
                    if (tree.diagnostics() && tree.diagnostics().length > 0) {
                        TypeScript.Environment.standardOut.WriteLine("Unexpected failure: " + fileName);
                        failCount++;
                    }
                }
            } catch (e) {
                failCount++;
                this.handleException(fileName, e);
            }
        }

        TypeScript.Environment.standardOut.WriteLine("");
        TypeScript.Environment.standardOut.WriteLine("Test 262 results:");
        TypeScript.Environment.standardOut.WriteLine("Test Count: " + testCount);
        TypeScript.Environment.standardOut.WriteLine("Skip Count: " + skippedTests.length);
        TypeScript.Environment.standardOut.WriteLine("Fail Count: " + failCount);

        for (var i = 0; i < skippedTests.length; i++) {
            TypeScript.Environment.standardOut.WriteLine(skippedTests[i]);
        }
    };
    return Program;
})();

var diagnostics = {};
for (var d in TypeScript.LocalizedDiagnosticMessages) {
    if (TypeScript.LocalizedDiagnosticMessages.hasOwnProperty(d)) {
        var info = TypeScript.LocalizedDiagnosticMessages[d];
        diagnostics[info.message] = { category: TypeScript.DiagnosticCategory[info.category], code: info.code };
    }
}

var whatever = JSON.stringify(diagnostics, null, 4);

var andersTime = 0;
var cyrusTime = 0;

var totalTime = 0;
var totalSize = 0;
var program = new Program();

totalTime = 0;
totalSize = 0;
program.runAllTests(true);

var count = 1;

TypeScript.Environment.standardOut.WriteLine("Total time: " + (totalTime / count));
TypeScript.Environment.standardOut.WriteLine("Total size: " + (totalSize / count));
TypeScript.Environment.standardOut.WriteLine("Anders time: " + andersTime);
TypeScript.Environment.standardOut.WriteLine("Cyrus time : " + cyrusTime);
