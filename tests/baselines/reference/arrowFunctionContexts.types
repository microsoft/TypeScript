=== tests/cases/conformance/expressions/functions/arrowFunctionContexts.ts ===
// Arrow function used in with statement
with (window) {
>window : Window & typeof globalThis

    var p = () => this;
>p : any
>() => this : any
>this : any
}

// Arrow function as argument to super call
class Base {
>Base : Base

    constructor(n: any) { }
>n : any
}

class Derived extends Base {
>Derived : Derived
>Base : Base

    constructor() {
        super(() => this);
>super(() => this) : void
>super : typeof Base
>() => this : () => this
>this : this
    }
}

// Arrow function as function argument
window.setTimeout(() => null, 100);
>window.setTimeout(() => null, 100) : number
>window.setTimeout : ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number) & ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number)
>window : Window & typeof globalThis
>setTimeout : ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number) & ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number)
>() => null : () => any
>null : null
>100 : 100

// Arrow function as value in array literal

var obj = (n: number) => '';
>obj : (n: number) => string
>(n: number) => '' : (n: number) => string
>n : number
>'' : ""

var obj: { (n: number): string; }; // OK
>obj : (n: number) => string
>n : number

var arr = [(n: number) => ''];
>arr : ((n: number) => string)[]
>[(n: number) => ''] : ((n: number) => string)[]
>(n: number) => '' : (n: number) => string
>n : number
>'' : ""

var arr: { (n: number): string; }[]; // Incorrect error here (bug 829597)
>arr : ((n: number) => string)[]
>n : number

// Arrow function as enum value
enum E {
>E : E

    x = () => 4, // Error expected
>x : E
>() => 4 : () => number
>4 : 4

    y = (() => this).length // error, can't use this in enum
>y : E
>(() => this).length : number
>(() => this) : () => any
>() => this : () => any
>this : any
>length : number
}

// Arrow function as module variable initializer
module M {
>M : typeof M

    export var a = (s) => '';
>a : (s: any) => string
>(s) => '' : (s: any) => string
>s : any
>'' : ""

    var b = (s) => s;
>b : (s: any) => any
>(s) => s : (s: any) => any
>s : any
>s : any
}

// Repeat above for module members that are functions? (necessary to redo all of them?)
module M2 {
>M2 : typeof M2

    // Arrow function used in with statement
    with (window) {
>window : Window & typeof globalThis

        var p = () => this;
>p : any
>() => this : any
>this : any
    }

    // Arrow function as argument to super call
    class Base {
>Base : Base

        constructor(n: any) { }
>n : any
    }

    class Derived extends Base {
>Derived : Derived
>Base : Base

        constructor() {
            super(() => this);
>super(() => this) : void
>super : typeof Base
>() => this : () => this
>this : this
        }
    }

    // Arrow function as function argument
    window.setTimeout(() => null, 100);
>window.setTimeout(() => null, 100) : number
>window.setTimeout : ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number) & ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number)
>window : Window & typeof globalThis
>setTimeout : ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number) & ((handler: TimerHandler, timeout?: number, ...arguments: any[]) => number)
>() => null : () => any
>null : null
>100 : 100

    // Arrow function as value in array literal

    var obj = (n: number) => '';
>obj : (n: number) => string
>(n: number) => '' : (n: number) => string
>n : number
>'' : ""

    var obj: { (n: number): string; }; // OK
>obj : (n: number) => string
>n : number

    var arr = [(n: number) => ''];
>arr : ((n: number) => string)[]
>[(n: number) => ''] : ((n: number) => string)[]
>(n: number) => '' : (n: number) => string
>n : number
>'' : ""

    var arr: { (n: number): string; }[]; // Incorrect error here (bug 829597)
>arr : ((n: number) => string)[]
>n : number

    // Arrow function as enum value
    enum E {
>E : E

        x = () => 4, // Error expected
>x : E
>() => 4 : () => number
>4 : 4

        y = (() => this).length
>y : E
>(() => this).length : number
>(() => this) : () => any
>() => this : () => any
>this : any
>length : number
    }

    // Arrow function as module variable initializer
    module M {
>M : typeof M

        export var a = (s) => '';
>a : (s: any) => string
>(s) => '' : (s: any) => string
>s : any
>'' : ""

        var b = (s) => s;
>b : (s: any) => any
>(s) => s : (s: any) => any
>s : any
>s : any
    }

}

// <Identifier>(ParamList) => { ... } is a generic arrow function
var generic1 = <T>(n: T) => [n];
>generic1 : <T>(n: T) => T[]
><T>(n: T) => [n] : <T>(n: T) => T[]
>n : T
>[n] : T[]
>n : T

var generic1: { <T>(n: T): T[] }; // Incorrect error, Bug 829597
>generic1 : <T>(n: T) => T[]
>n : T

var generic2 = <T>(n: T) => { return [n]; };
>generic2 : <T>(n: T) => T[]
><T>(n: T) => { return [n]; } : <T>(n: T) => T[]
>n : T
>[n] : T[]
>n : T

var generic2: { <T>(n: T): T[] };
>generic2 : <T>(n: T) => T[]
>n : T

// <Identifier> ((ParamList) => { ... } ) is a type assertion to an arrow function
var asserted1 = <any>((n) => [n]);
>asserted1 : any
><any>((n) => [n]) : any
>((n) => [n]) : (n: any) => any[]
>(n) => [n] : (n: any) => any[]
>n : any
>[n] : any[]
>n : any

var asserted1: any;
>asserted1 : any

var asserted2 = <any>((n) => { return n; });
>asserted2 : any
><any>((n) => { return n; }) : any
>((n) => { return n; }) : (n: any) => any
>(n) => { return n; } : (n: any) => any
>n : any
>n : any

var asserted2: any;
>asserted2 : any


