//// [tests/cases/compiler/augmentedTypesModules.ts] ////

=== augmentedTypesModules.ts ===
// module then var
namespace m1 { }
>m1 : Symbol(m1, Decl(augmentedTypesModules.ts, 0, 0), Decl(augmentedTypesModules.ts, 2, 3))

var m1 = 1; // Should be allowed
>m1 : Symbol(m1, Decl(augmentedTypesModules.ts, 0, 0), Decl(augmentedTypesModules.ts, 2, 3))

namespace m1a { var y = 2; } // error
>m1a : Symbol(m1a, Decl(augmentedTypesModules.ts, 2, 11))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 4, 19))

var m1a = 1; // error
>m1a : Symbol(m1a, Decl(augmentedTypesModules.ts, 5, 3))

namespace m1b { export var y = 2; } // error
>m1b : Symbol(m1b, Decl(augmentedTypesModules.ts, 5, 12))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 7, 26))

var m1b = 1; // error
>m1b : Symbol(m1b, Decl(augmentedTypesModules.ts, 8, 3))

namespace m1c {
>m1c : Symbol(m1c, Decl(augmentedTypesModules.ts, 8, 12), Decl(augmentedTypesModules.ts, 13, 3))

    export interface I { foo(): void; }
>I : Symbol(I, Decl(augmentedTypesModules.ts, 10, 15))
>foo : Symbol(I.foo, Decl(augmentedTypesModules.ts, 11, 24))
}
var m1c = 1; // Should be allowed
>m1c : Symbol(m1c, Decl(augmentedTypesModules.ts, 8, 12), Decl(augmentedTypesModules.ts, 13, 3))

namespace m1d { // error
>m1d : Symbol(m1d, Decl(augmentedTypesModules.ts, 13, 12))

    export class I { foo() { } }
>I : Symbol(I, Decl(augmentedTypesModules.ts, 15, 15))
>foo : Symbol(I.foo, Decl(augmentedTypesModules.ts, 16, 20))
}
var m1d = 1; // error
>m1d : Symbol(m1d, Decl(augmentedTypesModules.ts, 18, 3))

// module then function
namespace m2 { }
>m2 : Symbol(m2, Decl(augmentedTypesModules.ts, 21, 16), Decl(augmentedTypesModules.ts, 18, 12))

function m2() { }; // ok since the module is not instantiated
>m2 : Symbol(m2, Decl(augmentedTypesModules.ts, 21, 16), Decl(augmentedTypesModules.ts, 18, 12))

namespace m2a { var y = 2; }
>m2a : Symbol(m2a, Decl(augmentedTypesModules.ts, 24, 28), Decl(augmentedTypesModules.ts, 22, 18))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 24, 19))

function m2a() { }; // error since the module is instantiated
>m2a : Symbol(m2a, Decl(augmentedTypesModules.ts, 24, 28), Decl(augmentedTypesModules.ts, 22, 18))

namespace m2b { export var y = 2; }
>m2b : Symbol(m2b, Decl(augmentedTypesModules.ts, 27, 35), Decl(augmentedTypesModules.ts, 25, 19))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 27, 26))

function m2b() { };  // error since the module is instantiated
>m2b : Symbol(m2b, Decl(augmentedTypesModules.ts, 27, 35), Decl(augmentedTypesModules.ts, 25, 19))

// should be errors to have function first
function m2c() { }; 
>m2c : Symbol(m2c, Decl(augmentedTypesModules.ts, 28, 19), Decl(augmentedTypesModules.ts, 31, 19))

namespace m2c { export var y = 2; } 
>m2c : Symbol(m2c, Decl(augmentedTypesModules.ts, 28, 19), Decl(augmentedTypesModules.ts, 31, 19))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 32, 26))

namespace m2d { }
>m2d : Symbol(m2d, Decl(augmentedTypesModules.ts, 34, 17), Decl(augmentedTypesModules.ts, 32, 35))

declare function m2d(): void; 
>m2d : Symbol(m2d, Decl(augmentedTypesModules.ts, 34, 17), Decl(augmentedTypesModules.ts, 32, 35))

declare function m2e(): void; 
>m2e : Symbol(m2e, Decl(augmentedTypesModules.ts, 35, 29), Decl(augmentedTypesModules.ts, 37, 29))

namespace m2e { }
>m2e : Symbol(m2e, Decl(augmentedTypesModules.ts, 35, 29), Decl(augmentedTypesModules.ts, 37, 29))

function m2f() { };
>m2f : Symbol(m2f, Decl(augmentedTypesModules.ts, 38, 17), Decl(augmentedTypesModules.ts, 40, 19))

namespace m2f { export interface I { foo(): void } } 
>m2f : Symbol(m2f, Decl(augmentedTypesModules.ts, 38, 17), Decl(augmentedTypesModules.ts, 40, 19))
>I : Symbol(I, Decl(augmentedTypesModules.ts, 41, 15))
>foo : Symbol(I.foo, Decl(augmentedTypesModules.ts, 41, 36))

function m2g() { };
>m2g : Symbol(m2g, Decl(augmentedTypesModules.ts, 41, 52), Decl(augmentedTypesModules.ts, 43, 19))

namespace m2g { export class C { foo() { } } } 
>m2g : Symbol(m2g, Decl(augmentedTypesModules.ts, 41, 52), Decl(augmentedTypesModules.ts, 43, 19))
>C : Symbol(C, Decl(augmentedTypesModules.ts, 44, 15))
>foo : Symbol(C.foo, Decl(augmentedTypesModules.ts, 44, 32))

// module then class
namespace m3 { }
>m3 : Symbol(m3, Decl(augmentedTypesModules.ts, 44, 46), Decl(augmentedTypesModules.ts, 47, 16))

class m3 { } // ok since the module is not instantiated
>m3 : Symbol(m3, Decl(augmentedTypesModules.ts, 44, 46), Decl(augmentedTypesModules.ts, 47, 16))

namespace m3a { var y = 2; }
>m3a : Symbol(m3a, Decl(augmentedTypesModules.ts, 48, 12), Decl(augmentedTypesModules.ts, 50, 28))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 50, 19))

class m3a { foo() { } } // error, class isn't ambient or declared before the module
>m3a : Symbol(m3a, Decl(augmentedTypesModules.ts, 48, 12), Decl(augmentedTypesModules.ts, 50, 28))
>foo : Symbol(m3a.foo, Decl(augmentedTypesModules.ts, 51, 11))

class m3b { foo() { } }
>m3b : Symbol(m3b, Decl(augmentedTypesModules.ts, 51, 23), Decl(augmentedTypesModules.ts, 53, 23))
>foo : Symbol(m3b.foo, Decl(augmentedTypesModules.ts, 53, 11))

namespace m3b { var y = 2; }
>m3b : Symbol(m3b, Decl(augmentedTypesModules.ts, 51, 23), Decl(augmentedTypesModules.ts, 53, 23))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 54, 19))

class m3c { foo() { } }
>m3c : Symbol(m3c, Decl(augmentedTypesModules.ts, 54, 28), Decl(augmentedTypesModules.ts, 56, 23))
>foo : Symbol(m3c.foo, Decl(augmentedTypesModules.ts, 56, 11))

namespace m3c { export var y = 2; } 
>m3c : Symbol(m3c, Decl(augmentedTypesModules.ts, 54, 28), Decl(augmentedTypesModules.ts, 56, 23))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 57, 26))

declare class m3d { foo(): void }
>m3d : Symbol(m3d, Decl(augmentedTypesModules.ts, 57, 35), Decl(augmentedTypesModules.ts, 59, 33))
>foo : Symbol(m3d.foo, Decl(augmentedTypesModules.ts, 59, 19))

namespace m3d { export var y = 2; } 
>m3d : Symbol(m3d, Decl(augmentedTypesModules.ts, 57, 35), Decl(augmentedTypesModules.ts, 59, 33))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 60, 26))

namespace m3e { export var y = 2; } 
>m3e : Symbol(m3e, Decl(augmentedTypesModules.ts, 60, 35), Decl(augmentedTypesModules.ts, 62, 35))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 62, 26))

declare class m3e { foo(): void } 
>m3e : Symbol(m3e, Decl(augmentedTypesModules.ts, 60, 35), Decl(augmentedTypesModules.ts, 62, 35))
>foo : Symbol(m3e.foo, Decl(augmentedTypesModules.ts, 63, 19))

declare class m3f { foo(): void }
>m3f : Symbol(m3f, Decl(augmentedTypesModules.ts, 63, 33), Decl(augmentedTypesModules.ts, 65, 33))
>foo : Symbol(m3f.foo, Decl(augmentedTypesModules.ts, 65, 19))

namespace m3f { export interface I { foo(): void } }
>m3f : Symbol(m3f, Decl(augmentedTypesModules.ts, 63, 33), Decl(augmentedTypesModules.ts, 65, 33))
>I : Symbol(I, Decl(augmentedTypesModules.ts, 66, 15))
>foo : Symbol(I.foo, Decl(augmentedTypesModules.ts, 66, 36))

declare class m3g { foo(): void }
>m3g : Symbol(m3g, Decl(augmentedTypesModules.ts, 66, 52), Decl(augmentedTypesModules.ts, 68, 33))
>foo : Symbol(m3g.foo, Decl(augmentedTypesModules.ts, 68, 19))

namespace m3g { export class C { foo() { } } }
>m3g : Symbol(m3g, Decl(augmentedTypesModules.ts, 66, 52), Decl(augmentedTypesModules.ts, 68, 33))
>C : Symbol(C, Decl(augmentedTypesModules.ts, 69, 15))
>foo : Symbol(C.foo, Decl(augmentedTypesModules.ts, 69, 32))

// module then enum
// should be errors
namespace m4 { }
>m4 : Symbol(m4, Decl(augmentedTypesModules.ts, 69, 46), Decl(augmentedTypesModules.ts, 73, 16))

enum m4 { }
>m4 : Symbol(m4, Decl(augmentedTypesModules.ts, 69, 46), Decl(augmentedTypesModules.ts, 73, 16))

namespace m4a { var y = 2; }
>m4a : Symbol(m4a, Decl(augmentedTypesModules.ts, 74, 11), Decl(augmentedTypesModules.ts, 76, 28))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 76, 19))

enum m4a { One }
>m4a : Symbol(m4a, Decl(augmentedTypesModules.ts, 74, 11), Decl(augmentedTypesModules.ts, 76, 28))
>One : Symbol(m4a.One, Decl(augmentedTypesModules.ts, 77, 10))

namespace m4b { export var y = 2; }
>m4b : Symbol(m4b, Decl(augmentedTypesModules.ts, 77, 16), Decl(augmentedTypesModules.ts, 79, 35))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 79, 26))

enum m4b { One }
>m4b : Symbol(m4b, Decl(augmentedTypesModules.ts, 77, 16), Decl(augmentedTypesModules.ts, 79, 35))
>One : Symbol(m4b.One, Decl(augmentedTypesModules.ts, 80, 10))

namespace m4c { interface I { foo(): void } }
>m4c : Symbol(m4c, Decl(augmentedTypesModules.ts, 80, 16), Decl(augmentedTypesModules.ts, 82, 45))
>I : Symbol(I, Decl(augmentedTypesModules.ts, 82, 15))
>foo : Symbol(I.foo, Decl(augmentedTypesModules.ts, 82, 29))

enum m4c { One }
>m4c : Symbol(m4c, Decl(augmentedTypesModules.ts, 80, 16), Decl(augmentedTypesModules.ts, 82, 45))
>One : Symbol(m4c.One, Decl(augmentedTypesModules.ts, 83, 10))

namespace m4d { class C { foo() { } } }
>m4d : Symbol(m4d, Decl(augmentedTypesModules.ts, 83, 16), Decl(augmentedTypesModules.ts, 85, 39))
>C : Symbol(C, Decl(augmentedTypesModules.ts, 85, 15))
>foo : Symbol(C.foo, Decl(augmentedTypesModules.ts, 85, 25))

enum m4d { One }
>m4d : Symbol(m4d, Decl(augmentedTypesModules.ts, 83, 16), Decl(augmentedTypesModules.ts, 85, 39))
>One : Symbol(m4d.One, Decl(augmentedTypesModules.ts, 86, 10))

//// module then module

namespace m5 { export var y = 2; }
>m5 : Symbol(m5, Decl(augmentedTypesModules.ts, 86, 16), Decl(augmentedTypesModules.ts, 90, 34))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 90, 25))

namespace m5 { export interface I { foo(): void } } // should already be reasonably well covered
>m5 : Symbol(m5, Decl(augmentedTypesModules.ts, 86, 16), Decl(augmentedTypesModules.ts, 90, 34))
>I : Symbol(I, Decl(augmentedTypesModules.ts, 91, 14))
>foo : Symbol(I.foo, Decl(augmentedTypesModules.ts, 91, 35))

// module then import
namespace m6 { export var y = 2; }
>m6 : Symbol(m6, Decl(augmentedTypesModules.ts, 91, 51))
>y : Symbol(y, Decl(augmentedTypesModules.ts, 94, 25))

//import m6 = require('');

