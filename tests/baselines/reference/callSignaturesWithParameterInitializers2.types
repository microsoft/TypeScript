=== tests/cases/conformance/types/objectTypeLiteral/callSignatures/callSignaturesWithParameterInitializers2.ts ===
// Optional parameters allow initializers only in implementation signatures
// All the below declarations are errors

function foo(x = 2);
>foo : (x?: number) => any
>x : number
>2 : 2

function foo(x = 1) { }
>foo : (x?: number) => any
>x : number
>1 : 1

foo(1);
>foo(1) : any
>foo : (x?: number) => any
>1 : 1

foo();
>foo() : any
>foo : (x?: number) => any

class C {
>C : C

    foo(x = 2);
>foo : (x?: number) => any
>x : number
>2 : 2

    foo(x = 1) { }
>foo : (x?: number) => any
>x : number
>1 : 1
}

var c: C;
>c : C

c.foo();
>c.foo() : any
>c.foo : (x?: number) => any
>c : C
>foo : (x?: number) => any

c.foo(1);
>c.foo(1) : any
>c.foo : (x?: number) => any
>c : C
>foo : (x?: number) => any
>1 : 1

var b = {
>b : { foo(x?: number): any; foo(x?: number): void; }
>{    foo(x = 1), // error    foo(x = 1) { }, // error} : { foo(x?: number): any; foo(x?: number): void; }

    foo(x = 1), // error
>foo : { (x?: number): any; (x?: number): void; }
>x : number
>1 : 1

    foo(x = 1) { }, // error
>foo : { (x?: number): any; (x?: number): void; }
>x : number
>1 : 1
}

b.foo();
>b.foo() : any
>b.foo : { (x?: number): any; (x?: number): void; }
>b : { foo(x?: number): any; foo(x?: number): void; }
>foo : { (x?: number): any; (x?: number): void; }

b.foo(1);
>b.foo(1) : any
>b.foo : { (x?: number): any; (x?: number): void; }
>b : { foo(x?: number): any; foo(x?: number): void; }
>foo : { (x?: number): any; (x?: number): void; }
>1 : 1

