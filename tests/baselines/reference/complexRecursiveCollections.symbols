//// [tests/cases/compiler/complexRecursiveCollections.ts] ////

=== complex.ts ===
interface Ara<T> { t: T }
>Ara : Symbol(Ara, Decl(complex.ts, 0, 0))
>T : Symbol(T, Decl(complex.ts, 0, 14))
>t : Symbol(Ara.t, Decl(complex.ts, 0, 18))
>T : Symbol(T, Decl(complex.ts, 0, 14))

interface Collection<K, V> {
>Collection : Symbol(Collection, Decl(complex.ts, 0, 25))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>V : Symbol(V, Decl(complex.ts, 1, 23))

    map<M>(mapper: (value: V, key: K, iter: this) => M): Collection<K, M>;
>map : Symbol(Collection.map, Decl(complex.ts, 1, 28))
>M : Symbol(M, Decl(complex.ts, 2, 8))
>mapper : Symbol(mapper, Decl(complex.ts, 2, 11))
>value : Symbol(value, Decl(complex.ts, 2, 20))
>V : Symbol(V, Decl(complex.ts, 1, 23))
>key : Symbol(key, Decl(complex.ts, 2, 29))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>iter : Symbol(iter, Decl(complex.ts, 2, 37))
>M : Symbol(M, Decl(complex.ts, 2, 8))
>Collection : Symbol(Collection, Decl(complex.ts, 0, 25))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>M : Symbol(M, Decl(complex.ts, 2, 8))

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Ara<M>, context?: any): Collection<K, M>;
>flatMap : Symbol(Collection.flatMap, Decl(complex.ts, 2, 74))
>M : Symbol(M, Decl(complex.ts, 3, 12))
>mapper : Symbol(mapper, Decl(complex.ts, 3, 15))
>value : Symbol(value, Decl(complex.ts, 3, 24))
>V : Symbol(V, Decl(complex.ts, 1, 23))
>key : Symbol(key, Decl(complex.ts, 3, 33))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>iter : Symbol(iter, Decl(complex.ts, 3, 41))
>Ara : Symbol(Ara, Decl(complex.ts, 0, 0))
>M : Symbol(M, Decl(complex.ts, 3, 12))
>context : Symbol(context, Decl(complex.ts, 3, 64))
>Collection : Symbol(Collection, Decl(complex.ts, 0, 25))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>M : Symbol(M, Decl(complex.ts, 3, 12))

    // these seem necessary to push it over the top for memory usage
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
>reduce : Symbol(Collection.reduce, Decl(complex.ts, 3, 98), Decl(complex.ts, 5, 113))
>R : Symbol(R, Decl(complex.ts, 5, 11))
>reducer : Symbol(reducer, Decl(complex.ts, 5, 14))
>reduction : Symbol(reduction, Decl(complex.ts, 5, 24))
>R : Symbol(R, Decl(complex.ts, 5, 11))
>value : Symbol(value, Decl(complex.ts, 5, 37))
>V : Symbol(V, Decl(complex.ts, 1, 23))
>key : Symbol(key, Decl(complex.ts, 5, 47))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>iter : Symbol(iter, Decl(complex.ts, 5, 55))
>R : Symbol(R, Decl(complex.ts, 5, 11))
>initialReduction : Symbol(initialReduction, Decl(complex.ts, 5, 73))
>R : Symbol(R, Decl(complex.ts, 5, 11))
>context : Symbol(context, Decl(complex.ts, 5, 94))
>R : Symbol(R, Decl(complex.ts, 5, 11))

    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
>reduce : Symbol(Collection.reduce, Decl(complex.ts, 3, 98), Decl(complex.ts, 5, 113))
>R : Symbol(R, Decl(complex.ts, 6, 11))
>reducer : Symbol(reducer, Decl(complex.ts, 6, 14))
>reduction : Symbol(reduction, Decl(complex.ts, 6, 24))
>V : Symbol(V, Decl(complex.ts, 1, 23))
>R : Symbol(R, Decl(complex.ts, 6, 11))
>value : Symbol(value, Decl(complex.ts, 6, 41))
>V : Symbol(V, Decl(complex.ts, 1, 23))
>key : Symbol(key, Decl(complex.ts, 6, 51))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>iter : Symbol(iter, Decl(complex.ts, 6, 59))
>R : Symbol(R, Decl(complex.ts, 6, 11))
>R : Symbol(R, Decl(complex.ts, 6, 11))

    toSeq(): Seq<K, V>;
>toSeq : Symbol(Collection.toSeq, Decl(complex.ts, 6, 81))
>Seq : Symbol(Seq, Decl(complex.ts, 8, 1))
>K : Symbol(K, Decl(complex.ts, 1, 21))
>V : Symbol(V, Decl(complex.ts, 1, 23))
}
interface Seq<K, V> extends Collection<K, V> {
>Seq : Symbol(Seq, Decl(complex.ts, 8, 1))
>K : Symbol(K, Decl(complex.ts, 9, 14))
>V : Symbol(V, Decl(complex.ts, 9, 16))
>Collection : Symbol(Collection, Decl(complex.ts, 0, 25))
>K : Symbol(K, Decl(complex.ts, 9, 14))
>V : Symbol(V, Decl(complex.ts, 9, 16))
}
interface N1<T> extends Collection<void, T> {
>N1 : Symbol(N1, Decl(complex.ts, 10, 1))
>T : Symbol(T, Decl(complex.ts, 11, 13))
>Collection : Symbol(Collection, Decl(complex.ts, 0, 25))
>T : Symbol(T, Decl(complex.ts, 11, 13))

    map<M>(mapper: (value: T, key: void, iter: this) => M): N1<M>;
>map : Symbol(N1.map, Decl(complex.ts, 11, 45))
>M : Symbol(M, Decl(complex.ts, 12, 8))
>mapper : Symbol(mapper, Decl(complex.ts, 12, 11))
>value : Symbol(value, Decl(complex.ts, 12, 20))
>T : Symbol(T, Decl(complex.ts, 11, 13))
>key : Symbol(key, Decl(complex.ts, 12, 29))
>iter : Symbol(iter, Decl(complex.ts, 12, 40))
>M : Symbol(M, Decl(complex.ts, 12, 8))
>N1 : Symbol(N1, Decl(complex.ts, 10, 1))
>M : Symbol(M, Decl(complex.ts, 12, 8))

    flatMap<M>(mapper: (value: T, key: void, iter: this) => Ara<M>, context?: any): N1<M>;
>flatMap : Symbol(N1.flatMap, Decl(complex.ts, 12, 66))
>M : Symbol(M, Decl(complex.ts, 13, 12))
>mapper : Symbol(mapper, Decl(complex.ts, 13, 15))
>value : Symbol(value, Decl(complex.ts, 13, 24))
>T : Symbol(T, Decl(complex.ts, 11, 13))
>key : Symbol(key, Decl(complex.ts, 13, 33))
>iter : Symbol(iter, Decl(complex.ts, 13, 44))
>Ara : Symbol(Ara, Decl(complex.ts, 0, 0))
>M : Symbol(M, Decl(complex.ts, 13, 12))
>context : Symbol(context, Decl(complex.ts, 13, 67))
>N1 : Symbol(N1, Decl(complex.ts, 10, 1))
>M : Symbol(M, Decl(complex.ts, 13, 12))
}
interface N2<T> extends N1<T> {
>N2 : Symbol(N2, Decl(complex.ts, 14, 1))
>T : Symbol(T, Decl(complex.ts, 15, 13))
>N1 : Symbol(N1, Decl(complex.ts, 10, 1))
>T : Symbol(T, Decl(complex.ts, 15, 13))

    map<M>(mapper: (value: T, key: void, iter: this) => M): N2<M>;
>map : Symbol(N2.map, Decl(complex.ts, 15, 31))
>M : Symbol(M, Decl(complex.ts, 16, 8))
>mapper : Symbol(mapper, Decl(complex.ts, 16, 11))
>value : Symbol(value, Decl(complex.ts, 16, 20))
>T : Symbol(T, Decl(complex.ts, 15, 13))
>key : Symbol(key, Decl(complex.ts, 16, 29))
>iter : Symbol(iter, Decl(complex.ts, 16, 40))
>M : Symbol(M, Decl(complex.ts, 16, 8))
>N2 : Symbol(N2, Decl(complex.ts, 14, 1))
>M : Symbol(M, Decl(complex.ts, 16, 8))

    flatMap<M>(mapper: (value: T, key: void, iter: this) => Ara<M>, context?: any): N2<M>;
>flatMap : Symbol(N2.flatMap, Decl(complex.ts, 16, 66))
>M : Symbol(M, Decl(complex.ts, 17, 12))
>mapper : Symbol(mapper, Decl(complex.ts, 17, 15))
>value : Symbol(value, Decl(complex.ts, 17, 24))
>T : Symbol(T, Decl(complex.ts, 15, 13))
>key : Symbol(key, Decl(complex.ts, 17, 33))
>iter : Symbol(iter, Decl(complex.ts, 17, 44))
>Ara : Symbol(Ara, Decl(complex.ts, 0, 0))
>M : Symbol(M, Decl(complex.ts, 17, 12))
>context : Symbol(context, Decl(complex.ts, 17, 67))
>N2 : Symbol(N2, Decl(complex.ts, 14, 1))
>M : Symbol(M, Decl(complex.ts, 17, 12))

    toSeq(): N2<T>;
>toSeq : Symbol(N2.toSeq, Decl(complex.ts, 17, 90))
>N2 : Symbol(N2, Decl(complex.ts, 14, 1))
>T : Symbol(T, Decl(complex.ts, 15, 13))
}
=== immutable.ts ===
// Test that complex recursive collections can pass the `extends` assignability check without
// running out of memory. This bug was exposed in Typescript 2.4 when more generic signatures
// started being checked.
declare namespace Immutable {
>Immutable : Symbol(Immutable, Decl(immutable.ts, 0, 0))

  export function fromJS(jsValue: any, reviver?: (key: string | number, sequence: Collection.Keyed<string, any> | Collection.Indexed<any>, path?: Array<string | number>) => any): any;
>fromJS : Symbol(fromJS, Decl(immutable.ts, 3, 29))
>jsValue : Symbol(jsValue, Decl(immutable.ts, 4, 25))
>reviver : Symbol(reviver, Decl(immutable.ts, 4, 38))
>key : Symbol(key, Decl(immutable.ts, 4, 50))
>sequence : Symbol(sequence, Decl(immutable.ts, 4, 71))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>path : Symbol(path, Decl(immutable.ts, 4, 138))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

  export function is(first: any, second: any): boolean;
>is : Symbol(is, Decl(immutable.ts, 4, 183))
>first : Symbol(first, Decl(immutable.ts, 5, 21))
>second : Symbol(second, Decl(immutable.ts, 5, 32))

  export function hash(value: any): number;
>hash : Symbol(hash, Decl(immutable.ts, 5, 55))
>value : Symbol(value, Decl(immutable.ts, 6, 23))

  export function isImmutable(maybeImmutable: any): maybeImmutable is Collection<any, any>;
>isImmutable : Symbol(isImmutable, Decl(immutable.ts, 6, 43))
>maybeImmutable : Symbol(maybeImmutable, Decl(immutable.ts, 7, 30))
>maybeImmutable : Symbol(maybeImmutable, Decl(immutable.ts, 7, 30))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))

  export function isCollection(maybeCollection: any): maybeCollection is Collection<any, any>;
>isCollection : Symbol(isCollection, Decl(immutable.ts, 7, 91))
>maybeCollection : Symbol(maybeCollection, Decl(immutable.ts, 8, 31))
>maybeCollection : Symbol(maybeCollection, Decl(immutable.ts, 8, 31))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))

  export function isKeyed(maybeKeyed: any): maybeKeyed is Collection.Keyed<any, any>;
>isKeyed : Symbol(isKeyed, Decl(immutable.ts, 8, 94))
>maybeKeyed : Symbol(maybeKeyed, Decl(immutable.ts, 9, 26))
>maybeKeyed : Symbol(maybeKeyed, Decl(immutable.ts, 9, 26))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))

  export function isIndexed(maybeIndexed: any): maybeIndexed is Collection.Indexed<any>;
>isIndexed : Symbol(isIndexed, Decl(immutable.ts, 9, 85))
>maybeIndexed : Symbol(maybeIndexed, Decl(immutable.ts, 10, 28))
>maybeIndexed : Symbol(maybeIndexed, Decl(immutable.ts, 10, 28))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))

  export function isAssociative(maybeAssociative: any): maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>;
>isAssociative : Symbol(isAssociative, Decl(immutable.ts, 10, 88))
>maybeAssociative : Symbol(maybeAssociative, Decl(immutable.ts, 11, 32))
>maybeAssociative : Symbol(maybeAssociative, Decl(immutable.ts, 11, 32))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))

  export function isOrdered(maybeOrdered: any): boolean;
>isOrdered : Symbol(isOrdered, Decl(immutable.ts, 11, 129))
>maybeOrdered : Symbol(maybeOrdered, Decl(immutable.ts, 12, 28))

  export function isValueObject(maybeValue: any): maybeValue is ValueObject;
>isValueObject : Symbol(isValueObject, Decl(immutable.ts, 12, 56))
>maybeValue : Symbol(maybeValue, Decl(immutable.ts, 13, 32))
>maybeValue : Symbol(maybeValue, Decl(immutable.ts, 13, 32))
>ValueObject : Symbol(ValueObject, Decl(immutable.ts, 13, 76))

  export interface ValueObject {
>ValueObject : Symbol(ValueObject, Decl(immutable.ts, 13, 76))

    equals(other: any): boolean;
>equals : Symbol(ValueObject.equals, Decl(immutable.ts, 14, 32))
>other : Symbol(other, Decl(immutable.ts, 15, 11))

    hashCode(): number;
>hashCode : Symbol(ValueObject.hashCode, Decl(immutable.ts, 15, 32))
  }
  export namespace List {
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))

    function isList(maybeList: any): maybeList is List<any>;
>isList : Symbol(isList, Decl(immutable.ts, 18, 25))
>maybeList : Symbol(maybeList, Decl(immutable.ts, 19, 20))
>maybeList : Symbol(maybeList, Decl(immutable.ts, 19, 20))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))

    function of<T>(...values: Array<T>): List<T>;
>of : Symbol(of, Decl(immutable.ts, 19, 60))
>T : Symbol(T, Decl(immutable.ts, 20, 16))
>values : Symbol(values, Decl(immutable.ts, 20, 19))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 20, 16))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 20, 16))
  }
  export function List(): List<any>;
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))

  export function List<T>(): List<T>;
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 23, 23))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 23, 23))

  export function List<T>(collection: Iterable<T>): List<T>;
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 24, 23))
>collection : Symbol(collection, Decl(immutable.ts, 24, 26))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 24, 23))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 24, 23))

  export interface List<T> extends Collection.Indexed<T> {
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>Collection.Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    // Persistent changes
    set(index: number, value: T): List<T>;
>set : Symbol(List.set, Decl(immutable.ts, 25, 58))
>index : Symbol(index, Decl(immutable.ts, 27, 8))
>value : Symbol(value, Decl(immutable.ts, 27, 22))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    delete(index: number): List<T>;
>delete : Symbol(List.delete, Decl(immutable.ts, 27, 42))
>index : Symbol(index, Decl(immutable.ts, 28, 11))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    remove(index: number): List<T>;
>remove : Symbol(List.remove, Decl(immutable.ts, 28, 35))
>index : Symbol(index, Decl(immutable.ts, 29, 11))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    insert(index: number, value: T): List<T>;
>insert : Symbol(List.insert, Decl(immutable.ts, 29, 35))
>index : Symbol(index, Decl(immutable.ts, 30, 11))
>value : Symbol(value, Decl(immutable.ts, 30, 25))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    clear(): List<T>;
>clear : Symbol(List.clear, Decl(immutable.ts, 30, 45))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    push(...values: Array<T>): List<T>;
>push : Symbol(List.push, Decl(immutable.ts, 31, 21))
>values : Symbol(values, Decl(immutable.ts, 32, 9))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    pop(): List<T>;
>pop : Symbol(List.pop, Decl(immutable.ts, 32, 39))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    unshift(...values: Array<T>): List<T>;
>unshift : Symbol(List.unshift, Decl(immutable.ts, 33, 19))
>values : Symbol(values, Decl(immutable.ts, 34, 12))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    shift(): List<T>;
>shift : Symbol(List.shift, Decl(immutable.ts, 34, 42))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    update(index: number, notSetValue: T, updater: (value: T) => T): this;
>update : Symbol(List.update, Decl(immutable.ts, 35, 21), Decl(immutable.ts, 36, 74), Decl(immutable.ts, 37, 58))
>index : Symbol(index, Decl(immutable.ts, 36, 11))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 36, 25))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>updater : Symbol(updater, Decl(immutable.ts, 36, 41))
>value : Symbol(value, Decl(immutable.ts, 36, 52))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    update(index: number, updater: (value: T) => T): this;
>update : Symbol(List.update, Decl(immutable.ts, 35, 21), Decl(immutable.ts, 36, 74), Decl(immutable.ts, 37, 58))
>index : Symbol(index, Decl(immutable.ts, 37, 11))
>updater : Symbol(updater, Decl(immutable.ts, 37, 25))
>value : Symbol(value, Decl(immutable.ts, 37, 36))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    update<R>(updater: (value: this) => R): R;
>update : Symbol(List.update, Decl(immutable.ts, 35, 21), Decl(immutable.ts, 36, 74), Decl(immutable.ts, 37, 58))
>R : Symbol(R, Decl(immutable.ts, 38, 11))
>updater : Symbol(updater, Decl(immutable.ts, 38, 14))
>value : Symbol(value, Decl(immutable.ts, 38, 24))
>R : Symbol(R, Decl(immutable.ts, 38, 11))
>R : Symbol(R, Decl(immutable.ts, 38, 11))

    merge(...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>merge : Symbol(List.merge, Decl(immutable.ts, 38, 46))
>collections : Symbol(collections, Decl(immutable.ts, 39, 10))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    mergeWith(merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>mergeWith : Symbol(List.mergeWith, Decl(immutable.ts, 39, 73))
>merger : Symbol(merger, Decl(immutable.ts, 40, 14))
>oldVal : Symbol(oldVal, Decl(immutable.ts, 40, 23))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>newVal : Symbol(newVal, Decl(immutable.ts, 40, 33))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>key : Symbol(key, Decl(immutable.ts, 40, 44))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>collections : Symbol(collections, Decl(immutable.ts, 40, 63))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    mergeDeep(...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>mergeDeep : Symbol(List.mergeDeep, Decl(immutable.ts, 40, 127))
>collections : Symbol(collections, Decl(immutable.ts, 41, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    mergeDeepWith(merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>mergeDeepWith : Symbol(List.mergeDeepWith, Decl(immutable.ts, 41, 77))
>merger : Symbol(merger, Decl(immutable.ts, 42, 18))
>oldVal : Symbol(oldVal, Decl(immutable.ts, 42, 27))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>newVal : Symbol(newVal, Decl(immutable.ts, 42, 37))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>key : Symbol(key, Decl(immutable.ts, 42, 48))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>collections : Symbol(collections, Decl(immutable.ts, 42, 67))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    setSize(size: number): List<T>;
>setSize : Symbol(List.setSize, Decl(immutable.ts, 42, 131))
>size : Symbol(size, Decl(immutable.ts, 43, 12))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))

    // Deep persistent changes
    setIn(keyPath: Iterable<any>, value: any): this;
>setIn : Symbol(List.setIn, Decl(immutable.ts, 43, 35))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 45, 10))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>value : Symbol(value, Decl(immutable.ts, 45, 33))

    deleteIn(keyPath: Iterable<any>): this;
>deleteIn : Symbol(List.deleteIn, Decl(immutable.ts, 45, 52))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 46, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

    removeIn(keyPath: Iterable<any>): this;
>removeIn : Symbol(List.removeIn, Decl(immutable.ts, 46, 43))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 47, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

    updateIn(keyPath: Iterable<any>, notSetValue: any, updater: (value: any) => any): this;
>updateIn : Symbol(List.updateIn, Decl(immutable.ts, 47, 43), Decl(immutable.ts, 48, 91))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 48, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 48, 36))
>updater : Symbol(updater, Decl(immutable.ts, 48, 54))
>value : Symbol(value, Decl(immutable.ts, 48, 65))

    updateIn(keyPath: Iterable<any>, updater: (value: any) => any): this;
>updateIn : Symbol(List.updateIn, Decl(immutable.ts, 47, 43), Decl(immutable.ts, 48, 91))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 49, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>updater : Symbol(updater, Decl(immutable.ts, 49, 36))
>value : Symbol(value, Decl(immutable.ts, 49, 47))

    mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeIn : Symbol(List.mergeIn, Decl(immutable.ts, 49, 73))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 50, 12))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>collections : Symbol(collections, Decl(immutable.ts, 50, 35))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeDeepIn : Symbol(List.mergeDeepIn, Decl(immutable.ts, 50, 70))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 51, 16))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>collections : Symbol(collections, Decl(immutable.ts, 51, 39))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : Symbol(List.withMutations, Decl(immutable.ts, 51, 74))
>mutator : Symbol(mutator, Decl(immutable.ts, 53, 18))
>mutable : Symbol(mutable, Decl(immutable.ts, 53, 28))

    asMutable(): this;
>asMutable : Symbol(List.asMutable, Decl(immutable.ts, 53, 57))

    asImmutable(): this;
>asImmutable : Symbol(List.asImmutable, Decl(immutable.ts, 54, 22))

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): List<T | C>;
>concat : Symbol(List.concat, Decl(immutable.ts, 55, 24))
>C : Symbol(C, Decl(immutable.ts, 57, 11))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 57, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 57, 11))
>C : Symbol(C, Decl(immutable.ts, 57, 11))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>C : Symbol(C, Decl(immutable.ts, 57, 11))

    map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): List<M>;
>map : Symbol(List.map, Decl(immutable.ts, 57, 75))
>M : Symbol(M, Decl(immutable.ts, 58, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 58, 11))
>value : Symbol(value, Decl(immutable.ts, 58, 20))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>key : Symbol(key, Decl(immutable.ts, 58, 29))
>iter : Symbol(iter, Decl(immutable.ts, 58, 42))
>M : Symbol(M, Decl(immutable.ts, 58, 8))
>context : Symbol(context, Decl(immutable.ts, 58, 60))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>M : Symbol(M, Decl(immutable.ts, 58, 8))

    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): List<M>;
>flatMap : Symbol(List.flatMap, Decl(immutable.ts, 58, 85))
>M : Symbol(M, Decl(immutable.ts, 59, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 59, 15))
>value : Symbol(value, Decl(immutable.ts, 59, 24))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>key : Symbol(key, Decl(immutable.ts, 59, 33))
>iter : Symbol(iter, Decl(immutable.ts, 59, 46))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 59, 12))
>context : Symbol(context, Decl(immutable.ts, 59, 74))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>M : Symbol(M, Decl(immutable.ts, 59, 12))

    filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): List<F>;
>filter : Symbol(List.filter, Decl(immutable.ts, 59, 99), Decl(immutable.ts, 60, 112))
>F : Symbol(F, Decl(immutable.ts, 60, 11))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>predicate : Symbol(predicate, Decl(immutable.ts, 60, 24))
>value : Symbol(value, Decl(immutable.ts, 60, 36))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>index : Symbol(index, Decl(immutable.ts, 60, 45))
>iter : Symbol(iter, Decl(immutable.ts, 60, 60))
>value : Symbol(value, Decl(immutable.ts, 60, 36))
>F : Symbol(F, Decl(immutable.ts, 60, 11))
>context : Symbol(context, Decl(immutable.ts, 60, 87))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>F : Symbol(F, Decl(immutable.ts, 60, 11))

    filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : Symbol(List.filter, Decl(immutable.ts, 59, 99), Decl(immutable.ts, 60, 112))
>predicate : Symbol(predicate, Decl(immutable.ts, 61, 11))
>value : Symbol(value, Decl(immutable.ts, 61, 23))
>T : Symbol(T, Decl(immutable.ts, 25, 24))
>index : Symbol(index, Decl(immutable.ts, 61, 32))
>iter : Symbol(iter, Decl(immutable.ts, 61, 47))
>context : Symbol(context, Decl(immutable.ts, 61, 67))
  }
  export namespace Map {
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)

    function isMap(maybeMap: any): maybeMap is Map<any, any>;
>isMap : Symbol(isMap, Decl(immutable.ts, 63, 24))
>maybeMap : Symbol(maybeMap, Decl(immutable.ts, 64, 19))
>maybeMap : Symbol(maybeMap, Decl(immutable.ts, 64, 19))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)

    function of(...keyValues: Array<any>): Map<any, any>;
>of : Symbol(of, Decl(immutable.ts, 64, 61))
>keyValues : Symbol(keyValues, Decl(immutable.ts, 65, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
  }
  export function Map<K, V>(collection: Iterable<[K, V]>): Map<K, V>;
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 67, 22))
>V : Symbol(V, Decl(immutable.ts, 67, 24))
>collection : Symbol(collection, Decl(immutable.ts, 67, 28))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 67, 22))
>V : Symbol(V, Decl(immutable.ts, 67, 24))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 67, 22))
>V : Symbol(V, Decl(immutable.ts, 67, 24))

  export function Map<T>(collection: Iterable<Iterable<T>>): Map<T, T>;
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>T : Symbol(T, Decl(immutable.ts, 68, 22))
>collection : Symbol(collection, Decl(immutable.ts, 68, 25))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 68, 22))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>T : Symbol(T, Decl(immutable.ts, 68, 22))
>T : Symbol(T, Decl(immutable.ts, 68, 22))

  export function Map<V>(obj: {[key: string]: V}): Map<string, V>;
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>V : Symbol(V, Decl(immutable.ts, 69, 22))
>obj : Symbol(obj, Decl(immutable.ts, 69, 25))
>key : Symbol(key, Decl(immutable.ts, 69, 32))
>V : Symbol(V, Decl(immutable.ts, 69, 22))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>V : Symbol(V, Decl(immutable.ts, 69, 22))

  export function Map<K, V>(): Map<K, V>;
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 70, 22))
>V : Symbol(V, Decl(immutable.ts, 70, 24))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 70, 22))
>V : Symbol(V, Decl(immutable.ts, 70, 24))

  export function Map(): Map<any, any>;
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)

  export interface Map<K, V> extends Collection.Keyed<K, V> {
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>Collection.Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    // Persistent changes
    set(key: K, value: V): this;
>set : Symbol(Map.set, Decl(immutable.ts, 72, 61))
>key : Symbol(key, Decl(immutable.ts, 74, 8))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>value : Symbol(value, Decl(immutable.ts, 74, 15))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    delete(key: K): this;
>delete : Symbol(Map.delete, Decl(immutable.ts, 74, 32))
>key : Symbol(key, Decl(immutable.ts, 75, 11))
>K : Symbol(K, Decl(immutable.ts, 72, 23))

    remove(key: K): this;
>remove : Symbol(Map.remove, Decl(immutable.ts, 75, 25))
>key : Symbol(key, Decl(immutable.ts, 76, 11))
>K : Symbol(K, Decl(immutable.ts, 72, 23))

    deleteAll(keys: Iterable<K>): this;
>deleteAll : Symbol(Map.deleteAll, Decl(immutable.ts, 76, 25))
>keys : Symbol(keys, Decl(immutable.ts, 77, 14))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 72, 23))

    removeAll(keys: Iterable<K>): this;
>removeAll : Symbol(Map.removeAll, Decl(immutable.ts, 77, 39))
>keys : Symbol(keys, Decl(immutable.ts, 78, 14))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 72, 23))

    clear(): this;
>clear : Symbol(Map.clear, Decl(immutable.ts, 78, 39))

    update(key: K, notSetValue: V, updater: (value: V) => V): this;
>update : Symbol(Map.update, Decl(immutable.ts, 79, 18), Decl(immutable.ts, 80, 67), Decl(immutable.ts, 81, 51))
>key : Symbol(key, Decl(immutable.ts, 80, 11))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 80, 18))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>updater : Symbol(updater, Decl(immutable.ts, 80, 34))
>value : Symbol(value, Decl(immutable.ts, 80, 45))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    update(key: K, updater: (value: V) => V): this;
>update : Symbol(Map.update, Decl(immutable.ts, 79, 18), Decl(immutable.ts, 80, 67), Decl(immutable.ts, 81, 51))
>key : Symbol(key, Decl(immutable.ts, 81, 11))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>updater : Symbol(updater, Decl(immutable.ts, 81, 18))
>value : Symbol(value, Decl(immutable.ts, 81, 29))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    update<R>(updater: (value: this) => R): R;
>update : Symbol(Map.update, Decl(immutable.ts, 79, 18), Decl(immutable.ts, 80, 67), Decl(immutable.ts, 81, 51))
>R : Symbol(R, Decl(immutable.ts, 82, 11))
>updater : Symbol(updater, Decl(immutable.ts, 82, 14))
>value : Symbol(value, Decl(immutable.ts, 82, 24))
>R : Symbol(R, Decl(immutable.ts, 82, 11))
>R : Symbol(R, Decl(immutable.ts, 82, 11))

    merge(...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>merge : Symbol(Map.merge, Decl(immutable.ts, 82, 46))
>collections : Symbol(collections, Decl(immutable.ts, 83, 10))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 83, 53))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    mergeWith(merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>mergeWith : Symbol(Map.mergeWith, Decl(immutable.ts, 83, 78))
>merger : Symbol(merger, Decl(immutable.ts, 84, 14))
>oldVal : Symbol(oldVal, Decl(immutable.ts, 84, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>newVal : Symbol(newVal, Decl(immutable.ts, 84, 33))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 84, 44))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>collections : Symbol(collections, Decl(immutable.ts, 84, 58))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 84, 102))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    mergeDeep(...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>mergeDeep : Symbol(Map.mergeDeep, Decl(immutable.ts, 84, 127))
>collections : Symbol(collections, Decl(immutable.ts, 85, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 85, 57))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    mergeDeepWith(merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>mergeDeepWith : Symbol(Map.mergeDeepWith, Decl(immutable.ts, 85, 82))
>merger : Symbol(merger, Decl(immutable.ts, 86, 18))
>oldVal : Symbol(oldVal, Decl(immutable.ts, 86, 27))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>newVal : Symbol(newVal, Decl(immutable.ts, 86, 37))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 86, 48))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>collections : Symbol(collections, Decl(immutable.ts, 86, 62))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 86, 106))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    // Deep persistent changes
    setIn(keyPath: Iterable<any>, value: any): this;
>setIn : Symbol(Map.setIn, Decl(immutable.ts, 86, 131))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 88, 10))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>value : Symbol(value, Decl(immutable.ts, 88, 33))

    deleteIn(keyPath: Iterable<any>): this;
>deleteIn : Symbol(Map.deleteIn, Decl(immutable.ts, 88, 52))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 89, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

    removeIn(keyPath: Iterable<any>): this;
>removeIn : Symbol(Map.removeIn, Decl(immutable.ts, 89, 43))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 90, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

    updateIn(keyPath: Iterable<any>, notSetValue: any, updater: (value: any) => any): this;
>updateIn : Symbol(Map.updateIn, Decl(immutable.ts, 90, 43), Decl(immutable.ts, 91, 91))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 91, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 91, 36))
>updater : Symbol(updater, Decl(immutable.ts, 91, 54))
>value : Symbol(value, Decl(immutable.ts, 91, 65))

    updateIn(keyPath: Iterable<any>, updater: (value: any) => any): this;
>updateIn : Symbol(Map.updateIn, Decl(immutable.ts, 90, 43), Decl(immutable.ts, 91, 91))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 92, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>updater : Symbol(updater, Decl(immutable.ts, 92, 36))
>value : Symbol(value, Decl(immutable.ts, 92, 47))

    mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeIn : Symbol(Map.mergeIn, Decl(immutable.ts, 92, 73))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 93, 12))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>collections : Symbol(collections, Decl(immutable.ts, 93, 35))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeDeepIn : Symbol(Map.mergeDeepIn, Decl(immutable.ts, 93, 70))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 94, 16))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>collections : Symbol(collections, Decl(immutable.ts, 94, 39))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : Symbol(Map.withMutations, Decl(immutable.ts, 94, 74))
>mutator : Symbol(mutator, Decl(immutable.ts, 96, 18))
>mutable : Symbol(mutable, Decl(immutable.ts, 96, 28))

    asMutable(): this;
>asMutable : Symbol(Map.asMutable, Decl(immutable.ts, 96, 57))

    asImmutable(): this;
>asImmutable : Symbol(Map.asImmutable, Decl(immutable.ts, 97, 22))

    // Sequence algorithms
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>;
>concat : Symbol(Map.concat, Decl(immutable.ts, 98, 24), Decl(immutable.ts, 100, 83))
>KC : Symbol(KC, Decl(immutable.ts, 100, 11))
>VC : Symbol(VC, Decl(immutable.ts, 100, 14))
>collections : Symbol(collections, Decl(immutable.ts, 100, 19))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>KC : Symbol(KC, Decl(immutable.ts, 100, 11))
>VC : Symbol(VC, Decl(immutable.ts, 100, 14))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>KC : Symbol(KC, Decl(immutable.ts, 100, 11))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>VC : Symbol(VC, Decl(immutable.ts, 100, 14))

    concat<C>(...collections: Array<{[key: string]: C}>): Map<K | string, V | C>;
>concat : Symbol(Map.concat, Decl(immutable.ts, 98, 24), Decl(immutable.ts, 100, 83))
>C : Symbol(C, Decl(immutable.ts, 101, 11))
>collections : Symbol(collections, Decl(immutable.ts, 101, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>key : Symbol(key, Decl(immutable.ts, 101, 38))
>C : Symbol(C, Decl(immutable.ts, 101, 11))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>C : Symbol(C, Decl(immutable.ts, 101, 11))

    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Map<K, M>;
>map : Symbol(Map.map, Decl(immutable.ts, 101, 81))
>M : Symbol(M, Decl(immutable.ts, 102, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 102, 11))
>value : Symbol(value, Decl(immutable.ts, 102, 20))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 102, 29))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>iter : Symbol(iter, Decl(immutable.ts, 102, 37))
>M : Symbol(M, Decl(immutable.ts, 102, 8))
>context : Symbol(context, Decl(immutable.ts, 102, 55))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>M : Symbol(M, Decl(immutable.ts, 102, 8))

    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Map<M, V>;
>mapKeys : Symbol(Map.mapKeys, Decl(immutable.ts, 102, 82))
>M : Symbol(M, Decl(immutable.ts, 103, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 103, 15))
>key : Symbol(key, Decl(immutable.ts, 103, 24))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>value : Symbol(value, Decl(immutable.ts, 103, 31))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>iter : Symbol(iter, Decl(immutable.ts, 103, 41))
>M : Symbol(M, Decl(immutable.ts, 103, 12))
>context : Symbol(context, Decl(immutable.ts, 103, 59))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>M : Symbol(M, Decl(immutable.ts, 103, 12))
>V : Symbol(V, Decl(immutable.ts, 72, 25))

    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Map<KM, VM>;
>mapEntries : Symbol(Map.mapEntries, Decl(immutable.ts, 103, 86))
>KM : Symbol(KM, Decl(immutable.ts, 104, 15))
>VM : Symbol(VM, Decl(immutable.ts, 104, 18))
>mapper : Symbol(mapper, Decl(immutable.ts, 104, 23))
>entry : Symbol(entry, Decl(immutable.ts, 104, 32))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>index : Symbol(index, Decl(immutable.ts, 104, 46))
>iter : Symbol(iter, Decl(immutable.ts, 104, 61))
>KM : Symbol(KM, Decl(immutable.ts, 104, 15))
>VM : Symbol(VM, Decl(immutable.ts, 104, 18))
>context : Symbol(context, Decl(immutable.ts, 104, 86))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>KM : Symbol(KM, Decl(immutable.ts, 104, 15))
>VM : Symbol(VM, Decl(immutable.ts, 104, 18))

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Map<any, any>;
>flatMap : Symbol(Map.flatMap, Decl(immutable.ts, 104, 115))
>M : Symbol(M, Decl(immutable.ts, 105, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 105, 15))
>value : Symbol(value, Decl(immutable.ts, 105, 24))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 105, 33))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>iter : Symbol(iter, Decl(immutable.ts, 105, 41))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 105, 12))
>context : Symbol(context, Decl(immutable.ts, 105, 69))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Map<K, F>;
>filter : Symbol(Map.filter, Decl(immutable.ts, 105, 100), Decl(immutable.ts, 106, 107))
>F : Symbol(F, Decl(immutable.ts, 106, 11))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>predicate : Symbol(predicate, Decl(immutable.ts, 106, 24))
>value : Symbol(value, Decl(immutable.ts, 106, 36))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 106, 45))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>iter : Symbol(iter, Decl(immutable.ts, 106, 53))
>value : Symbol(value, Decl(immutable.ts, 106, 36))
>F : Symbol(F, Decl(immutable.ts, 106, 11))
>context : Symbol(context, Decl(immutable.ts, 106, 80))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>F : Symbol(F, Decl(immutable.ts, 106, 11))

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : Symbol(Map.filter, Decl(immutable.ts, 105, 100), Decl(immutable.ts, 106, 107))
>predicate : Symbol(predicate, Decl(immutable.ts, 107, 11))
>value : Symbol(value, Decl(immutable.ts, 107, 23))
>V : Symbol(V, Decl(immutable.ts, 72, 25))
>key : Symbol(key, Decl(immutable.ts, 107, 32))
>K : Symbol(K, Decl(immutable.ts, 72, 23))
>iter : Symbol(iter, Decl(immutable.ts, 107, 40))
>context : Symbol(context, Decl(immutable.ts, 107, 60))
  }
  export namespace OrderedMap {
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)

    function isOrderedMap(maybeOrderedMap: any): maybeOrderedMap is OrderedMap<any, any>;
>isOrderedMap : Symbol(isOrderedMap, Decl(immutable.ts, 109, 31))
>maybeOrderedMap : Symbol(maybeOrderedMap, Decl(immutable.ts, 110, 26))
>maybeOrderedMap : Symbol(maybeOrderedMap, Decl(immutable.ts, 110, 26))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
  }
  export function OrderedMap<K, V>(collection: Iterable<[K, V]>): OrderedMap<K, V>;
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 112, 29))
>V : Symbol(V, Decl(immutable.ts, 112, 31))
>collection : Symbol(collection, Decl(immutable.ts, 112, 35))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 112, 29))
>V : Symbol(V, Decl(immutable.ts, 112, 31))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 112, 29))
>V : Symbol(V, Decl(immutable.ts, 112, 31))

  export function OrderedMap<T>(collection: Iterable<Iterable<T>>): OrderedMap<T, T>;
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>T : Symbol(T, Decl(immutable.ts, 113, 29))
>collection : Symbol(collection, Decl(immutable.ts, 113, 32))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 113, 29))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>T : Symbol(T, Decl(immutable.ts, 113, 29))
>T : Symbol(T, Decl(immutable.ts, 113, 29))

  export function OrderedMap<V>(obj: {[key: string]: V}): OrderedMap<string, V>;
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>V : Symbol(V, Decl(immutable.ts, 114, 29))
>obj : Symbol(obj, Decl(immutable.ts, 114, 32))
>key : Symbol(key, Decl(immutable.ts, 114, 39))
>V : Symbol(V, Decl(immutable.ts, 114, 29))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>V : Symbol(V, Decl(immutable.ts, 114, 29))

  export function OrderedMap<K, V>(): OrderedMap<K, V>;
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 115, 29))
>V : Symbol(V, Decl(immutable.ts, 115, 31))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 115, 29))
>V : Symbol(V, Decl(immutable.ts, 115, 31))

  export function OrderedMap(): OrderedMap<any, any>;
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)

  export interface OrderedMap<K, V> extends Map<K, V> {
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>V : Symbol(V, Decl(immutable.ts, 117, 32))

    // Sequence algorithms
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): OrderedMap<K | KC, V | VC>;
>concat : Symbol(OrderedMap.concat, Decl(immutable.ts, 117, 55), Decl(immutable.ts, 119, 90))
>KC : Symbol(KC, Decl(immutable.ts, 119, 11))
>VC : Symbol(VC, Decl(immutable.ts, 119, 14))
>collections : Symbol(collections, Decl(immutable.ts, 119, 19))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>KC : Symbol(KC, Decl(immutable.ts, 119, 11))
>VC : Symbol(VC, Decl(immutable.ts, 119, 14))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>KC : Symbol(KC, Decl(immutable.ts, 119, 11))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>VC : Symbol(VC, Decl(immutable.ts, 119, 14))

    concat<C>(...collections: Array<{[key: string]: C}>): OrderedMap<K | string, V | C>;
>concat : Symbol(OrderedMap.concat, Decl(immutable.ts, 117, 55), Decl(immutable.ts, 119, 90))
>C : Symbol(C, Decl(immutable.ts, 120, 11))
>collections : Symbol(collections, Decl(immutable.ts, 120, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>key : Symbol(key, Decl(immutable.ts, 120, 38))
>C : Symbol(C, Decl(immutable.ts, 120, 11))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>C : Symbol(C, Decl(immutable.ts, 120, 11))

    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): OrderedMap<K, M>;
>map : Symbol(OrderedMap.map, Decl(immutable.ts, 120, 88))
>M : Symbol(M, Decl(immutable.ts, 121, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 121, 11))
>value : Symbol(value, Decl(immutable.ts, 121, 20))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>key : Symbol(key, Decl(immutable.ts, 121, 29))
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>iter : Symbol(iter, Decl(immutable.ts, 121, 37))
>M : Symbol(M, Decl(immutable.ts, 121, 8))
>context : Symbol(context, Decl(immutable.ts, 121, 55))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>M : Symbol(M, Decl(immutable.ts, 121, 8))

    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): OrderedMap<M, V>;
>mapKeys : Symbol(OrderedMap.mapKeys, Decl(immutable.ts, 121, 89))
>M : Symbol(M, Decl(immutable.ts, 122, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 122, 15))
>key : Symbol(key, Decl(immutable.ts, 122, 24))
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>value : Symbol(value, Decl(immutable.ts, 122, 31))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>iter : Symbol(iter, Decl(immutable.ts, 122, 41))
>M : Symbol(M, Decl(immutable.ts, 122, 12))
>context : Symbol(context, Decl(immutable.ts, 122, 59))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>M : Symbol(M, Decl(immutable.ts, 122, 12))
>V : Symbol(V, Decl(immutable.ts, 117, 32))

    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): OrderedMap<KM, VM>;
>mapEntries : Symbol(OrderedMap.mapEntries, Decl(immutable.ts, 122, 93))
>KM : Symbol(KM, Decl(immutable.ts, 123, 15))
>VM : Symbol(VM, Decl(immutable.ts, 123, 18))
>mapper : Symbol(mapper, Decl(immutable.ts, 123, 23))
>entry : Symbol(entry, Decl(immutable.ts, 123, 32))
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>index : Symbol(index, Decl(immutable.ts, 123, 46))
>iter : Symbol(iter, Decl(immutable.ts, 123, 61))
>KM : Symbol(KM, Decl(immutable.ts, 123, 15))
>VM : Symbol(VM, Decl(immutable.ts, 123, 18))
>context : Symbol(context, Decl(immutable.ts, 123, 86))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>KM : Symbol(KM, Decl(immutable.ts, 123, 15))
>VM : Symbol(VM, Decl(immutable.ts, 123, 18))

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): OrderedMap<any, any>;
>flatMap : Symbol(OrderedMap.flatMap, Decl(immutable.ts, 123, 122))
>M : Symbol(M, Decl(immutable.ts, 124, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 124, 15))
>value : Symbol(value, Decl(immutable.ts, 124, 24))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>key : Symbol(key, Decl(immutable.ts, 124, 33))
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>iter : Symbol(iter, Decl(immutable.ts, 124, 41))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 124, 12))
>context : Symbol(context, Decl(immutable.ts, 124, 69))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): OrderedMap<K, F>;
>filter : Symbol(OrderedMap.filter, Decl(immutable.ts, 124, 107), Decl(immutable.ts, 125, 114))
>F : Symbol(F, Decl(immutable.ts, 125, 11))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>predicate : Symbol(predicate, Decl(immutable.ts, 125, 24))
>value : Symbol(value, Decl(immutable.ts, 125, 36))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>key : Symbol(key, Decl(immutable.ts, 125, 45))
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>iter : Symbol(iter, Decl(immutable.ts, 125, 53))
>value : Symbol(value, Decl(immutable.ts, 125, 36))
>F : Symbol(F, Decl(immutable.ts, 125, 11))
>context : Symbol(context, Decl(immutable.ts, 125, 80))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>F : Symbol(F, Decl(immutable.ts, 125, 11))

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : Symbol(OrderedMap.filter, Decl(immutable.ts, 124, 107), Decl(immutable.ts, 125, 114))
>predicate : Symbol(predicate, Decl(immutable.ts, 126, 11))
>value : Symbol(value, Decl(immutable.ts, 126, 23))
>V : Symbol(V, Decl(immutable.ts, 117, 32))
>key : Symbol(key, Decl(immutable.ts, 126, 32))
>K : Symbol(K, Decl(immutable.ts, 117, 30))
>iter : Symbol(iter, Decl(immutable.ts, 126, 40))
>context : Symbol(context, Decl(immutable.ts, 126, 60))
  }
  export namespace Set {
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))

    function isSet(maybeSet: any): maybeSet is Set<any>;
>isSet : Symbol(isSet, Decl(immutable.ts, 128, 24))
>maybeSet : Symbol(maybeSet, Decl(immutable.ts, 129, 19))
>maybeSet : Symbol(maybeSet, Decl(immutable.ts, 129, 19))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))

    function of<T>(...values: Array<T>): Set<T>;
>of : Symbol(of, Decl(immutable.ts, 129, 56))
>T : Symbol(T, Decl(immutable.ts, 130, 16))
>values : Symbol(values, Decl(immutable.ts, 130, 19))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 130, 16))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 130, 16))

    function fromKeys<T>(iter: Collection<T, any>): Set<T>;
>fromKeys : Symbol(fromKeys, Decl(immutable.ts, 130, 48), Decl(immutable.ts, 131, 59))
>T : Symbol(T, Decl(immutable.ts, 131, 22))
>iter : Symbol(iter, Decl(immutable.ts, 131, 25))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 131, 22))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 131, 22))

    function fromKeys(obj: {[key: string]: any}): Set<string>;
>fromKeys : Symbol(fromKeys, Decl(immutable.ts, 130, 48), Decl(immutable.ts, 131, 59))
>obj : Symbol(obj, Decl(immutable.ts, 132, 22))
>key : Symbol(key, Decl(immutable.ts, 132, 29))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))

    function intersect<T>(sets: Iterable<Iterable<T>>): Set<T>;
>intersect : Symbol(intersect, Decl(immutable.ts, 132, 62))
>T : Symbol(T, Decl(immutable.ts, 133, 23))
>sets : Symbol(sets, Decl(immutable.ts, 133, 26))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 133, 23))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 133, 23))

    function union<T>(sets: Iterable<Iterable<T>>): Set<T>;
>union : Symbol(union, Decl(immutable.ts, 133, 63))
>T : Symbol(T, Decl(immutable.ts, 134, 19))
>sets : Symbol(sets, Decl(immutable.ts, 134, 22))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 134, 19))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 134, 19))
  }
  export function Set(): Set<any>;
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))

  export function Set<T>(): Set<T>;
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 137, 22))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 137, 22))

  export function Set<T>(collection: Iterable<T>): Set<T>;
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 138, 22))
>collection : Symbol(collection, Decl(immutable.ts, 138, 25))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 138, 22))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 138, 22))

  export interface Set<T> extends Collection.Set<T> {
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>Collection.Set : Symbol(Collection.Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Collection.Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    // Persistent changes
    add(value: T): this;
>add : Symbol(Set.add, Decl(immutable.ts, 139, 53))
>value : Symbol(value, Decl(immutable.ts, 141, 8))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    delete(value: T): this;
>delete : Symbol(Set.delete, Decl(immutable.ts, 141, 24))
>value : Symbol(value, Decl(immutable.ts, 142, 11))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    remove(value: T): this;
>remove : Symbol(Set.remove, Decl(immutable.ts, 142, 27))
>value : Symbol(value, Decl(immutable.ts, 143, 11))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    clear(): this;
>clear : Symbol(Set.clear, Decl(immutable.ts, 143, 27))

    union(...collections: Array<Collection<any, T> | Array<T>>): this;
>union : Symbol(Set.union, Decl(immutable.ts, 144, 18))
>collections : Symbol(collections, Decl(immutable.ts, 145, 10))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    merge(...collections: Array<Collection<any, T> | Array<T>>): this;
>merge : Symbol(Set.merge, Decl(immutable.ts, 145, 70))
>collections : Symbol(collections, Decl(immutable.ts, 146, 10))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    intersect(...collections: Array<Collection<any, T> | Array<T>>): this;
>intersect : Symbol(Set.intersect, Decl(immutable.ts, 146, 70))
>collections : Symbol(collections, Decl(immutable.ts, 147, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    subtract(...collections: Array<Collection<any, T> | Array<T>>): this;
>subtract : Symbol(Set.subtract, Decl(immutable.ts, 147, 74))
>collections : Symbol(collections, Decl(immutable.ts, 148, 13))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 139, 23))

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : Symbol(Set.withMutations, Decl(immutable.ts, 148, 73))
>mutator : Symbol(mutator, Decl(immutable.ts, 150, 18))
>mutable : Symbol(mutable, Decl(immutable.ts, 150, 28))

    asMutable(): this;
>asMutable : Symbol(Set.asMutable, Decl(immutable.ts, 150, 57))

    asImmutable(): this;
>asImmutable : Symbol(Set.asImmutable, Decl(immutable.ts, 151, 22))

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Set<T | C>;
>concat : Symbol(Set.concat, Decl(immutable.ts, 152, 24))
>C : Symbol(C, Decl(immutable.ts, 154, 11))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 154, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 154, 11))
>C : Symbol(C, Decl(immutable.ts, 154, 11))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>C : Symbol(C, Decl(immutable.ts, 154, 11))

    map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Set<M>;
>map : Symbol(Set.map, Decl(immutable.ts, 154, 74))
>M : Symbol(M, Decl(immutable.ts, 155, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 155, 11))
>value : Symbol(value, Decl(immutable.ts, 155, 20))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>key : Symbol(key, Decl(immutable.ts, 155, 29))
>iter : Symbol(iter, Decl(immutable.ts, 155, 41))
>M : Symbol(M, Decl(immutable.ts, 155, 8))
>context : Symbol(context, Decl(immutable.ts, 155, 59))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>M : Symbol(M, Decl(immutable.ts, 155, 8))

    flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any): Set<M>;
>flatMap : Symbol(Set.flatMap, Decl(immutable.ts, 155, 83))
>M : Symbol(M, Decl(immutable.ts, 156, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 156, 15))
>value : Symbol(value, Decl(immutable.ts, 156, 24))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>key : Symbol(key, Decl(immutable.ts, 156, 33))
>iter : Symbol(iter, Decl(immutable.ts, 156, 45))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 156, 12))
>context : Symbol(context, Decl(immutable.ts, 156, 73))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>M : Symbol(M, Decl(immutable.ts, 156, 12))

    filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Set<F>;
>filter : Symbol(Set.filter, Decl(immutable.ts, 156, 97), Decl(immutable.ts, 157, 108))
>F : Symbol(F, Decl(immutable.ts, 157, 11))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>predicate : Symbol(predicate, Decl(immutable.ts, 157, 24))
>value : Symbol(value, Decl(immutable.ts, 157, 36))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>key : Symbol(key, Decl(immutable.ts, 157, 45))
>iter : Symbol(iter, Decl(immutable.ts, 157, 57))
>value : Symbol(value, Decl(immutable.ts, 157, 36))
>F : Symbol(F, Decl(immutable.ts, 157, 11))
>context : Symbol(context, Decl(immutable.ts, 157, 84))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>F : Symbol(F, Decl(immutable.ts, 157, 11))

    filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : Symbol(Set.filter, Decl(immutable.ts, 156, 97), Decl(immutable.ts, 157, 108))
>predicate : Symbol(predicate, Decl(immutable.ts, 158, 11))
>value : Symbol(value, Decl(immutable.ts, 158, 23))
>T : Symbol(T, Decl(immutable.ts, 139, 23))
>key : Symbol(key, Decl(immutable.ts, 158, 32))
>iter : Symbol(iter, Decl(immutable.ts, 158, 44))
>context : Symbol(context, Decl(immutable.ts, 158, 64))
  }
  export namespace OrderedSet {
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))

    function isOrderedSet(maybeOrderedSet: any): boolean;
>isOrderedSet : Symbol(isOrderedSet, Decl(immutable.ts, 160, 31))
>maybeOrderedSet : Symbol(maybeOrderedSet, Decl(immutable.ts, 161, 26))

    function of<T>(...values: Array<T>): OrderedSet<T>;
>of : Symbol(of, Decl(immutable.ts, 161, 57))
>T : Symbol(T, Decl(immutable.ts, 162, 16))
>values : Symbol(values, Decl(immutable.ts, 162, 19))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 162, 16))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 162, 16))

    function fromKeys<T>(iter: Collection<T, any>): OrderedSet<T>;
>fromKeys : Symbol(fromKeys, Decl(immutable.ts, 162, 55), Decl(immutable.ts, 163, 66))
>T : Symbol(T, Decl(immutable.ts, 163, 22))
>iter : Symbol(iter, Decl(immutable.ts, 163, 25))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 163, 22))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 163, 22))

    function fromKeys(obj: {[key: string]: any}): OrderedSet<string>;
>fromKeys : Symbol(fromKeys, Decl(immutable.ts, 162, 55), Decl(immutable.ts, 163, 66))
>obj : Symbol(obj, Decl(immutable.ts, 164, 22))
>key : Symbol(key, Decl(immutable.ts, 164, 29))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
  }
  export function OrderedSet(): OrderedSet<any>;
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))

  export function OrderedSet<T>(): OrderedSet<T>;
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 167, 29))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 167, 29))

  export function OrderedSet<T>(collection: Iterable<T>): OrderedSet<T>;
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 168, 29))
>collection : Symbol(collection, Decl(immutable.ts, 168, 32))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 168, 29))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 168, 29))

  export interface OrderedSet<T> extends Set<T> {
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>T : Symbol(T, Decl(immutable.ts, 169, 30))

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): OrderedSet<T | C>;
>concat : Symbol(OrderedSet.concat, Decl(immutable.ts, 169, 49))
>C : Symbol(C, Decl(immutable.ts, 171, 11))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 171, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 171, 11))
>C : Symbol(C, Decl(immutable.ts, 171, 11))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>C : Symbol(C, Decl(immutable.ts, 171, 11))

    map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): OrderedSet<M>;
>map : Symbol(OrderedSet.map, Decl(immutable.ts, 171, 81))
>M : Symbol(M, Decl(immutable.ts, 172, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 172, 11))
>value : Symbol(value, Decl(immutable.ts, 172, 20))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>key : Symbol(key, Decl(immutable.ts, 172, 29))
>iter : Symbol(iter, Decl(immutable.ts, 172, 41))
>M : Symbol(M, Decl(immutable.ts, 172, 8))
>context : Symbol(context, Decl(immutable.ts, 172, 59))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>M : Symbol(M, Decl(immutable.ts, 172, 8))

    flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any): OrderedSet<M>;
>flatMap : Symbol(OrderedSet.flatMap, Decl(immutable.ts, 172, 90))
>M : Symbol(M, Decl(immutable.ts, 173, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 173, 15))
>value : Symbol(value, Decl(immutable.ts, 173, 24))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>key : Symbol(key, Decl(immutable.ts, 173, 33))
>iter : Symbol(iter, Decl(immutable.ts, 173, 45))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 173, 12))
>context : Symbol(context, Decl(immutable.ts, 173, 73))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>M : Symbol(M, Decl(immutable.ts, 173, 12))

    filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): OrderedSet<F>;
>filter : Symbol(OrderedSet.filter, Decl(immutable.ts, 173, 104), Decl(immutable.ts, 174, 115))
>F : Symbol(F, Decl(immutable.ts, 174, 11))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>predicate : Symbol(predicate, Decl(immutable.ts, 174, 24))
>value : Symbol(value, Decl(immutable.ts, 174, 36))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>key : Symbol(key, Decl(immutable.ts, 174, 45))
>iter : Symbol(iter, Decl(immutable.ts, 174, 57))
>value : Symbol(value, Decl(immutable.ts, 174, 36))
>F : Symbol(F, Decl(immutable.ts, 174, 11))
>context : Symbol(context, Decl(immutable.ts, 174, 84))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>F : Symbol(F, Decl(immutable.ts, 174, 11))

    filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : Symbol(OrderedSet.filter, Decl(immutable.ts, 173, 104), Decl(immutable.ts, 174, 115))
>predicate : Symbol(predicate, Decl(immutable.ts, 175, 11))
>value : Symbol(value, Decl(immutable.ts, 175, 23))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>key : Symbol(key, Decl(immutable.ts, 175, 32))
>iter : Symbol(iter, Decl(immutable.ts, 175, 44))
>context : Symbol(context, Decl(immutable.ts, 175, 64))

    zip(...collections: Array<Collection<any, any>>): OrderedSet<any>;
>zip : Symbol(OrderedSet.zip, Decl(immutable.ts, 175, 86))
>collections : Symbol(collections, Decl(immutable.ts, 176, 8))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))

    zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): OrderedSet<Z>;
>zipWith : Symbol(OrderedSet.zipWith, Decl(immutable.ts, 176, 70), Decl(immutable.ts, 177, 110), Decl(immutable.ts, 178, 165))
>U : Symbol(U, Decl(immutable.ts, 177, 12))
>Z : Symbol(Z, Decl(immutable.ts, 177, 14))
>zipper : Symbol(zipper, Decl(immutable.ts, 177, 18))
>value : Symbol(value, Decl(immutable.ts, 177, 27))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>otherValue : Symbol(otherValue, Decl(immutable.ts, 177, 36))
>U : Symbol(U, Decl(immutable.ts, 177, 12))
>Z : Symbol(Z, Decl(immutable.ts, 177, 14))
>otherCollection : Symbol(otherCollection, Decl(immutable.ts, 177, 57))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>U : Symbol(U, Decl(immutable.ts, 177, 12))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>Z : Symbol(Z, Decl(immutable.ts, 177, 14))

    zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z>;
>zipWith : Symbol(OrderedSet.zipWith, Decl(immutable.ts, 176, 70), Decl(immutable.ts, 177, 110), Decl(immutable.ts, 178, 165))
>U : Symbol(U, Decl(immutable.ts, 178, 12))
>V : Symbol(V, Decl(immutable.ts, 178, 14))
>Z : Symbol(Z, Decl(immutable.ts, 178, 17))
>zipper : Symbol(zipper, Decl(immutable.ts, 178, 21))
>value : Symbol(value, Decl(immutable.ts, 178, 30))
>T : Symbol(T, Decl(immutable.ts, 169, 30))
>otherValue : Symbol(otherValue, Decl(immutable.ts, 178, 39))
>U : Symbol(U, Decl(immutable.ts, 178, 12))
>thirdValue : Symbol(thirdValue, Decl(immutable.ts, 178, 54))
>V : Symbol(V, Decl(immutable.ts, 178, 14))
>Z : Symbol(Z, Decl(immutable.ts, 178, 17))
>otherCollection : Symbol(otherCollection, Decl(immutable.ts, 178, 75))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>U : Symbol(U, Decl(immutable.ts, 178, 12))
>thirdCollection : Symbol(thirdCollection, Decl(immutable.ts, 178, 112))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>V : Symbol(V, Decl(immutable.ts, 178, 14))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>Z : Symbol(Z, Decl(immutable.ts, 178, 17))

    zipWith<Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): OrderedSet<Z>;
>zipWith : Symbol(OrderedSet.zipWith, Decl(immutable.ts, 176, 70), Decl(immutable.ts, 177, 110), Decl(immutable.ts, 178, 165))
>Z : Symbol(Z, Decl(immutable.ts, 179, 12))
>zipper : Symbol(zipper, Decl(immutable.ts, 179, 15))
>any : Symbol(any, Decl(immutable.ts, 179, 24))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Z : Symbol(Z, Decl(immutable.ts, 179, 12))
>collections : Symbol(collections, Decl(immutable.ts, 179, 49))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>Z : Symbol(Z, Decl(immutable.ts, 179, 12))
  }
  export namespace Stack {
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))

    function isStack(maybeStack: any): maybeStack is Stack<any>;
>isStack : Symbol(isStack, Decl(immutable.ts, 181, 26))
>maybeStack : Symbol(maybeStack, Decl(immutable.ts, 182, 21))
>maybeStack : Symbol(maybeStack, Decl(immutable.ts, 182, 21))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))

    function of<T>(...values: Array<T>): Stack<T>;
>of : Symbol(of, Decl(immutable.ts, 182, 64))
>T : Symbol(T, Decl(immutable.ts, 183, 16))
>values : Symbol(values, Decl(immutable.ts, 183, 19))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 183, 16))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 183, 16))
  }
  export function Stack(): Stack<any>;
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))

  export function Stack<T>(): Stack<T>;
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 186, 24))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 186, 24))

  export function Stack<T>(collection: Iterable<T>): Stack<T>;
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 187, 24))
>collection : Symbol(collection, Decl(immutable.ts, 187, 27))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 187, 24))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 187, 24))

  export interface Stack<T> extends Collection.Indexed<T> {
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>Collection.Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    // Reading values
    peek(): T | undefined;
>peek : Symbol(Stack.peek, Decl(immutable.ts, 188, 59))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    // Persistent changes
    clear(): Stack<T>;
>clear : Symbol(Stack.clear, Decl(immutable.ts, 190, 26))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    unshift(...values: Array<T>): Stack<T>;
>unshift : Symbol(Stack.unshift, Decl(immutable.ts, 192, 22))
>values : Symbol(values, Decl(immutable.ts, 193, 12))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    unshiftAll(iter: Iterable<T>): Stack<T>;
>unshiftAll : Symbol(Stack.unshiftAll, Decl(immutable.ts, 193, 43))
>iter : Symbol(iter, Decl(immutable.ts, 194, 15))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    shift(): Stack<T>;
>shift : Symbol(Stack.shift, Decl(immutable.ts, 194, 44))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    push(...values: Array<T>): Stack<T>;
>push : Symbol(Stack.push, Decl(immutable.ts, 195, 22))
>values : Symbol(values, Decl(immutable.ts, 196, 9))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    pushAll(iter: Iterable<T>): Stack<T>;
>pushAll : Symbol(Stack.pushAll, Decl(immutable.ts, 196, 40))
>iter : Symbol(iter, Decl(immutable.ts, 197, 12))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    pop(): Stack<T>;
>pop : Symbol(Stack.pop, Decl(immutable.ts, 197, 41))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : Symbol(Stack.withMutations, Decl(immutable.ts, 198, 20))
>mutator : Symbol(mutator, Decl(immutable.ts, 200, 18))
>mutable : Symbol(mutable, Decl(immutable.ts, 200, 28))

    asMutable(): this;
>asMutable : Symbol(Stack.asMutable, Decl(immutable.ts, 200, 57))

    asImmutable(): this;
>asImmutable : Symbol(Stack.asImmutable, Decl(immutable.ts, 201, 22))

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Stack<T | C>;
>concat : Symbol(Stack.concat, Decl(immutable.ts, 202, 24))
>C : Symbol(C, Decl(immutable.ts, 204, 11))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 204, 14))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 204, 11))
>C : Symbol(C, Decl(immutable.ts, 204, 11))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>C : Symbol(C, Decl(immutable.ts, 204, 11))

    map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Stack<M>;
>map : Symbol(Stack.map, Decl(immutable.ts, 204, 76))
>M : Symbol(M, Decl(immutable.ts, 205, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 205, 11))
>value : Symbol(value, Decl(immutable.ts, 205, 20))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>key : Symbol(key, Decl(immutable.ts, 205, 29))
>iter : Symbol(iter, Decl(immutable.ts, 205, 42))
>M : Symbol(M, Decl(immutable.ts, 205, 8))
>context : Symbol(context, Decl(immutable.ts, 205, 60))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>M : Symbol(M, Decl(immutable.ts, 205, 8))

    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Stack<M>;
>flatMap : Symbol(Stack.flatMap, Decl(immutable.ts, 205, 86))
>M : Symbol(M, Decl(immutable.ts, 206, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 206, 15))
>value : Symbol(value, Decl(immutable.ts, 206, 24))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>key : Symbol(key, Decl(immutable.ts, 206, 33))
>iter : Symbol(iter, Decl(immutable.ts, 206, 46))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 206, 12))
>context : Symbol(context, Decl(immutable.ts, 206, 74))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>M : Symbol(M, Decl(immutable.ts, 206, 12))

    filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Set<F>;
>filter : Symbol(Stack.filter, Decl(immutable.ts, 206, 100), Decl(immutable.ts, 207, 111))
>F : Symbol(F, Decl(immutable.ts, 207, 11))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>predicate : Symbol(predicate, Decl(immutable.ts, 207, 24))
>value : Symbol(value, Decl(immutable.ts, 207, 36))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>index : Symbol(index, Decl(immutable.ts, 207, 45))
>iter : Symbol(iter, Decl(immutable.ts, 207, 60))
>value : Symbol(value, Decl(immutable.ts, 207, 36))
>F : Symbol(F, Decl(immutable.ts, 207, 11))
>context : Symbol(context, Decl(immutable.ts, 207, 87))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>F : Symbol(F, Decl(immutable.ts, 207, 11))

    filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : Symbol(Stack.filter, Decl(immutable.ts, 206, 100), Decl(immutable.ts, 207, 111))
>predicate : Symbol(predicate, Decl(immutable.ts, 208, 11))
>value : Symbol(value, Decl(immutable.ts, 208, 23))
>T : Symbol(T, Decl(immutable.ts, 188, 25))
>index : Symbol(index, Decl(immutable.ts, 208, 32))
>iter : Symbol(iter, Decl(immutable.ts, 208, 47))
>context : Symbol(context, Decl(immutable.ts, 208, 67))
  }
  export function Range(start?: number, end?: number, step?: number): Seq.Indexed<number>;
>Range : Symbol(Range, Decl(immutable.ts, 209, 3))
>start : Symbol(start, Decl(immutable.ts, 210, 24))
>end : Symbol(end, Decl(immutable.ts, 210, 39))
>step : Symbol(step, Decl(immutable.ts, 210, 53))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))

  export function Repeat<T>(value: T, times?: number): Seq.Indexed<T>;
>Repeat : Symbol(Repeat, Decl(immutable.ts, 210, 90))
>T : Symbol(T, Decl(immutable.ts, 211, 25))
>value : Symbol(value, Decl(immutable.ts, 211, 28))
>T : Symbol(T, Decl(immutable.ts, 211, 25))
>times : Symbol(times, Decl(immutable.ts, 211, 37))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 211, 25))

  export namespace Record {
>Record : Symbol(Record, Decl(immutable.ts, 259, 3), Decl(immutable.ts, 211, 70))

    export function isRecord(maybeRecord: any): maybeRecord is Record.Instance<any>;
>isRecord : Symbol(isRecord, Decl(immutable.ts, 212, 27))
>maybeRecord : Symbol(maybeRecord, Decl(immutable.ts, 213, 29))
>maybeRecord : Symbol(maybeRecord, Decl(immutable.ts, 213, 29))
>Record : Symbol(Record, Decl(immutable.ts, 259, 3), Decl(immutable.ts, 211, 70))
>Instance : Symbol(Instance, Decl(immutable.ts, 218, 5))

    export function getDescriptiveName(record: Instance<any>): string;
>getDescriptiveName : Symbol(getDescriptiveName, Decl(immutable.ts, 213, 84))
>record : Symbol(record, Decl(immutable.ts, 214, 39))
>Instance : Symbol(Instance, Decl(immutable.ts, 218, 5))

    export interface Class<T extends Object> {
>Class : Symbol(Class, Decl(immutable.ts, 214, 70))
>T : Symbol(T, Decl(immutable.ts, 215, 27))
>Object : Symbol(Object, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))

      (values?: Partial<T> | Iterable<[string, any]>): Instance<T> & Readonly<T>;
>values : Symbol(values, Decl(immutable.ts, 216, 7))
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 215, 27))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>Instance : Symbol(Instance, Decl(immutable.ts, 218, 5))
>T : Symbol(T, Decl(immutable.ts, 215, 27))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 215, 27))

      new (values?: Partial<T> | Iterable<[string, any]>): Instance<T> & Readonly<T>;
>values : Symbol(values, Decl(immutable.ts, 217, 11))
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 215, 27))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>Instance : Symbol(Instance, Decl(immutable.ts, 218, 5))
>T : Symbol(T, Decl(immutable.ts, 215, 27))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 215, 27))
    }
    export interface Instance<T extends Object> {
>Instance : Symbol(Instance, Decl(immutable.ts, 218, 5))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>Object : Symbol(Object, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))

      readonly size: number;
>size : Symbol(Instance.size, Decl(immutable.ts, 219, 49))

      // Reading values
      has(key: string): boolean;
>has : Symbol(Instance.has, Decl(immutable.ts, 220, 28))
>key : Symbol(key, Decl(immutable.ts, 222, 10))

      get<K extends keyof T>(key: K): T[K];
>get : Symbol(Instance.get, Decl(immutable.ts, 222, 32))
>K : Symbol(K, Decl(immutable.ts, 223, 10))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>key : Symbol(key, Decl(immutable.ts, 223, 29))
>K : Symbol(K, Decl(immutable.ts, 223, 10))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>K : Symbol(K, Decl(immutable.ts, 223, 10))

      // Reading deep values
      hasIn(keyPath: Iterable<any>): boolean;
>hasIn : Symbol(Instance.hasIn, Decl(immutable.ts, 223, 43))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 225, 12))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      getIn(keyPath: Iterable<any>): any;
>getIn : Symbol(Instance.getIn, Decl(immutable.ts, 225, 45))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 226, 12))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      // Value equality
      equals(other: any): boolean;
>equals : Symbol(Instance.equals, Decl(immutable.ts, 226, 41))
>other : Symbol(other, Decl(immutable.ts, 228, 13))

      hashCode(): number;
>hashCode : Symbol(Instance.hashCode, Decl(immutable.ts, 228, 34))

      // Persistent changes
      set<K extends keyof T>(key: K, value: T[K]): this;
>set : Symbol(Instance.set, Decl(immutable.ts, 229, 25))
>K : Symbol(K, Decl(immutable.ts, 231, 10))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>key : Symbol(key, Decl(immutable.ts, 231, 29))
>K : Symbol(K, Decl(immutable.ts, 231, 10))
>value : Symbol(value, Decl(immutable.ts, 231, 36))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>K : Symbol(K, Decl(immutable.ts, 231, 10))

      update<K extends keyof T>(key: K, updater: (value: T[K]) => T[K]): this;
>update : Symbol(Instance.update, Decl(immutable.ts, 231, 56))
>K : Symbol(K, Decl(immutable.ts, 232, 13))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>key : Symbol(key, Decl(immutable.ts, 232, 32))
>K : Symbol(K, Decl(immutable.ts, 232, 13))
>updater : Symbol(updater, Decl(immutable.ts, 232, 39))
>value : Symbol(value, Decl(immutable.ts, 232, 50))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>K : Symbol(K, Decl(immutable.ts, 232, 13))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>K : Symbol(K, Decl(immutable.ts, 232, 13))

      merge(...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>merge : Symbol(Instance.merge, Decl(immutable.ts, 232, 78))
>collections : Symbol(collections, Decl(immutable.ts, 233, 12))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      mergeDeep(...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>mergeDeep : Symbol(Instance.mergeDeep, Decl(immutable.ts, 233, 79))
>collections : Symbol(collections, Decl(immutable.ts, 234, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      mergeWith(merger: (oldVal: any, newVal: any, key: keyof T) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>mergeWith : Symbol(Instance.mergeWith, Decl(immutable.ts, 234, 83))
>merger : Symbol(merger, Decl(immutable.ts, 235, 16))
>oldVal : Symbol(oldVal, Decl(immutable.ts, 235, 25))
>newVal : Symbol(newVal, Decl(immutable.ts, 235, 37))
>key : Symbol(key, Decl(immutable.ts, 235, 50))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>collections : Symbol(collections, Decl(immutable.ts, 235, 72))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      mergeDeepWith(merger: (oldVal: any, newVal: any, key: any) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>mergeDeepWith : Symbol(Instance.mergeDeepWith, Decl(immutable.ts, 235, 140))
>merger : Symbol(merger, Decl(immutable.ts, 236, 20))
>oldVal : Symbol(oldVal, Decl(immutable.ts, 236, 29))
>newVal : Symbol(newVal, Decl(immutable.ts, 236, 41))
>key : Symbol(key, Decl(immutable.ts, 236, 54))
>collections : Symbol(collections, Decl(immutable.ts, 236, 72))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      delete<K extends keyof T>(key: K): this;
>delete : Symbol(Instance.delete, Decl(immutable.ts, 236, 140))
>K : Symbol(K, Decl(immutable.ts, 237, 13))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>key : Symbol(key, Decl(immutable.ts, 237, 32))
>K : Symbol(K, Decl(immutable.ts, 237, 13))

      remove<K extends keyof T>(key: K): this;
>remove : Symbol(Instance.remove, Decl(immutable.ts, 237, 46))
>K : Symbol(K, Decl(immutable.ts, 238, 13))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>key : Symbol(key, Decl(immutable.ts, 238, 32))
>K : Symbol(K, Decl(immutable.ts, 238, 13))

      clear(): this;
>clear : Symbol(Instance.clear, Decl(immutable.ts, 238, 46))

      // Deep persistent changes
      setIn(keyPath: Iterable<any>, value: any): this;
>setIn : Symbol(Instance.setIn, Decl(immutable.ts, 239, 20))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 241, 12))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>value : Symbol(value, Decl(immutable.ts, 241, 35))

      updateIn(keyPath: Iterable<any>, updater: (value: any) => any): this;
>updateIn : Symbol(Instance.updateIn, Decl(immutable.ts, 241, 54))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 242, 15))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>updater : Symbol(updater, Decl(immutable.ts, 242, 38))
>value : Symbol(value, Decl(immutable.ts, 242, 49))

      mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeIn : Symbol(Instance.mergeIn, Decl(immutable.ts, 242, 75))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 243, 14))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>collections : Symbol(collections, Decl(immutable.ts, 243, 37))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

      mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeDeepIn : Symbol(Instance.mergeDeepIn, Decl(immutable.ts, 243, 72))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 244, 18))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>collections : Symbol(collections, Decl(immutable.ts, 244, 41))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

      deleteIn(keyPath: Iterable<any>): this;
>deleteIn : Symbol(Instance.deleteIn, Decl(immutable.ts, 244, 76))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 245, 15))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      removeIn(keyPath: Iterable<any>): this;
>removeIn : Symbol(Instance.removeIn, Decl(immutable.ts, 245, 45))
>keyPath : Symbol(keyPath, Decl(immutable.ts, 246, 15))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

      // Conversion to JavaScript types
      toJS(): { [K in keyof T]: any };
>toJS : Symbol(Instance.toJS, Decl(immutable.ts, 246, 45))
>K : Symbol(K, Decl(immutable.ts, 248, 17))
>T : Symbol(T, Decl(immutable.ts, 219, 30))

      toJSON(): T;
>toJSON : Symbol(Instance.toJSON, Decl(immutable.ts, 248, 38))
>T : Symbol(T, Decl(immutable.ts, 219, 30))

      toObject(): T;
>toObject : Symbol(Instance.toObject, Decl(immutable.ts, 249, 18))
>T : Symbol(T, Decl(immutable.ts, 219, 30))

      // Transient changes
      withMutations(mutator: (mutable: this) => any): this;
>withMutations : Symbol(Instance.withMutations, Decl(immutable.ts, 250, 20))
>mutator : Symbol(mutator, Decl(immutable.ts, 252, 20))
>mutable : Symbol(mutable, Decl(immutable.ts, 252, 30))

      asMutable(): this;
>asMutable : Symbol(Instance.asMutable, Decl(immutable.ts, 252, 59))

      asImmutable(): this;
>asImmutable : Symbol(Instance.asImmutable, Decl(immutable.ts, 253, 24))

      // Sequence algorithms
      toSeq(): Seq.Keyed<keyof T, T[keyof T]>;
>toSeq : Symbol(Instance.toSeq, Decl(immutable.ts, 254, 26))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Seq.Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>T : Symbol(T, Decl(immutable.ts, 219, 30))

      [Symbol.iterator](): IterableIterator<[keyof T, T[keyof T]]>;
>[Symbol.iterator] : Symbol(Instance[Symbol.iterator], Decl(immutable.ts, 256, 46))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>IterableIterator : Symbol(IterableIterator, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
>T : Symbol(T, Decl(immutable.ts, 219, 30))
    }
  }
  export function Record<T>(defaultValues: T, name?: string): Record.Class<T>;
>Record : Symbol(Record, Decl(immutable.ts, 259, 3), Decl(immutable.ts, 211, 70))
>T : Symbol(T, Decl(immutable.ts, 260, 25))
>defaultValues : Symbol(defaultValues, Decl(immutable.ts, 260, 28))
>T : Symbol(T, Decl(immutable.ts, 260, 25))
>name : Symbol(name, Decl(immutable.ts, 260, 45))
>Record : Symbol(Record, Decl(immutable.ts, 259, 3), Decl(immutable.ts, 211, 70))
>Class : Symbol(Record.Class, Decl(immutable.ts, 214, 70))
>T : Symbol(T, Decl(immutable.ts, 260, 25))

  export namespace Seq {
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)

    function isSeq(maybeSeq: any): maybeSeq is Seq.Indexed<any> | Seq.Keyed<any, any>;
>isSeq : Symbol(isSeq, Decl(immutable.ts, 261, 24))
>maybeSeq : Symbol(maybeSeq, Decl(immutable.ts, 262, 19))
>maybeSeq : Symbol(maybeSeq, Decl(immutable.ts, 262, 19))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)

    function of<T>(...values: Array<T>): Seq.Indexed<T>;
>of : Symbol(of, Decl(immutable.ts, 262, 86))
>T : Symbol(T, Decl(immutable.ts, 263, 16))
>values : Symbol(values, Decl(immutable.ts, 263, 19))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 263, 16))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 263, 16))

    export namespace Keyed {}
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)

    export function Keyed<K, V>(collection: Iterable<[K, V]>): Seq.Keyed<K, V>;
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 265, 26))
>V : Symbol(V, Decl(immutable.ts, 265, 28))
>collection : Symbol(collection, Decl(immutable.ts, 265, 32))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 265, 26))
>V : Symbol(V, Decl(immutable.ts, 265, 28))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 265, 26))
>V : Symbol(V, Decl(immutable.ts, 265, 28))

    export function Keyed<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>V : Symbol(V, Decl(immutable.ts, 266, 26))
>obj : Symbol(obj, Decl(immutable.ts, 266, 29))
>key : Symbol(key, Decl(immutable.ts, 266, 36))
>V : Symbol(V, Decl(immutable.ts, 266, 26))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>V : Symbol(V, Decl(immutable.ts, 266, 26))

    export function Keyed<K, V>(): Seq.Keyed<K, V>;
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 267, 26))
>V : Symbol(V, Decl(immutable.ts, 267, 28))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 267, 26))
>V : Symbol(V, Decl(immutable.ts, 267, 28))

    export function Keyed(): Seq.Keyed<any, any>;
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)

    export interface Keyed<K, V> extends Seq<K, V>, Collection.Keyed<K, V> {
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>Collection.Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>V : Symbol(V, Decl(immutable.ts, 269, 29))

      toJS(): Object;
>toJS : Symbol(Keyed.toJS, Decl(immutable.ts, 269, 76))
>Object : Symbol(Object, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))

      toJSON(): { [key: string]: V };
>toJSON : Symbol(Keyed.toJSON, Decl(immutable.ts, 270, 21))
>key : Symbol(key, Decl(immutable.ts, 271, 19))
>V : Symbol(V, Decl(immutable.ts, 269, 29))

      toSeq(): this;
>toSeq : Symbol(Keyed.toSeq, Decl(immutable.ts, 271, 37))

      concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Seq.Keyed<K | KC, V | VC>;
>concat : Symbol(Keyed.concat, Decl(immutable.ts, 272, 20), Decl(immutable.ts, 273, 91))
>KC : Symbol(KC, Decl(immutable.ts, 273, 13))
>VC : Symbol(VC, Decl(immutable.ts, 273, 16))
>collections : Symbol(collections, Decl(immutable.ts, 273, 21))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>KC : Symbol(KC, Decl(immutable.ts, 273, 13))
>VC : Symbol(VC, Decl(immutable.ts, 273, 16))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>KC : Symbol(KC, Decl(immutable.ts, 273, 13))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>VC : Symbol(VC, Decl(immutable.ts, 273, 16))

      concat<C>(...collections: Array<{[key: string]: C}>): Seq.Keyed<K | string, V | C>;
>concat : Symbol(Keyed.concat, Decl(immutable.ts, 272, 20), Decl(immutable.ts, 273, 91))
>C : Symbol(C, Decl(immutable.ts, 274, 13))
>collections : Symbol(collections, Decl(immutable.ts, 274, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>key : Symbol(key, Decl(immutable.ts, 274, 40))
>C : Symbol(C, Decl(immutable.ts, 274, 13))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>C : Symbol(C, Decl(immutable.ts, 274, 13))

      map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Seq.Keyed<K, M>;
>map : Symbol(Keyed.map, Decl(immutable.ts, 274, 89))
>M : Symbol(M, Decl(immutable.ts, 275, 10))
>mapper : Symbol(mapper, Decl(immutable.ts, 275, 13))
>value : Symbol(value, Decl(immutable.ts, 275, 22))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>key : Symbol(key, Decl(immutable.ts, 275, 31))
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>iter : Symbol(iter, Decl(immutable.ts, 275, 39))
>M : Symbol(M, Decl(immutable.ts, 275, 10))
>context : Symbol(context, Decl(immutable.ts, 275, 57))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>M : Symbol(M, Decl(immutable.ts, 275, 10))

      mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Seq.Keyed<M, V>;
>mapKeys : Symbol(Keyed.mapKeys, Decl(immutable.ts, 275, 90))
>M : Symbol(M, Decl(immutable.ts, 276, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 276, 17))
>key : Symbol(key, Decl(immutable.ts, 276, 26))
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>value : Symbol(value, Decl(immutable.ts, 276, 33))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>iter : Symbol(iter, Decl(immutable.ts, 276, 43))
>M : Symbol(M, Decl(immutable.ts, 276, 14))
>context : Symbol(context, Decl(immutable.ts, 276, 61))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>M : Symbol(M, Decl(immutable.ts, 276, 14))
>V : Symbol(V, Decl(immutable.ts, 269, 29))

      mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Seq.Keyed<KM, VM>;
>mapEntries : Symbol(Keyed.mapEntries, Decl(immutable.ts, 276, 94))
>KM : Symbol(KM, Decl(immutable.ts, 277, 17))
>VM : Symbol(VM, Decl(immutable.ts, 277, 20))
>mapper : Symbol(mapper, Decl(immutable.ts, 277, 25))
>entry : Symbol(entry, Decl(immutable.ts, 277, 34))
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>index : Symbol(index, Decl(immutable.ts, 277, 48))
>iter : Symbol(iter, Decl(immutable.ts, 277, 63))
>KM : Symbol(KM, Decl(immutable.ts, 277, 17))
>VM : Symbol(VM, Decl(immutable.ts, 277, 20))
>context : Symbol(context, Decl(immutable.ts, 277, 88))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>KM : Symbol(KM, Decl(immutable.ts, 277, 17))
>VM : Symbol(VM, Decl(immutable.ts, 277, 20))

      flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Seq.Keyed<any, any>;
>flatMap : Symbol(Keyed.flatMap, Decl(immutable.ts, 277, 123))
>M : Symbol(M, Decl(immutable.ts, 278, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 278, 17))
>value : Symbol(value, Decl(immutable.ts, 278, 26))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>key : Symbol(key, Decl(immutable.ts, 278, 35))
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>iter : Symbol(iter, Decl(immutable.ts, 278, 43))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 278, 14))
>context : Symbol(context, Decl(immutable.ts, 278, 71))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)

      filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq.Keyed<K, F>;
>filter : Symbol(Keyed.filter, Decl(immutable.ts, 278, 108), Decl(immutable.ts, 279, 115))
>F : Symbol(F, Decl(immutable.ts, 279, 13))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>predicate : Symbol(predicate, Decl(immutable.ts, 279, 26))
>value : Symbol(value, Decl(immutable.ts, 279, 38))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>key : Symbol(key, Decl(immutable.ts, 279, 47))
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>iter : Symbol(iter, Decl(immutable.ts, 279, 55))
>value : Symbol(value, Decl(immutable.ts, 279, 38))
>F : Symbol(F, Decl(immutable.ts, 279, 13))
>context : Symbol(context, Decl(immutable.ts, 279, 82))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>F : Symbol(F, Decl(immutable.ts, 279, 13))

      filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : Symbol(Keyed.filter, Decl(immutable.ts, 278, 108), Decl(immutable.ts, 279, 115))
>predicate : Symbol(predicate, Decl(immutable.ts, 280, 13))
>value : Symbol(value, Decl(immutable.ts, 280, 25))
>V : Symbol(V, Decl(immutable.ts, 269, 29))
>key : Symbol(key, Decl(immutable.ts, 280, 34))
>K : Symbol(K, Decl(immutable.ts, 269, 27))
>iter : Symbol(iter, Decl(immutable.ts, 280, 42))
>context : Symbol(context, Decl(immutable.ts, 280, 62))
    }
    namespace Indexed {
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))

      function of<T>(...values: Array<T>): Seq.Indexed<T>;
>of : Symbol(of, Decl(immutable.ts, 282, 23))
>T : Symbol(T, Decl(immutable.ts, 283, 18))
>values : Symbol(values, Decl(immutable.ts, 283, 21))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 283, 18))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 283, 18))
    }
    export function Indexed(): Seq.Indexed<any>;
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))

    export function Indexed<T>(): Seq.Indexed<T>;
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 286, 28))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 286, 28))

    export function Indexed<T>(collection: Iterable<T>): Seq.Indexed<T>;
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 287, 28))
>collection : Symbol(collection, Decl(immutable.ts, 287, 31))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 287, 28))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 287, 28))

    export interface Indexed<T> extends Seq<number, T>, Collection.Indexed<T> {
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>Collection.Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 288, 29))

      toJS(): Array<any>;
>toJS : Symbol(Indexed.toJS, Decl(immutable.ts, 288, 79))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

      toJSON(): Array<T>;
>toJSON : Symbol(Indexed.toJSON, Decl(immutable.ts, 289, 25))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 288, 29))

      toSeq(): this;
>toSeq : Symbol(Indexed.toSeq, Decl(immutable.ts, 290, 25))

      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Indexed<T | C>;
>concat : Symbol(Indexed.concat, Decl(immutable.ts, 291, 20))
>C : Symbol(C, Decl(immutable.ts, 292, 13))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 292, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 292, 13))
>C : Symbol(C, Decl(immutable.ts, 292, 13))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>C : Symbol(C, Decl(immutable.ts, 292, 13))

      map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Seq.Indexed<M>;
>map : Symbol(Indexed.map, Decl(immutable.ts, 292, 84))
>M : Symbol(M, Decl(immutable.ts, 293, 10))
>mapper : Symbol(mapper, Decl(immutable.ts, 293, 13))
>value : Symbol(value, Decl(immutable.ts, 293, 22))
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>key : Symbol(key, Decl(immutable.ts, 293, 31))
>iter : Symbol(iter, Decl(immutable.ts, 293, 44))
>M : Symbol(M, Decl(immutable.ts, 293, 10))
>context : Symbol(context, Decl(immutable.ts, 293, 62))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>M : Symbol(M, Decl(immutable.ts, 293, 10))

      flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Seq.Indexed<M>;
>flatMap : Symbol(Indexed.flatMap, Decl(immutable.ts, 293, 94))
>M : Symbol(M, Decl(immutable.ts, 294, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 294, 17))
>value : Symbol(value, Decl(immutable.ts, 294, 26))
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>key : Symbol(key, Decl(immutable.ts, 294, 35))
>iter : Symbol(iter, Decl(immutable.ts, 294, 48))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 294, 14))
>context : Symbol(context, Decl(immutable.ts, 294, 76))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>M : Symbol(M, Decl(immutable.ts, 294, 14))

      filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Seq.Indexed<F>;
>filter : Symbol(Indexed.filter, Decl(immutable.ts, 294, 108), Decl(immutable.ts, 295, 121))
>F : Symbol(F, Decl(immutable.ts, 295, 13))
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>predicate : Symbol(predicate, Decl(immutable.ts, 295, 26))
>value : Symbol(value, Decl(immutable.ts, 295, 38))
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>index : Symbol(index, Decl(immutable.ts, 295, 47))
>iter : Symbol(iter, Decl(immutable.ts, 295, 62))
>value : Symbol(value, Decl(immutable.ts, 295, 38))
>F : Symbol(F, Decl(immutable.ts, 295, 13))
>context : Symbol(context, Decl(immutable.ts, 295, 89))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>F : Symbol(F, Decl(immutable.ts, 295, 13))

      filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : Symbol(Indexed.filter, Decl(immutable.ts, 294, 108), Decl(immutable.ts, 295, 121))
>predicate : Symbol(predicate, Decl(immutable.ts, 296, 13))
>value : Symbol(value, Decl(immutable.ts, 296, 25))
>T : Symbol(T, Decl(immutable.ts, 288, 29))
>index : Symbol(index, Decl(immutable.ts, 296, 34))
>iter : Symbol(iter, Decl(immutable.ts, 296, 49))
>context : Symbol(context, Decl(immutable.ts, 296, 69))
    }
    export namespace Set {
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))

      function of<T>(...values: Array<T>): Seq.Set<T>;
>of : Symbol(of, Decl(immutable.ts, 298, 26))
>T : Symbol(T, Decl(immutable.ts, 299, 18))
>values : Symbol(values, Decl(immutable.ts, 299, 21))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 299, 18))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 299, 18))
    }
    export function Set(): Seq.Set<any>;
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))

    export function Set<T>(): Seq.Set<T>;
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 302, 24))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 302, 24))

    export function Set<T>(collection: Iterable<T>): Seq.Set<T>;
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 303, 24))
>collection : Symbol(collection, Decl(immutable.ts, 303, 27))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 303, 24))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 303, 24))

    export interface Set<T> extends Seq<never, T>, Collection.Set<T> {
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>Collection.Set : Symbol(Collection.Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Collection.Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>T : Symbol(T, Decl(immutable.ts, 304, 25))

      toJS(): Array<any>;
>toJS : Symbol(Set.toJS, Decl(immutable.ts, 304, 70))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

      toJSON(): Array<T>;
>toJSON : Symbol(Set.toJSON, Decl(immutable.ts, 305, 25))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 304, 25))

      toSeq(): this;
>toSeq : Symbol(Set.toSeq, Decl(immutable.ts, 306, 25))

      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Set<T | C>;
>concat : Symbol(Set.concat, Decl(immutable.ts, 307, 20))
>C : Symbol(C, Decl(immutable.ts, 308, 13))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 308, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 308, 13))
>C : Symbol(C, Decl(immutable.ts, 308, 13))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>C : Symbol(C, Decl(immutable.ts, 308, 13))

      map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Seq.Set<M>;
>map : Symbol(Set.map, Decl(immutable.ts, 308, 80))
>M : Symbol(M, Decl(immutable.ts, 309, 10))
>mapper : Symbol(mapper, Decl(immutable.ts, 309, 13))
>value : Symbol(value, Decl(immutable.ts, 309, 22))
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>key : Symbol(key, Decl(immutable.ts, 309, 31))
>iter : Symbol(iter, Decl(immutable.ts, 309, 43))
>M : Symbol(M, Decl(immutable.ts, 309, 10))
>context : Symbol(context, Decl(immutable.ts, 309, 61))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>M : Symbol(M, Decl(immutable.ts, 309, 10))

      flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any): Seq.Set<M>;
>flatMap : Symbol(Set.flatMap, Decl(immutable.ts, 309, 89))
>M : Symbol(M, Decl(immutable.ts, 310, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 310, 17))
>value : Symbol(value, Decl(immutable.ts, 310, 26))
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>key : Symbol(key, Decl(immutable.ts, 310, 35))
>iter : Symbol(iter, Decl(immutable.ts, 310, 47))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 310, 14))
>context : Symbol(context, Decl(immutable.ts, 310, 75))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>M : Symbol(M, Decl(immutable.ts, 310, 14))

      filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Seq.Set<F>;
>filter : Symbol(Set.filter, Decl(immutable.ts, 310, 103), Decl(immutable.ts, 311, 114))
>F : Symbol(F, Decl(immutable.ts, 311, 13))
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>predicate : Symbol(predicate, Decl(immutable.ts, 311, 26))
>value : Symbol(value, Decl(immutable.ts, 311, 38))
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>key : Symbol(key, Decl(immutable.ts, 311, 47))
>iter : Symbol(iter, Decl(immutable.ts, 311, 59))
>value : Symbol(value, Decl(immutable.ts, 311, 38))
>F : Symbol(F, Decl(immutable.ts, 311, 13))
>context : Symbol(context, Decl(immutable.ts, 311, 86))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>F : Symbol(F, Decl(immutable.ts, 311, 13))

      filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : Symbol(Set.filter, Decl(immutable.ts, 310, 103), Decl(immutable.ts, 311, 114))
>predicate : Symbol(predicate, Decl(immutable.ts, 312, 13))
>value : Symbol(value, Decl(immutable.ts, 312, 25))
>T : Symbol(T, Decl(immutable.ts, 304, 25))
>key : Symbol(key, Decl(immutable.ts, 312, 34))
>iter : Symbol(iter, Decl(immutable.ts, 312, 46))
>context : Symbol(context, Decl(immutable.ts, 312, 66))
    }
  }
  export function Seq<S extends Seq<any, any>>(seq: S): S;
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>S : Symbol(S, Decl(immutable.ts, 315, 22))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>seq : Symbol(seq, Decl(immutable.ts, 315, 47))
>S : Symbol(S, Decl(immutable.ts, 315, 22))
>S : Symbol(S, Decl(immutable.ts, 315, 22))

  export function Seq<K, V>(collection: Collection.Keyed<K, V>): Seq.Keyed<K, V>;
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>K : Symbol(K, Decl(immutable.ts, 316, 22))
>V : Symbol(V, Decl(immutable.ts, 316, 24))
>collection : Symbol(collection, Decl(immutable.ts, 316, 28))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 316, 22))
>V : Symbol(V, Decl(immutable.ts, 316, 24))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Seq.Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 316, 22))
>V : Symbol(V, Decl(immutable.ts, 316, 24))

  export function Seq<T>(collection: Collection.Indexed<T>): Seq.Indexed<T>;
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>T : Symbol(T, Decl(immutable.ts, 317, 22))
>collection : Symbol(collection, Decl(immutable.ts, 317, 25))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 317, 22))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 317, 22))

  export function Seq<T>(collection: Collection.Set<T>): Seq.Set<T>;
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>T : Symbol(T, Decl(immutable.ts, 318, 22))
>collection : Symbol(collection, Decl(immutable.ts, 318, 25))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Collection.Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>T : Symbol(T, Decl(immutable.ts, 318, 22))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Seq.Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 318, 22))

  export function Seq<T>(collection: Iterable<T>): Seq.Indexed<T>;
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>T : Symbol(T, Decl(immutable.ts, 319, 22))
>collection : Symbol(collection, Decl(immutable.ts, 319, 25))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 319, 22))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 319, 22))

  export function Seq<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>V : Symbol(V, Decl(immutable.ts, 320, 22))
>obj : Symbol(obj, Decl(immutable.ts, 320, 25))
>key : Symbol(key, Decl(immutable.ts, 320, 32))
>V : Symbol(V, Decl(immutable.ts, 320, 22))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Seq.Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>V : Symbol(V, Decl(immutable.ts, 320, 22))

  export function Seq(): Seq<any, any>;
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)

  export interface Seq<K, V> extends Collection<K, V> {
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>V : Symbol(V, Decl(immutable.ts, 322, 25))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>V : Symbol(V, Decl(immutable.ts, 322, 25))

    readonly size: number | undefined;
>size : Symbol(Seq.size, Decl(immutable.ts, 322, 55))

    // Force evaluation
    cacheResult(): this;
>cacheResult : Symbol(Seq.cacheResult, Decl(immutable.ts, 323, 38))

    // Sequence algorithms
    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Seq<K, M>;
>map : Symbol(Seq.map, Decl(immutable.ts, 325, 24))
>M : Symbol(M, Decl(immutable.ts, 327, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 327, 11))
>value : Symbol(value, Decl(immutable.ts, 327, 20))
>V : Symbol(V, Decl(immutable.ts, 322, 25))
>key : Symbol(key, Decl(immutable.ts, 327, 29))
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>iter : Symbol(iter, Decl(immutable.ts, 327, 37))
>M : Symbol(M, Decl(immutable.ts, 327, 8))
>context : Symbol(context, Decl(immutable.ts, 327, 55))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>M : Symbol(M, Decl(immutable.ts, 327, 8))

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Seq<K, M>;
>flatMap : Symbol(Seq.flatMap, Decl(immutable.ts, 327, 82))
>M : Symbol(M, Decl(immutable.ts, 328, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 328, 15))
>value : Symbol(value, Decl(immutable.ts, 328, 24))
>V : Symbol(V, Decl(immutable.ts, 322, 25))
>key : Symbol(key, Decl(immutable.ts, 328, 33))
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>iter : Symbol(iter, Decl(immutable.ts, 328, 41))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 328, 12))
>context : Symbol(context, Decl(immutable.ts, 328, 69))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>M : Symbol(M, Decl(immutable.ts, 328, 12))

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq<K, F>;
>filter : Symbol(Seq.filter, Decl(immutable.ts, 328, 96), Decl(immutable.ts, 329, 107))
>F : Symbol(F, Decl(immutable.ts, 329, 11))
>V : Symbol(V, Decl(immutable.ts, 322, 25))
>predicate : Symbol(predicate, Decl(immutable.ts, 329, 24))
>value : Symbol(value, Decl(immutable.ts, 329, 36))
>V : Symbol(V, Decl(immutable.ts, 322, 25))
>key : Symbol(key, Decl(immutable.ts, 329, 45))
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>iter : Symbol(iter, Decl(immutable.ts, 329, 53))
>value : Symbol(value, Decl(immutable.ts, 329, 36))
>F : Symbol(F, Decl(immutable.ts, 329, 11))
>context : Symbol(context, Decl(immutable.ts, 329, 80))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>F : Symbol(F, Decl(immutable.ts, 329, 11))

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : Symbol(Seq.filter, Decl(immutable.ts, 328, 96), Decl(immutable.ts, 329, 107))
>predicate : Symbol(predicate, Decl(immutable.ts, 330, 11))
>value : Symbol(value, Decl(immutable.ts, 330, 23))
>V : Symbol(V, Decl(immutable.ts, 322, 25))
>key : Symbol(key, Decl(immutable.ts, 330, 32))
>K : Symbol(K, Decl(immutable.ts, 322, 23))
>iter : Symbol(iter, Decl(immutable.ts, 330, 40))
>context : Symbol(context, Decl(immutable.ts, 330, 60))
  }
  export namespace Collection {
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))

    function isKeyed(maybeKeyed: any): maybeKeyed is Collection.Keyed<any, any>;
>isKeyed : Symbol(isKeyed, Decl(immutable.ts, 332, 31))
>maybeKeyed : Symbol(maybeKeyed, Decl(immutable.ts, 333, 21))
>maybeKeyed : Symbol(maybeKeyed, Decl(immutable.ts, 333, 21))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))

    function isIndexed(maybeIndexed: any): maybeIndexed is Collection.Indexed<any>;
>isIndexed : Symbol(isIndexed, Decl(immutable.ts, 333, 80))
>maybeIndexed : Symbol(maybeIndexed, Decl(immutable.ts, 334, 23))
>maybeIndexed : Symbol(maybeIndexed, Decl(immutable.ts, 334, 23))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))

    function isAssociative(maybeAssociative: any): maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>;
>isAssociative : Symbol(isAssociative, Decl(immutable.ts, 334, 83))
>maybeAssociative : Symbol(maybeAssociative, Decl(immutable.ts, 335, 27))
>maybeAssociative : Symbol(maybeAssociative, Decl(immutable.ts, 335, 27))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))

    function isOrdered(maybeOrdered: any): boolean;
>isOrdered : Symbol(isOrdered, Decl(immutable.ts, 335, 124))
>maybeOrdered : Symbol(maybeOrdered, Decl(immutable.ts, 336, 23))

    export namespace Keyed {}
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))

    export function Keyed<K, V>(collection: Iterable<[K, V]>): Collection.Keyed<K, V>;
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 338, 26))
>V : Symbol(V, Decl(immutable.ts, 338, 28))
>collection : Symbol(collection, Decl(immutable.ts, 338, 32))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 338, 26))
>V : Symbol(V, Decl(immutable.ts, 338, 28))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 338, 26))
>V : Symbol(V, Decl(immutable.ts, 338, 28))

    export function Keyed<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>;
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>V : Symbol(V, Decl(immutable.ts, 339, 26))
>obj : Symbol(obj, Decl(immutable.ts, 339, 29))
>key : Symbol(key, Decl(immutable.ts, 339, 36))
>V : Symbol(V, Decl(immutable.ts, 339, 26))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>V : Symbol(V, Decl(immutable.ts, 339, 26))

    export interface Keyed<K, V> extends Collection<K, V> {
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>V : Symbol(V, Decl(immutable.ts, 340, 29))

      toJS(): Object;
>toJS : Symbol(Keyed.toJS, Decl(immutable.ts, 340, 59))
>Object : Symbol(Object, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))

      toJSON(): { [key: string]: V };
>toJSON : Symbol(Keyed.toJSON, Decl(immutable.ts, 341, 21))
>key : Symbol(key, Decl(immutable.ts, 342, 19))
>V : Symbol(V, Decl(immutable.ts, 340, 29))

      toSeq(): Seq.Keyed<K, V>;
>toSeq : Symbol(Keyed.toSeq, Decl(immutable.ts, 342, 37))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Seq.Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>V : Symbol(V, Decl(immutable.ts, 340, 29))

      // Sequence functions
      flip(): this;
>flip : Symbol(Keyed.flip, Decl(immutable.ts, 343, 31))

      concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>;
>concat : Symbol(Keyed.concat, Decl(immutable.ts, 345, 19), Decl(immutable.ts, 346, 98))
>KC : Symbol(KC, Decl(immutable.ts, 346, 13))
>VC : Symbol(VC, Decl(immutable.ts, 346, 16))
>collections : Symbol(collections, Decl(immutable.ts, 346, 21))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>KC : Symbol(KC, Decl(immutable.ts, 346, 13))
>VC : Symbol(VC, Decl(immutable.ts, 346, 16))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>KC : Symbol(KC, Decl(immutable.ts, 346, 13))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>VC : Symbol(VC, Decl(immutable.ts, 346, 16))

      concat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>;
>concat : Symbol(Keyed.concat, Decl(immutable.ts, 345, 19), Decl(immutable.ts, 346, 98))
>C : Symbol(C, Decl(immutable.ts, 347, 13))
>collections : Symbol(collections, Decl(immutable.ts, 347, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>key : Symbol(key, Decl(immutable.ts, 347, 40))
>C : Symbol(C, Decl(immutable.ts, 347, 13))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>C : Symbol(C, Decl(immutable.ts, 347, 13))

      map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Collection.Keyed<K, M>;
>map : Symbol(Keyed.map, Decl(immutable.ts, 347, 96))
>M : Symbol(M, Decl(immutable.ts, 348, 10))
>mapper : Symbol(mapper, Decl(immutable.ts, 348, 13))
>value : Symbol(value, Decl(immutable.ts, 348, 22))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>key : Symbol(key, Decl(immutable.ts, 348, 31))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>iter : Symbol(iter, Decl(immutable.ts, 348, 39))
>M : Symbol(M, Decl(immutable.ts, 348, 10))
>context : Symbol(context, Decl(immutable.ts, 348, 57))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>M : Symbol(M, Decl(immutable.ts, 348, 10))

      mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Collection.Keyed<M, V>;
>mapKeys : Symbol(Keyed.mapKeys, Decl(immutable.ts, 348, 97))
>M : Symbol(M, Decl(immutable.ts, 349, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 349, 17))
>key : Symbol(key, Decl(immutable.ts, 349, 26))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>value : Symbol(value, Decl(immutable.ts, 349, 33))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>iter : Symbol(iter, Decl(immutable.ts, 349, 43))
>M : Symbol(M, Decl(immutable.ts, 349, 14))
>context : Symbol(context, Decl(immutable.ts, 349, 61))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>M : Symbol(M, Decl(immutable.ts, 349, 14))
>V : Symbol(V, Decl(immutable.ts, 340, 29))

      mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Collection.Keyed<KM, VM>;
>mapEntries : Symbol(Keyed.mapEntries, Decl(immutable.ts, 349, 101))
>KM : Symbol(KM, Decl(immutable.ts, 350, 17))
>VM : Symbol(VM, Decl(immutable.ts, 350, 20))
>mapper : Symbol(mapper, Decl(immutable.ts, 350, 25))
>entry : Symbol(entry, Decl(immutable.ts, 350, 34))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>index : Symbol(index, Decl(immutable.ts, 350, 48))
>iter : Symbol(iter, Decl(immutable.ts, 350, 63))
>KM : Symbol(KM, Decl(immutable.ts, 350, 17))
>VM : Symbol(VM, Decl(immutable.ts, 350, 20))
>context : Symbol(context, Decl(immutable.ts, 350, 88))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>KM : Symbol(KM, Decl(immutable.ts, 350, 17))
>VM : Symbol(VM, Decl(immutable.ts, 350, 20))

      flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Collection.Keyed<any, any>;
>flatMap : Symbol(Keyed.flatMap, Decl(immutable.ts, 350, 130))
>M : Symbol(M, Decl(immutable.ts, 351, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 351, 17))
>value : Symbol(value, Decl(immutable.ts, 351, 26))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>key : Symbol(key, Decl(immutable.ts, 351, 35))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>iter : Symbol(iter, Decl(immutable.ts, 351, 43))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 351, 14))
>context : Symbol(context, Decl(immutable.ts, 351, 71))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))

      filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Collection.Keyed<K, F>;
>filter : Symbol(Keyed.filter, Decl(immutable.ts, 351, 115), Decl(immutable.ts, 352, 122))
>F : Symbol(F, Decl(immutable.ts, 352, 13))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>predicate : Symbol(predicate, Decl(immutable.ts, 352, 26))
>value : Symbol(value, Decl(immutable.ts, 352, 38))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>key : Symbol(key, Decl(immutable.ts, 352, 47))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>iter : Symbol(iter, Decl(immutable.ts, 352, 55))
>value : Symbol(value, Decl(immutable.ts, 352, 38))
>F : Symbol(F, Decl(immutable.ts, 352, 13))
>context : Symbol(context, Decl(immutable.ts, 352, 82))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>F : Symbol(F, Decl(immutable.ts, 352, 13))

      filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : Symbol(Keyed.filter, Decl(immutable.ts, 351, 115), Decl(immutable.ts, 352, 122))
>predicate : Symbol(predicate, Decl(immutable.ts, 353, 13))
>value : Symbol(value, Decl(immutable.ts, 353, 25))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
>key : Symbol(key, Decl(immutable.ts, 353, 34))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>iter : Symbol(iter, Decl(immutable.ts, 353, 42))
>context : Symbol(context, Decl(immutable.ts, 353, 62))

      [Symbol.iterator](): IterableIterator<[K, V]>;
>[Symbol.iterator] : Symbol(Keyed[Symbol.iterator], Decl(immutable.ts, 353, 84))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>IterableIterator : Symbol(IterableIterator, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 340, 27))
>V : Symbol(V, Decl(immutable.ts, 340, 29))
    }
    export namespace Indexed {}
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))

    export function Indexed<T>(collection: Iterable<T>): Collection.Indexed<T>;
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 357, 28))
>collection : Symbol(collection, Decl(immutable.ts, 357, 31))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 357, 28))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 357, 28))

    export interface Indexed<T> extends Collection<number, T> {
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      toJS(): Array<any>;
>toJS : Symbol(Indexed.toJS, Decl(immutable.ts, 358, 63))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

      toJSON(): Array<T>;
>toJSON : Symbol(Indexed.toJSON, Decl(immutable.ts, 359, 25))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      // Reading values
      get<NSV>(index: number, notSetValue: NSV): T | NSV;
>get : Symbol(Indexed.get, Decl(immutable.ts, 360, 25), Decl(immutable.ts, 362, 57))
>NSV : Symbol(NSV, Decl(immutable.ts, 362, 10))
>index : Symbol(index, Decl(immutable.ts, 362, 15))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 362, 29))
>NSV : Symbol(NSV, Decl(immutable.ts, 362, 10))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>NSV : Symbol(NSV, Decl(immutable.ts, 362, 10))

      get(index: number): T | undefined;
>get : Symbol(Indexed.get, Decl(immutable.ts, 360, 25), Decl(immutable.ts, 362, 57))
>index : Symbol(index, Decl(immutable.ts, 363, 10))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      // Conversion to Seq
      toSeq(): Seq.Indexed<T>;
>toSeq : Symbol(Indexed.toSeq, Decl(immutable.ts, 363, 40))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      fromEntrySeq(): Seq.Keyed<any, any>;
>fromEntrySeq : Symbol(Indexed.fromEntrySeq, Decl(immutable.ts, 365, 30))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Seq.Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)

      // Combination
      interpose(separator: T): this;
>interpose : Symbol(Indexed.interpose, Decl(immutable.ts, 366, 42))
>separator : Symbol(separator, Decl(immutable.ts, 368, 16))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      interleave(...collections: Array<Collection<any, T>>): this;
>interleave : Symbol(Indexed.interleave, Decl(immutable.ts, 368, 36))
>collections : Symbol(collections, Decl(immutable.ts, 369, 17))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      splice(index: number, removeNum: number, ...values: Array<T>): this;
>splice : Symbol(Indexed.splice, Decl(immutable.ts, 369, 66))
>index : Symbol(index, Decl(immutable.ts, 370, 13))
>removeNum : Symbol(removeNum, Decl(immutable.ts, 370, 27))
>values : Symbol(values, Decl(immutable.ts, 370, 46))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      zip(...collections: Array<Collection<any, any>>): Collection.Indexed<any>;
>zip : Symbol(Indexed.zip, Decl(immutable.ts, 370, 74))
>collections : Symbol(collections, Decl(immutable.ts, 371, 10))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))

      zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): Collection.Indexed<Z>;
>zipWith : Symbol(Indexed.zipWith, Decl(immutable.ts, 371, 80), Decl(immutable.ts, 372, 120), Decl(immutable.ts, 373, 175))
>U : Symbol(U, Decl(immutable.ts, 372, 14))
>Z : Symbol(Z, Decl(immutable.ts, 372, 16))
>zipper : Symbol(zipper, Decl(immutable.ts, 372, 20))
>value : Symbol(value, Decl(immutable.ts, 372, 29))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>otherValue : Symbol(otherValue, Decl(immutable.ts, 372, 38))
>U : Symbol(U, Decl(immutable.ts, 372, 14))
>Z : Symbol(Z, Decl(immutable.ts, 372, 16))
>otherCollection : Symbol(otherCollection, Decl(immutable.ts, 372, 59))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>U : Symbol(U, Decl(immutable.ts, 372, 14))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>Z : Symbol(Z, Decl(immutable.ts, 372, 16))

      zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Collection.Indexed<Z>;
>zipWith : Symbol(Indexed.zipWith, Decl(immutable.ts, 371, 80), Decl(immutable.ts, 372, 120), Decl(immutable.ts, 373, 175))
>U : Symbol(U, Decl(immutable.ts, 373, 14))
>V : Symbol(V, Decl(immutable.ts, 373, 16))
>Z : Symbol(Z, Decl(immutable.ts, 373, 19))
>zipper : Symbol(zipper, Decl(immutable.ts, 373, 23))
>value : Symbol(value, Decl(immutable.ts, 373, 32))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>otherValue : Symbol(otherValue, Decl(immutable.ts, 373, 41))
>U : Symbol(U, Decl(immutable.ts, 373, 14))
>thirdValue : Symbol(thirdValue, Decl(immutable.ts, 373, 56))
>V : Symbol(V, Decl(immutable.ts, 373, 16))
>Z : Symbol(Z, Decl(immutable.ts, 373, 19))
>otherCollection : Symbol(otherCollection, Decl(immutable.ts, 373, 77))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>U : Symbol(U, Decl(immutable.ts, 373, 14))
>thirdCollection : Symbol(thirdCollection, Decl(immutable.ts, 373, 114))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>V : Symbol(V, Decl(immutable.ts, 373, 16))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>Z : Symbol(Z, Decl(immutable.ts, 373, 19))

      zipWith<Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): Collection.Indexed<Z>;
>zipWith : Symbol(Indexed.zipWith, Decl(immutable.ts, 371, 80), Decl(immutable.ts, 372, 120), Decl(immutable.ts, 373, 175))
>Z : Symbol(Z, Decl(immutable.ts, 374, 14))
>zipper : Symbol(zipper, Decl(immutable.ts, 374, 17))
>any : Symbol(any, Decl(immutable.ts, 374, 26))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Z : Symbol(Z, Decl(immutable.ts, 374, 14))
>collections : Symbol(collections, Decl(immutable.ts, 374, 51))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>Z : Symbol(Z, Decl(immutable.ts, 374, 14))

      // Search for value
      indexOf(searchValue: T): number;
>indexOf : Symbol(Indexed.indexOf, Decl(immutable.ts, 374, 120))
>searchValue : Symbol(searchValue, Decl(immutable.ts, 376, 14))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      lastIndexOf(searchValue: T): number;
>lastIndexOf : Symbol(Indexed.lastIndexOf, Decl(immutable.ts, 376, 38))
>searchValue : Symbol(searchValue, Decl(immutable.ts, 377, 18))
>T : Symbol(T, Decl(immutable.ts, 358, 29))

      findIndex(predicate: (value: T, index: number, iter: this) => boolean, context?: any): number;
>findIndex : Symbol(Indexed.findIndex, Decl(immutable.ts, 377, 42))
>predicate : Symbol(predicate, Decl(immutable.ts, 378, 16))
>value : Symbol(value, Decl(immutable.ts, 378, 28))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>index : Symbol(index, Decl(immutable.ts, 378, 37))
>iter : Symbol(iter, Decl(immutable.ts, 378, 52))
>context : Symbol(context, Decl(immutable.ts, 378, 76))

      findLastIndex(predicate: (value: T, index: number, iter: this) => boolean, context?: any): number;
>findLastIndex : Symbol(Indexed.findLastIndex, Decl(immutable.ts, 378, 100))
>predicate : Symbol(predicate, Decl(immutable.ts, 379, 20))
>value : Symbol(value, Decl(immutable.ts, 379, 32))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>index : Symbol(index, Decl(immutable.ts, 379, 41))
>iter : Symbol(iter, Decl(immutable.ts, 379, 56))
>context : Symbol(context, Decl(immutable.ts, 379, 80))

      // Sequence algorithms
      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Indexed<T | C>;
>concat : Symbol(Indexed.concat, Decl(immutable.ts, 379, 104))
>C : Symbol(C, Decl(immutable.ts, 381, 13))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 381, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 381, 13))
>C : Symbol(C, Decl(immutable.ts, 381, 13))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>C : Symbol(C, Decl(immutable.ts, 381, 13))

      map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Collection.Indexed<M>;
>map : Symbol(Indexed.map, Decl(immutable.ts, 381, 91))
>M : Symbol(M, Decl(immutable.ts, 382, 10))
>mapper : Symbol(mapper, Decl(immutable.ts, 382, 13))
>value : Symbol(value, Decl(immutable.ts, 382, 22))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>key : Symbol(key, Decl(immutable.ts, 382, 31))
>iter : Symbol(iter, Decl(immutable.ts, 382, 44))
>M : Symbol(M, Decl(immutable.ts, 382, 10))
>context : Symbol(context, Decl(immutable.ts, 382, 62))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>M : Symbol(M, Decl(immutable.ts, 382, 10))

      flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Collection.Indexed<M>;
>flatMap : Symbol(Indexed.flatMap, Decl(immutable.ts, 382, 101))
>M : Symbol(M, Decl(immutable.ts, 383, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 383, 17))
>value : Symbol(value, Decl(immutable.ts, 383, 26))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>key : Symbol(key, Decl(immutable.ts, 383, 35))
>iter : Symbol(iter, Decl(immutable.ts, 383, 48))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 383, 14))
>context : Symbol(context, Decl(immutable.ts, 383, 76))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>M : Symbol(M, Decl(immutable.ts, 383, 14))

      filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Collection.Indexed<F>;
>filter : Symbol(Indexed.filter, Decl(immutable.ts, 383, 115), Decl(immutable.ts, 384, 128))
>F : Symbol(F, Decl(immutable.ts, 384, 13))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>predicate : Symbol(predicate, Decl(immutable.ts, 384, 26))
>value : Symbol(value, Decl(immutable.ts, 384, 38))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>index : Symbol(index, Decl(immutable.ts, 384, 47))
>iter : Symbol(iter, Decl(immutable.ts, 384, 62))
>value : Symbol(value, Decl(immutable.ts, 384, 38))
>F : Symbol(F, Decl(immutable.ts, 384, 13))
>context : Symbol(context, Decl(immutable.ts, 384, 89))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>F : Symbol(F, Decl(immutable.ts, 384, 13))

      filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : Symbol(Indexed.filter, Decl(immutable.ts, 383, 115), Decl(immutable.ts, 384, 128))
>predicate : Symbol(predicate, Decl(immutable.ts, 385, 13))
>value : Symbol(value, Decl(immutable.ts, 385, 25))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
>index : Symbol(index, Decl(immutable.ts, 385, 34))
>iter : Symbol(iter, Decl(immutable.ts, 385, 49))
>context : Symbol(context, Decl(immutable.ts, 385, 69))

      [Symbol.iterator](): IterableIterator<T>;
>[Symbol.iterator] : Symbol(Indexed[Symbol.iterator], Decl(immutable.ts, 385, 91))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>IterableIterator : Symbol(IterableIterator, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 358, 29))
    }
    export namespace Set {}
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))

    export function Set<T>(collection: Iterable<T>): Collection.Set<T>;
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>T : Symbol(T, Decl(immutable.ts, 389, 24))
>collection : Symbol(collection, Decl(immutable.ts, 389, 27))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 389, 24))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>T : Symbol(T, Decl(immutable.ts, 389, 24))

    export interface Set<T> extends Collection<never, T> {
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 390, 25))

      toJS(): Array<any>;
>toJS : Symbol(Set.toJS, Decl(immutable.ts, 390, 58))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

      toJSON(): Array<T>;
>toJSON : Symbol(Set.toJSON, Decl(immutable.ts, 391, 25))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 390, 25))

      toSeq(): Seq.Set<T>;
>toSeq : Symbol(Set.toSeq, Decl(immutable.ts, 392, 25))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Seq.Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>T : Symbol(T, Decl(immutable.ts, 390, 25))

      // Sequence algorithms
      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Set<T | C>;
>concat : Symbol(Set.concat, Decl(immutable.ts, 393, 26))
>C : Symbol(C, Decl(immutable.ts, 395, 13))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 395, 16))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>C : Symbol(C, Decl(immutable.ts, 395, 13))
>C : Symbol(C, Decl(immutable.ts, 395, 13))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
>C : Symbol(C, Decl(immutable.ts, 395, 13))

      map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Collection.Set<M>;
>map : Symbol(Set.map, Decl(immutable.ts, 395, 87))
>M : Symbol(M, Decl(immutable.ts, 396, 10))
>mapper : Symbol(mapper, Decl(immutable.ts, 396, 13))
>value : Symbol(value, Decl(immutable.ts, 396, 22))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
>key : Symbol(key, Decl(immutable.ts, 396, 31))
>iter : Symbol(iter, Decl(immutable.ts, 396, 43))
>M : Symbol(M, Decl(immutable.ts, 396, 10))
>context : Symbol(context, Decl(immutable.ts, 396, 61))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>M : Symbol(M, Decl(immutable.ts, 396, 10))

      flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any):  Collection.Set<M>;
>flatMap : Symbol(Set.flatMap, Decl(immutable.ts, 396, 96))
>M : Symbol(M, Decl(immutable.ts, 397, 14))
>mapper : Symbol(mapper, Decl(immutable.ts, 397, 17))
>value : Symbol(value, Decl(immutable.ts, 397, 26))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
>key : Symbol(key, Decl(immutable.ts, 397, 35))
>iter : Symbol(iter, Decl(immutable.ts, 397, 47))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 397, 14))
>context : Symbol(context, Decl(immutable.ts, 397, 75))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>M : Symbol(M, Decl(immutable.ts, 397, 14))

      filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Collection.Set<F>;
>filter : Symbol(Set.filter, Decl(immutable.ts, 397, 111), Decl(immutable.ts, 398, 121))
>F : Symbol(F, Decl(immutable.ts, 398, 13))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
>predicate : Symbol(predicate, Decl(immutable.ts, 398, 26))
>value : Symbol(value, Decl(immutable.ts, 398, 38))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
>key : Symbol(key, Decl(immutable.ts, 398, 47))
>iter : Symbol(iter, Decl(immutable.ts, 398, 59))
>value : Symbol(value, Decl(immutable.ts, 398, 38))
>F : Symbol(F, Decl(immutable.ts, 398, 13))
>context : Symbol(context, Decl(immutable.ts, 398, 86))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Set : Symbol(Set, Decl(immutable.ts, 388, 27), Decl(immutable.ts, 387, 5), Decl(immutable.ts, 389, 71))
>F : Symbol(F, Decl(immutable.ts, 398, 13))

      filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : Symbol(Set.filter, Decl(immutable.ts, 397, 111), Decl(immutable.ts, 398, 121))
>predicate : Symbol(predicate, Decl(immutable.ts, 399, 13))
>value : Symbol(value, Decl(immutable.ts, 399, 25))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
>key : Symbol(key, Decl(immutable.ts, 399, 34))
>iter : Symbol(iter, Decl(immutable.ts, 399, 46))
>context : Symbol(context, Decl(immutable.ts, 399, 66))

      [Symbol.iterator](): IterableIterator<T>;
>[Symbol.iterator] : Symbol(Set[Symbol.iterator], Decl(immutable.ts, 399, 88))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>IterableIterator : Symbol(IterableIterator, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 390, 25))
    }
  }
  export function Collection<I extends Collection<any, any>>(collection: I): I;
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>I : Symbol(I, Decl(immutable.ts, 403, 29))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>collection : Symbol(collection, Decl(immutable.ts, 403, 61))
>I : Symbol(I, Decl(immutable.ts, 403, 29))
>I : Symbol(I, Decl(immutable.ts, 403, 29))

  export function Collection<T>(collection: Iterable<T>): Collection.Indexed<T>;
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>T : Symbol(T, Decl(immutable.ts, 404, 29))
>collection : Symbol(collection, Decl(immutable.ts, 404, 32))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>T : Symbol(T, Decl(immutable.ts, 404, 29))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Indexed : Symbol(Collection.Indexed, Decl(immutable.ts, 356, 31), Decl(immutable.ts, 355, 5), Decl(immutable.ts, 357, 79))
>T : Symbol(T, Decl(immutable.ts, 404, 29))

  export function Collection<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>;
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>V : Symbol(V, Decl(immutable.ts, 405, 29))
>obj : Symbol(obj, Decl(immutable.ts, 405, 32))
>key : Symbol(key, Decl(immutable.ts, 405, 39))
>V : Symbol(V, Decl(immutable.ts, 405, 29))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>Keyed : Symbol(Collection.Keyed, Decl(immutable.ts, 337, 29), Decl(immutable.ts, 338, 86), Decl(immutable.ts, 336, 51), Decl(immutable.ts, 339, 83))
>V : Symbol(V, Decl(immutable.ts, 405, 29))

  export interface Collection<K, V> extends ValueObject {
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>ValueObject : Symbol(ValueObject, Decl(immutable.ts, 13, 76))

    // Value equality
    equals(other: any): boolean;
>equals : Symbol(Collection.equals, Decl(immutable.ts, 406, 57))
>other : Symbol(other, Decl(immutable.ts, 408, 11))

    hashCode(): number;
>hashCode : Symbol(Collection.hashCode, Decl(immutable.ts, 408, 32))

    // Reading values
    get<NSV>(key: K, notSetValue: NSV): V | NSV;
>get : Symbol(Collection.get, Decl(immutable.ts, 409, 23), Decl(immutable.ts, 411, 48))
>NSV : Symbol(NSV, Decl(immutable.ts, 411, 8))
>key : Symbol(key, Decl(immutable.ts, 411, 13))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 411, 20))
>NSV : Symbol(NSV, Decl(immutable.ts, 411, 8))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>NSV : Symbol(NSV, Decl(immutable.ts, 411, 8))

    get(key: K): V | undefined;
>get : Symbol(Collection.get, Decl(immutable.ts, 409, 23), Decl(immutable.ts, 411, 48))
>key : Symbol(key, Decl(immutable.ts, 412, 8))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    has(key: K): boolean;
>has : Symbol(Collection.has, Decl(immutable.ts, 412, 31))
>key : Symbol(key, Decl(immutable.ts, 413, 8))
>K : Symbol(K, Decl(immutable.ts, 406, 30))

    includes(value: V): boolean;
>includes : Symbol(Collection.includes, Decl(immutable.ts, 413, 25))
>value : Symbol(value, Decl(immutable.ts, 414, 13))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    contains(value: V): boolean;
>contains : Symbol(Collection.contains, Decl(immutable.ts, 414, 32))
>value : Symbol(value, Decl(immutable.ts, 415, 13))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    first(): V | undefined;
>first : Symbol(Collection.first, Decl(immutable.ts, 415, 32))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    last(): V | undefined;
>last : Symbol(Collection.last, Decl(immutable.ts, 416, 27))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Reading deep values
    getIn(searchKeyPath: Iterable<any>, notSetValue?: any): any;
>getIn : Symbol(Collection.getIn, Decl(immutable.ts, 417, 26))
>searchKeyPath : Symbol(searchKeyPath, Decl(immutable.ts, 419, 10))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 419, 39))

    hasIn(searchKeyPath: Iterable<any>): boolean;
>hasIn : Symbol(Collection.hasIn, Decl(immutable.ts, 419, 64))
>searchKeyPath : Symbol(searchKeyPath, Decl(immutable.ts, 420, 10))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))

    // Persistent changes
    update<R>(updater: (value: this) => R): R;
>update : Symbol(Collection.update, Decl(immutable.ts, 420, 49))
>R : Symbol(R, Decl(immutable.ts, 422, 11))
>updater : Symbol(updater, Decl(immutable.ts, 422, 14))
>value : Symbol(value, Decl(immutable.ts, 422, 24))
>R : Symbol(R, Decl(immutable.ts, 422, 11))
>R : Symbol(R, Decl(immutable.ts, 422, 11))

    // Conversion to JavaScript types
    toJS(): Array<any> | { [key: string]: any };
>toJS : Symbol(Collection.toJS, Decl(immutable.ts, 422, 46))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>key : Symbol(key, Decl(immutable.ts, 424, 28))

    toJSON(): Array<V> | { [key: string]: V };
>toJSON : Symbol(Collection.toJSON, Decl(immutable.ts, 424, 48))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 425, 28))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toArray(): Array<V>;
>toArray : Symbol(Collection.toArray, Decl(immutable.ts, 425, 46))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toObject(): { [key: string]: V };
>toObject : Symbol(Collection.toObject, Decl(immutable.ts, 426, 24))
>key : Symbol(key, Decl(immutable.ts, 427, 19))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Conversion to Collections
    toMap(): Map<K, V>;
>toMap : Symbol(Collection.toMap, Decl(immutable.ts, 427, 37))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toOrderedMap(): OrderedMap<K, V>;
>toOrderedMap : Symbol(Collection.toOrderedMap, Decl(immutable.ts, 429, 23))
>OrderedMap : Symbol(OrderedMap, Decl(immutable.ts, 111, 3), Decl(immutable.ts, 112, 83), Decl(immutable.ts, 113, 85), Decl(immutable.ts, 114, 80), Decl(immutable.ts, 115, 55) ... and 2 more)
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toSet(): Set<V>;
>toSet : Symbol(Collection.toSet, Decl(immutable.ts, 430, 37))
>Set : Symbol(Set, Decl(immutable.ts, 135, 3), Decl(immutable.ts, 136, 34), Decl(immutable.ts, 137, 35), Decl(immutable.ts, 127, 3), Decl(immutable.ts, 138, 58))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toOrderedSet(): OrderedSet<V>;
>toOrderedSet : Symbol(Collection.toOrderedSet, Decl(immutable.ts, 431, 20))
>OrderedSet : Symbol(OrderedSet, Decl(immutable.ts, 165, 3), Decl(immutable.ts, 166, 48), Decl(immutable.ts, 167, 49), Decl(immutable.ts, 159, 3), Decl(immutable.ts, 168, 72))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toList(): List<V>;
>toList : Symbol(Collection.toList, Decl(immutable.ts, 432, 34))
>List : Symbol(List, Decl(immutable.ts, 21, 3), Decl(immutable.ts, 22, 36), Decl(immutable.ts, 23, 37), Decl(immutable.ts, 17, 3), Decl(immutable.ts, 24, 60))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toStack(): Stack<V>;
>toStack : Symbol(Collection.toStack, Decl(immutable.ts, 433, 22))
>Stack : Symbol(Stack, Decl(immutable.ts, 184, 3), Decl(immutable.ts, 185, 38), Decl(immutable.ts, 186, 39), Decl(immutable.ts, 180, 3), Decl(immutable.ts, 187, 62))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Conversion to Seq
    toSeq(): this;
>toSeq : Symbol(Collection.toSeq, Decl(immutable.ts, 434, 24))

    toKeyedSeq(): Seq.Keyed<K, V>;
>toKeyedSeq : Symbol(Collection.toKeyedSeq, Decl(immutable.ts, 436, 18))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Seq.Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toIndexedSeq(): Seq.Indexed<V>;
>toIndexedSeq : Symbol(Collection.toIndexedSeq, Decl(immutable.ts, 437, 34))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    toSetSeq(): Seq.Set<V>;
>toSetSeq : Symbol(Collection.toSetSeq, Decl(immutable.ts, 438, 35))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Set : Symbol(Seq.Set, Decl(immutable.ts, 300, 5), Decl(immutable.ts, 301, 40), Decl(immutable.ts, 302, 41), Decl(immutable.ts, 297, 5), Decl(immutable.ts, 303, 64))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Iterators
    keys(): IterableIterator<K>;
>keys : Symbol(Collection.keys, Decl(immutable.ts, 439, 27))
>IterableIterator : Symbol(IterableIterator, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 406, 30))

    values(): IterableIterator<V>;
>values : Symbol(Collection.values, Decl(immutable.ts, 441, 32))
>IterableIterator : Symbol(IterableIterator, Decl(lib.es2015.iterable.d.ts, --, --))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    entries(): IterableIterator<[K, V]>;
>entries : Symbol(Collection.entries, Decl(immutable.ts, 442, 34))
>IterableIterator : Symbol(IterableIterator, Decl(lib.es2015.iterable.d.ts, --, --))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Collections (Seq)
    keySeq(): Seq.Indexed<K>;
>keySeq : Symbol(Collection.keySeq, Decl(immutable.ts, 443, 40))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>K : Symbol(K, Decl(immutable.ts, 406, 30))

    valueSeq(): Seq.Indexed<V>;
>valueSeq : Symbol(Collection.valueSeq, Decl(immutable.ts, 445, 29))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    entrySeq(): Seq.Indexed<[K, V]>;
>entrySeq : Symbol(Collection.entrySeq, Decl(immutable.ts, 446, 31))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Indexed : Symbol(Seq.Indexed, Decl(immutable.ts, 284, 5), Decl(immutable.ts, 285, 48), Decl(immutable.ts, 286, 49), Decl(immutable.ts, 281, 5), Decl(immutable.ts, 287, 72))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Sequence algorithms
    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Collection<K, M>;
>map : Symbol(Collection.map, Decl(immutable.ts, 447, 36))
>M : Symbol(M, Decl(immutable.ts, 449, 8))
>mapper : Symbol(mapper, Decl(immutable.ts, 449, 11))
>value : Symbol(value, Decl(immutable.ts, 449, 20))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 449, 29))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 449, 37))
>M : Symbol(M, Decl(immutable.ts, 449, 8))
>context : Symbol(context, Decl(immutable.ts, 449, 55))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>M : Symbol(M, Decl(immutable.ts, 449, 8))

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Collection<K, F>;
>filter : Symbol(Collection.filter, Decl(immutable.ts, 449, 89), Decl(immutable.ts, 450, 114))
>F : Symbol(F, Decl(immutable.ts, 450, 11))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>predicate : Symbol(predicate, Decl(immutable.ts, 450, 24))
>value : Symbol(value, Decl(immutable.ts, 450, 36))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 450, 45))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 450, 53))
>value : Symbol(value, Decl(immutable.ts, 450, 36))
>F : Symbol(F, Decl(immutable.ts, 450, 11))
>context : Symbol(context, Decl(immutable.ts, 450, 80))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>F : Symbol(F, Decl(immutable.ts, 450, 11))

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : Symbol(Collection.filter, Decl(immutable.ts, 449, 89), Decl(immutable.ts, 450, 114))
>predicate : Symbol(predicate, Decl(immutable.ts, 451, 11))
>value : Symbol(value, Decl(immutable.ts, 451, 23))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 451, 32))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 451, 40))
>context : Symbol(context, Decl(immutable.ts, 451, 60))

    filterNot(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>filterNot : Symbol(Collection.filterNot, Decl(immutable.ts, 451, 82))
>predicate : Symbol(predicate, Decl(immutable.ts, 452, 14))
>value : Symbol(value, Decl(immutable.ts, 452, 26))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 452, 35))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 452, 43))
>context : Symbol(context, Decl(immutable.ts, 452, 67))

    reverse(): this;
>reverse : Symbol(Collection.reverse, Decl(immutable.ts, 452, 89))

    sort(comparator?: (valueA: V, valueB: V) => number): this;
>sort : Symbol(Collection.sort, Decl(immutable.ts, 453, 20))
>comparator : Symbol(comparator, Decl(immutable.ts, 454, 9))
>valueA : Symbol(valueA, Decl(immutable.ts, 454, 23))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>valueB : Symbol(valueB, Decl(immutable.ts, 454, 33))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): this;
>sortBy : Symbol(Collection.sortBy, Decl(immutable.ts, 454, 62))
>C : Symbol(C, Decl(immutable.ts, 455, 11))
>comparatorValueMapper : Symbol(comparatorValueMapper, Decl(immutable.ts, 455, 14))
>value : Symbol(value, Decl(immutable.ts, 455, 38))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 455, 47))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 455, 55))
>C : Symbol(C, Decl(immutable.ts, 455, 11))
>comparator : Symbol(comparator, Decl(immutable.ts, 455, 73))
>valueA : Symbol(valueA, Decl(immutable.ts, 455, 88))
>C : Symbol(C, Decl(immutable.ts, 455, 11))
>valueB : Symbol(valueB, Decl(immutable.ts, 455, 98))
>C : Symbol(C, Decl(immutable.ts, 455, 11))

    groupBy<G>(grouper: (value: V, key: K, iter: this) => G, context?: any): /*Map*/Seq.Keyed<G, /*this*/Collection<K, V>>;
>groupBy : Symbol(Collection.groupBy, Decl(immutable.ts, 455, 127))
>G : Symbol(G, Decl(immutable.ts, 456, 12))
>grouper : Symbol(grouper, Decl(immutable.ts, 456, 15))
>value : Symbol(value, Decl(immutable.ts, 456, 25))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 456, 34))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 456, 42))
>G : Symbol(G, Decl(immutable.ts, 456, 12))
>context : Symbol(context, Decl(immutable.ts, 456, 60))
>Seq : Symbol(Seq, Decl(immutable.ts, 314, 3), Decl(immutable.ts, 315, 58), Decl(immutable.ts, 316, 81), Decl(immutable.ts, 317, 76), Decl(immutable.ts, 318, 68) ... and 4 more)
>Keyed : Symbol(Seq.Keyed, Decl(immutable.ts, 264, 29), Decl(immutable.ts, 265, 79), Decl(immutable.ts, 266, 76), Decl(immutable.ts, 267, 51), Decl(immutable.ts, 263, 56) ... and 1 more)
>G : Symbol(G, Decl(immutable.ts, 456, 12))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Side effects
    forEach(sideEffect: (value: V, key: K, iter: this) => any, context?: any): number;
>forEach : Symbol(Collection.forEach, Decl(immutable.ts, 456, 123))
>sideEffect : Symbol(sideEffect, Decl(immutable.ts, 458, 12))
>value : Symbol(value, Decl(immutable.ts, 458, 25))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 458, 34))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 458, 42))
>context : Symbol(context, Decl(immutable.ts, 458, 62))

    // Creating subsets
    slice(begin?: number, end?: number): this;
>slice : Symbol(Collection.slice, Decl(immutable.ts, 458, 86))
>begin : Symbol(begin, Decl(immutable.ts, 460, 10))
>end : Symbol(end, Decl(immutable.ts, 460, 25))

    rest(): this;
>rest : Symbol(Collection.rest, Decl(immutable.ts, 460, 46))

    butLast(): this;
>butLast : Symbol(Collection.butLast, Decl(immutable.ts, 461, 17))

    skip(amount: number): this;
>skip : Symbol(Collection.skip, Decl(immutable.ts, 462, 20))
>amount : Symbol(amount, Decl(immutable.ts, 463, 9))

    skipLast(amount: number): this;
>skipLast : Symbol(Collection.skipLast, Decl(immutable.ts, 463, 31))
>amount : Symbol(amount, Decl(immutable.ts, 464, 13))

    skipWhile(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>skipWhile : Symbol(Collection.skipWhile, Decl(immutable.ts, 464, 35))
>predicate : Symbol(predicate, Decl(immutable.ts, 465, 14))
>value : Symbol(value, Decl(immutable.ts, 465, 26))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 465, 35))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 465, 43))
>context : Symbol(context, Decl(immutable.ts, 465, 67))

    skipUntil(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>skipUntil : Symbol(Collection.skipUntil, Decl(immutable.ts, 465, 89))
>predicate : Symbol(predicate, Decl(immutable.ts, 466, 14))
>value : Symbol(value, Decl(immutable.ts, 466, 26))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 466, 35))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 466, 43))
>context : Symbol(context, Decl(immutable.ts, 466, 67))

    take(amount: number): this;
>take : Symbol(Collection.take, Decl(immutable.ts, 466, 89))
>amount : Symbol(amount, Decl(immutable.ts, 467, 9))

    takeLast(amount: number): this;
>takeLast : Symbol(Collection.takeLast, Decl(immutable.ts, 467, 31))
>amount : Symbol(amount, Decl(immutable.ts, 468, 13))

    takeWhile(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>takeWhile : Symbol(Collection.takeWhile, Decl(immutable.ts, 468, 35))
>predicate : Symbol(predicate, Decl(immutable.ts, 469, 14))
>value : Symbol(value, Decl(immutable.ts, 469, 26))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 469, 35))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 469, 43))
>context : Symbol(context, Decl(immutable.ts, 469, 67))

    takeUntil(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>takeUntil : Symbol(Collection.takeUntil, Decl(immutable.ts, 469, 89))
>predicate : Symbol(predicate, Decl(immutable.ts, 470, 14))
>value : Symbol(value, Decl(immutable.ts, 470, 26))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 470, 35))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 470, 43))
>context : Symbol(context, Decl(immutable.ts, 470, 67))

    // Combination
    concat(...valuesOrCollections: Array<any>): Collection<any, any>;
>concat : Symbol(Collection.concat, Decl(immutable.ts, 470, 89))
>valuesOrCollections : Symbol(valuesOrCollections, Decl(immutable.ts, 472, 11))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))

    flatten(depth?: number): Collection<any, any>;
>flatten : Symbol(Collection.flatten, Decl(immutable.ts, 472, 69), Decl(immutable.ts, 473, 50))
>depth : Symbol(depth, Decl(immutable.ts, 473, 12))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))

    flatten(shallow?: boolean): Collection<any, any>;
>flatten : Symbol(Collection.flatten, Decl(immutable.ts, 472, 69), Decl(immutable.ts, 473, 50))
>shallow : Symbol(shallow, Decl(immutable.ts, 474, 12))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Collection<K, M>;
>flatMap : Symbol(Collection.flatMap, Decl(immutable.ts, 474, 53))
>M : Symbol(M, Decl(immutable.ts, 475, 12))
>mapper : Symbol(mapper, Decl(immutable.ts, 475, 15))
>value : Symbol(value, Decl(immutable.ts, 475, 24))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 475, 33))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 475, 41))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>M : Symbol(M, Decl(immutable.ts, 475, 12))
>context : Symbol(context, Decl(immutable.ts, 475, 69))
>Collection : Symbol(Collection, Decl(immutable.ts, 402, 3), Decl(immutable.ts, 403, 79), Decl(immutable.ts, 404, 80), Decl(immutable.ts, 331, 3), Decl(immutable.ts, 405, 86))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>M : Symbol(M, Decl(immutable.ts, 475, 12))

    // Reducing a value
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
>reduce : Symbol(Collection.reduce, Decl(immutable.ts, 475, 103), Decl(immutable.ts, 477, 113))
>R : Symbol(R, Decl(immutable.ts, 477, 11))
>reducer : Symbol(reducer, Decl(immutable.ts, 477, 14))
>reduction : Symbol(reduction, Decl(immutable.ts, 477, 24))
>R : Symbol(R, Decl(immutable.ts, 477, 11))
>value : Symbol(value, Decl(immutable.ts, 477, 37))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 477, 47))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 477, 55))
>R : Symbol(R, Decl(immutable.ts, 477, 11))
>initialReduction : Symbol(initialReduction, Decl(immutable.ts, 477, 73))
>R : Symbol(R, Decl(immutable.ts, 477, 11))
>context : Symbol(context, Decl(immutable.ts, 477, 94))
>R : Symbol(R, Decl(immutable.ts, 477, 11))

    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
>reduce : Symbol(Collection.reduce, Decl(immutable.ts, 475, 103), Decl(immutable.ts, 477, 113))
>R : Symbol(R, Decl(immutable.ts, 478, 11))
>reducer : Symbol(reducer, Decl(immutable.ts, 478, 14))
>reduction : Symbol(reduction, Decl(immutable.ts, 478, 24))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>R : Symbol(R, Decl(immutable.ts, 478, 11))
>value : Symbol(value, Decl(immutable.ts, 478, 41))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 478, 51))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 478, 59))
>R : Symbol(R, Decl(immutable.ts, 478, 11))
>R : Symbol(R, Decl(immutable.ts, 478, 11))

    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
>reduceRight : Symbol(Collection.reduceRight, Decl(immutable.ts, 478, 81), Decl(immutable.ts, 479, 118))
>R : Symbol(R, Decl(immutable.ts, 479, 16))
>reducer : Symbol(reducer, Decl(immutable.ts, 479, 19))
>reduction : Symbol(reduction, Decl(immutable.ts, 479, 29))
>R : Symbol(R, Decl(immutable.ts, 479, 16))
>value : Symbol(value, Decl(immutable.ts, 479, 42))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 479, 52))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 479, 60))
>R : Symbol(R, Decl(immutable.ts, 479, 16))
>initialReduction : Symbol(initialReduction, Decl(immutable.ts, 479, 78))
>R : Symbol(R, Decl(immutable.ts, 479, 16))
>context : Symbol(context, Decl(immutable.ts, 479, 99))
>R : Symbol(R, Decl(immutable.ts, 479, 16))

    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
>reduceRight : Symbol(Collection.reduceRight, Decl(immutable.ts, 478, 81), Decl(immutable.ts, 479, 118))
>R : Symbol(R, Decl(immutable.ts, 480, 16))
>reducer : Symbol(reducer, Decl(immutable.ts, 480, 19))
>reduction : Symbol(reduction, Decl(immutable.ts, 480, 29))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>R : Symbol(R, Decl(immutable.ts, 480, 16))
>value : Symbol(value, Decl(immutable.ts, 480, 46))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 480, 56))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 480, 64))
>R : Symbol(R, Decl(immutable.ts, 480, 16))
>R : Symbol(R, Decl(immutable.ts, 480, 16))

    every(predicate: (value: V, key: K, iter: this) => boolean, context?: any): boolean;
>every : Symbol(Collection.every, Decl(immutable.ts, 480, 86))
>predicate : Symbol(predicate, Decl(immutable.ts, 481, 10))
>value : Symbol(value, Decl(immutable.ts, 481, 22))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 481, 31))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 481, 39))
>context : Symbol(context, Decl(immutable.ts, 481, 63))

    some(predicate: (value: V, key: K, iter: this) => boolean, context?: any): boolean;
>some : Symbol(Collection.some, Decl(immutable.ts, 481, 88))
>predicate : Symbol(predicate, Decl(immutable.ts, 482, 9))
>value : Symbol(value, Decl(immutable.ts, 482, 21))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 482, 30))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 482, 38))
>context : Symbol(context, Decl(immutable.ts, 482, 62))

    join(separator?: string): string;
>join : Symbol(Collection.join, Decl(immutable.ts, 482, 87))
>separator : Symbol(separator, Decl(immutable.ts, 483, 9))

    isEmpty(): boolean;
>isEmpty : Symbol(Collection.isEmpty, Decl(immutable.ts, 483, 37))

    count(): number;
>count : Symbol(Collection.count, Decl(immutable.ts, 484, 23), Decl(immutable.ts, 485, 20))

    count(predicate: (value: V, key: K, iter: this) => boolean, context?: any): number;
>count : Symbol(Collection.count, Decl(immutable.ts, 484, 23), Decl(immutable.ts, 485, 20))
>predicate : Symbol(predicate, Decl(immutable.ts, 486, 10))
>value : Symbol(value, Decl(immutable.ts, 486, 22))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 486, 31))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 486, 39))
>context : Symbol(context, Decl(immutable.ts, 486, 63))

    countBy<G>(grouper: (value: V, key: K, iter: this) => G, context?: any): Map<G, number>;
>countBy : Symbol(Collection.countBy, Decl(immutable.ts, 486, 87))
>G : Symbol(G, Decl(immutable.ts, 487, 12))
>grouper : Symbol(grouper, Decl(immutable.ts, 487, 15))
>value : Symbol(value, Decl(immutable.ts, 487, 25))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 487, 34))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 487, 42))
>G : Symbol(G, Decl(immutable.ts, 487, 12))
>context : Symbol(context, Decl(immutable.ts, 487, 60))
>Map : Symbol(Map, Decl(immutable.ts, 66, 3), Decl(immutable.ts, 67, 69), Decl(immutable.ts, 68, 71), Decl(immutable.ts, 69, 66), Decl(immutable.ts, 70, 41) ... and 2 more)
>G : Symbol(G, Decl(immutable.ts, 487, 12))

    // Search for value
    find(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): V | undefined;
>find : Symbol(Collection.find, Decl(immutable.ts, 487, 92))
>predicate : Symbol(predicate, Decl(immutable.ts, 489, 9))
>value : Symbol(value, Decl(immutable.ts, 489, 21))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 489, 30))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 489, 38))
>context : Symbol(context, Decl(immutable.ts, 489, 62))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 489, 77))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    findLast(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): V | undefined;
>findLast : Symbol(Collection.findLast, Decl(immutable.ts, 489, 110))
>predicate : Symbol(predicate, Decl(immutable.ts, 490, 13))
>value : Symbol(value, Decl(immutable.ts, 490, 25))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 490, 34))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 490, 42))
>context : Symbol(context, Decl(immutable.ts, 490, 66))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 490, 81))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    findEntry(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): [K, V] | undefined;
>findEntry : Symbol(Collection.findEntry, Decl(immutable.ts, 490, 114))
>predicate : Symbol(predicate, Decl(immutable.ts, 491, 14))
>value : Symbol(value, Decl(immutable.ts, 491, 26))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 491, 35))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 491, 43))
>context : Symbol(context, Decl(immutable.ts, 491, 67))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 491, 82))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): [K, V] | undefined;
>findLastEntry : Symbol(Collection.findLastEntry, Decl(immutable.ts, 491, 120))
>predicate : Symbol(predicate, Decl(immutable.ts, 492, 18))
>value : Symbol(value, Decl(immutable.ts, 492, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 492, 39))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 492, 47))
>context : Symbol(context, Decl(immutable.ts, 492, 71))
>notSetValue : Symbol(notSetValue, Decl(immutable.ts, 492, 86))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    findKey(predicate: (value: V, key: K, iter: this) => boolean, context?: any): K | undefined;
>findKey : Symbol(Collection.findKey, Decl(immutable.ts, 492, 124))
>predicate : Symbol(predicate, Decl(immutable.ts, 493, 12))
>value : Symbol(value, Decl(immutable.ts, 493, 24))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 493, 33))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 493, 41))
>context : Symbol(context, Decl(immutable.ts, 493, 65))
>K : Symbol(K, Decl(immutable.ts, 406, 30))

    findLastKey(predicate: (value: V, key: K, iter: this) => boolean, context?: any): K | undefined;
>findLastKey : Symbol(Collection.findLastKey, Decl(immutable.ts, 493, 96))
>predicate : Symbol(predicate, Decl(immutable.ts, 494, 16))
>value : Symbol(value, Decl(immutable.ts, 494, 28))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 494, 37))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 494, 45))
>context : Symbol(context, Decl(immutable.ts, 494, 69))
>K : Symbol(K, Decl(immutable.ts, 406, 30))

    keyOf(searchValue: V): K | undefined;
>keyOf : Symbol(Collection.keyOf, Decl(immutable.ts, 494, 100))
>searchValue : Symbol(searchValue, Decl(immutable.ts, 495, 10))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>K : Symbol(K, Decl(immutable.ts, 406, 30))

    lastKeyOf(searchValue: V): K | undefined;
>lastKeyOf : Symbol(Collection.lastKeyOf, Decl(immutable.ts, 495, 41))
>searchValue : Symbol(searchValue, Decl(immutable.ts, 496, 14))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>K : Symbol(K, Decl(immutable.ts, 406, 30))

    max(comparator?: (valueA: V, valueB: V) => number): V | undefined;
>max : Symbol(Collection.max, Decl(immutable.ts, 496, 45))
>comparator : Symbol(comparator, Decl(immutable.ts, 497, 8))
>valueA : Symbol(valueA, Decl(immutable.ts, 497, 22))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>valueB : Symbol(valueB, Decl(immutable.ts, 497, 32))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): V | undefined;
>maxBy : Symbol(Collection.maxBy, Decl(immutable.ts, 497, 70))
>C : Symbol(C, Decl(immutable.ts, 498, 10))
>comparatorValueMapper : Symbol(comparatorValueMapper, Decl(immutable.ts, 498, 13))
>value : Symbol(value, Decl(immutable.ts, 498, 37))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 498, 46))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 498, 54))
>C : Symbol(C, Decl(immutable.ts, 498, 10))
>comparator : Symbol(comparator, Decl(immutable.ts, 498, 72))
>valueA : Symbol(valueA, Decl(immutable.ts, 498, 87))
>C : Symbol(C, Decl(immutable.ts, 498, 10))
>valueB : Symbol(valueB, Decl(immutable.ts, 498, 97))
>C : Symbol(C, Decl(immutable.ts, 498, 10))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    min(comparator?: (valueA: V, valueB: V) => number): V | undefined;
>min : Symbol(Collection.min, Decl(immutable.ts, 498, 135))
>comparator : Symbol(comparator, Decl(immutable.ts, 499, 8))
>valueA : Symbol(valueA, Decl(immutable.ts, 499, 22))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>valueB : Symbol(valueB, Decl(immutable.ts, 499, 32))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): V | undefined;
>minBy : Symbol(Collection.minBy, Decl(immutable.ts, 499, 70))
>C : Symbol(C, Decl(immutable.ts, 500, 10))
>comparatorValueMapper : Symbol(comparatorValueMapper, Decl(immutable.ts, 500, 13))
>value : Symbol(value, Decl(immutable.ts, 500, 37))
>V : Symbol(V, Decl(immutable.ts, 406, 32))
>key : Symbol(key, Decl(immutable.ts, 500, 46))
>K : Symbol(K, Decl(immutable.ts, 406, 30))
>iter : Symbol(iter, Decl(immutable.ts, 500, 54))
>C : Symbol(C, Decl(immutable.ts, 500, 10))
>comparator : Symbol(comparator, Decl(immutable.ts, 500, 72))
>valueA : Symbol(valueA, Decl(immutable.ts, 500, 87))
>C : Symbol(C, Decl(immutable.ts, 500, 10))
>valueB : Symbol(valueB, Decl(immutable.ts, 500, 97))
>C : Symbol(C, Decl(immutable.ts, 500, 10))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    // Comparison
    isSubset(iter: Iterable<V>): boolean;
>isSubset : Symbol(Collection.isSubset, Decl(immutable.ts, 500, 135))
>iter : Symbol(iter, Decl(immutable.ts, 502, 13))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    isSuperset(iter: Iterable<V>): boolean;
>isSuperset : Symbol(Collection.isSuperset, Decl(immutable.ts, 502, 41))
>iter : Symbol(iter, Decl(immutable.ts, 503, 15))
>Iterable : Symbol(Iterable, Decl(lib.es2015.iterable.d.ts, --, --))
>V : Symbol(V, Decl(immutable.ts, 406, 32))

    readonly size: number;
>size : Symbol(Collection.size, Decl(immutable.ts, 503, 43))
  }
}
declare module "immutable" {
>"immutable" : Symbol("immutable", Decl(immutable.ts, 506, 1))

  export = Immutable
>Immutable : Symbol(Immutable, Decl(immutable.ts, 0, 0))
}

