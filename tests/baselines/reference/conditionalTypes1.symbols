=== tests/cases/conformance/types/conditional/conditionalTypes1.ts ===
type T00 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"
>T00 : Symbol(T00, Decl(conditionalTypes1.ts, 0, 0))
>Exclude : Symbol(Exclude, Decl(lib.d.ts, --, --))

type T01 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"
>T01 : Symbol(T01, Decl(conditionalTypes1.ts, 0, 59))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))

type T02 = Exclude<string | number | (() => void), Function>;  // string | number
>T02 : Symbol(T02, Decl(conditionalTypes1.ts, 1, 59))
>Exclude : Symbol(Exclude, Decl(lib.d.ts, --, --))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

type T03 = Extract<string | number | (() => void), Function>;  // () => void
>T03 : Symbol(T03, Decl(conditionalTypes1.ts, 3, 61))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

type T04 = NonNullable<string | number | undefined>;  // string | number
>T04 : Symbol(T04, Decl(conditionalTypes1.ts, 4, 61))
>NonNullable : Symbol(NonNullable, Decl(lib.d.ts, --, --))

type T05 = NonNullable<(() => string) | string[] | null | undefined>;  // (() => string) | string[]
>T05 : Symbol(T05, Decl(conditionalTypes1.ts, 6, 52))
>NonNullable : Symbol(NonNullable, Decl(lib.d.ts, --, --))

function f1<T>(x: T, y: NonNullable<T>) {
>f1 : Symbol(f1, Decl(conditionalTypes1.ts, 7, 69))
>T : Symbol(T, Decl(conditionalTypes1.ts, 9, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 9, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 9, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 9, 20))
>NonNullable : Symbol(NonNullable, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 9, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 9, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 9, 20))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 9, 20))
>x : Symbol(x, Decl(conditionalTypes1.ts, 9, 15))
}

function f2<T extends string | undefined>(x: T, y: NonNullable<T>) {
>f2 : Symbol(f2, Decl(conditionalTypes1.ts, 12, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 14, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 14, 42))
>T : Symbol(T, Decl(conditionalTypes1.ts, 14, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 14, 47))
>NonNullable : Symbol(NonNullable, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 14, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 14, 42))
>y : Symbol(y, Decl(conditionalTypes1.ts, 14, 47))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 14, 47))
>x : Symbol(x, Decl(conditionalTypes1.ts, 14, 42))

    let s1: string = x;  // Error
>s1 : Symbol(s1, Decl(conditionalTypes1.ts, 17, 7))
>x : Symbol(x, Decl(conditionalTypes1.ts, 14, 42))

    let s2: string = y;
>s2 : Symbol(s2, Decl(conditionalTypes1.ts, 18, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 14, 47))
}

function f3<T>(x: Partial<T>[keyof T], y: NonNullable<Partial<T>[keyof T]>) {
>f3 : Symbol(f3, Decl(conditionalTypes1.ts, 19, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 21, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 21, 15))
>Partial : Symbol(Partial, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 21, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 21, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 21, 38))
>NonNullable : Symbol(NonNullable, Decl(lib.d.ts, --, --))
>Partial : Symbol(Partial, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 21, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 21, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 21, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 21, 38))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 21, 38))
>x : Symbol(x, Decl(conditionalTypes1.ts, 21, 15))
}

function f4<T extends { x: string | undefined }>(x: T["x"], y: NonNullable<T["x"]>) {
>f4 : Symbol(f4, Decl(conditionalTypes1.ts, 24, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 26, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 26, 23))
>x : Symbol(x, Decl(conditionalTypes1.ts, 26, 49))
>T : Symbol(T, Decl(conditionalTypes1.ts, 26, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 26, 59))
>NonNullable : Symbol(NonNullable, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 26, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 26, 49))
>y : Symbol(y, Decl(conditionalTypes1.ts, 26, 59))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 26, 59))
>x : Symbol(x, Decl(conditionalTypes1.ts, 26, 49))

    let s1: string = x;  // Error
>s1 : Symbol(s1, Decl(conditionalTypes1.ts, 29, 7))
>x : Symbol(x, Decl(conditionalTypes1.ts, 26, 49))

    let s2: string = y;
>s2 : Symbol(s2, Decl(conditionalTypes1.ts, 30, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 26, 59))
}

type Options = { k: "a", a: number } | { k: "b", b: string } | { k: "c", c: boolean };
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 33, 16))
>a : Symbol(a, Decl(conditionalTypes1.ts, 33, 24))
>k : Symbol(k, Decl(conditionalTypes1.ts, 33, 40))
>b : Symbol(b, Decl(conditionalTypes1.ts, 33, 48))
>k : Symbol(k, Decl(conditionalTypes1.ts, 33, 64))
>c : Symbol(c, Decl(conditionalTypes1.ts, 33, 72))

type T10 = Exclude<Options, { k: "a" | "b" }>;  // { k: "c", c: boolean }
>T10 : Symbol(T10, Decl(conditionalTypes1.ts, 33, 86))
>Exclude : Symbol(Exclude, Decl(lib.d.ts, --, --))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 35, 29))

type T11 = Extract<Options, { k: "a" | "b" }>;  // { k: "a", a: number } | { k: "b", b: string }
>T11 : Symbol(T11, Decl(conditionalTypes1.ts, 35, 46))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 36, 29))

type T12 = Exclude<Options, { k: "a" } | { k: "b" }>;  // { k: "c", c: boolean }
>T12 : Symbol(T12, Decl(conditionalTypes1.ts, 36, 46))
>Exclude : Symbol(Exclude, Decl(lib.d.ts, --, --))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 38, 29))
>k : Symbol(k, Decl(conditionalTypes1.ts, 38, 42))

type T13 = Extract<Options, { k: "a" } | { k: "b" }>;  // { k: "a", a: number } | { k: "b", b: string }
>T13 : Symbol(T13, Decl(conditionalTypes1.ts, 38, 53))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 39, 29))
>k : Symbol(k, Decl(conditionalTypes1.ts, 39, 42))

type T14 = Exclude<Options, { q: "a" }>;  // Options
>T14 : Symbol(T14, Decl(conditionalTypes1.ts, 39, 53))
>Exclude : Symbol(Exclude, Decl(lib.d.ts, --, --))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>q : Symbol(q, Decl(conditionalTypes1.ts, 41, 29))

type T15 = Extract<Options, { q: "a" }>;  // never
>T15 : Symbol(T15, Decl(conditionalTypes1.ts, 41, 40))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>q : Symbol(q, Decl(conditionalTypes1.ts, 42, 29))

declare function f5<T extends Options, K extends string>(p: K): Extract<T, { k: K }>;
>f5 : Symbol(f5, Decl(conditionalTypes1.ts, 42, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 44, 20))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>K : Symbol(K, Decl(conditionalTypes1.ts, 44, 38))
>p : Symbol(p, Decl(conditionalTypes1.ts, 44, 57))
>K : Symbol(K, Decl(conditionalTypes1.ts, 44, 38))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 44, 20))
>k : Symbol(k, Decl(conditionalTypes1.ts, 44, 76))
>K : Symbol(K, Decl(conditionalTypes1.ts, 44, 38))

let x0 = f5("a");  // { k: "a", a: number }
>x0 : Symbol(x0, Decl(conditionalTypes1.ts, 45, 3))
>f5 : Symbol(f5, Decl(conditionalTypes1.ts, 42, 40))

type OptionsOfKind<K extends Options["k"]> = Extract<Options, { k: K }>;
>OptionsOfKind : Symbol(OptionsOfKind, Decl(conditionalTypes1.ts, 45, 17))
>K : Symbol(K, Decl(conditionalTypes1.ts, 47, 19))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 47, 63))
>K : Symbol(K, Decl(conditionalTypes1.ts, 47, 19))

type T16 = OptionsOfKind<"a" | "b">;  // { k: "a", a: number } | { k: "b", b: string }
>T16 : Symbol(T16, Decl(conditionalTypes1.ts, 47, 72))
>OptionsOfKind : Symbol(OptionsOfKind, Decl(conditionalTypes1.ts, 45, 17))

type Select<T, K extends keyof T, V extends T[K]> = Extract<T, { [P in K]: V }>;
>Select : Symbol(Select, Decl(conditionalTypes1.ts, 49, 36))
>T : Symbol(T, Decl(conditionalTypes1.ts, 51, 12))
>K : Symbol(K, Decl(conditionalTypes1.ts, 51, 14))
>T : Symbol(T, Decl(conditionalTypes1.ts, 51, 12))
>V : Symbol(V, Decl(conditionalTypes1.ts, 51, 33))
>T : Symbol(T, Decl(conditionalTypes1.ts, 51, 12))
>K : Symbol(K, Decl(conditionalTypes1.ts, 51, 14))
>Extract : Symbol(Extract, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 51, 12))
>P : Symbol(P, Decl(conditionalTypes1.ts, 51, 66))
>K : Symbol(K, Decl(conditionalTypes1.ts, 51, 14))
>V : Symbol(V, Decl(conditionalTypes1.ts, 51, 33))

type T17 = Select<Options, "k", "a" | "b">;  // // { k: "a", a: number } | { k: "b", b: string }
>T17 : Symbol(T17, Decl(conditionalTypes1.ts, 51, 80))
>Select : Symbol(Select, Decl(conditionalTypes1.ts, 49, 36))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 31, 1))

type TypeName<T> =
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 53, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 14))

    T extends string ? "string" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 14))

    T extends number ? "number" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 14))

    T extends boolean ? "boolean" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 14))

    T extends undefined ? "undefined" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 14))

    T extends Function ? "function" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 14))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

    "object";

type T20 = TypeName<string | (() => void)>;  // "string" | "function"
>T20 : Symbol(T20, Decl(conditionalTypes1.ts, 61, 13))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 53, 43))

type T21 = TypeName<any>;  // "string" | "number" | "boolean" | "undefined" | "function" | "object"
>T21 : Symbol(T21, Decl(conditionalTypes1.ts, 63, 43))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 53, 43))

type T22 = TypeName<never>;  // never
>T22 : Symbol(T22, Decl(conditionalTypes1.ts, 64, 25))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 53, 43))

type T23 = TypeName<{}>;  // "object"
>T23 : Symbol(T23, Decl(conditionalTypes1.ts, 65, 27))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 53, 43))

type KnockoutObservable<T> = { object: T };
>KnockoutObservable : Symbol(KnockoutObservable, Decl(conditionalTypes1.ts, 66, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 68, 24))
>object : Symbol(object, Decl(conditionalTypes1.ts, 68, 30))
>T : Symbol(T, Decl(conditionalTypes1.ts, 68, 24))

type KnockoutObservableArray<T> = { array: T };
>KnockoutObservableArray : Symbol(KnockoutObservableArray, Decl(conditionalTypes1.ts, 68, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 69, 29))
>array : Symbol(array, Decl(conditionalTypes1.ts, 69, 35))
>T : Symbol(T, Decl(conditionalTypes1.ts, 69, 29))

type KnockedOut<T> = T extends any[] ? KnockoutObservableArray<T[number]> : KnockoutObservable<T>;
>KnockedOut : Symbol(KnockedOut, Decl(conditionalTypes1.ts, 69, 47))
>T : Symbol(T, Decl(conditionalTypes1.ts, 71, 16))
>T : Symbol(T, Decl(conditionalTypes1.ts, 71, 16))
>KnockoutObservableArray : Symbol(KnockoutObservableArray, Decl(conditionalTypes1.ts, 68, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 71, 16))
>KnockoutObservable : Symbol(KnockoutObservable, Decl(conditionalTypes1.ts, 66, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 71, 16))

type KnockedOutObj<T> = {
>KnockedOutObj : Symbol(KnockedOutObj, Decl(conditionalTypes1.ts, 71, 98))
>T : Symbol(T, Decl(conditionalTypes1.ts, 73, 19))

    [P in keyof T]: KnockedOut<T[P]>;
>P : Symbol(P, Decl(conditionalTypes1.ts, 74, 5))
>T : Symbol(T, Decl(conditionalTypes1.ts, 73, 19))
>KnockedOut : Symbol(KnockedOut, Decl(conditionalTypes1.ts, 69, 47))
>T : Symbol(T, Decl(conditionalTypes1.ts, 73, 19))
>P : Symbol(P, Decl(conditionalTypes1.ts, 74, 5))
}

interface Item {
>Item : Symbol(Item, Decl(conditionalTypes1.ts, 75, 1))

    id: number;
>id : Symbol(Item.id, Decl(conditionalTypes1.ts, 77, 16))

    name: string;
>name : Symbol(Item.name, Decl(conditionalTypes1.ts, 78, 15))

    subitems: string[];
>subitems : Symbol(Item.subitems, Decl(conditionalTypes1.ts, 79, 17))
}

type KOItem = KnockedOutObj<Item>;
>KOItem : Symbol(KOItem, Decl(conditionalTypes1.ts, 81, 1))
>KnockedOutObj : Symbol(KnockedOutObj, Decl(conditionalTypes1.ts, 71, 98))
>Item : Symbol(Item, Decl(conditionalTypes1.ts, 75, 1))

interface Part {
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 83, 34))

    id: number;
>id : Symbol(Part.id, Decl(conditionalTypes1.ts, 85, 16))

    name: string;
>name : Symbol(Part.name, Decl(conditionalTypes1.ts, 86, 15))

    subparts: Part[];
>subparts : Symbol(Part.subparts, Decl(conditionalTypes1.ts, 87, 17))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 83, 34))

    updatePart(newName: string): void;
>updatePart : Symbol(Part.updatePart, Decl(conditionalTypes1.ts, 88, 21))
>newName : Symbol(newName, Decl(conditionalTypes1.ts, 89, 15))
}

type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
>FunctionPropertyNames : Symbol(FunctionPropertyNames, Decl(conditionalTypes1.ts, 90, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 92, 27))
>K : Symbol(K, Decl(conditionalTypes1.ts, 92, 35))
>T : Symbol(T, Decl(conditionalTypes1.ts, 92, 27))
>T : Symbol(T, Decl(conditionalTypes1.ts, 92, 27))
>K : Symbol(K, Decl(conditionalTypes1.ts, 92, 35))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))
>K : Symbol(K, Decl(conditionalTypes1.ts, 92, 35))
>T : Symbol(T, Decl(conditionalTypes1.ts, 92, 27))

type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;
>FunctionProperties : Symbol(FunctionProperties, Decl(conditionalTypes1.ts, 92, 95))
>T : Symbol(T, Decl(conditionalTypes1.ts, 93, 24))
>Pick : Symbol(Pick, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 93, 24))
>FunctionPropertyNames : Symbol(FunctionPropertyNames, Decl(conditionalTypes1.ts, 90, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 93, 24))

type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 93, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 95, 30))
>K : Symbol(K, Decl(conditionalTypes1.ts, 95, 38))
>T : Symbol(T, Decl(conditionalTypes1.ts, 95, 30))
>T : Symbol(T, Decl(conditionalTypes1.ts, 95, 30))
>K : Symbol(K, Decl(conditionalTypes1.ts, 95, 38))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))
>K : Symbol(K, Decl(conditionalTypes1.ts, 95, 38))
>T : Symbol(T, Decl(conditionalTypes1.ts, 95, 30))

type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;
>NonFunctionProperties : Symbol(NonFunctionProperties, Decl(conditionalTypes1.ts, 95, 98))
>T : Symbol(T, Decl(conditionalTypes1.ts, 96, 27))
>Pick : Symbol(Pick, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 96, 27))
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 93, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 96, 27))

type T30 = FunctionProperties<Part>;
>T30 : Symbol(T30, Decl(conditionalTypes1.ts, 96, 69))
>FunctionProperties : Symbol(FunctionProperties, Decl(conditionalTypes1.ts, 92, 95))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 83, 34))

type T31 = NonFunctionProperties<Part>;
>T31 : Symbol(T31, Decl(conditionalTypes1.ts, 98, 36))
>NonFunctionProperties : Symbol(NonFunctionProperties, Decl(conditionalTypes1.ts, 95, 98))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 83, 34))

function f7<T>(x: T, y: FunctionProperties<T>, z: NonFunctionProperties<T>) {
>f7 : Symbol(f7, Decl(conditionalTypes1.ts, 99, 39))
>T : Symbol(T, Decl(conditionalTypes1.ts, 101, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 101, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 101, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 101, 20))
>FunctionProperties : Symbol(FunctionProperties, Decl(conditionalTypes1.ts, 92, 95))
>T : Symbol(T, Decl(conditionalTypes1.ts, 101, 12))
>z : Symbol(z, Decl(conditionalTypes1.ts, 101, 46))
>NonFunctionProperties : Symbol(NonFunctionProperties, Decl(conditionalTypes1.ts, 95, 98))
>T : Symbol(T, Decl(conditionalTypes1.ts, 101, 12))

    x = y;  // Error
>x : Symbol(x, Decl(conditionalTypes1.ts, 101, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 101, 20))

    x = z;  // Error
>x : Symbol(x, Decl(conditionalTypes1.ts, 101, 15))
>z : Symbol(z, Decl(conditionalTypes1.ts, 101, 46))

    y = x;
>y : Symbol(y, Decl(conditionalTypes1.ts, 101, 20))
>x : Symbol(x, Decl(conditionalTypes1.ts, 101, 15))

    y = z;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 101, 20))
>z : Symbol(z, Decl(conditionalTypes1.ts, 101, 46))

    z = x;
>z : Symbol(z, Decl(conditionalTypes1.ts, 101, 46))
>x : Symbol(x, Decl(conditionalTypes1.ts, 101, 15))

    z = y;  // Error
>z : Symbol(z, Decl(conditionalTypes1.ts, 101, 46))
>y : Symbol(y, Decl(conditionalTypes1.ts, 101, 20))
}

function f8<T>(x: keyof T, y: FunctionPropertyNames<T>, z: NonFunctionPropertyNames<T>) {
>f8 : Symbol(f8, Decl(conditionalTypes1.ts, 108, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 110, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 110, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 110, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 110, 26))
>FunctionPropertyNames : Symbol(FunctionPropertyNames, Decl(conditionalTypes1.ts, 90, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 110, 12))
>z : Symbol(z, Decl(conditionalTypes1.ts, 110, 55))
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 93, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 110, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 110, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 110, 26))

    x = z;
>x : Symbol(x, Decl(conditionalTypes1.ts, 110, 15))
>z : Symbol(z, Decl(conditionalTypes1.ts, 110, 55))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 110, 26))
>x : Symbol(x, Decl(conditionalTypes1.ts, 110, 15))

    y = z;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 110, 26))
>z : Symbol(z, Decl(conditionalTypes1.ts, 110, 55))

    z = x;  // Error
>z : Symbol(z, Decl(conditionalTypes1.ts, 110, 55))
>x : Symbol(x, Decl(conditionalTypes1.ts, 110, 15))

    z = y;  // Error
>z : Symbol(z, Decl(conditionalTypes1.ts, 110, 55))
>y : Symbol(y, Decl(conditionalTypes1.ts, 110, 26))
}

type DeepReadonly<T> =
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 117, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 119, 18))

    T extends any[] ? DeepReadonlyArray<T[number]> :
>T : Symbol(T, Decl(conditionalTypes1.ts, 119, 18))
>DeepReadonlyArray : Symbol(DeepReadonlyArray, Decl(conditionalTypes1.ts, 122, 6))
>T : Symbol(T, Decl(conditionalTypes1.ts, 119, 18))

    T extends object ? DeepReadonlyObject<T> :
>T : Symbol(T, Decl(conditionalTypes1.ts, 119, 18))
>DeepReadonlyObject : Symbol(DeepReadonlyObject, Decl(conditionalTypes1.ts, 124, 72))
>T : Symbol(T, Decl(conditionalTypes1.ts, 119, 18))

    T;
>T : Symbol(T, Decl(conditionalTypes1.ts, 119, 18))

interface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {}
>DeepReadonlyArray : Symbol(DeepReadonlyArray, Decl(conditionalTypes1.ts, 122, 6))
>T : Symbol(T, Decl(conditionalTypes1.ts, 124, 28))
>ReadonlyArray : Symbol(ReadonlyArray, Decl(lib.d.ts, --, --))
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 117, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 124, 28))

type DeepReadonlyObject<T> = {
>DeepReadonlyObject : Symbol(DeepReadonlyObject, Decl(conditionalTypes1.ts, 124, 72))
>T : Symbol(T, Decl(conditionalTypes1.ts, 126, 24))

    readonly [P in NonFunctionPropertyNames<T>]: DeepReadonly<T[P]>;
>P : Symbol(P, Decl(conditionalTypes1.ts, 127, 14))
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 93, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 126, 24))
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 117, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 126, 24))
>P : Symbol(P, Decl(conditionalTypes1.ts, 127, 14))

};

function f10(part: DeepReadonly<Part>) {
>f10 : Symbol(f10, Decl(conditionalTypes1.ts, 128, 2))
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 117, 1))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 83, 34))

    let name: string = part.name;
>name : Symbol(name, Decl(conditionalTypes1.ts, 131, 7))
>part.name : Symbol(name)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>name : Symbol(name)

    let id: number = part.subparts[0].id;
>id : Symbol(id, Decl(conditionalTypes1.ts, 132, 7))
>part.subparts[0].id : Symbol(id)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>subparts : Symbol(subparts)
>id : Symbol(id)

    part.id = part.id;  // Error
>part.id : Symbol(id)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>id : Symbol(id)
>part.id : Symbol(id)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>id : Symbol(id)

    part.subparts[0] = part.subparts[0];  // Error
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>subparts : Symbol(subparts)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>subparts : Symbol(subparts)

    part.subparts[0].id = part.subparts[0].id;  // Error
>part.subparts[0].id : Symbol(id)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>subparts : Symbol(subparts)
>id : Symbol(id)
>part.subparts[0].id : Symbol(id)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
>subparts : Symbol(subparts)
>id : Symbol(id)

    part.updatePart("hello");  // Error
>part : Symbol(part, Decl(conditionalTypes1.ts, 130, 13))
}

type ZeroOf<T extends number | string | boolean> = T extends number ? 0 : T extends string ? "" : false;
>ZeroOf : Symbol(ZeroOf, Decl(conditionalTypes1.ts, 137, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 139, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 139, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 139, 12))

function zeroOf<T extends number | string | boolean>(value: T) {
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))
>T : Symbol(T, Decl(conditionalTypes1.ts, 141, 16))
>value : Symbol(value, Decl(conditionalTypes1.ts, 141, 53))
>T : Symbol(T, Decl(conditionalTypes1.ts, 141, 16))

    return <ZeroOf<T>>(typeof value === "number" ? 0 : typeof value === "string" ? "" : false);
>ZeroOf : Symbol(ZeroOf, Decl(conditionalTypes1.ts, 137, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 141, 16))
>value : Symbol(value, Decl(conditionalTypes1.ts, 141, 53))
>value : Symbol(value, Decl(conditionalTypes1.ts, 141, 53))
}

function f20<T extends string>(n: number, b: boolean, x: number | boolean, y: T) {
>f20 : Symbol(f20, Decl(conditionalTypes1.ts, 143, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 145, 13))
>n : Symbol(n, Decl(conditionalTypes1.ts, 145, 31))
>b : Symbol(b, Decl(conditionalTypes1.ts, 145, 41))
>x : Symbol(x, Decl(conditionalTypes1.ts, 145, 53))
>y : Symbol(y, Decl(conditionalTypes1.ts, 145, 74))
>T : Symbol(T, Decl(conditionalTypes1.ts, 145, 13))

    zeroOf(5);  // 0
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))

    zeroOf("hello");  // ""
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))

    zeroOf(true);  // false
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))

    zeroOf(n);  // 0
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))
>n : Symbol(n, Decl(conditionalTypes1.ts, 145, 31))

    zeroOf(b);  // False
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))
>b : Symbol(b, Decl(conditionalTypes1.ts, 145, 41))

    zeroOf(x);  // 0 | false
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))
>x : Symbol(x, Decl(conditionalTypes1.ts, 145, 53))

    zeroOf(y);  // ZeroOf<T>
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 139, 104))
>y : Symbol(y, Decl(conditionalTypes1.ts, 145, 74))
}

function f21<T extends number | string>(x: T, y: ZeroOf<T>) {
>f21 : Symbol(f21, Decl(conditionalTypes1.ts, 153, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 155, 13))
>x : Symbol(x, Decl(conditionalTypes1.ts, 155, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 155, 13))
>y : Symbol(y, Decl(conditionalTypes1.ts, 155, 45))
>ZeroOf : Symbol(ZeroOf, Decl(conditionalTypes1.ts, 137, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 155, 13))

    let z1: number | string = y;
>z1 : Symbol(z1, Decl(conditionalTypes1.ts, 156, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 155, 45))

    let z2: 0 | "" = y;
>z2 : Symbol(z2, Decl(conditionalTypes1.ts, 157, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 155, 45))

    x = y;  // Error
>x : Symbol(x, Decl(conditionalTypes1.ts, 155, 40))
>y : Symbol(y, Decl(conditionalTypes1.ts, 155, 45))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 155, 45))
>x : Symbol(x, Decl(conditionalTypes1.ts, 155, 40))
}

type Extends<T, U> = T extends U ? true : false;
>Extends : Symbol(Extends, Decl(conditionalTypes1.ts, 160, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 162, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 162, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 162, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 162, 15))

type If<C extends boolean, T, F> = C extends true ? T : F;
>If : Symbol(If, Decl(conditionalTypes1.ts, 162, 48))
>C : Symbol(C, Decl(conditionalTypes1.ts, 163, 8))
>T : Symbol(T, Decl(conditionalTypes1.ts, 163, 26))
>F : Symbol(F, Decl(conditionalTypes1.ts, 163, 29))
>C : Symbol(C, Decl(conditionalTypes1.ts, 163, 8))
>T : Symbol(T, Decl(conditionalTypes1.ts, 163, 26))
>F : Symbol(F, Decl(conditionalTypes1.ts, 163, 29))

type Not<C extends boolean> = If<C, false, true>;
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 163, 58))
>C : Symbol(C, Decl(conditionalTypes1.ts, 164, 9))
>If : Symbol(If, Decl(conditionalTypes1.ts, 162, 48))
>C : Symbol(C, Decl(conditionalTypes1.ts, 164, 9))

type And<A extends boolean, B extends boolean> = If<A, B, false>;
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))
>A : Symbol(A, Decl(conditionalTypes1.ts, 165, 9))
>B : Symbol(B, Decl(conditionalTypes1.ts, 165, 27))
>If : Symbol(If, Decl(conditionalTypes1.ts, 162, 48))
>A : Symbol(A, Decl(conditionalTypes1.ts, 165, 9))
>B : Symbol(B, Decl(conditionalTypes1.ts, 165, 27))

type Or<A extends boolean, B extends boolean> = If<A, true, B>;
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))
>A : Symbol(A, Decl(conditionalTypes1.ts, 166, 8))
>B : Symbol(B, Decl(conditionalTypes1.ts, 166, 26))
>If : Symbol(If, Decl(conditionalTypes1.ts, 162, 48))
>A : Symbol(A, Decl(conditionalTypes1.ts, 166, 8))
>B : Symbol(B, Decl(conditionalTypes1.ts, 166, 26))

type IsString<T> = Extends<T, string>;
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 166, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 168, 14))
>Extends : Symbol(Extends, Decl(conditionalTypes1.ts, 160, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 168, 14))

type Q1 = IsString<number>;  // false
>Q1 : Symbol(Q1, Decl(conditionalTypes1.ts, 168, 38))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 166, 63))

type Q2 = IsString<"abc">;  // true
>Q2 : Symbol(Q2, Decl(conditionalTypes1.ts, 170, 27))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 166, 63))

type Q3 = IsString<any>;  // boolean
>Q3 : Symbol(Q3, Decl(conditionalTypes1.ts, 171, 26))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 166, 63))

type Q4 = IsString<never>;  // never
>Q4 : Symbol(Q4, Decl(conditionalTypes1.ts, 172, 24))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 166, 63))

type N1 = Not<false>;  // true
>N1 : Symbol(N1, Decl(conditionalTypes1.ts, 173, 26))
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 163, 58))

type N2 = Not<true>;  // false
>N2 : Symbol(N2, Decl(conditionalTypes1.ts, 175, 21))
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 163, 58))

type N3 = Not<boolean>;  // boolean
>N3 : Symbol(N3, Decl(conditionalTypes1.ts, 176, 20))
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 163, 58))

type A1 = And<false, false>;  // false
>A1 : Symbol(A1, Decl(conditionalTypes1.ts, 177, 23))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A2 = And<false, true>;  // false
>A2 : Symbol(A2, Decl(conditionalTypes1.ts, 179, 28))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A3 = And<true, false>;  // false
>A3 : Symbol(A3, Decl(conditionalTypes1.ts, 180, 27))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A4 = And<true, true>;  // true
>A4 : Symbol(A4, Decl(conditionalTypes1.ts, 181, 27))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A5 = And<boolean, false>;  // false
>A5 : Symbol(A5, Decl(conditionalTypes1.ts, 182, 26))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A6 = And<false, boolean>;  // false
>A6 : Symbol(A6, Decl(conditionalTypes1.ts, 183, 30))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A7 = And<boolean, true>;  // boolean
>A7 : Symbol(A7, Decl(conditionalTypes1.ts, 184, 30))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A8 = And<true, boolean>;  // boolean
>A8 : Symbol(A8, Decl(conditionalTypes1.ts, 185, 29))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type A9 = And<boolean, boolean>;  // boolean
>A9 : Symbol(A9, Decl(conditionalTypes1.ts, 186, 29))
>And : Symbol(And, Decl(conditionalTypes1.ts, 164, 49))

type O1 = Or<false, false>;  // false
>O1 : Symbol(O1, Decl(conditionalTypes1.ts, 187, 32))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O2 = Or<false, true>;  // true
>O2 : Symbol(O2, Decl(conditionalTypes1.ts, 189, 27))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O3 = Or<true, false>;  // true
>O3 : Symbol(O3, Decl(conditionalTypes1.ts, 190, 26))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O4 = Or<true, true>;  // true
>O4 : Symbol(O4, Decl(conditionalTypes1.ts, 191, 26))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O5 = Or<boolean, false>;  // boolean
>O5 : Symbol(O5, Decl(conditionalTypes1.ts, 192, 25))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O6 = Or<false, boolean>;  // boolean
>O6 : Symbol(O6, Decl(conditionalTypes1.ts, 193, 29))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O7 = Or<boolean, true>;  // true
>O7 : Symbol(O7, Decl(conditionalTypes1.ts, 194, 29))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O8 = Or<true, boolean>;  // true
>O8 : Symbol(O8, Decl(conditionalTypes1.ts, 195, 28))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type O9 = Or<boolean, boolean>;  // boolean
>O9 : Symbol(O9, Decl(conditionalTypes1.ts, 196, 28))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 165, 65))

type T40 = never extends never ? true : false;  // true
>T40 : Symbol(T40, Decl(conditionalTypes1.ts, 197, 31))

type T41 = number extends never ? true : false;  // false
>T41 : Symbol(T41, Decl(conditionalTypes1.ts, 199, 46))

type T42 = never extends number ? true : false;  // true
>T42 : Symbol(T42, Decl(conditionalTypes1.ts, 200, 47))

type IsNever<T> = [T] extends [never] ? true : false;
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 201, 47))
>T : Symbol(T, Decl(conditionalTypes1.ts, 203, 13))
>T : Symbol(T, Decl(conditionalTypes1.ts, 203, 13))

type T50 = IsNever<never>;  // true
>T50 : Symbol(T50, Decl(conditionalTypes1.ts, 203, 53))
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 201, 47))

type T51 = IsNever<number>;  // false
>T51 : Symbol(T51, Decl(conditionalTypes1.ts, 205, 26))
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 201, 47))

type T52 = IsNever<any>;  // false
>T52 : Symbol(T52, Decl(conditionalTypes1.ts, 206, 27))
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 201, 47))

// Repros from #21664

type Eq<T, U> = T extends U ? U extends T ? true : false : false;
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 207, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 211, 8))
>U : Symbol(U, Decl(conditionalTypes1.ts, 211, 10))
>T : Symbol(T, Decl(conditionalTypes1.ts, 211, 8))
>U : Symbol(U, Decl(conditionalTypes1.ts, 211, 10))
>U : Symbol(U, Decl(conditionalTypes1.ts, 211, 10))
>T : Symbol(T, Decl(conditionalTypes1.ts, 211, 8))

type T60 = Eq<true, true>;  // true
>T60 : Symbol(T60, Decl(conditionalTypes1.ts, 211, 65))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 207, 24))

type T61 = Eq<true, false>;  // false
>T61 : Symbol(T61, Decl(conditionalTypes1.ts, 212, 26))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 207, 24))

type T62 = Eq<false, true>;  // false
>T62 : Symbol(T62, Decl(conditionalTypes1.ts, 213, 27))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 207, 24))

type T63 = Eq<false, false>;  // true
>T63 : Symbol(T63, Decl(conditionalTypes1.ts, 214, 27))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 207, 24))

type Eq1<T, U> = Eq<T, U> extends false ? false : true;
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 215, 28))
>T : Symbol(T, Decl(conditionalTypes1.ts, 217, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 217, 11))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 207, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 217, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 217, 11))

type T70 = Eq1<true, true>;  // true
>T70 : Symbol(T70, Decl(conditionalTypes1.ts, 217, 55))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 215, 28))

type T71 = Eq1<true, false>;  // false
>T71 : Symbol(T71, Decl(conditionalTypes1.ts, 218, 27))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 215, 28))

type T72 = Eq1<false, true>;  // false
>T72 : Symbol(T72, Decl(conditionalTypes1.ts, 219, 28))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 215, 28))

type T73 = Eq1<false, false>;  // true
>T73 : Symbol(T73, Decl(conditionalTypes1.ts, 220, 28))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 215, 28))

type Eq2<T, U> = Eq<T, U> extends true ? true : false;
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 221, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 223, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 223, 11))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 207, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 223, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 223, 11))

type T80 = Eq2<true, true>;  // true
>T80 : Symbol(T80, Decl(conditionalTypes1.ts, 223, 54))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 221, 29))

type T81 = Eq2<true, false>;  // false
>T81 : Symbol(T81, Decl(conditionalTypes1.ts, 224, 27))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 221, 29))

type T82 = Eq2<false, true>;  // false
>T82 : Symbol(T82, Decl(conditionalTypes1.ts, 225, 28))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 221, 29))

type T83 = Eq2<false, false>;  // true
>T83 : Symbol(T83, Decl(conditionalTypes1.ts, 226, 28))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 221, 29))

// Repro from #21756

type Foo<T> = T extends string ? boolean : number;
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 227, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 231, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 231, 9))

type Bar<T> = T extends string ? boolean : number;
>Bar : Symbol(Bar, Decl(conditionalTypes1.ts, 231, 50))
>T : Symbol(T, Decl(conditionalTypes1.ts, 232, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 232, 9))

const convert = <U>(value: Foo<U>): Bar<U> => value;
>convert : Symbol(convert, Decl(conditionalTypes1.ts, 233, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 233, 17))
>value : Symbol(value, Decl(conditionalTypes1.ts, 233, 20))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 227, 29))
>U : Symbol(U, Decl(conditionalTypes1.ts, 233, 17))
>Bar : Symbol(Bar, Decl(conditionalTypes1.ts, 231, 50))
>U : Symbol(U, Decl(conditionalTypes1.ts, 233, 17))
>value : Symbol(value, Decl(conditionalTypes1.ts, 233, 20))

type Baz<T> = Foo<T>;
>Baz : Symbol(Baz, Decl(conditionalTypes1.ts, 233, 52))
>T : Symbol(T, Decl(conditionalTypes1.ts, 235, 9))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 227, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 235, 9))

const convert2 = <T>(value: Foo<T>): Baz<T> => value;
>convert2 : Symbol(convert2, Decl(conditionalTypes1.ts, 236, 5))
>T : Symbol(T, Decl(conditionalTypes1.ts, 236, 18))
>value : Symbol(value, Decl(conditionalTypes1.ts, 236, 21))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 227, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 236, 18))
>Baz : Symbol(Baz, Decl(conditionalTypes1.ts, 233, 52))
>T : Symbol(T, Decl(conditionalTypes1.ts, 236, 18))
>value : Symbol(value, Decl(conditionalTypes1.ts, 236, 21))

function f31<T>() {
>f31 : Symbol(f31, Decl(conditionalTypes1.ts, 236, 53))
>T : Symbol(T, Decl(conditionalTypes1.ts, 238, 13))

    type T1 = T extends string ? boolean : number;
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 238, 19))
>T : Symbol(T, Decl(conditionalTypes1.ts, 238, 13))

    type T2 = T extends string ? boolean : number;
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 239, 50))
>T : Symbol(T, Decl(conditionalTypes1.ts, 238, 13))

    var x: T1;
>x : Symbol(x, Decl(conditionalTypes1.ts, 241, 7), Decl(conditionalTypes1.ts, 242, 7))
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 238, 19))

    var x: T2;
>x : Symbol(x, Decl(conditionalTypes1.ts, 241, 7), Decl(conditionalTypes1.ts, 242, 7))
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 239, 50))
}

function f32<T, U>() {
>f32 : Symbol(f32, Decl(conditionalTypes1.ts, 243, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 245, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 245, 15))

    type T1 = T & U extends string ? boolean : number;
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 245, 22))
>T : Symbol(T, Decl(conditionalTypes1.ts, 245, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 245, 15))

    type T2 = Foo<T & U>;
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 246, 54))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 227, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 245, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 245, 15))

    var z: T1;
>z : Symbol(z, Decl(conditionalTypes1.ts, 248, 7), Decl(conditionalTypes1.ts, 249, 7))
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 245, 22))

    var z: T2;  // Error, T2 is distributive, T1 isn't
>z : Symbol(z, Decl(conditionalTypes1.ts, 248, 7), Decl(conditionalTypes1.ts, 249, 7))
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 246, 54))
}

function f33<T, U>() {
>f33 : Symbol(f33, Decl(conditionalTypes1.ts, 250, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 252, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 252, 15))

    type T1 = Foo<T & U>;
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 252, 22))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 227, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 252, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 252, 15))

    type T2 = Bar<T & U>;
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 253, 25))
>Bar : Symbol(Bar, Decl(conditionalTypes1.ts, 231, 50))
>T : Symbol(T, Decl(conditionalTypes1.ts, 252, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 252, 15))

    var z: T1;
>z : Symbol(z, Decl(conditionalTypes1.ts, 255, 7), Decl(conditionalTypes1.ts, 256, 7))
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 252, 22))

    var z: T2;
>z : Symbol(z, Decl(conditionalTypes1.ts, 255, 7), Decl(conditionalTypes1.ts, 256, 7))
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 253, 25))
}

// Repro from #21823

type T90<T> = T extends 0 ? 0 : () => 0;
>T90 : Symbol(T90, Decl(conditionalTypes1.ts, 257, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 261, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 261, 9))

type T91<T> = T extends 0 ? 0 : () => 0;
>T91 : Symbol(T91, Decl(conditionalTypes1.ts, 261, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 262, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 262, 9))

const f40 = <U>(a: T90<U>): T91<U> => a;
>f40 : Symbol(f40, Decl(conditionalTypes1.ts, 263, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 263, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 263, 16))
>T90 : Symbol(T90, Decl(conditionalTypes1.ts, 257, 1))
>U : Symbol(U, Decl(conditionalTypes1.ts, 263, 13))
>T91 : Symbol(T91, Decl(conditionalTypes1.ts, 261, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 263, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 263, 16))

const f41 = <U>(a: T91<U>): T90<U> => a;
>f41 : Symbol(f41, Decl(conditionalTypes1.ts, 264, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 264, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 264, 16))
>T91 : Symbol(T91, Decl(conditionalTypes1.ts, 261, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 264, 13))
>T90 : Symbol(T90, Decl(conditionalTypes1.ts, 257, 1))
>U : Symbol(U, Decl(conditionalTypes1.ts, 264, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 264, 16))

type T92<T> = T extends () => 0 ? () => 1 : () => 2;
>T92 : Symbol(T92, Decl(conditionalTypes1.ts, 264, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 266, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 266, 9))

type T93<T> = T extends () => 0 ? () => 1 : () => 2;
>T93 : Symbol(T93, Decl(conditionalTypes1.ts, 266, 52))
>T : Symbol(T, Decl(conditionalTypes1.ts, 267, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 267, 9))

const f42 = <U>(a: T92<U>): T93<U> => a;
>f42 : Symbol(f42, Decl(conditionalTypes1.ts, 268, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 268, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 268, 16))
>T92 : Symbol(T92, Decl(conditionalTypes1.ts, 264, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 268, 13))
>T93 : Symbol(T93, Decl(conditionalTypes1.ts, 266, 52))
>U : Symbol(U, Decl(conditionalTypes1.ts, 268, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 268, 16))

const f43 = <U>(a: T93<U>): T92<U> => a;
>f43 : Symbol(f43, Decl(conditionalTypes1.ts, 269, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 269, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 269, 16))
>T93 : Symbol(T93, Decl(conditionalTypes1.ts, 266, 52))
>U : Symbol(U, Decl(conditionalTypes1.ts, 269, 13))
>T92 : Symbol(T92, Decl(conditionalTypes1.ts, 264, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 269, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 269, 16))

type T94<T> = T extends string ? true : 42;
>T94 : Symbol(T94, Decl(conditionalTypes1.ts, 269, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 271, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 271, 9))

type T95<T> = T extends string ? boolean : number;
>T95 : Symbol(T95, Decl(conditionalTypes1.ts, 271, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 272, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 272, 9))

const f44 = <U>(value: T94<U>): T95<U> => value;
>f44 : Symbol(f44, Decl(conditionalTypes1.ts, 273, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 273, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 273, 16))
>T94 : Symbol(T94, Decl(conditionalTypes1.ts, 269, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 273, 13))
>T95 : Symbol(T95, Decl(conditionalTypes1.ts, 271, 43))
>U : Symbol(U, Decl(conditionalTypes1.ts, 273, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 273, 16))

const f45 = <U>(value: T95<U>): T94<U> => value;  // Error
>f45 : Symbol(f45, Decl(conditionalTypes1.ts, 274, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 274, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 274, 16))
>T95 : Symbol(T95, Decl(conditionalTypes1.ts, 271, 43))
>U : Symbol(U, Decl(conditionalTypes1.ts, 274, 13))
>T94 : Symbol(T94, Decl(conditionalTypes1.ts, 269, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 274, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 274, 16))

// Repro from #21863

function f50() {
>f50 : Symbol(f50, Decl(conditionalTypes1.ts, 274, 48))

    type Eq<T, U> = T extends U ? U extends T ? true : false : false;
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 278, 16))
>T : Symbol(T, Decl(conditionalTypes1.ts, 279, 12))
>U : Symbol(U, Decl(conditionalTypes1.ts, 279, 14))
>T : Symbol(T, Decl(conditionalTypes1.ts, 279, 12))
>U : Symbol(U, Decl(conditionalTypes1.ts, 279, 14))
>U : Symbol(U, Decl(conditionalTypes1.ts, 279, 14))
>T : Symbol(T, Decl(conditionalTypes1.ts, 279, 12))

    type If<S, T, U> = S extends false ? U : T;
>If : Symbol(If, Decl(conditionalTypes1.ts, 279, 69))
>S : Symbol(S, Decl(conditionalTypes1.ts, 280, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 280, 14))
>U : Symbol(U, Decl(conditionalTypes1.ts, 280, 17))
>S : Symbol(S, Decl(conditionalTypes1.ts, 280, 12))
>U : Symbol(U, Decl(conditionalTypes1.ts, 280, 17))
>T : Symbol(T, Decl(conditionalTypes1.ts, 280, 14))

    type Omit<T extends object> = { [P in keyof T]: If<Eq<T[P], never>, never, P>; }[keyof T];
>Omit : Symbol(Omit, Decl(conditionalTypes1.ts, 280, 47))
>T : Symbol(T, Decl(conditionalTypes1.ts, 281, 14))
>P : Symbol(P, Decl(conditionalTypes1.ts, 281, 37))
>T : Symbol(T, Decl(conditionalTypes1.ts, 281, 14))
>If : Symbol(If, Decl(conditionalTypes1.ts, 279, 69))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 278, 16))
>T : Symbol(T, Decl(conditionalTypes1.ts, 281, 14))
>P : Symbol(P, Decl(conditionalTypes1.ts, 281, 37))
>P : Symbol(P, Decl(conditionalTypes1.ts, 281, 37))
>T : Symbol(T, Decl(conditionalTypes1.ts, 281, 14))

    type Omit2<T extends object, U = never> = { [P in keyof T]: If<Eq<T[P], U>, never, P>; }[keyof T];
>Omit2 : Symbol(Omit2, Decl(conditionalTypes1.ts, 281, 94))
>T : Symbol(T, Decl(conditionalTypes1.ts, 282, 15))
>U : Symbol(U, Decl(conditionalTypes1.ts, 282, 32))
>P : Symbol(P, Decl(conditionalTypes1.ts, 282, 49))
>T : Symbol(T, Decl(conditionalTypes1.ts, 282, 15))
>If : Symbol(If, Decl(conditionalTypes1.ts, 279, 69))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 278, 16))
>T : Symbol(T, Decl(conditionalTypes1.ts, 282, 15))
>P : Symbol(P, Decl(conditionalTypes1.ts, 282, 49))
>U : Symbol(U, Decl(conditionalTypes1.ts, 282, 32))
>P : Symbol(P, Decl(conditionalTypes1.ts, 282, 49))
>T : Symbol(T, Decl(conditionalTypes1.ts, 282, 15))

    type A = Omit<{ a: void; b: never; }>;  // 'a'
>A : Symbol(A, Decl(conditionalTypes1.ts, 282, 102))
>Omit : Symbol(Omit, Decl(conditionalTypes1.ts, 280, 47))
>a : Symbol(a, Decl(conditionalTypes1.ts, 283, 19))
>b : Symbol(b, Decl(conditionalTypes1.ts, 283, 28))

    type B = Omit2<{ a: void; b: never; }>;  // 'a'
>B : Symbol(B, Decl(conditionalTypes1.ts, 283, 42))
>Omit2 : Symbol(Omit2, Decl(conditionalTypes1.ts, 281, 94))
>a : Symbol(a, Decl(conditionalTypes1.ts, 284, 20))
>b : Symbol(b, Decl(conditionalTypes1.ts, 284, 29))
}

// Repro from #21862

type OldDiff<T extends string, U extends string> = (
>OldDiff : Symbol(OldDiff, Decl(conditionalTypes1.ts, 285, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 289, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 289, 30))

    & { [P in T]: P; }
>P : Symbol(P, Decl(conditionalTypes1.ts, 290, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 289, 13))
>P : Symbol(P, Decl(conditionalTypes1.ts, 290, 9))

    & { [P in U]: never; }
>P : Symbol(P, Decl(conditionalTypes1.ts, 291, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 289, 30))

    & { [x: string]: never; }
>x : Symbol(x, Decl(conditionalTypes1.ts, 292, 9))

)[T];
>T : Symbol(T, Decl(conditionalTypes1.ts, 289, 13))

type NewDiff<T, U> = T extends U ? never : T;
>NewDiff : Symbol(NewDiff, Decl(conditionalTypes1.ts, 293, 5))
>T : Symbol(T, Decl(conditionalTypes1.ts, 294, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 294, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 294, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 294, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 294, 13))

interface A {
>A : Symbol(A, Decl(conditionalTypes1.ts, 294, 45))

    a: 'a';
>a : Symbol(A.a, Decl(conditionalTypes1.ts, 295, 13))
}
interface B1 extends A {
>B1 : Symbol(B1, Decl(conditionalTypes1.ts, 297, 1))
>A : Symbol(A, Decl(conditionalTypes1.ts, 294, 45))

    b: 'b';
>b : Symbol(B1.b, Decl(conditionalTypes1.ts, 298, 24))

    c: OldDiff<keyof this, keyof A>;
>c : Symbol(B1.c, Decl(conditionalTypes1.ts, 299, 11))
>OldDiff : Symbol(OldDiff, Decl(conditionalTypes1.ts, 285, 1))
>A : Symbol(A, Decl(conditionalTypes1.ts, 294, 45))
}
interface B2 extends A {
>B2 : Symbol(B2, Decl(conditionalTypes1.ts, 301, 1))
>A : Symbol(A, Decl(conditionalTypes1.ts, 294, 45))

    b: 'b';
>b : Symbol(B2.b, Decl(conditionalTypes1.ts, 302, 24))

    c: NewDiff<keyof this, keyof A>;
>c : Symbol(B2.c, Decl(conditionalTypes1.ts, 303, 11))
>NewDiff : Symbol(NewDiff, Decl(conditionalTypes1.ts, 293, 5))
>A : Symbol(A, Decl(conditionalTypes1.ts, 294, 45))
}
type c1 = B1['c']; // 'c' | 'b'
>c1 : Symbol(c1, Decl(conditionalTypes1.ts, 305, 1))
>B1 : Symbol(B1, Decl(conditionalTypes1.ts, 297, 1))

type c2 = B2['c']; // 'c' | 'b'
>c2 : Symbol(c2, Decl(conditionalTypes1.ts, 306, 18))
>B2 : Symbol(B2, Decl(conditionalTypes1.ts, 301, 1))

// Repro from #21929

type NonFooKeys1<T extends object> = OldDiff<keyof T, 'foo'>;
>NonFooKeys1 : Symbol(NonFooKeys1, Decl(conditionalTypes1.ts, 307, 18))
>T : Symbol(T, Decl(conditionalTypes1.ts, 311, 17))
>OldDiff : Symbol(OldDiff, Decl(conditionalTypes1.ts, 285, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 311, 17))

type NonFooKeys2<T extends object> = Exclude<keyof T, 'foo'>;
>NonFooKeys2 : Symbol(NonFooKeys2, Decl(conditionalTypes1.ts, 311, 61))
>T : Symbol(T, Decl(conditionalTypes1.ts, 312, 17))
>Exclude : Symbol(Exclude, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 312, 17))

type Test1 = NonFooKeys1<{foo: 1, bar: 2, baz: 3}>;  // "bar" | "baz"
>Test1 : Symbol(Test1, Decl(conditionalTypes1.ts, 312, 61))
>NonFooKeys1 : Symbol(NonFooKeys1, Decl(conditionalTypes1.ts, 307, 18))
>foo : Symbol(foo, Decl(conditionalTypes1.ts, 314, 26))
>bar : Symbol(bar, Decl(conditionalTypes1.ts, 314, 33))
>baz : Symbol(baz, Decl(conditionalTypes1.ts, 314, 41))

type Test2 = NonFooKeys2<{foo: 1, bar: 2, baz: 3}>;  // "bar" | "baz"
>Test2 : Symbol(Test2, Decl(conditionalTypes1.ts, 314, 51))
>NonFooKeys2 : Symbol(NonFooKeys2, Decl(conditionalTypes1.ts, 311, 61))
>foo : Symbol(foo, Decl(conditionalTypes1.ts, 315, 26))
>bar : Symbol(bar, Decl(conditionalTypes1.ts, 315, 33))
>baz : Symbol(baz, Decl(conditionalTypes1.ts, 315, 41))

