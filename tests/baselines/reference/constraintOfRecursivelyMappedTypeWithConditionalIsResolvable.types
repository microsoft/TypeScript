=== tests/cases/compiler/constraintOfRecursivelyMappedTypeWithConditionalIsResolvable.ts ===
// https://github.com/Microsoft/TypeScript/issues/25379

interface Map<K, V> {
    // ...
}

export type ImmutableTypes = IImmutableMap<any>;
>ImmutableTypes : ImmutableTypes

export type ImmutableModel<T> = { [K in keyof T]: T[K] extends ImmutableTypes ? T[K] : never };
>ImmutableModel : ImmutableModel<T>

export interface IImmutableMap<T extends ImmutableModel<T>> extends Map<string, any> {
    set<K extends keyof T>(key: K, value: T[K]): IImmutableMap<T>;
>set : <K extends keyof T>(key: K, value: T[K]) => IImmutableMap<T>
>key : K
>value : T[K]
}

export type ImmutableTypes2 = IImmutableMap2<any>;
>ImmutableTypes2 : ImmutableTypes2

type isImmutableType<T> = [T] extends [ImmutableTypes2] ? T : never;
>isImmutableType : isImmutableType<T>

export type ImmutableModel2<T> = { [K in keyof T]: isImmutableType<T[K]> };
>ImmutableModel2 : ImmutableModel2<T>

export interface IImmutableMap2<T extends ImmutableModel2<T>> extends Map<string, any> {
    set<K extends keyof T>(key: K, value: T[K]): IImmutableMap2<T>;
>set : <K extends keyof T>(key: K, value: T[K]) => IImmutableMap2<T>
>key : K
>value : T[K]
}

