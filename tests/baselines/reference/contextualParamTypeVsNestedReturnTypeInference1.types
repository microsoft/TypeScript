//// [tests/cases/compiler/contextualParamTypeVsNestedReturnTypeInference1.ts] ////

=== contextualParamTypeVsNestedReturnTypeInference1.ts ===
interface Effect<A> {
  _A: A;
>_A : A
>   : ^
}
  
declare function effectGen<AEff>(f: () => AEff): Effect<AEff>;
>effectGen : <AEff>(f: () => AEff) => Effect<AEff>
>          : ^    ^^ ^^          ^^^^^            
>f : () => AEff
>  : ^^^^^^    

declare function effectFn<AEff, Args extends Array<any>>(
>effectFn : <AEff, Args extends Array<any>>(body: (...args: Args) => unknown) => (...args: Args) => Effect<AEff>
>         : ^    ^^    ^^^^^^^^^          ^^    ^^                          ^^^^^                               

  body: (...args: Args) => unknown,
>body : (...args: Args) => unknown
>     : ^^^^    ^^    ^^^^^       
>args : Args
>     : ^^^^

): (...args: Args) => Effect<AEff>;
>args : Args
>     : ^^^^
  
declare function layerEffect<S>(tag: Tag<S>, effect: Effect<S>): unknown;
>layerEffect : <S>(tag: Tag<S>, effect: Effect<S>) => unknown
>            : ^ ^^   ^^      ^^      ^^         ^^^^^       
>tag : Tag<S>
>    : ^^^^^^
>effect : Effect<S>
>       : ^^^^^^^^^
  
interface Tag<Type> {
  _Type: Type;
>_Type : Type
>      : ^^^^
}
  
declare const Foo: Tag<{
>Foo : Tag<{ fn: (a: string) => unknown; }>
>    : ^^^^^^^^^^                      ^^^^

  fn: (a: string) => unknown;
>fn : (a: string) => unknown
>   : ^ ^^      ^^^^^       
>a : string
>  : ^^^^^^

}>;
  
layerEffect(
>layerEffect(  Foo,  effectGen(function () {    return {      fn: effectFn(function (a) {        a; // string      }),    };  }),) : unknown
>                                                                                                                                  : ^^^^^^^
>layerEffect : <S>(tag: Tag<S>, effect: Effect<S>) => unknown
>            : ^ ^^   ^^      ^^      ^^         ^^^^^       

  Foo,
>Foo : Tag<{ fn: (a: string) => unknown; }>
>    : ^^^^^^^^^^                      ^^^^

  effectGen(function () {
>effectGen(function () {    return {      fn: effectFn(function (a) {        a; // string      }),    };  }) : Effect<{ fn: (a: string) => Effect<unknown>; }>
>                                                                                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>effectGen : <AEff>(f: () => AEff) => Effect<AEff>
>          : ^    ^^ ^^          ^^^^^            
>function () {    return {      fn: effectFn(function (a) {        a; // string      }),    };  } : () => { fn: (a: string) => Effect<unknown>; }
>                                                                                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    return {
>{      fn: effectFn(function (a) {        a; // string      }),    } : { fn: (a: string) => Effect<unknown>; }
>                                                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

      fn: effectFn(function (a) {
>fn : (a: string) => Effect<unknown>
>   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>effectFn(function (a) {        a; // string      }) : (a: string) => Effect<unknown>
>                                                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>effectFn : <AEff, Args extends Array<any>>(body: (...args: Args) => unknown) => (...args: Args) => Effect<AEff>
>         : ^    ^^    ^^^^^^^^^          ^^    ^^                          ^^^^^                               
>function (a) {        a; // string      } : (a: string) => void
>                                          : ^ ^^^^^^^^^^^^^^^^^
>a : string
>  : ^^^^^^

        a; // string
>a : string
>  : ^^^^^^

      }),
    };
  }),
);

