//// [tests/cases/compiler/contextualParamTypeVsNestedReturnTypeInference2.ts] ////

=== Performance Stats ===
Type Count: 1,000
Instantiation count: 2,500

=== contextualParamTypeVsNestedReturnTypeInference2.ts ===
type Covariant<A> = (_: never) => A;
>Covariant : Covariant<A>
>          : ^^^^^^^^^^^^
>_ : never
>  : ^^^^^

interface Effect<out A, out E = never, out R = never> {
  readonly _A: Covariant<A>;
>_A : Covariant<A>
>   : ^^^^^^^^^^^^

  readonly _E: Covariant<E>;
>_E : Covariant<E>
>   : ^^^^^^^^^^^^

  readonly _R: Covariant<R>;
>_R : Covariant<R>
>   : ^^^^^^^^^^^^
}

declare function effectGen<Eff extends Effect<any, any, any>, AEff>(
>effectGen : <Eff extends Effect<any, any, any>, AEff>(f: () => Generator<Eff, AEff, never>) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer _E, infer R>] ? R : never>
>          : ^   ^^^^^^^^^                     ^^    ^^ ^^                                 ^^^^^                                                                                                                                                                                                              

  f: () => Generator<Eff, AEff, never>
>f : () => Generator<Eff, AEff, never>
>  : ^^^^^^                           

): Effect<
  AEff,
  [Eff] extends [never]
    ? never
    : [Eff] extends [Effect<infer _A, infer E, infer _R>]
    ? E
    : never,
  [Eff] extends [never]
    ? never
    : [Eff] extends [Effect<infer _A, infer _E, infer R>]
    ? R
    : never
>;

declare function effectFn<
>effectFn : <Eff extends Effect<any, any, any>, AEff, Args extends Array<any>>(body: (...args: Args) => Generator<Eff, AEff, never>) => (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer _E, infer R>] ? R : never>
>         : ^   ^^^^^^^^^                     ^^    ^^    ^^^^^^^^^          ^^    ^^                                              ^^^^^                                                                                                                                                                                                                                 

  Eff extends Effect<any, any, any>,
  AEff,
  Args extends Array<any>
>(
  body: (...args: Args) => Generator<Eff, AEff, never>
>body : (...args: Args) => Generator<Eff, AEff, never>
>     : ^^^^    ^^    ^^^^^                           
>args : Args
>     : ^^^^

): (
  ...args: Args
>args : Args
>     : ^^^^

) => Effect<
  AEff,
  [Eff] extends [never]
    ? never
    : [Eff] extends [Effect<infer _A, infer E, infer _R>]
    ? E
    : never,
  [Eff] extends [never]
    ? never
    : [Eff] extends [Effect<infer _A, infer _E, infer R>]
    ? R
    : never
>;

interface Tag<in out Id, in out Value> {
  readonly _op: "Tag";
>_op : "Tag"
>    : ^^^^^

  readonly Service: Value;
>Service : Value
>        : ^^^^^

  readonly Identifier: Id;
>Identifier : Id
>           : ^^
}

interface TagClassShape<Id, Shape> {
  readonly Type: Shape;
>Type : Shape
>     : ^^^^^

  readonly Id: Id;
>Id : Id
>   : ^^
}

interface TagClass<Self, Id extends string, Type> extends Tag<Self, Type> {
  new (_: never): TagClassShape<Id, Type>;
>_ : never
>  : ^^^^^

  readonly key: Id;
>key : Id
>    : ^^
}

declare function layerEffect<I, S, E, R>(
>layerEffect : <I, S, E, R>(tag: Tag<I, S>, effect: Effect<S, E, R>) => unknown
>            : ^ ^^ ^^ ^^ ^^   ^^         ^^      ^^               ^^^^^       

  tag: Tag<I, S>,
>tag : Tag<I, S>
>    : ^^^^^^^^^

  effect: Effect<S, E, R>
>effect : Effect<S, E, R>
>       : ^^^^^^^^^^^^^^^

): unknown;

declare function Tag<const Id extends string>(
>Tag : <const Id extends string>(id: Id) => <Self, Shape>() => TagClass<Self, Id, Shape>
>    : ^^^^^^^  ^^^^^^^^^      ^^  ^^  ^^^^^                                            

  id: Id
>id : Id
>   : ^^

): <Self, Shape>() => TagClass<Self, Id, Shape>;

class Foo extends Tag("Foo")<
>Foo : Foo
>    : ^^^
>Tag("Foo")<  Foo,  {    fn: (a: string) => Effect<void>;  }>() : TagClassShape<"Foo", { fn: (a: string) => Effect<void>; }>
>                                                               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^                           ^^^^
>Tag("Foo") : <Self, Shape>() => TagClass<Self, "Foo", Shape>
>           : ^    ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Tag : <const Id extends string>(id: Id) => <Self, Shape>() => TagClass<Self, Id, Shape>
>    : ^^^^^^^  ^^^^^^^^^      ^^  ^^  ^^^^^                                            
>"Foo" : "Foo"
>      : ^^^^^

  Foo,
  {
    fn: (a: string) => Effect<void>;
>fn : (a: string) => Effect<void>
>   : ^ ^^      ^^^^^            
>a : string
>  : ^^^^^^
  }
>() {}

layerEffect(
>layerEffect(  Foo,  effectGen(function* () {    return {      fn: effectFn(function* (a) {        a; // string      }),    };  })) : unknown
>                                                                                                                                   : ^^^^^^^
>layerEffect : <I, S, E, R>(tag: Tag<I, S>, effect: Effect<S, E, R>) => unknown
>            : ^ ^^ ^^ ^^ ^^   ^^         ^^      ^^               ^^^^^       

  Foo,
>Foo : typeof Foo
>    : ^^^^^^^^^^

  effectGen(function* () {
>effectGen(function* () {    return {      fn: effectFn(function* (a) {        a; // string      }),    };  }) : Effect<{ fn: (a: string) => Effect<void, never, never>; }, never, never>
>                                                                                                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>effectGen : <Eff extends Effect<any, any, any>, AEff>(f: () => Generator<Eff, AEff, never>) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer _E, infer R>] ? R : never>
>          : ^   ^^^^^^^^^                     ^^    ^^ ^^                                 ^^^^^                                                                                                                                                                                                              
>function* () {    return {      fn: effectFn(function* (a) {        a; // string      }),    };  } : () => Generator<never, { fn: (a: string) => Effect<void, never, never>; }, never>
>                                                                                                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    return {
>{      fn: effectFn(function* (a) {        a; // string      }),    } : { fn: (a: string) => Effect<void, never, never>; }
>                                                                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

      fn: effectFn(function* (a) {
>fn : (a: string) => Effect<void, never, never>
>   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>effectFn(function* (a) {        a; // string      }) : (a: string) => Effect<void, never, never>
>                                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>effectFn : <Eff extends Effect<any, any, any>, AEff, Args extends Array<any>>(body: (...args: Args) => Generator<Eff, AEff, never>) => (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Effect<infer _A, infer _E, infer R>] ? R : never>
>         : ^   ^^^^^^^^^                     ^^    ^^    ^^^^^^^^^          ^^    ^^                                              ^^^^^                                                                                                                                                                                                                                 
>function* (a) {        a; // string      } : (a: string) => Generator<never, void, never>
>                                           : ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>a : string
>  : ^^^^^^

        a; // string
>a : string
>  : ^^^^^^

      }),
    };
  })
);

