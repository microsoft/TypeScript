//// [tests/cases/compiler/contextualTypeArrayBindingPatternConsistency.ts] ////

=== contextualTypeArrayBindingPatternConsistency.ts ===
type DataType = 'a' | 'b';
>DataType : DataType
>         : ^^^^^^^^

declare function foo<T extends { dataType: DataType }>(template: T): [T, any, any];
>foo : <T extends { dataType: DataType; }>(template: T) => [T, any, any]
>    : ^ ^^^^^^^^^                       ^^        ^^ ^^^^^             
>dataType : DataType
>         : ^^^^^^^^
>template : T
>         : ^

// These should behave identically since they call the same function with the same argument
// but use different destructuring patterns

// Pattern 1: [, , t] - should not have excess property error  
const [, , t1] = foo({ dataType: 'a', day: 0 });
> : undefined
> : ^^^^^^^^^
> : undefined
> : ^^^^^^^^^
>t1 : any
>   : ^^^
>foo({ dataType: 'a', day: 0 }) : [{ dataType: "a"; day: number; }, any, any]
>                               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>foo : <T extends { dataType: DataType; }>(template: T) => [T, any, any]
>    : ^ ^^^^^^^^^                       ^^        ^^ ^^^^^             
>{ dataType: 'a', day: 0 } : { dataType: "a"; day: number; }
>                          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>dataType : "a"
>         : ^^^
>'a' : "a"
>    : ^^^
>day : number
>    : ^^^^^^
>0 : 0
>  : ^

// Pattern 2: [, s, ] - should not have excess property error
const [, s1, ] = foo({ dataType: 'a', day: 0 });
> : undefined
> : ^^^^^^^^^
>s1 : any
>   : ^^^
>foo({ dataType: 'a', day: 0 }) : [{ dataType: "a"; day: number; }, any, any]
>                               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>foo : <T extends { dataType: DataType; }>(template: T) => [T, any, any]
>    : ^ ^^^^^^^^^                       ^^        ^^ ^^^^^             
>{ dataType: 'a', day: 0 } : { dataType: "a"; day: number; }
>                          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>dataType : "a"
>         : ^^^
>'a' : "a"
>    : ^^^
>day : number
>    : ^^^^^^
>0 : 0
>  : ^

// Both patterns should allow the excess property because they produce consistent contextual types
// that don't interfere with generic type inference

// Additional test cases to ensure the fix is general
const [, s2, ] = foo({ dataType: 'b', extra: 'test' }); // [, s, ] pattern with different property  
> : undefined
> : ^^^^^^^^^
>s2 : any
>   : ^^^
>foo({ dataType: 'b', extra: 'test' }) : [{ dataType: "b"; extra: string; }, any, any]
>                                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>foo : <T extends { dataType: DataType; }>(template: T) => [T, any, any]
>    : ^ ^^^^^^^^^                       ^^        ^^ ^^^^^             
>{ dataType: 'b', extra: 'test' } : { dataType: "b"; extra: string; }
>                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>dataType : "b"
>         : ^^^
>'b' : "b"
>    : ^^^
>extra : string
>      : ^^^^^^
>'test' : "test"
>       : ^^^^^^

const [, , s3] = foo({ dataType: 'a', another: 1 });    // [, , s] pattern
> : undefined
> : ^^^^^^^^^
> : undefined
> : ^^^^^^^^^
>s3 : any
>   : ^^^
>foo({ dataType: 'a', another: 1 }) : [{ dataType: "a"; another: number; }, any, any]
>                                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>foo : <T extends { dataType: DataType; }>(template: T) => [T, any, any]
>    : ^ ^^^^^^^^^                       ^^        ^^ ^^^^^             
>{ dataType: 'a', another: 1 } : { dataType: "a"; another: number; }
>                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>dataType : "a"
>         : ^^^
>'a' : "a"
>    : ^^^
>another : number
>        : ^^^^^^
>1 : 1
>  : ^

