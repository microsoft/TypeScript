=== tests/cases/conformance/controlFlow/controlFlowInstanceofExtendsFunction.ts ===
declare global {
>global : any

    interface Function {
        now(): string;
>now : () => string
    }
}

Function.prototype.now = function () {
>Function.prototype.now = function () {    return "now"} : () => string
>Function.prototype.now : () => string
>Function.prototype : Function
>Function : FunctionConstructor
>prototype : Function
>now : () => string
>function () {    return "now"} : () => string

    return "now"
>"now" : "now"
}

class X {
>X : X

    static now() {
>now : () => {}

        return {}
>{} : {}
    }

    why() {
>why : () => void

    }
}

class Y {
>Y : Y

}

console.log(X.now()) // works as expected
>console.log(X.now()) : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>X.now() : {}
>X.now : () => {}
>X : typeof X
>now : () => {}

console.log(Y.now()) // works as expected
>console.log(Y.now()) : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>Y.now() : string
>Y.now : () => string
>Y : typeof Y
>now : () => string

export const x: X | number = Math.random() > 0.5 ? new X() : 1
>x : number | X
>Math.random() > 0.5 ? new X() : 1 : X | 1
>Math.random() > 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
>new X() : X
>X : typeof X
>1 : 1

if (x instanceof X) {
>x instanceof X : boolean
>x : number | X
>X : typeof X

    x.why() // should compile
>x.why() : void
>x.why : () => void
>x : X
>why : () => void
}
