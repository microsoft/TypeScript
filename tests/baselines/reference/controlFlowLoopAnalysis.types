=== tests/cases/compiler/controlFlowLoopAnalysis.ts ===
// Repro from #8418

let cond: boolean;
>cond : boolean

function foo(x: number): number { return 1; }
>foo : (x: number) => number
>x : number
>1 : 1

function test1() {
>test1 : () => void

    let x: number | undefined;
>x : number | undefined

    while (cond) {
>cond : boolean

        while (cond) {
>cond : true

            while (cond) {
>cond : true

                x = foo(x);
>x = foo(x) : number
>x : number | undefined
>foo(x) : number
>foo : (x: number) => number
>x : number | undefined
            }
        }
        x = 1;
>x = 1 : 1
>x : number | undefined
>1 : 1
    }
}

// Repro from #8418

function test2() {
>test2 : () => void

    let x: number | undefined;
>x : number | undefined

    x = 1;
>x = 1 : 1
>x : number | undefined
>1 : 1

    while (cond) {
>cond : boolean

        while (cond) {
>cond : true

            x = foo(x);
>x = foo(x) : number
>x : number | undefined
>foo(x) : number
>foo : (x: number) => number
>x : number
        }
    }
}

// Repro from #8511

function mapUntilCant<a, b>(
>mapUntilCant : <a, b>(values: a[], canTake: (value: a, index: number) => boolean, mapping: (value: a, index: number) => b) => b[]

    values: a[],
>values : a[]

    canTake: (value: a, index: number) => boolean,
>canTake : (value: a, index: number) => boolean
>value : a
>index : number

    mapping: (value: a, index: number) => b
>mapping : (value: a, index: number) => b
>value : a
>index : number

): b[] {
    let result: b[] = [];
>result : b[]
>[] : never[]

    for (let index = 0, length = values.length; index < length; index++) {
>index : number
>0 : 0
>length : number
>values.length : number
>values : a[]
>length : number
>index < length : boolean
>index : number
>length : number
>index++ : number
>index : number

        let value = values[index];
>value : a
>values[index] : a
>values : a[]
>index : number

        if (canTake(value, index)) {
>canTake(value, index) : boolean
>canTake : (value: a, index: number) => boolean
>value : a
>index : number

            result.push(mapping(value, index));
>result.push(mapping(value, index)) : number
>result.push : (...items: b[]) => number
>result : b[]
>push : (...items: b[]) => number
>mapping(value, index) : b
>mapping : (value: a, index: number) => b
>value : a
>index : number

        } else {
            return result;
>result : b[]
        }
    }
    return result;
>result : b[]
}

