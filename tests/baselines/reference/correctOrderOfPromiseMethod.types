=== tests/cases/compiler/correctOrderOfPromiseMethod.ts ===
interface A {
    id: string
>id : string
}

interface B {
    id: string
>id : string

    fieldB: string
>fieldB : string
}

async function countEverything(): Promise<number> {
>countEverything : () => Promise<number>

    const providerA = async (): Promise<A[]> => { return [] }
>providerA : () => Promise<A[]>
>async (): Promise<A[]> => { return [] } : () => Promise<A[]>
>[] : undefined[]

    const providerB = async (): Promise<B[]> => { return [] }
>providerB : () => Promise<B[]>
>async (): Promise<B[]> => { return [] } : () => Promise<B[]>
>[] : undefined[]

    const [resultA, resultB] = await Promise.all([
>resultA : A[]
>resultB : B[]
>await Promise.all([        providerA(),        providerB(),    ] as const) : [A[], B[]]
>Promise.all([        providerA(),        providerB(),    ] as const) : Promise<[A[], B[]]>
>Promise.all : { <TAll>(values: Iterable<TAll>): Promise<(awaited TAll)[]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: readonly [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9, awaited T10]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: readonly [T1, T2, T3, T4, T5, T6, T7, T8, T9]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9]>; <T1, T2, T3, T4, T5, T6, T7, T8>(values: readonly [T1, T2, T3, T4, T5, T6, T7, T8]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8]>; <T1, T2, T3, T4, T5, T6, T7>(values: readonly [T1, T2, T3, T4, T5, T6, T7]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7]>; <T1, T2, T3, T4, T5, T6>(values: readonly [T1, T2, T3, T4, T5, T6]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6]>; <T1, T2, T3, T4, T5>(values: readonly [T1, T2, T3, T4, T5]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5]>; <T1, T2, T3, T4>(values: readonly [T1, T2, T3, T4]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4]>; <T1, T2, T3>(values: readonly [T1, T2, T3]): Promise<[awaited T1, awaited T2, awaited T3]>; <T1, T2>(values: readonly [T1, T2]): Promise<[awaited T1, awaited T2]>; <T>(values: readonly T[]): Promise<(awaited T)[]>; }
>Promise : PromiseConstructor
>all : { <TAll>(values: Iterable<TAll>): Promise<(awaited TAll)[]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: readonly [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9, awaited T10]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: readonly [T1, T2, T3, T4, T5, T6, T7, T8, T9]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9]>; <T1, T2, T3, T4, T5, T6, T7, T8>(values: readonly [T1, T2, T3, T4, T5, T6, T7, T8]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8]>; <T1, T2, T3, T4, T5, T6, T7>(values: readonly [T1, T2, T3, T4, T5, T6, T7]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7]>; <T1, T2, T3, T4, T5, T6>(values: readonly [T1, T2, T3, T4, T5, T6]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6]>; <T1, T2, T3, T4, T5>(values: readonly [T1, T2, T3, T4, T5]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5]>; <T1, T2, T3, T4>(values: readonly [T1, T2, T3, T4]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4]>; <T1, T2, T3>(values: readonly [T1, T2, T3]): Promise<[awaited T1, awaited T2, awaited T3]>; <T1, T2>(values: readonly [T1, T2]): Promise<[awaited T1, awaited T2]>; <T>(values: readonly T[]): Promise<(awaited T)[]>; }
>[        providerA(),        providerB(),    ] as const : readonly [Promise<A[]>, Promise<B[]>]
>[        providerA(),        providerB(),    ] : readonly [Promise<A[]>, Promise<B[]>]

        providerA(),
>providerA() : Promise<A[]>
>providerA : () => Promise<A[]>

        providerB(),
>providerB() : Promise<B[]>
>providerB : () => Promise<B[]>

    ] as const);

    const dataA: A[] = resultA;
>dataA : A[]
>resultA : A[]

    const dataB: B[] = resultB;
>dataB : B[]
>resultB : B[]

    if (dataA && dataB) {
>dataA && dataB : B[]
>dataA : A[]
>dataB : B[]

        return dataA.length + dataB.length;
>dataA.length + dataB.length : number
>dataA.length : number
>dataA : A[]
>length : number
>dataB.length : number
>dataB : B[]
>length : number
    }
    return 0;
>0 : 0
}

