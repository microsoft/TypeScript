//// [tests/cases/compiler/correlatedUnions3.ts] ////

=== correlatedUnions3.ts ===
type Definitions = {
>Definitions : Definitions
>            : ^^^^^^^^^^^

  onFoo: [arg: number];
>onFoo : [arg: number]
>      : ^^^^^^^^^^^^^

  onBar: [arg: string];
>onBar : [arg: string]
>      : ^^^^^^^^^^^^^

};

type SomeCallbacks = {
>SomeCallbacks : SomeCallbacks
>              : ^^^^^^^^^^^^^

  [K in keyof Definitions]?: (...args: Definitions[K]) => void;
>args : Definitions[K]
>     : ^^^^^^^^^^^^^^

};

const wrapCallback = <K extends keyof SomeCallbacks>(
>wrapCallback : <K extends keyof SomeCallbacks>(source: SomeCallbacks, target: SomeCallbacks, key: K) => void
>             : ^ ^^^^^^^^^                   ^^      ^^             ^^      ^^             ^^   ^^ ^^^^^^^^^
><K extends keyof SomeCallbacks>(  source: SomeCallbacks,  target: SomeCallbacks,  key: K,) => {  const callback = source[key];  target[key] =    callback &&    ((...args) => {      if (Math.random() > 0.5) {        return callback(...args);      }    });} : <K extends keyof SomeCallbacks>(source: SomeCallbacks, target: SomeCallbacks, key: K) => void
>                                                                                                                                                                                                                                                                : ^ ^^^^^^^^^                   ^^      ^^             ^^      ^^             ^^   ^^ ^^^^^^^^^

  source: SomeCallbacks,
>source : SomeCallbacks
>       : ^^^^^^^^^^^^^

  target: SomeCallbacks,
>target : SomeCallbacks
>       : ^^^^^^^^^^^^^

  key: K,
>key : K
>    : ^

) => {
  const callback = source[key];
>callback : SomeCallbacks[K]
>         : ^^^^^^^^^^^^^^^^
>source[key] : SomeCallbacks[K]
>            : ^^^^^^^^^^^^^^^^
>source : SomeCallbacks
>       : ^^^^^^^^^^^^^
>key : K
>    : ^

  target[key] =
>target[key] =    callback &&    ((...args) => {      if (Math.random() > 0.5) {        return callback(...args);      }    }) : (...args: Definitions[K]) => void
>                                                                                                                              : ^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^
>target[key] : SomeCallbacks[K]
>            : ^^^^^^^^^^^^^^^^
>target : SomeCallbacks
>       : ^^^^^^^^^^^^^
>key : K
>    : ^

    callback &&
>callback &&    ((...args) => {      if (Math.random() > 0.5) {        return callback(...args);      }    }) : (...args: Definitions[K]) => void
>                                                                                                             : ^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^
>callback : SomeCallbacks[K]
>         : ^^^^^^^^^^^^^^^^

    ((...args) => {
>((...args) => {      if (Math.random() > 0.5) {        return callback(...args);      }    }) : (...args: Definitions[K]) => void
>                                                                                              : ^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^
>(...args) => {      if (Math.random() > 0.5) {        return callback(...args);      }    } : (...args: Definitions[K]) => void
>                                                                                            : ^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^
>args : Definitions[K]
>     : ^^^^^^^^^^^^^^

      if (Math.random() > 0.5) {
>Math.random() > 0.5 : boolean
>                    : ^^^^^^^
>Math.random() : number
>              : ^^^^^^
>Math.random : () => number
>            : ^^^^^^      
>Math : Math
>     : ^^^^
>random : () => number
>       : ^^^^^^      
>0.5 : 0.5
>    : ^^^

        return callback(...args);
>callback(...args) : void
>                  : ^^^^
>callback : (...args: Definitions[K]) => void
>         : ^^^^    ^^^^^^^^^^^^^^^^^^^^^    
>...args : string | number
>        : ^^^^^^^^^^^^^^^
>args : Definitions[K]
>     : ^^^^^^^^^^^^^^
      }
    });
};

function wrapAll(callbacks: SomeCallbacks): SomeCallbacks {
>wrapAll : (callbacks: SomeCallbacks) => SomeCallbacks
>        : ^         ^^             ^^^^^             
>callbacks : SomeCallbacks
>          : ^^^^^^^^^^^^^

  const wrapped: SomeCallbacks = {};
>wrapped : SomeCallbacks
>        : ^^^^^^^^^^^^^
>{} : {}
>   : ^^

  for (let key in callbacks) {
>key : string
>    : ^^^^^^
>callbacks : SomeCallbacks
>          : ^^^^^^^^^^^^^

    wrapCallback(callbacks, wrapped, key as keyof SomeCallbacks);
>wrapCallback(callbacks, wrapped, key as keyof SomeCallbacks) : void
>                                                             : ^^^^
>wrapCallback : <K extends keyof SomeCallbacks>(source: SomeCallbacks, target: SomeCallbacks, key: K) => void
>             : ^ ^^^^^^^^^                   ^^      ^^             ^^      ^^             ^^   ^^ ^^^^^^^^^
>callbacks : SomeCallbacks
>          : ^^^^^^^^^^^^^
>wrapped : SomeCallbacks
>        : ^^^^^^^^^^^^^
>key as keyof SomeCallbacks : keyof Definitions
>                           : ^^^^^^^^^^^^^^^^^
>key : string
>    : ^^^^^^
  }
  return wrapped;
>wrapped : SomeCallbacks
>        : ^^^^^^^^^^^^^
}

