//// [tests/cases/conformance/types/typeRelationships/assignmentCompatibility/covariantCallbacks.ts] ////

=== covariantCallbacks.ts ===
// Test that callback parameters are related covariantly

interface P<T> {
    then(cb: (value: T) => void): void;
>then : (cb: (value: T) => void) => void
>cb : (value: T) => void
>value : T

};

interface A { a: string }
>a : string

interface B extends A { b: string }
>b : string

function f1(a: P<A>, b: P<B>) {
>f1 : (a: P<A>, b: P<B>) => void
>a : P<A>
>b : P<B>

    a = b;
>a = b : P<B>
>a : P<A>
>b : P<B>

    b = a;  // Error
>b = a : P<A>
>b : P<B>
>a : P<A>
}

function f2(a: Promise<A>, b: Promise<B>) {
>f2 : (a: Promise<A>, b: Promise<B>) => void
>a : Promise<A>
>b : Promise<B>

    a = b;
>a = b : Promise<B>
>a : Promise<A>
>b : Promise<B>

    b = a;  // Error
>b = a : Promise<A>
>b : Promise<B>
>a : Promise<A>
}

interface AList1 {
    forEach(cb: (item: A) => void): void;
>forEach : (cb: (item: A) => void) => void
>cb : (item: A) => void
>item : A
}

interface BList1 {
    forEach(cb: (item: B) => void): void;
>forEach : (cb: (item: B) => void) => void
>cb : (item: B) => void
>item : B
}

function f11(a: AList1, b: BList1) {
>f11 : (a: AList1, b: BList1) => void
>a : AList1
>b : BList1

    a = b;
>a = b : BList1
>a : AList1
>b : BList1

    b = a;  // Error
>b = a : AList1
>b : BList1
>a : AList1
}

interface AList2 {
    forEach(cb: (item: A) => boolean): void;
>forEach : (cb: (item: A) => boolean) => void
>cb : (item: A) => boolean
>item : A
}

interface BList2 {
    forEach(cb: (item: A) => void): void;
>forEach : (cb: (item: A) => void) => void
>cb : (item: A) => void
>item : A
}

function f12(a: AList2, b: BList2) {
>f12 : (a: AList2, b: BList2) => void
>a : AList2
>b : BList2

    a = b;
>a = b : BList2
>a : AList2
>b : BList2

    b = a;  // Error
>b = a : AList2
>b : BList2
>a : AList2
}

interface AList3 {
    forEach(cb: (item: A) => void): void;
>forEach : (cb: (item: A) => void) => void
>cb : (item: A) => void
>item : A
}

interface BList3 {
    forEach(cb: (item: A, context: any) => void): void;
>forEach : (cb: (item: A, context: any) => void) => void
>cb : (item: A, context: any) => void
>item : A
>context : any
}

function f13(a: AList3, b: BList3) {
>f13 : (a: AList3, b: BList3) => void
>a : AList3
>b : BList3

    a = b;
>a = b : BList3
>a : AList3
>b : BList3

    b = a;  // Error
>b = a : AList3
>b : BList3
>a : AList3
}

interface AList4 {
    forEach(cb: (item: A) => A): void;
>forEach : (cb: (item: A) => A) => void
>cb : (item: A) => A
>item : A
}

interface BList4 {
    forEach(cb: (item: B) => B): void;
>forEach : (cb: (item: B) => B) => void
>cb : (item: B) => B
>item : B
}

function f14(a: AList4, b: BList4) {
>f14 : (a: AList4, b: BList4) => void
>a : AList4
>b : BList4

    a = b;
>a = b : BList4
>a : AList4
>b : BList4

    b = a;  // Error
>b = a : AList4
>b : BList4
>a : AList4
}

// Repro from #51620

type Bivar<T> = { set(value: T): void }
>Bivar : Bivar<T>
>set : (value: T) => void
>value : T

declare let bu: Bivar<unknown>;
>bu : Bivar<unknown>

declare let bs: Bivar<string>;
>bs : Bivar<string>

bu = bs;
>bu = bs : Bivar<string>
>bu : Bivar<unknown>
>bs : Bivar<string>

bs = bu;
>bs = bu : Bivar<unknown>
>bs : Bivar<string>
>bu : Bivar<unknown>

declare let bfu: Bivar<(x: unknown) => void>;
>bfu : Bivar<(x: unknown) => void>
>x : unknown

declare let bfs: Bivar<(x: string) => void>;
>bfs : Bivar<(x: string) => void>
>x : string

bfu = bfs;
>bfu = bfs : Bivar<(x: string) => void>
>bfu : Bivar<(x: unknown) => void>
>bfs : Bivar<(x: string) => void>

bfs = bfu;
>bfs = bfu : Bivar<(x: unknown) => void>
>bfs : Bivar<(x: string) => void>
>bfu : Bivar<(x: unknown) => void>

type Bivar1<T> = { set(value: T): void }
>Bivar1 : Bivar1<T>
>set : (value: T) => void
>value : T

type Bivar2<T> = { set(value: T): void }
>Bivar2 : Bivar2<T>
>set : (value: T) => void
>value : T

declare let b1fu: Bivar1<(x: unknown) => void>;
>b1fu : Bivar1<(x: unknown) => void>
>x : unknown

declare let b2fs: Bivar2<(x: string) => void>;
>b2fs : Bivar2<(x: string) => void>
>x : string

b1fu = b2fs;
>b1fu = b2fs : Bivar2<(x: string) => void>
>b1fu : Bivar1<(x: unknown) => void>
>b2fs : Bivar2<(x: string) => void>

b2fs = b1fu;
>b2fs = b1fu : Bivar1<(x: unknown) => void>
>b2fs : Bivar2<(x: string) => void>
>b1fu : Bivar1<(x: unknown) => void>

type SetLike<T> = { set(value: T): void, get(): T }
>SetLike : SetLike<T>
>set : (value: T) => void
>value : T
>get : () => T

declare let sx: SetLike1<(x: unknown) => void>;
>sx : SetLike1<(x: unknown) => void>
>x : unknown

declare let sy: SetLike1<(x: string) => void>;
>sy : SetLike1<(x: string) => void>
>x : string

sx = sy;  // Error
>sx = sy : SetLike1<(x: string) => void>
>sx : SetLike1<(x: unknown) => void>
>sy : SetLike1<(x: string) => void>

sy = sx;
>sy = sx : SetLike1<(x: unknown) => void>
>sy : SetLike1<(x: string) => void>
>sx : SetLike1<(x: unknown) => void>

type SetLike1<T> = { set(value: T): void, get(): T }
>SetLike1 : SetLike1<T>
>set : (value: T) => void
>value : T
>get : () => T

type SetLike2<T> = { set(value: T): void, get(): T }
>SetLike2 : SetLike2<T>
>set : (value: T) => void
>value : T
>get : () => T

declare let s1: SetLike1<(x: unknown) => void>;
>s1 : SetLike1<(x: unknown) => void>
>x : unknown

declare let s2: SetLike2<(x: string) => void>;
>s2 : SetLike2<(x: string) => void>
>x : string

s1 = s2;  // Error
>s1 = s2 : SetLike2<(x: string) => void>
>s1 : SetLike1<(x: unknown) => void>
>s2 : SetLike2<(x: string) => void>

s2 = s1;
>s2 = s1 : SetLike1<(x: unknown) => void>
>s2 : SetLike2<(x: string) => void>
>s1 : SetLike1<(x: unknown) => void>

