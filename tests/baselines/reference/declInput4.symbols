//// [tests/cases/compiler/declInput4.ts] ////

=== declInput4.ts ===
module M {
>M : Symbol(M, Decl(declInput4.ts, 0, 0))

    class C { }
>C : Symbol(C, Decl(declInput4.ts, 0, 10))

    export class E {}
>E : Symbol(E, Decl(declInput4.ts, 1, 15))

    export interface I1 {}
>I1 : Symbol(I1, Decl(declInput4.ts, 2, 21))

    interface I2 {}
>I2 : Symbol(I2, Decl(declInput4.ts, 3, 26))

    export class D {
>D : Symbol(D, Decl(declInput4.ts, 4, 19))

        public m1: number;
>m1 : Symbol(D.m1, Decl(declInput4.ts, 5, 20))

        public m2: string;
>m2 : Symbol(D.m2, Decl(declInput4.ts, 6, 26))

        public m23: E;
>m23 : Symbol(D.m23, Decl(declInput4.ts, 7, 26))
>E : Symbol(E, Decl(declInput4.ts, 1, 15))

        public m24: I1;
>m24 : Symbol(D.m24, Decl(declInput4.ts, 8, 22))
>I1 : Symbol(I1, Decl(declInput4.ts, 2, 21))

        public m232(): E { return null;}
>m232 : Symbol(D.m232, Decl(declInput4.ts, 9, 23))
>E : Symbol(E, Decl(declInput4.ts, 1, 15))

        public m242(): I1 { return null; }
>m242 : Symbol(D.m242, Decl(declInput4.ts, 10, 40))
>I1 : Symbol(I1, Decl(declInput4.ts, 2, 21))

        public m26(i:I1) {}
>m26 : Symbol(D.m26, Decl(declInput4.ts, 11, 42))
>i : Symbol(i, Decl(declInput4.ts, 12, 19))
>I1 : Symbol(I1, Decl(declInput4.ts, 2, 21))
    }
}
