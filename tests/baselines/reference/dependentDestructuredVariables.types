=== tests/cases/conformance/controlFlow/dependentDestructuredVariables.ts ===
type Action =
>Action : Action

    | { kind: 'A', payload: number }
>kind : "A"
>payload : number

    | { kind: 'B', payload: string };
>kind : "B"
>payload : string

function f10({ kind, payload }: Action) {
>f10 : ({ kind, payload }: Action) => void
>kind : "A" | "B"
>payload : string | number

    if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

        payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string
    }
    if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

        payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string
    }
}

function f11(action: Action) {
>f11 : (action: Action) => void
>action : Action

    const { kind, payload } = action;
>kind : "A" | "B"
>payload : string | number
>action : Action

    if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

        payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string
    }
    if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

        payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string
    }
}

function f12({ kind, payload }: Action) {
>f12 : ({ kind, payload }: Action) => void
>kind : "A" | "B"
>payload : string | number

    switch (kind) {
>kind : "A" | "B"

        case 'A':
>'A' : "A"

            payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string

            break;
        case 'B':
>'B' : "B"

            payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string

            break;
        default:
            payload;  // never
>payload : never
    }
}

type Action2 =
>Action2 : Action2

    | { kind: 'A', payload: number | undefined }
>kind : "A"
>payload : number | undefined

    | { kind: 'B', payload: string | undefined };
>kind : "B"
>payload : string | undefined

function f20({ kind, payload }: Action2) {
>f20 : ({ kind, payload }: Action2) => void
>kind : "A" | "B"
>payload : string | number | undefined

    if (payload) {
>payload : string | number | undefined

        if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

            payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string
        }
        if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

            payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string
        }
    }
}

function f21(action: Action2) {
>f21 : (action: Action2) => void
>action : Action2

    const { kind, payload } = action;
>kind : "A" | "B"
>payload : string | number | undefined
>action : Action2

    if (payload) {
>payload : string | number | undefined

        if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

            payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string
        }
        if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

            payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string
        }
    }
}

function f22(action: Action2) {
>f22 : (action: Action2) => void
>action : Action2

    if (action.payload) {
>action.payload : string | number | undefined
>action : Action2
>payload : string | number | undefined

        const { kind, payload } = action;
>kind : "A" | "B"
>payload : string | number
>action : Action2

        if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

            payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string
        }
        if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

            payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string
        }
    }
}

function f23({ kind, payload }: Action2) {
>f23 : ({ kind, payload }: Action2) => void
>kind : "A" | "B"
>payload : string | number | undefined

    if (payload) {
>payload : string | number | undefined

        switch (kind) {
>kind : "A" | "B"

            case 'A':
>'A' : "A"

                payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string

                break;
            case 'B':
>'B' : "B"

                payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string

                break;
            default:
                payload;  // never
>payload : never
        }
    }
}

type Foo =
>Foo : Foo

    | { kind: 'A', isA: true }
>kind : "A"
>isA : true
>true : true

    | { kind: 'B', isA: false }
>kind : "B"
>isA : false
>false : false

    | { kind: 'C', isA: false };
>kind : "C"
>isA : false
>false : false

function f30({ kind, isA }: Foo) {
>f30 : ({ kind, isA }: Foo) => void
>kind : "A" | "B" | "C"
>isA : boolean

    if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B" | "C"
>'A' : "A"

        isA;   // true
>isA : true
    }
    if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B" | "C"
>'B' : "B"

        isA;   // false
>isA : false
    }
    if (kind === 'C') {
>kind === 'C' : boolean
>kind : "A" | "B" | "C"
>'C' : "C"

        isA;   // false
>isA : false
    }
    if (isA) {
>isA : boolean

        kind;  // 'A'
>kind : "A"
    }
    else {
        kind;  // 'B' | 'C'
>kind : "B" | "C"
    }
}

type Args = ['A', number] | ['B', string]
>Args : Args

function f40(...[kind, data]: Args) {
>f40 : (...[kind, data]: Args) => void
>kind : "A" | "B"
>data : string | number

    if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

        data.toFixed();
>data.toFixed() : string
>data.toFixed : (fractionDigits?: number | undefined) => string
>data : number
>toFixed : (fractionDigits?: number | undefined) => string
    }
    if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

        data.toUpperCase();
>data.toUpperCase() : string
>data.toUpperCase : () => string
>data : string
>toUpperCase : () => string
    }
}

// Repro from #35283

interface A<T> { variant: 'a', value: T }
>variant : "a"
>value : T

interface B<T> { variant: 'b', value: Array<T> }
>variant : "b"
>value : T[]

type AB<T> = A<T> | B<T>;
>AB : AB<T>

declare function printValue<T>(t: T): void;
>printValue : <T>(t: T) => void
>t : T

declare function printValueList<T>(t: Array<T>): void;
>printValueList : <T>(t: Array<T>) => void
>t : T[]

function unrefined1<T>(ab: AB<T>): void {
>unrefined1 : <T>(ab: AB<T>) => void
>ab : AB<T>

    const { variant, value } = ab;
>variant : "a" | "b"
>value : T | T[]
>ab : AB<T>

    if (variant === 'a') {
>variant === 'a' : boolean
>variant : "a" | "b"
>'a' : "a"

        printValue<T>(value);
>printValue<T>(value) : void
>printValue : <T>(t: T) => void
>value : T
    }
    else {
        printValueList<T>(value);
>printValueList<T>(value) : void
>printValueList : <T>(t: T[]) => void
>value : T[]
    }
}

// Repro from #38020

type Action3 =
>Action3 : Action3

    | {type: 'add', payload: { toAdd: number } }
>type : "add"
>payload : { toAdd: number; }
>toAdd : number

    | {type: 'remove', payload: { toRemove: number } };
>type : "remove"
>payload : { toRemove: number; }
>toRemove : number

const reducerBroken = (state: number, { type, payload }: Action3) => {
>reducerBroken : (state: number, { type, payload }: Action3) => number
>(state: number, { type, payload }: Action3) => {    switch (type) {        case 'add':            return state + payload.toAdd;        case 'remove':            return state - payload.toRemove;    }} : (state: number, { type, payload }: Action3) => number
>state : number
>type : "add" | "remove"
>payload : { toAdd: number; } | { toRemove: number; }

    switch (type) {
>type : "add" | "remove"

        case 'add':
>'add' : "add"

            return state + payload.toAdd;
>state + payload.toAdd : number
>state : number
>payload.toAdd : number
>payload : { toAdd: number; }
>toAdd : number

        case 'remove':
>'remove' : "remove"

            return state - payload.toRemove;
>state - payload.toRemove : number
>state : number
>payload.toRemove : number
>payload : { toRemove: number; }
>toRemove : number
    }
}

// Repro from #46143

declare var it: Iterator<number>;
>it : Iterator<number, any, undefined>

const { value, done } = it.next();
>value : any
>done : boolean | undefined
>it.next() : IteratorResult<number, any>
>it.next : (...args: [] | [undefined]) => IteratorResult<number, any>
>it : Iterator<number, any, undefined>
>next : (...args: [] | [undefined]) => IteratorResult<number, any>

if (!done) {
>!done : boolean
>done : boolean | undefined

    value;  // number
>value : number
}

// Repro from #46658

declare function f50(cb: (...args: Args) => void): void
>f50 : (cb: (...args: Args) => void) => void
>cb : (...args: Args) => void
>args : Args

f50((kind, data) => {
>f50((kind, data) => {    if (kind === 'A') {        data.toFixed();    }    if (kind === 'B') {        data.toUpperCase();    }}) : void
>f50 : (cb: (...args: Args) => void) => void
>(kind, data) => {    if (kind === 'A') {        data.toFixed();    }    if (kind === 'B') {        data.toUpperCase();    }} : (kind: "A" | "B", data: string | number) => void
>kind : "A" | "B"
>data : string | number

    if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

        data.toFixed();
>data.toFixed() : string
>data.toFixed : (fractionDigits?: number | undefined) => string
>data : number
>toFixed : (fractionDigits?: number | undefined) => string
    }
    if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

        data.toUpperCase();
>data.toUpperCase() : string
>data.toUpperCase : () => string
>data : string
>toUpperCase : () => string
    }
});

const f51: (...args: ['A', number] | ['B', string]) => void = (kind, payload) => {
>f51 : (...args: ['A', number] | ['B', string]) => void
>args : ["A", number] | ["B", string]
>(kind, payload) => {    if (kind === 'A') {        payload.toFixed();    }    if (kind === 'B') {        payload.toUpperCase();    }} : (kind: "A" | "B", payload: string | number) => void
>kind : "A" | "B"
>payload : string | number

    if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

        payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string
    }
    if (kind === 'B') {
>kind === 'B' : boolean
>kind : "A" | "B"
>'B' : "B"

        payload.toUpperCase();
>payload.toUpperCase() : string
>payload.toUpperCase : () => string
>payload : string
>toUpperCase : () => string
    }
};

const f52: (...args: ['A', number] | ['B']) => void = (kind, payload?) => {
>f52 : (...args: ['A', number] | ['B']) => void
>args : ["A", number] | ["B"]
>(kind, payload?) => {    if (kind === 'A') {        payload.toFixed();    }    else {        payload;  // undefined    }} : (kind: "A" | "B", payload?: number | undefined) => void
>kind : "A" | "B"
>payload : number | undefined

    if (kind === 'A') {
>kind === 'A' : boolean
>kind : "A" | "B"
>'A' : "A"

        payload.toFixed();
>payload.toFixed() : string
>payload.toFixed : (fractionDigits?: number | undefined) => string
>payload : number
>toFixed : (fractionDigits?: number | undefined) => string
    }
    else {
        payload;  // undefined
>payload : undefined
    }
};

declare function readFile(path: string, callback: (...args: [err: null, data: unknown[]] | [err: Error, data: undefined]) => void): void;
>readFile : (path: string, callback: (...args: [err: null, data: unknown[]] | [err: Error, data: undefined]) => void) => void
>path : string
>callback : (...args: [err: null, data: unknown[]] | [err: Error, data: undefined]) => void
>args : [err: null, data: unknown[]] | [err: Error, data: undefined]
>null : null

readFile('hello', (err, data) => {
>readFile('hello', (err, data) => {    if (err === null) {        data.length;    }    else {        err.message;    }}) : void
>readFile : (path: string, callback: (...args: [err: null, data: unknown[]] | [err: Error, data: undefined]) => void) => void
>'hello' : "hello"
>(err, data) => {    if (err === null) {        data.length;    }    else {        err.message;    }} : (err: Error | null, data: unknown[] | undefined) => void
>err : Error | null
>data : unknown[] | undefined

    if (err === null) {
>err === null : boolean
>err : Error | null
>null : null

        data.length;
>data.length : number
>data : unknown[]
>length : number
    }
    else {
        err.message;
>err.message : string
>err : Error
>message : string
    }
});

type ReducerArgs = ["add", { a: number, b: number }] | ["concat", { firstArr: any[], secondArr: any[] }];
>ReducerArgs : ReducerArgs
>a : number
>b : number
>firstArr : any[]
>secondArr : any[]

const reducer: (...args: ReducerArgs) => void = (op, args) => {
>reducer : (...args: ReducerArgs) => void
>args : ReducerArgs
>(op, args) => {    switch (op) {        case "add":            console.log(args.a + args.b);            break;        case "concat":            console.log(args.firstArr.concat(args.secondArr));            break;    }} : (op: "add" | "concat", args: { a: number; b: number; } | { firstArr: any[]; secondArr: any[]; }) => void
>op : "add" | "concat"
>args : { a: number; b: number; } | { firstArr: any[]; secondArr: any[]; }

    switch (op) {
>op : "add" | "concat"

        case "add":
>"add" : "add"

            console.log(args.a + args.b);
>console.log(args.a + args.b) : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>args.a + args.b : number
>args.a : number
>args : { a: number; b: number; }
>a : number
>args.b : number
>args : { a: number; b: number; }
>b : number

            break;
        case "concat":
>"concat" : "concat"

            console.log(args.firstArr.concat(args.secondArr));
>console.log(args.firstArr.concat(args.secondArr)) : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>args.firstArr.concat(args.secondArr) : any[]
>args.firstArr.concat : { (...items: ConcatArray<any>[]): any[]; (...items: any[]): any[]; }
>args.firstArr : any[]
>args : { firstArr: any[]; secondArr: any[]; }
>firstArr : any[]
>concat : { (...items: ConcatArray<any>[]): any[]; (...items: any[]): any[]; }
>args.secondArr : any[]
>args : { firstArr: any[]; secondArr: any[]; }
>secondArr : any[]

            break;
    }
}

reducer("add", { a: 1, b: 3 });
>reducer("add", { a: 1, b: 3 }) : void
>reducer : (...args: ReducerArgs) => void
>"add" : "add"
>{ a: 1, b: 3 } : { a: number; b: number; }
>a : number
>1 : 1
>b : number
>3 : 3

reducer("concat", { firstArr: [1, 2], secondArr: [3, 4] });
>reducer("concat", { firstArr: [1, 2], secondArr: [3, 4] }) : void
>reducer : (...args: ReducerArgs) => void
>"concat" : "concat"
>{ firstArr: [1, 2], secondArr: [3, 4] } : { firstArr: number[]; secondArr: number[]; }
>firstArr : number[]
>[1, 2] : number[]
>1 : 1
>2 : 2
>secondArr : number[]
>[3, 4] : number[]
>3 : 3
>4 : 4

// repro from https://github.com/microsoft/TypeScript/pull/47190#issuecomment-1057603588

type FooMethod = {
>FooMethod : FooMethod

  method(...args:
>method : (...args: [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]) => void
>args : [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]

    [type: "str", cb: (e: string) => void] |
>e : string

    [type: "num", cb: (e: number) => void]
>e : number

  ): void;
}

let fooM: FooMethod = {
>fooM : FooMethod
>{  method(type, cb) {    if (type == 'num') {      cb(123)    } else {      cb("abc")    }  }} : { method(type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)): void; }

  method(type, cb) {
>method : (type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)) => void
>type : "str" | "num"
>cb : ((e: string) => void) | ((e: number) => void)

    if (type == 'num') {
>type == 'num' : boolean
>type : "str" | "num"
>'num' : "num"

      cb(123)
>cb(123) : void
>cb : (e: number) => void
>123 : 123

    } else {
      cb("abc")
>cb("abc") : void
>cb : (e: string) => void
>"abc" : "abc"
    }
  }
};

type FooAsyncMethod = {
>FooAsyncMethod : FooAsyncMethod

  method(...args:
>method : (...args: [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]) => Promise<any>
>args : [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]

    [type: "str", cb: (e: string) => void] |
>e : string

    [type: "num", cb: (e: number) => void]
>e : number

  ): Promise<any>;
}

let fooAsyncM: FooAsyncMethod = {
>fooAsyncM : FooAsyncMethod
>{  async method(type, cb) {    if (type == 'num') {      cb(123)    } else {      cb("abc")    }  }} : { method(type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)): Promise<void>; }

  async method(type, cb) {
>method : (type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)) => Promise<void>
>type : "str" | "num"
>cb : ((e: string) => void) | ((e: number) => void)

    if (type == 'num') {
>type == 'num' : boolean
>type : "str" | "num"
>'num' : "num"

      cb(123)
>cb(123) : void
>cb : (e: number) => void
>123 : 123

    } else {
      cb("abc")
>cb("abc") : void
>cb : (e: string) => void
>"abc" : "abc"
    }
  }
};

type FooGenMethod = {
>FooGenMethod : FooGenMethod

  method(...args:
>method : (...args: [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]) => Generator<any, any, any>
>args : [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]

    [type: "str", cb: (e: string) => void] |
>e : string

    [type: "num", cb: (e: number) => void]
>e : number

  ): Generator<any, any, any>;
}

let fooGenM: FooGenMethod = {
>fooGenM : FooGenMethod
>{  *method(type, cb) {    if (type == 'num') {      cb(123)    } else {      cb("abc")    }  }} : { method(type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)): Generator<never, void, any>; }

  *method(type, cb) {
>method : (type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)) => Generator<never, void, any>
>type : "str" | "num"
>cb : ((e: string) => void) | ((e: number) => void)

    if (type == 'num') {
>type == 'num' : boolean
>type : "str" | "num"
>'num' : "num"

      cb(123)
>cb(123) : void
>cb : (e: number) => void
>123 : 123

    } else {
      cb("abc")
>cb("abc") : void
>cb : (e: string) => void
>"abc" : "abc"
    }
  }
};

type FooAsyncGenMethod = {
>FooAsyncGenMethod : FooAsyncGenMethod

  method(...args:
>method : (...args: [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]) => AsyncGenerator<any, any, any>
>args : [type: "str", cb: (e: string) => void] | [type: "num", cb: (e: number) => void]

    [type: "str", cb: (e: string) => void] |
>e : string

    [type: "num", cb: (e: number) => void]
>e : number

  ): AsyncGenerator<any, any, any>;
}

let fooAsyncGenM: FooAsyncGenMethod = {
>fooAsyncGenM : FooAsyncGenMethod
>{  async *method(type, cb) {    if (type == 'num') {      cb(123)    } else {      cb("abc")    }  }} : { method(type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)): AsyncGenerator<never, void, any>; }

  async *method(type, cb) {
>method : (type: "str" | "num", cb: ((e: string) => void) | ((e: number) => void)) => AsyncGenerator<never, void, any>
>type : "str" | "num"
>cb : ((e: string) => void) | ((e: number) => void)

    if (type == 'num') {
>type == 'num' : boolean
>type : "str" | "num"
>'num' : "num"

      cb(123)
>cb(123) : void
>cb : (e: number) => void
>123 : 123

    } else {
      cb("abc")
>cb("abc") : void
>cb : (e: string) => void
>"abc" : "abc"
    }
  }
};

