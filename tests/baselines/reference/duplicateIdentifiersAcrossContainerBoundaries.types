//// [tests/cases/compiler/duplicateIdentifiersAcrossContainerBoundaries.ts] ////

=== duplicateIdentifiersAcrossContainerBoundaries.ts ===
namespace M {
    export interface I { }
}
namespace M {
>M : typeof M
>  : ^^^^^^^^

    export class I { }
>I : I
>  : ^
}

namespace M {
>M : typeof M
>  : ^^^^^^^^

    export function f() { }
>f : typeof f
>  : ^^^^^^^^
}
namespace M {
>M : typeof M
>  : ^^^^^^^^

    export class f { } // error
>f : f
>  : ^
}

namespace M {
>M : typeof M
>  : ^^^^^^^^

    function g() { }
>g : () => void
>  : ^^^^^^^^^^
}
namespace M {
>M : typeof M
>  : ^^^^^^^^

    export class g { } // no error
>g : g
>  : ^
}

namespace M {
>M : typeof M
>  : ^^^^^^^^

    export class C { }
>C : C
>  : ^
}
namespace M {
>M : typeof M
>  : ^^^^^^^^

    function C() { } // no error
>C : () => void
>  : ^^^^^^^^^^
}

namespace M {
>M : typeof M
>  : ^^^^^^^^

    export var v = 3;
>v : number
>  : ^^^^^^
>3 : 3
>  : ^
}
namespace M {
>M : typeof M
>  : ^^^^^^^^

    export var v = 3; // error for redeclaring var in a different parent
>v : number
>  : ^^^^^^
>3 : 3
>  : ^
}

class Foo {
>Foo : Foo
>    : ^^^

    static x: number;
>x : number
>  : ^^^^^^
}

namespace Foo {
>Foo : typeof Foo
>    : ^^^^^^^^^^

    export var x: number; // error for redeclaring var in a different parent
>x : number
>  : ^^^^^^
}

namespace N {
>N : typeof N
>  : ^^^^^^^^

    export namespace F {
>F : typeof F
>  : ^^^^^^^^

        var t;
>t : any
>  : ^^^
    }
}
declare namespace N {
>N : typeof N
>  : ^^^^^^^^

    export function F(); // no error because function is ambient
>F : typeof F
>  : ^^^^^^^^
}

