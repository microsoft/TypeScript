//// [tests/cases/compiler/enumKeysAsComputedPropertiesWithBracketNotation.ts] ////

=== enumKeysAsComputedPropertiesWithBracketNotation.ts ===
// Test that enum keys accessed with bracket notation can be used as computed properties
// Regression test for https://github.com/microsoft/TypeScript/issues/25083

enum Type {
>Type : Symbol(Type, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 0, 0))

    Foo = 'foo',
>Foo : Symbol(Type.Foo, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 3, 11))

    '3x14' = '3x14'
>'3x14' : Symbol(Type['3x14'], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 4, 16))
}

// All of these should work
type TypeMap = {
>TypeMap : Symbol(TypeMap, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 6, 1))

    [Type.Foo]: string;        // Property access
>[Type.Foo] : Symbol([Type.Foo], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 9, 16))
>Type.Foo : Symbol(Type.Foo, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 3, 11))
>Type : Symbol(Type, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 0, 0))
>Foo : Symbol(Type.Foo, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 3, 11))

    [Type['3x14']]: number;    // Element access with non-identifier key
>[Type['3x14']] : Symbol([Type['3x14']], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 10, 23))
>Type : Symbol(Type, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 0, 0))
>'3x14' : Symbol(Type['3x14'], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 4, 16))
}

// Bracket notation with identifier key should also work (equivalent to property access)
type TypeMap2 = {
>TypeMap2 : Symbol(TypeMap2, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 12, 1))

    [Type['Foo']]: boolean;
>[Type['Foo']] : Symbol([Type['Foo']], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 15, 17))
>Type : Symbol(Type, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 0, 0))
>'Foo' : Symbol(Type.Foo, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 3, 11))
}

// Nested element access should work
const nested = {
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))

    inner: {
>inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))

        key: 'hello' as const
>key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
>const : Symbol(const)
    }
};

type TypeMap3 = {
>TypeMap3 : Symbol(TypeMap3, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 24, 2))

    [nested.inner.key]: string;
>[nested.inner.key] : Symbol([nested.inner.key], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 26, 17))
>nested.inner.key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
>nested.inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

// Element access on deeply nested path
type TypeMap4 = {
>TypeMap4 : Symbol(TypeMap4, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 28, 1))

    [nested['inner']['key']]: string;
>[nested['inner']['key']] : Symbol([nested['inner']['key']], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 31, 17))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>'inner' : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>'key' : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

// Mixed chain: element access followed by property access
type TypeMap5 = {
>TypeMap5 : Symbol(TypeMap5, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 33, 1))

    [nested['inner'].key]: string;
>[nested['inner'].key] : Symbol([nested['inner'].key], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 36, 17))
>nested['inner'].key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>'inner' : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

// Mixed chain: property access followed by element access
type TypeMap6 = {
>TypeMap6 : Symbol(TypeMap6, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 38, 1))

    [nested.inner['key']]: string;
>[nested.inner['key']] : Symbol([nested.inner['key']], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 41, 17))
>nested.inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>'key' : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

// Complex mixed chain
const deep = {
>deep : Symbol(deep, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 5))

    a: {
>a : Symbol(a, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 14))

        b: {
>b : Symbol(b, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 47, 8))

            c: {
>c : Symbol(c, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 48, 12))

                d: 'value' as const
>d : Symbol(d, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 49, 16))
>const : Symbol(const)
            }
        }
    }
};

type TypeMap7 = {
>TypeMap7 : Symbol(TypeMap7, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 54, 2))

    [deep.a['b'].c['d']]: string;
>[deep.a['b'].c['d']] : Symbol([deep.a['b'].c['d']], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 56, 17))
>deep.a['b'].c : Symbol(c, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 48, 12))
>deep.a : Symbol(a, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 14))
>deep : Symbol(deep, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 5))
>a : Symbol(a, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 14))
>'b' : Symbol(b, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 47, 8))
>c : Symbol(c, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 48, 12))
>'d' : Symbol(d, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 49, 16))
}

type TypeMap8 = {
>TypeMap8 : Symbol(TypeMap8, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 58, 1))

    [deep['a'].b['c'].d]: string;
>[deep['a'].b['c'].d] : Symbol([deep['a'].b['c'].d], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 60, 17))
>deep['a'].b['c'].d : Symbol(d, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 49, 16))
>deep['a'].b : Symbol(b, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 47, 8))
>deep : Symbol(deep, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 5))
>'a' : Symbol(a, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 14))
>b : Symbol(b, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 47, 8))
>'c' : Symbol(c, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 48, 12))
>d : Symbol(d, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 49, 16))
}

// Parenthesized expressions
type TypeMap9 = {
>TypeMap9 : Symbol(TypeMap9, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 62, 1))

    [(nested.inner).key]: string;
>[(nested.inner).key] : Symbol([(nested.inner).key], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 65, 17))
>(nested.inner).key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
>nested.inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

type TypeMap10 = {
>TypeMap10 : Symbol(TypeMap10, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 67, 1))

    [(nested['inner']).key]: string;
>[(nested['inner']).key] : Symbol([(nested['inner']).key], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 69, 18))
>(nested['inner']).key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>'inner' : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

type TypeMap11 = {
>TypeMap11 : Symbol(TypeMap11, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 71, 1))

    [(nested).inner.key]: string;
>[(nested).inner.key] : Symbol([(nested).inner.key], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 73, 18))
>(nested).inner.key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
>(nested).inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>inner : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
>key : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

// Parenthesized keys in element access
type TypeMap12 = {
>TypeMap12 : Symbol(TypeMap12, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 75, 1))

    [nested[('inner')]['key']]: string;
>[nested[('inner')]['key']] : Symbol([nested[('inner')]['key']], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 78, 18))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>'key' : Symbol(key, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 21, 12))
}

type TypeMap13 = {
>TypeMap13 : Symbol(TypeMap13, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 80, 1))

    [nested['inner'][('key')]]: string;
>[nested['inner'][('key')]] : Symbol([nested['inner'][('key')]], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 82, 18))
>nested : Symbol(nested, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 5))
>'inner' : Symbol(inner, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 20, 16))
}

type TypeMap14 = {
>TypeMap14 : Symbol(TypeMap14, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 84, 1))

    [deep[('a')][('b')].c['d']]: string;
>[deep[('a')][('b')].c['d']] : Symbol([deep[('a')][('b')].c['d']], Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 86, 18))
>deep[('a')][('b')].c : Symbol(c, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 48, 12))
>deep : Symbol(deep, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 46, 5))
>c : Symbol(c, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 48, 12))
>'d' : Symbol(d, Decl(enumKeysAsComputedPropertiesWithBracketNotation.ts, 49, 16))
}

