//// [tests/cases/compiler/enumKeysAsComputedPropertiesWithBracketNotation.ts] ////

=== enumKeysAsComputedPropertiesWithBracketNotation.ts ===
// Test that enum keys accessed with bracket notation can be used as computed properties
// Regression test for https://github.com/microsoft/TypeScript/issues/25083

enum Type {
>Type : Type
>     : ^^^^

    Foo = 'foo',
>Foo : Type.Foo
>    : ^^^^^^^^
>'foo' : "foo"
>      : ^^^^^

    '3x14' = '3x14'
>'3x14' : (typeof Type)["3x14"]
>       : ^^^^^^^^^^^^^^^^^^^^^
>'3x14' : "3x14"
>       : ^^^^^^
}

// All of these should work
type TypeMap = {
>TypeMap : TypeMap
>        : ^^^^^^^

    [Type.Foo]: string;        // Property access
>[Type.Foo] : string
>           : ^^^^^^
>Type.Foo : Type.Foo
>         : ^^^^^^^^
>Type : typeof Type
>     : ^^^^^^^^^^^
>Foo : Type.Foo
>    : ^^^^^^^^

    [Type['3x14']]: number;    // Element access with non-identifier key
>[Type['3x14']] : number
>               : ^^^^^^
>Type['3x14'] : (typeof Type)["3x14"]
>             : ^^^^^^^^^^^^^^^^^^^^^
>Type : typeof Type
>     : ^^^^^^^^^^^
>'3x14' : "3x14"
>       : ^^^^^^
}

// Bracket notation with identifier key should also work (equivalent to property access)
type TypeMap2 = {
>TypeMap2 : TypeMap2
>         : ^^^^^^^^

    [Type['Foo']]: boolean;
>[Type['Foo']] : boolean
>              : ^^^^^^^
>Type['Foo'] : Type.Foo
>            : ^^^^^^^^
>Type : typeof Type
>     : ^^^^^^^^^^^
>'Foo' : "Foo"
>      : ^^^^^
}

// Nested element access should work
const nested = {
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{    inner: {        key: 'hello' as const    }} : { inner: { key: "hello"; }; }
>                                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    inner: {
>inner : { key: "hello"; }
>      : ^^^^^^^^^^^^^^^^^
>{        key: 'hello' as const    } : { key: "hello"; }
>                                    : ^^^^^^^^^^^^^^^^^

        key: 'hello' as const
>key : "hello"
>    : ^^^^^^^
>'hello' as const : "hello"
>                 : ^^^^^^^
>'hello' : "hello"
>        : ^^^^^^^
    }
};

type TypeMap3 = {
>TypeMap3 : TypeMap3
>         : ^^^^^^^^

    [nested.inner.key]: string;
>[nested.inner.key] : string
>                   : ^^^^^^
>nested.inner.key : "hello"
>                 : ^^^^^^^
>nested.inner : { key: "hello"; }
>             : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>inner : { key: "hello"; }
>      : ^^^^^^^^^^^^^^^^^
>key : "hello"
>    : ^^^^^^^
}

// Element access on deeply nested path
type TypeMap4 = {
>TypeMap4 : TypeMap4
>         : ^^^^^^^^

    [nested['inner']['key']]: string;
>[nested['inner']['key']] : string
>                         : ^^^^^^
>nested['inner']['key'] : "hello"
>                       : ^^^^^^^
>nested['inner'] : { key: "hello"; }
>                : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>'inner' : "inner"
>        : ^^^^^^^
>'key' : "key"
>      : ^^^^^
}

// Mixed chain: element access followed by property access
type TypeMap5 = {
>TypeMap5 : TypeMap5
>         : ^^^^^^^^

    [nested['inner'].key]: string;
>[nested['inner'].key] : string
>                      : ^^^^^^
>nested['inner'].key : "hello"
>                    : ^^^^^^^
>nested['inner'] : { key: "hello"; }
>                : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>'inner' : "inner"
>        : ^^^^^^^
>key : "hello"
>    : ^^^^^^^
}

// Mixed chain: property access followed by element access
type TypeMap6 = {
>TypeMap6 : TypeMap6
>         : ^^^^^^^^

    [nested.inner['key']]: string;
>[nested.inner['key']] : string
>                      : ^^^^^^
>nested.inner['key'] : "hello"
>                    : ^^^^^^^
>nested.inner : { key: "hello"; }
>             : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>inner : { key: "hello"; }
>      : ^^^^^^^^^^^^^^^^^
>'key' : "key"
>      : ^^^^^
}

// Complex mixed chain
const deep = {
>deep : { a: { b: { c: { d: "value"; }; }; }; }
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{    a: {        b: {            c: {                d: 'value' as const            }        }    }} : { a: { b: { c: { d: "value"; }; }; }; }
>                                                                                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    a: {
>a : { b: { c: { d: "value"; }; }; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{        b: {            c: {                d: 'value' as const            }        }    } : { b: { c: { d: "value"; }; }; }
>                                                                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        b: {
>b : { c: { d: "value"; }; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^
>{            c: {                d: 'value' as const            }        } : { c: { d: "value"; }; }
>                                                                           : ^^^^^^^^^^^^^^^^^^^^^^^

            c: {
>c : { d: "value"; }
>  : ^^^^^^^^^^^^^^^
>{                d: 'value' as const            } : { d: "value"; }
>                                                  : ^^^^^^^^^^^^^^^

                d: 'value' as const
>d : "value"
>  : ^^^^^^^
>'value' as const : "value"
>                 : ^^^^^^^
>'value' : "value"
>        : ^^^^^^^
            }
        }
    }
};

type TypeMap7 = {
>TypeMap7 : TypeMap7
>         : ^^^^^^^^

    [deep.a['b'].c['d']]: string;
>[deep.a['b'].c['d']] : string
>                     : ^^^^^^
>deep.a['b'].c['d'] : "value"
>                   : ^^^^^^^
>deep.a['b'].c : { d: "value"; }
>              : ^^^^^^^^^^^^^^^
>deep.a['b'] : { c: { d: "value"; }; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^
>deep.a : { b: { c: { d: "value"; }; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>deep : { a: { b: { c: { d: "value"; }; }; }; }
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>a : { b: { c: { d: "value"; }; }; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>'b' : "b"
>    : ^^^
>c : { d: "value"; }
>  : ^^^^^^^^^^^^^^^
>'d' : "d"
>    : ^^^
}

type TypeMap8 = {
>TypeMap8 : TypeMap8
>         : ^^^^^^^^

    [deep['a'].b['c'].d]: string;
>[deep['a'].b['c'].d] : string
>                     : ^^^^^^
>deep['a'].b['c'].d : "value"
>                   : ^^^^^^^
>deep['a'].b['c'] : { d: "value"; }
>                 : ^^^^^^^^^^^^^^^
>deep['a'].b : { c: { d: "value"; }; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^
>deep['a'] : { b: { c: { d: "value"; }; }; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>deep : { a: { b: { c: { d: "value"; }; }; }; }
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>'a' : "a"
>    : ^^^
>b : { c: { d: "value"; }; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^
>'c' : "c"
>    : ^^^
>d : "value"
>  : ^^^^^^^
}

// Parenthesized expressions
type TypeMap9 = {
>TypeMap9 : TypeMap9
>         : ^^^^^^^^

    [(nested.inner).key]: string;
>[(nested.inner).key] : string
>                     : ^^^^^^
>(nested.inner).key : "hello"
>                   : ^^^^^^^
>(nested.inner) : { key: "hello"; }
>               : ^^^^^^^^^^^^^^^^^
>nested.inner : { key: "hello"; }
>             : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>inner : { key: "hello"; }
>      : ^^^^^^^^^^^^^^^^^
>key : "hello"
>    : ^^^^^^^
}

type TypeMap10 = {
>TypeMap10 : TypeMap10
>          : ^^^^^^^^^

    [(nested['inner']).key]: string;
>[(nested['inner']).key] : string
>                        : ^^^^^^
>(nested['inner']).key : "hello"
>                      : ^^^^^^^
>(nested['inner']) : { key: "hello"; }
>                  : ^^^^^^^^^^^^^^^^^
>nested['inner'] : { key: "hello"; }
>                : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>'inner' : "inner"
>        : ^^^^^^^
>key : "hello"
>    : ^^^^^^^
}

type TypeMap11 = {
>TypeMap11 : TypeMap11
>          : ^^^^^^^^^

    [(nested).inner.key]: string;
>[(nested).inner.key] : string
>                     : ^^^^^^
>(nested).inner.key : "hello"
>                   : ^^^^^^^
>(nested).inner : { key: "hello"; }
>               : ^^^^^^^^^^^^^^^^^
>(nested) : { inner: { key: "hello"; }; }
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>inner : { key: "hello"; }
>      : ^^^^^^^^^^^^^^^^^
>key : "hello"
>    : ^^^^^^^
}

// Parenthesized keys in element access
type TypeMap12 = {
>TypeMap12 : TypeMap12
>          : ^^^^^^^^^

    [nested[('inner')]['key']]: string;
>[nested[('inner')]['key']] : string
>                           : ^^^^^^
>nested[('inner')]['key'] : "hello"
>                         : ^^^^^^^
>nested[('inner')] : { key: "hello"; }
>                  : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>('inner') : "inner"
>          : ^^^^^^^
>'inner' : "inner"
>        : ^^^^^^^
>'key' : "key"
>      : ^^^^^
}

type TypeMap13 = {
>TypeMap13 : TypeMap13
>          : ^^^^^^^^^

    [nested['inner'][('key')]]: string;
>[nested['inner'][('key')]] : string
>                           : ^^^^^^
>nested['inner'][('key')] : "hello"
>                         : ^^^^^^^
>nested['inner'] : { key: "hello"; }
>                : ^^^^^^^^^^^^^^^^^
>nested : { inner: { key: "hello"; }; }
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>'inner' : "inner"
>        : ^^^^^^^
>('key') : "key"
>        : ^^^^^
>'key' : "key"
>      : ^^^^^
}

type TypeMap14 = {
>TypeMap14 : TypeMap14
>          : ^^^^^^^^^

    [deep[('a')][('b')].c['d']]: string;
>[deep[('a')][('b')].c['d']] : string
>                            : ^^^^^^
>deep[('a')][('b')].c['d'] : "value"
>                          : ^^^^^^^
>deep[('a')][('b')].c : { d: "value"; }
>                     : ^^^^^^^^^^^^^^^
>deep[('a')][('b')] : { c: { d: "value"; }; }
>                   : ^^^^^^^^^^^^^^^^^^^^^^^
>deep[('a')] : { b: { c: { d: "value"; }; }; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>deep : { a: { b: { c: { d: "value"; }; }; }; }
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>('a') : "a"
>      : ^^^
>'a' : "a"
>    : ^^^
>('b') : "b"
>      : ^^^
>'b' : "b"
>    : ^^^
>c : { d: "value"; }
>  : ^^^^^^^^^^^^^^^
>'d' : "d"
>    : ^^^
}

