//// [tests/cases/conformance/interfaces/declarationMerging/genericAndNonGenericInterfaceWithTheSameName2.ts] ////

=== genericAndNonGenericInterfaceWithTheSameName2.ts ===
// generic and non-generic interfaces with the same name do not merge

namespace M {
>M : Symbol(M, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 0, 0))

    interface A<T> {
>A : Symbol(A, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 2, 13))
>T : Symbol(T, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 3, 16))

        bar: T;
>bar : Symbol(A.bar, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 3, 20))
>T : Symbol(T, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 3, 16))
    }
}

namespace M2 {
>M2 : Symbol(M2, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 6, 1))

    interface A { // ok
>A : Symbol(A, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 8, 14))

        foo: string;
>foo : Symbol(A.foo, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 9, 17))
    }
}

namespace N {
>N : Symbol(N, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 12, 1))

    namespace M {
>M : Symbol(M, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 14, 13))

        interface A<T> {
>A : Symbol(A, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 15, 17))
>T : Symbol(T, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 16, 20))

            bar: T;
>bar : Symbol(A.bar, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 16, 24))
>T : Symbol(T, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 16, 20))
        }
    }

    namespace M2 {
>M2 : Symbol(M2, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 19, 5))

        interface A { // ok
>A : Symbol(A, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 21, 18))

            foo: string;
>foo : Symbol(A.foo, Decl(genericAndNonGenericInterfaceWithTheSameName2.ts, 22, 21))
        }
    }
}
