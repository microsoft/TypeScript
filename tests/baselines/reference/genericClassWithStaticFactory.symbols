//// [tests/cases/compiler/genericClassWithStaticFactory.ts] ////

=== genericClassWithStaticFactory.ts ===
namespace Editor {
>Editor : Symbol(Editor, Decl(genericClassWithStaticFactory.ts, 0, 0))

    export class List<T> {
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

        public next: List<T>;
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

        public prev: List<T>;
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

        private listFactory: ListFactory<T>;
>listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>ListFactory : Symbol(ListFactory, Decl(genericClassWithStaticFactory.ts, 106, 5))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

        constructor(public isHead: boolean, public data: T) {
>isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>data : Symbol(List.data, Decl(genericClassWithStaticFactory.ts, 7, 43))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            this.listFactory = new ListFactory<T>();
>this.listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>ListFactory : Symbol(ListFactory, Decl(genericClassWithStaticFactory.ts, 106, 5))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
           
        }

        public add(data: T): List<T> {
>add : Symbol(List.add, Decl(genericClassWithStaticFactory.ts, 10, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 12, 19))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            var entry = this.listFactory.MakeEntry(data);
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 13, 15))
>this.listFactory.MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>this.listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 12, 19))
            
            this.prev.next = entry;
>this.prev.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 13, 15))

            entry.next = this;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 13, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))

            entry.prev = this.prev;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 13, 15))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))

            this.prev = entry;
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 13, 15))

            return entry;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 13, 15))
        }

        public count(): number {
>count : Symbol(List.count, Decl(genericClassWithStaticFactory.ts, 20, 9))

            var entry: List<T>;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 23, 15))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            var i: number;
>i : Symbol(i, Decl(genericClassWithStaticFactory.ts, 24, 15))

            entry = this.next;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 23, 15))
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))

            for (i = 0; !(entry.isHead); i++) {
>i : Symbol(i, Decl(genericClassWithStaticFactory.ts, 24, 15))
>entry.isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 23, 15))
>isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>i : Symbol(i, Decl(genericClassWithStaticFactory.ts, 24, 15))

                entry = entry.next;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 23, 15))
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 23, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
            }

            return (i);
>i : Symbol(i, Decl(genericClassWithStaticFactory.ts, 24, 15))
        }

        public isEmpty(): boolean {
>isEmpty : Symbol(List.isEmpty, Decl(genericClassWithStaticFactory.ts, 32, 9))

            return (this.next == this);
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
        }

        public first(): T {
>first : Symbol(List.first, Decl(genericClassWithStaticFactory.ts, 36, 9))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            if (this.isEmpty())
>this.isEmpty : Symbol(List.isEmpty, Decl(genericClassWithStaticFactory.ts, 32, 9))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>isEmpty : Symbol(List.isEmpty, Decl(genericClassWithStaticFactory.ts, 32, 9))
            {
                return this.next.data;
>this.next.data : Symbol(List.data, Decl(genericClassWithStaticFactory.ts, 7, 43))
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>data : Symbol(List.data, Decl(genericClassWithStaticFactory.ts, 7, 43))
            }
            else {
                return null;
            }
        }

        public pushEntry(entry: List<T>): void {
>pushEntry : Symbol(List.pushEntry, Decl(genericClassWithStaticFactory.ts, 46, 9))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 48, 25))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            entry.isHead = false;
>entry.isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 48, 25))
>isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))

            entry.next = this.next;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 48, 25))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))

            entry.prev = this;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 48, 25))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))

            this.next = entry;
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 48, 25))

            entry.next.prev = entry; // entry.next.prev does not show intellisense, but entry.prev.prev does
>entry.next.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 48, 25))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 48, 25))
        }

        public push(data: T): void {
>push : Symbol(List.push, Decl(genericClassWithStaticFactory.ts, 54, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 56, 20))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            var entry = this.listFactory.MakeEntry(data);
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))
>this.listFactory.MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>this.listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 56, 20))

            entry.data = data;
>entry.data : Symbol(List.data, Decl(genericClassWithStaticFactory.ts, 7, 43))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))
>data : Symbol(List.data, Decl(genericClassWithStaticFactory.ts, 7, 43))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 56, 20))

            entry.isHead = false;
>entry.isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))
>isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))

            entry.next = this.next;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))

            entry.prev = this;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))

            this.next = entry;
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))

            entry.next.prev = entry;  // entry.next.prev does not show intellisense, but entry.prev.prev does
>entry.next.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 57, 15))
        }

        public popEntry(head: List<T>): List<T> {
>popEntry : Symbol(List.popEntry, Decl(genericClassWithStaticFactory.ts, 64, 9))
>head : Symbol(head, Decl(genericClassWithStaticFactory.ts, 66, 24))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            if (this.next.isHead) {
>this.next.isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))

                return null;
            }
            else {
                return this.listFactory.RemoveEntry(this.next);
>this.listFactory.RemoveEntry : Symbol(ListFactory.RemoveEntry, Decl(genericClassWithStaticFactory.ts, 122, 9))
>this.listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>RemoveEntry : Symbol(ListFactory.RemoveEntry, Decl(genericClassWithStaticFactory.ts, 122, 9))
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
            }
        }

        public insertEntry(entry: List<T>): List<T> {
>insertEntry : Symbol(List.insertEntry, Decl(genericClassWithStaticFactory.ts, 73, 9))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 75, 27))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            entry.isHead = false;
>entry.isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 75, 27))
>isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))

            this.prev.next = entry;
>this.prev.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 75, 27))

            entry.next = this;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 75, 27))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))

            entry.prev = this.prev;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 75, 27))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))

            this.prev = entry;
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 75, 27))

            return entry;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 75, 27))
        }

        public insertAfter(data: T): List<T> {
>insertAfter : Symbol(List.insertAfter, Decl(genericClassWithStaticFactory.ts, 82, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 84, 27))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            var entry: List<T> = this.listFactory.MakeEntry(data);
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 85, 15))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
>this.listFactory.MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>this.listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 84, 27))

            entry.next = this.next;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 85, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))

            entry.prev = this;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 85, 15))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))

            this.next = entry;
>this.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 85, 15))

            entry.next.prev = entry;// entry.next.prev does not show intellisense, but entry.prev.prev does
>entry.next.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 85, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 85, 15))

            return entry;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 85, 15))
        }

        public insertEntryBefore(entry: List<T>): List<T> {
>insertEntryBefore : Symbol(List.insertEntryBefore, Decl(genericClassWithStaticFactory.ts, 91, 9))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 93, 33))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            this.prev.next = entry;
>this.prev.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 93, 33))

            entry.next = this;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 93, 33))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))

            entry.prev = this.prev;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 93, 33))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))

            this.prev = entry;
>this.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 93, 33))

            return entry;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 93, 33))
        }

        public insertBefore(data: T): List<T> {
>insertBefore : Symbol(List.insertBefore, Decl(genericClassWithStaticFactory.ts, 100, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 102, 28))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 2, 22))

            var entry = this.listFactory.MakeEntry(data);
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 103, 15))
>this.listFactory.MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>this.listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>listFactory : Symbol(List.listFactory, Decl(genericClassWithStaticFactory.ts, 4, 29))
>MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 102, 28))

            return this.insertEntryBefore(entry);
>this.insertEntryBefore : Symbol(List.insertEntryBefore, Decl(genericClassWithStaticFactory.ts, 91, 9))
>this : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>insertEntryBefore : Symbol(List.insertEntryBefore, Decl(genericClassWithStaticFactory.ts, 91, 9))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 103, 15))
        }
    }

    export class ListFactory<T> {
>ListFactory : Symbol(ListFactory, Decl(genericClassWithStaticFactory.ts, 106, 5))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 108, 29))

        public MakeHead<T>(): List<T> {
>MakeHead : Symbol(ListFactory.MakeHead, Decl(genericClassWithStaticFactory.ts, 108, 33))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 110, 24))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 110, 24))

            var entry: List<T> = new List<T>(true, null);
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 111, 15))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 110, 24))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 110, 24))

            entry.prev = entry;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 111, 15))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 111, 15))

            entry.next = entry;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 111, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 111, 15))

            return entry;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 111, 15))
        }

        public MakeEntry<T>(data: T): List<T> {
>MakeEntry : Symbol(ListFactory.MakeEntry, Decl(genericClassWithStaticFactory.ts, 115, 9))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 117, 25))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 117, 28))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 117, 25))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 117, 25))

            var entry: List<T> = new List<T>(false, data);
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 118, 15))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 117, 25))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 117, 25))
>data : Symbol(data, Decl(genericClassWithStaticFactory.ts, 117, 28))

            entry.prev = entry;
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 118, 15))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 118, 15))

            entry.next = entry;
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 118, 15))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 118, 15))

            return entry;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 118, 15))
        }

        public RemoveEntry<T>(entry: List<T>): List<T> {
>RemoveEntry : Symbol(ListFactory.RemoveEntry, Decl(genericClassWithStaticFactory.ts, 122, 9))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 124, 27))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 124, 27))
>List : Symbol(List, Decl(genericClassWithStaticFactory.ts, 0, 18))
>T : Symbol(T, Decl(genericClassWithStaticFactory.ts, 124, 27))

            if (entry == null) {
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))

                return null;
            }
            else if (entry.isHead) {
>entry.isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))
>isHead : Symbol(List.isHead, Decl(genericClassWithStaticFactory.ts, 7, 20))

            // Can't remove the head of a list!
                return null;
            }
            else {
                entry.next.prev = entry.prev;
>entry.next.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))

                entry.prev.next = entry.next;
>entry.prev.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry.prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))
>prev : Symbol(List.prev, Decl(genericClassWithStaticFactory.ts, 3, 29))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry.next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))
>next : Symbol(List.next, Decl(genericClassWithStaticFactory.ts, 2, 26))

                return entry;
>entry : Symbol(entry, Decl(genericClassWithStaticFactory.ts, 124, 30))
            }
        }
    }
}
