=== tests/cases/conformance/types/members/indexSignatures1.ts ===
// Symbol index signature checking

const sym = Symbol();
>sym : unique symbol
>Symbol() : unique symbol
>Symbol : SymbolConstructor

function gg3(x: { [key: string]: string }, y: { [key: symbol]: string }, z: { [sym]: number }) {
>gg3 : (x: { [key: string]: string; }, y: { [key: symbol]: string; }, z: {    [sym]: number;}) => void
>x : { [key: string]: string; }
>key : string
>y : { [key: symbol]: string; }
>key : symbol
>z : { [sym]: number; }
>[sym] : number
>sym : unique symbol

    x = z;
>x = z : { [sym]: number; }
>x : { [key: string]: string; }
>z : { [sym]: number; }

    y = z;  // Error
>y = z : { [sym]: number; }
>y : { [key: symbol]: string; }
>z : { [sym]: number; }
}

// Overlapping index signatures

function gg1(x: { [key: `a${string}`]: string, [key: `${string}a`]: string }, y: { [key: `a${string}a`]: string }) {
>gg1 : (x: { [key: `a${string}`]: string; [key: `${string}a`]: string; }, y: { [key: `a${string}a`]: string; }) => void
>x : { [key: `a${string}`]: string; [key: `${string}a`]: string; }
>key : `a${string}`
>key : `${string}a`
>y : { [key: `a${string}a`]: string; }
>key : `a${string}a`

    x = y;
>x = y : { [key: `a${string}a`]: string; }
>x : { [key: `a${string}`]: string; [key: `${string}a`]: string; }
>y : { [key: `a${string}a`]: string; }

    y = x;
>y = x : { [key: `a${string}`]: string; [key: `${string}a`]: string; }
>y : { [key: `a${string}a`]: string; }
>x : { [key: `a${string}`]: string; [key: `${string}a`]: string; }
}

interface IX { [key: `a${string}`]: string, [key: `${string}a`]: string }
>key : `a${string}`
>key : `${string}a`

interface IY { [key: `a${string}a`]: string }
>key : `a${string}a`

function gg2(x: IX, y: IY) {
>gg2 : (x: IX, y: IY) => void
>x : IX
>y : IY

    x = y;  // Error
>x = y : IY
>x : IX
>y : IY

    y = x;
>y = x : IX
>y : IY
>x : IX
}

// Intersection of multiple applicable index signatures

declare let combo: { [x: `foo-${string}`]: 'a' | 'b' } & { [x: `${string}-bar`]: 'b' | 'c' };
>combo : { [x: `foo-${string}`]: "a" | "b"; } & { [x: `${string}-bar`]: "b" | "c"; }
>x : `foo-${string}`
>x : `${string}-bar`

const x1 = combo['foo-test'];  // 'a' | 'b'
>x1 : "a" | "b"
>combo['foo-test'] : "a" | "b"
>combo : { [x: `foo-${string}`]: "a" | "b"; } & { [x: `${string}-bar`]: "b" | "c"; }
>'foo-test' : "foo-test"

const x2 = combo['test-bar'];  // 'b' | 'c'
>x2 : "b" | "c"
>combo['test-bar'] : "b" | "c"
>combo : { [x: `foo-${string}`]: "a" | "b"; } & { [x: `${string}-bar`]: "b" | "c"; }
>'test-bar' : "test-bar"

const x3 = combo['foo-test-bar'];  // 'b' (('a' | 'b') & ('b' | 'c'))
>x3 : "b"
>combo['foo-test-bar'] : "b"
>combo : { [x: `foo-${string}`]: "a" | "b"; } & { [x: `${string}-bar`]: "b" | "c"; }
>'foo-test-bar' : "foo-test-bar"

// Property access on template pattern index signature

declare let dom: { [x: `data${string}`]: string };
>dom : { [x: `data${string}`]: string; }
>x : `data${string}`

const y1 = dom['data123'];
>y1 : string
>dom['data123'] : string
>dom : { [x: `data${string}`]: string; }
>'data123' : "data123"

const y2 = dom.data123;
>y2 : string
>dom.data123 : string
>dom : { [x: `data${string}`]: string; }
>data123 : string

// Excess property checking for template pattern index signature

dom = { data123: 'hello' };
>dom = { data123: 'hello' } : { data123: string; }
>dom : { [x: `data${string}`]: string; }
>{ data123: 'hello' } : { data123: string; }
>data123 : string
>'hello' : "hello"

dom = { date123: 'hello' };  // Error
>dom = { date123: 'hello' } : { date123: string; }
>dom : { [x: `data${string}`]: string; }
>{ date123: 'hello' } : { date123: string; }
>date123 : string
>'hello' : "hello"

// Contextual typing by index signature with template literal pattern

type Funcs = {
>Funcs : Funcs

    [key: `s${string}`]: (x: string) => void,
>key : `s${string}`
>x : string

    [key: `n${string}`]: (x: number) => void,
>key : `n${string}`
>x : number
}

const funcs: Funcs = {
>funcs : Funcs
>{    sfoo: x => x.length,  // x: string    nfoo: x => x * 2,     // n: number} : { sfoo: (x: string) => number; nfoo: (x: number) => number; }

    sfoo: x => x.length,  // x: string
>sfoo : (x: string) => number
>x => x.length : (x: string) => number
>x : string
>x.length : number
>x : string
>length : number

    nfoo: x => x * 2,     // n: number
>nfoo : (x: number) => number
>x => x * 2 : (x: number) => number
>x : number
>x * 2 : number
>x : number
>2 : 2
}

// Duplicate index signature checking

type Duplicates = {
>Duplicates : Duplicates

    [key: string | number]: any;  // Error
>key : string | number

    [key: number | symbol]: any;  // Error
>key : number | symbol

    [key: symbol | `foo${string}`]: any;  // Error
>key : symbol | `foo${string}`

    [key: `foo${string}`]: any;  // Error
>key : `foo${string}`
}

// Conflicting index signature checking

type Conflicting = {
>Conflicting : Conflicting

    [key: `a${string}`]: 'a';
>key : `a${string}`

    [key: `${string}a`]: 'b';
>key : `${string}a`

    [key: `a${string}a`]: 'c';  // Error
>key : `a${string}a`
}

// Invalid index signatures

type Invalid<T extends string> = {
>Invalid : Invalid<T>

    [key: 'a' | 'b' | 'c']: string;  // Error
>key : "a" | "b" | "c"

    [key: T | number]: string;  // Error
>key : number | T

    [key: Error]: string;  // Error
>key : Error
}

// Repros from #1863

const system = Symbol('system');
>system : unique symbol
>Symbol('system') : unique symbol
>Symbol : SymbolConstructor
>'system' : "system"

const SomeSytePlugin = Symbol('SomeSytePlugin');
>SomeSytePlugin : unique symbol
>Symbol('SomeSytePlugin') : unique symbol
>Symbol : SymbolConstructor
>'SomeSytePlugin' : "SomeSytePlugin"

interface Plugs {
    [key: symbol]: (...args: any) => unknown;
>key : symbol
>args : any
}

const plugins = {
>plugins : { user: Plugs; [system]: Plugs; }
>{    "user": {} as Plugs,    [system]: {} as Plugs} : { user: Plugs; [system]: Plugs; }

    "user": {} as Plugs,
>"user" : Plugs
>{} as Plugs : Plugs
>{} : {}

    [system]: {} as Plugs
>[system] : Plugs
>system : unique symbol
>{} as Plugs : Plugs
>{} : {}

};

plugins[system][SomeSytePlugin] = () => console.log('awsome');
>plugins[system][SomeSytePlugin] = () => console.log('awsome') : () => void
>plugins[system][SomeSytePlugin] : (...args: any) => unknown
>plugins[system] : Plugs
>plugins : { user: Plugs; [system]: Plugs; }
>system : unique symbol
>SomeSytePlugin : unique symbol
>() => console.log('awsome') : () => void
>console.log('awsome') : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>'awsome' : "awsome"

plugins[system][SomeSytePlugin]();
>plugins[system][SomeSytePlugin]() : unknown
>plugins[system][SomeSytePlugin] : (...args: any) => unknown
>plugins[system] : Plugs
>plugins : { user: Plugs; [system]: Plugs; }
>system : unique symbol
>SomeSytePlugin : unique symbol

var theAnswer: symbol = Symbol('secret');
>theAnswer : symbol
>Symbol('secret') : symbol
>Symbol : SymbolConstructor
>'secret' : "secret"

var obj = {} as Record<symbol, number>;
>obj : Record<symbol, number>
>{} as Record<symbol, number> : Record<symbol, number>
>{} : {}

obj[theAnswer] = 42;
>obj[theAnswer] = 42 : 42
>obj[theAnswer] : number
>obj : Record<symbol, number>
>theAnswer : symbol
>42 : 42

// Repro from #26470

const directive = Symbol('directive');
>directive : unique symbol
>Symbol('directive') : unique symbol
>Symbol : SymbolConstructor
>'directive' : "directive"

declare function foo<TArg, TRet, TDir>(options: { [x in string]: (arg: TArg) => TRet } & { [directive]?: TDir }): void;
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => void
>options : { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }
>arg : TArg
>[directive] : TDir | undefined
>directive : unique symbol

let case1 = foo({
>case1 : void
>foo({    [directive]: (x: string) => 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,}) : void
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => void
>{    [directive]: (x: string) => 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,} : { [directive]: (x: string) => "str"; addOne: (x: number) => number; double: (x: number) => number; }

    [directive]: (x: string) => 'str',
>[directive] : (x: string) => "str"
>directive : unique symbol
>(x: string) => 'str' : (x: string) => "str"
>x : string
>'str' : "str"

    addOne: (x: number) => x + 1,
>addOne : (x: number) => number
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    double: (x: number) => x + x,
>double : (x: number) => number
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

});

let case2 = foo({
>case2 : void
>foo({    addOne: (x: number) => x + 1,    double: (x: number) => x + x,    [directive]: (x: string) => 'str',}) : void
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => void
>{    addOne: (x: number) => x + 1,    double: (x: number) => x + x,    [directive]: (x: string) => 'str',} : { addOne: (x: number) => number; double: (x: number) => number; [directive]: (x: string) => "str"; }

    addOne: (x: number) => x + 1,
>addOne : (x: number) => number
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    double: (x: number) => x + x,
>double : (x: number) => number
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

    [directive]: (x: string) => 'str',
>[directive] : (x: string) => "str"
>directive : unique symbol
>(x: string) => 'str' : (x: string) => "str"
>x : string
>'str' : "str"

});

let case3 = foo({
>case3 : void
>foo({    [directive]: 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,}) : void
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => void
>{    [directive]: 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,} : { [directive]: string; addOne: (x: number) => number; double: (x: number) => number; }

    [directive]: 'str',
>[directive] : string
>directive : unique symbol
>'str' : "str"

    addOne: (x: number) => x + 1,
>addOne : (x: number) => number
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    double: (x: number) => x + x,
>double : (x: number) => number
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

});

// Repros from #42192

type Pseudo = `&:${string}`;
>Pseudo : `&:${string}`

const AmIPseudo1: Pseudo = '&:test';
>AmIPseudo1 : `&:${string}`
>'&:test' : "&:test"

const AmIPseudo: Pseudo = '&';  // Error
>AmIPseudo : `&:${string}`
>'&' : "&"

type PseudoDeclaration = { [key in Pseudo]: string };
>PseudoDeclaration : PseudoDeclaration

const test: PseudoDeclaration = { 'someKey' : 'someValue' };  // Error
>test : PseudoDeclaration
>{ 'someKey' : 'someValue' } : { someKey: string; }
>'someKey' : string
>'someValue' : "someValue"

type FieldPattern = `/${string}`;
>FieldPattern : `/${string}`

const path1: FieldPattern = '/one';
>path1 : `/${string}`
>'/one' : "/one"

const path2: FieldPattern = 'two';  // Error
>path2 : `/${string}`
>'two' : "two"

type PathsObject = { [P in FieldPattern]: object; };
>PathsObject : PathsObject

const pathObject: PathsObject = 123;  // Error
>pathObject : PathsObject
>123 : 123

type IdType = `${number}-${number}-${number}-${number}`
>IdType : `${number}-${number}-${number}-${number}`

const id: IdType = '0000-0000-0000-0001';
>id : `${number}-${number}-${number}-${number}`
>'0000-0000-0000-0001' : "0000-0000-0000-0001"

type A = Record<IdType, string>;
>A : A

const a: A = { [id]: 'test' }
>a : A
>{ [id]: 'test' } : { [x: string]: string; }
>[id] : string
>id : `${number}-${number}-${number}-${number}`
>'test' : "test"

let aid = a[id];
>aid : string
>a[id] : string
>a : A
>id : `${number}-${number}-${number}-${number}`

