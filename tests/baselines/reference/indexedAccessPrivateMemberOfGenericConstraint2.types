//// [tests/cases/compiler/indexedAccessPrivateMemberOfGenericConstraint2.ts] ////

=== indexedAccessPrivateMemberOfGenericConstraint2.ts ===
class A {
>A : A
>  : ^

  declare private a: { foo: number };
>a : { foo: number; }
>  : ^^^^^^^      ^^^
>foo : number
>    : ^^^^^^
}

class B {
>B : B
>  : ^

  declare private a: { bar: string };
>a : { bar: string; }
>  : ^^^^^^^      ^^^
>bar : string
>    : ^^^^^^
}

type X<T extends A> = [T["a"], (T | B)["a"]];
>X : X<T>
>  : ^^^^

type Y<T extends A | B> = T["a"];
>Y : any
>  : ^^^

type Z<T extends A & B> = T["a"];
>Z : any
>  : ^^^

type R<T extends A, T2 extends B> = (T | T2)["a"];
>R : any
>  : ^^^

type S<T extends B, T2 extends A> = (T | T2)["a"];
>S : any
>  : ^^^

type U<T extends A> = (T & B)["a"];
>U : any
>  : ^^^

type V<T extends A, T2 extends B> = (T & T2)["a"];
>V : any
>  : ^^^

type W<T extends B, T2 extends A> = (T & T2)["a"];
>W : any
>  : ^^^

class C {
>C : C
>  : ^

  declare private a: { foo: number };
>a : { foo: number; }
>  : ^^^^^^^      ^^^
>foo : number
>    : ^^^^^^
}

class D {
>D : D
>  : ^

  declare a: { bar: string };
>a : { bar: string; }
>  : ^^^^^^^      ^^^
>bar : string
>    : ^^^^^^
}

type X2<T extends C> = [T["a"], (T | D)["a"]];
>X2 : X2<T>
>   : ^^^^^

type Y2<T extends C | D> = T["a"];
>Y2 : any
>   : ^^^

type Z2<T extends C & D> = T["a"];
>Z2 : any
>   : ^^^

type R2<T extends C, T2 extends D> = (T | T2)["a"];
>R2 : any
>   : ^^^

type S2<T extends D, T2 extends C> = (T | T2)["a"];
>S2 : any
>   : ^^^

type U2<T extends C> = (T & D)["a"];
>U2 : any
>   : ^^^

type V2<T extends C, T2 extends D> = (T & T2)["a"];
>V2 : any
>   : ^^^

type W2<T extends D, T2 extends C> = (T & T2)["a"];
>W2 : any
>   : ^^^

class E {
>E : E
>  : ^

  declare a: { foo: number };
>a : { foo: number; }
>  : ^^^^^^^      ^^^
>foo : number
>    : ^^^^^^
}

class F {
>F : F
>  : ^

  declare private a: { bar: string };
>a : { bar: string; }
>  : ^^^^^^^      ^^^
>bar : string
>    : ^^^^^^
}

type X3<T extends E> = [T["a"], (T | F)["a"]];
>X3 : X3<T>
>   : ^^^^^

type Y3<T extends E | F> = T["a"];
>Y3 : any
>   : ^^^

type Z3<T extends E & F> = T["a"];
>Z3 : any
>   : ^^^

type R3<T extends E, T2 extends F> = (T | T2)["a"];
>R3 : any
>   : ^^^

type S3<T extends F, T2 extends E> = (T | T2)["a"];
>S3 : any
>   : ^^^

type U3<T extends E> = (T & F)["a"];
>U3 : any
>   : ^^^

type V3<T extends E, T2 extends F> = (T & T2)["a"];
>V3 : any
>   : ^^^

type W3<T extends F, T2 extends E> = (T & T2)["a"];
>W3 : any
>   : ^^^

class G {
>G : G
>  : ^

  declare b: { foo: number };
>b : { foo: number; }
>  : ^^^^^^^      ^^^
>foo : number
>    : ^^^^^^
}

class H {
>H : H
>  : ^

  declare private a: { bar: string };
>a : { bar: string; }
>  : ^^^^^^^      ^^^
>bar : string
>    : ^^^^^^
}

type X4<T extends G> = [T["a"], (T | H)["a"]];
>X4 : X4<T>
>   : ^^^^^

type Y4<T extends G | H> = T["a"];
>Y4 : any
>   : ^^^

type Z4<T extends G & H> = T["a"];
>Z4 : any
>   : ^^^

type R4<T extends G, T2 extends H> = (T | T2)["a"];
>R4 : any
>   : ^^^

type S4<T extends H, T2 extends G> = (T | T2)["a"];
>S4 : any
>   : ^^^

type U4<T extends G> = (T & H)["a"];
>U4 : any
>   : ^^^

type V4<T extends G, T2 extends H> = (T & T2)["a"];
>V4 : any
>   : ^^^

type W4<T extends H, T2 extends G> = (T & T2)["a"];
>W4 : any
>   : ^^^

