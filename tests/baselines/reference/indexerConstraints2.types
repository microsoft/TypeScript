=== tests/cases/compiler/indexerConstraints2.ts ===
class A { a: number; }
>A : A
>a : number

class B extends A { b: number; }
>B : B
>A : A
>b : number

// Inheritance
class F {
>F : F

    [s: string]: B
>s : string
}
class G extends F {
>G : G
>F : F

    [n: number]: A
>n : number
}

// Other way
class H {
>H : H

    [n: number]: A
>n : number
}
class I extends H {
>I : I
>H : H

    [s: string]: B
>s : string
}

// With hidden indexer
class J {
>J : J

    [n: number]: {}
>n : number
}

class K extends J {
>K : K
>J : J

    [n: number]: A;
>n : number

    [s: string]: B;
>s : string
}


type AliasedNumber = number;
>AliasedNumber : number

interface L {
    [n: AliasedNumber]: A;
>n : number
}

type AliasedString = string;
>AliasedString : string

interface M {
    [s: AliasedString]: A;
>s : string
}

type AliasedBoolean = boolean;
>AliasedBoolean : boolean

interface N {
    [b: AliasedBoolean]: A;
>b : boolean
}

type IndexableUnion = "foo" | "bar";
>IndexableUnion : IndexableUnion

interface O {
    [u: IndexableUnion]: A;
>u : IndexableUnion
}

type NonIndexableUnion = boolean | {};
>NonIndexableUnion : NonIndexableUnion

interface P {
    [u: NonIndexableUnion]: A;
>u : NonIndexableUnion
}

type NonIndexableUnion2 = string | number;
>NonIndexableUnion2 : NonIndexableUnion2

interface Q {
    [u: NonIndexableUnion2]: A;
>u : NonIndexableUnion2
}

type NonIndexableUnion3 = "foo" | 42;
>NonIndexableUnion3 : NonIndexableUnion3

interface R {
    [u: NonIndexableUnion3]: A;
>u : NonIndexableUnion3
}

interface S {
    [u: "foo" | "bar"]: A;
>u : "foo" | "bar"
}

type Key = string;
>Key : string

interface T {
    [key: Key]
>key : string
}

