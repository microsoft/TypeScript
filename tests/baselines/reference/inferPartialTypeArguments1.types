=== tests/cases/conformance/types/typeParameters/inferPartialTypeArguments1.tsx ===
declare module JSX {
    interface Element {}
}
declare namespace React {
>React : typeof React

    export function createElement(x: any, p: any, ...children: any[]): JSX.Element;
>createElement : (x: any, p: any, ...children: any[]) => JSX.Element
>x : any
>p : any
>children : any[]
>JSX : any
}
 class Foo<T, U> {
>Foo : Foo<T, U>

    constructor(public prop1: T, public prop2: U) {}
>prop1 : T
>prop2 : U
}
 function foo<T, U>(x: T, y: U): [T, U] { return [x, y]; }
>foo : <T, U>(x: T, y: U) => [T, U]
>x : T
>y : U
>[x, y] : [T, U]
>x : T
>y : U

 function tag<T, U>(x: TemplateStringsArray, ...args: (T | U)[]) { return args; }
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>x : TemplateStringsArray
>args : (T | U)[]
>args : (T | U)[]

 interface ComponentProps<T, U> {
    x: T;
>x : T

    y: U;
>y : U

    cb(props: this): void;
>cb : (props: this) => void
>props : this
}
 function Component<T, U>(x: ComponentProps<T, U>) {
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : ComponentProps<T, U>

    return <h></h>;
><h></h> : JSX.Element
>h : any
>h : any
}

const instance1 = new Foo<number,>(0, "");
>instance1 : Foo<number, string>
>new Foo<number,>(0, "") : Foo<number, string>
>Foo : typeof Foo
>0 : 0
>"" : ""

const result1 = foo<number,>(0, "");
>result1 : [number, string]
>foo<number,>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>0 : 0
>"" : ""

// const tagged1 = tag<number, _>`tags ${12} ${""}`; // Because of how union inference works, this won't actually work
const jsx1 = <Component<number,> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx1 : JSX.Element
><Component<number,> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

const instance2 = new Foo<, string>(0, "");
>instance2 : Foo<number, string>
>new Foo<, string>(0, "") : Foo<number, string>
>Foo : typeof Foo
>0 : 0
>"" : ""

const result2 = foo<, string>(0, "");
>result2 : [number, string]
>foo<, string>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>0 : 0
>"" : ""

const tagged2 = tag<, string>`tags ${12} ${""}`; // this will, though! Just because the `*` comes first!
>tagged2 : (string | number)[]
>tag<, string>`tags ${12} ${""}` : (string | number)[]
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx2 = <Component<, string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx2 : JSX.Element
><Component<, string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

const instance3 = new Foo<,>(0, "");
>instance3 : Foo<number, string>
>new Foo<,>(0, "") : Foo<number, string>
>Foo : typeof Foo
>0 : 0
>"" : ""

const result3 = foo<,>(0, "");
>result3 : [number, string]
>foo<,>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>0 : 0
>"" : ""

const tagged3 = tag<,>`tags ${12} ${""}`;
>tagged3 : unknown[]
>tag<,>`tags ${12} ${""}` : unknown[]
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx3 = <Component<,> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx3 : JSX.Element
><Component<,> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

// with trailing comma
const instance4 = new Foo<,,>(0, "");
>instance4 : Foo<number, string>
>new Foo<,,>(0, "") : Foo<number, string>
>Foo : typeof Foo
>0 : 0
>"" : ""

const result4 = foo<,,>(0, "");
>result4 : [number, string]
>foo<,,>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>0 : 0
>"" : ""

const tagged4 = tag<,,>`tags ${12} ${""}`;
>tagged4 : ?[]
>tag<,,>`tags ${12} ${""}` : ?[]
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx4 = <Component<,,> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx4 : JSX.Element
><Component<,,> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

declare function stillDefaultsIfNoInference<X, A = string, B = number, C = boolean>(arg: { a?: A, b?: B, c?: C, x?: X}): { a: A, b: B, c: C, x: X };
>stillDefaultsIfNoInference : <X, A = string, B = number, C = boolean>(arg: {    a?: A;    b?: B;    c?: C;    x?: X;}) => {    a: A;    b: B;    c: C;    x: X;}
>arg : { a?: A; b?: B; c?: C; x?: X; }
>a : A
>b : B
>c : C
>x : X
>a : A
>b : B
>c : C
>x : X

const result5 = stillDefaultsIfNoInference<, , , object> ({ b: "test" }); // expect result1 type is {a: string, b: string, c: object, x: {}
>result5 : { a: string; b: string; c: object; x: unknown; }
>stillDefaultsIfNoInference<, , , object> ({ b: "test" }) : { a: string; b: string; c: object; x: unknown; }
>stillDefaultsIfNoInference : <X, A = string, B = number, C = boolean>(arg: { a?: A; b?: B; c?: C; x?: X; }) => { a: A; b: B; c: C; x: X; }
>{ b: "test" } : { b: string; }
>b : string
>"test" : "test"

class Foo2<A extends {x: string} = {x: string, y: number}, B = number> {
>Foo2 : Foo2<A, B>
>x : string
>x : string
>y : number

    constructor(public a?: A, public b?: B) {}
>a : A
>b : B
}
const x = new Foo2<, string>();
>x : Foo2<{ x: string; y: number; }, string>
>new Foo2<, string>() : Foo2<{ x: string; y: number; }, string>
>Foo2 : typeof Foo2

x.a.x;
>x.a.x : string
>x.a : { x: string; y: number; }
>x : Foo2<{ x: string; y: number; }, string>
>a : { x: string; y: number; }
>x : string

x.a.y;
>x.a.y : number
>x.a : { x: string; y: number; }
>x : Foo2<{ x: string; y: number; }, string>
>a : { x: string; y: number; }
>y : number

x.b;
>x.b : string
>x : Foo2<{ x: string; y: number; }, string>
>b : string

