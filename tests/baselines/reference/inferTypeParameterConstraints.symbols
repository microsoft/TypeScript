//// [tests/cases/compiler/inferTypeParameterConstraints.ts] ////

=== inferTypeParameterConstraints.ts ===
// Repro from #42636

type SubGuard<A, X extends [A]> = X;
>SubGuard : Symbol(SubGuard, Decl(inferTypeParameterConstraints.ts, 0, 0))
>A : Symbol(A, Decl(inferTypeParameterConstraints.ts, 2, 14))
>X : Symbol(X, Decl(inferTypeParameterConstraints.ts, 2, 16))
>A : Symbol(A, Decl(inferTypeParameterConstraints.ts, 2, 14))
>X : Symbol(X, Decl(inferTypeParameterConstraints.ts, 2, 16))

type IsSub<M extends any[], S extends any[]> = M extends [...SubGuard<M[number], infer B>, ...S, ...any[]] ? B : never;
>IsSub : Symbol(IsSub, Decl(inferTypeParameterConstraints.ts, 2, 36))
>M : Symbol(M, Decl(inferTypeParameterConstraints.ts, 4, 11))
>S : Symbol(S, Decl(inferTypeParameterConstraints.ts, 4, 27))
>M : Symbol(M, Decl(inferTypeParameterConstraints.ts, 4, 11))
>SubGuard : Symbol(SubGuard, Decl(inferTypeParameterConstraints.ts, 0, 0))
>M : Symbol(M, Decl(inferTypeParameterConstraints.ts, 4, 11))
>B : Symbol(B, Decl(inferTypeParameterConstraints.ts, 4, 86))
>S : Symbol(S, Decl(inferTypeParameterConstraints.ts, 4, 27))
>B : Symbol(B, Decl(inferTypeParameterConstraints.ts, 4, 86))

type E0 = IsSub<[1, 2, 3, 4], [2, 3, 4]>;  // [1 | 2 | 3 | 4]
>E0 : Symbol(E0, Decl(inferTypeParameterConstraints.ts, 4, 119))
>IsSub : Symbol(IsSub, Decl(inferTypeParameterConstraints.ts, 2, 36))

type E1 = [1, 2, 3, 4] extends [...infer B, 2, 3, 4, ...any[]] ? B : never;  // unknown[]
>E1 : Symbol(E1, Decl(inferTypeParameterConstraints.ts, 6, 41))
>B : Symbol(B, Decl(inferTypeParameterConstraints.ts, 8, 40))
>B : Symbol(B, Decl(inferTypeParameterConstraints.ts, 8, 40))

// Repro from #42636

type Constrain<T extends C, C> = unknown;
>Constrain : Symbol(Constrain, Decl(inferTypeParameterConstraints.ts, 8, 75))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 12, 15))
>C : Symbol(C, Decl(inferTypeParameterConstraints.ts, 12, 27))
>C : Symbol(C, Decl(inferTypeParameterConstraints.ts, 12, 27))

type Foo<A> = A extends Constrain<infer X, A> ? X : never;
>Foo : Symbol(Foo, Decl(inferTypeParameterConstraints.ts, 12, 41))
>A : Symbol(A, Decl(inferTypeParameterConstraints.ts, 14, 9))
>A : Symbol(A, Decl(inferTypeParameterConstraints.ts, 14, 9))
>Constrain : Symbol(Constrain, Decl(inferTypeParameterConstraints.ts, 8, 75))
>X : Symbol(X, Decl(inferTypeParameterConstraints.ts, 14, 39))
>A : Symbol(A, Decl(inferTypeParameterConstraints.ts, 14, 9))
>X : Symbol(X, Decl(inferTypeParameterConstraints.ts, 14, 39))

type T0 = Foo<string>;  // string
>T0 : Symbol(T0, Decl(inferTypeParameterConstraints.ts, 14, 58))
>Foo : Symbol(Foo, Decl(inferTypeParameterConstraints.ts, 12, 41))

// https://github.com/microsoft/TypeScript/issues/57286#issuecomment-1927920336

class BaseClass<V> {
>BaseClass : Symbol(BaseClass, Decl(inferTypeParameterConstraints.ts, 16, 22))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 20, 16))

  protected fake(): V {
>fake : Symbol(BaseClass.fake, Decl(inferTypeParameterConstraints.ts, 20, 20))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 20, 16))

    throw new Error("");
>Error : Symbol(Error, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
  }
}

class Klass<V> extends BaseClass<V> {
>Klass : Symbol(Klass, Decl(inferTypeParameterConstraints.ts, 24, 1))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 26, 12))
>BaseClass : Symbol(BaseClass, Decl(inferTypeParameterConstraints.ts, 16, 22))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 26, 12))

  child = true;
>child : Symbol(Klass.child, Decl(inferTypeParameterConstraints.ts, 26, 37))
}

type Constructor<V, P extends BaseClass<V>> = new () => P;
>Constructor : Symbol(Constructor, Decl(inferTypeParameterConstraints.ts, 28, 1))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 30, 17))
>P : Symbol(P, Decl(inferTypeParameterConstraints.ts, 30, 19))
>BaseClass : Symbol(BaseClass, Decl(inferTypeParameterConstraints.ts, 16, 22))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 30, 17))
>P : Symbol(P, Decl(inferTypeParameterConstraints.ts, 30, 19))

type inferTest<V, T> = T extends Constructor<V, infer P> ? P : never;
>inferTest : Symbol(inferTest, Decl(inferTypeParameterConstraints.ts, 30, 58))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 31, 15))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 31, 17))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 31, 17))
>Constructor : Symbol(Constructor, Decl(inferTypeParameterConstraints.ts, 28, 1))
>V : Symbol(V, Decl(inferTypeParameterConstraints.ts, 31, 15))
>P : Symbol(P, Decl(inferTypeParameterConstraints.ts, 31, 53))
>P : Symbol(P, Decl(inferTypeParameterConstraints.ts, 31, 53))

type U = inferTest<number, Constructor<number, Klass<number>>>;
>U : Symbol(U, Decl(inferTypeParameterConstraints.ts, 31, 69))
>inferTest : Symbol(inferTest, Decl(inferTypeParameterConstraints.ts, 30, 58))
>Constructor : Symbol(Constructor, Decl(inferTypeParameterConstraints.ts, 28, 1))
>Klass : Symbol(Klass, Decl(inferTypeParameterConstraints.ts, 24, 1))

declare let m: U;
>m : Symbol(m, Decl(inferTypeParameterConstraints.ts, 35, 11))
>U : Symbol(U, Decl(inferTypeParameterConstraints.ts, 31, 69))

m.child; // ok
>m.child : Symbol(Klass.child, Decl(inferTypeParameterConstraints.ts, 26, 37))
>m : Symbol(m, Decl(inferTypeParameterConstraints.ts, 35, 11))
>child : Symbol(Klass.child, Decl(inferTypeParameterConstraints.ts, 26, 37))

// https://github.com/microsoft/TypeScript/issues/60299

type Data = [a: 1, b: 2, ...c: 3[]];
>Data : Symbol(Data, Decl(inferTypeParameterConstraints.ts, 36, 8))

type TestType1<T extends any[]> = T extends [
>TestType1 : Symbol(TestType1, Decl(inferTypeParameterConstraints.ts, 40, 36))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 42, 15))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 42, 15))

  ...infer R extends [any, any],
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 43, 10))

  ...any[],
]
  ? R
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 43, 10))

  : never;
type test1 = TestType1<Data>;
>test1 : Symbol(test1, Decl(inferTypeParameterConstraints.ts, 47, 10))
>TestType1 : Symbol(TestType1, Decl(inferTypeParameterConstraints.ts, 40, 36))
>Data : Symbol(Data, Decl(inferTypeParameterConstraints.ts, 36, 8))

type TestType2<T extends any[], Mask extends any[] = [any, any]> = T extends [
>TestType2 : Symbol(TestType2, Decl(inferTypeParameterConstraints.ts, 48, 29))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 50, 15))
>Mask : Symbol(Mask, Decl(inferTypeParameterConstraints.ts, 50, 31))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 50, 15))

  ...infer R extends Mask,
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 51, 10))
>Mask : Symbol(Mask, Decl(inferTypeParameterConstraints.ts, 50, 31))

  ...any[],
]
  ? R
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 51, 10))

  : never;
type test2 = TestType2<Data>;
>test2 : Symbol(test2, Decl(inferTypeParameterConstraints.ts, 55, 10))
>TestType2 : Symbol(TestType2, Decl(inferTypeParameterConstraints.ts, 48, 29))
>Data : Symbol(Data, Decl(inferTypeParameterConstraints.ts, 36, 8))

type ExcludeRest<T extends any[]> = Inner<T>;
>ExcludeRest : Symbol(ExcludeRest, Decl(inferTypeParameterConstraints.ts, 56, 29))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 58, 17))
>Inner : Symbol(Inner, Decl(inferTypeParameterConstraints.ts, 58, 45))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 58, 17))

type Inner<
>Inner : Symbol(Inner, Decl(inferTypeParameterConstraints.ts, 58, 45))

  T extends any[],
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 60, 11))

  Copy extends any[] = T,
>Copy : Symbol(Copy, Decl(inferTypeParameterConstraints.ts, 61, 18))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 60, 11))

  Mask extends any[] = [],
>Mask : Symbol(Mask, Decl(inferTypeParameterConstraints.ts, 62, 25))

> = Copy extends [any, ...infer Rest]
>Copy : Symbol(Copy, Decl(inferTypeParameterConstraints.ts, 61, 18))
>Rest : Symbol(Rest, Decl(inferTypeParameterConstraints.ts, 64, 31))

  ? Inner<T, Rest, [...Mask, any]>
>Inner : Symbol(Inner, Decl(inferTypeParameterConstraints.ts, 58, 45))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 60, 11))
>Rest : Symbol(Rest, Decl(inferTypeParameterConstraints.ts, 64, 31))
>Mask : Symbol(Mask, Decl(inferTypeParameterConstraints.ts, 62, 25))

  : Required<Copy> extends [any, ...infer Rest]
>Required : Symbol(Required, Decl(lib.es5.d.ts, --, --))
>Copy : Symbol(Copy, Decl(inferTypeParameterConstraints.ts, 61, 18))
>Rest : Symbol(Rest, Decl(inferTypeParameterConstraints.ts, 66, 41))

  ? Inner<T, Rest, [...Mask, any?]>
>Inner : Symbol(Inner, Decl(inferTypeParameterConstraints.ts, 58, 45))
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 60, 11))
>Rest : Symbol(Rest, Decl(inferTypeParameterConstraints.ts, 66, 41))
>Mask : Symbol(Mask, Decl(inferTypeParameterConstraints.ts, 62, 25))

  : T extends [...infer Result extends Mask, ...any[]]
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 60, 11))
>Result : Symbol(Result, Decl(inferTypeParameterConstraints.ts, 68, 23))
>Mask : Symbol(Mask, Decl(inferTypeParameterConstraints.ts, 62, 25))

  ? Result
>Result : Symbol(Result, Decl(inferTypeParameterConstraints.ts, 68, 23))

  : never;

type test3 = ExcludeRest<[a: 1, b: 2, c?: 3, ...d: 4[]]>;
>test3 : Symbol(test3, Decl(inferTypeParameterConstraints.ts, 70, 10))
>ExcludeRest : Symbol(ExcludeRest, Decl(inferTypeParameterConstraints.ts, 56, 29))

type Interpolable = string | number | bigint | boolean | null | undefined;
>Interpolable : Symbol(Interpolable, Decl(inferTypeParameterConstraints.ts, 72, 57))

type TestWithInterpolable1<
>TestWithInterpolable1 : Symbol(TestWithInterpolable1, Decl(inferTypeParameterConstraints.ts, 74, 74))

  T extends string,
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 76, 27))

  TOutput extends Interpolable = number,
>TOutput : Symbol(TOutput, Decl(inferTypeParameterConstraints.ts, 77, 19))
>Interpolable : Symbol(Interpolable, Decl(inferTypeParameterConstraints.ts, 72, 57))

> = T extends `${infer R extends TOutput}` ? R : never;
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 76, 27))
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 79, 22))
>TOutput : Symbol(TOutput, Decl(inferTypeParameterConstraints.ts, 77, 19))
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 79, 22))

type ResultWithInterpolable1 = TestWithInterpolable1<`100`>;
>ResultWithInterpolable1 : Symbol(ResultWithInterpolable1, Decl(inferTypeParameterConstraints.ts, 79, 55))
>TestWithInterpolable1 : Symbol(TestWithInterpolable1, Decl(inferTypeParameterConstraints.ts, 74, 74))

type TestWithInterpolable2<
>TestWithInterpolable2 : Symbol(TestWithInterpolable2, Decl(inferTypeParameterConstraints.ts, 81, 60))

  T extends string,
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 83, 27))

  TOutput extends Interpolable,
>TOutput : Symbol(TOutput, Decl(inferTypeParameterConstraints.ts, 84, 19))
>Interpolable : Symbol(Interpolable, Decl(inferTypeParameterConstraints.ts, 72, 57))

> = T extends `${infer R extends TOutput}` ? R : never;
>T : Symbol(T, Decl(inferTypeParameterConstraints.ts, 83, 27))
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 86, 22))
>TOutput : Symbol(TOutput, Decl(inferTypeParameterConstraints.ts, 84, 19))
>R : Symbol(R, Decl(inferTypeParameterConstraints.ts, 86, 22))

type ResultWithInterpolable2 = TestWithInterpolable2<`100`, number>;
>ResultWithInterpolable2 : Symbol(ResultWithInterpolable2, Decl(inferTypeParameterConstraints.ts, 86, 55))
>TestWithInterpolable2 : Symbol(TestWithInterpolable2, Decl(inferTypeParameterConstraints.ts, 81, 60))

