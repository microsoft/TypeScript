//// [tests/cases/compiler/inferTypeParameterConstraints.ts] ////

=== inferTypeParameterConstraints.ts ===
// Repro from #42636

type SubGuard<A, X extends [A]> = X;
>SubGuard : X
>         : ^

type IsSub<M extends any[], S extends any[]> = M extends [...SubGuard<M[number], infer B>, ...S, ...any[]] ? B : never;
>IsSub : IsSub<M, S>
>      : ^^^^^^^^^^^

type E0 = IsSub<[1, 2, 3, 4], [2, 3, 4]>;  // [1 | 2 | 3 | 4]
>E0 : [1 | 4 | 2 | 3]
>   : ^^^^^^^^^^^^^^^

type E1 = [1, 2, 3, 4] extends [...infer B, 2, 3, 4, ...any[]] ? B : never;  // unknown[]
>E1 : unknown[]
>   : ^^^^^^^^^

// Repro from #42636

type Constrain<T extends C, C> = unknown;
>Constrain : unknown
>          : ^^^^^^^

type Foo<A> = A extends Constrain<infer X, A> ? X : never;
>Foo : Foo<A>
>    : ^^^^^^

type T0 = Foo<string>;  // string
>T0 : string
>   : ^^^^^^

// https://github.com/microsoft/TypeScript/issues/57286#issuecomment-1927920336

class BaseClass<V> {
>BaseClass : BaseClass<V>
>          : ^^^^^^^^^^^^

  protected fake(): V {
>fake : () => V
>     : ^^^^^^ 

    throw new Error("");
>new Error("") : Error
>              : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"" : ""
>   : ^^
  }
}

class Klass<V> extends BaseClass<V> {
>Klass : Klass<V>
>      : ^^^^^^^^
>BaseClass : BaseClass<V>
>          : ^^^^^^^^^^^^

  child = true;
>child : boolean
>      : ^^^^^^^
>true : true
>     : ^^^^
}

type Constructor<V, P extends BaseClass<V>> = new () => P;
>Constructor : Constructor<V, P>
>            : ^^^^^^^^^^^^^^^^^

type inferTest<V, T> = T extends Constructor<V, infer P> ? P : never;
>inferTest : inferTest<V, T>
>          : ^^^^^^^^^^^^^^^

type U = inferTest<number, Constructor<number, Klass<number>>>;
>U : Klass<number>
>  : ^^^^^^^^^^^^^

declare let m: U;
>m : Klass<number>
>  : ^^^^^^^^^^^^^

m.child; // ok
>m.child : boolean
>        : ^^^^^^^
>m : Klass<number>
>  : ^^^^^^^^^^^^^
>child : boolean
>      : ^^^^^^^

// https://github.com/microsoft/TypeScript/issues/60299

type Data = [a: 1, b: 2, ...c: 3[]];
>Data : Data
>     : ^^^^

type TestType1<T extends any[]> = T extends [
>TestType1 : TestType1<T>
>          : ^^^^^^^^^^^^

  ...infer R extends [any, any],
  ...any[],
]
  ? R
  : never;
type test1 = TestType1<Data>;
>test1 : [a: 1, b: 2]
>      : ^^^^^^^^^^^^

type TestType2<T extends any[], Mask extends any[] = [any, any]> = T extends [
>TestType2 : TestType2<T, Mask>
>          : ^^^^^^^^^^^^^^^^^^

  ...infer R extends Mask,
  ...any[],
]
  ? R
  : never;
type test2 = TestType2<Data>;
>test2 : [a: 1, b: 2]
>      : ^^^^^^^^^^^^

type ExcludeRest<T extends any[]> = Inner<T>;
>ExcludeRest : ExcludeRest<T>
>            : ^^^^^^^^^^^^^^

type Inner<
>Inner : Inner<T, Copy, Mask>
>      : ^^^^^^^^^^^^^^^^^^^^

  T extends any[],
  Copy extends any[] = T,
  Mask extends any[] = [],
> = Copy extends [any, ...infer Rest]
  ? Inner<T, Rest, [...Mask, any]>
  : Required<Copy> extends [any, ...infer Rest]
  ? Inner<T, Rest, [...Mask, any?]>
  : T extends [...infer Result extends Mask, ...any[]]
  ? Result
  : never;

type test3 = ExcludeRest<[a: 1, b: 2, c?: 3, ...d: 4[]]>;
>test3 : [a: 1, b: 2, c?: 3 | undefined]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

type Interpolable = string | number | bigint | boolean | null | undefined;
>Interpolable : Interpolable
>             : ^^^^^^^^^^^^

type TestWithInterpolable1<
>TestWithInterpolable1 : TestWithInterpolable1<T, TOutput>
>                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  T extends string,
  TOutput extends Interpolable = number,
> = T extends `${infer R extends TOutput}` ? R : never;

type ResultWithInterpolable1 = TestWithInterpolable1<`100`>;
>ResultWithInterpolable1 : 100
>                        : ^^^

type TestWithInterpolable2<
>TestWithInterpolable2 : TestWithInterpolable2<T, TOutput>
>                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  T extends string,
  TOutput extends Interpolable,
> = T extends `${infer R extends TOutput}` ? R : never;
type ResultWithInterpolable2 = TestWithInterpolable2<`100`, number>;
>ResultWithInterpolable2 : 100
>                        : ^^^

