//// [tests/cases/compiler/inferenceShouldFailOnEvolvingArrays.ts] ////

=== inferenceShouldFailOnEvolvingArrays.ts ===
// repro from https://github.com/Microsoft/TypeScript/issues/25675
// The type of `arg` blocks inference but simplifies to T.
function logLength<T extends string, U extends string>(arg: { [K in U]: T }[U]): T {
>logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
>          : ^ ^^^^^^^^^      ^^ ^^^^^^^^^      ^^   ^^                   ^^^^^ 
>arg : { [K in U]: T; }[U]
>    : ^^^ ^^^^^^^^^^^^^^^

    console.log(arg.length);
>console.log(arg.length) : void
>                        : ^^^^
>console.log : (...data: any[]) => void
>            : ^^^^    ^^     ^^^^^    
>console : Console
>        : ^^^^^^^
>log : (...data: any[]) => void
>    : ^^^^    ^^     ^^^^^    
>arg.length : number
>           : ^^^^^^
>arg : { [K in U]: T; }[U]
>    : ^^^ ^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^

    return arg;
>arg : { [K in U]: T; }[U]
>    : ^^^ ^^^^^^^^^^^^^^^
}
logLength(42);  // error
>logLength(42) : string
>              : ^^^^^^
>logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
>          : ^ ^^^^^^^^^      ^^ ^^^^^^^^^      ^^   ^^                   ^^^^^ 
>42 : 42
>   : ^^

let z;
>z : any
>  : ^^^

z = logLength(42);  // no error; T is inferred as `any`
>z = logLength(42) : string
>                  : ^^^^^^
>z : any
>  : ^^^
>logLength(42) : string
>              : ^^^^^^
>logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
>          : ^ ^^^^^^^^^      ^^ ^^^^^^^^^      ^^   ^^                   ^^^^^ 
>42 : 42
>   : ^^

function logFirstLength<T extends string[], U extends string>(arg: { [K in U]: T }[U]): T {
>logFirstLength : <T extends string[], U extends string>(arg: { [K in U]: T; }[U]) => T
>               : ^ ^^^^^^^^^        ^^ ^^^^^^^^^      ^^   ^^                   ^^^^^ 
>arg : { [K in U]: T; }[U]
>    : ^^^ ^^^^^^^^^^^^^^^

    console.log(arg[0].length);
>console.log(arg[0].length) : void
>                           : ^^^^
>console.log : (...data: any[]) => void
>            : ^^^^    ^^     ^^^^^    
>console : Console
>        : ^^^^^^^
>log : (...data: any[]) => void
>    : ^^^^    ^^     ^^^^^    
>arg[0].length : number
>              : ^^^^^^
>arg[0] : string
>       : ^^^^^^
>arg : { [K in U]: T; }[U]
>    : ^^^ ^^^^^^^^^^^^^^^
>0 : 0
>  : ^
>length : number
>       : ^^^^^^

    return arg;
>arg : { [K in U]: T; }[U]
>    : ^^^ ^^^^^^^^^^^^^^^
}
logFirstLength([42]);  // error
>logFirstLength([42]) : string[]
>                     : ^^^^^^^^
>logFirstLength : <T extends string[], U extends string>(arg: { [K in U]: T; }[U]) => T
>               : ^ ^^^^^^^^^        ^^ ^^^^^^^^^      ^^   ^^                   ^^^^^ 
>[42] : number[]
>     : ^^^^^^^^
>42 : 42
>   : ^^

let zz = [];
>zz : any[]
>   : ^^^^^
>[] : never[]
>   : ^^^^^^^

zz.push(logLength(42));  // no error; T is inferred as `any`
>zz.push(logLength(42)) : number
>                       : ^^^^^^
>zz.push : (...items: any[]) => number
>        : ^^^^     ^^^^^^^^^^^^      
>zz : any[]
>   : ^^^^^
>push : (...items: any[]) => number
>     : ^^^^     ^^^^^^^^^^^^      
>logLength(42) : string
>              : ^^^^^^
>logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
>          : ^ ^^^^^^^^^      ^^ ^^^^^^^^^      ^^   ^^                   ^^^^^ 
>42 : 42
>   : ^^

zz = logFirstLength([42]);  // no error; T is inferred as `any[]`
>zz = logFirstLength([42]) : string[]
>                          : ^^^^^^^^
>zz : any[]
>   : ^^^^^
>logFirstLength([42]) : string[]
>                     : ^^^^^^^^
>logFirstLength : <T extends string[], U extends string>(arg: { [K in U]: T; }[U]) => T
>               : ^ ^^^^^^^^^        ^^ ^^^^^^^^^      ^^   ^^                   ^^^^^ 
>[42] : number[]
>     : ^^^^^^^^
>42 : 42
>   : ^^

