//// [tests/cases/compiler/instanceAndStaticDeclarations1.ts] ////

=== instanceAndStaticDeclarations1.ts ===
// from spec

class Point {
>Point : Symbol(Point, Decl(instanceAndStaticDeclarations1.ts, 0, 0))

    constructor(public x: number, public y: number) { }
>x : Symbol(Point.x, Decl(instanceAndStaticDeclarations1.ts, 3, 16))
>y : Symbol(Point.y, Decl(instanceAndStaticDeclarations1.ts, 3, 33))

    public distance(p: Point) {
>distance : Symbol(Point.distance, Decl(instanceAndStaticDeclarations1.ts, 3, 55))
>p : Symbol(p, Decl(instanceAndStaticDeclarations1.ts, 4, 20))
>Point : Symbol(Point, Decl(instanceAndStaticDeclarations1.ts, 0, 0))

        var dx = this.x - p.x;
>dx : Symbol(dx, Decl(instanceAndStaticDeclarations1.ts, 5, 11))
>this.x : Symbol(Point.x, Decl(instanceAndStaticDeclarations1.ts, 3, 16))
>this : Symbol(Point, Decl(instanceAndStaticDeclarations1.ts, 0, 0))
>x : Symbol(Point.x, Decl(instanceAndStaticDeclarations1.ts, 3, 16))
>p.x : Symbol(Point.x, Decl(instanceAndStaticDeclarations1.ts, 3, 16))
>p : Symbol(p, Decl(instanceAndStaticDeclarations1.ts, 4, 20))
>x : Symbol(Point.x, Decl(instanceAndStaticDeclarations1.ts, 3, 16))

        var dy = this.y - p.y;
>dy : Symbol(dy, Decl(instanceAndStaticDeclarations1.ts, 6, 11))
>this.y : Symbol(Point.y, Decl(instanceAndStaticDeclarations1.ts, 3, 33))
>this : Symbol(Point, Decl(instanceAndStaticDeclarations1.ts, 0, 0))
>y : Symbol(Point.y, Decl(instanceAndStaticDeclarations1.ts, 3, 33))
>p.y : Symbol(Point.y, Decl(instanceAndStaticDeclarations1.ts, 3, 33))
>p : Symbol(p, Decl(instanceAndStaticDeclarations1.ts, 4, 20))
>y : Symbol(Point.y, Decl(instanceAndStaticDeclarations1.ts, 3, 33))

        return Math.sqrt(dx * dx + dy * dy);
>Math.sqrt : Symbol(Math.sqrt, Decl(lib.es5.d.ts, --, --))
>Math : Symbol(Math, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>sqrt : Symbol(Math.sqrt, Decl(lib.es5.d.ts, --, --))
>dx : Symbol(dx, Decl(instanceAndStaticDeclarations1.ts, 5, 11))
>dx : Symbol(dx, Decl(instanceAndStaticDeclarations1.ts, 5, 11))
>dy : Symbol(dy, Decl(instanceAndStaticDeclarations1.ts, 6, 11))
>dy : Symbol(dy, Decl(instanceAndStaticDeclarations1.ts, 6, 11))
    }
    static origin = new Point(0, 0);
>origin : Symbol(Point.origin, Decl(instanceAndStaticDeclarations1.ts, 8, 5))
>Point : Symbol(Point, Decl(instanceAndStaticDeclarations1.ts, 0, 0))

    static distance(p1: Point, p2: Point) { return p1.distance(p2); }
>distance : Symbol(Point.distance, Decl(instanceAndStaticDeclarations1.ts, 9, 36))
>p1 : Symbol(p1, Decl(instanceAndStaticDeclarations1.ts, 10, 20))
>Point : Symbol(Point, Decl(instanceAndStaticDeclarations1.ts, 0, 0))
>p2 : Symbol(p2, Decl(instanceAndStaticDeclarations1.ts, 10, 30))
>Point : Symbol(Point, Decl(instanceAndStaticDeclarations1.ts, 0, 0))
>p1.distance : Symbol(Point.distance, Decl(instanceAndStaticDeclarations1.ts, 3, 55))
>p1 : Symbol(p1, Decl(instanceAndStaticDeclarations1.ts, 10, 20))
>distance : Symbol(Point.distance, Decl(instanceAndStaticDeclarations1.ts, 3, 55))
>p2 : Symbol(p2, Decl(instanceAndStaticDeclarations1.ts, 10, 30))
}
