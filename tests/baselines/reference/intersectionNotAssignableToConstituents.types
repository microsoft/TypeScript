=== tests/cases/compiler/intersectionNotAssignableToConstituents.ts ===
class A { private x: unknown }
>A : A
>x : unknown

class B { private x: unknown }
>B : B
>x : unknown

function f1(node: A | B) {
>f1 : (node: A | B) => void
>node : A | B

  if (node instanceof A || node instanceof A) {
>node instanceof A || node instanceof A : boolean
>node instanceof A : boolean
>node : A | B
>A : typeof A
>node instanceof A : boolean
>node : B
>A : typeof A

    node;  // A
>node : A
  }
  else {
    node;  // B
>node : B
  }
  node;  // A | B
>node : A | B
}

function f2(a: A, b: B, c: A & B) {
>f2 : (a: A, b: B, c: A & B) => void
>a : A
>b : B
>c : A & B

  a = b;  // Error
>a = b : B
>a : A
>b : B

  b = a;  // Error
>b = a : A
>b : B
>a : A

  a = c;  // Error (conflicting private fields)
>a = c : A & B
>a : A
>c : A & B

  b = c;  // Error (conflicting private fields)
>b = c : A & B
>b : B
>c : A & B
}

// Repro from #37659

abstract class ViewNode { }
>ViewNode : ViewNode

abstract class ViewRefNode extends ViewNode { }
>ViewRefNode : ViewRefNode
>ViewNode : ViewNode

abstract class ViewRefFileNode extends ViewRefNode { }
>ViewRefFileNode : ViewRefFileNode
>ViewRefNode : ViewRefNode

class CommitFileNode extends ViewRefFileNode {
>CommitFileNode : CommitFileNode
>ViewRefFileNode : ViewRefFileNode

  private _id: any;
>_id : any
}

class ResultsFileNode extends ViewRefFileNode {
>ResultsFileNode : ResultsFileNode
>ViewRefFileNode : ViewRefFileNode

  private _id: any;
>_id : any
}

class StashFileNode extends CommitFileNode { 
>StashFileNode : StashFileNode
>CommitFileNode : CommitFileNode

  private _id2: any;
>_id2 : any
}

class StatusFileNode extends ViewNode {
>StatusFileNode : StatusFileNode
>ViewNode : ViewNode

  private _id: any;
>_id : any
}

class Foo {
>Foo : Foo

  private async foo(node: CommitFileNode | ResultsFileNode | StashFileNode) {
>foo : (node: CommitFileNode | ResultsFileNode | StashFileNode) => Promise<void>
>node : CommitFileNode | ResultsFileNode | StashFileNode

		if (
			!(node instanceof CommitFileNode) &&
>!(node instanceof CommitFileNode) &&			!(node instanceof StashFileNode) &&			!(node instanceof ResultsFileNode) : boolean
>!(node instanceof CommitFileNode) &&			!(node instanceof StashFileNode) : boolean
>!(node instanceof CommitFileNode) : boolean
>(node instanceof CommitFileNode) : boolean
>node instanceof CommitFileNode : boolean
>node : CommitFileNode | ResultsFileNode | StashFileNode
>CommitFileNode : typeof CommitFileNode

			!(node instanceof StashFileNode) &&
>!(node instanceof StashFileNode) : boolean
>(node instanceof StashFileNode) : boolean
>node instanceof StashFileNode : boolean
>node : ResultsFileNode
>StashFileNode : typeof StashFileNode

			!(node instanceof ResultsFileNode)
>!(node instanceof ResultsFileNode) : boolean
>(node instanceof ResultsFileNode) : boolean
>node instanceof ResultsFileNode : boolean
>node : ResultsFileNode
>ResultsFileNode : typeof ResultsFileNode

		) {
			return;
		}

		await this.bar(node);
>await this.bar(node) : undefined
>this.bar(node) : Promise<undefined>
>this.bar : (node: CommitFileNode | ResultsFileNode | StashFileNode | StatusFileNode, options?: {} | undefined) => Promise<undefined>
>this : this
>bar : (node: CommitFileNode | ResultsFileNode | StashFileNode | StatusFileNode, options?: {} | undefined) => Promise<undefined>
>node : CommitFileNode | ResultsFileNode
	}

  private async bar(node: CommitFileNode | ResultsFileNode | StashFileNode | StatusFileNode, options?: {}) {
>bar : (node: CommitFileNode | ResultsFileNode | StashFileNode | StatusFileNode, options?: {} | undefined) => Promise<undefined>
>node : CommitFileNode | ResultsFileNode | StashFileNode | StatusFileNode
>options : {} | undefined

    return Promise.resolve(undefined);
>Promise.resolve(undefined) : Promise<undefined>
>Promise.resolve : { <T>(value: T | PromiseLike<T>): Promise<T>; (): Promise<void>; }
>Promise : PromiseConstructor
>resolve : { <T>(value: T | PromiseLike<T>): Promise<T>; (): Promise<void>; }
>undefined : undefined
  }
}

