//// [tests/cases/conformance/internalModules/moduleBody/invalidModuleWithStatementsOfEveryKind.ts] ////

=== invalidModuleWithStatementsOfEveryKind.ts ===
// All of these should be an error

namespace Y {
>Y : Symbol(Y, Decl(invalidModuleWithStatementsOfEveryKind.ts, 0, 0))

    public class A { s: string }
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 2, 13))
>s : Symbol(A.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 3, 20))

    public class BB<T> extends A {
>BB : Symbol(BB, Decl(invalidModuleWithStatementsOfEveryKind.ts, 3, 32))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 5, 20))
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 2, 13))

        id: number;
>id : Symbol(BB.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 5, 34))
    }
}

namespace Y2 {
>Y2 : Symbol(Y2, Decl(invalidModuleWithStatementsOfEveryKind.ts, 8, 1))

    public class AA<T> { s: T }
>AA : Symbol(AA, Decl(invalidModuleWithStatementsOfEveryKind.ts, 10, 14))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 11, 20))
>s : Symbol(AA.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 11, 24))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 11, 20))

    public interface I { id: number }
>I : Symbol(I, Decl(invalidModuleWithStatementsOfEveryKind.ts, 11, 31))
>id : Symbol(I.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 12, 24))

    public class B extends AA<string> implements I { id: number }
>B : Symbol(B, Decl(invalidModuleWithStatementsOfEveryKind.ts, 12, 37))
>AA : Symbol(AA, Decl(invalidModuleWithStatementsOfEveryKind.ts, 10, 14))
>I : Symbol(I, Decl(invalidModuleWithStatementsOfEveryKind.ts, 11, 31))
>id : Symbol(B.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 14, 52))
}

namespace Y3 {
>Y3 : Symbol(Y3, Decl(invalidModuleWithStatementsOfEveryKind.ts, 15, 1))

    public namespace Module {
>Module : Symbol(Module, Decl(invalidModuleWithStatementsOfEveryKind.ts, 17, 14))

        class A { s: string }
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 18, 29))
>s : Symbol(A.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 19, 17))
    }
}

namespace Y4 {
>Y4 : Symbol(Y4, Decl(invalidModuleWithStatementsOfEveryKind.ts, 21, 1))

    public enum Color { Blue, Red }
>Color : Symbol(Color, Decl(invalidModuleWithStatementsOfEveryKind.ts, 23, 14))
>Blue : Symbol(Color.Blue, Decl(invalidModuleWithStatementsOfEveryKind.ts, 24, 23))
>Red : Symbol(Color.Red, Decl(invalidModuleWithStatementsOfEveryKind.ts, 24, 29))
}

namespace YY {
>YY : Symbol(YY, Decl(invalidModuleWithStatementsOfEveryKind.ts, 25, 1))

    private class A { s: string }
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 27, 14))
>s : Symbol(A.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 28, 21))

    private class BB<T> extends A {
>BB : Symbol(BB, Decl(invalidModuleWithStatementsOfEveryKind.ts, 28, 33))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 30, 21))
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 27, 14))

        id: number;
>id : Symbol(BB.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 30, 35))
    }
}

namespace YY2 {
>YY2 : Symbol(YY2, Decl(invalidModuleWithStatementsOfEveryKind.ts, 33, 1))

    private class AA<T> { s: T }
>AA : Symbol(AA, Decl(invalidModuleWithStatementsOfEveryKind.ts, 35, 15))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 36, 21))
>s : Symbol(AA.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 36, 25))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 36, 21))

    private interface I { id: number }
>I : Symbol(I, Decl(invalidModuleWithStatementsOfEveryKind.ts, 36, 32))
>id : Symbol(I.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 37, 25))

    private class B extends AA<string> implements I { id: number }
>B : Symbol(B, Decl(invalidModuleWithStatementsOfEveryKind.ts, 37, 38))
>AA : Symbol(AA, Decl(invalidModuleWithStatementsOfEveryKind.ts, 35, 15))
>I : Symbol(I, Decl(invalidModuleWithStatementsOfEveryKind.ts, 36, 32))
>id : Symbol(B.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 39, 53))
}

namespace YY3 {
>YY3 : Symbol(YY3, Decl(invalidModuleWithStatementsOfEveryKind.ts, 40, 1))

    private namespace Module {
>Module : Symbol(Module, Decl(invalidModuleWithStatementsOfEveryKind.ts, 42, 15))

        class A { s: string }
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 43, 30))
>s : Symbol(A.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 44, 17))
    }
}

namespace YY4 {
>YY4 : Symbol(YY4, Decl(invalidModuleWithStatementsOfEveryKind.ts, 46, 1))

    private enum Color { Blue, Red }
>Color : Symbol(Color, Decl(invalidModuleWithStatementsOfEveryKind.ts, 48, 15))
>Blue : Symbol(Color.Blue, Decl(invalidModuleWithStatementsOfEveryKind.ts, 49, 24))
>Red : Symbol(Color.Red, Decl(invalidModuleWithStatementsOfEveryKind.ts, 49, 30))
}


namespace YYY {
>YYY : Symbol(YYY, Decl(invalidModuleWithStatementsOfEveryKind.ts, 50, 1))

    static class A { s: string }
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 53, 15))
>s : Symbol(A.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 54, 20))

    static class BB<T> extends A {
>BB : Symbol(BB, Decl(invalidModuleWithStatementsOfEveryKind.ts, 54, 32))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 56, 20))
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 53, 15))

        id: number;
>id : Symbol(BB.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 56, 34))
    }
}

namespace YYY2 {
>YYY2 : Symbol(YYY2, Decl(invalidModuleWithStatementsOfEveryKind.ts, 59, 1))

    static class AA<T> { s: T }
>AA : Symbol(AA, Decl(invalidModuleWithStatementsOfEveryKind.ts, 61, 16))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 62, 20))
>s : Symbol(AA.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 62, 24))
>T : Symbol(T, Decl(invalidModuleWithStatementsOfEveryKind.ts, 62, 20))

    static interface I { id: number }
>I : Symbol(I, Decl(invalidModuleWithStatementsOfEveryKind.ts, 62, 31))
>id : Symbol(I.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 63, 24))

    static class B extends AA<string> implements I { id: number }
>B : Symbol(B, Decl(invalidModuleWithStatementsOfEveryKind.ts, 63, 37))
>AA : Symbol(AA, Decl(invalidModuleWithStatementsOfEveryKind.ts, 61, 16))
>I : Symbol(I, Decl(invalidModuleWithStatementsOfEveryKind.ts, 62, 31))
>id : Symbol(B.id, Decl(invalidModuleWithStatementsOfEveryKind.ts, 65, 52))
}

namespace YYY3 {
>YYY3 : Symbol(YYY3, Decl(invalidModuleWithStatementsOfEveryKind.ts, 66, 1))

    static namespace Module {
>Module : Symbol(Module, Decl(invalidModuleWithStatementsOfEveryKind.ts, 68, 16))

        class A { s: string }
>A : Symbol(A, Decl(invalidModuleWithStatementsOfEveryKind.ts, 69, 29))
>s : Symbol(A.s, Decl(invalidModuleWithStatementsOfEveryKind.ts, 70, 17))
    }
}

namespace YYY4 {
>YYY4 : Symbol(YYY4, Decl(invalidModuleWithStatementsOfEveryKind.ts, 72, 1))

    static enum Color { Blue, Red }
>Color : Symbol(Color, Decl(invalidModuleWithStatementsOfEveryKind.ts, 74, 16))
>Blue : Symbol(Color.Blue, Decl(invalidModuleWithStatementsOfEveryKind.ts, 75, 23))
>Red : Symbol(Color.Red, Decl(invalidModuleWithStatementsOfEveryKind.ts, 75, 29))
}

