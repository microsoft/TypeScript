//// [tests/cases/compiler/iterableWithNeverAsUnionMember.ts] ////

=== iterableWithNeverAsUnionMember.ts ===
declare const o1: { a: "foo" } & { a: "bar" };
>o1 : never
>   : ^^^^^
>a : "foo"
>  : ^^^^^
>a : "bar"
>  : ^^^^^

const [el1] = o1; // error
>el1 : never
>    : ^^^^^
>o1 : never
>   : ^^^^^

// https://github.com/microsoft/TypeScript/issues/62462
declare var x: number[] | ({ t: "a" } & { t: "b" });
>x : number[]
>  : ^^^^^^^^
>t : "a"
>  : ^^^
>t : "b"
>  : ^^^

let [el2] = x; // ok
>el2 : number
>    : ^^^^^^
>x : number[]
>  : ^^^^^^^^

for (const elem of x) { // ok
>elem : number
>     : ^^^^^^
>x : number[]
>  : ^^^^^^^^

  elem.toFixed();
>elem.toFixed() : string
>               : ^^^^^^
>elem.toFixed : (fractionDigits?: number) => string
>             : ^              ^^^      ^^^^^      
>elem : number
>     : ^^^^^^
>toFixed : (fractionDigits?: number) => string
>        : ^              ^^^      ^^^^^      
}

type Shape =
>Shape : Shape
>      : ^^^^^

  | { kind: "circle"; radius: number }
>kind : "circle"
>     : ^^^^^^^^
>radius : number
>       : ^^^^^^

  | { kind: "rectangle"; width: number; height: number };
>kind : "rectangle"
>     : ^^^^^^^^^^^
>width : number
>      : ^^^^^^
>height : number
>       : ^^^^^^

type Circle = Shape & { kind: "circle" };
>Circle : { kind: "circle"; radius: number; } & { kind: "circle"; }
>       : ^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^
>kind : "circle"
>     : ^^^^^^^^

function doStuffWithCircle(arg: Circle | [Circle, (newValue: Circle) => void]) {
>doStuffWithCircle : (arg: Circle | [Circle, (newValue: Circle) => void]) => void
>                  : ^   ^^                                             ^^^^^^^^^
>arg : ({ kind: "circle"; radius: number; } & { kind: "circle"; }) | [{ kind: "circle"; radius: number; } & { kind: "circle"; }, (newValue: Circle) => void]
>    : ^^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^^^^^^^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^^^^        ^^      ^^^^^    ^
>newValue : { kind: "circle"; radius: number; } & { kind: "circle"; }
>         : ^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^

  if (Array.isArray(arg)) {
>Array.isArray(arg) : boolean
>                   : ^^^^^^^
>Array.isArray : (arg: any) => arg is any[]
>              : ^   ^^   ^^^^^            
>Array : ArrayConstructor
>      : ^^^^^^^^^^^^^^^^
>isArray : (arg: any) => arg is any[]
>        : ^   ^^   ^^^^^            
>arg : ({ kind: "circle"; radius: number; } & { kind: "circle"; }) | [{ kind: "circle"; radius: number; } & { kind: "circle"; }, (newValue: Circle) => void]
>    : ^^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^^^^^^^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^^^^        ^^      ^^^^^    ^

    let [value, setValue] = arg; // ok
>value : { kind: "circle"; radius: number; } & { kind: "circle"; }
>      : ^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^
>setValue : (newValue: Circle) => void
>         : ^        ^^      ^^^^^    
>arg : [{ kind: "circle"; radius: number; } & { kind: "circle"; }, (newValue: Circle) => void]
>    : ^^^^^^^^^        ^^^^^^^^^^      ^^^^^^^^^^^^^^        ^^^^^^        ^^      ^^^^^    ^
  }
}

function f1<T extends { a: "foo" } & { a: "bar" }>(x: T) {
>f1 : <T extends { a: "foo"; } & { a: "bar"; }>(x: T) => void
>   : ^ ^^^^^^^^^                             ^^ ^^ ^^^^^^^^^
>a : "foo"
>  : ^^^^^
>a : "bar"
>  : ^^^^^
>x : T
>  : ^

  let [y] = x; // error
>y : never
>  : ^^^^^
>x : T
>  : ^
}

declare const o2: ({ a: "foo" } & { a: "bar" }) | ({ b: "qwe" } & { b: "rty" });
>o2 : never
>   : ^^^^^
>a : "foo"
>  : ^^^^^
>a : "bar"
>  : ^^^^^
>b : "qwe"
>  : ^^^^^
>b : "rty"
>  : ^^^^^

const [el3] = o2; // error
>el3 : never
>    : ^^^^^
>o2 : never
>   : ^^^^^

