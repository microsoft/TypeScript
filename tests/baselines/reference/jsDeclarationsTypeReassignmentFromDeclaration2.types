=== tests/cases/conformance/jsdoc/declarations/index.js ===
const items = require("./some-mod")();
>items : Item[]
>require("./some-mod")() : Item[]
>require("./some-mod") : () => Item[]
>require : any
>"./some-mod" : "./some-mod"

module.exports = items;
>module.exports = items : { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }
>module.exports : { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }
>module : { exports: { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }; }
>exports : { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }
>items : Item[]

=== tests/cases/conformance/jsdoc/declarations/some-mod.d.ts ===
interface Item {
    x: string;
>x : string
}
declare function getItems(): Item[];
>getItems : () => Item[]

export = getItems;
>getItems : () => Item[]

