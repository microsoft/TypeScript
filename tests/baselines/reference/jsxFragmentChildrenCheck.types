//// [tests/cases/compiler/jsxFragmentChildrenCheck.tsx] ////

=== node_modules/@test/jsx-runtime/index.d.ts ===
export const jsx: any;
>jsx : any

export const jsxs: any;
>jsxs : any

type JsxElement =
>JsxElement : JsxElement
>           : ^^^^^^^^^^

  | JsxElementArray
  | undefined
  | string
  | ((arg: { foo: "bar" }) => void);
>arg : { foo: "bar"; }
>    : ^^^^^^^     ^^^
>foo : "bar"
>    : ^^^^^

interface JsxElementArray extends Array<JsxElement> {}

interface FragmentProps {
  children?: JsxElement;
>children : JsxElement
>         : ^^^^^^^^^^
}

export const Fragment: (props: FragmentProps) => any;
>Fragment : (props: FragmentProps) => any
>         : ^     ^^             ^^^^^   
>props : FragmentProps
>      : ^^^^^^^^^^^^^

declare global {
>global : any
>       : ^^^

  namespace JSX {
    interface IntrinsicElements {
      div: any;
>div : any

      span: any;
>span : any
    }
  }
}

=== index.tsx ===
import { Fragment } from "@test/jsx-runtime";
>Fragment : (props: import("node_modules/@test/jsx-runtime/index").FragmentProps) => any
>         : ^     ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^   

// This should pass - using explicit Fragment
<Fragment>
><Fragment>  {"ok"}  {({ foo }) => "also ok"}</Fragment> : error
>Fragment : (props: import("node_modules/@test/jsx-runtime/index").FragmentProps) => any
>         : ^     ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^   

  {"ok"}
>"ok" : "ok"
>     : ^^^^

  {({ foo }) => "also ok"}
>({ foo }) => "also ok" : ({ foo }: { foo: "bar"; }) => string
>                       : ^       ^^^^^^^^^     ^^^^^^^^^^^^^^
>foo : "bar"
>    : ^^^^^
>"also ok" : "also ok"
>          : ^^^^^^^^^

</Fragment>;
>Fragment : (props: import("node_modules/@test/jsx-runtime/index").FragmentProps) => any
>         : ^     ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^   

// This should also pass - using <> syntax should be equivalent
<>
><>  {"ok"}  {({ foo }) => "should also be ok"}</> : any

  {"ok"}
>"ok" : "ok"
>     : ^^^^

  {({ foo }) => "should also be ok"}
>({ foo }) => "should also be ok" : ({ foo }: { foo: "bar"; }) => string
>                                 : ^       ^^^^^^^^^     ^^^^^^^^^^^^^^
>foo : "bar"
>    : ^^^^^
>"should also be ok" : "should also be ok"
>                    : ^^^^^^^^^^^^^^^^^^^

</>;

