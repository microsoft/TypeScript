nestedInference.ts(36,15): error TS2345: Argument of type '"this is wrong"' is not assignable to parameter of type 'Pattern<"a" | "b">'.
nestedInference.ts(50,15): error TS2345: Argument of type '"this is wrong"' is not assignable to parameter of type 'Pattern<"a" | "b">'.


==== nestedInference.ts (2 errors) ====
    // repro from #52864
    
    const matcher = Symbol("@ts-pattern/matcher");
    
    type MatcherProtocol<input> = {
      match: <I>(value: I | input) => void;
    };
    
    interface Matcher<input> {
      [matcher](): MatcherProtocol<input>;
    }
    
    type Pattern<a> =
      | Matcher<a>
      | (a extends readonly [any, ...any]
          ? { readonly [index in keyof a]: Pattern<a[index]> }
          : a extends object
          ? { readonly [k in keyof a]: Pattern<a[k]> }
          : a);
    
    type Match<i> = {
      with<p extends Pattern<i>>(pattern: p): void;
    };
    
    declare function match<input>(value: input): Match<input>;
    declare function union<input, ps extends [Pattern<input>, ...Pattern<input>[]]>(
      ...patterns: ps
    ): Matcher<input>;
    declare function when<input, p extends (value: input) => unknown>(
      predicate: p
    ): Matcher<input>;
    
    match<"a" | "b">("a").with(union("a"));
    
    match<"a" | "b">("a")
      .with(union("this is wrong")); // error
                  ~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type '"this is wrong"' is not assignable to parameter of type 'Pattern<"a" | "b">'.
    
    match<"a" | "b">("a").with(
      when((x) => {
        let a: "a" | "b" = x; // OK
        return a;
      })
    );
    
    match<{ type: "a" | "b" }>({ type: "a" }).with({
      type: union("a"),
    });
    
    match<{ type: "a" | "b" }>({ type: "a" }).with({
      type: union("this is wrong"), // error
                  ~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type '"this is wrong"' is not assignable to parameter of type 'Pattern<"a" | "b">'.
    });
    
    match<{ type: "a" | "b" }>({ type: "a" }).with({
      type: when((x) => {
        let a: "a" | "b" = x; // OK
        return a;
      }),
    });
    
    // https://github.com/microsoft/TypeScript/issues/57978
    interface Action<Value> {
      _run(input: Value): Value;
    }
    
    declare function minLength<Value extends string | any[]>(min: number): Action<Value>
    
    declare function pipe1<TAction1 extends Action<string>>(
      action1: TAction1,
    ): (input: string) => string;
    
    const Schema1 = pipe1(minLength(1));
    