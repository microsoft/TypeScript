//// [tests/cases/compiler/noIterationTypeErrorsInCFA.ts] ////

=== noIterationTypeErrorsInCFA.ts ===
interface F {
    d(): void
>d : () => void
>  : ^^^^^^    
}
export function doRemove(dds: F | F[]) {
>doRemove : (dds: F | F[]) => F[]
>         : ^   ^^       ^^^^^^^^
>dds : F | F[]
>    : ^^^^^^^

    if (!Array.isArray(dds)) {
>!Array.isArray(dds) : boolean
>                    : ^^^^^^^
>Array.isArray(dds) : boolean
>                   : ^^^^^^^
>Array.isArray : { <T>(arg: ArrayLike<T>): arg is readonly T[]; (arg: unknown): arg is any[]; <T>(arg: Iterable<T>): arg is readonly T[]; }
>              : ^^^ ^^   ^^            ^^^                   ^^^   ^^       ^^^            ^^^ ^^   ^^           ^^^                   ^^^
>Array : ArrayConstructor
>      : ^^^^^^^^^^^^^^^^
>isArray : { <T>(arg: ArrayLike<T>): arg is readonly T[]; (arg: unknown): arg is any[]; <T>(arg: Iterable<T>): arg is readonly T[]; }
>        : ^^^ ^^   ^^            ^^^                   ^^^   ^^       ^^^            ^^^ ^^   ^^           ^^^                   ^^^
>dds : F | F[]
>    : ^^^^^^^

        dds = [dds]
>dds = [dds] : F[]
>            : ^^^
>dds : F | F[]
>    : ^^^^^^^
>[dds] : F[]
>      : ^^^
>dds : F
>    : ^
    }
    for (let n of dds) {
>n : F
>  : ^
>dds : F[]
>    : ^^^

        n.d()
>n.d() : void
>      : ^^^^
>n.d : () => void
>    : ^^^^^^    
>n : F
>  : ^
>d : () => void
>  : ^^^^^^    
    }
    return dds
>dds : F[]
>    : ^^^
}

