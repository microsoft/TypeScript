//// [tests/cases/conformance/parser/ecmascript5/RealWorld/parserharness.ts] ////

=== Performance Stats ===
Type Count: 1,000

=== parserharness.ts ===
//ï»¿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='..\compiler\io.ts'/>
///<reference path='..\compiler\typescript.ts'/>
///<reference path='..\services\typescriptServices.ts' />
///<reference path='diff.ts'/>

declare var assert: Harness.Assert;
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>Harness : any
>        : ^^^

declare var it;
>it : any
>   : ^^^

declare var describe;
>describe : any
>         : ^^^

declare var run;
>run : any
>    : ^^^

declare var IO: IIO;
>IO : IIO
>   : ^^^

declare var __dirname; // Node-specific
>__dirname : any
>          : ^^^

function switchToForwardSlashes(path: string) {
>switchToForwardSlashes : (path: string) => string
>                       : ^    ^^      ^^^^^^^^^^^
>path : string
>     : ^^^^^^

    return path.replace(/\\/g, "/");
>path.replace(/\\/g, "/") : string
>                         : ^^^^^^
>path.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>             : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>path : string
>     : ^^^^^^
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>        : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>/\\/g : RegExp
>      : ^^^^^^
>"/" : "/"
>    : ^^^
}

function filePath(fullPath: string) {
>filePath : (fullPath: string) => string
>         : ^        ^^      ^^^^^^^^^^^
>fullPath : string
>         : ^^^^^^

    fullPath = switchToForwardSlashes(fullPath);
>fullPath = switchToForwardSlashes(fullPath) : string
>                                            : ^^^^^^
>fullPath : string
>         : ^^^^^^
>switchToForwardSlashes(fullPath) : string
>                                 : ^^^^^^
>switchToForwardSlashes : (path: string) => string
>                       : ^    ^^      ^^^^^^^^^^^
>fullPath : string
>         : ^^^^^^

    var components = fullPath.split("/");
>components : string[]
>           : ^^^^^^^^
>fullPath.split("/") : string[]
>                    : ^^^^^^^^
>fullPath.split : (separator: string | RegExp, limit?: number) => string[]
>               : ^         ^^               ^^     ^^^      ^^^^^        
>fullPath : string
>         : ^^^^^^
>split : (separator: string | RegExp, limit?: number) => string[]
>      : ^         ^^               ^^     ^^^      ^^^^^        
>"/" : "/"
>    : ^^^

    var path: string[] = components.slice(0, components.length - 1);
>path : string[]
>     : ^^^^^^^^
>components.slice(0, components.length - 1) : string[]
>                                           : ^^^^^^^^
>components.slice : (start?: number, end?: number) => string[]
>                 : ^     ^^^      ^^   ^^^      ^^^^^^^^^^^^^
>components : string[]
>           : ^^^^^^^^
>slice : (start?: number, end?: number) => string[]
>      : ^     ^^^      ^^   ^^^      ^^^^^^^^^^^^^
>0 : 0
>  : ^
>components.length - 1 : number
>                      : ^^^^^^
>components.length : number
>                  : ^^^^^^
>components : string[]
>           : ^^^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^

    return path.join("/") + "/";
>path.join("/") + "/" : string
>                     : ^^^^^^
>path.join("/") : string
>               : ^^^^^^
>path.join : (separator?: string) => string
>          : ^         ^^^      ^^^^^      
>path : string[]
>     : ^^^^^^^^
>join : (separator?: string) => string
>     : ^         ^^^      ^^^^^      
>"/" : "/"
>    : ^^^
>"/" : "/"
>    : ^^^
}

var typescriptServiceFileName = filePath(IO.getExecutingFilePath()) + "typescriptServices.js";
>typescriptServiceFileName : string
>                          : ^^^^^^
>filePath(IO.getExecutingFilePath()) + "typescriptServices.js" : string
>                                                              : ^^^^^^
>filePath(IO.getExecutingFilePath()) : string
>                                    : ^^^^^^
>filePath : (fullPath: string) => string
>         : ^        ^^      ^^^^^^^^^^^
>IO.getExecutingFilePath() : any
>                          : ^^^
>IO.getExecutingFilePath : any
>                        : ^^^
>IO : IIO
>   : ^^^
>getExecutingFilePath : any
>                     : ^^^
>"typescriptServices.js" : "typescriptServices.js"
>                        : ^^^^^^^^^^^^^^^^^^^^^^^

var typescriptServiceFile = IO.readFile(typescriptServiceFileName);
>typescriptServiceFile : any
>                      : ^^^
>IO.readFile(typescriptServiceFileName) : any
>                                       : ^^^
>IO.readFile : any
>            : ^^^
>IO : IIO
>   : ^^^
>readFile : any
>         : ^^^
>typescriptServiceFileName : string
>                          : ^^^^^^

if (typeof ActiveXObject === "function") {
>typeof ActiveXObject === "function" : boolean
>                                    : ^^^^^^^
>typeof ActiveXObject : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>ActiveXObject : any
>              : ^^^
>"function" : "function"
>           : ^^^^^^^^^^

    eval(typescriptServiceFile);
>eval(typescriptServiceFile) : any
>                            : ^^^
>eval : (x: string) => any
>     : ^ ^^      ^^^^^   
>typescriptServiceFile : any
>                      : ^^^

} else if (typeof require === "function") {
>typeof require === "function" : boolean
>                              : ^^^^^^^
>typeof require : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>require : any
>        : ^^^
>"function" : "function"
>           : ^^^^^^^^^^

    var vm = require('vm');
>vm : any
>   : ^^^
>require('vm') : any
>              : ^^^
>require : any
>        : ^^^
>'vm' : "vm"
>     : ^^^^

    vm.runInThisContext(typescriptServiceFile, 'typescriptServices.js');
>vm.runInThisContext(typescriptServiceFile, 'typescriptServices.js') : any
>                                                                    : ^^^
>vm.runInThisContext : any
>                    : ^^^
>vm : any
>   : ^^^
>runInThisContext : any
>                 : ^^^
>typescriptServiceFile : any
>                      : ^^^
>'typescriptServices.js' : "typescriptServices.js"
>                        : ^^^^^^^^^^^^^^^^^^^^^^^

} else {
    throw new Error('Unknown context');
>new Error('Unknown context') : Error
>                             : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>'Unknown context' : "Unknown context"
>                  : ^^^^^^^^^^^^^^^^^
}

declare module process {
>process : typeof process
>        : ^^^^^^^^^^^^^^

    export function nextTick(callback: () => any): void;
>nextTick : (callback: () => any) => void
>         : ^        ^^         ^^^^^    
>callback : () => any
>         : ^^^^^^   

    export function on(event: string, listener: Function);
>on : (event: string, listener: Function) => any
>   : ^     ^^      ^^        ^^        ^^^^^^^^
>event : string
>      : ^^^^^^
>listener : Function
>         : ^^^^^^^^
}

module Harness {
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^

    // Settings 
    export var userSpecifiedroot = "";
>userSpecifiedroot : string
>                  : ^^^^^^
>"" : ""
>   : ^^

    var global = <any>Function("return this").call(null);
>global : any
>       : ^^^
><any>Function("return this").call(null) : any
>                                        : ^^^
>Function("return this").call(null) : any
>                                   : ^^^
>Function("return this").call : (this: Function, thisArg: any, ...argArray: any[]) => any
>                             : ^    ^^        ^^       ^^   ^^^^^        ^^     ^^^^^   
>Function("return this") : Function
>                        : ^^^^^^^^
>Function : FunctionConstructor
>         : ^^^^^^^^^^^^^^^^^^^
>"return this" : "return this"
>              : ^^^^^^^^^^^^^
>call : (this: Function, thisArg: any, ...argArray: any[]) => any
>     : ^    ^^        ^^       ^^   ^^^^^        ^^     ^^^^^   

    export var usePull = false;
>usePull : boolean
>        : ^^^^^^^
>false : false
>      : ^^^^^

    export interface ITestMetadata {
        id: string;
>id : string
>   : ^^^^^^

        desc: string;
>desc : string
>     : ^^^^^^

        pass: boolean;
>pass : boolean
>     : ^^^^^^^

        perfResults: {
>perfResults : { mean: number; min: number; max: number; stdDev: number; trials: number[]; }
>            : ^^^^^^^^      ^^^^^^^      ^^^^^^^      ^^^^^^^^^^      ^^^^^^^^^^        ^^^

            mean: number;
>mean : number
>     : ^^^^^^

            min: number;
>min : number
>    : ^^^^^^

            max: number;
>max : number
>    : ^^^^^^

            stdDev: number;
>stdDev : number
>       : ^^^^^^

            trials: number[];
>trials : number[]
>       : ^^^^^^^^

        };
    }
    export interface IScenarioMetadata {
        id: string;
>id : string
>   : ^^^^^^

        desc: string;
>desc : string
>     : ^^^^^^

        pass: boolean;
>pass : boolean
>     : ^^^^^^^

        bugs: string[];
>bugs : string[]
>     : ^^^^^^^^
    }

    // Assert functions
    export module Assert {
>Assert : typeof Assert
>       : ^^^^^^^^^^^^^

        export var bugIds: string[] = [];
>bugIds : string[]
>       : ^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        export var throwAssertError = (error: Error) => {
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>(error: Error) => {            throw error;        } : (error: Error) => never
>                                                     : ^     ^^     ^^^^^^^^^^
>error : Error
>      : ^^^^^

            throw error;
>error : Error
>      : ^^^^^

        };

        // Marks that the current scenario is impacted by a bug
        export function bug(id: string) {
>bug : (id: string) => void
>    : ^  ^^      ^^^^^^^^^
>id : string
>   : ^^^^^^

            if (bugIds.indexOf(id) < 0) {
>bugIds.indexOf(id) < 0 : boolean
>                       : ^^^^^^^
>bugIds.indexOf(id) : number
>                   : ^^^^^^
>bugIds.indexOf : (searchElement: string, fromIndex?: number) => number
>               : ^             ^^^^^^^^^^         ^^^      ^^^^^      
>bugIds : string[]
>       : ^^^^^^^^
>indexOf : (searchElement: string, fromIndex?: number) => number
>        : ^             ^^^^^^^^^^         ^^^      ^^^^^      
>id : string
>   : ^^^^^^
>0 : 0
>  : ^

                bugIds.push(id);
>bugIds.push(id) : number
>                : ^^^^^^
>bugIds.push : (...items: string[]) => number
>            : ^^^^     ^^^^^^^^^^^^^^^      
>bugIds : string[]
>       : ^^^^^^^^
>push : (...items: string[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^      
>id : string
>   : ^^^^^^
            }
        }

        // If there are any bugs in the test code, mark the scenario as impacted appropriately
        export function bugs(content: string) {
>bugs : (content: string) => void
>     : ^       ^^      ^^^^^^^^^
>content : string
>        : ^^^^^^

            var bugs = content.match(/\bbug (\d+)/i);
>bugs : RegExpMatchArray
>     : ^^^^^^^^^^^^^^^^
>content.match(/\bbug (\d+)/i) : RegExpMatchArray
>                              : ^^^^^^^^^^^^^^^^
>content.match : (regexp: string | RegExp) => RegExpMatchArray | null
>              : ^      ^^               ^^^^^                       
>content : string
>        : ^^^^^^
>match : (regexp: string | RegExp) => RegExpMatchArray | null
>      : ^      ^^               ^^^^^                       
>/\bbug (\d+)/i : RegExp
>               : ^^^^^^

            if (bugs) {
>bugs : RegExpMatchArray
>     : ^^^^^^^^^^^^^^^^

                bugs.forEach(bug => assert.bug(bug));
>bugs.forEach(bug => assert.bug(bug)) : void
>                                     : ^^^^
>bugs.forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>             : ^          ^^^     ^^^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>bugs : RegExpMatchArray
>     : ^^^^^^^^^^^^^^^^
>forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>        : ^          ^^^     ^^^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>bug => assert.bug(bug) : (bug: string) => any
>                       : ^   ^^^^^^^^^^^^^^^^
>bug : string
>    : ^^^^^^
>assert.bug(bug) : any
>                : ^^^
>assert.bug : any
>           : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>bug : any
>    : ^^^
>bug : string
>    : ^^^^^^
            }
        }

        export function is(result: boolean, msg?: string) {
>is : (result: boolean, msg?: string) => void
>   : ^      ^^       ^^   ^^^      ^^^^^^^^^
>result : boolean
>       : ^^^^^^^
>msg : string
>    : ^^^^^^

            if (!result) {
>!result : boolean
>        : ^^^^^^^
>result : boolean
>       : ^^^^^^^

                throwAssertError(new Error(msg || "Expected true, got false."));
>throwAssertError(new Error(msg || "Expected true, got false.")) : never
>                                                                : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error(msg || "Expected true, got false.") : Error
>                                              : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>msg || "Expected true, got false." : string
>                                   : ^^^^^^
>msg : string
>    : ^^^^^^
>"Expected true, got false." : "Expected true, got false."
>                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
            }
        }

        export function arrayLengthIs(arr: any[], length: number) {
>arrayLengthIs : (arr: any[], length: number) => void
>              : ^   ^^     ^^      ^^      ^^^^^^^^^
>arr : any[]
>    : ^^^^^
>length : number
>       : ^^^^^^

            if (arr.length != length) {
>arr.length != length : boolean
>                     : ^^^^^^^
>arr.length : number
>           : ^^^^^^
>arr : any[]
>    : ^^^^^
>length : number
>       : ^^^^^^
>length : number
>       : ^^^^^^

                var actual = '';
>actual : string
>       : ^^^^^^
>'' : ""
>   : ^^

                arr.forEach(n => actual = actual + '\n      ' + n.toString());
>arr.forEach(n => actual = actual + '\n      ' + n.toString()) : void
>                                                              : ^^^^
>arr.forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>            : ^          ^^^     ^^^^^^^     ^^      ^^     ^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>arr : any[]
>    : ^^^^^
>forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>        : ^          ^^^     ^^^^^^^     ^^      ^^     ^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>n => actual = actual + '\n      ' + n.toString() : (n: any) => string
>                                                 : ^ ^^^^^^^^^^^^^^^^
>n : any
>  : ^^^
>actual = actual + '\n      ' + n.toString() : string
>                                            : ^^^^^^
>actual : string
>       : ^^^^^^
>actual + '\n      ' + n.toString() : string
>                                   : ^^^^^^
>actual + '\n      ' : string
>                    : ^^^^^^
>actual : string
>       : ^^^^^^
>'\n      ' : "\n      "
>           : ^^^^^^^^^^
>n.toString() : any
>             : ^^^
>n.toString : any
>           : ^^^
>n : any
>  : ^^^
>toString : any
>         : ^^^

                throwAssertError(new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual));
>throwAssertError(new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual)) : never
>                                                                                                              : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual) : Error
>                                                                                            : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>'Expected array to have ' + length + ' elements. Actual elements were:' + actual : string
>                                                                                 : ^^^^^^
>'Expected array to have ' + length + ' elements. Actual elements were:' : string
>                                                                        : ^^^^^^
>'Expected array to have ' + length : string
>                                   : ^^^^^^
>'Expected array to have ' : "Expected array to have "
>                          : ^^^^^^^^^^^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>' elements. Actual elements were:' : " elements. Actual elements were:"
>                                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
            }
        }

        export function equal(actual, expected) {
>equal : (actual: any, expected: any) => void
>      : ^      ^^^^^^^        ^^^^^^^^^^^^^^
>actual : any
>       : ^^^
>expected : any
>         : ^^^

            if (actual !== expected) {
>actual !== expected : boolean
>                    : ^^^^^^^
>actual : any
>       : ^^^
>expected : any
>         : ^^^

                throwAssertError(new Error("Expected " + actual + " to equal " + expected));
>throwAssertError(new Error("Expected " + actual + " to equal " + expected)) : never
>                                                                            : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error("Expected " + actual + " to equal " + expected) : Error
>                                                          : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected " + actual + " to equal " + expected : string
>                                               : ^^^^^^
>"Expected " + actual + " to equal " : string
>                                    : ^^^^^^
>"Expected " + actual : string
>                     : ^^^^^^
>"Expected " : "Expected "
>            : ^^^^^^^^^^^
>actual : any
>       : ^^^
>" to equal " : " to equal "
>             : ^^^^^^^^^^^^
>expected : any
>         : ^^^
            }
        }

        export function notEqual(actual, expected) {
>notEqual : (actual: any, expected: any) => void
>         : ^      ^^^^^^^        ^^^^^^^^^^^^^^
>actual : any
>       : ^^^
>expected : any
>         : ^^^

            if (actual === expected) {
>actual === expected : boolean
>                    : ^^^^^^^
>actual : any
>       : ^^^
>expected : any
>         : ^^^

                throwAssertError(new Error("Expected " + actual + " to *not* equal " + expected));
>throwAssertError(new Error("Expected " + actual + " to *not* equal " + expected)) : never
>                                                                                  : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error("Expected " + actual + " to *not* equal " + expected) : Error
>                                                                : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected " + actual + " to *not* equal " + expected : string
>                                                     : ^^^^^^
>"Expected " + actual + " to *not* equal " : string
>                                          : ^^^^^^
>"Expected " + actual : string
>                     : ^^^^^^
>"Expected " : "Expected "
>            : ^^^^^^^^^^^
>actual : any
>       : ^^^
>" to *not* equal " : " to *not* equal "
>                   : ^^^^^^^^^^^^^^^^^^
>expected : any
>         : ^^^
            }
        }

        export function notNull(result) {
>notNull : (result: any) => void
>        : ^      ^^^^^^^^^^^^^^
>result : any
>       : ^^^

            if (result === null) {
>result === null : boolean
>                : ^^^^^^^
>result : any
>       : ^^^

                throwAssertError(new Error("Expected " + result + " to *not* be null"));
>throwAssertError(new Error("Expected " + result + " to *not* be null")) : never
>                                                                        : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error("Expected " + result + " to *not* be null") : Error
>                                                      : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected " + result + " to *not* be null" : string
>                                           : ^^^^^^
>"Expected " + result : string
>                     : ^^^^^^
>"Expected " : "Expected "
>            : ^^^^^^^^^^^
>result : any
>       : ^^^
>" to *not* be null" : " to *not* be null"
>                    : ^^^^^^^^^^^^^^^^^^^
            }
        }

        export function compilerWarning(result: Compiler.CompilerResult, line: number, column: number, desc: string) {
>compilerWarning : (result: Compiler.CompilerResult, line: number, column: number, desc: string) => void
>                : ^      ^^                       ^^    ^^      ^^      ^^      ^^    ^^      ^^^^^^^^^
>result : Compiler.CompilerResult
>       : ^^^^^^^^^^^^^^^^^^^^^^^
>Compiler : any
>         : ^^^
>line : number
>     : ^^^^^^
>column : number
>       : ^^^^^^
>desc : string
>     : ^^^^^^

            if (!result.isErrorAt(line, column, desc)) {
>!result.isErrorAt(line, column, desc) : boolean
>                                      : ^^^^^^^
>result.isErrorAt(line, column, desc) : boolean
>                                     : ^^^^^^^
>result.isErrorAt : (line: number, column: number, message: string) => boolean
>                 : ^    ^^      ^^      ^^      ^^       ^^      ^^^^^^^^^^^^
>result : Compiler.CompilerResult
>       : ^^^^^^^^^^^^^^^^^^^^^^^
>isErrorAt : (line: number, column: number, message: string) => boolean
>          : ^    ^^      ^^      ^^      ^^       ^^      ^^^^^^^^^^^^
>line : number
>     : ^^^^^^
>column : number
>       : ^^^^^^
>desc : string
>     : ^^^^^^

                var actual = '';
>actual : string
>       : ^^^^^^
>'' : ""
>   : ^^

                result.errors.forEach(err => {
>result.errors.forEach(err => {                    actual = actual + '\n     ' + err.toString();                }) : void
>                                                                                                                  : ^^^^
>result.errors.forEach : (callbackfn: (value: Compiler.CompilerError, index: number, array: Compiler.CompilerError[]) => void, thisArg?: any) => void
>                      : ^          ^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>result.errors : Compiler.CompilerError[]
>              : ^^^^^^^^^^^^^^^^^^^^^^^^
>result : Compiler.CompilerResult
>       : ^^^^^^^^^^^^^^^^^^^^^^^
>errors : Compiler.CompilerError[]
>       : ^^^^^^^^^^^^^^^^^^^^^^^^
>forEach : (callbackfn: (value: Compiler.CompilerError, index: number, array: Compiler.CompilerError[]) => void, thisArg?: any) => void
>        : ^          ^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>err => {                    actual = actual + '\n     ' + err.toString();                } : (err: Compiler.CompilerError) => void
>                                                                                           : ^   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>err : Compiler.CompilerError
>    : ^^^^^^^^^^^^^^^^^^^^^^

                    actual = actual + '\n     ' + err.toString();
>actual = actual + '\n     ' + err.toString() : string
>                                             : ^^^^^^
>actual : string
>       : ^^^^^^
>actual + '\n     ' + err.toString() : string
>                                    : ^^^^^^
>actual + '\n     ' : string
>                   : ^^^^^^
>actual : string
>       : ^^^^^^
>'\n     ' : "\n     "
>          : ^^^^^^^^^
>err.toString() : string
>               : ^^^^^^
>err.toString : () => string
>             : ^^^^^^^^^^^^
>err : Compiler.CompilerError
>    : ^^^^^^^^^^^^^^^^^^^^^^
>toString : () => string
>         : ^^^^^^^^^^^^

                });

                throwAssertError(new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual));
>throwAssertError(new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual)) : never
>                                                                                                                                          : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual) : Error
>                                                                                                                        : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual : string
>                                                                                                             : ^^^^^^
>"Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " : string
>                                                                                                    : ^^^^^^
>"Expected compiler warning at (" + line + ", " + column + "): " + desc : string
>                                                                       : ^^^^^^
>"Expected compiler warning at (" + line + ", " + column + "): " : string
>                                                                : ^^^^^^
>"Expected compiler warning at (" + line + ", " + column : string
>                                                        : ^^^^^^
>"Expected compiler warning at (" + line + ", " : string
>                                               : ^^^^^^
>"Expected compiler warning at (" + line : string
>                                        : ^^^^^^
>"Expected compiler warning at (" : "Expected compiler warning at ("
>                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>line : number
>     : ^^^^^^
>", " : ", "
>     : ^^^^
>column : number
>       : ^^^^^^
>"): " : "): "
>      : ^^^^^
>desc : string
>     : ^^^^^^
>"\nActual errors follow: " : "\nActual errors follow: "
>                           : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
            }
        }

        export function noDiff(text1, text2) {
>noDiff : (text1: any, text2: any) => void
>       : ^     ^^^^^^^     ^^^^^^^^^^^^^^
>text1 : any
>      : ^^^
>text2 : any
>      : ^^^

            text1 = text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n");
>text1 = text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>                                                                : ^^^
>text1 : any
>      : ^^^
>text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>                                                        : ^^^
>text1.replace(/^\s+|\s+$/g, "").replace : any
>                                        : ^^^
>text1.replace(/^\s+|\s+$/g, "") : any
>                                : ^^^
>text1.replace : any
>              : ^^^
>text1 : any
>      : ^^^
>replace : any
>        : ^^^
>/^\s+|\s+$/g : RegExp
>             : ^^^^^^
>"" : ""
>   : ^^
>replace : any
>        : ^^^
>/\r\n?/g : RegExp
>         : ^^^^^^
>"\n" : "\n"
>     : ^^^^

            text2 = text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n");
>text2 = text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>                                                                : ^^^
>text2 : any
>      : ^^^
>text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>                                                        : ^^^
>text2.replace(/^\s+|\s+$/g, "").replace : any
>                                        : ^^^
>text2.replace(/^\s+|\s+$/g, "") : any
>                                : ^^^
>text2.replace : any
>              : ^^^
>text2 : any
>      : ^^^
>replace : any
>        : ^^^
>/^\s+|\s+$/g : RegExp
>             : ^^^^^^
>"" : ""
>   : ^^
>replace : any
>        : ^^^
>/\r\n?/g : RegExp
>         : ^^^^^^
>"\n" : "\n"
>     : ^^^^

            if (text1 !== text2) {
>text1 !== text2 : boolean
>                : ^^^^^^^
>text1 : any
>      : ^^^
>text2 : any
>      : ^^^

                var errorString = "";
>errorString : string
>            : ^^^^^^
>"" : ""
>   : ^^

                var text1Lines = text1.split(/\n/);
>text1Lines : any
>           : ^^^
>text1.split(/\n/) : any
>                  : ^^^
>text1.split : any
>            : ^^^
>text1 : any
>      : ^^^
>split : any
>      : ^^^
>/\n/ : RegExp
>     : ^^^^^^

                var text2Lines = text2.split(/\n/);
>text2Lines : any
>           : ^^^
>text2.split(/\n/) : any
>                  : ^^^
>text2.split : any
>            : ^^^
>text2 : any
>      : ^^^
>split : any
>      : ^^^
>/\n/ : RegExp
>     : ^^^^^^

                for (var i = 0; i < text1Lines.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < text1Lines.length : boolean
>                      : ^^^^^^^
>i : number
>  : ^^^^^^
>text1Lines.length : any
>                  : ^^^
>text1Lines : any
>           : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    if (text1Lines[i] !== text2Lines[i]) {
>text1Lines[i] !== text2Lines[i] : boolean
>                                : ^^^^^^^
>text1Lines[i] : any
>              : ^^^
>text1Lines : any
>           : ^^^
>i : number
>  : ^^^^^^
>text2Lines[i] : any
>              : ^^^
>text2Lines : any
>           : ^^^
>i : number
>  : ^^^^^^

                        errorString += "Difference at line " + (i + 1) + ":\n";
>errorString += "Difference at line " + (i + 1) + ":\n" : string
>                                                       : ^^^^^^
>errorString : string
>            : ^^^^^^
>"Difference at line " + (i + 1) + ":\n" : string
>                                        : ^^^^^^
>"Difference at line " + (i + 1) : string
>                                : ^^^^^^
>"Difference at line " : "Difference at line "
>                      : ^^^^^^^^^^^^^^^^^^^^^
>(i + 1) : number
>        : ^^^^^^
>i + 1 : number
>      : ^^^^^^
>i : number
>  : ^^^^^^
>1 : 1
>  : ^
>":\n" : ":\n"
>      : ^^^^^

                        errorString += "                  Left File: " + text1Lines[i] + "\n";
>errorString += "                  Left File: " + text1Lines[i] + "\n" : string
>                                                                      : ^^^^^^
>errorString : string
>            : ^^^^^^
>"                  Left File: " + text1Lines[i] + "\n" : string
>                                                       : ^^^^^^
>"                  Left File: " + text1Lines[i] : string
>                                                : ^^^^^^
>"                  Left File: " : "                  Left File: "
>                                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>text1Lines[i] : any
>              : ^^^
>text1Lines : any
>           : ^^^
>i : number
>  : ^^^^^^
>"\n" : "\n"
>     : ^^^^

                        errorString += "                 Right File: " + text2Lines[i] + "\n\n";
>errorString += "                 Right File: " + text2Lines[i] + "\n\n" : string
>                                                                        : ^^^^^^
>errorString : string
>            : ^^^^^^
>"                 Right File: " + text2Lines[i] + "\n\n" : string
>                                                         : ^^^^^^
>"                 Right File: " + text2Lines[i] : string
>                                                : ^^^^^^
>"                 Right File: " : "                 Right File: "
>                                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>text2Lines[i] : any
>              : ^^^
>text2Lines : any
>           : ^^^
>i : number
>  : ^^^^^^
>"\n\n" : "\n\n"
>       : ^^^^^^
                    }
                }
                throwAssertError(new Error(errorString));
>throwAssertError(new Error(errorString)) : never
>                                         : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error(errorString) : Error
>                       : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>errorString : string
>            : ^^^^^^
            }
        }

        export function arrayContains(arr: any[], contains: any[]) {
>arrayContains : (arr: any[], contains: any[]) => void
>              : ^   ^^     ^^        ^^     ^^^^^^^^^
>arr : any[]
>    : ^^^^^
>contains : any[]
>         : ^^^^^

            var found;
>found : any
>      : ^^^

            for (var i = 0; i < contains.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < contains.length : boolean
>                    : ^^^^^^^
>i : number
>  : ^^^^^^
>contains.length : number
>                : ^^^^^^
>contains : any[]
>         : ^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                found = false;
>found = false : false
>              : ^^^^^
>found : any
>      : ^^^
>false : false
>      : ^^^^^

                for (var j = 0; j < arr.length; j++) {
>j : number
>  : ^^^^^^
>0 : 0
>  : ^
>j < arr.length : boolean
>               : ^^^^^^^
>j : number
>  : ^^^^^^
>arr.length : number
>           : ^^^^^^
>arr : any[]
>    : ^^^^^
>length : number
>       : ^^^^^^
>j++ : number
>    : ^^^^^^
>j : number
>  : ^^^^^^

                    if (arr[j] === contains[i]) {
>arr[j] === contains[i] : boolean
>                       : ^^^^^^^
>arr[j] : any
>       : ^^^
>arr : any[]
>    : ^^^^^
>j : number
>  : ^^^^^^
>contains[i] : any
>            : ^^^
>contains : any[]
>         : ^^^^^
>i : number
>  : ^^^^^^

                        found = true;
>found = true : true
>             : ^^^^
>found : any
>      : ^^^
>true : true
>     : ^^^^

                        break;
                    }
                }

                if (!found) {
>!found : boolean
>       : ^^^^^^^
>found : any
>      : ^^^

                    throwAssertError(new Error("Expected array to contain \"" + contains[i] + "\""));
>throwAssertError(new Error("Expected array to contain \"" + contains[i] + "\"")) : never
>                                                                                 : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error("Expected array to contain \"" + contains[i] + "\"") : Error
>                                                               : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected array to contain \"" + contains[i] + "\"" : string
>                                                    : ^^^^^^
>"Expected array to contain \"" + contains[i] : string
>                                             : ^^^^^^
>"Expected array to contain \"" : "Expected array to contain \""
>                               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>contains[i] : any
>            : ^^^
>contains : any[]
>         : ^^^^^
>i : number
>  : ^^^^^^
>"\"" : "\""
>     : ^^^^
                }
            }
        }

        export function arrayContainsOnce(arr: any[], filter: (item: any) => boolean) {
>arrayContainsOnce : (arr: any[], filter: (item: any) => boolean) => void
>                  : ^   ^^     ^^      ^^                      ^^^^^^^^^
>arr : any[]
>    : ^^^^^
>filter : (item: any) => boolean
>       : ^    ^^   ^^^^^       
>item : any
>     : ^^^

            var foundCount = 0;
>foundCount : number
>           : ^^^^^^
>0 : 0
>  : ^

            for (var i = 0; i < arr.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < arr.length : boolean
>               : ^^^^^^^
>i : number
>  : ^^^^^^
>arr.length : number
>           : ^^^^^^
>arr : any[]
>    : ^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                if (filter(arr[i])) {
>filter(arr[i]) : boolean
>               : ^^^^^^^
>filter : (item: any) => boolean
>       : ^    ^^   ^^^^^       
>arr[i] : any
>       : ^^^
>arr : any[]
>    : ^^^^^
>i : number
>  : ^^^^^^

                    foundCount++;
>foundCount++ : number
>             : ^^^^^^
>foundCount : number
>           : ^^^^^^
                }
            }

            if (foundCount !== 1) {
>foundCount !== 1 : boolean
>                 : ^^^^^^^
>foundCount : number
>           : ^^^^^^
>1 : 1
>  : ^

                throwAssertError(new Error("Expected array to match element only once (instead of " + foundCount + " times)"));
>throwAssertError(new Error("Expected array to match element only once (instead of " + foundCount + " times)")) : never
>                                                                                                               : ^^^^^
>throwAssertError : (error: Error) => never
>                 : ^     ^^     ^^^^^^^^^^
>new Error("Expected array to match element only once (instead of " + foundCount + " times)") : Error
>                                                                                             : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected array to match element only once (instead of " + foundCount + " times)" : string
>                                                                                  : ^^^^^^
>"Expected array to match element only once (instead of " + foundCount : string
>                                                                      : ^^^^^^
>"Expected array to match element only once (instead of " : "Expected array to match element only once (instead of "
>                                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>foundCount : number
>           : ^^^^^^
>" times)" : " times)"
>          : ^^^^^^^^^
            }
        }
    }

    /** Splits the given string on \r\n or on only \n if that fails */
    export function splitContentByNewlines(content: string) {
>splitContentByNewlines : (content: string) => string[]
>                       : ^       ^^      ^^^^^^^^^^^^^
>content : string
>        : ^^^^^^

        // Split up the input file by line
        // Note: IE JS engine incorrectly handles consecutive delimiters here when using RegExp split, so
        // we have to string-based splitting instead and try to figure out the delimiting chars
        var lines = content.split('\r\n');
>lines : string[]
>      : ^^^^^^^^
>content.split('\r\n') : string[]
>                      : ^^^^^^^^
>content.split : (separator: string | RegExp, limit?: number) => string[]
>              : ^         ^^               ^^     ^^^      ^^^^^        
>content : string
>        : ^^^^^^
>split : (separator: string | RegExp, limit?: number) => string[]
>      : ^         ^^               ^^     ^^^      ^^^^^        
>'\r\n' : "\r\n"
>       : ^^^^^^

        if (lines.length === 1) {
>lines.length === 1 : boolean
>                   : ^^^^^^^
>lines.length : number
>             : ^^^^^^
>lines : string[]
>      : ^^^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^

            lines = content.split('\n');
>lines = content.split('\n') : string[]
>                            : ^^^^^^^^
>lines : string[]
>      : ^^^^^^^^
>content.split('\n') : string[]
>                    : ^^^^^^^^
>content.split : (separator: string | RegExp, limit?: number) => string[]
>              : ^         ^^               ^^     ^^^      ^^^^^        
>content : string
>        : ^^^^^^
>split : (separator: string | RegExp, limit?: number) => string[]
>      : ^         ^^               ^^     ^^^      ^^^^^        
>'\n' : "\n"
>     : ^^^^
        }
        return lines;
>lines : string[]
>      : ^^^^^^^^
    }

    /** Reads a file under /tests */
    export function readFile(path: string) {
>readFile : (path: string) => any
>         : ^    ^^      ^^^^^^^^
>path : string
>     : ^^^^^^

        if (path.indexOf('tests') < 0) {
>path.indexOf('tests') < 0 : boolean
>                          : ^^^^^^^
>path.indexOf('tests') : number
>                      : ^^^^^^
>path.indexOf : (searchString: string, position?: number) => number
>             : ^            ^^      ^^        ^^^      ^^^^^      
>path : string
>     : ^^^^^^
>indexOf : (searchString: string, position?: number) => number
>        : ^            ^^      ^^        ^^^      ^^^^^      
>'tests' : "tests"
>        : ^^^^^^^
>0 : 0
>  : ^

            path = "tests/" + path;
>path = "tests/" + path : string
>                       : ^^^^^^
>path : string
>     : ^^^^^^
>"tests/" + path : string
>                : ^^^^^^
>"tests/" : "tests/"
>         : ^^^^^^^^
>path : string
>     : ^^^^^^
        }

        var content = IO.readFile(Harness.userSpecifiedroot + path);
>content : any
>        : ^^^
>IO.readFile(Harness.userSpecifiedroot + path) : any
>                                              : ^^^
>IO.readFile : any
>            : ^^^
>IO : IIO
>   : ^^^
>readFile : any
>         : ^^^
>Harness.userSpecifiedroot + path : string
>                                 : ^^^^^^
>Harness.userSpecifiedroot : string
>                          : ^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>userSpecifiedroot : string
>                  : ^^^^^^
>path : string
>     : ^^^^^^

        if (content == null) {
>content == null : boolean
>                : ^^^^^^^
>content : any
>        : ^^^

            throw new Error("failed to read file at: '" + Harness.userSpecifiedroot + path + "'");
>new Error("failed to read file at: '" + Harness.userSpecifiedroot + path + "'") : Error
>                                                                                : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"failed to read file at: '" + Harness.userSpecifiedroot + path + "'" : string
>                                                                     : ^^^^^^
>"failed to read file at: '" + Harness.userSpecifiedroot + path : string
>                                                               : ^^^^^^
>"failed to read file at: '" + Harness.userSpecifiedroot : string
>                                                        : ^^^^^^
>"failed to read file at: '" : "failed to read file at: '"
>                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Harness.userSpecifiedroot : string
>                          : ^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>userSpecifiedroot : string
>                  : ^^^^^^
>path : string
>     : ^^^^^^
>"'" : "'"
>    : ^^^
        }

        return content;
>content : any
>        : ^^^
    }

    // Logger
    export interface ILogger {
        start: (fileName?: string, priority?: number) => void;
>start : (fileName?: string, priority?: number) => void
>      : ^        ^^^      ^^        ^^^      ^^^^^    
>fileName : string
>         : ^^^^^^
>priority : number
>         : ^^^^^^

        end: (fileName?: string) => void;
>end : (fileName?: string) => void
>    : ^        ^^^      ^^^^^    
>fileName : string
>         : ^^^^^^

        scenarioStart: (scenario: IScenarioMetadata) => void;
>scenarioStart : (scenario: IScenarioMetadata) => void
>              : ^        ^^                 ^^^^^    
>scenario : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^

        scenarioEnd: (scenario: IScenarioMetadata, error?: Error) => void;
>scenarioEnd : (scenario: IScenarioMetadata, error?: Error) => void
>            : ^        ^^                 ^^     ^^^     ^^^^^    
>scenario : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^
>error : Error
>      : ^^^^^

        testStart: (test: ITestMetadata) => void;
>testStart : (test: ITestMetadata) => void
>          : ^    ^^             ^^^^^    
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        pass: (test: ITestMetadata) => void;
>pass : (test: ITestMetadata) => void
>     : ^    ^^             ^^^^^    
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        bug: (test: ITestMetadata) => void;
>bug : (test: ITestMetadata) => void
>    : ^    ^^             ^^^^^    
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        fail: (test: ITestMetadata) => void;
>fail : (test: ITestMetadata) => void
>     : ^    ^^             ^^^^^    
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        error: (test: ITestMetadata, error: Error) => void;
>error : (test: ITestMetadata, error: Error) => void
>      : ^    ^^             ^^     ^^     ^^^^^    
>test : ITestMetadata
>     : ^^^^^^^^^^^^^
>error : Error
>      : ^^^^^

        comment: (comment: string) => void;
>comment : (comment: string) => void
>        : ^       ^^      ^^^^^    
>comment : string
>        : ^^^^^^

        verify: (test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) => void;
>verify : (test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) => void
>       : ^    ^^             ^^      ^^       ^^      ^^   ^^        ^^   ^^       ^^      ^^^^^    
>test : ITestMetadata
>     : ^^^^^^^^^^^^^
>passed : boolean
>       : ^^^^^^^
>actual : any
>       : ^^^
>expected : any
>         : ^^^
>message : string
>        : ^^^^^^
    }

    export class Logger implements ILogger {
>Logger : Logger
>       : ^^^^^^

        public start(fileName?: string, priority?: number) { }
>start : (fileName?: string, priority?: number) => void
>      : ^        ^^^      ^^        ^^^      ^^^^^^^^^
>fileName : string
>         : ^^^^^^
>priority : number
>         : ^^^^^^

        public end(fileName?: string) { }
>end : (fileName?: string) => void
>    : ^        ^^^      ^^^^^^^^^
>fileName : string
>         : ^^^^^^

        public scenarioStart(scenario: IScenarioMetadata) { }
>scenarioStart : (scenario: IScenarioMetadata) => void
>              : ^        ^^                 ^^^^^^^^^
>scenario : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^

        public scenarioEnd(scenario: IScenarioMetadata, error?: Error) { }
>scenarioEnd : (scenario: IScenarioMetadata, error?: Error) => void
>            : ^        ^^                 ^^     ^^^     ^^^^^^^^^
>scenario : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^
>error : Error
>      : ^^^^^

        public testStart(test: ITestMetadata) { }
>testStart : (test: ITestMetadata) => void
>          : ^    ^^             ^^^^^^^^^
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        public pass(test: ITestMetadata) { }
>pass : (test: ITestMetadata) => void
>     : ^    ^^             ^^^^^^^^^
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        public bug(test: ITestMetadata) { }
>bug : (test: ITestMetadata) => void
>    : ^    ^^             ^^^^^^^^^
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        public fail(test: ITestMetadata) { }
>fail : (test: ITestMetadata) => void
>     : ^    ^^             ^^^^^^^^^
>test : ITestMetadata
>     : ^^^^^^^^^^^^^

        public error(test: ITestMetadata, error: Error) { }
>error : (test: ITestMetadata, error: Error) => void
>      : ^    ^^             ^^     ^^     ^^^^^^^^^
>test : ITestMetadata
>     : ^^^^^^^^^^^^^
>error : Error
>      : ^^^^^

        public comment(comment: string) { }
>comment : (comment: string) => void
>        : ^       ^^      ^^^^^^^^^
>comment : string
>        : ^^^^^^

        public verify(test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) { }
>verify : (test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) => void
>       : ^    ^^             ^^      ^^       ^^      ^^   ^^        ^^   ^^       ^^      ^^^^^^^^^
>test : ITestMetadata
>     : ^^^^^^^^^^^^^
>passed : boolean
>       : ^^^^^^^
>actual : any
>       : ^^^
>expected : any
>         : ^^^
>message : string
>        : ^^^^^^
    }

    // Logger-related functions
    var loggers: ILogger[] = [];
>loggers : ILogger[]
>        : ^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

    export function registerLogger(logger: ILogger) {
>registerLogger : (logger: ILogger) => void
>               : ^      ^^       ^^^^^^^^^
>logger : ILogger
>       : ^^^^^^^

        loggers.push(logger);
>loggers.push(logger) : number
>                     : ^^^^^^
>loggers.push : (...items: ILogger[]) => number
>             : ^^^^     ^^^^^^^^^^^^^^^^      
>loggers : ILogger[]
>        : ^^^^^^^^^
>push : (...items: ILogger[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^      
>logger : ILogger
>       : ^^^^^^^
    }
    export function emitLog(field: string, ...params: any[]) {
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>field : string
>      : ^^^^^^
>params : any[]
>       : ^^^^^

        for (var i = 0; i < loggers.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < loggers.length : boolean
>                   : ^^^^^^^
>i : number
>  : ^^^^^^
>loggers.length : number
>               : ^^^^^^
>loggers : ILogger[]
>        : ^^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

            if (typeof loggers[i][field] === 'function') {
>typeof loggers[i][field] === 'function' : boolean
>                                        : ^^^^^^^
>typeof loggers[i][field] : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>loggers[i][field] : any
>                  : ^^^
>loggers[i] : ILogger
>           : ^^^^^^^
>loggers : ILogger[]
>        : ^^^^^^^^^
>i : number
>  : ^^^^^^
>field : string
>      : ^^^^^^
>'function' : "function"
>           : ^^^^^^^^^^

                loggers[i][field].apply(loggers[i], params);
>loggers[i][field].apply(loggers[i], params) : any
>                                            : ^^^
>loggers[i][field].apply : any
>                        : ^^^
>loggers[i][field] : any
>                  : ^^^
>loggers[i] : ILogger
>           : ^^^^^^^
>loggers : ILogger[]
>        : ^^^^^^^^^
>i : number
>  : ^^^^^^
>field : string
>      : ^^^^^^
>apply : any
>      : ^^^
>loggers[i] : ILogger
>           : ^^^^^^^
>loggers : ILogger[]
>        : ^^^^^^^^^
>i : number
>  : ^^^^^^
>params : any[]
>       : ^^^^^
            }
        }
    }

    // BDD Framework
    export interface IDone {
        (e?: Error): void;
>e : Error
>  : ^^^^^
    }
    export class Runnable {
>Runnable : Runnable
>         : ^^^^^^^^

        constructor(public description: string, public block: any) { }
>description : string
>            : ^^^^^^
>block : any
>      : ^^^

        // The current stack of Runnable objects
        static currentStack: Runnable[] = [];
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        // The error, if any, that occurred when running 'block'
        public error: Error = null;
>error : Error
>      : ^^^^^

        // Whether or not this object has any failures (including in its descendants)
        public passed = null;
>passed : any
>       : ^^^

        // A list of bugs impacting this object
        public bugs: string[] = [];
>bugs : string[]
>     : ^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        // A list of all our child Runnables
        public children: Runnable[] = [];
>children : Runnable[]
>         : ^^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        public addChild(child: Runnable): void {
>addChild : (child: Runnable) => void
>         : ^     ^^        ^^^^^    
>child : Runnable
>      : ^^^^^^^^

            this.children.push(child);
>this.children.push(child) : number
>                          : ^^^^^^
>this.children.push : (...items: Runnable[]) => number
>                   : ^^^^     ^^^^^^^^^^^^^^^^^      
>this.children : Runnable[]
>              : ^^^^^^^^^^
>this : this
>     : ^^^^
>children : Runnable[]
>         : ^^^^^^^^^^
>push : (...items: Runnable[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^      
>child : Runnable
>      : ^^^^^^^^
        }

        /** Call function fn, which may take a done function and may possibly execute
         *  asynchronously, calling done when finished. Returns true or false depending
         *  on whether the function was asynchronous or not.
         */
        public call(fn: (done?: IDone) => void , done: IDone) {
>call : (fn: (done?: IDone) => void, done: IDone) => boolean
>     : ^  ^^                      ^^    ^^     ^^^^^^^^^^^^
>fn : (done?: IDone) => void
>   : ^    ^^^     ^^^^^    
>done : IDone
>     : ^^^^^
>done : IDone
>     : ^^^^^

            var isAsync = true;
>isAsync : boolean
>        : ^^^^^^^
>true : true
>     : ^^^^

            try {
                if (fn.length === 0) {
>fn.length === 0 : boolean
>                : ^^^^^^^
>fn.length : number
>          : ^^^^^^
>fn : (done?: IDone) => void
>   : ^    ^^^     ^^^^^    
>length : number
>       : ^^^^^^
>0 : 0
>  : ^

                    // No async.
                    fn();
>fn() : void
>     : ^^^^
>fn : (done?: IDone) => void
>   : ^    ^^^     ^^^^^    

                    done();
>done() : void
>       : ^^^^
>done : IDone
>     : ^^^^^

                    return false;
>false : false
>      : ^^^^^

                } else {
                    // Possibly async

                    Runnable.pushGlobalErrorHandler(done);
>Runnable.pushGlobalErrorHandler(done) : void
>                                      : ^^^^
>Runnable.pushGlobalErrorHandler : (done: IDone) => void
>                                : ^    ^^     ^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>pushGlobalErrorHandler : (done: IDone) => void
>                       : ^    ^^     ^^^^^^^^^
>done : IDone
>     : ^^^^^

                    fn(function () {
>fn(function () {                        isAsync = false; // If we execute synchronously, this will get called before the return below.                        Runnable.popGlobalErrorHandler();                        done();                    }) : void
>                                                                                                                                                                                                                                                     : ^^^^
>fn : (done?: IDone) => void
>   : ^    ^^^     ^^^^^    
>function () {                        isAsync = false; // If we execute synchronously, this will get called before the return below.                        Runnable.popGlobalErrorHandler();                        done();                    } : () => void
>                                                                                                                                                                                                                                                 : ^^^^^^^^^^

                        isAsync = false; // If we execute synchronously, this will get called before the return below.
>isAsync = false : false
>                : ^^^^^
>isAsync : boolean
>        : ^^^^^^^
>false : false
>      : ^^^^^

                        Runnable.popGlobalErrorHandler();
>Runnable.popGlobalErrorHandler() : void
>                                 : ^^^^
>Runnable.popGlobalErrorHandler : () => void
>                               : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>popGlobalErrorHandler : () => void
>                      : ^^^^^^^^^^

                        done();
>done() : void
>       : ^^^^
>done : IDone
>     : ^^^^^

                    });

                    return isAsync;
>isAsync : true
>        : ^^^^
                }

            } catch (e) {
>e : any
>  : ^^^

                done(e);
>done(e) : void
>        : ^^^^
>done : IDone
>     : ^^^^^
>e : any
>  : ^^^

                return false;
>false : false
>      : ^^^^^
            }
        }

        public run(done: IDone) { }
>run : (done: IDone) => void
>    : ^    ^^     ^^^^^^^^^
>done : IDone
>     : ^^^^^

        public runBlock(done: IDone) {
>runBlock : (done: IDone) => boolean
>         : ^    ^^     ^^^^^^^^^^^^
>done : IDone
>     : ^^^^^

            return this.call(this.block, done);
>this.call(this.block, done) : boolean
>                            : ^^^^^^^
>this.call : (fn: (done?: IDone) => void, done: IDone) => boolean
>          : ^  ^^                      ^^    ^^     ^^^^^^^^^^^^
>this : this
>     : ^^^^
>call : (fn: (done?: IDone) => void, done: IDone) => boolean
>     : ^  ^^                      ^^    ^^     ^^^^^^^^^^^^
>this.block : any
>           : ^^^
>this : this
>     : ^^^^
>block : any
>      : ^^^
>done : IDone
>     : ^^^^^
        }

        public runChild(index: number, done: IDone) {
>runChild : (index: number, done: IDone) => boolean
>         : ^     ^^      ^^    ^^     ^^^^^^^^^^^^
>index : number
>      : ^^^^^^
>done : IDone
>     : ^^^^^

            return this.call(<any>((done) => this.children[index].run(done)), done);
>this.call(<any>((done) => this.children[index].run(done)), done) : boolean
>                                                                 : ^^^^^^^
>this.call : (fn: (done?: IDone) => void, done: IDone) => boolean
>          : ^  ^^                      ^^    ^^     ^^^^^^^^^^^^
>this : this
>     : ^^^^
>call : (fn: (done?: IDone) => void, done: IDone) => boolean
>     : ^  ^^                      ^^    ^^     ^^^^^^^^^^^^
><any>((done) => this.children[index].run(done)) : any
>                                                : ^^^
>((done) => this.children[index].run(done)) : (done: any) => void
>                                           : ^    ^^^^^^^^^^^^^^
>(done) => this.children[index].run(done) : (done: any) => void
>                                         : ^    ^^^^^^^^^^^^^^
>done : any
>     : ^^^
>this.children[index].run(done) : void
>                               : ^^^^
>this.children[index].run : (done: IDone) => void
>                         : ^    ^^     ^^^^^^^^^
>this.children[index] : Runnable
>                     : ^^^^^^^^
>this.children : Runnable[]
>              : ^^^^^^^^^^
>this : this
>     : ^^^^
>children : Runnable[]
>         : ^^^^^^^^^^
>index : number
>      : ^^^^^^
>run : (done: IDone) => void
>    : ^    ^^     ^^^^^^^^^
>done : any
>     : ^^^
>done : IDone
>     : ^^^^^
        }

        static errorHandlerStack: { (e: Error): void; }[] = [];
>errorHandlerStack : ((e: Error) => void)[]
>                  : ^^ ^^     ^^^^^    ^^^
>e : Error
>  : ^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        static pushGlobalErrorHandler(done: IDone) {
>pushGlobalErrorHandler : (done: IDone) => void
>                       : ^    ^^     ^^^^^^^^^
>done : IDone
>     : ^^^^^

            errorHandlerStack.push(function (e) {
>errorHandlerStack.push(function (e) {                done(e);            }) : any
>                                                                            : ^^^
>errorHandlerStack.push : any
>                       : ^^^
>errorHandlerStack : any
>                  : ^^^
>push : any
>     : ^^^
>function (e) {                done(e);            } : (e: any) => void
>                                                    : ^ ^^^^^^^^^^^^^^
>e : any
>  : ^^^

                done(e);
>done(e) : void
>        : ^^^^
>done : IDone
>     : ^^^^^
>e : any
>  : ^^^

            });
        }

        static popGlobalErrorHandler() {
>popGlobalErrorHandler : () => void
>                      : ^^^^^^^^^^

            errorHandlerStack.pop();
>errorHandlerStack.pop() : any
>                        : ^^^
>errorHandlerStack.pop : any
>                      : ^^^
>errorHandlerStack : any
>                  : ^^^
>pop : any
>    : ^^^
        }

        static handleError(e: Error) {
>handleError : (e: Error) => void
>            : ^ ^^     ^^^^^^^^^
>e : Error
>  : ^^^^^

            if (errorHandlerStack.length === 0) {
>errorHandlerStack.length === 0 : boolean
>                               : ^^^^^^^
>errorHandlerStack.length : any
>                         : ^^^
>errorHandlerStack : any
>                  : ^^^
>length : any
>       : ^^^
>0 : 0
>  : ^

                IO.printLine('Global error: ' + e);
>IO.printLine('Global error: ' + e) : any
>                                   : ^^^
>IO.printLine : any
>             : ^^^
>IO : IIO
>   : ^^^
>printLine : any
>          : ^^^
>'Global error: ' + e : string
>                     : ^^^^^^
>'Global error: ' : "Global error: "
>                 : ^^^^^^^^^^^^^^^^
>e : Error
>  : ^^^^^

            } else {
                errorHandlerStack[errorHandlerStack.length - 1](e);
>errorHandlerStack[errorHandlerStack.length - 1](e) : any
>                                                   : ^^^
>errorHandlerStack[errorHandlerStack.length - 1] : any
>                                                : ^^^
>errorHandlerStack : any
>                  : ^^^
>errorHandlerStack.length - 1 : number
>                             : ^^^^^^
>errorHandlerStack.length : any
>                         : ^^^
>errorHandlerStack : any
>                  : ^^^
>length : any
>       : ^^^
>1 : 1
>  : ^
>e : Error
>  : ^^^^^
            }
        }
    }
    export class TestCase extends Runnable {
>TestCase : TestCase
>         : ^^^^^^^^
>Runnable : Runnable
>         : ^^^^^^^^

        public description: string;
>description : string
>            : ^^^^^^

        public block;
>block : any
>      : ^^^

        constructor(description: string, block: any) {
>description : string
>            : ^^^^^^
>block : any
>      : ^^^

            super(description, block);
>super(description, block) : void
>                          : ^^^^
>super : typeof Runnable
>      : ^^^^^^^^^^^^^^^
>description : string
>            : ^^^^^^
>block : any
>      : ^^^

            this.description = description;
>this.description = description : string
>                               : ^^^^^^
>this.description : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>description : string
>            : ^^^^^^
>description : string
>            : ^^^^^^

            this.block = block;
>this.block = block : any
>                   : ^^^
>this.block : any
>           : ^^^
>this : this
>     : ^^^^
>block : any
>      : ^^^
>block : any
>      : ^^^
        }

        public addChild(child: Runnable): void {
>addChild : (child: Runnable) => void
>         : ^     ^^        ^^^^^    
>child : Runnable
>      : ^^^^^^^^

            throw new Error("Testcases may not be nested inside other testcases");
>new Error("Testcases may not be nested inside other testcases") : Error
>                                                                : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Testcases may not be nested inside other testcases" : "Testcases may not be nested inside other testcases"
>                                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        }

        /** Run the test case block and fail the test if it raised an error. If no error is raised, the test passes. */
        public run(done: IDone) {
>run : (done: IDone) => void
>    : ^    ^^     ^^^^^^^^^
>done : IDone
>     : ^^^^^

            var that = this;
>that : this
>     : ^^^^
>this : this
>     : ^^^^

            Runnable.currentStack.push(this);
>Runnable.currentStack.push(this) : number
>                                 : ^^^^^^
>Runnable.currentStack.push : (...items: Runnable[]) => number
>                           : ^^^^     ^^^^^^^^^^^^^^^^^      
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>push : (...items: Runnable[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^      
>this : this
>     : ^^^^

            emitLog('testStart', { desc: this.description });
>emitLog('testStart', { desc: this.description }) : void
>                                                 : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'testStart' : "testStart"
>            : ^^^^^^^^^^^
>{ desc: this.description } : { desc: string; }
>                           : ^^^^^^^^^^^^^^^^^
>desc : string
>     : ^^^^^^
>this.description : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>description : string
>            : ^^^^^^

            if (this.block) {
>this.block : any
>           : ^^^
>this : this
>     : ^^^^
>block : any
>      : ^^^

                var async = this.runBlock(<any>function (e) {
>async : boolean
>      : ^^^^^^^
>this.runBlock(<any>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                }) : boolean
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : ^^^^^^^
>this.runBlock : (done: IDone) => boolean
>              : ^    ^^     ^^^^^^^^^^^^
>this : this
>     : ^^^^
>runBlock : (done: IDone) => boolean
>         : ^    ^^     ^^^^^^^^^^^^
><any>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                } : any
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               : ^^^
>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                } : (e: any) => void
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          : ^ ^^^^^^^^^^^^^^
>e : any
>  : ^^^

                    if (e) {
>e : any
>  : ^^^

                        that.passed = false;
>that.passed = false : false
>                    : ^^^^^
>that.passed : any
>            : ^^^
>that : this
>     : ^^^^
>passed : any
>       : ^^^
>false : false
>      : ^^^^^

                        that.error = e;
>that.error = e : any
>               : ^^^
>that.error : Error
>           : ^^^^^
>that : this
>     : ^^^^
>error : Error
>      : ^^^^^
>e : any
>  : ^^^

                        emitLog('error', { desc: this.description, pass: false }, e);
>emitLog('error', { desc: this.description, pass: false }, e) : void
>                                                             : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'error' : "error"
>        : ^^^^^^^
>{ desc: this.description, pass: false } : { desc: any; pass: boolean; }
>                                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>desc : any
>     : ^^^
>this.description : any
>                 : ^^^
>this : any
>     : ^^^
>description : any
>            : ^^^
>pass : boolean
>     : ^^^^^^^
>false : false
>      : ^^^^^
>e : any
>  : ^^^

                    } else {
                        that.passed = true;
>that.passed = true : true
>                   : ^^^^
>that.passed : any
>            : ^^^
>that : this
>     : ^^^^
>passed : any
>       : ^^^
>true : true
>     : ^^^^

                        emitLog('pass', { desc: this.description, pass: true });
>emitLog('pass', { desc: this.description, pass: true }) : void
>                                                        : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'pass' : "pass"
>       : ^^^^^^
>{ desc: this.description, pass: true } : { desc: any; pass: boolean; }
>                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>desc : any
>     : ^^^
>this.description : any
>                 : ^^^
>this : any
>     : ^^^
>description : any
>            : ^^^
>pass : boolean
>     : ^^^^^^^
>true : true
>     : ^^^^
                    }

                    Runnable.currentStack.pop();
>Runnable.currentStack.pop() : Runnable
>                            : ^^^^^^^^
>Runnable.currentStack.pop : () => Runnable
>                          : ^^^^^^^^^^^^^^
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>pop : () => Runnable
>    : ^^^^^^^^^^^^^^

                    done()
>done() : void
>       : ^^^^
>done : IDone
>     : ^^^^^

                });
            }

        }
    }

    export class Scenario extends Runnable {
>Scenario : Scenario
>         : ^^^^^^^^
>Runnable : Runnable
>         : ^^^^^^^^

        public description: string;
>description : string
>            : ^^^^^^

        public block;
>block : any
>      : ^^^

        constructor(description: string, block: any) {
>description : string
>            : ^^^^^^
>block : any
>      : ^^^

            super(description, block);
>super(description, block) : void
>                          : ^^^^
>super : typeof Runnable
>      : ^^^^^^^^^^^^^^^
>description : string
>            : ^^^^^^
>block : any
>      : ^^^

            this.description = description;
>this.description = description : string
>                               : ^^^^^^
>this.description : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>description : string
>            : ^^^^^^
>description : string
>            : ^^^^^^

            this.block = block;
>this.block = block : any
>                   : ^^^
>this.block : any
>           : ^^^
>this : this
>     : ^^^^
>block : any
>      : ^^^
>block : any
>      : ^^^
        }

        /** Run the block, and if the block doesn't raise an error, run the children. */
        public run(done: IDone) {
>run : (done: IDone) => void
>    : ^    ^^     ^^^^^^^^^
>done : IDone
>     : ^^^^^

            var that = this;
>that : this
>     : ^^^^
>this : this
>     : ^^^^

            Runnable.currentStack.push(this);
>Runnable.currentStack.push(this) : number
>                                 : ^^^^^^
>Runnable.currentStack.push : (...items: Runnable[]) => number
>                           : ^^^^     ^^^^^^^^^^^^^^^^^      
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>push : (...items: Runnable[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^      
>this : this
>     : ^^^^

            emitLog('scenarioStart', { desc: this.description });
>emitLog('scenarioStart', { desc: this.description }) : void
>                                                     : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'scenarioStart' : "scenarioStart"
>                : ^^^^^^^^^^^^^^^
>{ desc: this.description } : { desc: string; }
>                           : ^^^^^^^^^^^^^^^^^
>desc : string
>     : ^^^^^^
>this.description : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>description : string
>            : ^^^^^^

            var async = this.runBlock(<any>function (e) {
>async : boolean
>      : ^^^^^^^
>this.runBlock(<any>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            }) : boolean
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  : ^^^^^^^
>this.runBlock : (done: IDone) => boolean
>              : ^    ^^     ^^^^^^^^^^^^
>this : this
>     : ^^^^
>runBlock : (done: IDone) => boolean
>         : ^    ^^     ^^^^^^^^^^^^
><any>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            } : any
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   : ^^^
>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            } : (e: any) => void
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : ^ ^^^^^^^^^^^^^^
>e : any
>  : ^^^

                Runnable.currentStack.pop();
>Runnable.currentStack.pop() : Runnable
>                            : ^^^^^^^^
>Runnable.currentStack.pop : () => Runnable
>                          : ^^^^^^^^^^^^^^
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>pop : () => Runnable
>    : ^^^^^^^^^^^^^^

                if (e) {
>e : any
>  : ^^^

                    that.passed = false;
>that.passed = false : false
>                    : ^^^^^
>that.passed : any
>            : ^^^
>that : this
>     : ^^^^
>passed : any
>       : ^^^
>false : false
>      : ^^^^^

                    that.error = e;
>that.error = e : any
>               : ^^^
>that.error : Error
>           : ^^^^^
>that : this
>     : ^^^^
>error : Error
>      : ^^^^^
>e : any
>  : ^^^

                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };
>metadata : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^
>{ id: undefined, desc: this.description, pass: false, bugs: assert.bugIds } : { id: undefined; desc: any; pass: false; bugs: any; }
>                                                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>id : undefined
>   : ^^^^^^^^^
>undefined : undefined
>          : ^^^^^^^^^
>desc : any
>     : ^^^
>this.description : any
>                 : ^^^
>this : any
>     : ^^^
>description : any
>            : ^^^
>pass : false
>     : ^^^^^
>false : false
>      : ^^^^^
>bugs : any
>     : ^^^
>assert.bugIds : any
>              : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>bugIds : any
>       : ^^^

                    // Report all bugs affecting this scenario
                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
>assert.bugIds.forEach(desc => emitLog('bug', metadata, desc)) : any
>                                                              : ^^^
>assert.bugIds.forEach : any
>                      : ^^^
>assert.bugIds : any
>              : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>bugIds : any
>       : ^^^
>forEach : any
>        : ^^^
>desc => emitLog('bug', metadata, desc) : (desc: any) => void
>                                       : ^    ^^^^^^^^^^^^^^
>desc : any
>     : ^^^
>emitLog('bug', metadata, desc) : void
>                               : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'bug' : "bug"
>      : ^^^^^
>metadata : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^
>desc : any
>     : ^^^

                    emitLog('scenarioEnd', metadata, e);
>emitLog('scenarioEnd', metadata, e) : void
>                                    : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'scenarioEnd' : "scenarioEnd"
>              : ^^^^^^^^^^^^^
>metadata : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^
>e : any
>  : ^^^

                    done();
>done() : void
>       : ^^^^
>done : IDone
>     : ^^^^^

                } else {
                    that.passed = true; // so far so good.
>that.passed = true : true
>                   : ^^^^
>that.passed : any
>            : ^^^
>that : this
>     : ^^^^
>passed : any
>       : ^^^
>true : true
>     : ^^^^

                    that.runChildren(done);
>that.runChildren(done) : void
>                       : ^^^^
>that.runChildren : (done: IDone, index?: number) => void
>                 : ^    ^^     ^^     ^^^^^^^^^^^^^^^^^^
>that : this
>     : ^^^^
>runChildren : (done: IDone, index?: number) => void
>            : ^    ^^     ^^     ^^^^^^^^^^^^^^^^^^
>done : IDone
>     : ^^^^^
                }
            });
        }

        /** Run the children of the scenario (other scenarios and test cases). If any fail,
         *  set this scenario to failed. Synchronous tests will run synchronously without
         *  adding stack frames.
         */
        public runChildren(done: IDone, index = 0) {
>runChildren : (done: IDone, index?: number) => void
>            : ^    ^^     ^^     ^^^^^^^^^^^^^^^^^^
>done : IDone
>     : ^^^^^
>index : number
>      : ^^^^^^
>0 : 0
>  : ^

            var that = this;
>that : this
>     : ^^^^
>this : this
>     : ^^^^

            var async = false;
>async : boolean
>      : ^^^^^^^
>false : false
>      : ^^^^^

            for (; index < this.children.length; index++) {
>index < this.children.length : boolean
>                             : ^^^^^^^
>index : number
>      : ^^^^^^
>this.children.length : number
>                     : ^^^^^^
>this.children : Runnable[]
>              : ^^^^^^^^^^
>this : this
>     : ^^^^
>children : Runnable[]
>         : ^^^^^^^^^^
>length : number
>       : ^^^^^^
>index++ : number
>        : ^^^^^^
>index : number
>      : ^^^^^^

                async = this.runChild(index, <any>function (e) {
>async = this.runChild(index, <any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                }) : boolean
>                                                                                                                                                                                                                                        : ^^^^^^^
>async : boolean
>      : ^^^^^^^
>this.runChild(index, <any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                }) : boolean
>                                                                                                                                                                                                                                : ^^^^^^^
>this.runChild : (index: number, done: IDone) => boolean
>              : ^     ^^      ^^    ^^     ^^^^^^^^^^^^
>this : this
>     : ^^^^
>runChild : (index: number, done: IDone) => boolean
>         : ^     ^^      ^^    ^^     ^^^^^^^^^^^^
>index : number
>      : ^^^^^^
><any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                } : any
>                                                                                                                                                                                                          : ^^^
>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                } : (e: any) => void
>                                                                                                                                                                                                     : ^ ^^^^^^^^^^^^^^
>e : any
>  : ^^^

                    that.passed = that.passed && that.children[index].passed;
>that.passed = that.passed && that.children[index].passed : any
>                                                         : ^^^
>that.passed : any
>            : ^^^
>that : this
>     : ^^^^
>passed : any
>       : ^^^
>that.passed && that.children[index].passed : any
>                                           : ^^^
>that.passed : any
>            : ^^^
>that : this
>     : ^^^^
>passed : any
>       : ^^^
>that.children[index].passed : any
>                            : ^^^
>that.children[index] : Runnable
>                     : ^^^^^^^^
>that.children : Runnable[]
>              : ^^^^^^^^^^
>that : this
>     : ^^^^
>children : Runnable[]
>         : ^^^^^^^^^^
>index : number
>      : ^^^^^^
>passed : any
>       : ^^^

                    if (async)
>async : boolean
>      : ^^^^^^^

                        that.runChildren(done, index + 1);
>that.runChildren(done, index + 1) : void
>                                  : ^^^^
>that.runChildren : (done: IDone, index?: number) => void
>                 : ^    ^^     ^^     ^^^^^^^^^^^^^^^^^^
>that : this
>     : ^^^^
>runChildren : (done: IDone, index?: number) => void
>            : ^    ^^     ^^     ^^^^^^^^^^^^^^^^^^
>done : IDone
>     : ^^^^^
>index + 1 : number
>          : ^^^^^^
>index : number
>      : ^^^^^^
>1 : 1
>  : ^

                });

                if (async)
>async : boolean
>      : ^^^^^^^

                    return;
            }

            var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: this.passed, bugs: assert.bugIds };
>metadata : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^
>{ id: undefined, desc: this.description, pass: this.passed, bugs: assert.bugIds } : { id: undefined; desc: string; pass: any; bugs: any; }
>                                                                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>id : undefined
>   : ^^^^^^^^^
>undefined : undefined
>          : ^^^^^^^^^
>desc : string
>     : ^^^^^^
>this.description : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>description : string
>            : ^^^^^^
>pass : any
>     : ^^^
>this.passed : any
>            : ^^^
>this : this
>     : ^^^^
>passed : any
>       : ^^^
>bugs : any
>     : ^^^
>assert.bugIds : any
>              : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>bugIds : any
>       : ^^^

            // Report all bugs affecting this scenario
            assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
>assert.bugIds.forEach(desc => emitLog('bug', metadata, desc)) : any
>                                                              : ^^^
>assert.bugIds.forEach : any
>                      : ^^^
>assert.bugIds : any
>              : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>bugIds : any
>       : ^^^
>forEach : any
>        : ^^^
>desc => emitLog('bug', metadata, desc) : (desc: any) => void
>                                       : ^    ^^^^^^^^^^^^^^
>desc : any
>     : ^^^
>emitLog('bug', metadata, desc) : void
>                               : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'bug' : "bug"
>      : ^^^^^
>metadata : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^
>desc : any
>     : ^^^

            emitLog('scenarioEnd', metadata);
>emitLog('scenarioEnd', metadata) : void
>                                 : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'scenarioEnd' : "scenarioEnd"
>              : ^^^^^^^^^^^^^
>metadata : IScenarioMetadata
>         : ^^^^^^^^^^^^^^^^^

            done();
>done() : void
>       : ^^^^
>done : IDone
>     : ^^^^^
        }
    }
    export class Run extends Runnable {
>Run : Run
>    : ^^^
>Runnable : Runnable
>         : ^^^^^^^^

        constructor() {
            super('Test Run', null);
>super('Test Run', null) : void
>                        : ^^^^
>super : typeof Runnable
>      : ^^^^^^^^^^^^^^^
>'Test Run' : "Test Run"
>           : ^^^^^^^^^^
        }

        public run() {
>run : () => void
>    : ^^^^^^^^^^

            emitLog('start');
>emitLog('start') : void
>                 : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'start' : "start"
>        : ^^^^^^^

            this.runChildren();
>this.runChildren() : void
>                   : ^^^^
>this.runChildren : (index?: number) => void
>                 : ^     ^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>runChildren : (index?: number) => void
>            : ^     ^^^^^^^^^^^^^^^^^^
        }

        public runChildren(index = 0) {
>runChildren : (index?: number) => void
>            : ^     ^^^^^^^^^^^^^^^^^^
>index : number
>      : ^^^^^^
>0 : 0
>  : ^

            var async = false;
>async : boolean
>      : ^^^^^^^
>false : false
>      : ^^^^^

            var that = this;
>that : this
>     : ^^^^
>this : this
>     : ^^^^

            for (; index < this.children.length; index++) {
>index < this.children.length : boolean
>                             : ^^^^^^^
>index : number
>      : ^^^^^^
>this.children.length : number
>                     : ^^^^^^
>this.children : Runnable[]
>              : ^^^^^^^^^^
>this : this
>     : ^^^^
>children : Runnable[]
>         : ^^^^^^^^^^
>length : number
>       : ^^^^^^
>index++ : number
>        : ^^^^^^
>index : number
>      : ^^^^^^

                // Clear out bug descriptions
                assert.bugIds = [];
>assert.bugIds = [] : undefined[]
>                   : ^^^^^^^^^^^
>assert.bugIds : any
>              : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>bugIds : any
>       : ^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                async = this.runChild(index, <any>function (e) {
>async = this.runChild(index, <any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                }) : boolean
>                                                                                                                                                                            : ^^^^^^^
>async : boolean
>      : ^^^^^^^
>this.runChild(index, <any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                }) : boolean
>                                                                                                                                                                    : ^^^^^^^
>this.runChild : (index: number, done: IDone) => boolean
>              : ^     ^^      ^^    ^^     ^^^^^^^^^^^^
>this : this
>     : ^^^^
>runChild : (index: number, done: IDone) => boolean
>         : ^     ^^      ^^    ^^     ^^^^^^^^^^^^
>index : number
>      : ^^^^^^
><any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                } : any
>                                                                                                                                              : ^^^
>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                } : (e: any) => void
>                                                                                                                                         : ^ ^^^^^^^^^^^^^^
>e : any
>  : ^^^

                    if (async) {
>async : boolean
>      : ^^^^^^^

                        that.runChildren(index + 1);
>that.runChildren(index + 1) : void
>                            : ^^^^
>that.runChildren : (index?: number) => void
>                 : ^     ^^^^^^^^^^^^^^^^^^
>that : this
>     : ^^^^
>runChildren : (index?: number) => void
>            : ^     ^^^^^^^^^^^^^^^^^^
>index + 1 : number
>          : ^^^^^^
>index : number
>      : ^^^^^^
>1 : 1
>  : ^
                    }
                });

                if (async) {
>async : boolean
>      : ^^^^^^^

                    return;
                }
            }

            Perf.runBenchmarks();
>Perf.runBenchmarks() : void
>                     : ^^^^
>Perf.runBenchmarks : () => void
>                   : ^^^^^^^^^^
>Perf : typeof Perf
>     : ^^^^^^^^^^^
>runBenchmarks : () => void
>              : ^^^^^^^^^^

            emitLog('end');
>emitLog('end') : void
>               : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'end' : "end"
>      : ^^^^^
        }
    }

    // Performance test
    export module Perf {
>Perf : typeof Perf
>     : ^^^^^^^^^^^

        export module Clock {
>Clock : typeof Clock
>      : ^^^^^^^^^^^^

            export var now: () => number;
>now : () => number
>    : ^^^^^^      

            export var resolution: number;
>resolution : number
>           : ^^^^^^

            declare module WScript {
>WScript : typeof WScript
>        : ^^^^^^^^^^^^^^

                export function InitializeProjection();
>InitializeProjection : () => any
>                     : ^^^^^^^^^
            }

            declare module TestUtilities {
>TestUtilities : typeof TestUtilities
>              : ^^^^^^^^^^^^^^^^^^^^

                export function QueryPerformanceCounter(): number;
>QueryPerformanceCounter : () => number
>                        : ^^^^^^      

                export function QueryPerformanceFrequency(): number;
>QueryPerformanceFrequency : () => number
>                          : ^^^^^^      
            }

            if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
>typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined" : boolean
>                                                                                                : ^^^^^^^
>typeof WScript !== "undefined" : boolean
>                               : ^^^^^^^
>typeof WScript : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>WScript : typeof WScript
>        : ^^^^^^^^^^^^^^
>"undefined" : "undefined"
>            : ^^^^^^^^^^^
>typeof global['WScript'].InitializeProjection !== "undefined" : boolean
>                                                              : ^^^^^^^
>typeof global['WScript'].InitializeProjection : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>                                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>global['WScript'].InitializeProjection : any
>                                       : ^^^
>global['WScript'] : any
>                  : ^^^
>global : any
>       : ^^^
>'WScript' : "WScript"
>          : ^^^^^^^^^
>InitializeProjection : any
>                     : ^^^
>"undefined" : "undefined"
>            : ^^^^^^^^^^^

                // Running in JSHost.
                global['WScript'].InitializeProjection();
>global['WScript'].InitializeProjection() : any
>                                         : ^^^
>global['WScript'].InitializeProjection : any
>                                       : ^^^
>global['WScript'] : any
>                  : ^^^
>global : any
>       : ^^^
>'WScript' : "WScript"
>          : ^^^^^^^^^
>InitializeProjection : any
>                     : ^^^

                now = function () {
>now = function () {                    return TestUtilities.QueryPerformanceCounter();                } : () => number
>                                                                                                        : ^^^^^^^^^^^^
>now : () => number
>    : ^^^^^^      
>function () {                    return TestUtilities.QueryPerformanceCounter();                } : () => number
>                                                                                                  : ^^^^^^^^^^^^

                    return TestUtilities.QueryPerformanceCounter();
>TestUtilities.QueryPerformanceCounter() : number
>                                        : ^^^^^^
>TestUtilities.QueryPerformanceCounter : () => number
>                                      : ^^^^^^      
>TestUtilities : typeof TestUtilities
>              : ^^^^^^^^^^^^^^^^^^^^
>QueryPerformanceCounter : () => number
>                        : ^^^^^^      
                }

                resolution = TestUtilities.QueryPerformanceFrequency();
>resolution = TestUtilities.QueryPerformanceFrequency() : number
>                                                       : ^^^^^^
>resolution : number
>           : ^^^^^^
>TestUtilities.QueryPerformanceFrequency() : number
>                                          : ^^^^^^
>TestUtilities.QueryPerformanceFrequency : () => number
>                                        : ^^^^^^      
>TestUtilities : typeof TestUtilities
>              : ^^^^^^^^^^^^^^^^^^^^
>QueryPerformanceFrequency : () => number
>                          : ^^^^^^      

            } else {
                now = function () {
>now = function () {                    return Date.now();                } : () => number
>                                                                           : ^^^^^^^^^^^^
>now : () => number
>    : ^^^^^^      
>function () {                    return Date.now();                } : () => number
>                                                                     : ^^^^^^^^^^^^

                    return Date.now();
>Date.now() : number
>           : ^^^^^^
>Date.now : () => number
>         : ^^^^^^      
>Date : DateConstructor
>     : ^^^^^^^^^^^^^^^
>now : () => number
>    : ^^^^^^      
                }

                resolution = 1000;
>resolution = 1000 : 1000
>                  : ^^^^
>resolution : number
>           : ^^^^^^
>1000 : 1000
>     : ^^^^
            }
        }

        export class Timer {
>Timer : Timer
>      : ^^^^^

            public startTime;
>startTime : any
>          : ^^^

            public time = 0;
>time : number
>     : ^^^^^^
>0 : 0
>  : ^

            public start() {
>start : () => void
>      : ^^^^^^^^^^

                this.time = 0;
>this.time = 0 : 0
>              : ^
>this.time : number
>          : ^^^^^^
>this : this
>     : ^^^^
>time : number
>     : ^^^^^^
>0 : 0
>  : ^

                this.startTime = Clock.now();
>this.startTime = Clock.now() : number
>                             : ^^^^^^
>this.startTime : any
>               : ^^^
>this : this
>     : ^^^^
>startTime : any
>          : ^^^
>Clock.now() : number
>            : ^^^^^^
>Clock.now : () => number
>          : ^^^^^^      
>Clock : typeof Clock
>      : ^^^^^^^^^^^^
>now : () => number
>    : ^^^^^^      
            }

            public end() {
>end : () => void
>    : ^^^^^^^^^^

                // Set time to MS.
                this.time = (Clock.now() - this.startTime) / Clock.resolution * 1000;
>this.time = (Clock.now() - this.startTime) / Clock.resolution * 1000 : number
>                                                                     : ^^^^^^
>this.time : number
>          : ^^^^^^
>this : this
>     : ^^^^
>time : number
>     : ^^^^^^
>(Clock.now() - this.startTime) / Clock.resolution * 1000 : number
>                                                         : ^^^^^^
>(Clock.now() - this.startTime) / Clock.resolution : number
>                                                  : ^^^^^^
>(Clock.now() - this.startTime) : number
>                               : ^^^^^^
>Clock.now() - this.startTime : number
>                             : ^^^^^^
>Clock.now() : number
>            : ^^^^^^
>Clock.now : () => number
>          : ^^^^^^      
>Clock : typeof Clock
>      : ^^^^^^^^^^^^
>now : () => number
>    : ^^^^^^      
>this.startTime : any
>               : ^^^
>this : this
>     : ^^^^
>startTime : any
>          : ^^^
>Clock.resolution : number
>                 : ^^^^^^
>Clock : typeof Clock
>      : ^^^^^^^^^^^^
>resolution : number
>           : ^^^^^^
>1000 : 1000
>     : ^^^^
            }
        }

        export class Dataset {
>Dataset : Dataset
>        : ^^^^^^^

            public data: number[] = [];
>data : number[]
>     : ^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            public add(value: number) {
>add : (value: number) => void
>    : ^     ^^      ^^^^^^^^^
>value : number
>      : ^^^^^^

                this.data.push(value);
>this.data.push(value) : number
>                      : ^^^^^^
>this.data.push : (...items: number[]) => number
>               : ^^^^     ^^^^^^^^^^^^^^^      
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>push : (...items: number[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^      
>value : number
>      : ^^^^^^
            }

            public mean() {
>mean : () => number
>     : ^^^^^^^^^^^^

                var sum = 0;
>sum : number
>    : ^^^^^^
>0 : 0
>  : ^

                for (var i = 0; i < this.data.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < this.data.length : boolean
>                     : ^^^^^^^
>i : number
>  : ^^^^^^
>this.data.length : number
>                 : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    sum += this.data[i];
>sum += this.data[i] : number
>                    : ^^^^^^
>sum : number
>    : ^^^^^^
>this.data[i] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>i : number
>  : ^^^^^^
                }

                return sum / this.data.length;
>sum / this.data.length : number
>                       : ^^^^^^
>sum : number
>    : ^^^^^^
>this.data.length : number
>                 : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>length : number
>       : ^^^^^^
            }

            public min() {
>min : () => number
>    : ^^^^^^^^^^^^

                var min = this.data[0];
>min : number
>    : ^^^^^^
>this.data[0] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>0 : 0
>  : ^

                for (var i = 1; i < this.data.length; i++) {
>i : number
>  : ^^^^^^
>1 : 1
>  : ^
>i < this.data.length : boolean
>                     : ^^^^^^^
>i : number
>  : ^^^^^^
>this.data.length : number
>                 : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    if (this.data[i] < min) {
>this.data[i] < min : boolean
>                   : ^^^^^^^
>this.data[i] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>i : number
>  : ^^^^^^
>min : number
>    : ^^^^^^

                        min = this.data[i];
>min = this.data[i] : number
>                   : ^^^^^^
>min : number
>    : ^^^^^^
>this.data[i] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>i : number
>  : ^^^^^^
                    }
                }

                return min;
>min : number
>    : ^^^^^^
            }

            public max() {
>max : () => number
>    : ^^^^^^^^^^^^

                var max = this.data[0];
>max : number
>    : ^^^^^^
>this.data[0] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>0 : 0
>  : ^

                for (var i = 1; i < this.data.length; i++) {
>i : number
>  : ^^^^^^
>1 : 1
>  : ^
>i < this.data.length : boolean
>                     : ^^^^^^^
>i : number
>  : ^^^^^^
>this.data.length : number
>                 : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    if (this.data[i] > max) {
>this.data[i] > max : boolean
>                   : ^^^^^^^
>this.data[i] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>i : number
>  : ^^^^^^
>max : number
>    : ^^^^^^

                        max = this.data[i];
>max = this.data[i] : number
>                   : ^^^^^^
>max : number
>    : ^^^^^^
>this.data[i] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>i : number
>  : ^^^^^^
                    }
                }

                return max;
>max : number
>    : ^^^^^^
            }

            public stdDev() {
>stdDev : () => number
>       : ^^^^^^^^^^^^

                var sampleMean = this.mean();
>sampleMean : number
>           : ^^^^^^
>this.mean() : number
>            : ^^^^^^
>this.mean : () => number
>          : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>mean : () => number
>     : ^^^^^^^^^^^^

                var sumOfSquares = 0;
>sumOfSquares : number
>             : ^^^^^^
>0 : 0
>  : ^

                for (var i = 0; i < this.data.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < this.data.length : boolean
>                     : ^^^^^^^
>i : number
>  : ^^^^^^
>this.data.length : number
>                 : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    sumOfSquares += Math.pow(this.data[i] - sampleMean, 2);
>sumOfSquares += Math.pow(this.data[i] - sampleMean, 2) : number
>                                                       : ^^^^^^
>sumOfSquares : number
>             : ^^^^^^
>Math.pow(this.data[i] - sampleMean, 2) : number
>                                       : ^^^^^^
>Math.pow : (x: number, y: number) => number
>         : ^ ^^      ^^ ^^      ^^^^^      
>Math : Math
>     : ^^^^
>pow : (x: number, y: number) => number
>    : ^ ^^      ^^ ^^      ^^^^^      
>this.data[i] - sampleMean : number
>                          : ^^^^^^
>this.data[i] : number
>             : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>i : number
>  : ^^^^^^
>sampleMean : number
>           : ^^^^^^
>2 : 2
>  : ^
                }

                return Math.sqrt(sumOfSquares / this.data.length);
>Math.sqrt(sumOfSquares / this.data.length) : number
>                                           : ^^^^^^
>Math.sqrt : (x: number) => number
>          : ^ ^^      ^^^^^      
>Math : Math
>     : ^^^^
>sqrt : (x: number) => number
>     : ^ ^^      ^^^^^      
>sumOfSquares / this.data.length : number
>                                : ^^^^^^
>sumOfSquares : number
>             : ^^^^^^
>this.data.length : number
>                 : ^^^^^^
>this.data : number[]
>          : ^^^^^^^^
>this : this
>     : ^^^^
>data : number[]
>     : ^^^^^^^^
>length : number
>       : ^^^^^^
            }
        }

        // Base benchmark class with some defaults.
        export class Benchmark {
>Benchmark : Benchmark
>          : ^^^^^^^^^

            public iterations = 10;
>iterations : number
>           : ^^^^^^
>10 : 10
>   : ^^

            public description = "";
>description : string
>            : ^^^^^^
>"" : ""
>   : ^^

            public bench(subBench?: () => void ) { }
>bench : (subBench?: () => void) => void
>      : ^        ^^^          ^^^^^^^^^
>subBench : () => void
>         : ^^^^^^    

            public before() { }
>before : () => void
>       : ^^^^^^^^^^

            public beforeEach() { }
>beforeEach : () => void
>           : ^^^^^^^^^^

            public after() { }
>after : () => void
>      : ^^^^^^^^^^

            public afterEach() { }
>afterEach : () => void
>          : ^^^^^^^^^^

            public results: { [x: string]: Dataset; } = <{ [x: string]: Dataset; }>{};
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>x : string
>  : ^^^^^^
><{ [x: string]: Dataset; }>{} : { [x: string]: Dataset; }
>                              : ^^^^^^^^^^^^^^^^^^^^^^^^^
>x : string
>  : ^^^^^^
>{} : {}
>   : ^^

            public addTimingFor(name: string, timing: number) {
>addTimingFor : (name: string, timing: number) => void
>             : ^    ^^      ^^      ^^      ^^^^^^^^^
>name : string
>     : ^^^^^^
>timing : number
>       : ^^^^^^

                this.results[name] = this.results[name] || new Dataset();
>this.results[name] = this.results[name] || new Dataset() : Dataset
>                                                         : ^^^^^^^
>this.results[name] : Dataset
>                   : ^^^^^^^
>this.results : { [x: string]: Dataset; }
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>this.results[name] || new Dataset() : Dataset
>                                    : ^^^^^^^
>this.results[name] : Dataset
>                   : ^^^^^^^
>this.results : { [x: string]: Dataset; }
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>new Dataset() : Dataset
>              : ^^^^^^^
>Dataset : typeof Dataset
>        : ^^^^^^^^^^^^^^

                this.results[name].add(timing);
>this.results[name].add(timing) : void
>                               : ^^^^
>this.results[name].add : (value: number) => void
>                       : ^     ^^      ^^^^^^^^^
>this.results[name] : Dataset
>                   : ^^^^^^^
>this.results : { [x: string]: Dataset; }
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>add : (value: number) => void
>    : ^     ^^      ^^^^^^^^^
>timing : number
>       : ^^^^^^
            }
        }

        export var benchmarks: { new (): Benchmark; }[] = [];
>benchmarks : (new () => Benchmark)[]
>           : ^^^^^^^^^^^         ^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        var timeFunction: (
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
>             : ^         ^^         ^^           ^^^      ^^    ^^^      ^^ ^^^                               ^^^^^    

            benchmark: Benchmark,
>benchmark : Benchmark
>          : ^^^^^^^^^

            description?: string,
>description : string
>            : ^^^^^^

            name?: string,
>name : string
>     : ^^^^^^

            f?: (bench?: { (): void; }) => void
>f : (bench?: { (): void; }) => void
>  : ^     ^^^             ^^^^^    
>bench : () => void
>      : ^^^^^^    

        ) => void;

        timeFunction = function (
>timeFunction = function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : ^         ^^         ^^           ^^^      ^^    ^^^      ^^ ^^^^     ^^^             ^^^^^    ^^^^^    
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
>             : ^         ^^         ^^           ^^^      ^^    ^^^      ^^ ^^^                               ^^^^^    
>function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      : ^         ^^         ^^           ^^^      ^^    ^^^      ^^ ^^^^     ^^^             ^^^^^    ^^^^^    

            benchmark: Benchmark,
>benchmark : Benchmark
>          : ^^^^^^^^^

            description: string = benchmark.description,
>description : string
>            : ^^^^^^
>benchmark.description : string
>                      : ^^^^^^
>benchmark : Benchmark
>          : ^^^^^^^^^
>description : string
>            : ^^^^^^

            name: string = '',
>name : string
>     : ^^^^^^
>'' : ""
>   : ^^

            f = benchmark.bench
>f : (bench?: { (): void; }) => void
>  : ^     ^^^             ^^^^^    
>benchmark.bench : (subBench?: () => void) => void
>                : ^        ^^^          ^^^^^^^^^
>benchmark : Benchmark
>          : ^^^^^^^^^
>bench : (subBench?: () => void) => void
>      : ^        ^^^          ^^^^^^^^^

        ): void {

            var t = new Timer();
>t : Timer
>  : ^^^^^
>new Timer() : Timer
>            : ^^^^^
>Timer : typeof Timer
>      : ^^^^^^^^^^^^

            t.start();
>t.start() : void
>          : ^^^^
>t.start : () => void
>        : ^^^^^^^^^^
>t : Timer
>  : ^^^^^
>start : () => void
>      : ^^^^^^^^^^

            var subBenchmark = function (name, f): void {
>subBenchmark : (name: any, f: any) => void
>             : ^    ^^^^^^^ ^^^^^^^^^^    
>function (name, f): void {                timeFunction(benchmark, description, name, f);            } : (name: any, f: any) => void
>                                                                                                      : ^    ^^^^^^^ ^^^^^^^^^^    
>name : any
>     : ^^^
>f : any
>  : ^^^

                timeFunction(benchmark, description, name, f);
>timeFunction(benchmark, description, name, f) : void
>                                              : ^^^^
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
>             : ^         ^^         ^^           ^^^      ^^    ^^^      ^^ ^^^                               ^^^^^    
>benchmark : Benchmark
>          : ^^^^^^^^^
>description : string
>            : ^^^^^^
>name : any
>     : ^^^
>f : any
>  : ^^^
            }

            f.call(benchmark, subBenchmark);
>f.call(benchmark, subBenchmark) : any
>                                : ^^^
>f.call : (this: Function, thisArg: any, ...argArray: any[]) => any
>       : ^    ^^        ^^       ^^   ^^^^^        ^^     ^^^^^   
>f : (bench?: { (): void; }) => void
>  : ^     ^^^             ^^^^^    
>call : (this: Function, thisArg: any, ...argArray: any[]) => any
>     : ^    ^^        ^^       ^^   ^^^^^        ^^     ^^^^^   
>benchmark : Benchmark
>          : ^^^^^^^^^
>subBenchmark : (name: any, f: any) => void
>             : ^    ^^^^^^^ ^^^^^^^^^^    

            t.end();
>t.end() : void
>        : ^^^^
>t.end : () => void
>      : ^^^^^^^^^^
>t : Timer
>  : ^^^^^
>end : () => void
>    : ^^^^^^^^^^

            benchmark.addTimingFor(name, t.time);
>benchmark.addTimingFor(name, t.time) : void
>                                     : ^^^^
>benchmark.addTimingFor : (name: string, timing: number) => void
>                       : ^    ^^      ^^      ^^      ^^^^^^^^^
>benchmark : Benchmark
>          : ^^^^^^^^^
>addTimingFor : (name: string, timing: number) => void
>             : ^    ^^      ^^      ^^      ^^^^^^^^^
>name : string
>     : ^^^^^^
>t.time : number
>       : ^^^^^^
>t : Timer
>  : ^^^^^
>time : number
>     : ^^^^^^
        }

        export function runBenchmarks() {
>runBenchmarks : () => void
>              : ^^^^^^^^^^

            for (var i = 0; i < benchmarks.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < benchmarks.length : boolean
>                      : ^^^^^^^
>i : number
>  : ^^^^^^
>benchmarks.length : number
>                  : ^^^^^^
>benchmarks : (new () => Benchmark)[]
>           : ^^^^^^^^^^^         ^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                var b = new benchmarks[i]();
>b : Benchmark
>  : ^^^^^^^^^
>new benchmarks[i]() : Benchmark
>                    : ^^^^^^^^^
>benchmarks[i] : new () => Benchmark
>              : ^^^^^^^^^^         
>benchmarks : (new () => Benchmark)[]
>           : ^^^^^^^^^^^         ^^^
>i : number
>  : ^^^^^^


                var t = new Timer();
>t : Timer
>  : ^^^^^
>new Timer() : Timer
>            : ^^^^^
>Timer : typeof Timer
>      : ^^^^^^^^^^^^

                b.before();
>b.before() : void
>           : ^^^^
>b.before : () => void
>         : ^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>before : () => void
>       : ^^^^^^^^^^

                for (var j = 0; j < b.iterations; j++) {
>j : number
>  : ^^^^^^
>0 : 0
>  : ^
>j < b.iterations : boolean
>                 : ^^^^^^^
>j : number
>  : ^^^^^^
>b.iterations : number
>             : ^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>iterations : number
>           : ^^^^^^
>j++ : number
>    : ^^^^^^
>j : number
>  : ^^^^^^

                    b.beforeEach();
>b.beforeEach() : void
>               : ^^^^
>b.beforeEach : () => void
>             : ^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>beforeEach : () => void
>           : ^^^^^^^^^^

                    timeFunction(b);
>timeFunction(b) : void
>                : ^^^^
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
>             : ^         ^^         ^^           ^^^      ^^    ^^^      ^^ ^^^                               ^^^^^    
>b : Benchmark
>  : ^^^^^^^^^

                    b.afterEach();
>b.afterEach() : void
>              : ^^^^
>b.afterEach : () => void
>            : ^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>afterEach : () => void
>          : ^^^^^^^^^^
                }
                b.after();
>b.after() : void
>          : ^^^^
>b.after : () => void
>        : ^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>after : () => void
>      : ^^^^^^^^^^

                for (var prop in b.results) {
>prop : string
>     : ^^^^^^
>b.results : { [x: string]: Dataset; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^

                    var description = b.description + (prop ? ": " + prop : '');
>description : string
>            : ^^^^^^
>b.description + (prop ? ": " + prop : '') : string
>                                          : ^^^^^^
>b.description : string
>              : ^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>description : string
>            : ^^^^^^
>(prop ? ": " + prop : '') : string
>                          : ^^^^^^
>prop ? ": " + prop : '' : string
>                        : ^^^^^^
>prop : string
>     : ^^^^^^
>": " + prop : string
>            : ^^^^^^
>": " : ": "
>     : ^^^^
>prop : string
>     : ^^^^^^
>'' : ""
>   : ^^

                    emitLog('testStart', { desc: description });
>emitLog('testStart', { desc: description }) : void
>                                            : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'testStart' : "testStart"
>            : ^^^^^^^^^^^
>{ desc: description } : { desc: string; }
>                      : ^^^^^^^^^^^^^^^^^
>desc : string
>     : ^^^^^^
>description : string
>            : ^^^^^^

                    emitLog('pass', {
>emitLog('pass', {                        desc: description, pass: true, perfResults: {                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        }                    }) : void
>                                                                                                                                                                                                                                                                                                                                                                                                                                  : ^^^^
>emitLog : (field: string, ...params: any[]) => void
>        : ^     ^^      ^^^^^      ^^     ^^^^^^^^^
>'pass' : "pass"
>       : ^^^^^^
>{                        desc: description, pass: true, perfResults: {                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        }                    } : { desc: string; pass: boolean; perfResults: { mean: number; min: number; max: number; stdDev: number; trials: number[]; }; }
>                                                                                                                                                                                                                                                                                                                                                                                                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                        desc: description, pass: true, perfResults: {
>desc : string
>     : ^^^^^^
>description : string
>            : ^^^^^^
>pass : boolean
>     : ^^^^^^^
>true : true
>     : ^^^^
>perfResults : { mean: number; min: number; max: number; stdDev: number; trials: number[]; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        } : { mean: number; min: number; max: number; stdDev: number; trials: number[]; }
>                                                                                                                                                                                                                                                                                                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                            mean: b.results[prop].mean(),
>mean : number
>     : ^^^^^^
>b.results[prop].mean() : number
>                       : ^^^^^^
>b.results[prop].mean : () => number
>                     : ^^^^^^^^^^^^
>b.results[prop] : Dataset
>                : ^^^^^^^
>b.results : { [x: string]: Dataset; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>prop : string
>     : ^^^^^^
>mean : () => number
>     : ^^^^^^^^^^^^

                            min: b.results[prop].min(),
>min : number
>    : ^^^^^^
>b.results[prop].min() : number
>                      : ^^^^^^
>b.results[prop].min : () => number
>                    : ^^^^^^^^^^^^
>b.results[prop] : Dataset
>                : ^^^^^^^
>b.results : { [x: string]: Dataset; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>prop : string
>     : ^^^^^^
>min : () => number
>    : ^^^^^^^^^^^^

                            max: b.results[prop].max(),
>max : number
>    : ^^^^^^
>b.results[prop].max() : number
>                      : ^^^^^^
>b.results[prop].max : () => number
>                    : ^^^^^^^^^^^^
>b.results[prop] : Dataset
>                : ^^^^^^^
>b.results : { [x: string]: Dataset; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>prop : string
>     : ^^^^^^
>max : () => number
>    : ^^^^^^^^^^^^

                            stdDev: b.results[prop].stdDev(),
>stdDev : number
>       : ^^^^^^
>b.results[prop].stdDev() : number
>                         : ^^^^^^
>b.results[prop].stdDev : () => number
>                       : ^^^^^^^^^^^^
>b.results[prop] : Dataset
>                : ^^^^^^^
>b.results : { [x: string]: Dataset; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>prop : string
>     : ^^^^^^
>stdDev : () => number
>       : ^^^^^^^^^^^^

                            trials: b.results[prop].data
>trials : number[]
>       : ^^^^^^^^
>b.results[prop].data : number[]
>                     : ^^^^^^^^
>b.results[prop] : Dataset
>                : ^^^^^^^
>b.results : { [x: string]: Dataset; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^
>b : Benchmark
>  : ^^^^^^^^^
>results : { [x: string]: Dataset; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^
>prop : string
>     : ^^^^^^
>data : number[]
>     : ^^^^^^^^
                        }
                    });
                }

            }
        }

        // Replace with better type when classes are assignment compatible with
        // the below type.
        // export function addBenchmark(BenchmarkClass: {new(): Benchmark;}) {
        export function addBenchmark(BenchmarkClass: any) {
>addBenchmark : (BenchmarkClass: any) => void
>             : ^              ^^   ^^^^^^^^^
>BenchmarkClass : any
>               : ^^^

            benchmarks.push(BenchmarkClass);
>benchmarks.push(BenchmarkClass) : number
>                                : ^^^^^^
>benchmarks.push : (...items: (new () => Benchmark)[]) => number
>                : ^^^^     ^^^^^^^^^^^^^         ^^^^^^^^      
>benchmarks : (new () => Benchmark)[]
>           : ^^^^^^^^^^^         ^^^
>push : (...items: (new () => Benchmark)[]) => number
>     : ^^^^     ^^^^^^^^^^^^^         ^^^^^^^^      
>BenchmarkClass : any
>               : ^^^
        }

    }

    /** Functionality for compiling TypeScript code */
    export module Compiler {
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^

        /** Aggregate various writes into a single array of lines. Useful for passing to the
         *  TypeScript compiler to fill with source code or errors.
         */
        export class WriterAggregator implements ITextWriter {
>WriterAggregator : WriterAggregator
>                 : ^^^^^^^^^^^^^^^^

            public lines: string[] = [];
>lines : string[]
>      : ^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            public currentLine = "";
>currentLine : string
>            : ^^^^^^
>"" : ""
>   : ^^

            public Write(str) {
>Write : (str: any) => void
>      : ^   ^^^^^^^^^^^^^^
>str : any
>    : ^^^

                this.currentLine += str;
>this.currentLine += str : string
>                        : ^^^^^^
>this.currentLine : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>currentLine : string
>            : ^^^^^^
>str : any
>    : ^^^
            }

            public WriteLine(str) {
>WriteLine : (str: any) => void
>          : ^   ^^^^^^^^^^^^^^
>str : any
>    : ^^^

                this.lines.push(this.currentLine + str);
>this.lines.push(this.currentLine + str) : number
>                                        : ^^^^^^
>this.lines.push : (...items: string[]) => number
>                : ^^^^     ^^^^^^^^^^^^^^^      
>this.lines : string[]
>           : ^^^^^^^^
>this : this
>     : ^^^^
>lines : string[]
>      : ^^^^^^^^
>push : (...items: string[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^      
>this.currentLine + str : string
>                       : ^^^^^^
>this.currentLine : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>currentLine : string
>            : ^^^^^^
>str : any
>    : ^^^

                this.currentLine = "";
>this.currentLine = "" : ""
>                      : ^^
>this.currentLine : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>currentLine : string
>            : ^^^^^^
>"" : ""
>   : ^^
            }

            public Close() {
>Close : () => void
>      : ^^^^^^^^^^

                if (this.currentLine.length > 0) { this.lines.push(this.currentLine); }
>this.currentLine.length > 0 : boolean
>                            : ^^^^^^^
>this.currentLine.length : number
>                        : ^^^^^^
>this.currentLine : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>currentLine : string
>            : ^^^^^^
>length : number
>       : ^^^^^^
>0 : 0
>  : ^
>this.lines.push(this.currentLine) : number
>                                  : ^^^^^^
>this.lines.push : (...items: string[]) => number
>                : ^^^^     ^^^^^^^^^^^^^^^      
>this.lines : string[]
>           : ^^^^^^^^
>this : this
>     : ^^^^
>lines : string[]
>      : ^^^^^^^^
>push : (...items: string[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^      
>this.currentLine : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>currentLine : string
>            : ^^^^^^

                this.currentLine = "";
>this.currentLine = "" : ""
>                      : ^^
>this.currentLine : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>currentLine : string
>            : ^^^^^^
>"" : ""
>   : ^^
            }

            public reset() {
>reset : () => void
>      : ^^^^^^^^^^

                this.lines = [];
>this.lines = [] : undefined[]
>                : ^^^^^^^^^^^
>this.lines : string[]
>           : ^^^^^^^^
>this : this
>     : ^^^^
>lines : string[]
>      : ^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                this.currentLine = "";
>this.currentLine = "" : ""
>                      : ^^
>this.currentLine : string
>                 : ^^^^^^
>this : this
>     : ^^^^
>currentLine : string
>            : ^^^^^^
>"" : ""
>   : ^^
            }
        }

        /** Mimics having multiple files, later concatenated to a single file. */
        export class EmitterIOHost implements TypeScript.EmitterIOHost {
>EmitterIOHost : EmitterIOHost
>              : ^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            private fileCollection = {};
>fileCollection : {}
>               : ^^
>{} : {}
>   : ^^

            /** create file gets the whole path to create, so this works as expected with the --out parameter */
            public createFile(s: string, useUTF8?: boolean): ITextWriter {
>createFile : (s: string, useUTF8?: boolean) => ITextWriter
>           : ^ ^^      ^^       ^^^       ^^^^^           
>s : string
>  : ^^^^^^
>useUTF8 : boolean
>        : ^^^^^^^

                if (this.fileCollection[s]) {
>this.fileCollection[s] : any
>                       : ^^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>s : string
>  : ^^^^^^

                    return <ITextWriter>this.fileCollection[s];
><ITextWriter>this.fileCollection[s] : ITextWriter
>                                    : ^^^^^^^^^^^
>this.fileCollection[s] : any
>                       : ^^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>s : string
>  : ^^^^^^
                }

                var writer = new Harness.Compiler.WriterAggregator();
>writer : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
>new Harness.Compiler.WriterAggregator() : WriterAggregator
>                                        : ^^^^^^^^^^^^^^^^
>Harness.Compiler.WriterAggregator : typeof WriterAggregator
>                                  : ^^^^^^^^^^^^^^^^^^^^^^^
>Harness.Compiler : typeof Compiler
>                 : ^^^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>WriterAggregator : typeof WriterAggregator
>                 : ^^^^^^^^^^^^^^^^^^^^^^^

                this.fileCollection[s] = writer;
>this.fileCollection[s] = writer : WriterAggregator
>                                : ^^^^^^^^^^^^^^^^
>this.fileCollection[s] : any
>                       : ^^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>s : string
>  : ^^^^^^
>writer : WriterAggregator
>       : ^^^^^^^^^^^^^^^^

                return writer;
>writer : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
            }

            public directoryExists(s: string) { return false; }
>directoryExists : (s: string) => boolean
>                : ^ ^^      ^^^^^^^^^^^^
>s : string
>  : ^^^^^^
>false : false
>      : ^^^^^

            public fileExists(s: string) { return typeof this.fileCollection[s] !== 'undefined'; }
>fileExists : (s: string) => boolean
>           : ^ ^^      ^^^^^^^^^^^^
>s : string
>  : ^^^^^^
>typeof this.fileCollection[s] !== 'undefined' : boolean
>                                              : ^^^^^^^
>typeof this.fileCollection[s] : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>this.fileCollection[s] : any
>                       : ^^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>s : string
>  : ^^^^^^
>'undefined' : "undefined"
>            : ^^^^^^^^^^^

            public resolvePath(s: string) { return s; }
>resolvePath : (s: string) => string
>            : ^ ^^      ^^^^^^^^^^^
>s : string
>  : ^^^^^^
>s : string
>  : ^^^^^^

            public reset() { this.fileCollection = {}; }
>reset : () => void
>      : ^^^^^^^^^^
>this.fileCollection = {} : {}
>                         : ^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>{} : {}
>   : ^^

            public toArray(): { filename: string; file: WriterAggregator; }[] {
>toArray : () => { filename: string; file: WriterAggregator; }[]
>        : ^^^^^^                                               
>filename : string
>         : ^^^^^^
>file : WriterAggregator
>     : ^^^^^^^^^^^^^^^^

                var result: { filename: string; file: WriterAggregator; }[] = [];
>result : { filename: string; file: WriterAggregator; }[]
>       : ^^^^^^^^^^^^      ^^^^^^^^                ^^^^^
>filename : string
>         : ^^^^^^
>file : WriterAggregator
>     : ^^^^^^^^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                for (var p in this.fileCollection) {
>p : string
>  : ^^^^^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^

                    if (this.fileCollection.hasOwnProperty(p)) {
>this.fileCollection.hasOwnProperty(p) : boolean
>                                      : ^^^^^^^
>this.fileCollection.hasOwnProperty : (v: PropertyKey) => boolean
>                                   : ^ ^^           ^^^^^       
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>hasOwnProperty : (v: PropertyKey) => boolean
>               : ^ ^^           ^^^^^       
>p : string
>  : ^^^^^^

                        var current = <Harness.Compiler.WriterAggregator>this.fileCollection[p];
>current : WriterAggregator
>        : ^^^^^^^^^^^^^^^^
><Harness.Compiler.WriterAggregator>this.fileCollection[p] : WriterAggregator
>                                                          : ^^^^^^^^^^^^^^^^
>Harness : any
>        : ^^^
>Compiler : any
>         : ^^^
>this.fileCollection[p] : any
>                       : ^^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>p : string
>  : ^^^^^^

                        if (current.lines.length > 0) {
>current.lines.length > 0 : boolean
>                         : ^^^^^^^
>current.lines.length : number
>                     : ^^^^^^
>current.lines : string[]
>              : ^^^^^^^^
>current : WriterAggregator
>        : ^^^^^^^^^^^^^^^^
>lines : string[]
>      : ^^^^^^^^
>length : number
>       : ^^^^^^
>0 : 0
>  : ^

                            if (p !== '0.js') { current.lines.unshift('////[' + p + ']'); }
>p !== '0.js' : boolean
>             : ^^^^^^^
>p : string
>  : ^^^^^^
>'0.js' : "0.js"
>       : ^^^^^^
>current.lines.unshift('////[' + p + ']') : number
>                                         : ^^^^^^
>current.lines.unshift : (...items: string[]) => number
>                      : ^^^^     ^^^^^^^^^^^^^^^      
>current.lines : string[]
>              : ^^^^^^^^
>current : WriterAggregator
>        : ^^^^^^^^^^^^^^^^
>lines : string[]
>      : ^^^^^^^^
>unshift : (...items: string[]) => number
>        : ^^^^     ^^^^^^^^^^^^^^^      
>'////[' + p + ']' : string
>                  : ^^^^^^
>'////[' + p : string
>            : ^^^^^^
>'////[' : "////["
>        : ^^^^^^^
>p : string
>  : ^^^^^^
>']' : "]"
>    : ^^^

                            result.push({ filename: p, file: this.fileCollection[p] });
>result.push({ filename: p, file: this.fileCollection[p] }) : number
>                                                           : ^^^^^^
>result.push : (...items: { filename: string; file: WriterAggregator; }[]) => number
>            : ^^^^     ^^^^^^^^^^^^^^      ^^^^^^^^                ^^^^^^^^^^      
>result : { filename: string; file: WriterAggregator; }[]
>       : ^^^^^^^^^^^^      ^^^^^^^^                ^^^^^
>push : (...items: { filename: string; file: WriterAggregator; }[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^      ^^^^^^^^                ^^^^^^^^^^      
>{ filename: p, file: this.fileCollection[p] } : { filename: string; file: any; }
>                                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>filename : string
>         : ^^^^^^
>p : string
>  : ^^^^^^
>file : any
>     : ^^^
>this.fileCollection[p] : any
>                       : ^^^
>this.fileCollection : {}
>                    : ^^
>this : this
>     : ^^^^
>fileCollection : {}
>               : ^^
>p : string
>  : ^^^^^^
                        }
                    }
                }
                return result;
>result : { filename: string; file: WriterAggregator; }[]
>       : ^^^^^^^^^^^^      ^^^^^^^^                ^^^^^
            }
        }

        var libFolder: string = global['WScript'] ? TypeScript.filePath(global['WScript'].ScriptFullName) : (__dirname + '/');
>libFolder : string
>          : ^^^^^^
>global['WScript'] ? TypeScript.filePath(global['WScript'].ScriptFullName) : (__dirname + '/') : any
>                                                                                              : ^^^
>global['WScript'] : any
>                  : ^^^
>global : any
>       : ^^^
>'WScript' : "WScript"
>          : ^^^^^^^^^
>TypeScript.filePath(global['WScript'].ScriptFullName) : any
>                                                      : ^^^
>TypeScript.filePath : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>filePath : any
>         : ^^^
>global['WScript'].ScriptFullName : any
>                                 : ^^^
>global['WScript'] : any
>                  : ^^^
>global : any
>       : ^^^
>'WScript' : "WScript"
>          : ^^^^^^^^^
>ScriptFullName : any
>               : ^^^
>(__dirname + '/') : string
>                  : ^^^^^^
>__dirname + '/' : string
>                : ^^^^^^
>__dirname : any
>          : ^^^
>'/' : "/"
>    : ^^^

        export var libText = IO ? IO.readFile(libFolder + "lib.d.ts") : '';
>libText : any
>        : ^^^
>IO ? IO.readFile(libFolder + "lib.d.ts") : '' : any
>                                              : ^^^
>IO : IIO
>   : ^^^
>IO.readFile(libFolder + "lib.d.ts") : any
>                                    : ^^^
>IO.readFile : any
>            : ^^^
>IO : IIO
>   : ^^^
>readFile : any
>         : ^^^
>libFolder + "lib.d.ts" : string
>                       : ^^^^^^
>libFolder : string
>          : ^^^^^^
>"lib.d.ts" : "lib.d.ts"
>           : ^^^^^^^^^^
>'' : ""
>   : ^^

        var stdout = new EmitterIOHost();
>stdout : EmitterIOHost
>       : ^^^^^^^^^^^^^
>new EmitterIOHost() : EmitterIOHost
>                    : ^^^^^^^^^^^^^
>EmitterIOHost : typeof EmitterIOHost
>              : ^^^^^^^^^^^^^^^^^^^^

        var stderr = new WriterAggregator();
>stderr : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
>new WriterAggregator() : WriterAggregator
>                       : ^^^^^^^^^^^^^^^^
>WriterAggregator : typeof WriterAggregator
>                 : ^^^^^^^^^^^^^^^^^^^^^^^

        export function isDeclareFile(filename: string) {
>isDeclareFile : (filename: string) => boolean
>              : ^        ^^      ^^^^^^^^^^^^
>filename : string
>         : ^^^^^^

            return /\.d\.ts$/.test(filename);
>/\.d\.ts$/.test(filename) : boolean
>                          : ^^^^^^^
>/\.d\.ts$/.test : (string: string) => boolean
>                : ^      ^^      ^^^^^       
>/\.d\.ts$/ : RegExp
>           : ^^^^^^
>test : (string: string) => boolean
>     : ^      ^^      ^^^^^       
>filename : string
>         : ^^^^^^
        }

        export function makeDefaultCompilerForTest(c?: TypeScript.TypeScriptCompiler) {
>makeDefaultCompilerForTest : (c?: TypeScript.TypeScriptCompiler) => any
>                           : ^ ^^^                             ^^^^^^^^
>c : TypeScript.TypeScriptCompiler
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            var compiler = c || new TypeScript.TypeScriptCompiler(stderr);
>compiler : any
>         : ^^^
>c || new TypeScript.TypeScriptCompiler(stderr) : any
>                                               : ^^^
>c : TypeScript.TypeScriptCompiler
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>new TypeScript.TypeScriptCompiler(stderr) : any
>                                          : ^^^
>TypeScript.TypeScriptCompiler : any
>                              : ^^^
>TypeScript : any
>           : ^^^
>TypeScriptCompiler : any
>                   : ^^^
>stderr : WriterAggregator
>       : ^^^^^^^^^^^^^^^^

            compiler.parser.errorRecovery = true;
>compiler.parser.errorRecovery = true : true
>                                     : ^^^^
>compiler.parser.errorRecovery : any
>                              : ^^^
>compiler.parser : any
>                : ^^^
>compiler : any
>         : ^^^
>parser : any
>       : ^^^
>errorRecovery : any
>              : ^^^
>true : true
>     : ^^^^

            compiler.settings.codeGenTarget = TypeScript.CodeGenTarget.ES5;
>compiler.settings.codeGenTarget = TypeScript.CodeGenTarget.ES5 : any
>                                                               : ^^^
>compiler.settings.codeGenTarget : any
>                                : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : any
>         : ^^^
>settings : any
>         : ^^^
>codeGenTarget : any
>              : ^^^
>TypeScript.CodeGenTarget.ES5 : any
>                             : ^^^
>TypeScript.CodeGenTarget : any
>                         : ^^^
>TypeScript : any
>           : ^^^
>CodeGenTarget : any
>              : ^^^
>ES5 : any
>    : ^^^

            compiler.settings.controlFlow = true;
>compiler.settings.controlFlow = true : true
>                                     : ^^^^
>compiler.settings.controlFlow : any
>                              : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : any
>         : ^^^
>settings : any
>         : ^^^
>controlFlow : any
>            : ^^^
>true : true
>     : ^^^^

            compiler.settings.controlFlowUseDef = true;
>compiler.settings.controlFlowUseDef = true : true
>                                           : ^^^^
>compiler.settings.controlFlowUseDef : any
>                                    : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : any
>         : ^^^
>settings : any
>         : ^^^
>controlFlowUseDef : any
>                  : ^^^
>true : true
>     : ^^^^

            if (Harness.usePull) {
>Harness.usePull : boolean
>                : ^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>usePull : boolean
>        : ^^^^^^^

                compiler.settings.usePull = true;
>compiler.settings.usePull = true : true
>                                 : ^^^^
>compiler.settings.usePull : any
>                          : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : any
>         : ^^^
>settings : any
>         : ^^^
>usePull : any
>        : ^^^
>true : true
>     : ^^^^

                compiler.settings.useFidelity = true;
>compiler.settings.useFidelity = true : true
>                                     : ^^^^
>compiler.settings.useFidelity : any
>                              : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : any
>         : ^^^
>settings : any
>         : ^^^
>useFidelity : any
>            : ^^^
>true : true
>     : ^^^^
            }

            compiler.parseEmitOption(stdout);
>compiler.parseEmitOption(stdout) : any
>                                 : ^^^
>compiler.parseEmitOption : any
>                         : ^^^
>compiler : any
>         : ^^^
>parseEmitOption : any
>                : ^^^
>stdout : EmitterIOHost
>       : ^^^^^^^^^^^^^

            TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;
>TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous : any
>                                                                    : ^^^
>TypeScript.moduleGenTarget : any
>                           : ^^^
>TypeScript : any
>           : ^^^
>moduleGenTarget : any
>                : ^^^
>TypeScript.ModuleGenTarget.Synchronous : any
>                                       : ^^^
>TypeScript.ModuleGenTarget : any
>                           : ^^^
>TypeScript : any
>           : ^^^
>ModuleGenTarget : any
>                : ^^^
>Synchronous : any
>            : ^^^

            compiler.addUnit(Harness.Compiler.libText, "lib.d.ts", true);
>compiler.addUnit(Harness.Compiler.libText, "lib.d.ts", true) : any
>                                                             : ^^^
>compiler.addUnit : any
>                 : ^^^
>compiler : any
>         : ^^^
>addUnit : any
>        : ^^^
>Harness.Compiler.libText : any
>                         : ^^^
>Harness.Compiler : typeof Compiler
>                 : ^^^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>libText : any
>        : ^^^
>"lib.d.ts" : "lib.d.ts"
>           : ^^^^^^^^^^
>true : true
>     : ^^^^

            return compiler;
>compiler : any
>         : ^^^
        }

        var compiler: TypeScript.TypeScriptCompiler;
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

        recreate();
>recreate() : void
>           : ^^^^
>recreate : () => void
>         : ^^^^^^^^^^

        // pullUpdateUnit is sufficient if an existing unit is updated, if a new unit is added we need to do a full typecheck
        var needsFullTypeCheck = true;
>needsFullTypeCheck : boolean
>                   : ^^^^^^^
>true : true
>     : ^^^^

        export function compile(code?: string, filename?: string) {
>compile : (code?: string, filename?: string) => void
>        : ^    ^^^      ^^        ^^^      ^^^^^^^^^
>code : string
>     : ^^^^^^
>filename : string
>         : ^^^^^^

            if (usePull) {
>usePull : boolean
>        : ^^^^^^^

                if (needsFullTypeCheck) {
>needsFullTypeCheck : boolean
>                   : ^^^^^^^

                    compiler.pullTypeCheck(true);
>compiler.pullTypeCheck(true) : any
>                             : ^^^
>compiler.pullTypeCheck : any
>                       : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullTypeCheck : any
>              : ^^^
>true : true
>     : ^^^^

                    needsFullTypeCheck = false;
>needsFullTypeCheck = false : false
>                           : ^^^^^
>needsFullTypeCheck : boolean
>                   : ^^^^^^^
>false : false
>      : ^^^^^
                }
                else {
                    // requires unit to already exist in the compiler
                    compiler.pullUpdateUnit(new TypeScript.StringSourceText(""), filename, true);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(""), filename, true) : any
>                                                                             : ^^^
>compiler.pullUpdateUnit : any
>                        : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullUpdateUnit : any
>               : ^^^
>new TypeScript.StringSourceText("") : any
>                                    : ^^^
>TypeScript.StringSourceText : any
>                            : ^^^
>TypeScript : any
>           : ^^^
>StringSourceText : any
>                 : ^^^
>"" : ""
>   : ^^
>filename : string
>         : ^^^^^^
>true : true
>     : ^^^^

                    compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), filename, true);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), filename, true) : any
>                                                                               : ^^^
>compiler.pullUpdateUnit : any
>                        : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullUpdateUnit : any
>               : ^^^
>new TypeScript.StringSourceText(code) : any
>                                      : ^^^
>TypeScript.StringSourceText : any
>                            : ^^^
>TypeScript : any
>           : ^^^
>StringSourceText : any
>                 : ^^^
>code : string
>     : ^^^^^^
>filename : string
>         : ^^^^^^
>true : true
>     : ^^^^
                }
            }
            else {
                compiler.reTypeCheck();
>compiler.reTypeCheck() : any
>                       : ^^^
>compiler.reTypeCheck : any
>                     : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>reTypeCheck : any
>            : ^^^
            }
        }

        // Types
        export class Type {
>Type : Type
>     : ^^^^

            constructor(public type, public code, public identifier) { }
>type : any
>     : ^^^
>code : any
>     : ^^^
>identifier : any
>           : ^^^

            public normalizeToArray(arg: any) {
>normalizeToArray : (arg: any) => any[]
>                 : ^   ^^   ^^^^^^^^^^
>arg : any
>    : ^^^

                if ((Array.isArray && Array.isArray(arg)) || arg instanceof Array)
>(Array.isArray && Array.isArray(arg)) || arg instanceof Array : boolean
>                                                              : ^^^^^^^
>(Array.isArray && Array.isArray(arg)) : boolean
>                                      : ^^^^^^^
>Array.isArray && Array.isArray(arg) : boolean
>                                    : ^^^^^^^
>Array.isArray : (arg: any) => arg is any[]
>              : ^   ^^   ^^^^^            
>Array : ArrayConstructor
>      : ^^^^^^^^^^^^^^^^
>isArray : (arg: any) => arg is any[]
>        : ^   ^^   ^^^^^            
>Array.isArray(arg) : boolean
>                   : ^^^^^^^
>Array.isArray : (arg: any) => arg is any[]
>              : ^   ^^   ^^^^^            
>Array : ArrayConstructor
>      : ^^^^^^^^^^^^^^^^
>isArray : (arg: any) => arg is any[]
>        : ^   ^^   ^^^^^            
>arg : any
>    : ^^^
>arg instanceof Array : boolean
>                     : ^^^^^^^
>arg : any
>    : ^^^
>Array : ArrayConstructor
>      : ^^^^^^^^^^^^^^^^

                    return arg;
>arg : any[]
>    : ^^^^^

                return [arg];
>[arg] : any[]
>      : ^^^^^
>arg : any
>    : ^^^
            }

            public compilesOk(testCode): boolean {
>compilesOk : (testCode: any) => boolean
>           : ^        ^^^^^^^^^^       
>testCode : any
>         : ^^^

                var errors = null;
>errors : any
>       : ^^^

                compileString(testCode, 'test.ts', function (compilerResult) {
>compileString(testCode, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : void
>                                                                                                                                    : ^^^^
>compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>              : ^    ^^      ^^        ^^      ^^        ^^                                      ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>testCode : any
>         : ^^^
>'test.ts' : "test.ts"
>          : ^^^^^^^^^
>function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => void
>                                                                                                : ^              ^^^^^^^^^^^^^^^^^^^^^^^^^
>compilerResult : CompilerResult
>               : ^^^^^^^^^^^^^^

                    errors = compilerResult.errors;
>errors = compilerResult.errors : CompilerError[]
>                               : ^^^^^^^^^^^^^^^
>errors : any
>       : ^^^
>compilerResult.errors : CompilerError[]
>                      : ^^^^^^^^^^^^^^^
>compilerResult : CompilerResult
>               : ^^^^^^^^^^^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^

                })

                return errors.length === 0;
>errors.length === 0 : boolean
>                    : ^^^^^^^
>errors.length : any
>              : ^^^
>errors : any
>       : ^^^
>length : any
>       : ^^^
>0 : 0
>  : ^
            }

            public isSubtypeOf(other: Type) {
>isSubtypeOf : (other: Type) => boolean
>            : ^     ^^    ^^^^^^^^^^^^
>other : Type
>      : ^^^^

                var testCode = 'class __test1__ {\n';
>testCode : string
>         : ^^^^^^
>'class __test1__ {\n' : "class __test1__ {\n"
>                      : ^^^^^^^^^^^^^^^^^^^^^

                testCode += '    public test() {\n';
>testCode += '    public test() {\n' : string
>                                    : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    public test() {\n' : "    public test() {\n"
>                        : ^^^^^^^^^^^^^^^^^^^^^^^

                testCode += '        ' + other.code + ';\n';
>testCode += '        ' + other.code + ';\n' : string
>                                            : ^^^^^^
>testCode : string
>         : ^^^^^^
>'        ' + other.code + ';\n' : string
>                                : ^^^^^^
>'        ' + other.code : string
>                        : ^^^^^^
>'        ' : "        "
>           : ^^^^^^^^^^
>other.code : any
>           : ^^^
>other : Type
>      : ^^^^
>code : any
>     : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '        return ' + other.identifier + ';\n';
>testCode += '        return ' + other.identifier + ';\n' : string
>                                                         : ^^^^^^
>testCode : string
>         : ^^^^^^
>'        return ' + other.identifier + ';\n' : string
>                                             : ^^^^^^
>'        return ' + other.identifier : string
>                                     : ^^^^^^
>'        return ' : "        return "
>                  : ^^^^^^^^^^^^^^^^^
>other.identifier : any
>                 : ^^^
>other : Type
>      : ^^^^
>identifier : any
>           : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '    }\n';
>testCode += '    }\n' : string
>                      : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    }\n' : "    }\n"
>          : ^^^^^^^^^

                testCode += '}\n';
>testCode += '}\n' : string
>                  : ^^^^^^
>testCode : string
>         : ^^^^^^
>'}\n' : "}\n"
>      : ^^^^^

                testCode += 'class __test2__ extends __test1__ {\n';
>testCode += 'class __test2__ extends __test1__ {\n' : string
>                                                    : ^^^^^^
>testCode : string
>         : ^^^^^^
>'class __test2__ extends __test1__ {\n' : "class __test2__ extends __test1__ {\n"
>                                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                testCode += '    public test() {\n';
>testCode += '    public test() {\n' : string
>                                    : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    public test() {\n' : "    public test() {\n"
>                        : ^^^^^^^^^^^^^^^^^^^^^^^

                testCode += '        ' + this.code + ';\n';
>testCode += '        ' + this.code + ';\n' : string
>                                           : ^^^^^^
>testCode : string
>         : ^^^^^^
>'        ' + this.code + ';\n' : string
>                               : ^^^^^^
>'        ' + this.code : string
>                       : ^^^^^^
>'        ' : "        "
>           : ^^^^^^^^^^
>this.code : any
>          : ^^^
>this : this
>     : ^^^^
>code : any
>     : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '        return ' + other.identifier + ';\n';
>testCode += '        return ' + other.identifier + ';\n' : string
>                                                         : ^^^^^^
>testCode : string
>         : ^^^^^^
>'        return ' + other.identifier + ';\n' : string
>                                             : ^^^^^^
>'        return ' + other.identifier : string
>                                     : ^^^^^^
>'        return ' : "        return "
>                  : ^^^^^^^^^^^^^^^^^
>other.identifier : any
>                 : ^^^
>other : Type
>      : ^^^^
>identifier : any
>           : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '    }\n';
>testCode += '    }\n' : string
>                      : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    }\n' : "    }\n"
>          : ^^^^^^^^^

                testCode += '}\n';
>testCode += '}\n' : string
>                  : ^^^^^^
>testCode : string
>         : ^^^^^^
>'}\n' : "}\n"
>      : ^^^^^

                return this.compilesOk(testCode);
>this.compilesOk(testCode) : boolean
>                          : ^^^^^^^
>this.compilesOk : (testCode: any) => boolean
>                : ^        ^^^^^^^^^^       
>this : this
>     : ^^^^
>compilesOk : (testCode: any) => boolean
>           : ^        ^^^^^^^^^^       
>testCode : string
>         : ^^^^^^
            }

            // TODO: Find an implementation of isIdenticalTo that works.
            //public isIdenticalTo(other: Type) {
            //    var testCode = 'module __test1__ {\n';
            //    testCode += '    ' + this.code + ';\n';
            //    testCode += '    export var __val__ = ' + this.identifier + ';\n';
            //    testCode += '}\n';
            //    testCode += 'var __test1__val__ = __test1__.__val__;\n';

            //    testCode += 'module __test2__ {\n';
            //    testCode += '    ' + other.code + ';\n';
            //    testCode += '    export var __val__ = ' + other.identifier + ';\n';
            //    testCode += '}\n';
            //    testCode += 'var __test2__val__ = __test2__.__val__;\n';

            //    testCode += 'function __test__function__() { if(true) { return __test1__val__ }; return __test2__val__; }';

            //    return this.compilesOk(testCode);
            //}

            public assertSubtypeOf(others: any) {
>assertSubtypeOf : (others: any) => void
>                : ^      ^^   ^^^^^^^^^
>others : any
>       : ^^^

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>                                       : ^^^^^
>others : any
>       : ^^^
>this.normalizeToArray(others) : any[]
>                              : ^^^^^
>this.normalizeToArray : (arg: any) => any[]
>                      : ^   ^^   ^^^^^^^^^^
>this : this
>     : ^^^^
>normalizeToArray : (arg: any) => any[]
>                 : ^   ^^   ^^^^^^^^^^
>others : any
>       : ^^^

                for (var i = 0; i < others.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < others.length : boolean
>                  : ^^^^^^^
>i : number
>  : ^^^^^^
>others.length : any
>              : ^^^
>others : any
>       : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    if (!this.isSubtypeOf(others[i])) {
>!this.isSubtypeOf(others[i]) : boolean
>                             : ^^^^^^^
>this.isSubtypeOf(others[i]) : boolean
>                            : ^^^^^^^
>this.isSubtypeOf : (other: Type) => boolean
>                 : ^     ^^    ^^^^^^^^^^^^
>this : this
>     : ^^^^
>isSubtypeOf : (other: Type) => boolean
>            : ^     ^^    ^^^^^^^^^^^^
>others[i] : any
>          : ^^^
>others : any
>       : ^^^
>i : number
>  : ^^^^^^

                        throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
>new Error("Expected " + this.type + " to be a subtype of " + others[i].type) : Error
>                                                                             : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected " + this.type + " to be a subtype of " + others[i].type : string
>                                                                  : ^^^^^^
>"Expected " + this.type + " to be a subtype of " : string
>                                                 : ^^^^^^
>"Expected " + this.type : string
>                        : ^^^^^^
>"Expected " : "Expected "
>            : ^^^^^^^^^^^
>this.type : any
>          : ^^^
>this : this
>     : ^^^^
>type : any
>     : ^^^
>" to be a subtype of " : " to be a subtype of "
>                       : ^^^^^^^^^^^^^^^^^^^^^^
>others[i].type : any
>               : ^^^
>others[i] : any
>          : ^^^
>others : any
>       : ^^^
>i : number
>  : ^^^^^^
>type : any
>     : ^^^
                    }
                }
            }

            public assertNotSubtypeOf(others: any) {
>assertNotSubtypeOf : (others: any) => void
>                   : ^      ^^   ^^^^^^^^^
>others : any
>       : ^^^

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>                                       : ^^^^^
>others : any
>       : ^^^
>this.normalizeToArray(others) : any[]
>                              : ^^^^^
>this.normalizeToArray : (arg: any) => any[]
>                      : ^   ^^   ^^^^^^^^^^
>this : this
>     : ^^^^
>normalizeToArray : (arg: any) => any[]
>                 : ^   ^^   ^^^^^^^^^^
>others : any
>       : ^^^

                for (var i = 0; i < others.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < others.length : boolean
>                  : ^^^^^^^
>i : number
>  : ^^^^^^
>others.length : any
>              : ^^^
>others : any
>       : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    if (this.isSubtypeOf(others[i])) {
>this.isSubtypeOf(others[i]) : boolean
>                            : ^^^^^^^
>this.isSubtypeOf : (other: Type) => boolean
>                 : ^     ^^    ^^^^^^^^^^^^
>this : this
>     : ^^^^
>isSubtypeOf : (other: Type) => boolean
>            : ^     ^^    ^^^^^^^^^^^^
>others[i] : any
>          : ^^^
>others : any
>       : ^^^
>i : number
>  : ^^^^^^

                        throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
>new Error("Expected " + this.type + " to be a subtype of " + others[i].type) : Error
>                                                                             : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected " + this.type + " to be a subtype of " + others[i].type : string
>                                                                  : ^^^^^^
>"Expected " + this.type + " to be a subtype of " : string
>                                                 : ^^^^^^
>"Expected " + this.type : string
>                        : ^^^^^^
>"Expected " : "Expected "
>            : ^^^^^^^^^^^
>this.type : any
>          : ^^^
>this : this
>     : ^^^^
>type : any
>     : ^^^
>" to be a subtype of " : " to be a subtype of "
>                       : ^^^^^^^^^^^^^^^^^^^^^^
>others[i].type : any
>               : ^^^
>others[i] : any
>          : ^^^
>others : any
>       : ^^^
>i : number
>  : ^^^^^^
>type : any
>     : ^^^
                    }
                }
            }

            //public assertIdenticalTo(other: Type) {
            //    if (!this.isIdenticalTo(other)) {
            //        throw new Error("Expected " + this.type + " to be identical to " + other.type);
            //    }
            //}

            //public assertNotIdenticalTo(other: Type) {
            //    if (!this.isIdenticalTo(other)) {
            //        throw new Error("Expected " + this.type + " to not be identical to " + other.type);
            //    }
            //}

            public isAssignmentCompatibleWith(other: Type) {
>isAssignmentCompatibleWith : (other: Type) => boolean
>                           : ^     ^^    ^^^^^^^^^^^^
>other : Type
>      : ^^^^

                var testCode = 'module __test1__ {\n';
>testCode : string
>         : ^^^^^^
>'module __test1__ {\n' : "module __test1__ {\n"
>                       : ^^^^^^^^^^^^^^^^^^^^^^

                testCode += '    ' + this.code + ';\n';
>testCode += '    ' + this.code + ';\n' : string
>                                       : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    ' + this.code + ';\n' : string
>                           : ^^^^^^
>'    ' + this.code : string
>                   : ^^^^^^
>'    ' : "    "
>       : ^^^^^^
>this.code : any
>          : ^^^
>this : this
>     : ^^^^
>code : any
>     : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '    export var __val__ = ' + this.identifier + ';\n';
>testCode += '    export var __val__ = ' + this.identifier + ';\n' : string
>                                                                  : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    export var __val__ = ' + this.identifier + ';\n' : string
>                                                      : ^^^^^^
>'    export var __val__ = ' + this.identifier : string
>                                              : ^^^^^^
>'    export var __val__ = ' : "    export var __val__ = "
>                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>this.identifier : any
>                : ^^^
>this : this
>     : ^^^^
>identifier : any
>           : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '}\n';
>testCode += '}\n' : string
>                  : ^^^^^^
>testCode : string
>         : ^^^^^^
>'}\n' : "}\n"
>      : ^^^^^

                testCode += 'var __test1__val__ = __test1__.__val__;\n';
>testCode += 'var __test1__val__ = __test1__.__val__;\n' : string
>                                                        : ^^^^^^
>testCode : string
>         : ^^^^^^
>'var __test1__val__ = __test1__.__val__;\n' : "var __test1__val__ = __test1__.__val__;\n"
>                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                testCode += 'module __test2__ {\n';
>testCode += 'module __test2__ {\n' : string
>                                   : ^^^^^^
>testCode : string
>         : ^^^^^^
>'module __test2__ {\n' : "module __test2__ {\n"
>                       : ^^^^^^^^^^^^^^^^^^^^^^

                testCode += '    export ' + other.code + ';\n';
>testCode += '    export ' + other.code + ';\n' : string
>                                               : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    export ' + other.code + ';\n' : string
>                                   : ^^^^^^
>'    export ' + other.code : string
>                           : ^^^^^^
>'    export ' : "    export "
>              : ^^^^^^^^^^^^^
>other.code : any
>           : ^^^
>other : Type
>      : ^^^^
>code : any
>     : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '    export var __val__ = ' + other.identifier + ';\n';
>testCode += '    export var __val__ = ' + other.identifier + ';\n' : string
>                                                                   : ^^^^^^
>testCode : string
>         : ^^^^^^
>'    export var __val__ = ' + other.identifier + ';\n' : string
>                                                       : ^^^^^^
>'    export var __val__ = ' + other.identifier : string
>                                               : ^^^^^^
>'    export var __val__ = ' : "    export var __val__ = "
>                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>other.identifier : any
>                 : ^^^
>other : Type
>      : ^^^^
>identifier : any
>           : ^^^
>';\n' : ";\n"
>      : ^^^^^

                testCode += '}\n';
>testCode += '}\n' : string
>                  : ^^^^^^
>testCode : string
>         : ^^^^^^
>'}\n' : "}\n"
>      : ^^^^^

                testCode += 'var __test2__val__ = __test2__.__val__;\n';
>testCode += 'var __test2__val__ = __test2__.__val__;\n' : string
>                                                        : ^^^^^^
>testCode : string
>         : ^^^^^^
>'var __test2__val__ = __test2__.__val__;\n' : "var __test2__val__ = __test2__.__val__;\n"
>                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                testCode += '__test2__val__ = __test1__val__;';
>testCode += '__test2__val__ = __test1__val__;' : string
>                                               : ^^^^^^
>testCode : string
>         : ^^^^^^
>'__test2__val__ = __test1__val__;' : "__test2__val__ = __test1__val__;"
>                                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                return this.compilesOk(testCode);
>this.compilesOk(testCode) : boolean
>                          : ^^^^^^^
>this.compilesOk : (testCode: any) => boolean
>                : ^        ^^^^^^^^^^       
>this : this
>     : ^^^^
>compilesOk : (testCode: any) => boolean
>           : ^        ^^^^^^^^^^       
>testCode : string
>         : ^^^^^^
            }

            public assertAssignmentCompatibleWith(others: any) {
>assertAssignmentCompatibleWith : (others: any) => void
>                               : ^      ^^   ^^^^^^^^^
>others : any
>       : ^^^

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>                                       : ^^^^^
>others : any
>       : ^^^
>this.normalizeToArray(others) : any[]
>                              : ^^^^^
>this.normalizeToArray : (arg: any) => any[]
>                      : ^   ^^   ^^^^^^^^^^
>this : this
>     : ^^^^
>normalizeToArray : (arg: any) => any[]
>                 : ^   ^^   ^^^^^^^^^^
>others : any
>       : ^^^

                for (var i = 0; i < others.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < others.length : boolean
>                  : ^^^^^^^
>i : number
>  : ^^^^^^
>others.length : any
>              : ^^^
>others : any
>       : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    var other = others[i];
>other : any
>      : ^^^
>others[i] : any
>          : ^^^
>others : any
>       : ^^^
>i : number
>  : ^^^^^^

                    if (!this.isAssignmentCompatibleWith(other)) {
>!this.isAssignmentCompatibleWith(other) : boolean
>                                        : ^^^^^^^
>this.isAssignmentCompatibleWith(other) : boolean
>                                       : ^^^^^^^
>this.isAssignmentCompatibleWith : (other: Type) => boolean
>                                : ^     ^^    ^^^^^^^^^^^^
>this : this
>     : ^^^^
>isAssignmentCompatibleWith : (other: Type) => boolean
>                           : ^     ^^    ^^^^^^^^^^^^
>other : any
>      : ^^^

                        throw new Error("Expected " + this.type + " to be assignment compatible with " + other.type);
>new Error("Expected " + this.type + " to be assignment compatible with " + other.type) : Error
>                                                                                       : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected " + this.type + " to be assignment compatible with " + other.type : string
>                                                                            : ^^^^^^
>"Expected " + this.type + " to be assignment compatible with " : string
>                                                               : ^^^^^^
>"Expected " + this.type : string
>                        : ^^^^^^
>"Expected " : "Expected "
>            : ^^^^^^^^^^^
>this.type : any
>          : ^^^
>this : this
>     : ^^^^
>type : any
>     : ^^^
>" to be assignment compatible with " : " to be assignment compatible with "
>                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>other.type : any
>           : ^^^
>other : any
>      : ^^^
>type : any
>     : ^^^
                    }
                }
            }

            public assertNotAssignmentCompatibleWith(others: any) {
>assertNotAssignmentCompatibleWith : (others: any) => void
>                                  : ^      ^^   ^^^^^^^^^
>others : any
>       : ^^^

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>                                       : ^^^^^
>others : any
>       : ^^^
>this.normalizeToArray(others) : any[]
>                              : ^^^^^
>this.normalizeToArray : (arg: any) => any[]
>                      : ^   ^^   ^^^^^^^^^^
>this : this
>     : ^^^^
>normalizeToArray : (arg: any) => any[]
>                 : ^   ^^   ^^^^^^^^^^
>others : any
>       : ^^^

                for (var i = 0; i < others.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < others.length : boolean
>                  : ^^^^^^^
>i : number
>  : ^^^^^^
>others.length : any
>              : ^^^
>others : any
>       : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    var other = others[i];
>other : any
>      : ^^^
>others[i] : any
>          : ^^^
>others : any
>       : ^^^
>i : number
>  : ^^^^^^

                    if (this.isAssignmentCompatibleWith(other)) {
>this.isAssignmentCompatibleWith(other) : boolean
>                                       : ^^^^^^^
>this.isAssignmentCompatibleWith : (other: Type) => boolean
>                                : ^     ^^    ^^^^^^^^^^^^
>this : this
>     : ^^^^
>isAssignmentCompatibleWith : (other: Type) => boolean
>                           : ^     ^^    ^^^^^^^^^^^^
>other : any
>      : ^^^

                        throw new Error("Expected " + this.type + " to not be assignment compatible with " + other.type);
>new Error("Expected " + this.type + " to not be assignment compatible with " + other.type) : Error
>                                                                                           : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected " + this.type + " to not be assignment compatible with " + other.type : string
>                                                                                : ^^^^^^
>"Expected " + this.type + " to not be assignment compatible with " : string
>                                                                   : ^^^^^^
>"Expected " + this.type : string
>                        : ^^^^^^
>"Expected " : "Expected "
>            : ^^^^^^^^^^^
>this.type : any
>          : ^^^
>this : this
>     : ^^^^
>type : any
>     : ^^^
>" to not be assignment compatible with " : " to not be assignment compatible with "
>                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>other.type : any
>           : ^^^
>other : any
>      : ^^^
>type : any
>     : ^^^
                    }
                }
            }

            public assertThisCanBeAssignedTo(desc: string, these: any[], notThese: any[]) {
>assertThisCanBeAssignedTo : (desc: string, these: any[], notThese: any[]) => void
>                          : ^    ^^      ^^     ^^     ^^        ^^     ^^^^^^^^^
>desc : string
>     : ^^^^^^
>these : any[]
>      : ^^^^^
>notThese : any[]
>         : ^^^^^

                it(desc + " is assignable to ", () => {
>it(desc + " is assignable to ", () => {                    this.assertAssignmentCompatibleWith(these);                }) : void
>                                                                                                                         : ^^^^
>it : (description: string, block: () => void) => void
>   : ^           ^^      ^^     ^^          ^^^^^^^^^
>desc + " is assignable to " : string
>                            : ^^^^^^
>desc : string
>     : ^^^^^^
>" is assignable to " : " is assignable to "
>                     : ^^^^^^^^^^^^^^^^^^^^
>() => {                    this.assertAssignmentCompatibleWith(these);                } : () => void
>                                                                                        : ^^^^^^^^^^

                    this.assertAssignmentCompatibleWith(these);
>this.assertAssignmentCompatibleWith(these) : void
>                                           : ^^^^
>this.assertAssignmentCompatibleWith : (others: any) => void
>                                    : ^      ^^   ^^^^^^^^^
>this : this
>     : ^^^^
>assertAssignmentCompatibleWith : (others: any) => void
>                               : ^      ^^   ^^^^^^^^^
>these : any[]
>      : ^^^^^

                });
        
                it(desc + " not assignable to ", () => {
>it(desc + " not assignable to ", () => {                    this.assertNotAssignmentCompatibleWith(notThese);                }) : void
>                                                                                                                                : ^^^^
>it : (description: string, block: () => void) => void
>   : ^           ^^      ^^     ^^          ^^^^^^^^^
>desc + " not assignable to " : string
>                             : ^^^^^^
>desc : string
>     : ^^^^^^
>" not assignable to " : " not assignable to "
>                      : ^^^^^^^^^^^^^^^^^^^^^
>() => {                    this.assertNotAssignmentCompatibleWith(notThese);                } : () => void
>                                                                                              : ^^^^^^^^^^

                    this.assertNotAssignmentCompatibleWith(notThese);
>this.assertNotAssignmentCompatibleWith(notThese) : void
>                                                 : ^^^^
>this.assertNotAssignmentCompatibleWith : (others: any) => void
>                                       : ^      ^^   ^^^^^^^^^
>this : this
>     : ^^^^
>assertNotAssignmentCompatibleWith : (others: any) => void
>                                  : ^      ^^   ^^^^^^^^^
>notThese : any[]
>         : ^^^^^

                });
            }

        }

        export class TypeFactory {
>TypeFactory : TypeFactory
>            : ^^^^^^^^^^^

            public any: Type;
>any : Type
>    : ^^^^

            public number: Type;
>number : Type
>       : ^^^^

            public string: Type;
>string : Type
>       : ^^^^

            public boolean: Type;
>boolean : Type
>        : ^^^^

            constructor() {
                this.any = this.get('var x : any', 'x');
>this.any = this.get('var x : any', 'x') : Type
>                                        : ^^^^
>this.any : Type
>         : ^^^^
>this : this
>     : ^^^^
>any : Type
>    : ^^^^
>this.get('var x : any', 'x') : Type
>                             : ^^^^
>this.get : (code: string, target: any) => Type
>         : ^    ^^      ^^      ^^   ^^^^^^^^^
>this : this
>     : ^^^^
>get : (code: string, target: any) => Type
>    : ^    ^^      ^^      ^^   ^^^^^^^^^
>'var x : any' : "var x : any"
>              : ^^^^^^^^^^^^^
>'x' : "x"
>    : ^^^

                this.number = this.get('var x : number', 'x');
>this.number = this.get('var x : number', 'x') : Type
>                                              : ^^^^
>this.number : Type
>            : ^^^^
>this : this
>     : ^^^^
>number : Type
>       : ^^^^
>this.get('var x : number', 'x') : Type
>                                : ^^^^
>this.get : (code: string, target: any) => Type
>         : ^    ^^      ^^      ^^   ^^^^^^^^^
>this : this
>     : ^^^^
>get : (code: string, target: any) => Type
>    : ^    ^^      ^^      ^^   ^^^^^^^^^
>'var x : number' : "var x : number"
>                 : ^^^^^^^^^^^^^^^^
>'x' : "x"
>    : ^^^

                this.string = this.get('var x : string', 'x');
>this.string = this.get('var x : string', 'x') : Type
>                                              : ^^^^
>this.string : Type
>            : ^^^^
>this : this
>     : ^^^^
>string : Type
>       : ^^^^
>this.get('var x : string', 'x') : Type
>                                : ^^^^
>this.get : (code: string, target: any) => Type
>         : ^    ^^      ^^      ^^   ^^^^^^^^^
>this : this
>     : ^^^^
>get : (code: string, target: any) => Type
>    : ^    ^^      ^^      ^^   ^^^^^^^^^
>'var x : string' : "var x : string"
>                 : ^^^^^^^^^^^^^^^^
>'x' : "x"
>    : ^^^

                this.boolean = this.get('var x : boolean', 'x');
>this.boolean = this.get('var x : boolean', 'x') : Type
>                                                : ^^^^
>this.boolean : Type
>             : ^^^^
>this : this
>     : ^^^^
>boolean : Type
>        : ^^^^
>this.get('var x : boolean', 'x') : Type
>                                 : ^^^^
>this.get : (code: string, target: any) => Type
>         : ^    ^^      ^^      ^^   ^^^^^^^^^
>this : this
>     : ^^^^
>get : (code: string, target: any) => Type
>    : ^    ^^      ^^      ^^   ^^^^^^^^^
>'var x : boolean' : "var x : boolean"
>                  : ^^^^^^^^^^^^^^^^^
>'x' : "x"
>    : ^^^
            }

            public get (code: string, target: any) {
>get : (code: string, target: any) => Type
>    : ^    ^^      ^^      ^^   ^^^^^^^^^
>code : string
>     : ^^^^^^
>target : any
>       : ^^^

                var targetIdentifier = '';
>targetIdentifier : string
>                 : ^^^^^^
>'' : ""
>   : ^^

                var targetPosition = -1;
>targetPosition : number
>               : ^^^^^^
>-1 : -1
>   : ^^
>1 : 1
>  : ^

                if (typeof target === "string") {
>typeof target === "string" : boolean
>                           : ^^^^^^^
>typeof target : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>target : any
>       : ^^^
>"string" : "string"
>         : ^^^^^^^^

                    targetIdentifier = target;
>targetIdentifier = target : string
>                          : ^^^^^^
>targetIdentifier : string
>                 : ^^^^^^
>target : string
>       : ^^^^^^
                }
                else if (typeof target === "number") {
>typeof target === "number" : boolean
>                           : ^^^^^^^
>typeof target : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>target : any
>       : ^^^
>"number" : "number"
>         : ^^^^^^^^

                    targetPosition = target;
>targetPosition = target : number
>                        : ^^^^^^
>targetPosition : number
>               : ^^^^^^
>target : number
>       : ^^^^^^
                }
                else {
                    throw new Error("Expected string or number not " + (typeof target));
>new Error("Expected string or number not " + (typeof target)) : Error
>                                                              : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Expected string or number not " + (typeof target) : string
>                                                   : ^^^^^^
>"Expected string or number not " : "Expected string or number not "
>                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>(typeof target) : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>typeof target : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>target : any
>       : ^^^
                }

                var errors = null;
>errors : any
>       : ^^^

                compileString(code, 'test.ts', function (compilerResult) {
>compileString(code, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : void
>                                                                                                                                : ^^^^
>compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>              : ^    ^^      ^^        ^^      ^^        ^^                                      ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>code : string
>     : ^^^^^^
>'test.ts' : "test.ts"
>          : ^^^^^^^^^
>function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => void
>                                                                                                : ^              ^^^^^^^^^^^^^^^^^^^^^^^^^
>compilerResult : CompilerResult
>               : ^^^^^^^^^^^^^^

                    errors = compilerResult.errors;
>errors = compilerResult.errors : CompilerError[]
>                               : ^^^^^^^^^^^^^^^
>errors : any
>       : ^^^
>compilerResult.errors : CompilerError[]
>                      : ^^^^^^^^^^^^^^^
>compilerResult : CompilerResult
>               : ^^^^^^^^^^^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^

                })

                if (errors.length > 0)
>errors.length > 0 : boolean
>                  : ^^^^^^^
>errors.length : any
>              : ^^^
>errors : any
>       : ^^^
>length : any
>       : ^^^
>0 : 0
>  : ^

                    throw new Error("Type definition contains errors: " + errors.join(","));
>new Error("Type definition contains errors: " + errors.join(",")) : Error
>                                                                  : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Type definition contains errors: " + errors.join(",") : string
>                                                       : ^^^^^^
>"Type definition contains errors: " : "Type definition contains errors: "
>                                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>errors.join(",") : any
>                 : ^^^
>errors.join : any
>            : ^^^
>errors : any
>       : ^^^
>join : any
>     : ^^^
>"," : ","
>    : ^^^

                var matchingIdentifiers: Type[] = [];
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                if (!usePull) {
>!usePull : boolean
>         : ^^^^^^^
>usePull : boolean
>        : ^^^^^^^

                    // This will find the requested identifier in the first script where it's present, a naive search of each member in each script,
                    // which means this won't play nicely if the same identifier is used in multiple units, but it will enable this to work on multi-file tests.
                    // m = 1 because the first script will always be lib.d.ts which we don't want to search.                                
                    for (var m = 1; m < compiler.scripts.members.length; m++) {
>m : number
>  : ^^^^^^
>1 : 1
>  : ^
>m < compiler.scripts.members.length : boolean
>                                    : ^^^^^^^
>m : number
>  : ^^^^^^
>compiler.scripts.members.length : any
>                                : ^^^
>compiler.scripts.members : any
>                         : ^^^
>compiler.scripts : any
>                 : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>scripts : any
>        : ^^^
>members : any
>        : ^^^
>length : any
>       : ^^^
>m++ : number
>    : ^^^^^^
>m : number
>  : ^^^^^^

                        var script = compiler.scripts.members[m];
>script : any
>       : ^^^
>compiler.scripts.members[m] : any
>                            : ^^^
>compiler.scripts.members : any
>                         : ^^^
>compiler.scripts : any
>                 : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>scripts : any
>        : ^^^
>members : any
>        : ^^^
>m : number
>  : ^^^^^^

                        var enclosingScopeContext = TypeScript.findEnclosingScopeAt(new TypeScript.NullLogger(), <TypeScript.Script>script, new TypeScript.StringSourceText(code), 0, false);
>enclosingScopeContext : any
>                      : ^^^
>TypeScript.findEnclosingScopeAt(new TypeScript.NullLogger(), <TypeScript.Script>script, new TypeScript.StringSourceText(code), 0, false) : any
>                                                                                                                                         : ^^^
>TypeScript.findEnclosingScopeAt : any
>                                : ^^^
>TypeScript : any
>           : ^^^
>findEnclosingScopeAt : any
>                     : ^^^
>new TypeScript.NullLogger() : any
>                            : ^^^
>TypeScript.NullLogger : any
>                      : ^^^
>TypeScript : any
>           : ^^^
>NullLogger : any
>           : ^^^
><TypeScript.Script>script : TypeScript.Script
>                          : ^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>script : any
>       : ^^^
>new TypeScript.StringSourceText(code) : any
>                                      : ^^^
>TypeScript.StringSourceText : any
>                            : ^^^
>TypeScript : any
>           : ^^^
>StringSourceText : any
>                 : ^^^
>code : string
>     : ^^^^^^
>0 : 0
>  : ^
>false : false
>      : ^^^^^

                        var entries = new TypeScript.ScopeTraversal(compiler).getScopeEntries(enclosingScopeContext);
>entries : any
>        : ^^^
>new TypeScript.ScopeTraversal(compiler).getScopeEntries(enclosingScopeContext) : any
>                                                                               : ^^^
>new TypeScript.ScopeTraversal(compiler).getScopeEntries : any
>                                                        : ^^^
>new TypeScript.ScopeTraversal(compiler) : any
>                                        : ^^^
>TypeScript.ScopeTraversal : any
>                          : ^^^
>TypeScript : any
>           : ^^^
>ScopeTraversal : any
>               : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>getScopeEntries : any
>                : ^^^
>enclosingScopeContext : any
>                      : ^^^

                        for (var i = 0; i < entries.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < entries.length : boolean
>                   : ^^^^^^^
>i : number
>  : ^^^^^^
>entries.length : any
>               : ^^^
>entries : any
>        : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                            if (entries[i].name === targetIdentifier) {
>entries[i].name === targetIdentifier : boolean
>                                     : ^^^^^^^
>entries[i].name : any
>                : ^^^
>entries[i] : any
>           : ^^^
>entries : any
>        : ^^^
>i : number
>  : ^^^^^^
>name : any
>     : ^^^
>targetIdentifier : string
>                 : ^^^^^^

                                matchingIdentifiers.push(new Type(entries[i].type, code, targetIdentifier));
>matchingIdentifiers.push(new Type(entries[i].type, code, targetIdentifier)) : number
>                                                                            : ^^^^^^
>matchingIdentifiers.push : (...items: Type[]) => number
>                         : ^^^^     ^^^^^^^^^^^^^      
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>push : (...items: Type[]) => number
>     : ^^^^     ^^^^^^^^^^^^^      
>new Type(entries[i].type, code, targetIdentifier) : Type
>                                                  : ^^^^
>Type : typeof Type
>     : ^^^^^^^^^^^
>entries[i].type : any
>                : ^^^
>entries[i] : any
>           : ^^^
>entries : any
>        : ^^^
>i : number
>  : ^^^^^^
>type : any
>     : ^^^
>code : string
>     : ^^^^^^
>targetIdentifier : string
>                 : ^^^^^^
                            }
                        }
                    }
                }
                else {
                    for (var m = 0; m < compiler.scripts.members.length; m++) {
>m : number
>  : ^^^^^^
>0 : 0
>  : ^
>m < compiler.scripts.members.length : boolean
>                                    : ^^^^^^^
>m : number
>  : ^^^^^^
>compiler.scripts.members.length : any
>                                : ^^^
>compiler.scripts.members : any
>                         : ^^^
>compiler.scripts : any
>                 : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>scripts : any
>        : ^^^
>members : any
>        : ^^^
>length : any
>       : ^^^
>m++ : number
>    : ^^^^^^
>m : number
>  : ^^^^^^

                        var script2 = <TypeScript.Script>compiler.scripts.members[m];
>script2 : TypeScript.Script
>        : ^^^^^^^^^^^^^^^^^
><TypeScript.Script>compiler.scripts.members[m] : TypeScript.Script
>                                               : ^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>compiler.scripts.members[m] : any
>                            : ^^^
>compiler.scripts.members : any
>                         : ^^^
>compiler.scripts : any
>                 : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>scripts : any
>        : ^^^
>members : any
>        : ^^^
>m : number
>  : ^^^^^^

                        if (script2.locationInfo.filename !== 'lib.d.ts') {
>script2.locationInfo.filename !== 'lib.d.ts' : boolean
>                                             : ^^^^^^^
>script2.locationInfo.filename : any
>                              : ^^^
>script2.locationInfo : any
>                     : ^^^
>script2 : TypeScript.Script
>        : ^^^^^^^^^^^^^^^^^
>locationInfo : any
>             : ^^^
>filename : any
>         : ^^^
>'lib.d.ts' : "lib.d.ts"
>           : ^^^^^^^^^^

                            if (targetPosition > -1) {
>targetPosition > -1 : boolean
>                    : ^^^^^^^
>targetPosition : number
>               : ^^^^^^
>-1 : -1
>   : ^^
>1 : 1
>  : ^

                                var tyInfo = compiler.pullGetTypeInfoAtPosition(targetPosition, script2);
>tyInfo : any
>       : ^^^
>compiler.pullGetTypeInfoAtPosition(targetPosition, script2) : any
>                                                            : ^^^
>compiler.pullGetTypeInfoAtPosition : any
>                                   : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullGetTypeInfoAtPosition : any
>                          : ^^^
>targetPosition : number
>               : ^^^^^^
>script2 : TypeScript.Script
>        : ^^^^^^^^^^^^^^^^^

                                var name = this.getTypeInfoName(tyInfo.ast);
>name : string
>     : ^^^^^^
>this.getTypeInfoName(tyInfo.ast) : string
>                                 : ^^^^^^
>this.getTypeInfoName : (ast: TypeScript.AST) => string
>                     : ^   ^^              ^^^^^^^^^^^
>this : this
>     : ^^^^
>getTypeInfoName : (ast: TypeScript.AST) => string
>                : ^   ^^              ^^^^^^^^^^^
>tyInfo.ast : any
>           : ^^^
>tyInfo : any
>       : ^^^
>ast : any
>    : ^^^

                                var foundValue = new Type(tyInfo.typeInfo, code, name);
>foundValue : Type
>           : ^^^^
>new Type(tyInfo.typeInfo, code, name) : Type
>                                      : ^^^^
>Type : typeof Type
>     : ^^^^^^^^^^^
>tyInfo.typeInfo : any
>                : ^^^
>tyInfo : any
>       : ^^^
>typeInfo : any
>         : ^^^
>code : string
>     : ^^^^^^
>name : string
>     : ^^^^^^

                                if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
>!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>                                                                                                                                                         : ^^^^^^^
>matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>                                                                                                                                                        : ^^^^^^^
>matchingIdentifiers.some : (predicate: (value: Type, index: number, array: Type[]) => unknown, thisArg?: any) => boolean
>                         : ^         ^^^     ^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^       ^^^   ^^^^^       
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>some : (predicate: (value: Type, index: number, array: Type[]) => unknown, thisArg?: any) => boolean
>     : ^         ^^^     ^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^       ^^^   ^^^^^       
>value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : (value: Type) => boolean
>                                                                                                                              : ^     ^^^^^^^^^^^^^^^^^^
>value : Type
>      : ^^^^
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : boolean
>                                                                                                                     : ^^^^^^^
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) : boolean
>                                                                                 : ^^^^^^^
>(value.identifier === foundValue.identifier) : boolean
>                                             : ^^^^^^^
>value.identifier === foundValue.identifier : boolean
>                                           : ^^^^^^^
>value.identifier : any
>                 : ^^^
>value : Type
>      : ^^^^
>identifier : any
>           : ^^^
>foundValue.identifier : any
>                      : ^^^
>foundValue : Type
>           : ^^^^
>identifier : any
>           : ^^^
>(value.code === foundValue.code) : boolean
>                                 : ^^^^^^^
>value.code === foundValue.code : boolean
>                               : ^^^^^^^
>value.code : any
>           : ^^^
>value : Type
>      : ^^^^
>code : any
>     : ^^^
>foundValue.code : any
>                : ^^^
>foundValue : Type
>           : ^^^^
>code : any
>     : ^^^
>(value.type === foundValue.type) : boolean
>                                 : ^^^^^^^
>value.type === foundValue.type : boolean
>                               : ^^^^^^^
>value.type : any
>           : ^^^
>value : Type
>      : ^^^^
>type : any
>     : ^^^
>foundValue.type : any
>                : ^^^
>foundValue : Type
>           : ^^^^
>type : any
>     : ^^^

                                    matchingIdentifiers.push(foundValue);
>matchingIdentifiers.push(foundValue) : number
>                                     : ^^^^^^
>matchingIdentifiers.push : (...items: Type[]) => number
>                         : ^^^^     ^^^^^^^^^^^^^      
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>push : (...items: Type[]) => number
>     : ^^^^     ^^^^^^^^^^^^^      
>foundValue : Type
>           : ^^^^
                                }
                            }
                            else {
                                for (var pos = 0; pos < code.length; pos++) {
>pos : number
>    : ^^^^^^
>0 : 0
>  : ^
>pos < code.length : boolean
>                  : ^^^^^^^
>pos : number
>    : ^^^^^^
>code.length : number
>            : ^^^^^^
>code : string
>     : ^^^^^^
>length : number
>       : ^^^^^^
>pos++ : number
>      : ^^^^^^
>pos : number
>    : ^^^^^^

                                    var tyInfo = compiler.pullGetTypeInfoAtPosition(pos, script2);
>tyInfo : any
>       : ^^^
>compiler.pullGetTypeInfoAtPosition(pos, script2) : any
>                                                 : ^^^
>compiler.pullGetTypeInfoAtPosition : any
>                                   : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullGetTypeInfoAtPosition : any
>                          : ^^^
>pos : number
>    : ^^^^^^
>script2 : TypeScript.Script
>        : ^^^^^^^^^^^^^^^^^

                                    var name = this.getTypeInfoName(tyInfo.ast);
>name : string
>     : ^^^^^^
>this.getTypeInfoName(tyInfo.ast) : string
>                                 : ^^^^^^
>this.getTypeInfoName : (ast: TypeScript.AST) => string
>                     : ^   ^^              ^^^^^^^^^^^
>this : this
>     : ^^^^
>getTypeInfoName : (ast: TypeScript.AST) => string
>                : ^   ^^              ^^^^^^^^^^^
>tyInfo.ast : any
>           : ^^^
>tyInfo : any
>       : ^^^
>ast : any
>    : ^^^

                                    if (name === targetIdentifier) {
>name === targetIdentifier : boolean
>                          : ^^^^^^^
>name : string
>     : ^^^^^^
>targetIdentifier : string
>                 : ^^^^^^

                                        var foundValue = new Type(tyInfo.typeInfo, code, targetIdentifier);
>foundValue : Type
>           : ^^^^
>new Type(tyInfo.typeInfo, code, targetIdentifier) : Type
>                                                  : ^^^^
>Type : typeof Type
>     : ^^^^^^^^^^^
>tyInfo.typeInfo : any
>                : ^^^
>tyInfo : any
>       : ^^^
>typeInfo : any
>         : ^^^
>code : string
>     : ^^^^^^
>targetIdentifier : string
>                 : ^^^^^^

                                        if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
>!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>                                                                                                                                                         : ^^^^^^^
>matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>                                                                                                                                                        : ^^^^^^^
>matchingIdentifiers.some : (predicate: (value: Type, index: number, array: Type[]) => unknown, thisArg?: any) => boolean
>                         : ^         ^^^     ^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^       ^^^   ^^^^^       
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>some : (predicate: (value: Type, index: number, array: Type[]) => unknown, thisArg?: any) => boolean
>     : ^         ^^^     ^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^       ^^^   ^^^^^       
>value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : (value: Type) => boolean
>                                                                                                                              : ^     ^^^^^^^^^^^^^^^^^^
>value : Type
>      : ^^^^
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : boolean
>                                                                                                                     : ^^^^^^^
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) : boolean
>                                                                                 : ^^^^^^^
>(value.identifier === foundValue.identifier) : boolean
>                                             : ^^^^^^^
>value.identifier === foundValue.identifier : boolean
>                                           : ^^^^^^^
>value.identifier : any
>                 : ^^^
>value : Type
>      : ^^^^
>identifier : any
>           : ^^^
>foundValue.identifier : any
>                      : ^^^
>foundValue : Type
>           : ^^^^
>identifier : any
>           : ^^^
>(value.code === foundValue.code) : boolean
>                                 : ^^^^^^^
>value.code === foundValue.code : boolean
>                               : ^^^^^^^
>value.code : any
>           : ^^^
>value : Type
>      : ^^^^
>code : any
>     : ^^^
>foundValue.code : any
>                : ^^^
>foundValue : Type
>           : ^^^^
>code : any
>     : ^^^
>(value.type === foundValue.type) : boolean
>                                 : ^^^^^^^
>value.type === foundValue.type : boolean
>                               : ^^^^^^^
>value.type : any
>           : ^^^
>value : Type
>      : ^^^^
>type : any
>     : ^^^
>foundValue.type : any
>                : ^^^
>foundValue : Type
>           : ^^^^
>type : any
>     : ^^^

                                            matchingIdentifiers.push(foundValue);
>matchingIdentifiers.push(foundValue) : number
>                                     : ^^^^^^
>matchingIdentifiers.push : (...items: Type[]) => number
>                         : ^^^^     ^^^^^^^^^^^^^      
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>push : (...items: Type[]) => number
>     : ^^^^     ^^^^^^^^^^^^^      
>foundValue : Type
>           : ^^^^
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (matchingIdentifiers.length === 0) {
>matchingIdentifiers.length === 0 : boolean
>                                 : ^^^^^^^
>matchingIdentifiers.length : number
>                           : ^^^^^^
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>length : number
>       : ^^^^^^
>0 : 0
>  : ^

                    if (targetPosition > -1) {
>targetPosition > -1 : boolean
>                    : ^^^^^^^
>targetPosition : number
>               : ^^^^^^
>-1 : -1
>   : ^^
>1 : 1
>  : ^

                        throw new Error("Could not find an identifier at position " + targetPosition);
>new Error("Could not find an identifier at position " + targetPosition) : Error
>                                                                        : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Could not find an identifier at position " + targetPosition : string
>                                                             : ^^^^^^
>"Could not find an identifier at position " : "Could not find an identifier at position "
>                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>targetPosition : number
>               : ^^^^^^
                    }
                    else {
                        throw new Error("Could not find an identifier " + targetIdentifier + " in any known scopes");
>new Error("Could not find an identifier " + targetIdentifier + " in any known scopes") : Error
>                                                                                       : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Could not find an identifier " + targetIdentifier + " in any known scopes" : string
>                                                                            : ^^^^^^
>"Could not find an identifier " + targetIdentifier : string
>                                                   : ^^^^^^
>"Could not find an identifier " : "Could not find an identifier "
>                                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>targetIdentifier : string
>                 : ^^^^^^
>" in any known scopes" : " in any known scopes"
>                       : ^^^^^^^^^^^^^^^^^^^^^^
                    }
                }
                else if (matchingIdentifiers.length > 1) {
>matchingIdentifiers.length > 1 : boolean
>                               : ^^^^^^^
>matchingIdentifiers.length : number
>                           : ^^^^^^
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^

                    throw new Error("Found multiple matching identifiers for " + target);
>new Error("Found multiple matching identifiers for " + target) : Error
>                                                               : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Found multiple matching identifiers for " + target : string
>                                                    : ^^^^^^
>"Found multiple matching identifiers for " : "Found multiple matching identifiers for "
>                                           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>target : string | number
>       : ^^^^^^^^^^^^^^^
                }
                else {
                    return matchingIdentifiers[0];
>matchingIdentifiers[0] : Type
>                       : ^^^^
>matchingIdentifiers : Type[]
>                    : ^^^^^^
>0 : 0
>  : ^
                }
            }

            private getTypeInfoName(ast : TypeScript.AST) {
>getTypeInfoName : (ast: TypeScript.AST) => string
>                : ^   ^^              ^^^^^^^^^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

                var name = '';
>name : string
>     : ^^^^^^
>'' : ""
>   : ^^

                switch (ast.nodeType) {
>ast.nodeType : any
>             : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>nodeType : any
>         : ^^^

                    case TypeScript.NodeType.Name: // Type Name?
>TypeScript.NodeType.Name : any
>                         : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>Name : any
>     : ^^^

                    case TypeScript.NodeType.Null:
>TypeScript.NodeType.Null : any
>                         : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>Null : any
>     : ^^^

                    case TypeScript.NodeType.List:
>TypeScript.NodeType.List : any
>                         : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>List : any
>     : ^^^

                    case TypeScript.NodeType.Empty:
>TypeScript.NodeType.Empty : any
>                          : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>Empty : any
>      : ^^^

                    case TypeScript.NodeType.EmptyExpr:
>TypeScript.NodeType.EmptyExpr : any
>                              : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>EmptyExpr : any
>          : ^^^

                    case TypeScript.NodeType.Asg:
>TypeScript.NodeType.Asg : any
>                        : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>Asg : any
>    : ^^^

                    case TypeScript.NodeType.True:
>TypeScript.NodeType.True : any
>                         : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>True : any
>     : ^^^

                    case TypeScript.NodeType.False:
>TypeScript.NodeType.False : any
>                          : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>False : any
>      : ^^^

                    case TypeScript.NodeType.ArrayLit:
>TypeScript.NodeType.ArrayLit : any
>                             : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>ArrayLit : any
>         : ^^^

                    case TypeScript.NodeType.TypeRef:
>TypeScript.NodeType.TypeRef : any
>                            : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>TypeRef : any
>        : ^^^

                        break;
                    case TypeScript.NodeType.Super:
>TypeScript.NodeType.Super : any
>                          : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>Super : any
>      : ^^^

                        name = (<any>ast).text;
>name = (<any>ast).text : any
>                       : ^^^
>name : string
>     : ^^^^^^
>(<any>ast).text : any
>                : ^^^
>(<any>ast) : any
>           : ^^^
><any>ast : any
>         : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>text : any
>     : ^^^

                        break;
                    case TypeScript.NodeType.Regex:
>TypeScript.NodeType.Regex : any
>                          : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>Regex : any
>      : ^^^

                        name = (<TypeScript.RegexLiteral>ast).text;
>name = (<TypeScript.RegexLiteral>ast).text : any
>                                           : ^^^
>name : string
>     : ^^^^^^
>(<TypeScript.RegexLiteral>ast).text : any
>                                    : ^^^
>(<TypeScript.RegexLiteral>ast) : TypeScript.RegexLiteral
>                               : ^^^^^^^^^^^^^^^^^^^^^^^
><TypeScript.RegexLiteral>ast : TypeScript.RegexLiteral
>                             : ^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>text : any
>     : ^^^

                        break;
                    case TypeScript.NodeType.QString:
>TypeScript.NodeType.QString : any
>                            : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>QString : any
>        : ^^^

                        name = (<any>ast).text;
>name = (<any>ast).text : any
>                       : ^^^
>name : string
>     : ^^^^^^
>(<any>ast).text : any
>                : ^^^
>(<any>ast) : any
>           : ^^^
><any>ast : any
>         : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>text : any
>     : ^^^

                        break;
                    case TypeScript.NodeType.NumberLit:
>TypeScript.NodeType.NumberLit : any
>                              : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>NumberLit : any
>          : ^^^

                        name = (<TypeScript.NumberLiteral>ast).text;
>name = (<TypeScript.NumberLiteral>ast).text : any
>                                            : ^^^
>name : string
>     : ^^^^^^
>(<TypeScript.NumberLiteral>ast).text : any
>                                     : ^^^
>(<TypeScript.NumberLiteral>ast) : TypeScript.NumberLiteral
>                                : ^^^^^^^^^^^^^^^^^^^^^^^^
><TypeScript.NumberLiteral>ast : TypeScript.NumberLiteral
>                              : ^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>text : any
>     : ^^^

                        break;
                    case TypeScript.NodeType.Return:
>TypeScript.NodeType.Return : any
>                           : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>Return : any
>       : ^^^

                        //name = (<TypeScript.ReturnStatement>tyInfo.ast).returnExpression.actualText; // why is this complaining?
                        break;
                    case TypeScript.NodeType.InterfaceDeclaration:
>TypeScript.NodeType.InterfaceDeclaration : any
>                                         : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>InterfaceDeclaration : any
>                     : ^^^

                        name = (<TypeScript.InterfaceDeclaration>ast).name.actualText;
>name = (<TypeScript.InterfaceDeclaration>ast).name.actualText : any
>                                                              : ^^^
>name : string
>     : ^^^^^^
>(<TypeScript.InterfaceDeclaration>ast).name.actualText : any
>                                                       : ^^^
>(<TypeScript.InterfaceDeclaration>ast).name : any
>                                            : ^^^
>(<TypeScript.InterfaceDeclaration>ast) : TypeScript.InterfaceDeclaration
>                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
><TypeScript.InterfaceDeclaration>ast : TypeScript.InterfaceDeclaration
>                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>name : any
>     : ^^^
>actualText : any
>           : ^^^

                        break;
                    case TypeScript.NodeType.ModuleDeclaration:
>TypeScript.NodeType.ModuleDeclaration : any
>                                      : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>ModuleDeclaration : any
>                  : ^^^

                        name = (<TypeScript.ModuleDeclaration>ast).name.actualText;
>name = (<TypeScript.ModuleDeclaration>ast).name.actualText : any
>                                                           : ^^^
>name : string
>     : ^^^^^^
>(<TypeScript.ModuleDeclaration>ast).name.actualText : any
>                                                    : ^^^
>(<TypeScript.ModuleDeclaration>ast).name : any
>                                         : ^^^
>(<TypeScript.ModuleDeclaration>ast) : TypeScript.ModuleDeclaration
>                                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
><TypeScript.ModuleDeclaration>ast : TypeScript.ModuleDeclaration
>                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>name : any
>     : ^^^
>actualText : any
>           : ^^^

                        break;
                    case TypeScript.NodeType.ClassDeclaration:
>TypeScript.NodeType.ClassDeclaration : any
>                                     : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>ClassDeclaration : any
>                 : ^^^

                        name = (<TypeScript.ClassDeclaration>ast).name.actualText;
>name = (<TypeScript.ClassDeclaration>ast).name.actualText : any
>                                                          : ^^^
>name : string
>     : ^^^^^^
>(<TypeScript.ClassDeclaration>ast).name.actualText : any
>                                                   : ^^^
>(<TypeScript.ClassDeclaration>ast).name : any
>                                        : ^^^
>(<TypeScript.ClassDeclaration>ast) : TypeScript.ClassDeclaration
>                                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
><TypeScript.ClassDeclaration>ast : TypeScript.ClassDeclaration
>                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>name : any
>     : ^^^
>actualText : any
>           : ^^^

                        break;
                    case TypeScript.NodeType.FuncDecl:
>TypeScript.NodeType.FuncDecl : any
>                             : ^^^
>TypeScript.NodeType : any
>                    : ^^^
>TypeScript : any
>           : ^^^
>NodeType : any
>         : ^^^
>FuncDecl : any
>         : ^^^

                        name = !(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText; // name == null for lambdas
>name = !(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText : any
>                                                                                          : ^^^
>name : string
>     : ^^^^^^
>!(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText : any
>                                                                                   : ^^^
>!(<TypeScript.FuncDecl>ast).name : boolean
>                                 : ^^^^^^^
>(<TypeScript.FuncDecl>ast).name : any
>                                : ^^^
>(<TypeScript.FuncDecl>ast) : TypeScript.FuncDecl
>                           : ^^^^^^^^^^^^^^^^^^^
><TypeScript.FuncDecl>ast : TypeScript.FuncDecl
>                         : ^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>name : any
>     : ^^^
>"" : ""
>   : ^^
>(<TypeScript.FuncDecl>ast).name.actualText : any
>                                           : ^^^
>(<TypeScript.FuncDecl>ast).name : any
>                                : ^^^
>(<TypeScript.FuncDecl>ast) : TypeScript.FuncDecl
>                           : ^^^^^^^^^^^^^^^^^^^
><TypeScript.FuncDecl>ast : TypeScript.FuncDecl
>                         : ^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^
>name : any
>     : ^^^
>actualText : any
>           : ^^^

                        break;
                    default:
                        // TODO: is there a reason to mess with all the special cases above and not just do this (ie take whatever property is there and works?)
                        var a = <any>ast;
>a : any
>  : ^^^
><any>ast : any
>         : ^^^
>ast : TypeScript.AST
>    : ^^^^^^^^^^^^^^

                        name = (a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '';
>name = (a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '' : any
>                                                                                          : ^^^
>name : string
>     : ^^^^^^
>(a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '' : any
>                                                                                   : ^^^
>(a.id) : any
>       : ^^^
>a.id : any
>     : ^^^
>a : any
>  : ^^^
>id : any
>   : ^^^
>(a.id.actualText) : any
>                  : ^^^
>a.id.actualText : any
>                : ^^^
>a.id : any
>     : ^^^
>a : any
>  : ^^^
>id : any
>   : ^^^
>actualText : any
>           : ^^^
>(a.name) ? a.name.actualText : (a.text) ? a.text : '' : any
>                                                      : ^^^
>(a.name) : any
>         : ^^^
>a.name : any
>       : ^^^
>a : any
>  : ^^^
>name : any
>     : ^^^
>a.name.actualText : any
>                  : ^^^
>a.name : any
>       : ^^^
>a : any
>  : ^^^
>name : any
>     : ^^^
>actualText : any
>           : ^^^
>(a.text) ? a.text : '' : any
>                       : ^^^
>(a.text) : any
>         : ^^^
>a.text : any
>       : ^^^
>a : any
>  : ^^^
>text : any
>     : ^^^
>a.text : any
>       : ^^^
>a : any
>  : ^^^
>text : any
>     : ^^^
>'' : ""
>   : ^^

                        break;
                }

                return name;
>name : string
>     : ^^^^^^
            }

            public isOfType(expr: string, expectedType: string) {
>isOfType : (expr: string, expectedType: string) => void
>         : ^    ^^      ^^            ^^      ^^^^^^^^^
>expr : string
>     : ^^^^^^
>expectedType : string
>             : ^^^^^^

                var actualType = this.get('var _v_a_r_ = ' + expr, '_v_a_r_');
>actualType : Type
>           : ^^^^
>this.get('var _v_a_r_ = ' + expr, '_v_a_r_') : Type
>                                             : ^^^^
>this.get : (code: string, target: any) => Type
>         : ^    ^^      ^^      ^^   ^^^^^^^^^
>this : this
>     : ^^^^
>get : (code: string, target: any) => Type
>    : ^    ^^      ^^      ^^   ^^^^^^^^^
>'var _v_a_r_ = ' + expr : string
>                        : ^^^^^^
>'var _v_a_r_ = ' : "var _v_a_r_ = "
>                 : ^^^^^^^^^^^^^^^^
>expr : string
>     : ^^^^^^
>'_v_a_r_' : "_v_a_r_"
>          : ^^^^^^^^^

                it('Expression "' + expr + '" is of type "' + expectedType + '"', function () {
>it('Expression "' + expr + '" is of type "' + expectedType + '"', function () {                    assert.equal(actualType.type, expectedType);                }) : void
>                                                                                                                                                                  : ^^^^
>it : (description: string, block: () => void) => void
>   : ^           ^^      ^^     ^^          ^^^^^^^^^
>'Expression "' + expr + '" is of type "' + expectedType + '"' : string
>                                                              : ^^^^^^
>'Expression "' + expr + '" is of type "' + expectedType : string
>                                                        : ^^^^^^
>'Expression "' + expr + '" is of type "' : string
>                                         : ^^^^^^
>'Expression "' + expr : string
>                      : ^^^^^^
>'Expression "' : "Expression \""
>               : ^^^^^^^^^^^^^^^
>expr : string
>     : ^^^^^^
>'" is of type "' : "\" is of type \""
>                 : ^^^^^^^^^^^^^^^^^^
>expectedType : string
>             : ^^^^^^
>'"' : "\""
>    : ^^^^
>function () {                    assert.equal(actualType.type, expectedType);                } : () => void
>                                                                                               : ^^^^^^^^^^

                    assert.equal(actualType.type, expectedType);
>assert.equal(actualType.type, expectedType) : any
>                                            : ^^^
>assert.equal : any
>             : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>equal : any
>      : ^^^
>actualType.type : any
>                : ^^^
>actualType : Type
>           : ^^^^
>type : any
>     : ^^^
>expectedType : string
>             : ^^^^^^

                });
            }
        }

        /** Generates a .d.ts file for the given code
          * @param verifyNoDeclFile pass true when the given code should generate no decl file, false otherwise
          * @param unitName add the given code under thie name, else use '0.ts'
          * @param compilationContext a set of functions to be run before and after compiling this code for doing things like adding dependencies first
          * @param references the set of referenced files used by the given code
          */
        export function generateDeclFile(code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: Harness.Compiler.CompilationContext, references?: TypeScript.IFileReference[]): string {
>generateDeclFile : (code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: Harness.Compiler.CompilationContext, references?: TypeScript.IFileReference[]) => string
>                 : ^    ^^      ^^                ^^       ^^        ^^^      ^^                  ^^^                                   ^^          ^^^                           ^^^^^      
>code : string
>     : ^^^^^^
>verifyNoDeclFile : boolean
>                 : ^^^^^^^
>unitName : string
>         : ^^^^^^
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>Harness : any
>        : ^^^
>Compiler : any
>         : ^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            reset();
>reset() : void
>        : ^^^^
>reset : () => void
>      : ^^^^^^^^^^

            compiler.settings.generateDeclarationFiles = true;
>compiler.settings.generateDeclarationFiles = true : true
>                                                  : ^^^^
>compiler.settings.generateDeclarationFiles : any
>                                           : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
>generateDeclarationFiles : any
>                         : ^^^
>true : true
>     : ^^^^

            var oldOutputOption = compiler.settings.outputOption;
>oldOutputOption : any
>                : ^^^
>compiler.settings.outputOption : any
>                               : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
>outputOption : any
>             : ^^^

            var oldEmitterIOHost = compiler.emitSettings.ioHost;
>oldEmitterIOHost : any
>                 : ^^^
>compiler.emitSettings.ioHost : any
>                             : ^^^
>compiler.emitSettings : any
>                      : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emitSettings : any
>             : ^^^
>ioHost : any
>       : ^^^

            try {
                if (compilationContext && compilationContext.preCompile) {
>compilationContext && compilationContext.preCompile : () => void
>                                                    : ^^^^^^    
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>compilationContext.preCompile : () => void
>                              : ^^^^^^    
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>preCompile : () => void
>           : ^^^^^^    

                    compilationContext.preCompile();
>compilationContext.preCompile() : void
>                                : ^^^^
>compilationContext.preCompile : () => void
>                              : ^^^^^^    
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>preCompile : () => void
>           : ^^^^^^    
                }

                addUnit(code, unitName, false, false, references);
>addUnit(code, unitName, false, false, references) : TypeScript.Script
>                                                  : ^^^^^^^^^^^^^^^^^
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: TypeScript.IFileReference[]) => TypeScript.Script
>        : ^    ^^      ^^        ^^^      ^^          ^^^       ^^             ^^^       ^^          ^^^                           ^^^^^^^^^^^^^^^^^^^^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>false : false
>      : ^^^^^
>false : false
>      : ^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

                compiler.reTypeCheck();
>compiler.reTypeCheck() : any
>                       : ^^^
>compiler.reTypeCheck : any
>                     : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>reTypeCheck : any
>            : ^^^

                var outputs = {};
>outputs : {}
>        : ^^
>{} : {}
>   : ^^

                compiler.settings.outputOption = "";
>compiler.settings.outputOption = "" : ""
>                                    : ^^
>compiler.settings.outputOption : any
>                               : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
>outputOption : any
>             : ^^^
>"" : ""
>   : ^^

                compiler.parseEmitOption(
>compiler.parseEmitOption(                    {                        createFile: (fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        },                        directoryExists: (path: string) => true,                        fileExists: (path: string) => true,                        resolvePath: (path: string) => path                    }) : any
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                           : ^^^
>compiler.parseEmitOption : any
>                         : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>parseEmitOption : any
>                : ^^^
                    {
>{                        createFile: (fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        },                        directoryExists: (path: string) => true,                        fileExists: (path: string) => true,                        resolvePath: (path: string) => path                    } : { createFile: (fn: string) => any; directoryExists: (path: string) => boolean; fileExists: (path: string) => boolean; resolvePath: (path: string) => string; }
>                                                                                                                                                                                                                                                                                                                                                                                                                             : ^^^^^^^^^^^^^^^  ^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^      ^^^^^^^^^^^^^^

                        createFile: (fn: string) => {
>createFile : (fn: string) => any
>           : ^  ^^      ^^^^^^^^
>(fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        } : (fn: string) => any
>                                                                                                                                                                            : ^  ^^      ^^^^^^^^
>fn : string
>   : ^^^^^^

                            outputs[fn] = new Harness.Compiler.WriterAggregator();
>outputs[fn] = new Harness.Compiler.WriterAggregator() : WriterAggregator
>                                                      : ^^^^^^^^^^^^^^^^
>outputs[fn] : any
>            : ^^^
>outputs : {}
>        : ^^
>fn : string
>   : ^^^^^^
>new Harness.Compiler.WriterAggregator() : WriterAggregator
>                                        : ^^^^^^^^^^^^^^^^
>Harness.Compiler.WriterAggregator : typeof WriterAggregator
>                                  : ^^^^^^^^^^^^^^^^^^^^^^^
>Harness.Compiler : typeof Compiler
>                 : ^^^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>WriterAggregator : typeof WriterAggregator
>                 : ^^^^^^^^^^^^^^^^^^^^^^^

                            return outputs[fn];
>outputs[fn] : any
>            : ^^^
>outputs : {}
>        : ^^
>fn : string
>   : ^^^^^^

                        },
                        directoryExists: (path: string) => true,
>directoryExists : (path: string) => boolean
>                : ^    ^^      ^^^^^^^^^^^^
>(path: string) => true : (path: string) => boolean
>                       : ^    ^^      ^^^^^^^^^^^^
>path : string
>     : ^^^^^^
>true : true
>     : ^^^^

                        fileExists: (path: string) => true,
>fileExists : (path: string) => boolean
>           : ^    ^^      ^^^^^^^^^^^^
>(path: string) => true : (path: string) => boolean
>                       : ^    ^^      ^^^^^^^^^^^^
>path : string
>     : ^^^^^^
>true : true
>     : ^^^^

                        resolvePath: (path: string) => path
>resolvePath : (path: string) => string
>            : ^    ^^      ^^^^^^^^^^^
>(path: string) => path : (path: string) => string
>                       : ^    ^^      ^^^^^^^^^^^
>path : string
>     : ^^^^^^
>path : string
>     : ^^^^^^

                    });
                compiler.emitDeclarations();
>compiler.emitDeclarations() : any
>                            : ^^^
>compiler.emitDeclarations : any
>                          : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emitDeclarations : any
>                 : ^^^

                var results: string = null;
>results : string
>        : ^^^^^^

                for (var fn in outputs) {
>fn : string
>   : ^^^^^^
>outputs : {}
>        : ^^

                    if (fn.indexOf('.d.ts') >= 0) {
>fn.indexOf('.d.ts') >= 0 : boolean
>                         : ^^^^^^^
>fn.indexOf('.d.ts') : number
>                    : ^^^^^^
>fn.indexOf : (searchString: string, position?: number) => number
>           : ^            ^^      ^^        ^^^      ^^^^^      
>fn : string
>   : ^^^^^^
>indexOf : (searchString: string, position?: number) => number
>        : ^            ^^      ^^        ^^^      ^^^^^      
>'.d.ts' : ".d.ts"
>        : ^^^^^^^
>0 : 0
>  : ^

                        var writer = <Harness.Compiler.WriterAggregator>outputs[fn];
>writer : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
><Harness.Compiler.WriterAggregator>outputs[fn] : WriterAggregator
>                                               : ^^^^^^^^^^^^^^^^
>Harness : any
>        : ^^^
>Compiler : any
>         : ^^^
>outputs[fn] : any
>            : ^^^
>outputs : {}
>        : ^^
>fn : string
>   : ^^^^^^

                        writer.Close();
>writer.Close() : void
>               : ^^^^
>writer.Close : () => void
>             : ^^^^^^^^^^
>writer : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
>Close : () => void
>      : ^^^^^^^^^^

                        results = writer.lines.join('\n');
>results = writer.lines.join('\n') : string
>                                  : ^^^^^^
>results : string
>        : ^^^^^^
>writer.lines.join('\n') : string
>                        : ^^^^^^
>writer.lines.join : (separator?: string) => string
>                  : ^         ^^^      ^^^^^      
>writer.lines : string[]
>             : ^^^^^^^^
>writer : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
>lines : string[]
>      : ^^^^^^^^
>join : (separator?: string) => string
>     : ^         ^^^      ^^^^^      
>'\n' : "\n"
>     : ^^^^

                        if (verifyNoDeclFile && results != "") {
>verifyNoDeclFile && results != "" : boolean
>                                  : ^^^^^^^
>verifyNoDeclFile : boolean
>                 : ^^^^^^^
>results != "" : boolean
>              : ^^^^^^^
>results : string
>        : ^^^^^^
>"" : ""
>   : ^^

                            throw new Error('Compilation should not produce ' + fn);
>new Error('Compilation should not produce ' + fn) : Error
>                                                  : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>'Compilation should not produce ' + fn : string
>                                       : ^^^^^^
>'Compilation should not produce ' : "Compilation should not produce "
>                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>fn : string
>   : ^^^^^^
                        }
                    }
                }

                if (results) {
>results : string
>        : ^^^^^^

                    return results;
>results : string
>        : ^^^^^^
                }

                if (!verifyNoDeclFile) {
>!verifyNoDeclFile : boolean
>                  : ^^^^^^^
>verifyNoDeclFile : boolean
>                 : ^^^^^^^

                    throw new Error('Compilation did not produce .d.ts files');
>new Error('Compilation did not produce .d.ts files') : Error
>                                                     : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>'Compilation did not produce .d.ts files' : "Compilation did not produce .d.ts files"
>                                          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                }
            } finally {
                compiler.settings.generateDeclarationFiles = false;
>compiler.settings.generateDeclarationFiles = false : false
>                                                   : ^^^^^
>compiler.settings.generateDeclarationFiles : any
>                                           : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
>generateDeclarationFiles : any
>                         : ^^^
>false : false
>      : ^^^^^

                compiler.settings.outputOption = oldOutputOption;
>compiler.settings.outputOption = oldOutputOption : any
>                                                 : ^^^
>compiler.settings.outputOption : any
>                               : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
>outputOption : any
>             : ^^^
>oldOutputOption : any
>                : ^^^

                compiler.parseEmitOption(oldEmitterIOHost);
>compiler.parseEmitOption(oldEmitterIOHost) : any
>                                           : ^^^
>compiler.parseEmitOption : any
>                         : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>parseEmitOption : any
>                : ^^^
>oldEmitterIOHost : any
>                 : ^^^

                if (compilationContext && compilationContext.postCompile) {
>compilationContext && compilationContext.postCompile : () => void
>                                                     : ^^^^^^    
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>compilationContext.postCompile : () => void
>                               : ^^^^^^    
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>postCompile : () => void
>            : ^^^^^^    

                    compilationContext.postCompile();
>compilationContext.postCompile() : void
>                                 : ^^^^
>compilationContext.postCompile : () => void
>                               : ^^^^^^    
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>postCompile : () => void
>            : ^^^^^^    
                }

                var uName = unitName || '0.ts';
>uName : string
>      : ^^^^^^
>unitName || '0.ts' : string
>                   : ^^^^^^
>unitName : string
>         : ^^^^^^
>'0.ts' : "0.ts"
>       : ^^^^^^

                updateUnit('', uName);
>updateUnit('', uName) : void
>                      : ^^^^
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>           : ^    ^^      ^^        ^^      ^^           ^^^       ^^^^^^^^^
>'' : ""
>   : ^^
>uName : string
>      : ^^^^^^
            }

            return '';
>'' : ""
>   : ^^
        }

        /** Contains the code and errors of a compilation and some helper methods to check its status. */
        export class CompilerResult {
>CompilerResult : CompilerResult
>               : ^^^^^^^^^^^^^^

            public code: string;
>code : string
>     : ^^^^^^

            public errors: CompilerError[];
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^

            /** @param fileResults an array of strings for the filename and an ITextWriter with its code */
            constructor(public fileResults: { filename: string; file: WriterAggregator; }[], errorLines: string[], public scripts: TypeScript.Script[]) {
>fileResults : { filename: string; file: WriterAggregator; }[]
>            : ^^^^^^^^^^^^      ^^^^^^^^                ^^^^^
>filename : string
>         : ^^^^^^
>file : WriterAggregator
>     : ^^^^^^^^^^^^^^^^
>errorLines : string[]
>           : ^^^^^^^^
>scripts : TypeScript.Script[]
>        : ^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

                var lines = [];
>lines : any[]
>      : ^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                fileResults.forEach(v => lines = lines.concat(v.file.lines));
>fileResults.forEach(v => lines = lines.concat(v.file.lines)) : void
>                                                             : ^^^^
>fileResults.forEach : (callbackfn: (value: { filename: string; file: WriterAggregator; }, index: number, array: { filename: string; file: WriterAggregator; }[]) => void, thisArg?: any) => void
>                    : ^          ^^^     ^^^^^^^^^^^^^^      ^^^^^^^^                ^^^^^     ^^      ^^     ^^^^^^^^^^^^^^      ^^^^^^^^                ^^^^^^^^^^    ^^       ^^^   ^^^^^    
>fileResults : { filename: string; file: WriterAggregator; }[]
>            : ^^^^^^^^^^^^      ^^^^^^^^                ^^^^^
>forEach : (callbackfn: (value: { filename: string; file: WriterAggregator; }, index: number, array: { filename: string; file: WriterAggregator; }[]) => void, thisArg?: any) => void
>        : ^          ^^^     ^^^^^^^^^^^^^^      ^^^^^^^^                ^^^^^     ^^      ^^     ^^^^^^^^^^^^^^      ^^^^^^^^                ^^^^^^^^^^    ^^       ^^^   ^^^^^    
>v => lines = lines.concat(v.file.lines) : (v: { filename: string; file: WriterAggregator; }) => any[]
>                                        : ^ ^^^^^^^^^^^^^^      ^^^^^^^^                ^^^^^^^^^^^^^
>v : { filename: string; file: WriterAggregator; }
>  : ^^^^^^^^^^^^      ^^^^^^^^                ^^^
>lines = lines.concat(v.file.lines) : any[]
>                                   : ^^^^^
>lines : any[]
>      : ^^^^^
>lines.concat(v.file.lines) : any[]
>                           : ^^^^^
>lines.concat : { (...items: ConcatArray<any>[]): any[]; (...items: any[]): any[]; }
>             : ^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^
>lines : any[]
>      : ^^^^^
>concat : { (...items: ConcatArray<any>[]): any[]; (...items: any[]): any[]; }
>       : ^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^
>v.file.lines : string[]
>             : ^^^^^^^^
>v.file : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
>v : { filename: string; file: WriterAggregator; }
>  : ^^^^^^^^^^^^      ^^^^^^^^                ^^^
>file : WriterAggregator
>     : ^^^^^^^^^^^^^^^^
>lines : string[]
>      : ^^^^^^^^

                this.code = lines.join("\n")
>this.code = lines.join("\n") : string
>                             : ^^^^^^
>this.code : string
>          : ^^^^^^
>this : this
>     : ^^^^
>code : string
>     : ^^^^^^
>lines.join("\n") : string
>                 : ^^^^^^
>lines.join : (separator?: string) => string
>           : ^         ^^^      ^^^^^      
>lines : any[]
>      : ^^^^^
>join : (separator?: string) => string
>     : ^         ^^^      ^^^^^      
>"\n" : "\n"
>     : ^^^^

                this.errors = [];
>this.errors = [] : undefined[]
>                 : ^^^^^^^^^^^
>this.errors : CompilerError[]
>            : ^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                for (var i = 0; i < errorLines.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < errorLines.length : boolean
>                      : ^^^^^^^
>i : number
>  : ^^^^^^
>errorLines.length : number
>                  : ^^^^^^
>errorLines : string[]
>           : ^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    if (Harness.usePull) {
>Harness.usePull : boolean
>                : ^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>usePull : boolean
>        : ^^^^^^^

                        var err = <any>errorLines[i]; // TypeScript.PullError
>err : any
>    : ^^^
><any>errorLines[i] : any
>                   : ^^^
>errorLines[i] : string
>              : ^^^^^^
>errorLines : string[]
>           : ^^^^^^^^
>i : number
>  : ^^^^^^

                        this.errors.push(new CompilerError(err.filename, 0, 0, err.message));
>this.errors.push(new CompilerError(err.filename, 0, 0, err.message)) : number
>                                                                     : ^^^^^^
>this.errors.push : (...items: CompilerError[]) => number
>                 : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^      
>this.errors : CompilerError[]
>            : ^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^
>push : (...items: CompilerError[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^      
>new CompilerError(err.filename, 0, 0, err.message) : CompilerError
>                                                   : ^^^^^^^^^^^^^
>CompilerError : typeof CompilerError
>              : ^^^^^^^^^^^^^^^^^^^^
>err.filename : any
>             : ^^^
>err : any
>    : ^^^
>filename : any
>         : ^^^
>0 : 0
>  : ^
>0 : 0
>  : ^
>err.message : any
>            : ^^^
>err : any
>    : ^^^
>message : any
>        : ^^^

                    } else {
                        var match = errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/);
>match : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^
>errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/) : RegExpMatchArray
>                                                                         : ^^^^^^^^^^^^^^^^
>errorLines[i].match : (regexp: string | RegExp) => RegExpMatchArray | null
>                    : ^      ^^               ^^^^^                       
>errorLines[i] : string
>              : ^^^^^^
>errorLines : string[]
>           : ^^^^^^^^
>i : number
>  : ^^^^^^
>match : (regexp: string | RegExp) => RegExpMatchArray | null
>      : ^      ^^               ^^^^^                       
>/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/ : RegExp
>                                                    : ^^^^^^

                        if (match) {
>match : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^

                            this.errors.push(new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4]));
>this.errors.push(new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4])) : number
>                                                                                                    : ^^^^^^
>this.errors.push : (...items: CompilerError[]) => number
>                 : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^      
>this.errors : CompilerError[]
>            : ^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^
>push : (...items: CompilerError[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^      
>new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4]) : CompilerError
>                                                                                  : ^^^^^^^^^^^^^
>CompilerError : typeof CompilerError
>              : ^^^^^^^^^^^^^^^^^^^^
>match[1] : string
>         : ^^^^^^
>match : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^
>1 : 1
>  : ^
>parseFloat(match[2]) : number
>                     : ^^^^^^
>parseFloat : (string: string) => number
>           : ^      ^^      ^^^^^      
>match[2] : string
>         : ^^^^^^
>match : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^
>2 : 2
>  : ^
>parseFloat(match[3]) : number
>                     : ^^^^^^
>parseFloat : (string: string) => number
>           : ^      ^^      ^^^^^      
>match[3] : string
>         : ^^^^^^
>match : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^
>3 : 3
>  : ^
>match[4] : string
>         : ^^^^^^
>match : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^
>4 : 4
>  : ^
                        }
                        else {
                            WScript.Echo("non-match on: " + errorLines[i]);
>WScript.Echo("non-match on: " + errorLines[i]) : any
>                                               : ^^^
>WScript.Echo : any
>             : ^^^
>WScript : any
>        : ^^^
>Echo : any
>     : ^^^
>"non-match on: " + errorLines[i] : string
>                                 : ^^^^^^
>"non-match on: " : "non-match on: "
>                 : ^^^^^^^^^^^^^^^^
>errorLines[i] : string
>              : ^^^^^^
>errorLines : string[]
>           : ^^^^^^^^
>i : number
>  : ^^^^^^
                        }
                    }
                }
            }

            public isErrorAt(line: number, column: number, message: string) {
>isErrorAt : (line: number, column: number, message: string) => boolean
>          : ^    ^^      ^^      ^^      ^^       ^^      ^^^^^^^^^^^^
>line : number
>     : ^^^^^^
>column : number
>       : ^^^^^^
>message : string
>        : ^^^^^^

                for (var i = 0; i < this.errors.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < this.errors.length : boolean
>                       : ^^^^^^^
>i : number
>  : ^^^^^^
>this.errors.length : number
>                   : ^^^^^^
>this.errors : CompilerError[]
>            : ^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    if (this.errors[i].line === line && this.errors[i].column === column && this.errors[i].message === message)
>this.errors[i].line === line && this.errors[i].column === column && this.errors[i].message === message : boolean
>                                                                                                       : ^^^^^^^
>this.errors[i].line === line && this.errors[i].column === column : boolean
>                                                                 : ^^^^^^^
>this.errors[i].line === line : boolean
>                             : ^^^^^^^
>this.errors[i].line : number
>                    : ^^^^^^
>this.errors[i] : CompilerError
>               : ^^^^^^^^^^^^^
>this.errors : CompilerError[]
>            : ^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>line : number
>     : ^^^^^^
>line : number
>     : ^^^^^^
>this.errors[i].column === column : boolean
>                                 : ^^^^^^^
>this.errors[i].column : number
>                      : ^^^^^^
>this.errors[i] : CompilerError
>               : ^^^^^^^^^^^^^
>this.errors : CompilerError[]
>            : ^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>column : number
>       : ^^^^^^
>column : number
>       : ^^^^^^
>this.errors[i].message === message : boolean
>                                   : ^^^^^^^
>this.errors[i].message : string
>                       : ^^^^^^
>this.errors[i] : CompilerError
>               : ^^^^^^^^^^^^^
>this.errors : CompilerError[]
>            : ^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>errors : CompilerError[]
>       : ^^^^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>message : string
>        : ^^^^^^
>message : string
>        : ^^^^^^

                        return true;
>true : true
>     : ^^^^
                }

                return false;
>false : false
>      : ^^^^^
            }
        }

        // Compiler Error.
        export class CompilerError {
>CompilerError : CompilerError
>              : ^^^^^^^^^^^^^

            constructor(public file: string,
>file : string
>     : ^^^^^^

                    public line: number,
>line : number
>     : ^^^^^^

                    public column: number,
>column : number
>       : ^^^^^^

                    public message: string) { }
>message : string
>        : ^^^^^^

            public toString() {
>toString : () => string
>         : ^^^^^^^^^^^^

                return this.file + "(" + this.line + "," + this.column + "): " + this.message;
>this.file + "(" + this.line + "," + this.column + "): " + this.message : string
>                                                                       : ^^^^^^
>this.file + "(" + this.line + "," + this.column + "): " : string
>                                                        : ^^^^^^
>this.file + "(" + this.line + "," + this.column : string
>                                                : ^^^^^^
>this.file + "(" + this.line + "," : string
>                                  : ^^^^^^
>this.file + "(" + this.line : string
>                            : ^^^^^^
>this.file + "(" : string
>                : ^^^^^^
>this.file : string
>          : ^^^^^^
>this : this
>     : ^^^^
>file : string
>     : ^^^^^^
>"(" : "("
>    : ^^^
>this.line : number
>          : ^^^^^^
>this : this
>     : ^^^^
>line : number
>     : ^^^^^^
>"," : ","
>    : ^^^
>this.column : number
>            : ^^^^^^
>this : this
>     : ^^^^
>column : number
>       : ^^^^^^
>"): " : "): "
>      : ^^^^^
>this.message : string
>             : ^^^^^^
>this : this
>     : ^^^^
>message : string
>        : ^^^^^^
            }
        }

        /** Create a new instance of the compiler with default settings and lib.d.ts, then typecheck */
        export function recreate() {
>recreate : () => void
>         : ^^^^^^^^^^

            compiler = makeDefaultCompilerForTest();
>compiler = makeDefaultCompilerForTest() : any
>                                        : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>makeDefaultCompilerForTest() : any
>                             : ^^^
>makeDefaultCompilerForTest : (c?: TypeScript.TypeScriptCompiler) => any
>                           : ^ ^^^                             ^^^^^^^^

            if (usePull) {
>usePull : boolean
>        : ^^^^^^^

                compiler.pullTypeCheck(true);
>compiler.pullTypeCheck(true) : any
>                             : ^^^
>compiler.pullTypeCheck : any
>                       : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullTypeCheck : any
>              : ^^^
>true : true
>     : ^^^^
            }
            else {
                compiler.typeCheck();
>compiler.typeCheck() : any
>                     : ^^^
>compiler.typeCheck : any
>                   : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>typeCheck : any
>          : ^^^
            }
        }

        export function reset() {
>reset : () => void
>      : ^^^^^^^^^^

            stdout.reset();
>stdout.reset() : void
>               : ^^^^
>stdout.reset : () => void
>             : ^^^^^^^^^^
>stdout : EmitterIOHost
>       : ^^^^^^^^^^^^^
>reset : () => void
>      : ^^^^^^^^^^

            stderr.reset();
>stderr.reset() : void
>               : ^^^^
>stderr.reset : () => void
>             : ^^^^^^^^^^
>stderr : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
>reset : () => void
>      : ^^^^^^^^^^

            var files = compiler.units.map((value) => value.filename);
>files : any
>      : ^^^
>compiler.units.map((value) => value.filename) : any
>                                              : ^^^
>compiler.units.map : any
>                   : ^^^
>compiler.units : any
>               : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units : any
>      : ^^^
>map : any
>    : ^^^
>(value) => value.filename : (value: any) => any
>                          : ^     ^^^^^^^^^^^^^
>value : any
>      : ^^^
>value.filename : any
>               : ^^^
>value : any
>      : ^^^
>filename : any
>         : ^^^

            for (var i = 0; i < files.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < files.length : boolean
>                 : ^^^^^^^
>i : number
>  : ^^^^^^
>files.length : any
>             : ^^^
>files : any
>      : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                var fname = files[i];
>fname : any
>      : ^^^
>files[i] : any
>         : ^^^
>files : any
>      : ^^^
>i : number
>  : ^^^^^^

                if(fname !== 'lib.d.ts') {
>fname !== 'lib.d.ts' : boolean
>                     : ^^^^^^^
>fname : any
>      : ^^^
>'lib.d.ts' : "lib.d.ts"
>           : ^^^^^^^^^^

                    updateUnit('', fname);
>updateUnit('', fname) : void
>                      : ^^^^
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>           : ^    ^^      ^^        ^^      ^^           ^^^       ^^^^^^^^^
>'' : ""
>   : ^^
>fname : any
>      : ^^^
                    }
            }

            compiler.errorReporter.hasErrors = false;
>compiler.errorReporter.hasErrors = false : false
>                                         : ^^^^^
>compiler.errorReporter.hasErrors : any
>                                 : ^^^
>compiler.errorReporter : any
>                       : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>errorReporter : any
>              : ^^^
>hasErrors : any
>          : ^^^
>false : false
>      : ^^^^^
        }

        // Defines functions to invoke before compiling a piece of code and a post compile action intended to clean up the
        // effects of preCompile, preferably with something lighter weight than a full recreate()
        export interface CompilationContext {
            filename: string;
>filename : string
>         : ^^^^^^

            preCompile: () => void;
>preCompile : () => void
>           : ^^^^^^    

            postCompile: () => void;
>postCompile : () => void
>            : ^^^^^^    
        }

        export function addUnit(code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: TypeScript.IFileReference[]) {
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: TypeScript.IFileReference[]) => TypeScript.Script
>        : ^    ^^      ^^        ^^^      ^^          ^^^       ^^             ^^^       ^^          ^^^                           ^^^^^^^^^^^^^^^^^^^^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
>isDeclareFile : boolean
>              : ^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            var script: TypeScript.Script = null;
>script : TypeScript.Script
>       : ^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            var uName = unitName || '0' + (isDeclareFile ? '.d.ts' : '.ts');
>uName : string
>      : ^^^^^^
>unitName || '0' + (isDeclareFile ? '.d.ts' : '.ts') : string
>                                                    : ^^^^^^
>unitName : string
>         : ^^^^^^
>'0' + (isDeclareFile ? '.d.ts' : '.ts') : string
>                                        : ^^^^^^
>'0' : "0"
>    : ^^^
>(isDeclareFile ? '.d.ts' : '.ts') : ".d.ts" | ".ts"
>                                  : ^^^^^^^^^^^^^^^
>isDeclareFile ? '.d.ts' : '.ts' : ".d.ts" | ".ts"
>                                : ^^^^^^^^^^^^^^^
>isDeclareFile : boolean
>              : ^^^^^^^
>'.d.ts' : ".d.ts"
>        : ^^^^^^^
>'.ts' : ".ts"
>      : ^^^^^

            for (var i = 0; i < compiler.units.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < compiler.units.length : boolean
>                          : ^^^^^^^
>i : number
>  : ^^^^^^
>compiler.units.length : any
>                      : ^^^
>compiler.units : any
>               : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units : any
>      : ^^^
>length : any
>       : ^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                if (compiler.units[i].filename === uName) {
>compiler.units[i].filename === uName : boolean
>                                     : ^^^^^^^
>compiler.units[i].filename : any
>                           : ^^^
>compiler.units[i] : any
>                  : ^^^
>compiler.units : any
>               : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units : any
>      : ^^^
>i : number
>  : ^^^^^^
>filename : any
>         : ^^^
>uName : string
>      : ^^^^^^

                    updateUnit(code, uName);
>updateUnit(code, uName) : void
>                        : ^^^^
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>           : ^    ^^      ^^        ^^      ^^           ^^^       ^^^^^^^^^
>code : string
>     : ^^^^^^
>uName : string
>      : ^^^^^^

                    script = <TypeScript.Script>compiler.scripts.members[i];
>script = <TypeScript.Script>compiler.scripts.members[i] : TypeScript.Script
>                                                        : ^^^^^^^^^^^^^^^^^
>script : TypeScript.Script
>       : ^^^^^^^^^^^^^^^^^
><TypeScript.Script>compiler.scripts.members[i] : TypeScript.Script
>                                               : ^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>compiler.scripts.members[i] : any
>                            : ^^^
>compiler.scripts.members : any
>                         : ^^^
>compiler.scripts : any
>                 : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>scripts : any
>        : ^^^
>members : any
>        : ^^^
>i : number
>  : ^^^^^^
                }
            }
            if (!script) {
>!script : boolean
>        : ^^^^^^^
>script : TypeScript.Script
>       : ^^^^^^^^^^^^^^^^^

                // TODO: make this toggleable, shouldn't be necessary once typecheck bugs are cleaned up
                // but without it subsequent tests are treated as edits, making for somewhat useful stress testing
                // of persistent typecheck state
                //compiler.addUnit("", uName, isResident, references); // equivalent to compiler.deleteUnit(...)
                script = compiler.addUnit(code, uName, isResident, references);
>script = compiler.addUnit(code, uName, isResident, references) : any
>                                                               : ^^^
>script : TypeScript.Script
>       : ^^^^^^^^^^^^^^^^^
>compiler.addUnit(code, uName, isResident, references) : any
>                                                      : ^^^
>compiler.addUnit : any
>                 : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>addUnit : any
>        : ^^^
>code : string
>     : ^^^^^^
>uName : string
>      : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

                needsFullTypeCheck = true;
>needsFullTypeCheck = true : true
>                          : ^^^^
>needsFullTypeCheck : boolean
>                   : ^^^^^^^
>true : true
>     : ^^^^
            }

            return script;
>script : TypeScript.Script
>       : ^^^^^^^^^^^^^^^^^
        }

        export function updateUnit(code: string, unitName: string, setRecovery?: boolean) {
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>           : ^    ^^      ^^        ^^      ^^           ^^^       ^^^^^^^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>setRecovery : boolean
>            : ^^^^^^^

            if (Harness.usePull) {
>Harness.usePull : boolean
>                : ^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>usePull : boolean
>        : ^^^^^^^

                compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), unitName, setRecovery);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), unitName, setRecovery) : any
>                                                                                      : ^^^
>compiler.pullUpdateUnit : any
>                        : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullUpdateUnit : any
>               : ^^^
>new TypeScript.StringSourceText(code) : any
>                                      : ^^^
>TypeScript.StringSourceText : any
>                            : ^^^
>TypeScript : any
>           : ^^^
>StringSourceText : any
>                 : ^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>setRecovery : boolean
>            : ^^^^^^^

            } else {
                compiler.updateUnit(code, unitName, setRecovery);
>compiler.updateUnit(code, unitName, setRecovery) : any
>                                                 : ^^^
>compiler.updateUnit : any
>                    : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>updateUnit : any
>           : ^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>setRecovery : boolean
>            : ^^^^^^^
            }
        }

        export function compileFile(path: string, callback: (res: CompilerResult) => void , settingsCallback?: (settings?: TypeScript.CompilationSettings) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileFile : (path: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: TypeScript.CompilationSettings) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>            : ^    ^^      ^^        ^^                             ^^                ^^^                                                   ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>path : string
>     : ^^^^^^
>callback : (res: CompilerResult) => void
>         : ^   ^^              ^^^^^    
>res : CompilerResult
>    : ^^^^^^^^^^^^^^
>settingsCallback : (settings?: TypeScript.CompilationSettings) => void
>                 : ^        ^^^                              ^^^^^    
>settings : TypeScript.CompilationSettings
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            path = switchToForwardSlashes(path);
>path = switchToForwardSlashes(path) : string
>                                    : ^^^^^^
>path : string
>     : ^^^^^^
>switchToForwardSlashes(path) : string
>                             : ^^^^^^
>switchToForwardSlashes : (path: string) => string
>                       : ^    ^^      ^^^^^^^^^^^
>path : string
>     : ^^^^^^

            var filename = path.match(/[^\/]*$/)[0];
>filename : string
>         : ^^^^^^
>path.match(/[^\/]*$/)[0] : string
>                         : ^^^^^^
>path.match(/[^\/]*$/) : RegExpMatchArray
>                      : ^^^^^^^^^^^^^^^^
>path.match : (regexp: string | RegExp) => RegExpMatchArray | null
>           : ^      ^^               ^^^^^                       
>path : string
>     : ^^^^^^
>match : (regexp: string | RegExp) => RegExpMatchArray | null
>      : ^      ^^               ^^^^^                       
>/[^\/]*$/ : RegExp
>          : ^^^^^^
>0 : 0
>  : ^

            var code = readFile(path);
>code : any
>     : ^^^
>readFile(path) : any
>               : ^^^
>readFile : (path: string) => any
>         : ^    ^^      ^^^^^^^^
>path : string
>     : ^^^^^^

            compileUnit(code, filename, callback, settingsCallback, context, references);
>compileUnit(code, filename, callback, settingsCallback, context, references) : void
>                                                                             : ^^^^
>compileUnit : (code: string, filename: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: TypeScript.CompilationSettings) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>            : ^    ^^      ^^        ^^      ^^        ^^                             ^^                ^^^                                                   ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>code : any
>     : ^^^
>filename : string
>         : ^^^^^^
>callback : (res: CompilerResult) => void
>         : ^   ^^              ^^^^^    
>settingsCallback : (settings?: TypeScript.CompilationSettings) => void
>                 : ^        ^^^                              ^^^^^    
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
        }

        export function compileUnit(code: string, filename: string, callback: (res: CompilerResult) => void , settingsCallback?: (settings?: TypeScript.CompilationSettings) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileUnit : (code: string, filename: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: TypeScript.CompilationSettings) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>            : ^    ^^      ^^        ^^      ^^        ^^                             ^^                ^^^                                                   ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>code : string
>     : ^^^^^^
>filename : string
>         : ^^^^^^
>callback : (res: CompilerResult) => void
>         : ^   ^^              ^^^^^    
>res : CompilerResult
>    : ^^^^^^^^^^^^^^
>settingsCallback : (settings?: TypeScript.CompilationSettings) => void
>                 : ^        ^^^                              ^^^^^    
>settings : TypeScript.CompilationSettings
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            // not recursive
            function clone/* <T> */(source: any, target: any) {
>clone : (source: any, target: any) => void
>      : ^      ^^   ^^      ^^   ^^^^^^^^^
>source : any
>       : ^^^
>target : any
>       : ^^^

                for (var prop in source) {
>prop : string
>     : ^^^^^^
>source : any
>       : ^^^

                    target[prop] = source[prop];
>target[prop] = source[prop] : any
>                            : ^^^
>target[prop] : any
>             : ^^^
>target : any
>       : ^^^
>prop : string
>     : ^^^^^^
>source[prop] : any
>             : ^^^
>source : any
>       : ^^^
>prop : string
>     : ^^^^^^
                }
            }

            var oldCompilerSettings = new TypeScript.CompilationSettings();
>oldCompilerSettings : any
>                    : ^^^
>new TypeScript.CompilationSettings() : any
>                                     : ^^^
>TypeScript.CompilationSettings : any
>                               : ^^^
>TypeScript : any
>           : ^^^
>CompilationSettings : any
>                    : ^^^

            clone(compiler.settings, oldCompilerSettings);
>clone(compiler.settings, oldCompilerSettings) : void
>                                              : ^^^^
>clone : (source: any, target: any) => void
>      : ^      ^^   ^^      ^^   ^^^^^^^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
>oldCompilerSettings : any
>                    : ^^^

            var oldEmitSettings = new TypeScript.EmitOptions(compiler.settings);
>oldEmitSettings : any
>                : ^^^
>new TypeScript.EmitOptions(compiler.settings) : any
>                                              : ^^^
>TypeScript.EmitOptions : any
>                       : ^^^
>TypeScript : any
>           : ^^^
>EmitOptions : any
>            : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^

            clone(compiler.emitSettings, oldEmitSettings);
>clone(compiler.emitSettings, oldEmitSettings) : void
>                                              : ^^^^
>clone : (source: any, target: any) => void
>      : ^      ^^   ^^      ^^   ^^^^^^^^^
>compiler.emitSettings : any
>                      : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emitSettings : any
>             : ^^^
>oldEmitSettings : any
>                : ^^^

            var oldModuleGenTarget = TypeScript.moduleGenTarget;
>oldModuleGenTarget : any
>                   : ^^^
>TypeScript.moduleGenTarget : any
>                           : ^^^
>TypeScript : any
>           : ^^^
>moduleGenTarget : any
>                : ^^^

            if (settingsCallback) {
>settingsCallback : (settings?: TypeScript.CompilationSettings) => void
>                 : ^        ^^^                              ^^^^^    

                settingsCallback(compiler.settings);
>settingsCallback(compiler.settings) : void
>                                    : ^^^^
>settingsCallback : (settings?: TypeScript.CompilationSettings) => void
>                 : ^        ^^^                              ^^^^^    
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^

                compiler.emitSettings = new TypeScript.EmitOptions(compiler.settings);
>compiler.emitSettings = new TypeScript.EmitOptions(compiler.settings) : any
>                                                                      : ^^^
>compiler.emitSettings : any
>                      : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emitSettings : any
>             : ^^^
>new TypeScript.EmitOptions(compiler.settings) : any
>                                              : ^^^
>TypeScript.EmitOptions : any
>                       : ^^^
>TypeScript : any
>           : ^^^
>EmitOptions : any
>            : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
            }
            try {
                compileString(code, filename, callback, context, references);
>compileString(code, filename, callback, context, references) : void
>                                                             : ^^^^
>compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>              : ^    ^^      ^^        ^^      ^^        ^^                                      ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>code : string
>     : ^^^^^^
>filename : string
>         : ^^^^^^
>callback : (res: CompilerResult) => void
>         : ^   ^^              ^^^^^    
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

            } finally {
                // If settingsCallback exists, assume that it modified the global compiler instance's settings in some way.
                // So that a test doesn't have side effects for tests run after it, restore the compiler settings to their previous state.
                if (settingsCallback) {
>settingsCallback : (settings?: TypeScript.CompilationSettings) => void
>                 : ^        ^^^                              ^^^^^    

                    compiler.settings = oldCompilerSettings;
>compiler.settings = oldCompilerSettings : any
>                                        : ^^^
>compiler.settings : any
>                  : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : any
>         : ^^^
>oldCompilerSettings : any
>                    : ^^^

                    compiler.emitSettings = oldEmitSettings;
>compiler.emitSettings = oldEmitSettings : any
>                                        : ^^^
>compiler.emitSettings : any
>                      : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emitSettings : any
>             : ^^^
>oldEmitSettings : any
>                : ^^^

                    TypeScript.moduleGenTarget = oldModuleGenTarget;
>TypeScript.moduleGenTarget = oldModuleGenTarget : any
>                                                : ^^^
>TypeScript.moduleGenTarget : any
>                           : ^^^
>TypeScript : any
>           : ^^^
>moduleGenTarget : any
>                : ^^^
>oldModuleGenTarget : any
>                   : ^^^
                }
            }
        }

        export function compileUnits(units: TestCaseParser.TestUnitData[], callback: (res: Compiler.CompilerResult) => void , settingsCallback?: () => void ) {
>compileUnits : (units: TestCaseParser.TestUnitData[], callback: (res: Compiler.CompilerResult) => void, settingsCallback?: () => void) => void
>             : ^     ^^                             ^^        ^^                                      ^^                ^^^          ^^^^^^^^^
>units : TestCaseParser.TestUnitData[]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TestCaseParser : any
>               : ^^^
>callback : (res: Compiler.CompilerResult) => void
>         : ^   ^^                       ^^^^^    
>res : CompilerResult
>    : ^^^^^^^^^^^^^^
>Compiler : any
>         : ^^^
>settingsCallback : () => void
>                 : ^^^^^^    

            var lastUnit = units[units.length - 1];
>lastUnit : TestCaseParser.TestUnitData
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units[units.length - 1] : TestCaseParser.TestUnitData
>                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units : TestCaseParser.TestUnitData[]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units.length - 1 : number
>                 : ^^^^^^
>units.length : number
>             : ^^^^^^
>units : TestCaseParser.TestUnitData[]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^

            var unitName = switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/)[0];
>unitName : string
>         : ^^^^^^
>switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/)[0] : string
>                                                          : ^^^^^^
>switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/) : RegExpMatchArray
>                                                       : ^^^^^^^^^^^^^^^^
>switchToForwardSlashes(lastUnit.name).match : (regexp: string | RegExp) => RegExpMatchArray | null
>                                            : ^      ^^               ^^^^^                       
>switchToForwardSlashes(lastUnit.name) : string
>                                      : ^^^^^^
>switchToForwardSlashes : (path: string) => string
>                       : ^    ^^      ^^^^^^^^^^^
>lastUnit.name : string
>              : ^^^^^^
>lastUnit : TestCaseParser.TestUnitData
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>match : (regexp: string | RegExp) => RegExpMatchArray | null
>      : ^      ^^               ^^^^^                       
>/[^\/]*$/ : RegExp
>          : ^^^^^^
>0 : 0
>  : ^

            var dependencies = units.slice(0, units.length - 1);
>dependencies : TestCaseParser.TestUnitData[]
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units.slice(0, units.length - 1) : TestCaseParser.TestUnitData[]
>                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units.slice : (start?: number, end?: number) => TestCaseParser.TestUnitData[]
>            : ^     ^^^      ^^   ^^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>units : TestCaseParser.TestUnitData[]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>slice : (start?: number, end?: number) => TestCaseParser.TestUnitData[]
>      : ^     ^^^      ^^   ^^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>0 : 0
>  : ^
>units.length - 1 : number
>                 : ^^^^^^
>units.length : number
>             : ^^^^^^
>units : TestCaseParser.TestUnitData[]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^

            var compilationContext = Harness.Compiler.defineCompilationContextForTest(unitName, dependencies);
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>Harness.Compiler.defineCompilationContextForTest(unitName, dependencies) : CompilationContext
>                                                                         : ^^^^^^^^^^^^^^^^^^
>Harness.Compiler.defineCompilationContextForTest : (filename: string, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>                                                 : ^        ^^      ^^            ^^                             ^^^^^                  
>Harness.Compiler : typeof Compiler
>                 : ^^^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>defineCompilationContextForTest : (filename: string, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>                                : ^        ^^      ^^            ^^                             ^^^^^                  
>unitName : string
>         : ^^^^^^
>dependencies : TestCaseParser.TestUnitData[]
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            compileUnit(lastUnit.content, unitName, callback, settingsCallback, compilationContext, lastUnit.references);
>compileUnit(lastUnit.content, unitName, callback, settingsCallback, compilationContext, lastUnit.references) : void
>                                                                                                             : ^^^^
>compileUnit : (code: string, filename: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: TypeScript.CompilationSettings) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>            : ^    ^^      ^^        ^^      ^^        ^^                             ^^                ^^^                                                   ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>lastUnit.content : string
>                 : ^^^^^^
>lastUnit : TestCaseParser.TestUnitData
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>content : string
>        : ^^^^^^
>unitName : string
>         : ^^^^^^
>callback : (res: Compiler.CompilerResult) => void
>         : ^   ^^                       ^^^^^    
>settingsCallback : () => void
>                 : ^^^^^^    
>compilationContext : CompilationContext
>                   : ^^^^^^^^^^^^^^^^^^
>lastUnit.references : TypeScript.IFileReference[]
>                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>lastUnit : TestCaseParser.TestUnitData
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
        }

        export function emitToOutfile(outfile: WriterAggregator) {
>emitToOutfile : (outfile: WriterAggregator) => void
>              : ^       ^^                ^^^^^^^^^
>outfile : WriterAggregator
>        : ^^^^^^^^^^^^^^^^

            compiler.emitToOutfile(outfile);
>compiler.emitToOutfile(outfile) : any
>                                : ^^^
>compiler.emitToOutfile : any
>                       : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emitToOutfile : any
>              : ^^^
>outfile : WriterAggregator
>        : ^^^^^^^^^^^^^^^^
        }

        export function emit(ioHost: TypeScript.EmitterIOHost, usePullEmitter?: boolean) {
>emit : (ioHost: TypeScript.EmitterIOHost, usePullEmitter?: boolean) => void
>     : ^      ^^                        ^^              ^^^       ^^^^^^^^^
>ioHost : TypeScript.EmitterIOHost
>       : ^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>usePullEmitter : boolean
>               : ^^^^^^^

            compiler.emit(ioHost, usePullEmitter);
>compiler.emit(ioHost, usePullEmitter) : any
>                                      : ^^^
>compiler.emit : any
>              : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emit : any
>     : ^^^
>ioHost : TypeScript.EmitterIOHost
>       : ^^^^^^^^^^^^^^^^^^^^^^^^
>usePullEmitter : boolean
>               : ^^^^^^^
        }

        export function compileString(code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
>              : ^    ^^      ^^        ^^      ^^        ^^                                      ^^       ^^^                  ^^          ^^^                           ^^^^^^^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>callback : (res: Compiler.CompilerResult) => void
>         : ^   ^^                       ^^^^^    
>res : CompilerResult
>    : ^^^^^^^^^^^^^^
>Compiler : any
>         : ^^^
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^

            var scripts: TypeScript.Script[] = [];
>scripts : TypeScript.Script[]
>        : ^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            reset();
>reset() : void
>        : ^^^^
>reset : () => void
>      : ^^^^^^^^^^

            if (context) {
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^

                context.preCompile();
>context.preCompile() : void
>                     : ^^^^
>context.preCompile : () => void
>                   : ^^^^^^    
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>preCompile : () => void
>           : ^^^^^^    
            }

            var isDeclareFile = Harness.Compiler.isDeclareFile(unitName);
>isDeclareFile : boolean
>              : ^^^^^^^
>Harness.Compiler.isDeclareFile(unitName) : boolean
>                                         : ^^^^^^^
>Harness.Compiler.isDeclareFile : (filename: string) => boolean
>                               : ^        ^^      ^^^^^^^^^^^^
>Harness.Compiler : typeof Compiler
>                 : ^^^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>isDeclareFile : (filename: string) => boolean
>              : ^        ^^      ^^^^^^^^^^^^
>unitName : string
>         : ^^^^^^

            // for single file tests just add them as using the old '0.ts' naming scheme
            var uName = context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts');
>uName : string
>      : ^^^^^^
>context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts') : string
>                                                           : ^^^^^^
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>unitName : string
>         : ^^^^^^
>((isDeclareFile) ? '0.d.ts' : '0.ts') : "0.ts" | "0.d.ts"
>                                      : ^^^^^^^^^^^^^^^^^
>(isDeclareFile) ? '0.d.ts' : '0.ts' : "0.ts" | "0.d.ts"
>                                    : ^^^^^^^^^^^^^^^^^
>(isDeclareFile) : boolean
>                : ^^^^^^^
>isDeclareFile : boolean
>              : ^^^^^^^
>'0.d.ts' : "0.d.ts"
>         : ^^^^^^^^
>'0.ts' : "0.ts"
>       : ^^^^^^

            scripts.push(addUnit(code, uName, false, isDeclareFile, references));
>scripts.push(addUnit(code, uName, false, isDeclareFile, references)) : number
>                                                                     : ^^^^^^
>scripts.push : (...items: TypeScript.Script[]) => number
>             : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^      
>scripts : TypeScript.Script[]
>        : ^^^^^^^^^^^^^^^^^^^
>push : (...items: TypeScript.Script[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^      
>addUnit(code, uName, false, isDeclareFile, references) : TypeScript.Script
>                                                       : ^^^^^^^^^^^^^^^^^
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: TypeScript.IFileReference[]) => TypeScript.Script
>        : ^    ^^      ^^        ^^^      ^^          ^^^       ^^             ^^^       ^^          ^^^                           ^^^^^^^^^^^^^^^^^^^^^^
>code : string
>     : ^^^^^^
>uName : string
>      : ^^^^^^
>false : false
>      : ^^^^^
>isDeclareFile : boolean
>              : ^^^^^^^
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

            compile(code, uName);
>compile(code, uName) : void
>                     : ^^^^
>compile : (code?: string, filename?: string) => void
>        : ^    ^^^      ^^        ^^^      ^^^^^^^^^
>code : string
>     : ^^^^^^
>uName : string
>      : ^^^^^^

            var errors;
>errors : any
>       : ^^^

            if (usePull) {
>usePull : boolean
>        : ^^^^^^^

                // TODO: no emit support with pull yet
                errors = compiler.pullGetErrorsForFile(uName);
>errors = compiler.pullGetErrorsForFile(uName) : any
>                                              : ^^^
>errors : any
>       : ^^^
>compiler.pullGetErrorsForFile(uName) : any
>                                     : ^^^
>compiler.pullGetErrorsForFile : any
>                              : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>pullGetErrorsForFile : any
>                     : ^^^
>uName : string
>      : ^^^^^^

                emit(stdout, true);
>emit(stdout, true) : void
>                   : ^^^^
>emit : (ioHost: TypeScript.EmitterIOHost, usePullEmitter?: boolean) => void
>     : ^      ^^                        ^^              ^^^       ^^^^^^^^^
>stdout : EmitterIOHost
>       : ^^^^^^^^^^^^^
>true : true
>     : ^^^^
            }
            else {
                errors = stderr.lines;
>errors = stderr.lines : string[]
>                      : ^^^^^^^^
>errors : any
>       : ^^^
>stderr.lines : string[]
>             : ^^^^^^^^
>stderr : WriterAggregator
>       : ^^^^^^^^^^^^^^^^
>lines : string[]
>      : ^^^^^^^^

                emit(stdout, false);
>emit(stdout, false) : void
>                    : ^^^^
>emit : (ioHost: TypeScript.EmitterIOHost, usePullEmitter?: boolean) => void
>     : ^      ^^                        ^^              ^^^       ^^^^^^^^^
>stdout : EmitterIOHost
>       : ^^^^^^^^^^^^^
>false : false
>      : ^^^^^

                //output decl file
                compiler.emitDeclarations();
>compiler.emitDeclarations() : any
>                            : ^^^
>compiler.emitDeclarations : any
>                          : ^^^
>compiler : TypeScript.TypeScriptCompiler
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>emitDeclarations : any
>                 : ^^^
            }

            if (context) {
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^

                context.postCompile();
>context.postCompile() : void
>                      : ^^^^
>context.postCompile : () => void
>                    : ^^^^^^    
>context : CompilationContext
>        : ^^^^^^^^^^^^^^^^^^
>postCompile : () => void
>            : ^^^^^^    
            }

            callback(new CompilerResult(stdout.toArray(), errors, scripts));
>callback(new CompilerResult(stdout.toArray(), errors, scripts)) : void
>                                                                : ^^^^
>callback : (res: Compiler.CompilerResult) => void
>         : ^   ^^                       ^^^^^    
>new CompilerResult(stdout.toArray(), errors, scripts) : CompilerResult
>                                                      : ^^^^^^^^^^^^^^
>CompilerResult : typeof CompilerResult
>               : ^^^^^^^^^^^^^^^^^^^^^
>stdout.toArray() : { filename: string; file: WriterAggregator; }[]
>                 : ^^^^^^^^^^^^      ^^^^^^^^                ^^^^^
>stdout.toArray : () => { filename: string; file: WriterAggregator; }[]
>               : ^^^^^^                                               
>stdout : EmitterIOHost
>       : ^^^^^^^^^^^^^
>toArray : () => { filename: string; file: WriterAggregator; }[]
>        : ^^^^^^                                               
>errors : any
>       : ^^^
>scripts : TypeScript.Script[]
>        : ^^^^^^^^^^^^^^^^^^^
        }

        /** Returns a set of functions which can be later executed to add and remove given dependencies to the compiler so that
         *  a file can be successfully compiled. These functions will add/remove named units and code to the compiler for each dependency. 
         */
        export function defineCompilationContextForTest(filename: string, dependencies: TestCaseParser.TestUnitData[]): CompilationContext {
>defineCompilationContextForTest : (filename: string, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>                                : ^        ^^      ^^            ^^                             ^^^^^                  
>filename : string
>         : ^^^^^^
>dependencies : TestCaseParser.TestUnitData[]
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TestCaseParser : any
>               : ^^^

            // if the given file has no dependencies, there is no context to return, it can be compiled without additional work
            if (dependencies.length == 0) {
>dependencies.length == 0 : boolean
>                         : ^^^^^^^
>dependencies.length : number
>                    : ^^^^^^
>dependencies : TestCaseParser.TestUnitData[]
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>0 : 0
>  : ^

                return null;
            } else {
                var addedFiles = [];
>addedFiles : any[]
>           : ^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                var precompile = () => {
>precompile : () => void
>           : ^^^^^^^^^^
>() => {                    // REVIEW: if any dependency has a triple slash reference then does postCompile potentially have to do a recreate since we can't update references with updateUnit?                    // easy enough to do if so, prefer to avoid the recreate cost until it proves to be an issue                    dependencies.forEach(dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    });                } : () => void
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  : ^^^^^^^^^^

                    // REVIEW: if any dependency has a triple slash reference then does postCompile potentially have to do a recreate since we can't update references with updateUnit?
                    // easy enough to do if so, prefer to avoid the recreate cost until it proves to be an issue
                    dependencies.forEach(dep => {
>dependencies.forEach(dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    }) : void
>                                                                                                                                                                                                              : ^^^^
>dependencies.forEach : (callbackfn: (value: TestCaseParser.TestUnitData, index: number, array: TestCaseParser.TestUnitData[]) => void, thisArg?: any) => void
>                     : ^          ^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>dependencies : TestCaseParser.TestUnitData[]
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>forEach : (callbackfn: (value: TestCaseParser.TestUnitData, index: number, array: TestCaseParser.TestUnitData[]) => void, thisArg?: any) => void
>        : ^          ^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    } : (dep: TestCaseParser.TestUnitData) => void
>                                                                                                                                                                                        : ^   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>dep : TestCaseParser.TestUnitData
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));
>addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name)) : TypeScript.Script
>                                                                                : ^^^^^^^^^^^^^^^^^
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: TypeScript.IFileReference[]) => TypeScript.Script
>        : ^    ^^      ^^        ^^^      ^^          ^^^       ^^             ^^^       ^^          ^^^                           ^^^^^^^^^^^^^^^^^^^^^^
>dep.content : string
>            : ^^^^^^
>dep : TestCaseParser.TestUnitData
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>content : string
>        : ^^^^^^
>dep.name : string
>         : ^^^^^^
>dep : TestCaseParser.TestUnitData
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>false : false
>      : ^^^^^
>Harness.Compiler.isDeclareFile(dep.name) : boolean
>                                         : ^^^^^^^
>Harness.Compiler.isDeclareFile : (filename: string) => boolean
>                               : ^        ^^      ^^^^^^^^^^^^
>Harness.Compiler : typeof Compiler
>                 : ^^^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>isDeclareFile : (filename: string) => boolean
>              : ^        ^^      ^^^^^^^^^^^^
>dep.name : string
>         : ^^^^^^
>dep : TestCaseParser.TestUnitData
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^

                        addedFiles.push(dep.name);
>addedFiles.push(dep.name) : number
>                          : ^^^^^^
>addedFiles.push : (...items: any[]) => number
>                : ^^^^     ^^^^^^^^^^^^      
>addedFiles : any[]
>           : ^^^^^
>push : (...items: any[]) => number
>     : ^^^^     ^^^^^^^^^^^^      
>dep.name : string
>         : ^^^^^^
>dep : TestCaseParser.TestUnitData
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^

                    });
                };
                var postcompile = () => {
>postcompile : () => void
>            : ^^^^^^^^^^
>() => {                    addedFiles.forEach(file => {                        updateUnit('', file);                    });                } : () => void
>                                                                                                                                             : ^^^^^^^^^^

                    addedFiles.forEach(file => {
>addedFiles.forEach(file => {                        updateUnit('', file);                    }) : void
>                                                                                                : ^^^^
>addedFiles.forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>                   : ^          ^^^     ^^^^^^^     ^^      ^^     ^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>addedFiles : any[]
>           : ^^^^^
>forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>        : ^          ^^^     ^^^^^^^     ^^      ^^     ^^^^^^^^^^^^    ^^       ^^^   ^^^^^    
>file => {                        updateUnit('', file);                    } : (file: any) => void
>                                                                            : ^    ^^^^^^^^^^^^^^
>file : any
>     : ^^^

                        updateUnit('', file);
>updateUnit('', file) : void
>                     : ^^^^
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>           : ^    ^^      ^^        ^^      ^^           ^^^       ^^^^^^^^^
>'' : ""
>   : ^^
>file : any
>     : ^^^

                    });
                };
                var context = {
>context : { filename: string; preCompile: () => void; postCompile: () => void; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{                    filename: filename,                    preCompile: precompile,                    postCompile: postcompile                } : { filename: string; preCompile: () => void; postCompile: () => void; }
>                                                                                                                                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                    filename: filename,
>filename : string
>         : ^^^^^^
>filename : string
>         : ^^^^^^

                    preCompile: precompile,
>preCompile : () => void
>           : ^^^^^^^^^^
>precompile : () => void
>           : ^^^^^^^^^^

                    postCompile: postcompile
>postCompile : () => void
>            : ^^^^^^^^^^
>postcompile : () => void
>            : ^^^^^^^^^^

                };
                return context;
>context : { filename: string; preCompile: () => void; postCompile: () => void; }
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            }
        }
    }

    /** Parses the test cases files 
     *  extracts options and individual files in a multifile test
     */
    export module TestCaseParser {
>TestCaseParser : typeof TestCaseParser
>               : ^^^^^^^^^^^^^^^^^^^^^

        /** all the necesarry information to set the right compiler settings */
        export interface CompilerSetting {
            flag: string;
>flag : string
>     : ^^^^^^

            value: string;
>value : string
>      : ^^^^^^
        }

        /** All the necessary information to turn a multi file test into useful units for later compilation */
        export interface TestUnitData {
            content: string;
>content : string
>        : ^^^^^^

            name: string;
>name : string
>     : ^^^^^^

            originalFilePath: string;
>originalFilePath : string
>                 : ^^^^^^

            references: TypeScript.IFileReference[];
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
        }

        // Regex for parsing options in the format "@Alpha: Value of any sort"
        private optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm;  // multiple matches on multiple lines
>optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm : RegExp
>                                             : ^^^^^^
>optionRegex : any
>            : ^^^
>/^[\/]{2}\s*@(\w+):\s*(\S*)/gm : RegExp
>                               : ^^^^^^

        // List of allowed metadata names
        var fileMetadataNames = ["filename", "comments", "declaration", "module", "nolib", "sourcemap", "target", "out"];
>fileMetadataNames : string[]
>                  : ^^^^^^^^
>["filename", "comments", "declaration", "module", "nolib", "sourcemap", "target", "out"] : string[]
>                                                                                         : ^^^^^^^^
>"filename" : "filename"
>           : ^^^^^^^^^^
>"comments" : "comments"
>           : ^^^^^^^^^^
>"declaration" : "declaration"
>              : ^^^^^^^^^^^^^
>"module" : "module"
>         : ^^^^^^^^
>"nolib" : "nolib"
>        : ^^^^^^^
>"sourcemap" : "sourcemap"
>            : ^^^^^^^^^^^
>"target" : "target"
>         : ^^^^^^^^
>"out" : "out"
>      : ^^^^^

        function extractCompilerSettings(content: string): CompilerSetting[] {
>extractCompilerSettings : (content: string) => CompilerSetting[]
>                        : ^       ^^      ^^^^^                 
>content : string
>        : ^^^^^^

            var opts = [];
>opts : any[]
>     : ^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            var match;
>match : any
>      : ^^^

            while ((match = optionRegex.exec(content)) != null) {
>(match = optionRegex.exec(content)) != null : boolean
>                                            : ^^^^^^^
>(match = optionRegex.exec(content)) : any
>                                    : ^^^
>match = optionRegex.exec(content) : any
>                                  : ^^^
>match : any
>      : ^^^
>optionRegex.exec(content) : any
>                          : ^^^
>optionRegex.exec : any
>                 : ^^^
>optionRegex : any
>            : ^^^
>exec : any
>     : ^^^
>content : string
>        : ^^^^^^

                opts.push({ flag: match[1], value: match[2] });
>opts.push({ flag: match[1], value: match[2] }) : number
>                                               : ^^^^^^
>opts.push : (...items: any[]) => number
>          : ^^^^     ^^^^^^^^^^^^      
>opts : any[]
>     : ^^^^^
>push : (...items: any[]) => number
>     : ^^^^     ^^^^^^^^^^^^      
>{ flag: match[1], value: match[2] } : { flag: any; value: any; }
>                                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>flag : any
>     : ^^^
>match[1] : any
>         : ^^^
>match : any
>      : ^^^
>1 : 1
>  : ^
>value : any
>      : ^^^
>match[2] : any
>         : ^^^
>match : any
>      : ^^^
>2 : 2
>  : ^
            }

            return opts;
>opts : any[]
>     : ^^^^^
        }

        /** Given a test file containing // @Filename directives, return an array of named units of code to be added to an existing compiler instance */
        export function makeUnitsFromTest(code: string, filename: string): { settings: CompilerSetting[]; testUnitData: TestUnitData[]; } {
>makeUnitsFromTest : (code: string, filename: string) => { settings: CompilerSetting[]; testUnitData: TestUnitData[]; }
>                  : ^    ^^      ^^        ^^      ^^^^^                                                              
>code : string
>     : ^^^^^^
>filename : string
>         : ^^^^^^
>settings : CompilerSetting[]
>         : ^^^^^^^^^^^^^^^^^
>testUnitData : TestUnitData[]
>             : ^^^^^^^^^^^^^^

            var settings = extractCompilerSettings(code);
>settings : CompilerSetting[]
>         : ^^^^^^^^^^^^^^^^^
>extractCompilerSettings(code) : CompilerSetting[]
>                              : ^^^^^^^^^^^^^^^^^
>extractCompilerSettings : (content: string) => CompilerSetting[]
>                        : ^       ^^      ^^^^^                 
>code : string
>     : ^^^^^^

            // List of all the subfiles we've parsed out
            var files: TestUnitData[] = [];
>files : TestUnitData[]
>      : ^^^^^^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            var lines = splitContentByNewlines(code);
>lines : string[]
>      : ^^^^^^^^
>splitContentByNewlines(code) : string[]
>                             : ^^^^^^^^
>splitContentByNewlines : (content: string) => string[]
>                       : ^       ^^      ^^^^^^^^^^^^^
>code : string
>     : ^^^^^^

            // Stuff related to the subfile we're parsing
            var currentFileContent: string = null;
>currentFileContent : string
>                   : ^^^^^^

            var currentFileOptions = {};
>currentFileOptions : {}
>                   : ^^
>{} : {}
>   : ^^

            var currentFileName = null;
>currentFileName : any
>                : ^^^

            var refs: TypeScript.IFileReference[] = [];
>refs : TypeScript.IFileReference[]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            for (var i = 0; i < lines.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < lines.length : boolean
>                 : ^^^^^^^
>i : number
>  : ^^^^^^
>lines.length : number
>             : ^^^^^^
>lines : string[]
>      : ^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                var line = lines[i];
>line : string
>     : ^^^^^^
>lines[i] : string
>         : ^^^^^^
>lines : string[]
>      : ^^^^^^^^
>i : number
>  : ^^^^^^

                var isTripleSlashReference = /[\/]{3}\s*<reference path/.test(line);
>isTripleSlashReference : boolean
>                       : ^^^^^^^
>/[\/]{3}\s*<reference path/.test(line) : boolean
>                                       : ^^^^^^^
>/[\/]{3}\s*<reference path/.test : (string: string) => boolean
>                                 : ^      ^^      ^^^^^       
>/[\/]{3}\s*<reference path/ : RegExp
>                            : ^^^^^^
>test : (string: string) => boolean
>     : ^      ^^      ^^^^^       
>line : string
>     : ^^^^^^

                var testMetaData = optionRegex.exec(line);
>testMetaData : any
>             : ^^^
>optionRegex.exec(line) : any
>                       : ^^^
>optionRegex.exec : any
>                 : ^^^
>optionRegex : any
>            : ^^^
>exec : any
>     : ^^^
>line : string
>     : ^^^^^^

                // Triple slash references need to be tracked as they are added to the compiler as an additional parameter to addUnit
                if (isTripleSlashReference) {
>isTripleSlashReference : boolean
>                       : ^^^^^^^

                    var isRef = line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/);
>isRef : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^
>line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/) : RegExpMatchArray
>                                                    : ^^^^^^^^^^^^^^^^
>line.match : (regexp: string | RegExp) => RegExpMatchArray | null
>           : ^      ^^               ^^^^^                       
>line : string
>     : ^^^^^^
>match : (regexp: string | RegExp) => RegExpMatchArray | null
>      : ^      ^^               ^^^^^                       
>/reference\spath='(\w*_?\w*\.?d?\.ts)'/ : RegExp
>                                        : ^^^^^^

                    if (isRef) {
>isRef : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^

                        var ref = {
>ref : { minChar: number; limChar: number; startLine: number; startCol: number; path: string; isResident: boolean; }
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{                            minChar: 0,                            limChar: 0,                            startLine:0,                            startCol:0,                            path: isRef[1],                            isResident: false                        } : { minChar: number; limChar: number; startLine: number; startCol: number; path: string; isResident: boolean; }
>                                                                                                                                                                                                                                                                                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                            minChar: 0,
>minChar : number
>        : ^^^^^^
>0 : 0
>  : ^

                            limChar: 0,
>limChar : number
>        : ^^^^^^
>0 : 0
>  : ^

                            startLine:0,
>startLine : number
>          : ^^^^^^
>0 : 0
>  : ^

                            startCol:0,
>startCol : number
>         : ^^^^^^
>0 : 0
>  : ^

                            path: isRef[1],
>path : string
>     : ^^^^^^
>isRef[1] : string
>         : ^^^^^^
>isRef : RegExpMatchArray
>      : ^^^^^^^^^^^^^^^^
>1 : 1
>  : ^

                            isResident: false
>isResident : boolean
>           : ^^^^^^^
>false : false
>      : ^^^^^

                        };

                        refs.push(ref);
>refs.push(ref) : number
>               : ^^^^^^
>refs.push : (...items: TypeScript.IFileReference[]) => number
>          : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      
>refs : TypeScript.IFileReference[]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>push : (...items: TypeScript.IFileReference[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      
>ref : { minChar: number; limChar: number; startLine: number; startCol: number; path: string; isResident: boolean; }
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                    }
                } else if (testMetaData) {
>testMetaData : any
>             : ^^^

                    // Comment line, check for global/file @options and record them
                    optionRegex.lastIndex = 0;
>optionRegex.lastIndex = 0 : 0
>                          : ^
>optionRegex.lastIndex : any
>                      : ^^^
>optionRegex : any
>            : ^^^
>lastIndex : any
>          : ^^^
>0 : 0
>  : ^

                    var fileNameIndex = fileMetadataNames.indexOf(testMetaData[1].toLowerCase());
>fileNameIndex : number
>              : ^^^^^^
>fileMetadataNames.indexOf(testMetaData[1].toLowerCase()) : number
>                                                         : ^^^^^^
>fileMetadataNames.indexOf : (searchElement: string, fromIndex?: number) => number
>                          : ^             ^^^^^^^^^^         ^^^      ^^^^^      
>fileMetadataNames : string[]
>                  : ^^^^^^^^
>indexOf : (searchElement: string, fromIndex?: number) => number
>        : ^             ^^^^^^^^^^         ^^^      ^^^^^      
>testMetaData[1].toLowerCase() : any
>                              : ^^^
>testMetaData[1].toLowerCase : any
>                            : ^^^
>testMetaData[1] : any
>                : ^^^
>testMetaData : any
>             : ^^^
>1 : 1
>  : ^
>toLowerCase : any
>            : ^^^

                    if (fileNameIndex == -1) {
>fileNameIndex == -1 : boolean
>                    : ^^^^^^^
>fileNameIndex : number
>              : ^^^^^^
>-1 : -1
>   : ^^
>1 : 1
>  : ^

                        throw new Error('Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', '));
>new Error('Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', ')) : Error
>                                                                                                                                      : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>'Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', ') : string
>                                                                                                                           : ^^^^^^
>'Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' : string
>                                                                                            : ^^^^^^
>'Unrecognized metadata name "' + testMetaData[1] : string
>                                                 : ^^^^^^
>'Unrecognized metadata name "' : "Unrecognized metadata name \""
>                               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>testMetaData[1] : any
>                : ^^^
>testMetaData : any
>             : ^^^
>1 : 1
>  : ^
>'". Available file metadata names are: ' : "\". Available file metadata names are: "
>                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>fileMetadataNames.join(', ') : string
>                             : ^^^^^^
>fileMetadataNames.join : (separator?: string) => string
>                       : ^         ^^^      ^^^^^      
>fileMetadataNames : string[]
>                  : ^^^^^^^^
>join : (separator?: string) => string
>     : ^         ^^^      ^^^^^      
>', ' : ", "
>     : ^^^^

                    } else if (fileNameIndex == 0) {
>fileNameIndex == 0 : boolean
>                   : ^^^^^^^
>fileNameIndex : number
>              : ^^^^^^
>0 : 0
>  : ^

                        currentFileOptions[testMetaData[1]] = testMetaData[2];
>currentFileOptions[testMetaData[1]] = testMetaData[2] : any
>                                                      : ^^^
>currentFileOptions[testMetaData[1]] : any
>                                    : ^^^
>currentFileOptions : {}
>                   : ^^
>testMetaData[1] : any
>                : ^^^
>testMetaData : any
>             : ^^^
>1 : 1
>  : ^
>testMetaData[2] : any
>                : ^^^
>testMetaData : any
>             : ^^^
>2 : 2
>  : ^

                    } else {
                        continue;
                    }

                    // New metadata statement after having collected some code to go with the previous metadata
                    if (currentFileName) {
>currentFileName : any
>                : ^^^

                        // Store result file
                        var newTestFile =
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: TypeScript.IFileReference[]; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                            {
>{                                content: currentFileContent,                                name: currentFileName,                                fileOptions: currentFileOptions,                                originalFilePath: filename,                                references: refs                            } : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: TypeScript.IFileReference[]; }
>                                                                                                                                                                                                                                                                                                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                                content: currentFileContent,
>content : string
>        : ^^^^^^
>currentFileContent : string
>                   : ^^^^^^

                                name: currentFileName,
>name : any
>     : ^^^
>currentFileName : any
>                : ^^^

                                fileOptions: currentFileOptions,
>fileOptions : {}
>            : ^^
>currentFileOptions : {}
>                   : ^^

                                originalFilePath: filename,
>originalFilePath : string
>                 : ^^^^^^
>filename : string
>         : ^^^^^^

                                references: refs
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>refs : TypeScript.IFileReference[]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

                            };
                        files.push(newTestFile);
>files.push(newTestFile) : number
>                        : ^^^^^^
>files.push : (...items: TestUnitData[]) => number
>           : ^^^^     ^^^^^^^^^^^^^^^^^^^^^      
>files : TestUnitData[]
>      : ^^^^^^^^^^^^^^
>push : (...items: TestUnitData[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^      
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: TypeScript.IFileReference[]; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                        // Reset local data
                        currentFileContent = null;
>currentFileContent = null : null
>                          : ^^^^
>currentFileContent : string
>                   : ^^^^^^

                        currentFileOptions = {};
>currentFileOptions = {} : {}
>                        : ^^
>currentFileOptions : {}
>                   : ^^
>{} : {}
>   : ^^

                        currentFileName = testMetaData[2];
>currentFileName = testMetaData[2] : any
>                                  : ^^^
>currentFileName : any
>                : ^^^
>testMetaData[2] : any
>                : ^^^
>testMetaData : any
>             : ^^^
>2 : 2
>  : ^

                        refs = [];
>refs = [] : undefined[]
>          : ^^^^^^^^^^^
>refs : TypeScript.IFileReference[]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                    } else {
                        // First metadata marker in the file
                        currentFileName = testMetaData[2];
>currentFileName = testMetaData[2] : any
>                                  : ^^^
>currentFileName : any
>                : ^^^
>testMetaData[2] : any
>                : ^^^
>testMetaData : any
>             : ^^^
>2 : 2
>  : ^
                    }
                } else {
                    // Subfile content line
                    // Append to the current subfile content, inserting a newline needed
                    if (currentFileContent === null) {
>currentFileContent === null : boolean
>                            : ^^^^^^^
>currentFileContent : string
>                   : ^^^^^^

                        currentFileContent = '';
>currentFileContent = '' : ""
>                        : ^^
>currentFileContent : string
>                   : ^^^^^^
>'' : ""
>   : ^^

                    } else {
                        // End-of-line
                        currentFileContent = currentFileContent + '\n';
>currentFileContent = currentFileContent + '\n' : string
>                                               : ^^^^^^
>currentFileContent : string
>                   : ^^^^^^
>currentFileContent + '\n' : string
>                          : ^^^^^^
>currentFileContent : string
>                   : ^^^^^^
>'\n' : "\n"
>     : ^^^^
                    }
                    currentFileContent = currentFileContent + line;
>currentFileContent = currentFileContent + line : string
>                                               : ^^^^^^
>currentFileContent : string
>                   : ^^^^^^
>currentFileContent + line : string
>                          : ^^^^^^
>currentFileContent : string
>                   : ^^^^^^
>line : string
>     : ^^^^^^
                }
            }

            // normalize the filename for the single file case
            currentFileName = files.length > 0 ? currentFileName : '0.ts';
>currentFileName = files.length > 0 ? currentFileName : '0.ts' : any
>                                                              : ^^^
>currentFileName : any
>                : ^^^
>files.length > 0 ? currentFileName : '0.ts' : any
>                                            : ^^^
>files.length > 0 : boolean
>                 : ^^^^^^^
>files.length : number
>             : ^^^^^^
>files : TestUnitData[]
>      : ^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>0 : 0
>  : ^
>currentFileName : any
>                : ^^^
>'0.ts' : "0.ts"
>       : ^^^^^^

            // EOF, push whatever remains
            var newTestFile = {
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: TypeScript.IFileReference[]; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{                content: currentFileContent || '',                name: currentFileName,                fileOptions: currentFileOptions,                originalFilePath: filename,                references: refs            } : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: TypeScript.IFileReference[]; }
>                                                                                                                                                                                                                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                content: currentFileContent || '',
>content : string
>        : ^^^^^^
>currentFileContent || '' : string
>                         : ^^^^^^
>currentFileContent : string
>                   : ^^^^^^
>'' : ""
>   : ^^

                name: currentFileName,
>name : any
>     : ^^^
>currentFileName : any
>                : ^^^

                fileOptions: currentFileOptions,
>fileOptions : {}
>            : ^^
>currentFileOptions : {}
>                   : ^^

                originalFilePath: filename,
>originalFilePath : string
>                 : ^^^^^^
>filename : string
>         : ^^^^^^

                references: refs
>references : TypeScript.IFileReference[]
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>refs : TypeScript.IFileReference[]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

            };
            files.push(newTestFile);
>files.push(newTestFile) : number
>                        : ^^^^^^
>files.push : (...items: TestUnitData[]) => number
>           : ^^^^     ^^^^^^^^^^^^^^^^^^^^^      
>files : TestUnitData[]
>      : ^^^^^^^^^^^^^^
>push : (...items: TestUnitData[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^      
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: TypeScript.IFileReference[]; }
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            return { settings: settings, testUnitData: files };
>{ settings: settings, testUnitData: files } : { settings: CompilerSetting[]; testUnitData: TestUnitData[]; }
>                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>settings : CompilerSetting[]
>         : ^^^^^^^^^^^^^^^^^
>settings : CompilerSetting[]
>         : ^^^^^^^^^^^^^^^^^
>testUnitData : TestUnitData[]
>             : ^^^^^^^^^^^^^^
>files : TestUnitData[]
>      : ^^^^^^^^^^^^^^
        }
    }

    export class ScriptInfo {
>ScriptInfo : ScriptInfo
>           : ^^^^^^^^^^

        public version: number;
>version : number
>        : ^^^^^^

        public editRanges: { length: number; editRange: TypeScript.ScriptEditRange; }[] = [];
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>length : number
>       : ^^^^^^
>editRange : TypeScript.ScriptEditRange
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        constructor(public name: string, public content: string, public isResident: boolean, public maxScriptVersions: number) {
>name : string
>     : ^^^^^^
>content : string
>        : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
>maxScriptVersions : number
>                  : ^^^^^^

            this.version = 1;
>this.version = 1 : 1
>                 : ^
>this.version : number
>             : ^^^^^^
>this : this
>     : ^^^^
>version : number
>        : ^^^^^^
>1 : 1
>  : ^
        }

        public updateContent(content: string, isResident: boolean) {
>updateContent : (content: string, isResident: boolean) => void
>              : ^       ^^      ^^          ^^       ^^^^^^^^^
>content : string
>        : ^^^^^^
>isResident : boolean
>           : ^^^^^^^

            this.editRanges = [];
>this.editRanges = [] : undefined[]
>                     : ^^^^^^^^^^^
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            this.content = content;
>this.content = content : string
>                       : ^^^^^^
>this.content : string
>             : ^^^^^^
>this : this
>     : ^^^^
>content : string
>        : ^^^^^^
>content : string
>        : ^^^^^^

            this.isResident = isResident;
>this.isResident = isResident : boolean
>                             : ^^^^^^^
>this.isResident : boolean
>                : ^^^^^^^
>this : this
>     : ^^^^
>isResident : boolean
>           : ^^^^^^^
>isResident : boolean
>           : ^^^^^^^

            this.version++;
>this.version++ : number
>               : ^^^^^^
>this.version : number
>             : ^^^^^^
>this : this
>     : ^^^^
>version : number
>        : ^^^^^^
        }

        public editContent(minChar: number, limChar: number, newText: string) {
>editContent : (minChar: number, limChar: number, newText: string) => void
>            : ^       ^^      ^^       ^^      ^^       ^^      ^^^^^^^^^
>minChar : number
>        : ^^^^^^
>limChar : number
>        : ^^^^^^
>newText : string
>        : ^^^^^^

            // Apply edits
            var prefix = this.content.substring(0, minChar);
>prefix : string
>       : ^^^^^^
>this.content.substring(0, minChar) : string
>                                   : ^^^^^^
>this.content.substring : (start: number, end?: number) => string
>                       : ^     ^^      ^^   ^^^      ^^^^^      
>this.content : string
>             : ^^^^^^
>this : this
>     : ^^^^
>content : string
>        : ^^^^^^
>substring : (start: number, end?: number) => string
>          : ^     ^^      ^^   ^^^      ^^^^^      
>0 : 0
>  : ^
>minChar : number
>        : ^^^^^^

            var middle = newText;
>middle : string
>       : ^^^^^^
>newText : string
>        : ^^^^^^

            var suffix = this.content.substring(limChar);
>suffix : string
>       : ^^^^^^
>this.content.substring(limChar) : string
>                                : ^^^^^^
>this.content.substring : (start: number, end?: number) => string
>                       : ^     ^^      ^^   ^^^      ^^^^^      
>this.content : string
>             : ^^^^^^
>this : this
>     : ^^^^
>content : string
>        : ^^^^^^
>substring : (start: number, end?: number) => string
>          : ^     ^^      ^^   ^^^      ^^^^^      
>limChar : number
>        : ^^^^^^

            this.content = prefix + middle + suffix;
>this.content = prefix + middle + suffix : string
>                                        : ^^^^^^
>this.content : string
>             : ^^^^^^
>this : this
>     : ^^^^
>content : string
>        : ^^^^^^
>prefix + middle + suffix : string
>                         : ^^^^^^
>prefix + middle : string
>                : ^^^^^^
>prefix : string
>       : ^^^^^^
>middle : string
>       : ^^^^^^
>suffix : string
>       : ^^^^^^

            // Store edit range + new length of script
            this.editRanges.push({
>this.editRanges.push({                length: this.content.length,                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)            }) : number
>                                                                                                                                                                                                  : ^^^^^^
>this.editRanges.push : (...items: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => number
>                     : ^^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^      
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>push : (...items: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => number
>     : ^^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^      
>{                length: this.content.length,                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)            } : { length: number; editRange: any; }
>                                                                                                                                                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                length: this.content.length,
>length : number
>       : ^^^^^^
>this.content.length : number
>                    : ^^^^^^
>this.content : string
>             : ^^^^^^
>this : this
>     : ^^^^
>content : string
>        : ^^^^^^
>length : number
>       : ^^^^^^

                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)
>editRange : any
>          : ^^^
>new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length) : any
>                                                                                       : ^^^
>TypeScript.ScriptEditRange : any
>                           : ^^^
>TypeScript : any
>           : ^^^
>ScriptEditRange : any
>                : ^^^
>minChar : number
>        : ^^^^^^
>limChar : number
>        : ^^^^^^
>(limChar - minChar) + newText.length : number
>                                     : ^^^^^^
>(limChar - minChar) : number
>                    : ^^^^^^
>limChar - minChar : number
>                  : ^^^^^^
>limChar : number
>        : ^^^^^^
>minChar : number
>        : ^^^^^^
>newText.length : number
>               : ^^^^^^
>newText : string
>        : ^^^^^^
>length : number
>       : ^^^^^^

            });

            if (this.editRanges.length > this.maxScriptVersions) {
>this.editRanges.length > this.maxScriptVersions : boolean
>                                                : ^^^^^^^
>this.editRanges.length : number
>                       : ^^^^^^
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>length : number
>       : ^^^^^^
>this.maxScriptVersions : number
>                       : ^^^^^^
>this : this
>     : ^^^^
>maxScriptVersions : number
>                  : ^^^^^^

                this.editRanges.splice(0, this.maxScriptVersions - this.editRanges.length);
>this.editRanges.splice(0, this.maxScriptVersions - this.editRanges.length) : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                                                                           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this.editRanges.splice : { (start: number, deleteCount?: number): { length: number; editRange: TypeScript.ScriptEditRange; }[]; (start: number, deleteCount: number, ...items: { length: number; editRange: TypeScript.ScriptEditRange; }[]): { length: number; editRange: TypeScript.ScriptEditRange; }[]; }
>                       : ^^^     ^^      ^^           ^^^      ^^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^     ^^      ^^           ^^      ^^^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>splice : { (start: number, deleteCount?: number): { length: number; editRange: TypeScript.ScriptEditRange; }[]; (start: number, deleteCount: number, ...items: { length: number; editRange: TypeScript.ScriptEditRange; }[]): { length: number; editRange: TypeScript.ScriptEditRange; }[]; }
>       : ^^^     ^^      ^^           ^^^      ^^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^     ^^      ^^           ^^      ^^^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^
>0 : 0
>  : ^
>this.maxScriptVersions - this.editRanges.length : number
>                                                : ^^^^^^
>this.maxScriptVersions : number
>                       : ^^^^^^
>this : this
>     : ^^^^
>maxScriptVersions : number
>                  : ^^^^^^
>this.editRanges.length : number
>                       : ^^^^^^
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>length : number
>       : ^^^^^^
            }

            // Update version #
            this.version++;
>this.version++ : number
>               : ^^^^^^
>this.version : number
>             : ^^^^^^
>this : this
>     : ^^^^
>version : number
>        : ^^^^^^
        }

        public getEditRangeSinceVersion(version: number): TypeScript.ScriptEditRange {
>getEditRangeSinceVersion : (version: number) => TypeScript.ScriptEditRange
>                         : ^       ^^      ^^^^^                          
>version : number
>        : ^^^^^^
>TypeScript : any
>           : ^^^

            if (this.version == version) {
>this.version == version : boolean
>                        : ^^^^^^^
>this.version : number
>             : ^^^^^^
>this : this
>     : ^^^^
>version : number
>        : ^^^^^^
>version : number
>        : ^^^^^^

                // No edits!
                return null;
            }

            var initialEditRangeIndex = this.editRanges.length - (this.version - version);
>initialEditRangeIndex : number
>                      : ^^^^^^
>this.editRanges.length - (this.version - version) : number
>                                                  : ^^^^^^
>this.editRanges.length : number
>                       : ^^^^^^
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>length : number
>       : ^^^^^^
>(this.version - version) : number
>                         : ^^^^^^
>this.version - version : number
>                       : ^^^^^^
>this.version : number
>             : ^^^^^^
>this : this
>     : ^^^^
>version : number
>        : ^^^^^^
>version : number
>        : ^^^^^^

            if (initialEditRangeIndex < 0 || initialEditRangeIndex >= this.editRanges.length) {
>initialEditRangeIndex < 0 || initialEditRangeIndex >= this.editRanges.length : boolean
>                                                                             : ^^^^^^^
>initialEditRangeIndex < 0 : boolean
>                          : ^^^^^^^
>initialEditRangeIndex : number
>                      : ^^^^^^
>0 : 0
>  : ^
>initialEditRangeIndex >= this.editRanges.length : boolean
>                                                : ^^^^^^^
>initialEditRangeIndex : number
>                      : ^^^^^^
>this.editRanges.length : number
>                       : ^^^^^^
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>length : number
>       : ^^^^^^

                // Too far away from what we know
                return TypeScript.ScriptEditRange.unknown();
>TypeScript.ScriptEditRange.unknown() : any
>                                     : ^^^
>TypeScript.ScriptEditRange.unknown : any
>                                   : ^^^
>TypeScript.ScriptEditRange : any
>                           : ^^^
>TypeScript : any
>           : ^^^
>ScriptEditRange : any
>                : ^^^
>unknown : any
>        : ^^^
            }

            var entries = this.editRanges.slice(initialEditRangeIndex);
>entries : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>        : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this.editRanges.slice(initialEditRangeIndex) : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                                             : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this.editRanges.slice : (start?: number, end?: number) => { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                      : ^     ^^^      ^^   ^^^      ^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this.editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>                : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>this : this
>     : ^^^^
>editRanges : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>slice : (start?: number, end?: number) => { length: number; editRange: TypeScript.ScriptEditRange; }[]
>      : ^     ^^^      ^^   ^^^      ^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>initialEditRangeIndex : number
>                      : ^^^^^^

            var minDistFromStart = entries.map(x => x.editRange.minChar).reduce((prev, current) => Math.min(prev, current));
>minDistFromStart : any
>                 : ^^^
>entries.map(x => x.editRange.minChar).reduce((prev, current) => Math.min(prev, current)) : any
>                                                                                         : ^^^
>entries.map(x => x.editRange.minChar).reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>                                             : ^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^ ^^          ^^^             ^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^            ^^^^^^^^^^
>entries.map(x => x.editRange.minChar) : any[]
>                                      : ^^^^^
>entries.map : <U>(callbackfn: (value: { length: number; editRange: TypeScript.ScriptEditRange; }, index: number, array: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => U, thisArg?: any) => U[]
>            : ^ ^^          ^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^     ^^      ^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>entries : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>        : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>map : <U>(callbackfn: (value: { length: number; editRange: TypeScript.ScriptEditRange; }, index: number, array: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => U, thisArg?: any) => U[]
>    : ^ ^^          ^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^     ^^      ^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>x => x.editRange.minChar : (x: { length: number; editRange: TypeScript.ScriptEditRange; }) => any
>                         : ^ ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^
>x : { length: number; editRange: TypeScript.ScriptEditRange; }
>  : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>x.editRange.minChar : any
>                    : ^^^
>x.editRange : TypeScript.ScriptEditRange
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>x : { length: number; editRange: TypeScript.ScriptEditRange; }
>  : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>editRange : TypeScript.ScriptEditRange
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>minChar : any
>        : ^^^
>reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>       : ^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^ ^^          ^^^             ^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^            ^^^^^^^^^^
>(prev, current) => Math.min(prev, current) : (prev: any, current: any) => number
>                                           : ^    ^^^^^^^       ^^^^^^^^^^^^^^^^
>prev : any
>     : ^^^
>current : any
>        : ^^^
>Math.min(prev, current) : number
>                        : ^^^^^^
>Math.min : (...values: number[]) => number
>         : ^^^^      ^^        ^^^^^      
>Math : Math
>     : ^^^^
>min : (...values: number[]) => number
>    : ^^^^      ^^        ^^^^^      
>prev : any
>     : ^^^
>current : any
>        : ^^^

            var minDistFromEnd = entries.map(x => x.length - x.editRange.limChar).reduce((prev, current) => Math.min(prev, current));
>minDistFromEnd : number
>               : ^^^^^^
>entries.map(x => x.length - x.editRange.limChar).reduce((prev, current) => Math.min(prev, current)) : number
>                                                                                                    : ^^^^^^
>entries.map(x => x.length - x.editRange.limChar).reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>                                                        : ^^^          ^^^             ^^^^^^^^^^            ^^^^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^          ^^^             ^^^^^^^^^^            ^^^^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^^^^^^^ ^^          ^^^             ^^^^^            ^^^^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^            ^^^^^^^^^^
>entries.map(x => x.length - x.editRange.limChar) : number[]
>                                                 : ^^^^^^^^
>entries.map : <U>(callbackfn: (value: { length: number; editRange: TypeScript.ScriptEditRange; }, index: number, array: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => U, thisArg?: any) => U[]
>            : ^ ^^          ^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^     ^^      ^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>entries : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>        : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>map : <U>(callbackfn: (value: { length: number; editRange: TypeScript.ScriptEditRange; }, index: number, array: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => U, thisArg?: any) => U[]
>    : ^ ^^          ^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^     ^^      ^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>x => x.length - x.editRange.limChar : (x: { length: number; editRange: TypeScript.ScriptEditRange; }) => number
>                                    : ^ ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^^
>x : { length: number; editRange: TypeScript.ScriptEditRange; }
>  : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>x.length - x.editRange.limChar : number
>                               : ^^^^^^
>x.length : number
>         : ^^^^^^
>x : { length: number; editRange: TypeScript.ScriptEditRange; }
>  : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>length : number
>       : ^^^^^^
>x.editRange.limChar : any
>                    : ^^^
>x.editRange : TypeScript.ScriptEditRange
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>x : { length: number; editRange: TypeScript.ScriptEditRange; }
>  : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>editRange : TypeScript.ScriptEditRange
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>limChar : any
>        : ^^^
>reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>       : ^^^          ^^^             ^^^^^^^^^^            ^^^^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^          ^^^             ^^^^^^^^^^            ^^^^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^^^^^^^ ^^          ^^^             ^^^^^            ^^^^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^            ^^^^^^^^^^
>(prev, current) => Math.min(prev, current) : (prev: number, current: number) => number
>                                           : ^    ^^^^^^^^^^       ^^^^^^^^^^^^^^^^^^^
>prev : number
>     : ^^^^^^
>current : number
>        : ^^^^^^
>Math.min(prev, current) : number
>                        : ^^^^^^
>Math.min : (...values: number[]) => number
>         : ^^^^      ^^        ^^^^^      
>Math : Math
>     : ^^^^
>min : (...values: number[]) => number
>    : ^^^^      ^^        ^^^^^      
>prev : number
>     : ^^^^^^
>current : number
>        : ^^^^^^

            var aggDelta = entries.map(x => x.editRange.delta).reduce((prev, current) => prev + current);
>aggDelta : any
>         : ^^^
>entries.map(x => x.editRange.delta).reduce((prev, current) => prev + current) : any
>                                                                              : ^^^
>entries.map(x => x.editRange.delta).reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>                                           : ^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^ ^^          ^^^             ^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^            ^^^^^^^^^^
>entries.map(x => x.editRange.delta) : any[]
>                                    : ^^^^^
>entries.map : <U>(callbackfn: (value: { length: number; editRange: TypeScript.ScriptEditRange; }, index: number, array: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => U, thisArg?: any) => U[]
>            : ^ ^^          ^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^     ^^      ^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>entries : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>        : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>map : <U>(callbackfn: (value: { length: number; editRange: TypeScript.ScriptEditRange; }, index: number, array: { length: number; editRange: TypeScript.ScriptEditRange; }[]) => U, thisArg?: any) => U[]
>    : ^ ^^          ^^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^     ^^      ^^     ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>x => x.editRange.delta : (x: { length: number; editRange: TypeScript.ScriptEditRange; }) => any
>                       : ^ ^^^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^^^^^^^
>x : { length: number; editRange: TypeScript.ScriptEditRange; }
>  : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>x.editRange.delta : any
>                  : ^^^
>x.editRange : TypeScript.ScriptEditRange
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>x : { length: number; editRange: TypeScript.ScriptEditRange; }
>  : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>editRange : TypeScript.ScriptEditRange
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>delta : any
>      : ^^^
>reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>       : ^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^^^^^^^^          ^^^             ^^^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^ ^^          ^^^             ^^^^^            ^^^^^^^            ^^      ^^     ^^^^^^^^^^^^^^^            ^^^^^^^^^^
>(prev, current) => prev + current : (prev: any, current: any) => any
>                                  : ^    ^^^^^^^       ^^^^^^^^^^^^^
>prev : any
>     : ^^^
>current : any
>        : ^^^
>prev + current : any
>               : ^^^
>prev : any
>     : ^^^
>current : any
>        : ^^^

            return new TypeScript.ScriptEditRange(minDistFromStart, entries[0].length - minDistFromEnd, aggDelta);
>new TypeScript.ScriptEditRange(minDistFromStart, entries[0].length - minDistFromEnd, aggDelta) : any
>                                                                                               : ^^^
>TypeScript.ScriptEditRange : any
>                           : ^^^
>TypeScript : any
>           : ^^^
>ScriptEditRange : any
>                : ^^^
>minDistFromStart : any
>                 : ^^^
>entries[0].length - minDistFromEnd : number
>                                   : ^^^^^^
>entries[0].length : number
>                  : ^^^^^^
>entries[0] : { length: number; editRange: TypeScript.ScriptEditRange; }
>           : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^
>entries : { length: number; editRange: TypeScript.ScriptEditRange; }[]
>        : ^^^^^^^^^^      ^^^^^^^^^^^^^                          ^^^^^
>0 : 0
>  : ^
>length : number
>       : ^^^^^^
>minDistFromEnd : number
>               : ^^^^^^
>aggDelta : any
>         : ^^^
        }
    }

    export class TypeScriptLS implements Services.ILanguageServiceShimHost {
>TypeScriptLS : TypeScriptLS
>             : ^^^^^^^^^^^^
>Services : any
>         : ^^^

        private ls: Services.ILanguageServiceShim = null;
>ls : Services.ILanguageServiceShim
>   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Services : any
>         : ^^^

        public scripts: ScriptInfo[] = [];
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

        public maxScriptVersions = 100;
>maxScriptVersions : number
>                  : ^^^^^^
>100 : 100
>    : ^^^

        public addDefaultLibrary() {
>addDefaultLibrary : () => void
>                  : ^^^^^^^^^^

            this.addScript("lib.d.ts", Harness.Compiler.libText, true);
>this.addScript("lib.d.ts", Harness.Compiler.libText, true) : void
>                                                           : ^^^^
>this.addScript : (name: string, content: string, isResident?: boolean) => void
>               : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>addScript : (name: string, content: string, isResident?: boolean) => void
>          : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>"lib.d.ts" : "lib.d.ts"
>           : ^^^^^^^^^^
>Harness.Compiler.libText : any
>                         : ^^^
>Harness.Compiler : typeof Compiler
>                 : ^^^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>libText : any
>        : ^^^
>true : true
>     : ^^^^
        }

        public addFile(name: string, isResident = false) {
>addFile : (name: string, isResident?: boolean) => void
>        : ^    ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
>false : false
>      : ^^^^^

            var code: string = readFile(name);
>code : string
>     : ^^^^^^
>readFile(name) : any
>               : ^^^
>readFile : (path: string) => any
>         : ^    ^^      ^^^^^^^^
>name : string
>     : ^^^^^^

            this.addScript(name, code, isResident);
>this.addScript(name, code, isResident) : void
>                                       : ^^^^
>this.addScript : (name: string, content: string, isResident?: boolean) => void
>               : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>addScript : (name: string, content: string, isResident?: boolean) => void
>          : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>code : string
>     : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
        }

        public addScript(name: string, content: string, isResident = false) {
>addScript : (name: string, content: string, isResident?: boolean) => void
>          : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>content : string
>        : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
>false : false
>      : ^^^^^

            var script = new ScriptInfo(name, content, isResident, this.maxScriptVersions);
>script : ScriptInfo
>       : ^^^^^^^^^^
>new ScriptInfo(name, content, isResident, this.maxScriptVersions) : ScriptInfo
>                                                                  : ^^^^^^^^^^
>ScriptInfo : typeof ScriptInfo
>           : ^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>content : string
>        : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
>this.maxScriptVersions : number
>                       : ^^^^^^
>this : this
>     : ^^^^
>maxScriptVersions : number
>                  : ^^^^^^

            this.scripts.push(script);
>this.scripts.push(script) : number
>                          : ^^^^^^
>this.scripts.push : (...items: ScriptInfo[]) => number
>                  : ^^^^     ^^^^^^^^^^^^^^^^^^^      
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>push : (...items: ScriptInfo[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^      
>script : ScriptInfo
>       : ^^^^^^^^^^
        }

        public updateScript(name: string, content: string, isResident = false) {
>updateScript : (name: string, content: string, isResident?: boolean) => void
>             : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>content : string
>        : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
>false : false
>      : ^^^^^

            for (var i = 0; i < this.scripts.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < this.scripts.length : boolean
>                        : ^^^^^^^
>i : number
>  : ^^^^^^
>this.scripts.length : number
>                    : ^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                if (this.scripts[i].name == name) {
>this.scripts[i].name == name : boolean
>                             : ^^^^^^^
>this.scripts[i].name : string
>                     : ^^^^^^
>this.scripts[i] : ScriptInfo
>                : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>name : string
>     : ^^^^^^
>name : string
>     : ^^^^^^

                    this.scripts[i].updateContent(content, isResident);
>this.scripts[i].updateContent(content, isResident) : void
>                                                   : ^^^^
>this.scripts[i].updateContent : (content: string, isResident: boolean) => void
>                              : ^       ^^      ^^          ^^       ^^^^^^^^^
>this.scripts[i] : ScriptInfo
>                : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>updateContent : (content: string, isResident: boolean) => void
>              : ^       ^^      ^^          ^^       ^^^^^^^^^
>content : string
>        : ^^^^^^
>isResident : boolean
>           : ^^^^^^^

                    return;
                }
            }

            this.addScript(name, content, isResident);
>this.addScript(name, content, isResident) : void
>                                          : ^^^^
>this.addScript : (name: string, content: string, isResident?: boolean) => void
>               : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>addScript : (name: string, content: string, isResident?: boolean) => void
>          : ^    ^^      ^^       ^^      ^^          ^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>content : string
>        : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
        }

        public editScript(name: string, minChar: number, limChar: number, newText: string) {
>editScript : (name: string, minChar: number, limChar: number, newText: string) => void
>           : ^    ^^      ^^       ^^      ^^       ^^      ^^       ^^      ^^^^^^^^^
>name : string
>     : ^^^^^^
>minChar : number
>        : ^^^^^^
>limChar : number
>        : ^^^^^^
>newText : string
>        : ^^^^^^

            for (var i = 0; i < this.scripts.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < this.scripts.length : boolean
>                        : ^^^^^^^
>i : number
>  : ^^^^^^
>this.scripts.length : number
>                    : ^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                if (this.scripts[i].name == name) {
>this.scripts[i].name == name : boolean
>                             : ^^^^^^^
>this.scripts[i].name : string
>                     : ^^^^^^
>this.scripts[i] : ScriptInfo
>                : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>name : string
>     : ^^^^^^
>name : string
>     : ^^^^^^

                    this.scripts[i].editContent(minChar, limChar, newText);
>this.scripts[i].editContent(minChar, limChar, newText) : void
>                                                       : ^^^^
>this.scripts[i].editContent : (minChar: number, limChar: number, newText: string) => void
>                            : ^       ^^      ^^       ^^      ^^       ^^      ^^^^^^^^^
>this.scripts[i] : ScriptInfo
>                : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>editContent : (minChar: number, limChar: number, newText: string) => void
>            : ^       ^^      ^^       ^^      ^^       ^^      ^^^^^^^^^
>minChar : number
>        : ^^^^^^
>limChar : number
>        : ^^^^^^
>newText : string
>        : ^^^^^^

                    return;
                }
            }

            throw new Error("No script with name '" + name + "'");
>new Error("No script with name '" + name + "'") : Error
>                                                : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"No script with name '" + name + "'" : string
>                                     : ^^^^^^
>"No script with name '" + name : string
>                               : ^^^^^^
>"No script with name '" : "No script with name '"
>                        : ^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>"'" : "'"
>    : ^^^
        }

        public getScriptContent(scriptIndex: number): string {
>getScriptContent : (scriptIndex: number) => string
>                 : ^           ^^      ^^^^^      
>scriptIndex : number
>            : ^^^^^^

            return this.scripts[scriptIndex].content;
>this.scripts[scriptIndex].content : string
>                                  : ^^^^^^
>this.scripts[scriptIndex] : ScriptInfo
>                          : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>scriptIndex : number
>            : ^^^^^^
>content : string
>        : ^^^^^^
        }

        //////////////////////////////////////////////////////////////////////
        // ILogger implementation
        //
        public information(): boolean { return false; }
>information : () => boolean
>            : ^^^^^^       
>false : false
>      : ^^^^^

        public debug(): boolean { return true; }
>debug : () => boolean
>      : ^^^^^^       
>true : true
>     : ^^^^

        public warning(): boolean { return true; }
>warning : () => boolean
>        : ^^^^^^       
>true : true
>     : ^^^^

        public error(): boolean { return true; }
>error : () => boolean
>      : ^^^^^^       
>true : true
>     : ^^^^

        public fatal(): boolean { return true; }
>fatal : () => boolean
>      : ^^^^^^       
>true : true
>     : ^^^^

        public log(s: string): void {
>log : (s: string) => void
>    : ^ ^^      ^^^^^    
>s : string
>  : ^^^^^^

            // For debugging...
            //IO.printLine("TypeScriptLS:" + s);
        }

        //////////////////////////////////////////////////////////////////////
        // ILanguageServiceShimHost implementation
        //

        public getCompilationSettings(): string/*json for Tools.CompilationSettings*/ {
>getCompilationSettings : () => string
>                       : ^^^^^^      

            return ""; // i.e. default settings
>"" : ""
>   : ^^
        }

        public getScriptCount(): number {
>getScriptCount : () => number
>               : ^^^^^^      

            return this.scripts.length;
>this.scripts.length : number
>                    : ^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>length : number
>       : ^^^^^^
        }

        public getScriptSourceText(scriptIndex: number, start: number, end: number): string {
>getScriptSourceText : (scriptIndex: number, start: number, end: number) => string
>                    : ^           ^^      ^^     ^^      ^^   ^^      ^^^^^      
>scriptIndex : number
>            : ^^^^^^
>start : number
>      : ^^^^^^
>end : number
>    : ^^^^^^

            return this.scripts[scriptIndex].content.substring(start, end);
>this.scripts[scriptIndex].content.substring(start, end) : string
>                                                        : ^^^^^^
>this.scripts[scriptIndex].content.substring : (start: number, end?: number) => string
>                                            : ^     ^^      ^^   ^^^      ^^^^^      
>this.scripts[scriptIndex].content : string
>                                  : ^^^^^^
>this.scripts[scriptIndex] : ScriptInfo
>                          : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>scriptIndex : number
>            : ^^^^^^
>content : string
>        : ^^^^^^
>substring : (start: number, end?: number) => string
>          : ^     ^^      ^^   ^^^      ^^^^^      
>start : number
>      : ^^^^^^
>end : number
>    : ^^^^^^
        }

        public getScriptSourceLength(scriptIndex: number): number {
>getScriptSourceLength : (scriptIndex: number) => number
>                      : ^           ^^      ^^^^^      
>scriptIndex : number
>            : ^^^^^^

            return this.scripts[scriptIndex].content.length;
>this.scripts[scriptIndex].content.length : number
>                                         : ^^^^^^
>this.scripts[scriptIndex].content : string
>                                  : ^^^^^^
>this.scripts[scriptIndex] : ScriptInfo
>                          : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>scriptIndex : number
>            : ^^^^^^
>content : string
>        : ^^^^^^
>length : number
>       : ^^^^^^
        }

        public getScriptId(scriptIndex: number): string {
>getScriptId : (scriptIndex: number) => string
>            : ^           ^^      ^^^^^      
>scriptIndex : number
>            : ^^^^^^

            return this.scripts[scriptIndex].name;
>this.scripts[scriptIndex].name : string
>                               : ^^^^^^
>this.scripts[scriptIndex] : ScriptInfo
>                          : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>scriptIndex : number
>            : ^^^^^^
>name : string
>     : ^^^^^^
        }

        public getScriptIsResident(scriptIndex: number): boolean {
>getScriptIsResident : (scriptIndex: number) => boolean
>                    : ^           ^^      ^^^^^       
>scriptIndex : number
>            : ^^^^^^

            return this.scripts[scriptIndex].isResident;
>this.scripts[scriptIndex].isResident : boolean
>                                     : ^^^^^^^
>this.scripts[scriptIndex] : ScriptInfo
>                          : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>scriptIndex : number
>            : ^^^^^^
>isResident : boolean
>           : ^^^^^^^
        }

        public getScriptVersion(scriptIndex: number): number {
>getScriptVersion : (scriptIndex: number) => number
>                 : ^           ^^      ^^^^^      
>scriptIndex : number
>            : ^^^^^^

            return this.scripts[scriptIndex].version;
>this.scripts[scriptIndex].version : number
>                                  : ^^^^^^
>this.scripts[scriptIndex] : ScriptInfo
>                          : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>scriptIndex : number
>            : ^^^^^^
>version : number
>        : ^^^^^^
        }

        public getScriptEditRangeSinceVersion(scriptIndex: number, scriptVersion: number): string {
>getScriptEditRangeSinceVersion : (scriptIndex: number, scriptVersion: number) => string
>                               : ^           ^^      ^^             ^^      ^^^^^      
>scriptIndex : number
>            : ^^^^^^
>scriptVersion : number
>              : ^^^^^^

            var range = this.scripts[scriptIndex].getEditRangeSinceVersion(scriptVersion);
>range : TypeScript.ScriptEditRange
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>this.scripts[scriptIndex].getEditRangeSinceVersion(scriptVersion) : TypeScript.ScriptEditRange
>                                                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>this.scripts[scriptIndex].getEditRangeSinceVersion : (version: number) => TypeScript.ScriptEditRange
>                                                   : ^       ^^      ^^^^^                          
>this.scripts[scriptIndex] : ScriptInfo
>                          : ^^^^^^^^^^
>this.scripts : ScriptInfo[]
>             : ^^^^^^^^^^^^
>this : this
>     : ^^^^
>scripts : ScriptInfo[]
>        : ^^^^^^^^^^^^
>scriptIndex : number
>            : ^^^^^^
>getEditRangeSinceVersion : (version: number) => TypeScript.ScriptEditRange
>                         : ^       ^^      ^^^^^                          
>scriptVersion : number
>              : ^^^^^^

            var result = (range.minChar + "," + range.limChar + "," + range.delta);
>result : string
>       : ^^^^^^
>(range.minChar + "," + range.limChar + "," + range.delta) : string
>                                                          : ^^^^^^
>range.minChar + "," + range.limChar + "," + range.delta : string
>                                                        : ^^^^^^
>range.minChar + "," + range.limChar + "," : string
>                                          : ^^^^^^
>range.minChar + "," + range.limChar : string
>                                    : ^^^^^^
>range.minChar + "," : string
>                    : ^^^^^^
>range.minChar : any
>              : ^^^
>range : TypeScript.ScriptEditRange
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>minChar : any
>        : ^^^
>"," : ","
>    : ^^^
>range.limChar : any
>              : ^^^
>range : TypeScript.ScriptEditRange
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>limChar : any
>        : ^^^
>"," : ","
>    : ^^^
>range.delta : any
>            : ^^^
>range : TypeScript.ScriptEditRange
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>delta : any
>      : ^^^

            return result;
>result : string
>       : ^^^^^^
        }

        /** Return a new instance of the language service shim, up-to-date wrt to typecheck.
         *  To access the non-shim (i.e. actual) language service, use the "ls.languageService" property.
         */
        public getLanguageService(): Services.ILanguageServiceShim {
>getLanguageService : () => Services.ILanguageServiceShim
>                   : ^^^^^^                             
>Services : any
>         : ^^^

            var ls = new Services.TypeScriptServicesFactory().createLanguageServiceShim(this);
>ls : any
>   : ^^^
>new Services.TypeScriptServicesFactory().createLanguageServiceShim(this) : any
>                                                                         : ^^^
>new Services.TypeScriptServicesFactory().createLanguageServiceShim : any
>                                                                   : ^^^
>new Services.TypeScriptServicesFactory() : any
>                                         : ^^^
>Services.TypeScriptServicesFactory : any
>                                   : ^^^
>Services : any
>         : ^^^
>TypeScriptServicesFactory : any
>                          : ^^^
>createLanguageServiceShim : any
>                          : ^^^
>this : this
>     : ^^^^

            ls.refresh(true);
>ls.refresh(true) : any
>                 : ^^^
>ls.refresh : any
>           : ^^^
>ls : any
>   : ^^^
>refresh : any
>        : ^^^
>true : true
>     : ^^^^

            this.ls = ls;
>this.ls = ls : any
>             : ^^^
>this.ls : Services.ILanguageServiceShim
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>ls : Services.ILanguageServiceShim
>   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>ls : any
>   : ^^^

            return ls;
>ls : any
>   : ^^^
        }

        /** Parse file given its source text */
        public parseSourceText(fileName: string, sourceText: TypeScript.ISourceText): TypeScript.Script {
>parseSourceText : (fileName: string, sourceText: TypeScript.ISourceText) => TypeScript.Script
>                : ^        ^^      ^^          ^^                      ^^^^^                 
>fileName : string
>         : ^^^^^^
>sourceText : TypeScript.ISourceText
>           : ^^^^^^^^^^^^^^^^^^^^^^
>TypeScript : any
>           : ^^^
>TypeScript : any
>           : ^^^

            var parser = new TypeScript.Parser();
>parser : any
>       : ^^^
>new TypeScript.Parser() : any
>                        : ^^^
>TypeScript.Parser : any
>                  : ^^^
>TypeScript : any
>           : ^^^
>Parser : any
>       : ^^^

            parser.setErrorRecovery(null);
>parser.setErrorRecovery(null) : any
>                              : ^^^
>parser.setErrorRecovery : any
>                        : ^^^
>parser : any
>       : ^^^
>setErrorRecovery : any
>                 : ^^^

            parser.errorCallback = (a, b, c, d) => { };
>parser.errorCallback = (a, b, c, d) => { } : (a: any, b: any, c: any, d: any) => void
>                                           : ^ ^^^^^^^ ^^^^^^^ ^^^^^^^ ^^^^^^^^^^^^^^
>parser.errorCallback : any
>                     : ^^^
>parser : any
>       : ^^^
>errorCallback : any
>              : ^^^
>(a, b, c, d) => { } : (a: any, b: any, c: any, d: any) => void
>                    : ^ ^^^^^^^ ^^^^^^^ ^^^^^^^ ^^^^^^^^^^^^^^
>a : any
>  : ^^^
>b : any
>  : ^^^
>c : any
>  : ^^^
>d : any
>  : ^^^

            var script = parser.parse(sourceText, fileName, 0);
>script : any
>       : ^^^
>parser.parse(sourceText, fileName, 0) : any
>                                      : ^^^
>parser.parse : any
>             : ^^^
>parser : any
>       : ^^^
>parse : any
>      : ^^^
>sourceText : TypeScript.ISourceText
>           : ^^^^^^^^^^^^^^^^^^^^^^
>fileName : string
>         : ^^^^^^
>0 : 0
>  : ^

            return script;
>script : any
>       : ^^^
        }

        /** Parse a file on disk given its filename */
        public parseFile(fileName: string) {
>parseFile : (fileName: string) => TypeScript.Script
>          : ^        ^^      ^^^^^^^^^^^^^^^^^^^^^^
>fileName : string
>         : ^^^^^^

            var sourceText = new TypeScript.StringSourceText(IO.readFile(fileName))
>sourceText : any
>           : ^^^
>new TypeScript.StringSourceText(IO.readFile(fileName)) : any
>                                                       : ^^^
>TypeScript.StringSourceText : any
>                            : ^^^
>TypeScript : any
>           : ^^^
>StringSourceText : any
>                 : ^^^
>IO.readFile(fileName) : any
>                      : ^^^
>IO.readFile : any
>            : ^^^
>IO : IIO
>   : ^^^
>readFile : any
>         : ^^^
>fileName : string
>         : ^^^^^^

            return this.parseSourceText(fileName, sourceText);
>this.parseSourceText(fileName, sourceText) : TypeScript.Script
>                                           : ^^^^^^^^^^^^^^^^^
>this.parseSourceText : (fileName: string, sourceText: TypeScript.ISourceText) => TypeScript.Script
>                     : ^        ^^      ^^          ^^                      ^^^^^                 
>this : this
>     : ^^^^
>parseSourceText : (fileName: string, sourceText: TypeScript.ISourceText) => TypeScript.Script
>                : ^        ^^      ^^          ^^                      ^^^^^                 
>fileName : string
>         : ^^^^^^
>sourceText : any
>           : ^^^
        }
        
        /**
         * @param line 1 based index
         * @param col 1 based index
        */
        public lineColToPosition(fileName: string, line: number, col: number): number {
>lineColToPosition : (fileName: string, line: number, col: number) => number
>                  : ^        ^^      ^^    ^^      ^^   ^^      ^^^^^      
>fileName : string
>         : ^^^^^^
>line : number
>     : ^^^^^^
>col : number
>    : ^^^^^^

            var script = this.ls.languageService.getScriptAST(fileName);
>script : any
>       : ^^^
>this.ls.languageService.getScriptAST(fileName) : any
>                                               : ^^^
>this.ls.languageService.getScriptAST : any
>                                     : ^^^
>this.ls.languageService : any
>                        : ^^^
>this.ls : Services.ILanguageServiceShim
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>ls : Services.ILanguageServiceShim
>   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>languageService : any
>                : ^^^
>getScriptAST : any
>             : ^^^
>fileName : string
>         : ^^^^^^

            assert.notNull(script);
>assert.notNull(script) : any
>                       : ^^^
>assert.notNull : any
>               : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>notNull : any
>        : ^^^
>script : any
>       : ^^^

            assert.is(line >= 1);
>assert.is(line >= 1) : any
>                     : ^^^
>assert.is : any
>          : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>is : any
>   : ^^^
>line >= 1 : boolean
>          : ^^^^^^^
>line : number
>     : ^^^^^^
>1 : 1
>  : ^

            assert.is(col >= 1);
>assert.is(col >= 1) : any
>                    : ^^^
>assert.is : any
>          : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>is : any
>   : ^^^
>col >= 1 : boolean
>         : ^^^^^^^
>col : number
>    : ^^^^^^
>1 : 1
>  : ^

            assert.is(line <= script.locationInfo.lineMap.length);
>assert.is(line <= script.locationInfo.lineMap.length) : any
>                                                      : ^^^
>assert.is : any
>          : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>is : any
>   : ^^^
>line <= script.locationInfo.lineMap.length : boolean
>                                           : ^^^^^^^
>line : number
>     : ^^^^^^
>script.locationInfo.lineMap.length : any
>                                   : ^^^
>script.locationInfo.lineMap : any
>                            : ^^^
>script.locationInfo : any
>                    : ^^^
>script : any
>       : ^^^
>locationInfo : any
>             : ^^^
>lineMap : any
>        : ^^^
>length : any
>       : ^^^

            return TypeScript.getPositionFromZeroBasedLineColumn(script, line - 1, col - 1);
>TypeScript.getPositionFromZeroBasedLineColumn(script, line - 1, col - 1) : any
>                                                                         : ^^^
>TypeScript.getPositionFromZeroBasedLineColumn : any
>                                              : ^^^
>TypeScript : any
>           : ^^^
>getPositionFromZeroBasedLineColumn : any
>                                   : ^^^
>script : any
>       : ^^^
>line - 1 : number
>         : ^^^^^^
>line : number
>     : ^^^^^^
>1 : 1
>  : ^
>col - 1 : number
>        : ^^^^^^
>col : number
>    : ^^^^^^
>1 : 1
>  : ^
        }

        /**
         * @param line 0 based index
         * @param col 0 based index
        */
        public positionToZeroBasedLineCol(fileName: string, position: number): TypeScript.ILineCol {
>positionToZeroBasedLineCol : (fileName: string, position: number) => TypeScript.ILineCol
>                           : ^        ^^      ^^        ^^      ^^^^^                   
>fileName : string
>         : ^^^^^^
>position : number
>         : ^^^^^^
>TypeScript : any
>           : ^^^

            var script = this.ls.languageService.getScriptAST(fileName);
>script : any
>       : ^^^
>this.ls.languageService.getScriptAST(fileName) : any
>                                               : ^^^
>this.ls.languageService.getScriptAST : any
>                                     : ^^^
>this.ls.languageService : any
>                        : ^^^
>this.ls : Services.ILanguageServiceShim
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>this : this
>     : ^^^^
>ls : Services.ILanguageServiceShim
>   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>languageService : any
>                : ^^^
>getScriptAST : any
>             : ^^^
>fileName : string
>         : ^^^^^^

            assert.notNull(script);
>assert.notNull(script) : any
>                       : ^^^
>assert.notNull : any
>               : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>notNull : any
>        : ^^^
>script : any
>       : ^^^

            var result = TypeScript.getZeroBasedLineColumnFromPosition(script, position);
>result : any
>       : ^^^
>TypeScript.getZeroBasedLineColumnFromPosition(script, position) : any
>                                                                : ^^^
>TypeScript.getZeroBasedLineColumnFromPosition : any
>                                              : ^^^
>TypeScript : any
>           : ^^^
>getZeroBasedLineColumnFromPosition : any
>                                   : ^^^
>script : any
>       : ^^^
>position : number
>         : ^^^^^^

            assert.is(result.line >= 0);
>assert.is(result.line >= 0) : any
>                            : ^^^
>assert.is : any
>          : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>is : any
>   : ^^^
>result.line >= 0 : boolean
>                 : ^^^^^^^
>result.line : any
>            : ^^^
>result : any
>       : ^^^
>line : any
>     : ^^^
>0 : 0
>  : ^

            assert.is(result.col >= 0);
>assert.is(result.col >= 0) : any
>                           : ^^^
>assert.is : any
>          : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>is : any
>   : ^^^
>result.col >= 0 : boolean
>                : ^^^^^^^
>result.col : any
>           : ^^^
>result : any
>       : ^^^
>col : any
>    : ^^^
>0 : 0
>  : ^

            return result;
>result : any
>       : ^^^
        }

        /** Verify that applying edits to sourceFileName result in the content of the file baselineFileName */
        public checkEdits(sourceFileName: string, baselineFileName: string, edits: Services.TextEdit[]) {
>checkEdits : (sourceFileName: string, baselineFileName: string, edits: Services.TextEdit[]) => void
>           : ^              ^^      ^^                ^^      ^^     ^^                   ^^^^^^^^^
>sourceFileName : string
>               : ^^^^^^
>baselineFileName : string
>                 : ^^^^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>Services : any
>         : ^^^

            var script = readFile(sourceFileName);
>script : any
>       : ^^^
>readFile(sourceFileName) : any
>                         : ^^^
>readFile : (path: string) => any
>         : ^    ^^      ^^^^^^^^
>sourceFileName : string
>               : ^^^^^^

            var formattedScript = this.applyEdits(script, edits);
>formattedScript : string
>                : ^^^^^^
>this.applyEdits(script, edits) : string
>                               : ^^^^^^
>this.applyEdits : (content: string, edits: Services.TextEdit[]) => string
>                : ^       ^^      ^^     ^^                   ^^^^^      
>this : this
>     : ^^^^
>applyEdits : (content: string, edits: Services.TextEdit[]) => string
>           : ^       ^^      ^^     ^^                   ^^^^^      
>script : any
>       : ^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^

            var baseline = readFile(baselineFileName);
>baseline : any
>         : ^^^
>readFile(baselineFileName) : any
>                           : ^^^
>readFile : (path: string) => any
>         : ^    ^^      ^^^^^^^^
>baselineFileName : string
>                 : ^^^^^^

            assert.noDiff(formattedScript, baseline);
>assert.noDiff(formattedScript, baseline) : any
>                                         : ^^^
>assert.noDiff : any
>              : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>noDiff : any
>       : ^^^
>formattedScript : string
>                : ^^^^^^
>baseline : any
>         : ^^^

            assert.equal(formattedScript, baseline);
>assert.equal(formattedScript, baseline) : any
>                                        : ^^^
>assert.equal : any
>             : ^^^
>assert : Harness.Assert
>       : ^^^^^^^^^^^^^^
>equal : any
>      : ^^^
>formattedScript : string
>                : ^^^^^^
>baseline : any
>         : ^^^
        }


        /** Apply an array of text edits to a string, and return the resulting string. */
        public applyEdits(content: string, edits: Services.TextEdit[]): string {
>applyEdits : (content: string, edits: Services.TextEdit[]) => string
>           : ^       ^^      ^^     ^^                   ^^^^^      
>content : string
>        : ^^^^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>Services : any
>         : ^^^

            var result = content;
>result : string
>       : ^^^^^^
>content : string
>        : ^^^^^^

            edits = this.normalizeEdits(edits);
>edits = this.normalizeEdits(edits) : Services.TextEdit[]
>                                   : ^^^^^^^^^^^^^^^^^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>this.normalizeEdits(edits) : Services.TextEdit[]
>                           : ^^^^^^^^^^^^^^^^^^^
>this.normalizeEdits : (edits: Services.TextEdit[]) => Services.TextEdit[]
>                    : ^     ^^                   ^^^^^                   
>this : this
>     : ^^^^
>normalizeEdits : (edits: Services.TextEdit[]) => Services.TextEdit[]
>               : ^     ^^                   ^^^^^                   
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^

            for (var i = edits.length - 1; i >= 0; i--) {
>i : number
>  : ^^^^^^
>edits.length - 1 : number
>                 : ^^^^^^
>edits.length : number
>             : ^^^^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^
>i >= 0 : boolean
>       : ^^^^^^^
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i-- : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                var edit = edits[i];
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>edits[i] : Services.TextEdit
>         : ^^^^^^^^^^^^^^^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>i : number
>  : ^^^^^^

                var prefix = result.substring(0, edit.minChar);
>prefix : string
>       : ^^^^^^
>result.substring(0, edit.minChar) : string
>                                  : ^^^^^^
>result.substring : (start: number, end?: number) => string
>                 : ^     ^^      ^^   ^^^      ^^^^^      
>result : string
>       : ^^^^^^
>substring : (start: number, end?: number) => string
>          : ^     ^^      ^^   ^^^      ^^^^^      
>0 : 0
>  : ^
>edit.minChar : any
>             : ^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>minChar : any
>        : ^^^

                var middle = edit.text;
>middle : any
>       : ^^^
>edit.text : any
>          : ^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>text : any
>     : ^^^

                var suffix = result.substring(edit.limChar);
>suffix : string
>       : ^^^^^^
>result.substring(edit.limChar) : string
>                               : ^^^^^^
>result.substring : (start: number, end?: number) => string
>                 : ^     ^^      ^^   ^^^      ^^^^^      
>result : string
>       : ^^^^^^
>substring : (start: number, end?: number) => string
>          : ^     ^^      ^^   ^^^      ^^^^^      
>edit.limChar : any
>             : ^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>limChar : any
>        : ^^^

                result = prefix + middle + suffix;
>result = prefix + middle + suffix : string
>                                  : ^^^^^^
>result : string
>       : ^^^^^^
>prefix + middle + suffix : string
>                         : ^^^^^^
>prefix + middle : string
>                : ^^^^^^
>prefix : string
>       : ^^^^^^
>middle : any
>       : ^^^
>suffix : string
>       : ^^^^^^
            }
            return result;
>result : string
>       : ^^^^^^
        }

        /** Normalize an array of edits by removing overlapping entries and sorting entries on the minChar position. */
        private normalizeEdits(edits: Services.TextEdit[]): Services.TextEdit[] {
>normalizeEdits : (edits: Services.TextEdit[]) => Services.TextEdit[]
>               : ^     ^^                   ^^^^^                   
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>Services : any
>         : ^^^
>Services : any
>         : ^^^

            var result: Services.TextEdit[] = [];
>result : Services.TextEdit[]
>       : ^^^^^^^^^^^^^^^^^^^
>Services : any
>         : ^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

            function mapEdits(edits: Services.TextEdit[]): { edit: Services.TextEdit; index: number; }[] {
>mapEdits : (edits: Services.TextEdit[]) => { edit: Services.TextEdit; index: number; }[]
>         : ^     ^^                   ^^^^^                                             
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>Services : any
>         : ^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>Services : any
>         : ^^^
>index : number
>      : ^^^^^^

                var result = [];
>result : any[]
>       : ^^^^^
>[] : undefined[]
>   : ^^^^^^^^^^^

                for (var i = 0; i < edits.length; i++) {
>i : number
>  : ^^^^^^
>0 : 0
>  : ^
>i < edits.length : boolean
>                 : ^^^^^^^
>i : number
>  : ^^^^^^
>edits.length : number
>             : ^^^^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>length : number
>       : ^^^^^^
>i++ : number
>    : ^^^^^^
>i : number
>  : ^^^^^^

                    result.push({ edit: edits[i], index: i });
>result.push({ edit: edits[i], index: i }) : number
>                                          : ^^^^^^
>result.push : (...items: any[]) => number
>            : ^^^^     ^^^^^^^^^^^^      
>result : any[]
>       : ^^^^^
>push : (...items: any[]) => number
>     : ^^^^     ^^^^^^^^^^^^      
>{ edit: edits[i], index: i } : { edit: Services.TextEdit; index: number; }
>                             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>edits[i] : Services.TextEdit
>         : ^^^^^^^^^^^^^^^^^
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>i : number
>  : ^^^^^^
>index : number
>      : ^^^^^^
>i : number
>  : ^^^^^^
                }
                return result;
>result : any[]
>       : ^^^^^
            }

            var temp = mapEdits(edits).sort(function (a, b) {
>temp : { edit: Services.TextEdit; index: number; }[]
>     : ^^^^^^^^                 ^^^^^^^^^      ^^^^^
>mapEdits(edits).sort(function (a, b) {                var result = a.edit.minChar - b.edit.minChar;                if (result == 0)                    result = a.index - b.index;                return result;            }) : { edit: Services.TextEdit; index: number; }[]
>                                                                                                                                                                                                                               : ^^^^^^^^                 ^^^^^^^^^      ^^^^^
>mapEdits(edits).sort : (compareFn?: (a: { edit: Services.TextEdit; index: number; }, b: { edit: Services.TextEdit; index: number; }) => number) => { edit: Services.TextEdit; index: number; }[]
>                     : ^         ^^^^ ^^^^^^^^^^                 ^^^^^^^^^      ^^^^^ ^^^^^^^^^^                 ^^^^^^^^^      ^^^^^^^^      ^^^^^^^^^^^^^                 ^^^^^^^^^      ^^^^^
>mapEdits(edits) : { edit: Services.TextEdit; index: number; }[]
>                : ^^^^^^^^                 ^^^^^^^^^      ^^^^^
>mapEdits : (edits: Services.TextEdit[]) => { edit: Services.TextEdit; index: number; }[]
>         : ^     ^^                   ^^^^^                                             
>edits : Services.TextEdit[]
>      : ^^^^^^^^^^^^^^^^^^^
>sort : (compareFn?: (a: { edit: Services.TextEdit; index: number; }, b: { edit: Services.TextEdit; index: number; }) => number) => { edit: Services.TextEdit; index: number; }[]
>     : ^         ^^^^ ^^^^^^^^^^                 ^^^^^^^^^      ^^^^^ ^^^^^^^^^^                 ^^^^^^^^^      ^^^^^^^^      ^^^^^^^^^^^^^                 ^^^^^^^^^      ^^^^^
>function (a, b) {                var result = a.edit.minChar - b.edit.minChar;                if (result == 0)                    result = a.index - b.index;                return result;            } : (a: { edit: Services.TextEdit; index: number; }, b: { edit: Services.TextEdit; index: number; }) => number
>                                                                                                                                                                                                         : ^ ^^^^^^^^^^                 ^^^^^^^^^      ^^^^^ ^^^^^^^^^^                 ^^^^^^^^^      ^^^^^^^^^^^^^^
>a : { edit: Services.TextEdit; index: number; }
>  : ^^^^^^^^                 ^^^^^^^^^      ^^^
>b : { edit: Services.TextEdit; index: number; }
>  : ^^^^^^^^                 ^^^^^^^^^      ^^^

                var result = a.edit.minChar - b.edit.minChar;
>result : number
>       : ^^^^^^
>a.edit.minChar - b.edit.minChar : number
>                                : ^^^^^^
>a.edit.minChar : any
>               : ^^^
>a.edit : Services.TextEdit
>       : ^^^^^^^^^^^^^^^^^
>a : { edit: Services.TextEdit; index: number; }
>  : ^^^^^^^^                 ^^^^^^^^^      ^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>minChar : any
>        : ^^^
>b.edit.minChar : any
>               : ^^^
>b.edit : Services.TextEdit
>       : ^^^^^^^^^^^^^^^^^
>b : { edit: Services.TextEdit; index: number; }
>  : ^^^^^^^^                 ^^^^^^^^^      ^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^
>minChar : any
>        : ^^^

                if (result == 0)
>result == 0 : boolean
>            : ^^^^^^^
>result : number
>       : ^^^^^^
>0 : 0
>  : ^

                    result = a.index - b.index;
>result = a.index - b.index : number
>                           : ^^^^^^
>result : number
>       : ^^^^^^
>a.index - b.index : number
>                  : ^^^^^^
>a.index : number
>        : ^^^^^^
>a : { edit: Services.TextEdit; index: number; }
>  : ^^^^^^^^                 ^^^^^^^^^      ^^^
>index : number
>      : ^^^^^^
>b.index : number
>        : ^^^^^^
>b : { edit: Services.TextEdit; index: number; }
>  : ^^^^^^^^                 ^^^^^^^^^      ^^^
>index : number
>      : ^^^^^^

                return result;
>result : number
>       : ^^^^^^

            });

            var current = 0;
>current : number
>        : ^^^^^^
>0 : 0
>  : ^

            var next = 1;
>next : number
>     : ^^^^^^
>1 : 1
>  : ^

            while (current < temp.length) {
>current < temp.length : boolean
>                      : ^^^^^^^
>current : number
>        : ^^^^^^
>temp.length : number
>            : ^^^^^^
>temp : { edit: Services.TextEdit; index: number; }[]
>     : ^^^^^^^^                 ^^^^^^^^^      ^^^^^
>length : number
>       : ^^^^^^

                var currentEdit = temp[current].edit;
>currentEdit : Services.TextEdit
>            : ^^^^^^^^^^^^^^^^^
>temp[current].edit : Services.TextEdit
>                   : ^^^^^^^^^^^^^^^^^
>temp[current] : { edit: Services.TextEdit; index: number; }
>              : ^^^^^^^^                 ^^^^^^^^^      ^^^
>temp : { edit: Services.TextEdit; index: number; }[]
>     : ^^^^^^^^                 ^^^^^^^^^      ^^^^^
>current : number
>        : ^^^^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^

                // Last edit
                if (next >= temp.length) {
>next >= temp.length : boolean
>                    : ^^^^^^^
>next : number
>     : ^^^^^^
>temp.length : number
>            : ^^^^^^
>temp : { edit: Services.TextEdit; index: number; }[]
>     : ^^^^^^^^                 ^^^^^^^^^      ^^^^^
>length : number
>       : ^^^^^^

                    result.push(currentEdit);
>result.push(currentEdit) : number
>                         : ^^^^^^
>result.push : (...items: Services.TextEdit[]) => number
>            : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^      
>result : Services.TextEdit[]
>       : ^^^^^^^^^^^^^^^^^^^
>push : (...items: Services.TextEdit[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^      
>currentEdit : Services.TextEdit
>            : ^^^^^^^^^^^^^^^^^

                    current++;
>current++ : number
>          : ^^^^^^
>current : number
>        : ^^^^^^

                    continue;
                }
                var nextEdit = temp[next].edit;
>nextEdit : Services.TextEdit
>         : ^^^^^^^^^^^^^^^^^
>temp[next].edit : Services.TextEdit
>                : ^^^^^^^^^^^^^^^^^
>temp[next] : { edit: Services.TextEdit; index: number; }
>           : ^^^^^^^^                 ^^^^^^^^^      ^^^
>temp : { edit: Services.TextEdit; index: number; }[]
>     : ^^^^^^^^                 ^^^^^^^^^      ^^^^^
>next : number
>     : ^^^^^^
>edit : Services.TextEdit
>     : ^^^^^^^^^^^^^^^^^

                var gap = nextEdit.minChar - currentEdit.limChar;
>gap : number
>    : ^^^^^^
>nextEdit.minChar - currentEdit.limChar : number
>                                       : ^^^^^^
>nextEdit.minChar : any
>                 : ^^^
>nextEdit : Services.TextEdit
>         : ^^^^^^^^^^^^^^^^^
>minChar : any
>        : ^^^
>currentEdit.limChar : any
>                    : ^^^
>currentEdit : Services.TextEdit
>            : ^^^^^^^^^^^^^^^^^
>limChar : any
>        : ^^^

                // non-overlapping edits
                if (gap >= 0) {
>gap >= 0 : boolean
>         : ^^^^^^^
>gap : number
>    : ^^^^^^
>0 : 0
>  : ^

                    result.push(currentEdit);
>result.push(currentEdit) : number
>                         : ^^^^^^
>result.push : (...items: Services.TextEdit[]) => number
>            : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^      
>result : Services.TextEdit[]
>       : ^^^^^^^^^^^^^^^^^^^
>push : (...items: Services.TextEdit[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^      
>currentEdit : Services.TextEdit
>            : ^^^^^^^^^^^^^^^^^

                    current = next;
>current = next : number
>               : ^^^^^^
>current : number
>        : ^^^^^^
>next : number
>     : ^^^^^^

                    next++;
>next++ : number
>       : ^^^^^^
>next : number
>     : ^^^^^^

                    continue;
                }

                // overlapping edits: for now, we only support ignoring an next edit 
                // entirely contained in the current edit.
                if (currentEdit.limChar >= nextEdit.limChar) {
>currentEdit.limChar >= nextEdit.limChar : boolean
>                                        : ^^^^^^^
>currentEdit.limChar : any
>                    : ^^^
>currentEdit : Services.TextEdit
>            : ^^^^^^^^^^^^^^^^^
>limChar : any
>        : ^^^
>nextEdit.limChar : any
>                 : ^^^
>nextEdit : Services.TextEdit
>         : ^^^^^^^^^^^^^^^^^
>limChar : any
>        : ^^^

                    next++;
>next++ : number
>       : ^^^^^^
>next : number
>     : ^^^^^^

                    continue;
                }
                else {
                    throw new Error("Trying to apply overlapping edits");
>new Error("Trying to apply overlapping edits") : Error
>                                               : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>"Trying to apply overlapping edits" : "Trying to apply overlapping edits"
>                                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                }
            }

            return result;
>result : Services.TextEdit[]
>       : ^^^^^^^^^^^^^^^^^^^
        }

        public getHostSettings(): string {
>getHostSettings : () => string
>                : ^^^^^^      

            return JSON.stringify({ usePullLanguageService: usePull });
>JSON.stringify({ usePullLanguageService: usePull }) : string
>                                                    : ^^^^^^
>JSON.stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (number | string)[] | null, space?: string | number): string; }
>               : ^^^     ^^   ^^        ^^^                                           ^^     ^^^               ^^^      ^^^     ^^   ^^        ^^^                          ^^     ^^^               ^^^      ^^^
>JSON : JSON
>     : ^^^^
>stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (number | string)[] | null, space?: string | number): string; }
>          : ^^^     ^^   ^^        ^^^                                           ^^     ^^^               ^^^      ^^^     ^^   ^^        ^^^                          ^^     ^^^               ^^^      ^^^
>{ usePullLanguageService: usePull } : { usePullLanguageService: boolean; }
>                                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>usePullLanguageService : boolean
>                       : ^^^^^^^
>usePull : boolean
>        : ^^^^^^^
        }
    }

    // Describe/it definitions
    export function describe(description: string, block: () => any) {
>describe : (description: string, block: () => any) => void
>         : ^           ^^      ^^     ^^         ^^^^^^^^^
>description : string
>            : ^^^^^^
>block : () => any
>      : ^^^^^^   

        var newScenario = new Scenario(description, block);
>newScenario : Scenario
>            : ^^^^^^^^
>new Scenario(description, block) : Scenario
>                                 : ^^^^^^^^
>Scenario : typeof Scenario
>         : ^^^^^^^^^^^^^^^
>description : string
>            : ^^^^^^
>block : () => any
>      : ^^^^^^   

        if (Runnable.currentStack.length === 0) {
>Runnable.currentStack.length === 0 : boolean
>                                   : ^^^^^^^
>Runnable.currentStack.length : number
>                             : ^^^^^^
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>length : number
>       : ^^^^^^
>0 : 0
>  : ^

            Runnable.currentStack.push(currentRun);
>Runnable.currentStack.push(currentRun) : number
>                                       : ^^^^^^
>Runnable.currentStack.push : (...items: Runnable[]) => number
>                           : ^^^^     ^^^^^^^^^^^^^^^^^      
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>push : (...items: Runnable[]) => number
>     : ^^^^     ^^^^^^^^^^^^^^^^^      
>currentRun : Run
>           : ^^^
        }

        Runnable.currentStack[Runnable.currentStack.length - 1].addChild(newScenario);
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild(newScenario) : void
>                                                                              : ^^^^
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild : (child: Runnable) => void
>                                                                 : ^     ^^        ^^^^^    
>Runnable.currentStack[Runnable.currentStack.length - 1] : Runnable
>                                                        : ^^^^^^^^
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>Runnable.currentStack.length - 1 : number
>                                 : ^^^^^^
>Runnable.currentStack.length : number
>                             : ^^^^^^
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^
>addChild : (child: Runnable) => void
>         : ^     ^^        ^^^^^    
>newScenario : Scenario
>            : ^^^^^^^^
    }
    export function it(description: string, block: () => void ) {
>it : (description: string, block: () => void) => void
>   : ^           ^^      ^^     ^^          ^^^^^^^^^
>description : string
>            : ^^^^^^
>block : () => void
>      : ^^^^^^    

        var testCase = new TestCase(description, block);
>testCase : TestCase
>         : ^^^^^^^^
>new TestCase(description, block) : TestCase
>                                 : ^^^^^^^^
>TestCase : typeof TestCase
>         : ^^^^^^^^^^^^^^^
>description : string
>            : ^^^^^^
>block : () => void
>      : ^^^^^^    

        Runnable.currentStack[Runnable.currentStack.length - 1].addChild(testCase);
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild(testCase) : void
>                                                                           : ^^^^
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild : (child: Runnable) => void
>                                                                 : ^     ^^        ^^^^^    
>Runnable.currentStack[Runnable.currentStack.length - 1] : Runnable
>                                                        : ^^^^^^^^
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>Runnable.currentStack.length - 1 : number
>                                 : ^^^^^^
>Runnable.currentStack.length : number
>                             : ^^^^^^
>Runnable.currentStack : Runnable[]
>                      : ^^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>currentStack : Runnable[]
>             : ^^^^^^^^^^
>length : number
>       : ^^^^^^
>1 : 1
>  : ^
>addChild : (child: Runnable) => void
>         : ^     ^^        ^^^^^    
>testCase : TestCase
>         : ^^^^^^^^
    }

    export function run() {
>run : () => void
>    : ^^^^^^^^^^

        if (typeof process !== "undefined") {
>typeof process !== "undefined" : boolean
>                               : ^^^^^^^
>typeof process : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>process : typeof process
>        : ^^^^^^^^^^^^^^
>"undefined" : "undefined"
>            : ^^^^^^^^^^^

            process.on('uncaughtException', Runnable.handleError);
>process.on('uncaughtException', Runnable.handleError) : any
>                                                      : ^^^
>process.on : (event: string, listener: Function) => any
>           : ^     ^^      ^^        ^^        ^^^^^^^^
>process : typeof process
>        : ^^^^^^^^^^^^^^
>on : (event: string, listener: Function) => any
>   : ^     ^^      ^^        ^^        ^^^^^^^^
>'uncaughtException' : "uncaughtException"
>                    : ^^^^^^^^^^^^^^^^^^^
>Runnable.handleError : (e: Error) => void
>                     : ^ ^^     ^^^^^^^^^
>Runnable : typeof Runnable
>         : ^^^^^^^^^^^^^^^
>handleError : (e: Error) => void
>            : ^ ^^     ^^^^^^^^^
        }

        Baseline.reset();
>Baseline.reset() : void
>                 : ^^^^
>Baseline.reset : () => void
>               : ^^^^^^^^^^
>Baseline : typeof Baseline
>         : ^^^^^^^^^^^^^^^
>reset : () => void
>      : ^^^^^^^^^^

        currentRun.run();
>currentRun.run() : void
>                 : ^^^^
>currentRun.run : () => void
>               : ^^^^^^^^^^
>currentRun : Run
>           : ^^^
>run : () => void
>    : ^^^^^^^^^^
    }

    /** Runs TypeScript or Javascript code. */
    export module Runner {
>Runner : typeof Runner
>       : ^^^^^^^^^^^^^

        export function runCollateral(path: string, callback: (error: Error, result: any) => void ) {
>runCollateral : (path: string, callback: (error: Error, result: any) => void) => void
>              : ^    ^^      ^^        ^^                                   ^^^^^^^^^
>path : string
>     : ^^^^^^
>callback : (error: Error, result: any) => void
>         : ^     ^^     ^^      ^^   ^^^^^    
>error : Error
>      : ^^^^^
>result : any
>       : ^^^

            path = switchToForwardSlashes(path);
>path = switchToForwardSlashes(path) : string
>                                    : ^^^^^^
>path : string
>     : ^^^^^^
>switchToForwardSlashes(path) : string
>                             : ^^^^^^
>switchToForwardSlashes : (path: string) => string
>                       : ^    ^^      ^^^^^^^^^^^
>path : string
>     : ^^^^^^

            runString(readFile(path), path.match(/[^\/]*$/)[0], callback);
>runString(readFile(path), path.match(/[^\/]*$/)[0], callback) : void
>                                                              : ^^^^
>runString : (code: string, unitName: string, callback: (error: Error, result: any) => void) => void
>          : ^    ^^      ^^        ^^      ^^        ^^                                   ^^^^^^^^^
>readFile(path) : any
>               : ^^^
>readFile : (path: string) => any
>         : ^    ^^      ^^^^^^^^
>path : string
>     : ^^^^^^
>path.match(/[^\/]*$/)[0] : string
>                         : ^^^^^^
>path.match(/[^\/]*$/) : RegExpMatchArray
>                      : ^^^^^^^^^^^^^^^^
>path.match : (regexp: string | RegExp) => RegExpMatchArray | null
>           : ^      ^^               ^^^^^                       
>path : string
>     : ^^^^^^
>match : (regexp: string | RegExp) => RegExpMatchArray | null
>      : ^      ^^               ^^^^^                       
>/[^\/]*$/ : RegExp
>          : ^^^^^^
>0 : 0
>  : ^
>callback : (error: Error, result: any) => void
>         : ^     ^^     ^^      ^^   ^^^^^    
        }

        export function runJSString(code: string, callback: (error: Error, result: any) => void ) {
>runJSString : (code: string, callback: (error: Error, result: any) => void) => void
>            : ^    ^^      ^^        ^^                                   ^^^^^^^^^
>code : string
>     : ^^^^^^
>callback : (error: Error, result: any) => void
>         : ^     ^^     ^^      ^^   ^^^^^    
>error : Error
>      : ^^^^^
>result : any
>       : ^^^

            // List of names that get overriden by various test code we eval
            var dangerNames: any = ['Array'];
>dangerNames : any
>            : ^^^
>['Array'] : string[]
>          : ^^^^^^^^
>'Array' : "Array"
>        : ^^^^^^^

            var globalBackup: any = {};
>globalBackup : any
>             : ^^^
>{} : {}
>   : ^^

            var n: string = null;
>n : string
>  : ^^^^^^

            for (n in dangerNames) {
>n : string
>  : ^^^^^^
>dangerNames : any
>            : ^^^

                globalBackup[dangerNames[n]] = global[dangerNames[n]];
>globalBackup[dangerNames[n]] = global[dangerNames[n]] : any
>                                                      : ^^^
>globalBackup[dangerNames[n]] : any
>                             : ^^^
>globalBackup : any
>             : ^^^
>dangerNames[n] : any
>               : ^^^
>dangerNames : any
>            : ^^^
>n : string
>  : ^^^^^^
>global[dangerNames[n]] : any
>                       : ^^^
>global : any
>       : ^^^
>dangerNames[n] : any
>               : ^^^
>dangerNames : any
>            : ^^^
>n : string
>  : ^^^^^^
            }

            try {
                var res = eval(code);
>res : any
>    : ^^^
>eval(code) : any
>           : ^^^
>eval : (x: string) => any
>     : ^ ^^      ^^^^^   
>code : string
>     : ^^^^^^

                for (n in dangerNames) {
>n : string
>  : ^^^^^^
>dangerNames : any
>            : ^^^

                    global[dangerNames[n]] = globalBackup[dangerNames[n]];
>global[dangerNames[n]] = globalBackup[dangerNames[n]] : any
>                                                      : ^^^
>global[dangerNames[n]] : any
>                       : ^^^
>global : any
>       : ^^^
>dangerNames[n] : any
>               : ^^^
>dangerNames : any
>            : ^^^
>n : string
>  : ^^^^^^
>globalBackup[dangerNames[n]] : any
>                             : ^^^
>globalBackup : any
>             : ^^^
>dangerNames[n] : any
>               : ^^^
>dangerNames : any
>            : ^^^
>n : string
>  : ^^^^^^
                }

                callback(null, res);
>callback(null, res) : void
>                    : ^^^^
>callback : (error: Error, result: any) => void
>         : ^     ^^     ^^      ^^   ^^^^^    
>res : any
>    : ^^^

            } catch (e) {
>e : any
>  : ^^^

                for (n in dangerNames) {
>n : string
>  : ^^^^^^
>dangerNames : any
>            : ^^^

                    global[dangerNames[n]] = globalBackup[dangerNames[n]];
>global[dangerNames[n]] = globalBackup[dangerNames[n]] : any
>                                                      : ^^^
>global[dangerNames[n]] : any
>                       : ^^^
>global : any
>       : ^^^
>dangerNames[n] : any
>               : ^^^
>dangerNames : any
>            : ^^^
>n : string
>  : ^^^^^^
>globalBackup[dangerNames[n]] : any
>                             : ^^^
>globalBackup : any
>             : ^^^
>dangerNames[n] : any
>               : ^^^
>dangerNames : any
>            : ^^^
>n : string
>  : ^^^^^^
                }

                callback(e, null);
>callback(e, null) : void
>                  : ^^^^
>callback : (error: Error, result: any) => void
>         : ^     ^^     ^^      ^^   ^^^^^    
>e : any
>  : ^^^
            }
        }

        export function runString(code: string, unitName: string, callback: (error: Error, result: any) => void ) {
>runString : (code: string, unitName: string, callback: (error: Error, result: any) => void) => void
>          : ^    ^^      ^^        ^^      ^^        ^^                                   ^^^^^^^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>callback : (error: Error, result: any) => void
>         : ^     ^^     ^^      ^^   ^^^^^    
>error : Error
>      : ^^^^^
>result : any
>       : ^^^

            Compiler.compileString(code, unitName, function (res) {
>Compiler.compileString(code, unitName, function (res) {                runJSString(res.code, callback);            }) : void
>                                                                                                                      : ^^^^
>Compiler.compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: Compiler.CompilationContext, references?: TypeScript.IFileReference[]) => void
>                       : ^    ^^      ^^        ^^      ^^        ^^                                      ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^          ^^^                           ^^^^^^^^^
>Compiler : typeof Compiler
>         : ^^^^^^^^^^^^^^^
>compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: Compiler.CompilationContext, references?: TypeScript.IFileReference[]) => void
>              : ^    ^^      ^^        ^^      ^^        ^^                                      ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^          ^^^                           ^^^^^^^^^
>code : string
>     : ^^^^^^
>unitName : string
>         : ^^^^^^
>function (res) {                runJSString(res.code, callback);            } : (res: Compiler.CompilerResult) => void
>                                                                              : ^   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>res : Compiler.CompilerResult
>    : ^^^^^^^^^^^^^^^^^^^^^^^

                runJSString(res.code, callback);
>runJSString(res.code, callback) : void
>                                : ^^^^
>runJSString : (code: string, callback: (error: Error, result: any) => void) => void
>            : ^    ^^      ^^        ^^                                   ^^^^^^^^^
>res.code : string
>         : ^^^^^^
>res : Compiler.CompilerResult
>    : ^^^^^^^^^^^^^^^^^^^^^^^
>code : string
>     : ^^^^^^
>callback : (error: Error, result: any) => void
>         : ^     ^^     ^^      ^^   ^^^^^    

            });
        }
    }

    /** Support class for baseline files */
    export module Baseline {
>Baseline : typeof Baseline
>         : ^^^^^^^^^^^^^^^

        var reportFilename = 'baseline-report.html';
>reportFilename : string
>               : ^^^^^^
>'baseline-report.html' : "baseline-report.html"
>                       : ^^^^^^^^^^^^^^^^^^^^^^

        var firstRun = true;
>firstRun : boolean
>         : ^^^^^^^
>true : true
>     : ^^^^

        var htmlTrailer = '</body></html>';
>htmlTrailer : string
>            : ^^^^^^
>'</body></html>' : "</body></html>"
>                 : ^^^^^^^^^^^^^^^^

        var htmlLeader = '<html><head><title>Baseline Report</title>';
>htmlLeader : string
>           : ^^^^^^
>'<html><head><title>Baseline Report</title>' : "<html><head><title>Baseline Report</title>"
>                                             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += ("<style>");
>htmlLeader += ("<style>") : string
>                          : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>("<style>") : "<style>"
>            : ^^^^^^^^^
>"<style>" : "<style>"
>          : ^^^^^^^^^

        htmlLeader += '\r\n' + (".code { font: 9pt 'Courier New'; }");
>htmlLeader += '\r\n' + (".code { font: 9pt 'Courier New'; }") : string
>                                                              : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + (".code { font: 9pt 'Courier New'; }") : string
>                                                : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>(".code { font: 9pt 'Courier New'; }") : ".code { font: 9pt 'Courier New'; }"
>                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>".code { font: 9pt 'Courier New'; }" : ".code { font: 9pt 'Courier New'; }"
>                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + (".old { background-color: #EE1111; }");
>htmlLeader += '\r\n' + (".old { background-color: #EE1111; }") : string
>                                                               : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + (".old { background-color: #EE1111; }") : string
>                                                 : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>(".old { background-color: #EE1111; }") : ".old { background-color: #EE1111; }"
>                                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>".old { background-color: #EE1111; }" : ".old { background-color: #EE1111; }"
>                                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + (".new { background-color: #FFFF11; }");
>htmlLeader += '\r\n' + (".new { background-color: #FFFF11; }") : string
>                                                               : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + (".new { background-color: #FFFF11; }") : string
>                                                 : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>(".new { background-color: #FFFF11; }") : ".new { background-color: #FFFF11; }"
>                                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>".new { background-color: #FFFF11; }" : ".new { background-color: #FFFF11; }"
>                                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + (".from { background-color: #EE1111; color: #1111EE; }");
>htmlLeader += '\r\n' + (".from { background-color: #EE1111; color: #1111EE; }") : string
>                                                                                : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + (".from { background-color: #EE1111; color: #1111EE; }") : string
>                                                                  : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>(".from { background-color: #EE1111; color: #1111EE; }") : ".from { background-color: #EE1111; color: #1111EE; }"
>                                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>".from { background-color: #EE1111; color: #1111EE; }" : ".from { background-color: #EE1111; color: #1111EE; }"
>                                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }");
>htmlLeader += '\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }") : string
>                                                                              : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }") : string
>                                                                : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>(".to { background-color: #EEEE11; color: #1111EE; }") : ".to { background-color: #EEEE11; color: #1111EE; }"
>                                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>".to { background-color: #EEEE11; color: #1111EE; }" : ".to { background-color: #EEEE11; color: #1111EE; }"
>                                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + ("h2 { margin-bottom: 0px; }");
>htmlLeader += '\r\n' + ("h2 { margin-bottom: 0px; }") : string
>                                                      : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + ("h2 { margin-bottom: 0px; }") : string
>                                        : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>("h2 { margin-bottom: 0px; }") : "h2 { margin-bottom: 0px; }"
>                               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>"h2 { margin-bottom: 0px; }" : "h2 { margin-bottom: 0px; }"
>                             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + ("h2 { padding-bottom: 0px; }");
>htmlLeader += '\r\n' + ("h2 { padding-bottom: 0px; }") : string
>                                                       : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + ("h2 { padding-bottom: 0px; }") : string
>                                         : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>("h2 { padding-bottom: 0px; }") : "h2 { padding-bottom: 0px; }"
>                                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>"h2 { padding-bottom: 0px; }" : "h2 { padding-bottom: 0px; }"
>                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + ("h4 { font-weight: normal; }");
>htmlLeader += '\r\n' + ("h4 { font-weight: normal; }") : string
>                                                       : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + ("h4 { font-weight: normal; }") : string
>                                         : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>("h4 { font-weight: normal; }") : "h4 { font-weight: normal; }"
>                                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>"h4 { font-weight: normal; }" : "h4 { font-weight: normal; }"
>                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        htmlLeader += '\r\n' + ("</style>");
>htmlLeader += '\r\n' + ("</style>") : string
>                                    : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
>'\r\n' + ("</style>") : string
>                      : ^^^^^^
>'\r\n' : "\r\n"
>       : ^^^^^^
>("</style>") : "</style>"
>             : ^^^^^^^^^^
>"</style>" : "</style>"
>           : ^^^^^^^^^^

        export interface BaselineOptions {
            LineEndingSensitive?: boolean;
>LineEndingSensitive : boolean
>                    : ^^^^^^^
        }

        function localPath(filename: string) {
>localPath : (filename: string) => string
>          : ^        ^^      ^^^^^^^^^^^
>filename : string
>         : ^^^^^^

            if (global.runners[0].testType === 'prototyping') {
>global.runners[0].testType === 'prototyping' : boolean
>                                             : ^^^^^^^
>global.runners[0].testType : any
>                           : ^^^
>global.runners[0] : any
>                  : ^^^
>global.runners : any
>               : ^^^
>global : any
>       : ^^^
>runners : any
>        : ^^^
>0 : 0
>  : ^
>testType : any
>         : ^^^
>'prototyping' : "prototyping"
>              : ^^^^^^^^^^^^^

                return Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' + filename : string
>                                                                            : ^^^^^^
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' : string
>                                                                 : ^^^^^^
>Harness.userSpecifiedroot : string
>                          : ^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>userSpecifiedroot : string
>                  : ^^^^^^
>'tests/baselines/prototyping/local/' : "tests/baselines/prototyping/local/"
>                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>filename : string
>         : ^^^^^^
            }
            else {
                return Harness.userSpecifiedroot + 'tests/baselines/local/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/local/' + filename : string
>                                                                : ^^^^^^
>Harness.userSpecifiedroot + 'tests/baselines/local/' : string
>                                                     : ^^^^^^
>Harness.userSpecifiedroot : string
>                          : ^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>userSpecifiedroot : string
>                  : ^^^^^^
>'tests/baselines/local/' : "tests/baselines/local/"
>                         : ^^^^^^^^^^^^^^^^^^^^^^^^
>filename : string
>         : ^^^^^^
            }
        }

        function referencePath(filename: string) {
>referencePath : (filename: string) => string
>              : ^        ^^      ^^^^^^^^^^^
>filename : string
>         : ^^^^^^

            if (global.runners[0].testType === 'prototyping') {
>global.runners[0].testType === 'prototyping' : boolean
>                                             : ^^^^^^^
>global.runners[0].testType : any
>                           : ^^^
>global.runners[0] : any
>                  : ^^^
>global.runners : any
>               : ^^^
>global : any
>       : ^^^
>runners : any
>        : ^^^
>0 : 0
>  : ^
>testType : any
>         : ^^^
>'prototyping' : "prototyping"
>              : ^^^^^^^^^^^^^

                return Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' + filename : string
>                                                                                : ^^^^^^
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' : string
>                                                                     : ^^^^^^
>Harness.userSpecifiedroot : string
>                          : ^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>userSpecifiedroot : string
>                  : ^^^^^^
>'tests/baselines/prototyping/reference/' : "tests/baselines/prototyping/reference/"
>                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>filename : string
>         : ^^^^^^
            }
            else {
                return Harness.userSpecifiedroot + 'tests/baselines/reference/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/reference/' + filename : string
>                                                                    : ^^^^^^
>Harness.userSpecifiedroot + 'tests/baselines/reference/' : string
>                                                         : ^^^^^^
>Harness.userSpecifiedroot : string
>                          : ^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>userSpecifiedroot : string
>                  : ^^^^^^
>'tests/baselines/reference/' : "tests/baselines/reference/"
>                             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>filename : string
>         : ^^^^^^
            }
        }

        export function reset() {
>reset : () => void
>      : ^^^^^^^^^^

            if (IO.fileExists(reportFilename)) {
>IO.fileExists(reportFilename) : any
>                              : ^^^
>IO.fileExists : any
>              : ^^^
>IO : IIO
>   : ^^^
>fileExists : any
>           : ^^^
>reportFilename : string
>               : ^^^^^^

                IO.deleteFile(reportFilename);
>IO.deleteFile(reportFilename) : any
>                              : ^^^
>IO.deleteFile : any
>              : ^^^
>IO : IIO
>   : ^^^
>deleteFile : any
>           : ^^^
>reportFilename : string
>               : ^^^^^^
            }
        }

        function prepareBaselineReport(): string {
>prepareBaselineReport : () => string
>                      : ^^^^^^      

            var reportContent = htmlLeader;
>reportContent : string
>              : ^^^^^^
>htmlLeader : string
>           : ^^^^^^

            // Delete the baseline-report.html file if needed
            if (IO.fileExists(reportFilename)) {
>IO.fileExists(reportFilename) : any
>                              : ^^^
>IO.fileExists : any
>              : ^^^
>IO : IIO
>   : ^^^
>fileExists : any
>           : ^^^
>reportFilename : string
>               : ^^^^^^

                reportContent = IO.readFile(reportFilename);
>reportContent = IO.readFile(reportFilename) : any
>                                            : ^^^
>reportContent : string
>              : ^^^^^^
>IO.readFile(reportFilename) : any
>                            : ^^^
>IO.readFile : any
>            : ^^^
>IO : IIO
>   : ^^^
>readFile : any
>         : ^^^
>reportFilename : string
>               : ^^^^^^

                reportContent = reportContent.replace(htmlTrailer, '');
>reportContent = reportContent.replace(htmlTrailer, '') : string
>                                                       : ^^^^^^
>reportContent : string
>              : ^^^^^^
>reportContent.replace(htmlTrailer, '') : string
>                                       : ^^^^^^
>reportContent.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>                      : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>reportContent : string
>              : ^^^^^^
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>        : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>htmlTrailer : string
>            : ^^^^^^
>'' : ""
>   : ^^

            } else {
                reportContent = htmlLeader;
>reportContent = htmlLeader : string
>                           : ^^^^^^
>reportContent : string
>              : ^^^^^^
>htmlLeader : string
>           : ^^^^^^
            }
            return reportContent;
>reportContent : string
>              : ^^^^^^
        }

        function generateActual(actualFilename: string, generateContent: () => string): string {
>generateActual : (actualFilename: string, generateContent: () => string) => string
>               : ^              ^^      ^^               ^^            ^^^^^      
>actualFilename : string
>               : ^^^^^^
>generateContent : () => string
>                : ^^^^^^      

            // Create folders if needed
            IO.createDirectory(IO.dirName(IO.dirName(actualFilename)));
>IO.createDirectory(IO.dirName(IO.dirName(actualFilename))) : any
>                                                           : ^^^
>IO.createDirectory : any
>                   : ^^^
>IO : IIO
>   : ^^^
>createDirectory : any
>                : ^^^
>IO.dirName(IO.dirName(actualFilename)) : any
>                                       : ^^^
>IO.dirName : any
>           : ^^^
>IO : IIO
>   : ^^^
>dirName : any
>        : ^^^
>IO.dirName(actualFilename) : any
>                           : ^^^
>IO.dirName : any
>           : ^^^
>IO : IIO
>   : ^^^
>dirName : any
>        : ^^^
>actualFilename : string
>               : ^^^^^^

            IO.createDirectory(IO.dirName(actualFilename));
>IO.createDirectory(IO.dirName(actualFilename)) : any
>                                               : ^^^
>IO.createDirectory : any
>                   : ^^^
>IO : IIO
>   : ^^^
>createDirectory : any
>                : ^^^
>IO.dirName(actualFilename) : any
>                           : ^^^
>IO.dirName : any
>           : ^^^
>IO : IIO
>   : ^^^
>dirName : any
>        : ^^^
>actualFilename : string
>               : ^^^^^^

            // Delete the actual file in case it fails
            if (IO.fileExists(actualFilename)) {
>IO.fileExists(actualFilename) : any
>                              : ^^^
>IO.fileExists : any
>              : ^^^
>IO : IIO
>   : ^^^
>fileExists : any
>           : ^^^
>actualFilename : string
>               : ^^^^^^

                IO.deleteFile(actualFilename);
>IO.deleteFile(actualFilename) : any
>                              : ^^^
>IO.deleteFile : any
>              : ^^^
>IO : IIO
>   : ^^^
>deleteFile : any
>           : ^^^
>actualFilename : string
>               : ^^^^^^
            }

            var actual = generateContent();
>actual : string
>       : ^^^^^^
>generateContent() : string
>                  : ^^^^^^
>generateContent : () => string
>                : ^^^^^^      

            if (actual === undefined) {
>actual === undefined : boolean
>                     : ^^^^^^^
>actual : string
>       : ^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

                throw new Error('The generated content was "undefined". Return "null" if no baselining is required."');
>new Error('The generated content was "undefined". Return "null" if no baselining is required."') : Error
>                                                                                                 : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>'The generated content was "undefined". Return "null" if no baselining is required."' : "The generated content was \"undefined\". Return \"null\" if no baselining is required.\""
>                                                                                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            }

            // Store the content in the 'local' folder so we
            // can accept it later (manually)
            if (actual !== null) {
>actual !== null : boolean
>                : ^^^^^^^
>actual : string
>       : ^^^^^^

                IO.writeFile(actualFilename, actual);
>IO.writeFile(actualFilename, actual) : any
>                                     : ^^^
>IO.writeFile : any
>             : ^^^
>IO : IIO
>   : ^^^
>writeFile : any
>          : ^^^
>actualFilename : string
>               : ^^^^^^
>actual : string
>       : ^^^^^^
            }

            return actual;
>actual : string
>       : ^^^^^^
        }

        function compareToBaseline(actual: string, relativeFilename: string, opts: BaselineOptions) {
>compareToBaseline : (actual: string, relativeFilename: string, opts: BaselineOptions) => { expected: string; actual: string; }
>                  : ^      ^^      ^^                ^^      ^^    ^^               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
>relativeFilename : string
>                 : ^^^^^^
>opts : BaselineOptions
>     : ^^^^^^^^^^^^^^^

            // actual is now either undefined (the generator had an error), null (no file requested),
            // or some real output of the function
            if (actual === undefined) {
>actual === undefined : boolean
>                     : ^^^^^^^
>actual : string
>       : ^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

                // Nothing to do
                return;
            }

            var refFilename = referencePath(relativeFilename);
>refFilename : string
>            : ^^^^^^
>referencePath(relativeFilename) : string
>                                : ^^^^^^
>referencePath : (filename: string) => string
>              : ^        ^^      ^^^^^^^^^^^
>relativeFilename : string
>                 : ^^^^^^

            if (actual === null) {
>actual === null : boolean
>                : ^^^^^^^
>actual : string
>       : ^^^^^^

                actual = '<no content>';
>actual = '<no content>' : "<no content>"
>                        : ^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
>'<no content>' : "<no content>"
>               : ^^^^^^^^^^^^^^
            }

            var expected = '<no content>';
>expected : string
>         : ^^^^^^
>'<no content>' : "<no content>"
>               : ^^^^^^^^^^^^^^

            if (IO.fileExists(refFilename)) {
>IO.fileExists(refFilename) : any
>                           : ^^^
>IO.fileExists : any
>              : ^^^
>IO : IIO
>   : ^^^
>fileExists : any
>           : ^^^
>refFilename : string
>            : ^^^^^^

                expected = IO.readFile(refFilename);
>expected = IO.readFile(refFilename) : any
>                                    : ^^^
>expected : string
>         : ^^^^^^
>IO.readFile(refFilename) : any
>                         : ^^^
>IO.readFile : any
>            : ^^^
>IO : IIO
>   : ^^^
>readFile : any
>         : ^^^
>refFilename : string
>            : ^^^^^^
            }

            var lineEndingSensitive = opts && opts.LineEndingSensitive;
>lineEndingSensitive : boolean
>                    : ^^^^^^^
>opts && opts.LineEndingSensitive : boolean
>                                 : ^^^^^^^
>opts : BaselineOptions
>     : ^^^^^^^^^^^^^^^
>opts.LineEndingSensitive : boolean
>                         : ^^^^^^^
>opts : BaselineOptions
>     : ^^^^^^^^^^^^^^^
>LineEndingSensitive : boolean
>                    : ^^^^^^^

            if (!lineEndingSensitive) {
>!lineEndingSensitive : boolean
>                     : ^^^^^^^
>lineEndingSensitive : boolean
>                    : ^^^^^^^

                expected = expected.replace(/\r\n?/g, '\n')
>expected = expected.replace(/\r\n?/g, '\n') : string
>                                            : ^^^^^^
>expected : string
>         : ^^^^^^
>expected.replace(/\r\n?/g, '\n') : string
>                                 : ^^^^^^
>expected.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>                 : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>expected : string
>         : ^^^^^^
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>        : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>/\r\n?/g : RegExp
>         : ^^^^^^
>'\n' : "\n"
>     : ^^^^

                actual = actual.replace(/\r\n?/g, '\n')
>actual = actual.replace(/\r\n?/g, '\n') : string
>                                        : ^^^^^^
>actual : string
>       : ^^^^^^
>actual.replace(/\r\n?/g, '\n') : string
>                               : ^^^^^^
>actual.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>               : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>actual : string
>       : ^^^^^^
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>        : ^^^           ^^               ^^            ^^      ^^^      ^^^           ^^               ^^        ^^                                             ^^^      ^^^
>/\r\n?/g : RegExp
>         : ^^^^^^
>'\n' : "\n"
>     : ^^^^
            }

            return { expected: expected, actual: actual };
>{ expected: expected, actual: actual } : { expected: string; actual: string; }
>                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>expected : string
>         : ^^^^^^
>expected : string
>         : ^^^^^^
>actual : string
>       : ^^^^^^
>actual : string
>       : ^^^^^^
        }

        function writeComparison(expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) {
>writeComparison : (expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) => void
>                : ^        ^^      ^^      ^^      ^^                ^^      ^^              ^^      ^^                      ^^      ^^^^^^^^^
>expected : string
>         : ^^^^^^
>actual : string
>       : ^^^^^^
>relativeFilename : string
>                 : ^^^^^^
>actualFilename : string
>               : ^^^^^^
>descriptionForDescribe : string
>                       : ^^^^^^

            if (expected != actual) {
>expected != actual : boolean
>                   : ^^^^^^^
>expected : string
>         : ^^^^^^
>actual : string
>       : ^^^^^^

                // Overwrite & issue error
                var errMsg = 'The baseline file ' + relativeFilename + ' has changed. Please refer to baseline-report.html and ';
>errMsg : string
>       : ^^^^^^
>'The baseline file ' + relativeFilename + ' has changed. Please refer to baseline-report.html and ' : string
>                                                                                                    : ^^^^^^
>'The baseline file ' + relativeFilename : string
>                                        : ^^^^^^
>'The baseline file ' : "The baseline file "
>                     : ^^^^^^^^^^^^^^^^^^^^
>relativeFilename : string
>                 : ^^^^^^
>' has changed. Please refer to baseline-report.html and ' : " has changed. Please refer to baseline-report.html and "
>                                                          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                errMsg += 'either fix the regression (if unintended) or run nmake baseline-accept (if intended).'
>errMsg += 'either fix the regression (if unintended) or run nmake baseline-accept (if intended).' : string
>                                                                                                  : ^^^^^^
>errMsg : string
>       : ^^^^^^
>'either fix the regression (if unintended) or run nmake baseline-accept (if intended).' : "either fix the regression (if unintended) or run nmake baseline-accept (if intended)."
>                                                                                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                var refFilename = referencePath(relativeFilename);
>refFilename : string
>            : ^^^^^^
>referencePath(relativeFilename) : string
>                                : ^^^^^^
>referencePath : (filename: string) => string
>              : ^        ^^      ^^^^^^^^^^^
>relativeFilename : string
>                 : ^^^^^^

                // Append diff to the report
                var diff = new Diff.StringDiff(expected, actual);
>diff : any
>     : ^^^
>new Diff.StringDiff(expected, actual) : any
>                                      : ^^^
>Diff.StringDiff : any
>                : ^^^
>Diff : any
>     : ^^^
>StringDiff : any
>           : ^^^
>expected : string
>         : ^^^^^^
>actual : string
>       : ^^^^^^

                var header = '<h2>' + descriptionForDescribe + '</h2>';
>header : string
>       : ^^^^^^
>'<h2>' + descriptionForDescribe + '</h2>' : string
>                                          : ^^^^^^
>'<h2>' + descriptionForDescribe : string
>                                : ^^^^^^
>'<h2>' : "<h2>"
>       : ^^^^^^
>descriptionForDescribe : string
>                       : ^^^^^^
>'</h2>' : "</h2>"
>        : ^^^^^^^

                header += '<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>';
>header += '<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>' : string
>                                                                                        : ^^^^^^
>header : string
>       : ^^^^^^
>'<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>' : string
>                                                                              : ^^^^^^
>'<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename : string
>                                                                    : ^^^^^^
>'<h4>Left file: ' + actualFilename + '; Right file: ' : string
>                                                      : ^^^^^^
>'<h4>Left file: ' + actualFilename : string
>                                   : ^^^^^^
>'<h4>Left file: ' : "<h4>Left file: "
>                  : ^^^^^^^^^^^^^^^^^
>actualFilename : string
>               : ^^^^^^
>'; Right file: ' : "; Right file: "
>                 : ^^^^^^^^^^^^^^^^
>refFilename : string
>            : ^^^^^^
>'</h4>' : "</h4>"
>        : ^^^^^^^

                var trailer = '<hr>';
>trailer : string
>        : ^^^^^^
>'<hr>' : "<hr>"
>       : ^^^^^^

                var reportContentSoFar = prepareBaselineReport();
>reportContentSoFar : string
>                   : ^^^^^^
>prepareBaselineReport() : string
>                        : ^^^^^^
>prepareBaselineReport : () => string
>                      : ^^^^^^      

                reportContentSoFar = reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer;
>reportContentSoFar = reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer : string
>                                                                                                                             : ^^^^^^
>reportContentSoFar : string
>                   : ^^^^^^
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer : string
>                                                                                                        : ^^^^^^
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer : string
>                                                                                          : ^^^^^^
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' : string
>                                                                                : ^^^^^^
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml : string
>                                                                     : ^^^^^^
>reportContentSoFar + header + '<div class="code">' : string
>                                                   : ^^^^^^
>reportContentSoFar + header : string
>                            : ^^^^^^
>reportContentSoFar : string
>                   : ^^^^^^
>header : string
>       : ^^^^^^
>'<div class="code">' : "<div class=\"code\">"
>                     : ^^^^^^^^^^^^^^^^^^^^^^
>diff.mergedHtml : any
>                : ^^^
>diff : any
>     : ^^^
>mergedHtml : any
>           : ^^^
>'</div>' : "</div>"
>         : ^^^^^^^^
>trailer : string
>        : ^^^^^^
>htmlTrailer : string
>            : ^^^^^^

                IO.writeFile(reportFilename, reportContentSoFar);
>IO.writeFile(reportFilename, reportContentSoFar) : any
>                                                 : ^^^
>IO.writeFile : any
>             : ^^^
>IO : IIO
>   : ^^^
>writeFile : any
>          : ^^^
>reportFilename : string
>               : ^^^^^^
>reportContentSoFar : string
>                   : ^^^^^^

                throw new Error(errMsg);
>new Error(errMsg) : Error
>                  : ^^^^^
>Error : ErrorConstructor
>      : ^^^^^^^^^^^^^^^^
>errMsg : string
>       : ^^^^^^
            }
        }

        export function runBaseline(
>runBaseline : (descriptionForDescribe: string, relativeFilename: string, generateContent: () => string, runImmediately?: boolean, opts?: BaselineOptions) => void
>            : ^                      ^^      ^^                ^^      ^^               ^^            ^^              ^^^^^^^^^^^^    ^^^               ^^^^^^^^^

            descriptionForDescribe: string,
>descriptionForDescribe : string
>                       : ^^^^^^

            relativeFilename: string,
>relativeFilename : string
>                 : ^^^^^^

            generateContent: () => string,
>generateContent : () => string
>                : ^^^^^^      

            runImmediately? = false,
>runImmediately : boolean
>               : ^^^^^^^
>false : false
>      : ^^^^^

            opts?: BaselineOptions) {
>opts : BaselineOptions
>     : ^^^^^^^^^^^^^^^

            var actual = <string>undefined;
>actual : string
>       : ^^^^^^
><string>undefined : string
>                  : ^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

            var actualFilename = localPath(relativeFilename);
>actualFilename : string
>               : ^^^^^^
>localPath(relativeFilename) : string
>                            : ^^^^^^
>localPath : (filename: string) => string
>          : ^        ^^      ^^^^^^^^^^^
>relativeFilename : string
>                 : ^^^^^^

            if (runImmediately) {
>runImmediately : boolean
>               : ^^^^^^^

                var actual = generateActual(actualFilename, generateContent);
>actual : string
>       : ^^^^^^
>generateActual(actualFilename, generateContent) : string
>                                                : ^^^^^^
>generateActual : (actualFilename: string, generateContent: () => string) => string
>               : ^              ^^      ^^               ^^            ^^^^^      
>actualFilename : string
>               : ^^^^^^
>generateContent : () => string
>                : ^^^^^^      

                var comparison = compareToBaseline(actual, relativeFilename, opts);
>comparison : { expected: string; actual: string; }
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>compareToBaseline(actual, relativeFilename, opts) : { expected: string; actual: string; }
>                                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>compareToBaseline : (actual: string, relativeFilename: string, opts: BaselineOptions) => { expected: string; actual: string; }
>                  : ^      ^^      ^^                ^^      ^^    ^^               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
>relativeFilename : string
>                 : ^^^^^^
>opts : BaselineOptions
>     : ^^^^^^^^^^^^^^^

                writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
>writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe) : void
>                                                                                                                  : ^^^^
>writeComparison : (expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) => void
>                : ^        ^^      ^^      ^^      ^^                ^^      ^^              ^^      ^^                      ^^      ^^^^^^^^^
>comparison.expected : string
>                    : ^^^^^^
>comparison : { expected: string; actual: string; }
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>expected : string
>         : ^^^^^^
>comparison.actual : string
>                  : ^^^^^^
>comparison : { expected: string; actual: string; }
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
>relativeFilename : string
>                 : ^^^^^^
>actualFilename : string
>               : ^^^^^^
>descriptionForDescribe : string
>                       : ^^^^^^

            } else {
                describe(descriptionForDescribe, () => {
>describe(descriptionForDescribe, () => {                    var actual: string;                    it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    });                    it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    });                }) : void
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         : ^^^^
>describe : (description: string, block: () => any) => void
>         : ^           ^^      ^^     ^^         ^^^^^^^^^
>descriptionForDescribe : string
>                       : ^^^^^^
>() => {                    var actual: string;                    it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    });                    it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    });                } : () => void
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       : ^^^^^^^^^^

                    var actual: string;
>actual : string
>       : ^^^^^^

                    it('Can generate the content without error', () => {
>it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    }) : void
>                                                                                                                                                            : ^^^^
>it : (description: string, block: () => void) => void
>   : ^           ^^      ^^     ^^          ^^^^^^^^^
>'Can generate the content without error' : "Can generate the content without error"
>                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>() => {                        actual = generateActual(actualFilename, generateContent);                    } : () => void
>                                                                                                              : ^^^^^^^^^^

                        actual = generateActual(actualFilename, generateContent);
>actual = generateActual(actualFilename, generateContent) : string
>                                                         : ^^^^^^
>actual : string
>       : ^^^^^^
>generateActual(actualFilename, generateContent) : string
>                                                : ^^^^^^
>generateActual : (actualFilename: string, generateContent: () => string) => string
>               : ^              ^^      ^^               ^^            ^^^^^      
>actualFilename : string
>               : ^^^^^^
>generateContent : () => string
>                : ^^^^^^      

                    });

                    it('Matches the baseline file', () => {
>it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    }) : void
>                                                                                                                                                                                                                                                                                                   : ^^^^
>it : (description: string, block: () => void) => void
>   : ^           ^^      ^^     ^^          ^^^^^^^^^
>'Matches the baseline file' : "Matches the baseline file"
>                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>() => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    } : () => void
>                                                                                                                                                                                                                                                                  : ^^^^^^^^^^

                        var comparison = compareToBaseline(actual, relativeFilename, opts);
>comparison : { expected: string; actual: string; }
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>compareToBaseline(actual, relativeFilename, opts) : { expected: string; actual: string; }
>                                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>compareToBaseline : (actual: string, relativeFilename: string, opts: BaselineOptions) => { expected: string; actual: string; }
>                  : ^      ^^      ^^                ^^      ^^    ^^               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
>relativeFilename : string
>                 : ^^^^^^
>opts : BaselineOptions
>     : ^^^^^^^^^^^^^^^

                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
>writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe) : void
>                                                                                                                  : ^^^^
>writeComparison : (expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) => void
>                : ^        ^^      ^^      ^^      ^^                ^^      ^^              ^^      ^^                      ^^      ^^^^^^^^^
>comparison.expected : string
>                    : ^^^^^^
>comparison : { expected: string; actual: string; }
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>expected : string
>         : ^^^^^^
>comparison.actual : string
>                  : ^^^^^^
>comparison : { expected: string; actual: string; }
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>actual : string
>       : ^^^^^^
>relativeFilename : string
>                 : ^^^^^^
>actualFilename : string
>               : ^^^^^^
>descriptionForDescribe : string
>                       : ^^^^^^

                    });
                });
            }
        }
    }

    var currentRun = new Run();
>currentRun : Run
>           : ^^^
>new Run() : Run
>          : ^^^
>Run : typeof Run
>    : ^^^^^^^^^^

    global.describe = describe;
>global.describe = describe : (description: string, block: () => any) => void
>                           : ^           ^^      ^^     ^^         ^^^^^^^^^
>global.describe : any
>                : ^^^
>global : any
>       : ^^^
>describe : any
>         : ^^^
>describe : (description: string, block: () => any) => void
>         : ^           ^^      ^^     ^^         ^^^^^^^^^

    global.run = run;
>global.run = run : () => void
>                 : ^^^^^^^^^^
>global.run : any
>           : ^^^
>global : any
>       : ^^^
>run : any
>    : ^^^
>run : () => void
>    : ^^^^^^^^^^

    global.it = it;
>global.it = it : (description: string, block: () => void) => void
>               : ^           ^^      ^^     ^^          ^^^^^^^^^
>global.it : any
>          : ^^^
>global : any
>       : ^^^
>it : any
>   : ^^^
>it : (description: string, block: () => void) => void
>   : ^           ^^      ^^     ^^          ^^^^^^^^^

    global.assert = Harness.Assert;
>global.assert = Harness.Assert : typeof Assert
>                               : ^^^^^^^^^^^^^
>global.assert : any
>              : ^^^
>global : any
>       : ^^^
>assert : any
>       : ^^^
>Harness.Assert : typeof Assert
>               : ^^^^^^^^^^^^^
>Harness : typeof Harness
>        : ^^^^^^^^^^^^^^
>Assert : typeof Assert
>       : ^^^^^^^^^^^^^
}

