=== tests/cases/conformance/salsa/plainJSGrammarErrors.js ===
class C {
>C : Symbol(C, Decl(plainJSGrammarErrors.js, 0, 0))

    // #private mistakes
    q = #unbound
>q : Symbol(C.q, Decl(plainJSGrammarErrors.js, 0, 9))

    m() {
>m : Symbol(C.m, Decl(plainJSGrammarErrors.js, 2, 16))

        #p
        if (#po in this) {
>this : Symbol(C, Decl(plainJSGrammarErrors.js, 0, 0))
        }
    }
    #m() {
>#m : Symbol(C.#m, Decl(plainJSGrammarErrors.js, 7, 5))

         this.#m = () => {}
>this.#m : Symbol(C.#m, Decl(plainJSGrammarErrors.js, 7, 5))
>this : Symbol(C, Decl(plainJSGrammarErrors.js, 0, 0))
    }
    // await in static block
    static {
        for await (const x of [1,2,3]) {
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 13, 24))

            console.log(x)
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 13, 24))
        }
    }
    // modifier mistakes
    static constructor() { }
    async constructor() { }
    const x = 1
>x : Symbol(C.x, Decl(plainJSGrammarErrors.js, 19, 27))

    const y() {
>y : Symbol(C.y, Decl(plainJSGrammarErrors.js, 20, 15))

        return 12
    }
    async async extremelyAsync() {
>extremelyAsync : Symbol(C.extremelyAsync, Decl(plainJSGrammarErrors.js, 23, 5))
    }
    async static oorder(){ }
>oorder : Symbol(C.oorder, Decl(plainJSGrammarErrors.js, 25, 5))

    export cantExportProperty = 1
>cantExportProperty : Symbol(C.cantExportProperty, Decl(plainJSGrammarErrors.js, 26, 28))

    export cantExportMethod() {
>cantExportMethod : Symbol(C.cantExportMethod, Decl(plainJSGrammarErrors.js, 27, 33))
    }

    // accessor mistakes
    get incorporeal();
>incorporeal : Symbol(C.incorporeal, Decl(plainJSGrammarErrors.js, 29, 5))

    get parametric(n) { return 1 }
>parametric : Symbol(C.parametric, Decl(plainJSGrammarErrors.js, 32, 22))
>n : Symbol(n, Decl(plainJSGrammarErrors.js, 33, 19))

    set invariant() { }
>invariant : Symbol(C.invariant, Decl(plainJSGrammarErrors.js, 33, 34))

    set binary(fst, snd) { }
>binary : Symbol(C.binary, Decl(plainJSGrammarErrors.js, 34, 23))
>fst : Symbol(fst, Decl(plainJSGrammarErrors.js, 35, 15))
>snd : Symbol(snd, Decl(plainJSGrammarErrors.js, 35, 19))

    set variable(...n) { }
>variable : Symbol(C.variable, Decl(plainJSGrammarErrors.js, 35, 28))
>n : Symbol(n, Decl(plainJSGrammarErrors.js, 36, 17))

    // other
    "constructor" = 16
>"constructor" : Symbol(C["constructor"], Decl(plainJSGrammarErrors.js, 36, 26))
}
// #private mistakes
#unrelated
junk.#m
new C().#m
>C : Symbol(C, Decl(plainJSGrammarErrors.js, 0, 0))

// modifier mistakes
export export var extremelyExported = 10
>extremelyExported : Symbol(extremelyExported, Decl(plainJSGrammarErrors.js, 47, 17))

export static var staticExport = 1
>staticExport : Symbol(staticExport, Decl(plainJSGrammarErrors.js, 48, 17))

function staticParam(static x = 1) { return x }
>staticParam : Symbol(staticParam, Decl(plainJSGrammarErrors.js, 48, 34))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 49, 21))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 49, 21))

async export function oorder(x = 1) { return x }
>oorder : Symbol(oorder, Decl(plainJSGrammarErrors.js, 49, 47))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 50, 29))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 50, 29))

function cantExportParam(export x = 1) { return x }
>cantExportParam : Symbol(cantExportParam, Decl(plainJSGrammarErrors.js, 50, 48))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 51, 25))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 51, 25))

function cantAsyncParam(async x = 1) { return x }
>cantAsyncParam : Symbol(cantAsyncParam, Decl(plainJSGrammarErrors.js, 51, 51))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 52, 24))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 52, 24))

async async function extremelyAsync() {}
>extremelyAsync : Symbol(extremelyAsync, Decl(plainJSGrammarErrors.js, 52, 49))

async class CantAsyncClass {
>CantAsyncClass : Symbol(CantAsyncClass, Decl(plainJSGrammarErrors.js, 53, 40))

    async cantAsyncPropert = 1
>cantAsyncPropert : Symbol(CantAsyncClass.cantAsyncPropert, Decl(plainJSGrammarErrors.js, 54, 28))
}
async const cantAsyncConst = 2
>cantAsyncConst : Symbol(cantAsyncConst, Decl(plainJSGrammarErrors.js, 57, 11))

async import 'assert'
async export { CantAsyncClass }
>CantAsyncClass : Symbol(CantAsyncClass, Decl(plainJSGrammarErrors.js, 59, 14))

// rest parameters
function restMustBeLast(...x, y) {
>restMustBeLast : Symbol(restMustBeLast, Decl(plainJSGrammarErrors.js, 59, 31))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 62, 24))
>y : Symbol(y, Decl(plainJSGrammarErrors.js, 62, 29))
}
function restCantHaveInitialiser(...x = [1,2,3]) {
>restCantHaveInitialiser : Symbol(restCantHaveInitialiser, Decl(plainJSGrammarErrors.js, 63, 1))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 64, 33))
}
;({ ...{} } = {})
const doom = { e: 1, m: 1, name: "knee-deep" }
>doom : Symbol(doom, Decl(plainJSGrammarErrors.js, 67, 5))
>e : Symbol(e, Decl(plainJSGrammarErrors.js, 67, 14))
>m : Symbol(m, Decl(plainJSGrammarErrors.js, 67, 20))
>name : Symbol(name, Decl(plainJSGrammarErrors.js, 67, 26))

const { ...rest, e: episode, m: mission } = doom
>rest : Symbol(rest, Decl(plainJSGrammarErrors.js, 68, 7))
>e : Symbol(e, Decl(plainJSGrammarErrors.js, 67, 14))
>episode : Symbol(episode, Decl(plainJSGrammarErrors.js, 68, 16))
>m : Symbol(m, Decl(plainJSGrammarErrors.js, 67, 20))
>mission : Symbol(mission, Decl(plainJSGrammarErrors.js, 68, 28))
>doom : Symbol(doom, Decl(plainJSGrammarErrors.js, 67, 5))

const { e: eep, m: em, ...rest: noRestAllowed } = doom
>e : Symbol(e, Decl(plainJSGrammarErrors.js, 67, 14))
>eep : Symbol(eep, Decl(plainJSGrammarErrors.js, 69, 7))
>m : Symbol(m, Decl(plainJSGrammarErrors.js, 67, 20))
>em : Symbol(em, Decl(plainJSGrammarErrors.js, 69, 15))
>noRestAllowed : Symbol(noRestAllowed, Decl(plainJSGrammarErrors.js, 69, 22))
>doom : Symbol(doom, Decl(plainJSGrammarErrors.js, 67, 5))

// left-over parsing
var x = 1 || 2 ?? 3
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 72, 3), Decl(plainJSGrammarErrors.js, 73, 3))

var x = 2 ?? 3 || 4
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 72, 3), Decl(plainJSGrammarErrors.js, 73, 3))

const arr = x
>arr : Symbol(arr, Decl(plainJSGrammarErrors.js, 74, 5))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 74, 11))

  => x + 1
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 74, 11))

var a = [1,2]
>a : Symbol(a, Decl(plainJSGrammarErrors.js, 76, 3))

a?.`length`;
>a : Symbol(a, Decl(plainJSGrammarErrors.js, 76, 3))

const o = {
>o : Symbol(o, Decl(plainJSGrammarErrors.js, 78, 5))

    [console.log('oh no'),2]: 'hi',
>[console.log('oh no'),2] : Symbol([console.log('oh no'),2], Decl(plainJSGrammarErrors.js, 78, 11))
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))

    #noPrivate: 3,
>#noPrivate : Symbol(#noPrivate, Decl(plainJSGrammarErrors.js, 79, 35))

    export cantExportProperties: 4,
>cantExportProperties : Symbol(cantExportProperties, Decl(plainJSGrammarErrors.js, 80, 18))

    // TODO: See what the existing JS error is like for these
    cantHaveQuestionMark?: 1,
>cantHaveQuestionMark : Symbol(cantHaveQuestionMark, Decl(plainJSGrammarErrors.js, 81, 35))

    m?() { return 12 },
>m : Symbol(m, Decl(plainJSGrammarErrors.js, 83, 29))

    definitely!,
>definitely : Symbol(definitely, Decl(plainJSGrammarErrors.js, 84, 23))

    definiteMethod!() { return 13 },
>definiteMethod : Symbol(definiteMethod, Decl(plainJSGrammarErrors.js, 85, 16))
}
const noAssignment = {
>noAssignment : Symbol(noAssignment, Decl(plainJSGrammarErrors.js, 88, 5))

    assignment = 1,
>assignment : Symbol(assignment, Decl(plainJSGrammarErrors.js, 88, 22))
}

// let/const mistakes
const { e: ee };
>e : Symbol(e)
>ee : Symbol(ee, Decl(plainJSGrammarErrors.js, 93, 7))

const noInit;
>noInit : Symbol(noInit, Decl(plainJSGrammarErrors.js, 94, 5))

let let = 15;
>let : Symbol(let, Decl(plainJSGrammarErrors.js, 95, 3))

if (true)
    let onlyBlockLet = 17;
>onlyBlockLet : Symbol(onlyBlockLet, Decl(plainJSGrammarErrors.js, 97, 7))

if (true)
    const onlyBlockConst = 18;
>onlyBlockConst : Symbol(onlyBlockConst, Decl(plainJSGrammarErrors.js, 99, 9))

// loop mistakes
let async
>async : Symbol(async, Decl(plainJSGrammarErrors.js, 102, 3))

export const l = [1,2,3]
>l : Symbol(l, Decl(plainJSGrammarErrors.js, 103, 12))

for (async of l) {
>async : Symbol(async, Decl(plainJSGrammarErrors.js, 102, 3))
>l : Symbol(l, Decl(plainJSGrammarErrors.js, 103, 12))

    console.log(x)
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 72, 3), Decl(plainJSGrammarErrors.js, 73, 3))
}
for (const cantHaveInit = 1 of [1,2,3]) {
>cantHaveInit : Symbol(cantHaveInit, Decl(plainJSGrammarErrors.js, 107, 10))

    console.log(cantHaveInit)
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>cantHaveInit : Symbol(cantHaveInit, Decl(plainJSGrammarErrors.js, 107, 10))
}
for (const cantHaveInit = 1 in [1,2,3]) {
>cantHaveInit : Symbol(cantHaveInit, Decl(plainJSGrammarErrors.js, 110, 10))

    console.log(cantHaveInit)
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>cantHaveInit : Symbol(cantHaveInit, Decl(plainJSGrammarErrors.js, 110, 10))
}
// duplication mistakes
var b
>b : Symbol(b, Decl(plainJSGrammarErrors.js, 114, 3))

switch (b) {
>b : Symbol(b, Decl(plainJSGrammarErrors.js, 114, 3))

    case false:
        console.log('no')
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))

    default:
        console.log('yes')
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))

    default:
        console.log('wat')
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
}
try {
    throw 2
}
catch (e) {
>e : Symbol(e, Decl(plainJSGrammarErrors.js, 126, 7))

    const e = 1
>e : Symbol(e, Decl(plainJSGrammarErrors.js, 127, 9))

    console.log(e)
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>e : Symbol(e, Decl(plainJSGrammarErrors.js, 127, 9))
}
label: for (const x in [1,2,3]) {
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 130, 17))

    label: for (const y in [1,2,3]) {
>y : Symbol(y, Decl(plainJSGrammarErrors.js, 131, 21))

        break label;
    }
}

// labels
function crossFunctionBoundary() {
>crossFunctionBoundary : Symbol(crossFunctionBoundary, Decl(plainJSGrammarErrors.js, 134, 1))

    outer: for(;;) {
        function test() {
>test : Symbol(test, Decl(plainJSGrammarErrors.js, 138, 20))

            break outer
        }
        test()
>test : Symbol(test, Decl(plainJSGrammarErrors.js, 138, 20))
    }
}
function continueIterationOnly(x) {
>continueIterationOnly : Symbol(continueIterationOnly, Decl(plainJSGrammarErrors.js, 144, 1))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 145, 31))

    outer: switch (x) {
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 145, 31))

        case 1:
            continue outer
    }
}
function jumpToLabelOnly(x) {
>jumpToLabelOnly : Symbol(jumpToLabelOnly, Decl(plainJSGrammarErrors.js, 150, 1))
>x : Symbol(x, Decl(plainJSGrammarErrors.js, 151, 25))

    break jumpToLabelOnly
}
for (;;) {
    break toplevel
    continue toplevel
}
break
continue

// other weirdness
export let noMeta = import.metal
>noMeta : Symbol(noMeta, Decl(plainJSGrammarErrors.js, 162, 10))

function foo() { new.targe }
>foo : Symbol(foo, Decl(plainJSGrammarErrors.js, 162, 32))
>new.targe : Symbol(foo, Decl(plainJSGrammarErrors.js, 162, 32))
>targe : Symbol(foo, Decl(plainJSGrammarErrors.js, 162, 32))

const nullaryDynamicImport = import()
>nullaryDynamicImport : Symbol(nullaryDynamicImport, Decl(plainJSGrammarErrors.js, 164, 5))

const trinaryDynamicImport = import('1', '2', '3')
>trinaryDynamicImport : Symbol(trinaryDynamicImport, Decl(plainJSGrammarErrors.js, 165, 5))

const spreadDynamicImport = import(...[])
>spreadDynamicImport : Symbol(spreadDynamicImport, Decl(plainJSGrammarErrors.js, 166, 5))

