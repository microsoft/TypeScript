=== tests/cases/compiler/promiseVoidErrorCallback.ts ===
interface T1 {
>T1 : Symbol(T1, Decl(promiseVoidErrorCallback.ts, 0, 0))

    __t1: string;
>__t1 : Symbol(__t1, Decl(promiseVoidErrorCallback.ts, 0, 14))
}

interface T2 {
>T2 : Symbol(T2, Decl(promiseVoidErrorCallback.ts, 2, 1))

    __t2: string;
>__t2 : Symbol(__t2, Decl(promiseVoidErrorCallback.ts, 4, 14))
}

interface T3 {
>T3 : Symbol(T3, Decl(promiseVoidErrorCallback.ts, 6, 1))

    __t3: string;
>__t3 : Symbol(__t3, Decl(promiseVoidErrorCallback.ts, 8, 14))
}

function f1(): Promise<T1> {
>f1 : Symbol(f1, Decl(promiseVoidErrorCallback.ts, 10, 1))
>Promise : Symbol(Promise, Decl(lib.d.ts, 4772, 1), Decl(lib.d.ts, 4858, 11))
>T1 : Symbol(T1, Decl(promiseVoidErrorCallback.ts, 0, 0))

    return Promise.resolve({ __t1: "foo_t1" });
<<<<<<< HEAD
>Promise.resolve : Symbol(PromiseConstructor.resolve, Decl(lib.d.ts, 4840, 39), Decl(lib.d.ts, 4847, 54))
>Promise : Symbol(Promise, Decl(lib.d.ts, 4772, 1), Decl(lib.d.ts, 4858, 11))
>resolve : Symbol(PromiseConstructor.resolve, Decl(lib.d.ts, 4840, 39), Decl(lib.d.ts, 4847, 54))
=======
>Promise.resolve : Symbol(PromiseConstructor.resolve, Decl(lib.d.ts, 4837, 39), Decl(lib.d.ts, 4844, 54))
>Promise : Symbol(Promise, Decl(lib.d.ts, 4770, 1), Decl(lib.d.ts, 4855, 11))
>resolve : Symbol(PromiseConstructor.resolve, Decl(lib.d.ts, 4837, 39), Decl(lib.d.ts, 4844, 54))
>{ __t1: "foo_t1" } : Symbol(, Decl(promiseVoidErrorCallback.ts, 13, 27))
>>>>>>> Accept symbol baselines
>__t1 : Symbol(__t1, Decl(promiseVoidErrorCallback.ts, 13, 28))
}

function f2(x: T1): T2 {
>f2 : Symbol(f2, Decl(promiseVoidErrorCallback.ts, 14, 1))
>x : Symbol(x, Decl(promiseVoidErrorCallback.ts, 16, 12))
>T1 : Symbol(T1, Decl(promiseVoidErrorCallback.ts, 0, 0))
>T2 : Symbol(T2, Decl(promiseVoidErrorCallback.ts, 2, 1))

    return { __t2: x.__t1 + ":foo_21" };
>{ __t2: x.__t1 + ":foo_21" } : Symbol(, Decl(promiseVoidErrorCallback.ts, 17, 10))
>__t2 : Symbol(__t2, Decl(promiseVoidErrorCallback.ts, 17, 12))
>x.__t1 : Symbol(T1.__t1, Decl(promiseVoidErrorCallback.ts, 0, 14))
>x : Symbol(x, Decl(promiseVoidErrorCallback.ts, 16, 12))
>__t1 : Symbol(T1.__t1, Decl(promiseVoidErrorCallback.ts, 0, 14))
}

var x3 = f1()
>x3 : Symbol(x3, Decl(promiseVoidErrorCallback.ts, 20, 3))
>f1()    .then(f2, (e: Error) => {    throw e;})    .then : Symbol(Promise.then, Decl(lib.d.ts, 4777, 22), Decl(lib.d.ts, 4784, 158))
>f1()    .then : Symbol(Promise.then, Decl(lib.d.ts, 4777, 22), Decl(lib.d.ts, 4784, 158))
>f1 : Symbol(f1, Decl(promiseVoidErrorCallback.ts, 10, 1))

    .then(f2, (e: Error) => {
>then : Symbol(Promise.then, Decl(lib.d.ts, 4777, 22), Decl(lib.d.ts, 4784, 158))
>f2 : Symbol(f2, Decl(promiseVoidErrorCallback.ts, 14, 1))
>(e: Error) => {    throw e;} : Symbol((Anonymous function), Decl(promiseVoidErrorCallback.ts, 21, 13))
>e : Symbol(e, Decl(promiseVoidErrorCallback.ts, 21, 15))
>Error : Symbol(Error, Decl(lib.d.ts, 876, 38), Decl(lib.d.ts, 889, 11))

    throw e;
>e : Symbol(e, Decl(promiseVoidErrorCallback.ts, 21, 15))

})
    .then((x: T2) => {
<<<<<<< HEAD
>then : Symbol(Promise.then, Decl(lib.d.ts, 4777, 22), Decl(lib.d.ts, 4784, 158))
=======
>then : Symbol(Promise.then, Decl(lib.d.ts, 4775, 22), Decl(lib.d.ts, 4782, 158))
>(x: T2) => {    return { __t3: x.__t2 + "bar" };} : Symbol((Anonymous function), Decl(promiseVoidErrorCallback.ts, 24, 10))
>>>>>>> Accept symbol baselines
>x : Symbol(x, Decl(promiseVoidErrorCallback.ts, 24, 11))
>T2 : Symbol(T2, Decl(promiseVoidErrorCallback.ts, 2, 1))

    return { __t3: x.__t2 + "bar" };
>{ __t3: x.__t2 + "bar" } : Symbol(, Decl(promiseVoidErrorCallback.ts, 25, 10))
>__t3 : Symbol(__t3, Decl(promiseVoidErrorCallback.ts, 25, 12))
>x.__t2 : Symbol(T2.__t2, Decl(promiseVoidErrorCallback.ts, 4, 14))
>x : Symbol(x, Decl(promiseVoidErrorCallback.ts, 24, 11))
>__t2 : Symbol(T2.__t2, Decl(promiseVoidErrorCallback.ts, 4, 14))

});
