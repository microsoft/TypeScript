//// [tests/cases/compiler/ramdaToolsNoInfinite2.ts] ////

=== Performance Stats ===
Assignability cache: 5,000
Type Count: 10,000
Instantiation count: 25,000

=== ramdaToolsNoInfinite2.ts ===
declare module "Any/Kind" {
>"Any/Kind" : typeof import("Any/Kind")
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Extends } from "Any/Extends";
>Extends : any
>        : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type Kind<A extends any> = Extends<A, Function> extends 1 ? 'function' : Extends<A, List> extends 1 ? 'array' : Extends<A, object> extends 1 ? 'object' : Extends<A, string> extends 1 ? 'string' : Extends<A, number> extends 1 ? 'number' : Extends<A, boolean> extends 1 ? 'boolean' : 'unknown';
>Kind : Kind<A>
>     : ^^^^^^^
}
declare module "Any/Compute" {
>"Any/Compute" : typeof import("Any/Compute")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Compute<A extends any> = A extends Function ? A : {
>Compute : Compute<A>
>        : ^^^^^^^^^^

        [K in keyof A]: A[K];
    } & {};
}
declare module "Object/Pick" {
>"Object/Pick" : typeof import("Object/Pick")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Key } from "Any/Key";
>Key : any
>    : ^^^

    type __Pick<O extends object, K extends keyof O> = {
>__Pick : { [P in K]: O[P]; }
>       : ^^^ ^^^^^^^^^^^^^^^

        [P in K]: O[P];
    } & {};

    export type _Pick<O extends object, K extends Key> = __Pick<O, keyof O & K>;
>_Pick : _Pick<O, K>
>      : ^^^^^^^^^^^

    export type Pick<O extends object, K extends Key> = O extends unknown ? _Pick<O, K & keyof O> : never;
>Pick : Pick<O, K>
>     : ^^^^^^^^^^
}
declare module "Object/Keys" {
>"Object/Keys" : typeof import("Object/Keys")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Keys as UKeys } from "Union/Keys";
>Keys : any
>     : ^^^
>UKeys : any
>      : ^^^

    export type Keys<O extends object> = UKeys<O>;
>Keys : Keys<O>
>     : ^^^^^^^
}
declare module "Object/Omit" {
>"Object/Omit" : typeof import("Object/Omit")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { _Pick } from "Object/Pick";
>_Pick : any
>      : ^^^

    import { Exclude } from "Union/Exclude";
>Exclude : any
>        : ^^^

    import { Key } from "Any/Key";
>Key : any
>    : ^^^

    import { Keys } from "Object/Keys";
>Keys : any
>     : ^^^

    export type _Omit<O extends object, K extends Key> = _Pick<O, Exclude<Keys<O>, K>>;
>_Omit : _Omit<O, K>
>      : ^^^^^^^^^^^

    export type Omit<O extends object, K extends Key> = O extends unknown ? _Omit<O, K> : never;
>Omit : Omit<O, K>
>     : ^^^^^^^^^^
}
declare module "Object/At" {
>"Object/At" : typeof import("Object/At")
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Key } from "Any/Key";
>Key : any
>    : ^^^

    import { Boolean } from "Boolean/Boolean";
>Boolean : any
>        : ^^^

    type AtStrict<O extends object, K extends Key> = [K & keyof O] extends [never] ? never : O[K & keyof O];
>AtStrict : AtStrict<O, K>
>         : ^^^^^^^^^^^^^^

    type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
>AtLoose : AtLoose<O, K>
>        : ^^^^^^^^^^^^^

    export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
>At : At<O, K, strict>
>   : ^^^^^^^^^^^^^^^^

        1: AtStrict<O, K>;
>1 : AtStrict<O, K>
>  : ^^^^^^^^^^^^^^

        0: AtLoose<O, K>;
>0 : AtLoose<O, K>
>  : ^^^^^^^^^^^^^

    }[strict];
}
declare module "Boolean/Boolean" {
>"Boolean/Boolean" : typeof import("Boolean/Boolean")
>                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Boolean = True | False;
>Boolean : Boolean
>        : ^^^^^^^

    export type True = 1;
>True : 1
>     : ^

    export type False = 0;
>False : 0
>      : ^
}
declare module "Boolean/Not" {
>"Boolean/Not" : typeof import("Boolean/Not")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Boolean } from "Boolean/Boolean";
>Boolean : any
>        : ^^^

    export type Not<B extends Boolean> = {
>Not : Not<B>
>    : ^^^^^^

        0: 1;
>0 : 1
>  : ^

        1: 0;
>1 : 0
>  : ^

    }[B];
}
declare module "Union/Has" {
>"Union/Has" : typeof import("Union/Has")
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Union } from "Union/Union";
>Union : any
>      : ^^^

    import { Not } from "Boolean/Not";
>Not : any
>    : ^^^

    import { Extends } from "Any/Extends";
>Extends : any
>        : ^^^

    export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;
>Has : Has<U, U1>
>    : ^^^^^^^^^^
}
declare module "Union/Union" {
>"Union/Union" : typeof import("Union/Union")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Union = any;
>Union : any
}
declare module "Union/Exclude" {
>"Union/Exclude" : typeof import("Union/Exclude")
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Union } from "Union/Union";
>Union : any
>      : ^^^

    export type Exclude<U extends Union, M extends Union> = U extends M ? never : U;
>Exclude : Exclude<U, M>
>        : ^^^^^^^^^^^^^
}
declare module "Any/_Internal" {
>"Any/_Internal" : typeof import("Any/_Internal")
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { _NumberOf } from "Number/NumberOf";
>_NumberOf : any
>          : ^^^

    export type Match = 'default' | 'implements->' | '<-implements' | 'extends->' | '<-extends' | 'equals';
>Match : Match
>      : ^^^^^

    export type NumberOf<N extends any> = N extends number ? _NumberOf<N> : N;
>NumberOf : NumberOf<N>
>         : ^^^^^^^^^^^
}
declare module "Any/Implements" {
>"Any/Implements" : typeof import("Any/Implements")
>                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Extends } from "Any/Extends";
>Extends : any
>        : ^^^

    export type Implements<A1 extends any, A2 extends any> = Extends<A1, A2> extends 1 ? 1 : 0;
>Implements : Implements<A1, A2>
>           : ^^^^^^^^^^^^^^^^^^
}
declare module "Any/Key" {
>"Any/Key" : typeof import("Any/Key")
>          : ^^^^^^^^^^^^^^^^^^^^^^^^

    export type Key = string | number | symbol;
>Key : Key
>    : ^^^
}
declare module "Union/Keys" {
>"Union/Keys" : typeof import("Union/Keys")
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Union } from "Union/Union";
>Union : any
>      : ^^^

    import { Key } from "Any/Key";
>Key : any
>    : ^^^

    export type Keys<U extends Union> = (U extends unknown ? keyof U : never) & Key;
>Keys : Keys<U>
>     : ^^^^^^^
}
declare module "List/ObjectOf" {
>"List/ObjectOf" : typeof import("List/ObjectOf")
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { _Omit } from "Object/Omit";
>_Omit : any
>      : ^^^

    import { Has } from "Union/Has";
>Has : any
>    : ^^^

    import { At } from "Object/At";
>At : any
>   : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type _ObjectOf<L extends object> = Has<keyof L, keyof List> extends 1 ? number extends At<L, 'length'> ? _Omit<L, Exclude<keyof any[], number>> : _Omit<L, keyof any[]> : L;
>_ObjectOf : _ObjectOf<L>
>          : ^^^^^^^^^^^^

    export type ObjectOf<L extends object> = L extends unknown ? _ObjectOf<L> : never;
>ObjectOf : ObjectOf<L>
>         : ^^^^^^^^^^^
}
declare module "List/Keys" {
>"List/Keys" : typeof import("List/Keys")
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Exclude } from "Union/Exclude";
>Exclude : any
>        : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    import { Keys as UKeys } from "Union/Keys";
>Keys : any
>     : ^^^
>UKeys : any
>      : ^^^

    export type Keys<L extends List> = Exclude<UKeys<L>, keyof any[]> | number;
>Keys : Keys<L>
>     : ^^^^^^^
}
declare module "Object/Merge" {
>"Object/Merge" : typeof import("Object/Merge")
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { _Omit } from "Object/Omit";
>_Omit : any
>      : ^^^

    import { At } from "Object/At";
>At : any
>   : ^^^

    import { Compute } from "Any/Compute";
>Compute : any
>        : ^^^

    import { Depth } from "Object/_Internal";
>Depth : any
>      : ^^^

    import { Kind } from "Any/Kind";
>Kind : any
>     : ^^^

    export type MergeFlat<O extends object, O1 extends object> = Compute<O & _Omit<O1, keyof O>>;
>MergeFlat : MergeFlat<O, O1>
>          : ^^^^^^^^^^^^^^^^

    export type MergeDeep<O, O1> = (Kind<(O | O1)> extends 'object' ? MergeFlat<O & {}, O1 & {}> extends infer M ? {
>MergeDeep : MergeDeep<O, O1>
>          : ^^^^^^^^^^^^^^^^

        [K in keyof M]: MergeDeep<M[K], At<O1 & {}, K>>;
    } & {} : never : O);

    export type Merge<O extends object, O1 extends object, depth extends Depth = 'flat'> = {
>Merge : Merge<O, O1, depth>
>      : ^^^^^^^^^^^^^^^^^^^

        'flat': MergeFlat<O, O1>;
>'flat' : Compute<O & _Omit<O1, keyof O>>
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        'deep': MergeDeep<O, O1>;
>'deep' : MergeDeep<O, O1>
>       : ^^^^^^^^^^^^^^^^

    }[depth];
}
declare module "Union/NonNullable" {
>"Union/NonNullable" : typeof import("Union/NonNullable")
>                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Exclude } from "Union/Exclude";
>Exclude : any
>        : ^^^

    import { Union } from "Union/Union";
>Union : any
>      : ^^^

    export type NonNullable<U extends Union> = Exclude<U, undefined | null>;
>NonNullable : NonNullable<U>
>            : ^^^^^^^^^^^^^^
}
declare module "Object/ListOf" {
>"Object/ListOf" : typeof import("Object/ListOf")
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { IterationOf } from "Iteration/IterationOf";
>IterationOf : any
>            : ^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    import { Cast } from "Any/Cast";
>Cast : any
>     : ^^^

    import { Key } from "Iteration/Key";
>Key : any
>    : ^^^

    import { Next } from "Iteration/Next";
>Next : any
>     : ^^^

    import { _Append } from "List/Append";
>_Append : any
>        : ^^^

    import { Exclude } from "Union/Exclude";
>Exclude : any
>        : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    import { Extends } from "Any/Extends";
>Extends : any
>        : ^^^

    type PickIfEntry<O extends object, LN extends List, I extends Iteration> = Key<I> extends keyof O ? _Append<LN, O[Cast<Key<I>, keyof O>]> : LN;
>PickIfEntry : PickIfEntry<O, LN, I>
>            : ^^^^^^^^^^^^^^^^^^^^^

    type __ListOf<O extends object, K, LN extends List = [], I extends Iteration = IterationOf<'0'>> = {
>__ListOf : __ListOf<O, K, LN, I>
>         : ^^^^^^^^^^^^^^^^^^^^^

        0: __ListOf<O, Exclude<K, Key<I>>, PickIfEntry<O, LN, I>, Next<I>>;
>0 : __ListOf<O, Exclude<K, Key<I>>, PickIfEntry<O, LN, I>, Next<I>>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        1: LN;
>1 : LN
>  : ^^

    }[Extends<[K], [never]>];

    export type _ListOf<O extends object> = __ListOf<O, keyof O> extends infer X ? Cast<X, List> : never;
>_ListOf : _ListOf<O>
>        : ^^^^^^^^^^

    export type ListOf<O extends object> = O extends unknown ? _ListOf<O> : never;
>ListOf : ListOf<O>
>       : ^^^^^^^^^
}
declare module "Object/NonNullable" {
>"Object/NonNullable" : typeof import("Object/NonNullable")
>                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { MergeFlat } from "Object/Merge";
>MergeFlat : any
>          : ^^^

    import { NonNullable as UNonNullable } from "Union/NonNullable";
>NonNullable : any
>            : ^^^
>UNonNullable : any
>             : ^^^

    import { Depth } from "Object/_Internal";
>Depth : any
>      : ^^^

    import { Pick } from "Object/Pick";
>Pick : any
>     : ^^^

    import { Key } from "Any/Key";
>Key : any
>    : ^^^

    import { Implements } from "Any/Implements";
>Implements : any
>           : ^^^

    import { Keys } from "Object/Keys";
>Keys : any
>     : ^^^

    export type NonNullableFlat<O> = {
>NonNullableFlat : { [K in keyof O]: UNonNullable<O[K]>; }
>                : ^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        [K in keyof O]: UNonNullable<O[K]>;
    } & {};

    export type NonNullableDeep<O> = {
>NonNullableDeep : NonNullableDeep<O>
>                : ^^^^^^^^^^^^^^^^^^

        [K in keyof O]: NonNullableDeep<UNonNullable<O[K]>>;
    };

    type NonNullablePart<O extends object, depth extends Depth> = {
>NonNullablePart : NonNullablePart<O, depth>
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^

        'flat': NonNullableFlat<O>;
>'flat' : { [K in keyof O]: import("Union/Exclude").Exclude<O[K], null | undefined>; }
>       : ^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        'deep': NonNullableDeep<O>;
>'deep' : NonNullableDeep<O>
>       : ^^^^^^^^^^^^^^^^^^

    }[depth];

    export type NonNullable<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
>NonNullable : NonNullable<O, K, depth>
>            : ^^^^^^^^^^^^^^^^^^^^^^^^

        1: NonNullablePart<O, depth>;
>1 : NonNullablePart<O, depth>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^

        0: MergeFlat<NonNullablePart<Pick<O, K>, depth>, O>;
>0 : MergeFlat<NonNullablePart<Pick<O, K>, depth>, O>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    }[Implements<Keys<O>, K>] & {};
}
declare module "Object/Overwrite" {
>"Object/Overwrite" : typeof import("Object/Overwrite")
>                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Overwrite<O extends object, O1 extends object> = {
>Overwrite : { [K in keyof O]: K extends keyof O1 ? O1[K] : O[K]; }
>          : ^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
    } & {};
}
declare module "Number/_Internal" {
>"Number/_Internal" : typeof import("Number/_Internal")
>                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { IterationMap } from "Iteration/IterationOf";
>IterationMap : any
>             : ^^^

    import { Format } from "Iteration/Format";
>Format : any
>       : ^^^

    export type Formats = 'b' | 'n' | 's';
>Formats : Formats
>        : ^^^^^^^

    type KnownIterationMapKeys = '-40' | '-39' | '-38' | '-37' | '-36' | '-35' | '-34' | '-33' | '-32' | '-31' | '-30' | '-29' | '-28' | '-27' | '-26' | '-25' | '-24' | '-23' | '-22' | '-21' | '-20' | '-19' | '-18' | '-17' | '-16' | '-15' | '-14' | '-13' | '-12' | '-11' | '-10' | '-9' | '-8' | '-7' | '-6' | '-5' | '-4' | '-3' | '-2' | '-1' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' | '33' | '34' | '35' | '36' | '37' | '38' | '39' | '40';
>KnownIterationMapKeys : KnownIterationMapKeys
>                      : ^^^^^^^^^^^^^^^^^^^^^

    type PositiveIterationKeys = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' | '33' | '34' | '35' | '36' | '37' | '38' | '39' | '40';
>PositiveIterationKeys : PositiveIterationKeys
>                      : ^^^^^^^^^^^^^^^^^^^^^

    type NegativeIterationKeys = '-40' | '-39' | '-38' | '-37' | '-36' | '-35' | '-34' | '-33' | '-32' | '-31' | '-30' | '-29' | '-28' | '-27' | '-26' | '-25' | '-24' | '-23' | '-22' | '-21' | '-20' | '-19' | '-18' | '-17' | '-16' | '-15' | '-14' | '-13' | '-12' | '-11' | '-10' | '-9' | '-8' | '-7' | '-6' | '-5' | '-4' | '-3' | '-2' | '-1';
>NegativeIterationKeys : NegativeIterationKeys
>                      : ^^^^^^^^^^^^^^^^^^^^^

    export type Numbers = {
>Numbers : Numbers
>        : ^^^^^^^

        'string': {
>'string' : { all: Format<IterationMap[KnownIterationMapKeys], "s">; '+': Format<IterationMap[PositiveIterationKeys], "s">; '-': Format<IterationMap[NegativeIterationKeys], "s">; '0': Format<IterationMap["0"], "s">; }
>         : ^^^^^^^                                                ^^^^^^^                                                ^^^^^^^                                                ^^^^^^^                              ^^^

            'all': Format<IterationMap[KnownIterationMapKeys], 's'>;
>'all' : "-40" | "-39" | "-38" | "-37" | "-36" | "-35" | "-34" | "-33" | "-32" | "-31" | "-30" | "-29" | "-28" | "-27" | "-26" | "-25" | "-24" | "-23" | "-22" | "-21" | "-20" | "-19" | "-18" | "-17" | "-16" | "-15" | "-14" | "-13" | "-12" | "-11" | "-10" | "-9" | "-8" | "-7" | "-6" | "-5" | "-4" | "-3" | "-2" | "-1" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "16" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "24" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "32" | "33" | "34" | "35" | "36" | "37" | "38" | "39" | "40"
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            '+': Format<IterationMap[PositiveIterationKeys], 's'>;
>'+' : "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "16" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "24" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "32" | "33" | "34" | "35" | "36" | "37" | "38" | "39" | "40"
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            '-': Format<IterationMap[NegativeIterationKeys], 's'>;
>'-' : "-40" | "-39" | "-38" | "-37" | "-36" | "-35" | "-34" | "-33" | "-32" | "-31" | "-30" | "-29" | "-28" | "-27" | "-26" | "-25" | "-24" | "-23" | "-22" | "-21" | "-20" | "-19" | "-18" | "-17" | "-16" | "-15" | "-14" | "-13" | "-12" | "-11" | "-10" | "-9" | "-8" | "-7" | "-6" | "-5" | "-4" | "-3" | "-2" | "-1"
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            '0': Format<IterationMap['0'], 's'>;
>'0' : "0"
>    : ^^^

        };
        'number': {
>'number' : { all: Format<IterationMap[KnownIterationMapKeys], "n">; '+': Format<IterationMap[PositiveIterationKeys], "n">; '-': Format<IterationMap[NegativeIterationKeys], "n">; '0': Format<IterationMap["0"], "n">; }
>         : ^^^^^^^                                                ^^^^^^^                                                ^^^^^^^                                                ^^^^^^^                              ^^^

            'all': Format<IterationMap[KnownIterationMapKeys], 'n'>;
>'all' : 0 | 1 | 3 | 5 | 40 | -40 | 39 | -39 | 38 | -38 | 37 | -37 | 36 | -36 | 35 | -35 | 34 | -34 | 33 | -33 | 32 | -32 | 31 | -31 | 30 | -30 | 29 | -29 | 28 | -28 | 27 | -27 | 26 | -26 | 25 | -25 | 24 | -24 | 23 | -23 | 22 | -22 | 21 | -21 | 20 | -20 | 19 | -19 | 18 | -18 | 17 | -17 | 16 | -16 | 15 | -15 | 14 | -14 | 13 | -13 | 12 | -12 | 11 | -11 | 10 | -10 | 9 | -9 | 8 | -8 | 7 | -7 | 6 | -6 | -5 | 4 | -4 | -3 | 2 | -2 | -1
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            '+': Format<IterationMap[PositiveIterationKeys], 'n'>;
>'+' : 1 | 3 | 5 | 40 | 39 | 38 | 37 | 36 | 35 | 34 | 33 | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 4 | 2
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            '-': Format<IterationMap[NegativeIterationKeys], 'n'>;
>'-' : -40 | -39 | -38 | -37 | -36 | -35 | -34 | -33 | -32 | -31 | -30 | -29 | -28 | -27 | -26 | -25 | -24 | -23 | -22 | -21 | -20 | -19 | -18 | -17 | -16 | -15 | -14 | -13 | -12 | -11 | -10 | -9 | -8 | -7 | -6 | -5 | -4 | -3 | -2 | -1
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            '0': Format<IterationMap['0'], 'n'>;
>'0' : 0
>    : ^

        };
    };
}
declare module "Number/Number" {
>"Number/Number" : typeof import("Number/Number")
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Number = string;
>Number : string
>       : ^^^^^^
}
declare module "Iteration/_Internal" {
>"Iteration/_Internal" : typeof import("Iteration/_Internal")
>                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Formats = 'n' | 's';
>Formats : Formats
>        : ^^^^^^^

    export type Way = '->' | '<-';
>Way : Way
>    : ^^^
}
declare module "List/Prepend" {
>"List/Prepend" : typeof import("List/Prepend")
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type Prepend<L extends List, A extends any> = ((head: A, ...args: L) => any) extends ((...args: infer U) => any) ? U : L;
>Prepend : [head: A, ...args: L]
>        : ^^^^^^^^^^^^^^^^^^^^^
>head : A
>     : ^
>args : L
>     : ^
>args : U
>     : ^
}
declare module "List/_Internal" {
>"List/_Internal" : typeof import("List/_Internal")
>                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Overwrite } from "Object/Overwrite";
>Overwrite : any
>          : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type Naked<L extends List> = Overwrite<Required<L>, L>;
>Naked : { [K in keyof Required<L>]: K extends keyof L ? L[K] : Required<L>[K]; }
>      : ^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}
declare module "List/Tail" {
>"List/Tail" : typeof import("List/Tail")
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type Tail<L extends List> = ((...t: L) => any) extends ((head: any, ...tail: infer LTail) => any) ? LTail : never;
>Tail : Tail<L>
>     : ^^^^^^^
>t : L
>  : ^
>head : any
>tail : LTail
>     : ^^^^^
}
declare module "Iteration/Format" {
>"Iteration/Format" : typeof import("Iteration/Format")
>                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    import { Formats } from "Iteration/_Internal";
>Formats : any
>        : ^^^

    export type Format<I extends Iteration, fmt extends Formats> = {
>Format : Format<I, fmt>
>       : ^^^^^^^^^^^^^^

        's': I[2];
>'s' : I[2]
>    : ^^^^

        'n': I[3];
>'n' : I[3]
>    : ^^^^

    }[fmt];
}
declare module "Iteration/Pos" {
>"Iteration/Pos" : typeof import("Iteration/Pos")
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    import { Format } from "Iteration/Format";
>Format : any
>       : ^^^

    export type Pos<I extends Iteration> = Format<I, 'n'>;
>Pos : I[3]
>    : ^^^^
}
declare module "List/Append" {
>"List/Append" : typeof import("List/Append")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { _Concat } from "List/Concat";
>_Concat : any
>        : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type _Append<L extends List, A extends any> = _Concat<L, [A]>;
>_Append : _Append<L, A>
>        : ^^^^^^^^^^^^^

    export type Append<L extends List, A extends any> = L extends unknown ? A extends unknown ? _Append<L, A> : never : never;
>Append : Append<L, A>
>       : ^^^^^^^^^^^^
}
declare module "List/Reverse" {
>"List/Reverse" : typeof import("List/Reverse")
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Prepend } from "List/Prepend";
>Prepend : any
>        : ^^^

    import { Pos } from "Iteration/Pos";
>Pos : any
>    : ^^^

    import { Next } from "Iteration/Next";
>Next : any
>     : ^^^

    import { Length } from "List/Length";
>Length : any
>       : ^^^

    import { IterationOf } from "Iteration/IterationOf";
>IterationOf : any
>            : ^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    import { Cast } from "Any/Cast";
>Cast : any
>     : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    import { Naked } from "List/_Internal";
>Naked : any
>      : ^^^

    import { Extends } from "Any/Extends";
>Extends : any
>        : ^^^

    type __Reverse<L extends List, LO extends List, I extends Iteration = IterationOf<'0'>> = {
>__Reverse : __Reverse<L, LO, I>
>          : ^^^^^^^^^^^^^^^^^^^

        0: __Reverse<L, Prepend<LO, L[Pos<I>]>, Next<I>>;
>0 : __Reverse<L, [head: L[Pos<I>], ...args: LO], Next<I>>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        1: LO;
>1 : LO
>  : ^^

    }[Extends<Pos<I>, Length<L>>];

    export type _Reverse<L extends List, LO extends List = []> = __Reverse<Naked<L>, LO> extends infer X ? Cast<X, List> : never;
>_Reverse : _Reverse<L, LO>
>         : ^^^^^^^^^^^^^^^

    export type Reverse<L extends List, LO extends List = []> = L extends unknown ? LO extends unknown ? _Reverse<L, LO> : never : never;
>Reverse : Reverse<L, LO>
>        : ^^^^^^^^^^^^^^
}
declare module "List/Concat" {
>"List/Concat" : typeof import("List/Concat")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { _Reverse } from "List/Reverse";
>_Reverse : any
>         : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type _Concat<L extends List, L1 extends List> = _Reverse<_Reverse<L>, L1>;
>_Concat : _Concat<L, L1>
>        : ^^^^^^^^^^^^^^

    export type Concat<L extends List, L1 extends List> = L extends unknown ? L1 extends L1 ? _Concat<L, L1> : never : never;
>Concat : Concat<L, L1>
>       : ^^^^^^^^^^^^^
}
declare module "List/Drop" {
>"List/Drop" : typeof import("List/Drop")
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Tail } from "List/Tail";
>Tail : any
>     : ^^^

    import { Cast } from "Any/Cast";
>Cast : any
>     : ^^^

    import { IterationOf } from "Iteration/IterationOf";
>IterationOf : any
>            : ^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    import { Number } from "Number/Number";
>Number : any
>       : ^^^

    import { Way } from "Iteration/_Internal";
>Way : any
>    : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    import { Pos } from "Iteration/Pos";
>Pos : any
>    : ^^^

    import { Prev } from "Iteration/Prev";
>Prev : any
>     : ^^^

    import { Prepend } from "List/Prepend";
>Prepend : any
>        : ^^^

    import { Naked } from "List/_Internal";
>Naked : any
>      : ^^^

    import { Extends } from "Any/Extends";
>Extends : any
>        : ^^^

    type DropForth<L extends List, N extends Iteration> = {
>DropForth : DropForth<L, N>
>          : ^^^^^^^^^^^^^^^

        0: DropForth<Tail<L>, Prev<N>>;
>0 : DropForth<Tail<L>, Prev<N>>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        1: L;
>1 : L
>  : ^

    }[Extends<0, Pos<N>>];

    type DropBack<L extends List, N extends Iteration, I extends Iteration = Prev<N>, LN extends List = []> = {
>DropBack : DropBack<L, N, I, LN>
>         : ^^^^^^^^^^^^^^^^^^^^^

        0: DropBack<L, N, Prev<I>, Prepend<LN, L[Pos<I>]>>;
>0 : DropBack<L, N, Prev<I>, [head: L[Pos<I>], ...args: LN]>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        1: LN;
>1 : LN
>  : ^^

    }[Extends<-1, Pos<I>>];
>-1 : -1
>   : ^^
>1 : 1
>  : ^

    type __Drop<L extends List, N extends Iteration, way extends Way = '->'> = {
>__Drop : __Drop<L, N, way>
>       : ^^^^^^^^^^^^^^^^^

        '->': DropForth<L, N>;
>'->' : DropForth<L, N>
>     : ^^^^^^^^^^^^^^^

        '<-': DropBack<L, N>;
>'<-' : DropBack<L, N, Prev<N>, []>
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

    }[way];

    export type _Drop<L extends List, N extends Number, way extends Way = '->'> = __Drop<Naked<L>, IterationOf<N>, way> extends infer X ? Cast<X, List> : never;
>_Drop : _Drop<L, N, way>
>      : ^^^^^^^^^^^^^^^^

    export type Drop<L extends List, N extends Number, way extends Way = '->'> = L extends unknown ? N extends unknown ? _Drop<L, N, way> : never : never;
>Drop : Drop<L, N, way>
>     : ^^^^^^^^^^^^^^^
}
declare module "List/Length" {
>"List/Length" : typeof import("List/Length")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { NumberOf } from "Number/NumberOf";
>NumberOf : any
>         : ^^^

    import { Formats } from "Iteration/_Internal";
>Formats : any
>        : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export type Length<L extends List, fmt extends Formats = 'n'> = {
>Length : Length<L, fmt>
>       : ^^^^^^^^^^^^^^

        's': NumberOf<L['length']>;
>'s' : NumberOf<L["length"]>
>    : ^^^^^^^^^^^^^^^^^^^^^

        'n': L['length'];
>'n' : L["length"]
>    : ^^^^^^^^^^^

    }[fmt];
}
declare module "Iteration/Next" {
>"Iteration/Next" : typeof import("Iteration/Next")
>                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { IterationMap } from "Iteration/IterationOf";
>IterationMap : any
>             : ^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    export type Next<I extends Iteration> = IterationMap[I[1]];
>Next : Next<I>
>     : ^^^^^^^
}
declare module "Any/Cast" {
>"Any/Cast" : typeof import("Any/Cast")
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Cast<A1 extends any, A2 extends any> = A1 extends A2 ? A1 : A2;
>Cast : Cast<A1, A2>
>     : ^^^^^^^^^^^^
}
declare module "Function/Parameters" {
>"Function/Parameters" : typeof import("Function/Parameters")
>                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Function } from "Function/Function";
>Function : any
>         : ^^^

    export type Parameters<F extends Function> = F extends ((...args: infer L) => any) ? L : never;
>Parameters : Parameters<F>
>           : ^^^^^^^^^^^^^
>args : L
>     : ^
}
declare module "Function/Return" {
>"Function/Return" : typeof import("Function/Return")
>                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Function } from "Function/Function";
>Function : any
>         : ^^^

    export type Return<F extends Function> = F extends ((...args: any[]) => infer R) ? R : never;
>Return : Return<F>
>       : ^^^^^^^^^
>args : any[]
>     : ^^^^^
}
declare module "Iteration/Prev" {
>"Iteration/Prev" : typeof import("Iteration/Prev")
>                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { IterationMap } from "Iteration/IterationOf";
>IterationMap : any
>             : ^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    export type Prev<I extends Iteration> = IterationMap[I[0]];
>Prev : Prev<I>
>     : ^^^^^^^
}
declare module "Number/NumberOf" {
>"Number/NumberOf" : typeof import("Number/NumberOf")
>                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { IterationMap } from "Iteration/IterationOf";
>IterationMap : any
>             : ^^^

    import { Key } from "Iteration/Key";
>Key : any
>    : ^^^

    import { Pos } from "Iteration/Pos";
>Pos : any
>    : ^^^

    import { Numbers } from "Number/_Internal";
>Numbers : any
>        : ^^^

    export type _NumberOf<N extends number> = {
>_NumberOf : _NumberOf<N>
>          : ^^^^^^^^^^^^

        [K in keyof IterationMap]: Pos<IterationMap[K]> extends N ? Key<IterationMap[K]> : never;
    }[keyof IterationMap];

    export type NumberOf<N extends number> = N extends Numbers['number']['all'] ? _NumberOf<N> : string;
>NumberOf : NumberOf<N>
>         : ^^^^^^^^^^^
}
declare module "Object/_Internal" {
>"Object/_Internal" : typeof import("Object/_Internal")
>                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Modx = ['?' | '!', 'W' | 'R'];
>Modx : Modx
>     : ^^^^

    export type Depth = 'flat' | 'deep';
>Depth : Depth
>      : ^^^^^

    export type Empty<O extends object> = {
>Empty : Empty<O>
>      : ^^^^^^^^

        [K in keyof O]: undefined;
    };
}
declare module "Iteration/IterationOf" {
>"Iteration/IterationOf" : typeof import("Iteration/IterationOf")
>                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Number } from "Number/Number";
>Number : any
>       : ^^^

    export type IterationMap = {
>IterationMap : IterationMap
>             : ^^^^^^^^^^^^

        '-40': ['__', '-39', '-40', -40, '-'];
>'-40' : ["__", "-39", "-40", -40, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-40 : -40
>    : ^^^
>40 : 40
>   : ^^

        '-39': ['-40', '-38', '-39', -39, '-'];
>'-39' : ["-40", "-38", "-39", -39, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-39 : -39
>    : ^^^
>39 : 39
>   : ^^

        '-38': ['-39', '-37', '-38', -38, '-'];
>'-38' : ["-39", "-37", "-38", -38, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-38 : -38
>    : ^^^
>38 : 38
>   : ^^

        '-37': ['-38', '-36', '-37', -37, '-'];
>'-37' : ["-38", "-36", "-37", -37, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-37 : -37
>    : ^^^
>37 : 37
>   : ^^

        '-36': ['-37', '-35', '-36', -36, '-'];
>'-36' : ["-37", "-35", "-36", -36, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-36 : -36
>    : ^^^
>36 : 36
>   : ^^

        '-35': ['-36', '-34', '-35', -35, '-'];
>'-35' : ["-36", "-34", "-35", -35, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-35 : -35
>    : ^^^
>35 : 35
>   : ^^

        '-34': ['-35', '-33', '-34', -34, '-'];
>'-34' : ["-35", "-33", "-34", -34, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-34 : -34
>    : ^^^
>34 : 34
>   : ^^

        '-33': ['-34', '-32', '-33', -33, '-'];
>'-33' : ["-34", "-32", "-33", -33, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-33 : -33
>    : ^^^
>33 : 33
>   : ^^

        '-32': ['-33', '-31', '-32', -32, '-'];
>'-32' : ["-33", "-31", "-32", -32, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-32 : -32
>    : ^^^
>32 : 32
>   : ^^

        '-31': ['-32', '-30', '-31', -31, '-'];
>'-31' : ["-32", "-30", "-31", -31, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-31 : -31
>    : ^^^
>31 : 31
>   : ^^

        '-30': ['-31', '-29', '-30', -30, '-'];
>'-30' : ["-31", "-29", "-30", -30, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-30 : -30
>    : ^^^
>30 : 30
>   : ^^

        '-29': ['-30', '-28', '-29', -29, '-'];
>'-29' : ["-30", "-28", "-29", -29, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-29 : -29
>    : ^^^
>29 : 29
>   : ^^

        '-28': ['-29', '-27', '-28', -28, '-'];
>'-28' : ["-29", "-27", "-28", -28, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-28 : -28
>    : ^^^
>28 : 28
>   : ^^

        '-27': ['-28', '-26', '-27', -27, '-'];
>'-27' : ["-28", "-26", "-27", -27, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-27 : -27
>    : ^^^
>27 : 27
>   : ^^

        '-26': ['-27', '-25', '-26', -26, '-'];
>'-26' : ["-27", "-25", "-26", -26, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-26 : -26
>    : ^^^
>26 : 26
>   : ^^

        '-25': ['-26', '-24', '-25', -25, '-'];
>'-25' : ["-26", "-24", "-25", -25, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-25 : -25
>    : ^^^
>25 : 25
>   : ^^

        '-24': ['-25', '-23', '-24', -24, '-'];
>'-24' : ["-25", "-23", "-24", -24, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-24 : -24
>    : ^^^
>24 : 24
>   : ^^

        '-23': ['-24', '-22', '-23', -23, '-'];
>'-23' : ["-24", "-22", "-23", -23, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-23 : -23
>    : ^^^
>23 : 23
>   : ^^

        '-22': ['-23', '-21', '-22', -22, '-'];
>'-22' : ["-23", "-21", "-22", -22, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-22 : -22
>    : ^^^
>22 : 22
>   : ^^

        '-21': ['-22', '-20', '-21', -21, '-'];
>'-21' : ["-22", "-20", "-21", -21, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-21 : -21
>    : ^^^
>21 : 21
>   : ^^

        '-20': ['-21', '-19', '-20', -20, '-'];
>'-20' : ["-21", "-19", "-20", -20, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-20 : -20
>    : ^^^
>20 : 20
>   : ^^

        '-19': ['-20', '-18', '-19', -19, '-'];
>'-19' : ["-20", "-18", "-19", -19, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-19 : -19
>    : ^^^
>19 : 19
>   : ^^

        '-18': ['-19', '-17', '-18', -18, '-'];
>'-18' : ["-19", "-17", "-18", -18, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-18 : -18
>    : ^^^
>18 : 18
>   : ^^

        '-17': ['-18', '-16', '-17', -17, '-'];
>'-17' : ["-18", "-16", "-17", -17, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-17 : -17
>    : ^^^
>17 : 17
>   : ^^

        '-16': ['-17', '-15', '-16', -16, '-'];
>'-16' : ["-17", "-15", "-16", -16, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-16 : -16
>    : ^^^
>16 : 16
>   : ^^

        '-15': ['-16', '-14', '-15', -15, '-'];
>'-15' : ["-16", "-14", "-15", -15, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-15 : -15
>    : ^^^
>15 : 15
>   : ^^

        '-14': ['-15', '-13', '-14', -14, '-'];
>'-14' : ["-15", "-13", "-14", -14, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-14 : -14
>    : ^^^
>14 : 14
>   : ^^

        '-13': ['-14', '-12', '-13', -13, '-'];
>'-13' : ["-14", "-12", "-13", -13, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-13 : -13
>    : ^^^
>13 : 13
>   : ^^

        '-12': ['-13', '-11', '-12', -12, '-'];
>'-12' : ["-13", "-11", "-12", -12, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-12 : -12
>    : ^^^
>12 : 12
>   : ^^

        '-11': ['-12', '-10', '-11', -11, '-'];
>'-11' : ["-12", "-10", "-11", -11, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-11 : -11
>    : ^^^
>11 : 11
>   : ^^

        '-10': ['-11', '-9', '-10', -10, '-'];
>'-10' : ["-11", "-9", "-10", -10, "-"]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-10 : -10
>    : ^^^
>10 : 10
>   : ^^

        '-9': ['-10', '-8', '-9', -9, '-'];
>'-9' : ["-10", "-8", "-9", -9, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-9 : -9
>   : ^^
>9 : 9
>  : ^

        '-8': ['-9', '-7', '-8', -8, '-'];
>'-8' : ["-9", "-7", "-8", -8, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-8 : -8
>   : ^^
>8 : 8
>  : ^

        '-7': ['-8', '-6', '-7', -7, '-'];
>'-7' : ["-8", "-6", "-7", -7, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-7 : -7
>   : ^^
>7 : 7
>  : ^

        '-6': ['-7', '-5', '-6', -6, '-'];
>'-6' : ["-7", "-5", "-6", -6, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-6 : -6
>   : ^^
>6 : 6
>  : ^

        '-5': ['-6', '-4', '-5', -5, '-'];
>'-5' : ["-6", "-4", "-5", -5, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-5 : -5
>   : ^^
>5 : 5
>  : ^

        '-4': ['-5', '-3', '-4', -4, '-'];
>'-4' : ["-5", "-3", "-4", -4, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-4 : -4
>   : ^^
>4 : 4
>  : ^

        '-3': ['-4', '-2', '-3', -3, '-'];
>'-3' : ["-4", "-2", "-3", -3, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-3 : -3
>   : ^^
>3 : 3
>  : ^

        '-2': ['-3', '-1', '-2', -2, '-'];
>'-2' : ["-3", "-1", "-2", -2, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>-2 : -2
>   : ^^
>2 : 2
>  : ^

        '-1': ['-2', '0', '-1', -1, '-'];
>'-1' : ["-2", "0", "-1", -1, "-"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>-1 : -1
>   : ^^
>1 : 1
>  : ^

        '0': ['-1', '1', '0', 0, '0'];
>'0' : ["-1", "1", "0", 0, "0"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^^

        '1': ['0', '2', '1', 1, '+'];
>'1' : ["0", "2", "1", 1, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '2': ['1', '3', '2', 2, '+'];
>'2' : ["1", "3", "2", 2, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '3': ['2', '4', '3', 3, '+'];
>'3' : ["2", "4", "3", 3, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '4': ['3', '5', '4', 4, '+'];
>'4' : ["3", "5", "4", 4, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '5': ['4', '6', '5', 5, '+'];
>'5' : ["4", "6", "5", 5, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '6': ['5', '7', '6', 6, '+'];
>'6' : ["5", "7", "6", 6, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '7': ['6', '8', '7', 7, '+'];
>'7' : ["6", "8", "7", 7, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '8': ['7', '9', '8', 8, '+'];
>'8' : ["7", "9", "8", 8, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^

        '9': ['8', '10', '9', 9, '+'];
>'9' : ["8", "10", "9", 9, "+"]
>    : ^^^^^^^^^^^^^^^^^^^^^^^^

        '10': ['9', '11', '10', 10, '+'];
>'10' : ["9", "11", "10", 10, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^

        '11': ['10', '12', '11', 11, '+'];
>'11' : ["10", "12", "11", 11, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '12': ['11', '13', '12', 12, '+'];
>'12' : ["11", "13", "12", 12, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '13': ['12', '14', '13', 13, '+'];
>'13' : ["12", "14", "13", 13, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '14': ['13', '15', '14', 14, '+'];
>'14' : ["13", "15", "14", 14, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '15': ['14', '16', '15', 15, '+'];
>'15' : ["14", "16", "15", 15, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '16': ['15', '17', '16', 16, '+'];
>'16' : ["15", "17", "16", 16, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '17': ['16', '18', '17', 17, '+'];
>'17' : ["16", "18", "17", 17, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '18': ['17', '19', '18', 18, '+'];
>'18' : ["17", "19", "18", 18, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '19': ['18', '20', '19', 19, '+'];
>'19' : ["18", "20", "19", 19, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '20': ['19', '21', '20', 20, '+'];
>'20' : ["19", "21", "20", 20, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '21': ['20', '22', '21', 21, '+'];
>'21' : ["20", "22", "21", 21, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '22': ['21', '23', '22', 22, '+'];
>'22' : ["21", "23", "22", 22, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '23': ['22', '24', '23', 23, '+'];
>'23' : ["22", "24", "23", 23, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '24': ['23', '25', '24', 24, '+'];
>'24' : ["23", "25", "24", 24, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '25': ['24', '26', '25', 25, '+'];
>'25' : ["24", "26", "25", 25, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '26': ['25', '27', '26', 26, '+'];
>'26' : ["25", "27", "26", 26, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '27': ['26', '28', '27', 27, '+'];
>'27' : ["26", "28", "27", 27, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '28': ['27', '29', '28', 28, '+'];
>'28' : ["27", "29", "28", 28, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '29': ['28', '30', '29', 29, '+'];
>'29' : ["28", "30", "29", 29, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '30': ['29', '31', '30', 30, '+'];
>'30' : ["29", "31", "30", 30, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '31': ['30', '32', '31', 31, '+'];
>'31' : ["30", "32", "31", 31, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '32': ['31', '33', '32', 32, '+'];
>'32' : ["31", "33", "32", 32, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '33': ['32', '34', '33', 33, '+'];
>'33' : ["32", "34", "33", 33, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '34': ['33', '35', '34', 34, '+'];
>'34' : ["33", "35", "34", 34, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '35': ['34', '36', '35', 35, '+'];
>'35' : ["34", "36", "35", 35, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '36': ['35', '37', '36', 36, '+'];
>'36' : ["35", "37", "36", 36, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '37': ['36', '38', '37', 37, '+'];
>'37' : ["36", "38", "37", 37, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '38': ['37', '39', '38', 38, '+'];
>'38' : ["37", "39", "38", 38, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '39': ['38', '40', '39', 39, '+'];
>'39' : ["38", "40", "39", 39, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '40': ['39', '__', '40', 40, '+'];
>'40' : ["39", "__", "40", 40, "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        '__': ['__', '__', string, number, '-' | '0' | '+'];
>'__' : ["__", "__", string, number, "0" | "-" | "+"]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    };

    export type IterationOf<N extends Number> = N extends keyof IterationMap ? IterationMap[N] : IterationMap['__'];
>IterationOf : IterationOf<N>
>            : ^^^^^^^^^^^^^^
}
declare module "Iteration/Iteration" {
>"Iteration/Iteration" : typeof import("Iteration/Iteration")
>                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { IterationMap } from "Iteration/IterationOf";
>IterationMap : any
>             : ^^^

    export type Iteration = [keyof IterationMap, keyof IterationMap, string, number, '-' | '0' | '+'];
>Iteration : Iteration
>          : ^^^^^^^^^
}
declare module "Iteration/Key" {
>"Iteration/Key" : typeof import("Iteration/Key")
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    import { Format } from "Iteration/Format";
>Format : any
>       : ^^^

    export type Key<I extends Iteration> = Format<I, 's'>;
>Key : I[2]
>    : ^^^^
}
declare module "List/NonNullable" {
>"List/NonNullable" : typeof import("List/NonNullable")
>                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Depth } from "Object/_Internal";
>Depth : any
>      : ^^^

    import { NonNullable as ONonNullable } from "Object/NonNullable";
>NonNullable : any
>            : ^^^
>ONonNullable : any
>             : ^^^

    import { ListOf } from "Object/ListOf";
>ListOf : any
>       : ^^^

    import { Cast } from "Any/Cast";
>Cast : any
>     : ^^^

    import { Key } from "Any/Key";
>Key : any
>    : ^^^

    import { ObjectOf } from "List/ObjectOf";
>ObjectOf : any
>         : ^^^

    import { Implements } from "Any/Implements";
>Implements : any
>           : ^^^

    import { Keys } from "List/Keys";
>Keys : any
>     : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    import { NumberOf } from "Any/_Internal";
>NumberOf : any
>         : ^^^

    export type NonNullable<L extends List, K extends Key = Key, depth extends Depth = 'flat'> = {
>NonNullable : NonNullable<L, K, depth>
>            : ^^^^^^^^^^^^^^^^^^^^^^^^

        1: Cast<ONonNullable<L, Key, depth>, List>;
>1 : Cast<ONonNullable<L, Key, depth>, List>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        0: ListOf<ONonNullable<ObjectOf<L>, NumberOf<K>, depth>>;
>0 : ListOf<ONonNullable<ObjectOf<L>, NumberOf<K>, depth>>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    }[Implements<Keys<L>, K>] & {};
}
declare module "Any/Type" {
>"Any/Type" : typeof import("Any/Type")
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^

    const symbol: unique symbol;
>symbol : unique symbol
>       : ^^^^^^^^^^^^^

    export type Type<A extends any, Id extends string> = A & {
>Type : Type<A, Id>
>     : ^^^^^^^^^^^

        [K in typeof symbol]: Id;
>symbol : unique symbol
>       : ^^^^^^^^^^^^^

    };
}
declare module "Any/x" {
>"Any/x" : typeof import("Any/x")
>        : ^^^^^^^^^^^^^^^^^^^^^^

    import { Type } from "Any/Type";
>Type : any
>     : ^^^

    export type x = Type<{}, 'x'>;
>x : { [symbol]: "x"; }
>  : ^^^^^^^^^^^^^^^^^^
}
declare module "List/List" {
>"List/List" : typeof import("List/List")
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type List<A = any> = ReadonlyArray<A>;
>List : List<A>
>     : ^^^^^^^
}
declare module "Function/Function" {
>"Function/Function" : typeof import("Function/Function")
>                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    export interface Function<P extends List = any, R extends any = any> {
        (...args: P): R;
>args : P
>     : ^
    }
}
declare module "Any/Extends" {
>"Any/Extends" : typeof import("Any/Extends")
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    export type Extends<A1 extends any, A2 extends any> = [A1] extends [never] ? 0 : A1 extends A2 ? 1 : 0;
>Extends : Extends<A1, A2>
>        : ^^^^^^^^^^^^^^^
}

declare module "Function/Curry" {
>"Function/Curry" : typeof import("Function/Curry")
>                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    import { Pos } from "Iteration/Pos";
>Pos : any
>    : ^^^

    import { _Append } from "List/Append";
>_Append : any
>        : ^^^

    import { _Concat } from "List/Concat";
>_Concat : any
>        : ^^^

    import { _Drop } from "List/Drop";
>_Drop : any
>      : ^^^

    import { Length } from "List/Length";
>Length : any
>       : ^^^

    import { Next } from "Iteration/Next";
>Next : any
>     : ^^^

    import { Cast } from "Any/Cast";
>Cast : any
>     : ^^^

    import { Parameters } from "Function/Parameters";
>Parameters : any
>           : ^^^

    import { Return } from "Function/Return";
>Return : any
>       : ^^^

    import { IterationOf } from "Iteration/IterationOf";
>IterationOf : any
>            : ^^^

    import { Iteration } from "Iteration/Iteration";
>Iteration : any
>          : ^^^

    import { Key } from "Iteration/Key";
>Key : any
>    : ^^^

    import { NonNullable } from "List/NonNullable";
>NonNullable : any
>            : ^^^

    import { x } from "Any/x";
>x : any
>  : ^^^

    import { List } from "List/List";
>List : any
>     : ^^^

    import { Function } from "Function/Function";
>Function : any
>         : ^^^

    import { Extends } from "Any/Extends";
>Extends : any
>        : ^^^

    type GapOf<L1 extends List, L2 extends List, LN extends List, I extends Iteration = IterationOf<'0'>> = L1[Pos<I>] extends x ? _Append<LN, L2[Pos<I>]> : LN;
>GapOf : GapOf<L1, L2, LN, I>
>      : ^^^^^^^^^^^^^^^^^^^^

    type _GapsOf<L1 extends List, L2 extends List, LN extends List = [], I extends Iteration = IterationOf<'0'>> = {
>_GapsOf : _GapsOf<L1, L2, LN, I>
>        : ^^^^^^^^^^^^^^^^^^^^^^

        0: _GapsOf<L1, L2, GapOf<L1, L2, LN, I>, Next<I>>;
>0 : _GapsOf<L1, L2, GapOf<L1, L2, LN, I>, Next<I>>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        1: _Concat<LN, _Drop<L2, Key<I>>>;
>1 : _Concat<LN, _Drop<L2, Key<I>>>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    }[Extends<Pos<I>, Length<L1>>];

    type GapsOf<L1 extends List, L2 extends List> = _GapsOf<L1, L2> extends infer X ? Cast<X, List> : never;
>GapsOf : GapsOf<L1, L2>
>       : ^^^^^^^^^^^^^^

    type Gaps<L extends List> = NonNullable<{
>Gaps : Gaps<L>
>     : ^^^^^^^

        [K in keyof L]?: L[K] | x;
    }>;

    export type Curry<F extends Function> = <L extends List>(...args: Cast<L, Gaps<Parameters<F>>>) => GapsOf<L, Parameters<F>> extends infer G ? Length<Cast<G, List>> extends infer L ? L extends 0 ? Return<F> : L extends 1 ? Curry<(...args: Cast<G, List>) => Return<F>> & ((...args: Cast<G, List>) => Return<F>) : Curry<(...args: Cast<G, List>) => Return<F>> : never : never;
>Curry : Curry<F>
>      : ^^^^^^^^
>args : Cast<L, Gaps<Parameters<F>>>
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>args : Cast<G, List>
>     : ^^^^^^^^^^^^^
>args : Cast<G, List>
>     : ^^^^^^^^^^^^^
>args : Cast<G, List>
>     : ^^^^^^^^^^^^^
}



