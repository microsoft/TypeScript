//// [tests/cases/compiler/reflexiveIdentityRelation.ts] ////

=== reflexiveIdentityRelation.ts ===
namespace reflexiveIdentityRelation {
    type Equals<A, B> = (<T>() => T extends B ? 1 : 0) extends (<T>() => T extends A ? 1 : 0) ? true : false;
>Equals : Equals<A, B>
>       : ^^^^^^^^^^^^
>true : true
>     : ^^^^
>false : false
>      : ^^^^^

    type Intersection = Equals<{a: 1} & {a: 1}, {a: 1}>;  // true
>Intersection : true
>             : ^^^^
>a : 1
>  : ^
>a : 1
>  : ^
>a : 1
>  : ^

    type Union = Equals<{a: 1} | {a: 1}, {a: 1}>;  // true
>Union : true
>      : ^^^^
>a : 1
>  : ^
>a : 1
>  : ^
>a : 1
>  : ^

    type UnionOfIntersection = Equals<{a: 1} & {b: 2} | {a: 1} & {b: 2}, {a: 1} & {b: 2}>;  // true
>UnionOfIntersection : true
>                    : ^^^^
>a : 1
>  : ^
>b : 2
>  : ^
>a : 1
>  : ^
>b : 2
>  : ^
>a : 1
>  : ^
>b : 2
>  : ^

    // The intersection distributes to `{a: 1} & {a: 1} | {a: 1} & {b: 2} | {b: 2} & {a: 1} | {b: 2} & {b: 2}`
    // which is not identical to `{a: 1} | {b: 2}`
    type IntersectionOfUnion = Equals<({a: 1} | {b: 2}) & ({a: 1} | {b: 2}), {a: 1} | {b: 2}>;  // false
>IntersectionOfUnion : false
>                    : ^^^^^
>a : 1
>  : ^
>b : 2
>  : ^
>a : 1
>  : ^
>b : 2
>  : ^
>a : 1
>  : ^
>b : 2
>  : ^
}

