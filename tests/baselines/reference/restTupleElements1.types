=== tests/cases/conformance/types/tuple/restTupleElements1.ts ===
type T00 = [string?];
>T00 : [(string | undefined)?]

type T01 = [string, string?];
>T01 : [string, (string | undefined)?]

type T02 = [string?, string];  // Error
>T02 : [string | undefined, string]

type T03 = [...string[]];
>T03 : string[]

type T04 = [...[...string[]]];
>T04 : string[]

type T05 = [...[...[...string[]]]];
>T05 : string[]

type T06 = [string, ...string[]];
>T06 : [string, ...string[]]

type T07 = [...string[], string];  // Error
>T07 : [string[], string]

type T08 = [...string];  // Error
>T08 : string[]

type T09 = [...string?];  // Error
>T09 : (string | null)[]

type T10 = [string, ...[...string[]]];
>T10 : [string, ...string[]]

type T11 = [string, ...[...[...string[]]]];
>T11 : [string, ...string[]]

type T15 = [boolean, number, ...string[]];
>T15 : [boolean, number, ...string[]]

type L15 = T15["length"];  // number
>L15 : number

declare function assign<T, S extends T>(): void;
>assign : <T, S extends T>() => void

assign<number[], [...number[]]>();
>assign<number[], [...number[]]>() : void
>assign : <T, S extends T>() => void

assign<number[], [number, ...number[]]>();
>assign<number[], [number, ...number[]]>() : void
>assign : <T, S extends T>() => void

assign<[...number[]], number[]>();
>assign<[...number[]], number[]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], number[]>();  // Error
>assign<[number, ...number[]], number[]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], []>();  // Error
>assign<[number, ...number[]], []>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], [number]>();
>assign<[number, ...number[]], [number]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], [number, number]>();
>assign<[number, ...number[]], [number, number]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], [number, number, ...number[]]>();
>assign<[number, ...number[]], [number, number, ...number[]]>() : void
>assign : <T, S extends T>() => void

assign<[number], [...number[]]>();  // Error
>assign<[number], [...number[]]>() : void
>assign : <T, S extends T>() => void

assign<[number], [number, ...number[]]>();  // Error
>assign<[number], [number, ...number[]]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], [number, ...string[]]>();  // Error
>assign<[number, ...number[]], [number, ...string[]]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], [string, ...number[]]>();  // Error
>assign<[number, ...number[]], [string, ...number[]]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], [number, number, string]>();  // Error
>assign<[number, ...number[]], [number, number, string]>() : void
>assign : <T, S extends T>() => void

assign<[number, ...number[]], [number, number, number, string]>();  // Error
>assign<[number, ...number[]], [number, number, number, string]>() : void
>assign : <T, S extends T>() => void

type T20 = [number, string, ...boolean[]];
>T20 : [number, string, ...boolean[]]

type T21 = T20[0];
>T21 : number

type T22 = T20[0 | 1];
>T22 : string | number

type T23 = T20[0 | 1 | 2];
>T23 : string | number | boolean

type T24 = T20[0 | 1 | 2 | 3];
>T24 : string | number | boolean

type T25 = T20[1 | 2 | 3];
>T25 : string | boolean

type T26 = T20[2 | 3];
>T26 : boolean

type T27 = T20[3];
>T27 : boolean

type T28 = T20[number];
>T28 : string | number | boolean

declare const t: T20;
>t : [number, string, ...boolean[]]

declare const x: number;
>x : number

let e0 = t[0];  // number
>e0 : number
>t[0] : number
>t : [number, string, ...boolean[]]
>0 : 0

let e1 = t[1];  // string
>e1 : string
>t[1] : string
>t : [number, string, ...boolean[]]
>1 : 1

let e2 = t[2];  // boolean
>e2 : boolean
>t[2] : boolean
>t : [number, string, ...boolean[]]
>2 : 2

let e3 = t[3];  // boolean
>e3 : boolean
>t[3] : boolean
>t : [number, string, ...boolean[]]
>3 : 3

let ex = t[x];  // number | string | boolean
>ex : string | number | boolean
>t[x] : string | number | boolean
>t : [number, string, ...boolean[]]
>x : number

declare function f0<T, U>(x: [T, ...U[]]): [T, U];
>f0 : <T, U>(x: [T, ...U[]]) => [T, U]
>x : [T, ...U[]]

f0([]);  // Error
>f0([]) : [{}, {}]
>f0 : <T, U>(x: [T, ...U[]]) => [T, U]
>[] : []

f0([1]);
>f0([1]) : [number, {}]
>f0 : <T, U>(x: [T, ...U[]]) => [T, U]
>[1] : [number]
>1 : 1

f0([1, 2, 3]);
>f0([1, 2, 3]) : [number, number]
>f0 : <T, U>(x: [T, ...U[]]) => [T, U]
>[1, 2, 3] : [number, number, number]
>1 : 1
>2 : 2
>3 : 3

f0([1, "hello", true]);
>f0([1, "hello", true]) : [number, string | boolean]
>f0 : <T, U>(x: [T, ...U[]]) => [T, U]
>[1, "hello", true] : [number, string, true]
>1 : 1
>"hello" : "hello"
>true : true

declare function f1(a: [(x: number) => number, ...((x: string) => number)[]]): void;
>f1 : (a: [(x: number) => number, ...((x: string) => number)[]]) => void
>a : [(x: number) => number, ...((x: string) => number)[]]
>x : number
>x : string

declare function f2(...a: [(x: number) => number, ...((x: string) => number)[]]): void;
>f2 : (a_0: (x: number) => number, ...a_1: ((x: string) => number)[]) => void
>a : [(x: number) => number, ...((x: string) => number)[]]
>x : number
>x : string

f1([x => x * 2, x => x.length, x => x.charCodeAt(0)]);
>f1([x => x * 2, x => x.length, x => x.charCodeAt(0)]) : void
>f1 : (a: [(x: number) => number, ...((x: string) => number)[]]) => void
>[x => x * 2, x => x.length, x => x.charCodeAt(0)] : [(x: number) => number, (x: string) => number, (x: string) => number]
>x => x * 2 : (x: number) => number
>x : number
>x * 2 : number
>x : number
>2 : 2
>x => x.length : (x: string) => number
>x : string
>x.length : number
>x : string
>length : number
>x => x.charCodeAt(0) : (x: string) => number
>x : string
>x.charCodeAt(0) : number
>x.charCodeAt : (index: number) => number
>x : string
>charCodeAt : (index: number) => number
>0 : 0

f2(x => x * 2, x => x.length, x => x.charCodeAt(0));
>f2(x => x * 2, x => x.length, x => x.charCodeAt(0)) : void
>f2 : (a_0: (x: number) => number, ...a_1: ((x: string) => number)[]) => void
>x => x * 2 : (x: number) => number
>x : number
>x * 2 : number
>x : number
>2 : 2
>x => x.length : (x: string) => number
>x : string
>x.length : number
>x : string
>length : number
>x => x.charCodeAt(0) : (x: string) => number
>x : string
>x.charCodeAt(0) : number
>x.charCodeAt : (index: number) => number
>x : string
>charCodeAt : (index: number) => number
>0 : 0

