//// [tests/cases/compiler/reverseMappedThisLeak.ts] ////

=== reverseMappedThisLeak.ts ===
declare function test<T extends Record<string, unknown>>(obj:{
>test : <T extends Record<string, unknown>>(obj: { [K in keyof T]: () => T[K]; }) => T
>     : ^ ^^^^^^^^^                       ^^   ^^                               ^^^^^ 
>obj : { [K in keyof T]: () => T[K]; }
>    : ^^^ ^^^^^^^^^^^^^^^^^^^^    ^^^

  [K in keyof T]: () => T[K];
}): T;

const obj = test({
>obj : { a: number; b: T[string]; }
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>test({  a() {    return 1;  },  b() {    return this.a();    // Expected: number    // Actual: T[string] (bug)  }}) : { a: number; b: T[string]; }
>                                                                                                                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>test : <T extends Record<string, unknown>>(obj: { [K in keyof T]: () => T[K]; }) => T
>     : ^ ^^^^^^^^^                       ^^   ^^                               ^^^^^ 
>{  a() {    return 1;  },  b() {    return this.a();    // Expected: number    // Actual: T[string] (bug)  }} : { a(): number; b(): T[string]; }
>                                                                                                              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  a() {
>a : () => number
>  : ^^^^^^^^^^^^

    return 1;
>1 : 1
>  : ^

  },
  b() {
>b : () => T[string]
>  : ^^^^^^^^^^^^^^^

    return this.a();
>this.a() : number
>         : ^^^^^^
>this.a : () => number
>       : ^^^^^^^^^^^^
>this : { a: () => number; b: () => T[string]; }
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>a : () => number
>  : ^^^^^^^^^^^^

    // Expected: number
    // Actual: T[string] (bug)
  }
});

obj.b(); // should be `number`, but currently inferred as `T[string]`
>obj.b() : any
>        : ^^^
>obj.b : T[string]
>      : ^^^^^^^^^
>obj : { a: number; b: T[string]; }
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>b : T[string]
>  : ^^^^^^^^^

