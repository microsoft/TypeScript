//// [tests/cases/compiler/reverseMappedTypeInferFromFilteringNameType1.ts] ////

=== reverseMappedTypeInferFromFilteringNameType1.ts ===
declare class User {
>User : User
>     : ^^^^

  public name: string;
>name : string
>     : ^^^^^^

  public last: string;
>last : string
>     : ^^^^^^

  public age: number;
>age : number
>    : ^^^^^^
}

type AllowedNeeds<T> = {
>AllowedNeeds : AllowedNeeds<T>
>             : ^^^^^^^^^^^^^^^

  [K in keyof T as K & keyof User]: T[K];
};

declare function extend<T>(
>extend : <T>(input: { [K in keyof T]: { needs: AllowedNeeds<T[K]>; compute: (x: Pick<User, keyof T[K] & keyof User>) => any; }; }) => T
>       : ^ ^^     ^^                                                                                                             ^^^^^ 

  input: {
>input : { [K in keyof T]: { needs: AllowedNeeds<T[K]>; compute: (x: Pick<User, keyof T[K] & keyof User>) => any; }; }
>      : ^^^ ^^^^^^^^^^^^^^^^^^^^^^^                  ^^^^^^^^^^^                                               ^^^^^^

    [K in keyof T]: {
      needs: AllowedNeeds<T[K]>
>needs : AllowedNeeds<T[K]>
>      : ^^^^^^^^^^^^^^^^^^

      compute: (x: Pick<User, keyof T[K] & keyof User>) => any;
>compute : (x: Pick<User, keyof T[K] & keyof User>) => any
>        : ^ ^^                                   ^^^^^   
>x : Pick<User, keyof T[K] & keyof User>
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    };
  }
): T

const inferred1 = extend({
>inferred1 : { fullName: { name: boolean; last: boolean; }; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>extend({  fullName: {    needs: {      name: true,      last: true,    },    compute: (user) => `${user.name} ${user.last}`,  },}) : { fullName: { name: boolean; last: boolean; }; }
>                                                                                                                                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>extend : <T>(input: { [K in keyof T]: { needs: AllowedNeeds<T[K]>; compute: (x: Pick<User, keyof T[K] & keyof User>) => any; }; }) => T
>       : ^ ^^     ^^                                                                                                             ^^^^^ 
>{  fullName: {    needs: {      name: true,      last: true,    },    compute: (user) => `${user.name} ${user.last}`,  },} : { fullName: { needs: { name: true; last: true; }; compute: (user: Pick<User, "name" | "last">) => string; }; }
>                                                                                                                           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  fullName: {
>fullName : { needs: { name: true; last: true; }; compute: (user: Pick<User, "name" | "last">) => string; }
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{    needs: {      name: true,      last: true,    },    compute: (user) => `${user.name} ${user.last}`,  } : { needs: { name: true; last: true; }; compute: (user: Pick<User, "name" | "last">) => string; }
>                                                                                                            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    needs: {
>needs : { name: true; last: true; }
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{      name: true,      last: true,    } : { name: true; last: true; }
>                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

      name: true,
>name : true
>     : ^^^^
>true : true
>     : ^^^^

      last: true,
>last : true
>     : ^^^^
>true : true
>     : ^^^^

    },
    compute: (user) => `${user.name} ${user.last}`,
>compute : (user: Pick<User, "name" | "last">) => string
>        : ^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>(user) => `${user.name} ${user.last}` : (user: Pick<User, "name" | "last">) => string
>                                      : ^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>user : Pick<User, "name" | "last">
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>`${user.name} ${user.last}` : string
>                            : ^^^^^^
>user.name : string
>          : ^^^^^^
>user : Pick<User, "name" | "last">
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>name : string
>     : ^^^^^^
>user.last : string
>          : ^^^^^^
>user : Pick<User, "name" | "last">
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>last : string
>     : ^^^^^^

  },
});

const inferred2 = extend({
>inferred2 : { fullName: { last: boolean; }; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>extend({  fullName: {    needs: {      last: true,      doesntExist: true // error    },    compute: (user) => {},  },}) : { fullName: { last: boolean; }; }
>                                                                                                                         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>extend : <T>(input: { [K in keyof T]: { needs: AllowedNeeds<T[K]>; compute: (x: Pick<User, keyof T[K] & keyof User>) => any; }; }) => T
>       : ^ ^^     ^^                                                                                                             ^^^^^ 
>{  fullName: {    needs: {      last: true,      doesntExist: true // error    },    compute: (user) => {},  },} : { fullName: { needs: { last: true; doesntExist: boolean; }; compute: (user: Pick<User, "last">) => void; }; }
>                                                                                                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  fullName: {
>fullName : { needs: { last: true; doesntExist: boolean; }; compute: (user: Pick<User, "last">) => void; }
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{    needs: {      last: true,      doesntExist: true // error    },    compute: (user) => {},  } : { needs: { last: true; doesntExist: boolean; }; compute: (user: Pick<User, "last">) => void; }
>                                                                                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    needs: {
>needs : { last: true; doesntExist: boolean; }
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{      last: true,      doesntExist: true // error    } : { last: true; doesntExist: boolean; }
>                                                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

      last: true,
>last : true
>     : ^^^^
>true : true
>     : ^^^^

      doesntExist: true // error
>doesntExist : boolean
>            : ^^^^^^^
>true : true
>     : ^^^^

    },
    compute: (user) => {},
>compute : (user: Pick<User, "last">) => void
>        : ^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>(user) => {} : (user: Pick<User, "last">) => void
>             : ^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>user : Pick<User, "last">
>     : ^^^^^^^^^^^^^^^^^^

  },
});

