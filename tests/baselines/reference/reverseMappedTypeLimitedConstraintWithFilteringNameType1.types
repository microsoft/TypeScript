//// [tests/cases/compiler/reverseMappedTypeLimitedConstraintWithFilteringNameType1.ts] ////

=== reverseMappedTypeLimitedConstraintWithFilteringNameType1.ts ===
type XNumber = { x: number };
>XNumber : { x: number; }
>x : number

declare function foo<T extends XNumber>(props: {
>foo : <T extends XNumber>(props: { [K in keyof T as K & "x"]: T[K]; }) => T
>props : { [K in keyof T as K & "x"]: T[K]; }

  [K in keyof T as K & keyof XNumber]: T[K];
}): T;
const foo1 = foo({ x: 1, y: "foo" });
>foo1 : { x: 1; }
>foo({ x: 1, y: "foo" }) : { x: 1; }
>foo : <T extends XNumber>(props: { [K in keyof T as K & "x"]: T[K]; }) => T
>{ x: 1, y: "foo" } : { x: 1; y: string; }
>x : 1
>1 : 1
>y : string
>"foo" : "foo"

const objFoo = { x: 1, y: "foo" };
>objFoo : { x: number; y: string; }
>{ x: 1, y: "foo" } : { x: number; y: string; }
>x : number
>1 : 1
>y : string
>"foo" : "foo"

const foo2 = foo(objFoo);
>foo2 : { x: number; }
>foo(objFoo) : { x: number; }
>foo : <T extends XNumber>(props: { [K in keyof T as K & "x"]: T[K]; }) => T
>objFoo : { x: number; y: string; }

const checkType =
>checkType : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }

  <T,>() =>
><T,>() =>  <U extends T>(value: { [K in keyof U & keyof T]: U[K] }) =>    value : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }

  <U extends T>(value: { [K in keyof U & keyof T]: U[K] }) =>
><U extends T>(value: { [K in keyof U & keyof T]: U[K] }) =>    value : <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
>value : { [K in keyof U & keyof T]: U[K]; }

    value;
>value : { [K in keyof U & keyof T]: U[K]; }

const checked1 = checkType<{ x: number; y: string }>()({
>checked1 : { x: number; y: "y"; }
>checkType<{ x: number; y: string }>()({  x: 1 as number,  y: "y",  z: "z",}) : { x: number; y: "y"; }
>checkType<{ x: number; y: string }>() : <U extends { x: number; y: string; }>(value: { [K in keyof U & ("x" | "y")]: U[K]; }) => { [K in keyof U & ("x" | "y")]: U[K]; }
>checkType : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
>x : number
>y : string
>{  x: 1 as number,  y: "y",  z: "z",} : { x: number; y: "y"; z: string; }

  x: 1 as number,
>x : number
>1 as number : number
>1 : 1

  y: "y",
>y : "y"
>"y" : "y"

  z: "z",
>z : string
>"z" : "z"

});
const objChecked = {
>objChecked : { x: number; y: string; z: string; }
>{  x: 1,  y: "y",  z: "z",} : { x: number; y: string; z: string; }

  x: 1,
>x : number
>1 : 1

  y: "y",
>y : string
>"y" : "y"

  z: "z",
>z : string
>"z" : "z"

};
const checked2 = checkType<{ x: number; y: string }>()(objChecked);
>checked2 : { x: number; y: string; }
>checkType<{ x: number; y: string }>()(objChecked) : { x: number; y: string; }
>checkType<{ x: number; y: string }>() : <U extends { x: number; y: string; }>(value: { [K in keyof U & ("x" | "y")]: U[K]; }) => { [K in keyof U & ("x" | "y")]: U[K]; }
>checkType : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
>x : number
>y : string
>objChecked : { x: number; y: string; z: string; }

declare function fn1<T extends Record<string, number>>(obj: {
>fn1 : <T extends Record<string, number>>(obj: { [K in keyof T as K extends "a" ? K : never]: T[K]; }) => T
>obj : { [K in keyof T as K extends "a" ? K : never]: T[K]; }

  [K in keyof T as K extends "a" ? K : never]: T[K];
}): T;
const obj1 = {
>obj1 : { a: number; b: boolean; }
>{  a: 42,  b: true,} : { a: number; b: boolean; }

  a: 42,
>a : number
>42 : 42

  b: true,
>b : boolean
>true : true

};
const result1 = fn1(obj1);
>result1 : { a: number; }
>fn1(obj1) : { a: number; }
>fn1 : <T extends Record<string, number>>(obj: { [K in keyof T as K extends "a" ? K : never]: T[K]; }) => T
>obj1 : { a: number; b: boolean; }

declare function fn2<T>(obj: {
>fn2 : <T>(obj: { [K in keyof T & ("a" | "b") as K extends "a" | "c" ? K : never]: T[K]; }) => T
>obj : { [K in keyof T & ("a" | "b") as K extends "a" | "c" ? K : never]: T[K]; }

  [K in keyof T & ("a" | "b") as K extends "a" | "c" ? K : never]: T[K];
}): T;
const obj2 = { a: 1, b: 2, c: 3 };
>obj2 : { a: number; b: number; c: number; }
>{ a: 1, b: 2, c: 3 } : { a: number; b: number; c: number; }
>a : number
>1 : 1
>b : number
>2 : 2
>c : number
>3 : 3

const result2 = fn2(obj2);
>result2 : { a: number; }
>fn2(obj2) : { a: number; }
>fn2 : <T>(obj: { [K in keyof T & ("a" | "b") as K extends "a" | "c" ? K : never]: T[K]; }) => T
>obj2 : { a: number; b: number; c: number; }

declare function fn3<T>(obj: {
>fn3 : <T>(obj: { [K in keyof T & ("a" | "c") as K extends "a" | "b" ? K : never]: T[K]; }) => T
>obj : { [K in keyof T & ("a" | "c") as K extends "a" | "b" ? K : never]: T[K]; }

  [K in keyof T & ("a" | "c") as K extends "a" | "b" ? K : never]: T[K];
}): T;
const obj3 = { a: 1, b: 2, c: 3 };
>obj3 : { a: number; b: number; c: number; }
>{ a: 1, b: 2, c: 3 } : { a: number; b: number; c: number; }
>a : number
>1 : 1
>b : number
>2 : 2
>c : number
>3 : 3

const result3 = fn3(obj3);
>result3 : { a: number; }
>fn3(obj3) : { a: number; }
>fn3 : <T>(obj: { [K in keyof T & ("a" | "c") as K extends "a" | "b" ? K : never]: T[K]; }) => T
>obj3 : { a: number; b: number; c: number; }

