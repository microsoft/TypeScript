//// [tests/cases/compiler/revertedIntersection.ts] ////

=== revertedIntersection.ts ===
type StateConfig<TAction extends string> = {
>StateConfig : StateConfig<TAction>

  entry?: TAction
>entry : TAction | undefined

  states?: Record<string, StateConfig<TAction>>;
>states : Record<string, StateConfig<TAction>> | undefined

};

type StateSchema = {
>StateSchema : { states?: Record<string, StateSchema> | undefined; }

  states?: Record<string, StateSchema>;
>states : Record<string, StateSchema> | undefined

};

declare function createMachine<
>createMachine : <TConfig extends StateConfig<TAction>, TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }) => [TAction, TConfig]

  TConfig extends StateConfig<TAction>,
  TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string,
>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K] }): [TAction, TConfig];
>config : { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }

const inferredParams1 = createMachine({
>inferredParams1 : ["foo", StateConfig<"foo">]
>createMachine({  entry: "foo",  states: {    a: {      entry: "bar",    },  },  extra: 12,}) : ["foo", StateConfig<"foo">]
>createMachine : <TConfig extends StateConfig<TAction>, TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }) => [TAction, TConfig]
>{  entry: "foo",  states: {    a: {      entry: "bar",    },  },  extra: 12,} : { entry: "foo"; states: { a: { entry: "bar"; }; }; extra: number; }

  entry: "foo",
>entry : "foo"
>"foo" : "foo"

  states: {
>states : { a: { entry: "bar"; }; }
>{    a: {      entry: "bar",    },  } : { a: { entry: "bar"; }; }

    a: {
>a : { entry: "bar"; }
>{      entry: "bar",    } : { entry: "bar"; }

      entry: "bar",
>entry : "bar"
>"bar" : "bar"

    },
  },
  extra: 12,
>extra : number
>12 : 12

});

const inferredParams2 = createMachine({
>inferredParams2 : ["foo", { entry: "foo"; states: { a: { entry: "foo"; }; }; extra: number; }]
>createMachine({  entry: "foo",  states: {    a: {      entry: "foo",    },  },  extra: 12,}) : ["foo", { entry: "foo"; states: { a: { entry: "foo"; }; }; extra: number; }]
>createMachine : <TConfig extends StateConfig<TAction>, TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }) => [TAction, TConfig]
>{  entry: "foo",  states: {    a: {      entry: "foo",    },  },  extra: 12,} : { entry: "foo"; states: { a: { entry: "foo"; }; }; extra: number; }

  entry: "foo",
>entry : "foo"
>"foo" : "foo"

  states: {
>states : { a: { entry: "foo"; }; }
>{    a: {      entry: "foo",    },  } : { a: { entry: "foo"; }; }

    a: {
>a : { entry: "foo"; }
>{      entry: "foo",    } : { entry: "foo"; }

      entry: "foo",
>entry : "foo"
>"foo" : "foo"

    },
  },
  extra: 12,
>extra : number
>12 : 12

});


// -----------------------------------------------------------------------------------------

const checkType = <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K] }) => value;
>checkType : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
><T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K] }) => value : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
><U extends T>(value: { [K in keyof U & keyof T]: U[K] }) => value : <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
>value : { [K in keyof U & keyof T]: U[K]; }
>value : { [K in keyof U & keyof T]: U[K]; }

const checked = checkType<{x: number, y: string}>()({
>checked : { x: number; y: "y"; }
>checkType<{x: number, y: string}>()({  x: 1 as number,  y: "y",  z: "z", // undesirable property z is *not* allowed}) : { x: number; y: "y"; }
>checkType<{x: number, y: string}>() : <U extends { x: number; y: string; }>(value: { [K in keyof U & ("x" | "y")]: U[K]; }) => { [K in keyof U & ("x" | "y")]: U[K]; }
>checkType : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
>x : number
>y : string
>{  x: 1 as number,  y: "y",  z: "z", // undesirable property z is *not* allowed} : { x: number; y: "y"; z: string; }

  x: 1 as number,
>x : number
>1 as number : number
>1 : 1

  y: "y",
>y : "y"
>"y" : "y"

  z: "z", // undesirable property z is *not* allowed
>z : string
>"z" : "z"

});

checked;
>checked : { x: number; y: "y"; }

  // ^?

// -----------------------------------------------------------------------------------------

interface Stuff {
    field: number;
>field : number

    anotherField: string;
>anotherField : string
}

function doStuffWithStuff<T extends Stuff>(s: { [K in keyof T & keyof Stuff]: T[K] } ): T {
>doStuffWithStuff : <T extends Stuff>(s: { [K in keyof T & keyof Stuff]: T[K]; }) => T
>s : { [K in keyof T & keyof Stuff]: T[K]; }

    if(Math.random() > 0.5) {
>Math.random() > 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5

      return s as T
>s as T : T
>s : { [K in keyof T & keyof Stuff]: T[K]; }

    } else {
      return s
>s : { [K in keyof T & keyof Stuff]: T[K]; }
    }
}

doStuffWithStuff({ field: 1, anotherField: 'a', extra: 123 })
>doStuffWithStuff({ field: 1, anotherField: 'a', extra: 123 }) : { field: 1; anotherField: "a"; extra: number; }
>doStuffWithStuff : <T extends Stuff>(s: { [K in keyof T & keyof Stuff]: T[K]; }) => T
>{ field: 1, anotherField: 'a', extra: 123 } : { field: 1; anotherField: "a"; extra: number; }
>field : 1
>1 : 1
>anotherField : "a"
>'a' : "a"
>extra : number
>123 : 123

function doStuffWithStuffArr<T extends Stuff>(arr: { [K in keyof T & keyof Stuff]: T[K] }[]): T[] {
>doStuffWithStuffArr : <T extends Stuff>(arr: { [K in keyof T & keyof Stuff]: T[K]; }[]) => T[]
>arr : { [K in keyof T & keyof Stuff]: T[K]; }[]

    if(Math.random() > 0.5) {
>Math.random() > 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5

      return arr as T[]
>arr as T[] : T[]
>arr : { [K in keyof T & keyof Stuff]: T[K]; }[]

    } else {
      return arr
>arr : { [K in keyof T & keyof Stuff]: T[K]; }[]
    }
}

doStuffWithStuffArr([
>doStuffWithStuffArr([    { field: 1, anotherField: 'a', extra: 123 },]) : { field: 1; anotherField: "a"; extra: number; }[]
>doStuffWithStuffArr : <T extends Stuff>(arr: { [K in keyof T & keyof Stuff]: T[K]; }[]) => T[]
>[    { field: 1, anotherField: 'a', extra: 123 },] : { field: 1; anotherField: "a"; extra: number; }[]

    { field: 1, anotherField: 'a', extra: 123 },
>{ field: 1, anotherField: 'a', extra: 123 } : { field: 1; anotherField: "a"; extra: number; }
>field : 1
>1 : 1
>anotherField : "a"
>'a' : "a"
>extra : number
>123 : 123

])

// -----------------------------------------------------------------------------------------

type XNumber = { x: number }
>XNumber : { x: number; }
>x : number

declare function foo<T extends XNumber>(props: {[K in keyof T & keyof XNumber]: T[K]}): void;
>foo : <T extends XNumber>(props: { [K in keyof T & "x"]: T[K]; }) => void
>props : { [K in keyof T & "x"]: T[K]; }

function bar(props: {x: number, y: string}) {
>bar : (props: {    x: number;    y: string;}) => void
>props : { x: number; y: string; }
>x : number
>y : string

  return foo(props); // no error because lack of excess property check by design
>foo(props) : void
>foo : <T extends XNumber>(props: { [K in keyof T & "x"]: T[K]; }) => void
>props : { x: number; y: string; }
}

foo({x: 1, y: 'foo'});
>foo({x: 1, y: 'foo'}) : void
>foo : <T extends XNumber>(props: { [K in keyof T & "x"]: T[K]; }) => void
>{x: 1, y: 'foo'} : { x: 1; y: string; }
>x : 1
>1 : 1
>y : string
>'foo' : "foo"

foo({...{x: 1, y: 'foo'}}); // no error because lack of excess property check by design
>foo({...{x: 1, y: 'foo'}}) : void
>foo : <T extends XNumber>(props: { [K in keyof T & "x"]: T[K]; }) => void
>{...{x: 1, y: 'foo'}} : { x: 1; y: string; }
>{x: 1, y: 'foo'} : { x: 1; y: string; }
>x : 1
>1 : 1
>y : string
>'foo' : "foo"

