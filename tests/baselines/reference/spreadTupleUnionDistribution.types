//// [tests/cases/conformance/types/spread/spreadTupleUnionDistribution.ts] ////

=== spreadTupleUnionDistribution.ts ===
// Repro from #62812
// Spread operator fails to distribute over union when recursive type call is inlined instead of aliased

type CrossProduct<Union, Counter extends unknown[]> =
>CrossProduct : CrossProduct<Union, Counter>
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Counter extends [infer Zero, ...infer Rest]
    ? (Union extends infer Member
        ? [Member, ...CrossProduct<Union, Rest>]
        : never)
    : [];

// Basic test - this works
let test1: CrossProduct<number | string, [undefined]>;  // [string] | [number]
>test1 : [string] | [number]
>      : ^^^^^^^^^^^^^^^^^^^

type Depth1 = CrossProduct<number | string, [undefined]> // [string] | [number]
>Depth1 : [string] | [number]
>       : ^^^^^^^^^^^^^^^^^^^

// With alias - this should work and give full cross product
let test2: (number | string extends infer Union ? (Union extends unknown ? [Union, ...Depth1]: never) : never);
>test2 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Expected: [string, string] | [number, number] | [string, number] | [number, string]

// With inlined type - this should also work but currently doesn't distribute properly
let test3: (number | string extends infer Union ? (Union extends unknown ? [Union, ...CrossProduct<number | string, [undefined]>]: never) : never);
>test3 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Expected: [string, string] | [number, number] | [string, number] | [number, string]
// Actual (bug): [string, string] | [number, number]

// With literal union - this works
let test4: (number | string extends infer Union ? (Union extends unknown ? [Union, ...([string] | [number])]: never) : never);
>test4 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Expected: [string, string] | [number, number] | [string, number] | [number, string]

// Test that the types are actually correct by checking assignability
type Expected = [string, string] | [number, number] | [string, number] | [number, string];
>Expected : Expected
>         : ^^^^^^^^

// These should all be true (no error)
type Test1Check = Expected extends typeof test2 ? true : false;
>Test1Check : true
>           : ^^^^
>test2 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>true : true
>     : ^^^^
>false : false
>      : ^^^^^

type Test2Check = typeof test2 extends Expected ? true : false;
>Test2Check : true
>           : ^^^^
>test2 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>true : true
>     : ^^^^
>false : false
>      : ^^^^^

// If the bug is fixed, these will also be true (no error)
type Test3Check = Expected extends typeof test3 ? true : false;
>Test3Check : true
>           : ^^^^
>test3 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>true : true
>     : ^^^^
>false : false
>      : ^^^^^

type Test4Check = typeof test3 extends Expected ? true : false;
>Test4Check : true
>           : ^^^^
>test3 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>true : true
>     : ^^^^
>false : false
>      : ^^^^^

type Test5Check = Expected extends typeof test4 ? true : false;
>Test5Check : true
>           : ^^^^
>test4 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>true : true
>     : ^^^^
>false : false
>      : ^^^^^

type Test6Check = typeof test4 extends Expected ? true : false;
>Test6Check : true
>           : ^^^^
>test4 : [string, string] | [string, number] | [number, string] | [number, number]
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>true : true
>     : ^^^^
>false : false
>      : ^^^^^

// Force an error if checks fail
const _check1: Test1Check = true;
>_check1 : true
>        : ^^^^
>true : true
>     : ^^^^

const _check2: Test2Check = true;
>_check2 : true
>        : ^^^^
>true : true
>     : ^^^^

const _check3: Test3Check = true;  // This will error if bug exists
>_check3 : true
>        : ^^^^
>true : true
>     : ^^^^

const _check4: Test4Check = true;  // This will error if bug exists
>_check4 : true
>        : ^^^^
>true : true
>     : ^^^^

const _check5: Test5Check = true;
>_check5 : true
>        : ^^^^
>true : true
>     : ^^^^

const _check6: Test6Check = true;
>_check6 : true
>        : ^^^^
>true : true
>     : ^^^^

