//// [tests/cases/compiler/spreadUnionPropOverride.ts] ////

=== spreadUnionPropOverride.ts ===
// Repro from #62655
type Thing = {
>Thing : Thing
>      : ^^^^^

    id: string;
>id : string
>   : ^^^^^^

    label: string;
>label : string
>      : ^^^^^^

};

const things: Thing[] = [];
>things : Thing[]
>       : ^^^^^^^
>[] : never[]
>   : ^^^^^^^

function find(id: string): undefined | Thing {
>find : (id: string) => undefined | Thing
>     : ^  ^^      ^^^^^                 
>id : string
>   : ^^^^^^

    return things.find(thing => thing.id === id);
>things.find(thing => thing.id === id) : Thing | undefined
>                                      : ^^^^^^^^^^^^^^^^^
>things.find : { <S extends Thing>(predicate: (value: Thing, index: number, obj: Thing[]) => value is S, thisArg?: any): S | undefined; (predicate: (value: Thing, index: number, obj: Thing[]) => unknown, thisArg?: any): Thing | undefined; }
>            : ^^^ ^^^^^^^^^^^^^^^^         ^^^     ^^^^^^^^^     ^^      ^^   ^^^^^^^^^^^^^^^^^^^^^^^^^^       ^^^   ^^^^^^^^^^^^^^^^^^^         ^^^     ^^^^^^^^^     ^^      ^^   ^^^^^^^^^^^^^^       ^^       ^^^   ^^^^^^^^^^^^^^^^^^^^^^^
>things : Thing[]
>       : ^^^^^^^
>find : { <S extends Thing>(predicate: (value: Thing, index: number, obj: Thing[]) => value is S, thisArg?: any): S | undefined; (predicate: (value: Thing, index: number, obj: Thing[]) => unknown, thisArg?: any): Thing | undefined; }
>     : ^^^ ^^^^^^^^^^^^^^^^         ^^^     ^^^^^^^^^     ^^      ^^   ^^^^^^^^^^^^^^^^^^^^^^^^^^       ^^^   ^^^^^^^^^^^^^^^^^^^         ^^^     ^^^^^^^^^     ^^      ^^   ^^^^^^^^^^^^^^       ^^       ^^^   ^^^^^^^^^^^^^^^^^^^^^^^
>thing => thing.id === id : (thing: Thing) => boolean
>                         : ^     ^^^^^^^^^^^^^^^^^^^
>thing : Thing
>      : ^^^^^
>thing.id === id : boolean
>                : ^^^^^^^
>thing.id : string
>         : ^^^^^^
>thing : Thing
>      : ^^^^^
>id : string
>   : ^^^^^^
>id : string
>   : ^^^^^^
}

declare function fun(thing: Thing): void;
>fun : (thing: Thing) => void
>    : ^     ^^     ^^^^^    
>thing : Thing
>      : ^^^^^

fun({
>fun({    id: 'foo',    ...find('foo') ?? {        label: 'Foo',    },}) : void
>                                                                        : ^^^^
>fun : (thing: Thing) => void
>    : ^     ^^     ^^^^^    
>{    id: 'foo',    ...find('foo') ?? {        label: 'Foo',    },} : { id: string; label: string; } | { label: string; id: string; }
>                                                                   : ^^^^^^      ^^^^^^^^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    id: 'foo',
>id : string
>   : ^^^^^^
>'foo' : "foo"
>      : ^^^^^

    ...find('foo') ?? {
>find('foo') ?? {        label: 'Foo',    } : Thing | { label: string; }
>                                           : ^^^^^^^^^^^^^^^^^^^^^^^^^^
>find('foo') : Thing | undefined
>            : ^^^^^^^^^^^^^^^^^
>find : (id: string) => undefined | Thing
>     : ^  ^^      ^^^^^                 
>'foo' : "foo"
>      : ^^^^^
>{        label: 'Foo',    } : { label: string; }
>                            : ^^^^^^^^^^^^^^^^^^

        label: 'Foo',
>label : string
>      : ^^^^^^
>'Foo' : "Foo"
>      : ^^^^^

    },
});

// Should not error when spreading a union where one type doesn't have the property
const obj1 = {
>obj1 : { y: number; x: number; } | { y: number; x: number; }
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{    x: 1,    ...(Math.random() > 0.5 ? { y: 2 } : { y: 2, x: 3 }),} : { y: number; x: number; } | { y: number; x: number; }
>                                                                     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    x: 1,
>x : number
>  : ^^^^^^
>1 : 1
>  : ^

    ...(Math.random() > 0.5 ? { y: 2 } : { y: 2, x: 3 }),
>(Math.random() > 0.5 ? { y: 2 } : { y: 2, x: 3 }) : { y: number; } | { y: number; x: number; }
>                                                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Math.random() > 0.5 ? { y: 2 } : { y: 2, x: 3 } : { y: number; } | { y: number; x: number; }
>                                                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Math.random() > 0.5 : boolean
>                    : ^^^^^^^
>Math.random() : number
>              : ^^^^^^
>Math.random : () => number
>            : ^^^^^^      
>Math : Math
>     : ^^^^
>random : () => number
>       : ^^^^^^      
>0.5 : 0.5
>    : ^^^
>{ y: 2 } : { y: number; }
>         : ^^^^^^^^^^^^^^
>y : number
>  : ^^^^^^
>2 : 2
>  : ^
>{ y: 2, x: 3 } : { y: number; x: number; }
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^
>y : number
>  : ^^^^^^
>2 : 2
>  : ^
>x : number
>  : ^^^^^^
>3 : 3
>  : ^

}; // OK - x might be overwritten

// Should error when the property is in all constituents
const obj2 = {
>obj2 : { x: number; y: number; } | { x: number; z: number; }
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>{    x: 1,    ...(Math.random() > 0.5 ? { x: 2, y: 3 } : { x: 4, z: 5 }),} : { x: number; y: number; } | { x: number; z: number; }
>                                                                           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    x: 1,
>x : number
>  : ^^^^^^
>1 : 1
>  : ^

    ...(Math.random() > 0.5 ? { x: 2, y: 3 } : { x: 4, z: 5 }),
>(Math.random() > 0.5 ? { x: 2, y: 3 } : { x: 4, z: 5 }) : { x: number; y: number; } | { x: number; z: number; }
>                                                        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Math.random() > 0.5 ? { x: 2, y: 3 } : { x: 4, z: 5 } : { x: number; y: number; } | { x: number; z: number; }
>                                                      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Math.random() > 0.5 : boolean
>                    : ^^^^^^^
>Math.random() : number
>              : ^^^^^^
>Math.random : () => number
>            : ^^^^^^      
>Math : Math
>     : ^^^^
>random : () => number
>       : ^^^^^^      
>0.5 : 0.5
>    : ^^^
>{ x: 2, y: 3 } : { x: number; y: number; }
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^
>x : number
>  : ^^^^^^
>2 : 2
>  : ^
>y : number
>  : ^^^^^^
>3 : 3
>  : ^
>{ x: 4, z: 5 } : { x: number; z: number; }
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^
>x : number
>  : ^^^^^^
>4 : 4
>  : ^
>z : number
>  : ^^^^^^
>5 : 5
>  : ^

}; // Error - x is always overwritten

// Should not error with optional property in union
type Partial1 = { a: string; b?: number };
>Partial1 : Partial1
>         : ^^^^^^^^
>a : string
>  : ^^^^^^
>b : number | undefined
>  : ^^^^^^^^^^^^^^^^^^

type Partial2 = { a: string; c: boolean };
>Partial2 : Partial2
>         : ^^^^^^^^
>a : string
>  : ^^^^^^
>c : boolean
>  : ^^^^^^^

declare const partial: Partial1 | Partial2;
>partial : Partial1 | Partial2
>        : ^^^^^^^^^^^^^^^^^^^

const obj3 = {
>obj3 : { a: string; b: number; } | { a: string; c: boolean; b: number; }
>     : ^^^^^      ^^^^^      ^^^^^^^^^^^      ^^^^^       ^^^^^^^^^^^^^^
>{    b: 42,    ...partial,} : { a: string; b: number; } | { a: string; c: boolean; b: number; }
>                            : ^^^^^      ^^^^^      ^^^^^^^^^^^      ^^^^^       ^^^^^^^^^^^^^^

    b: 42,
>b : number
>  : ^^^^^^
>42 : 42
>   : ^^

    ...partial,
>partial : Partial1 | Partial2
>        : ^^^^^^^^^^^^^^^^^^^

}; // OK - b is optional in Partial1 and missing in Partial2

// Should error when property is required in all types
const obj4 = {
>obj4 : { a: string; b?: number; } | { a: string; c: boolean; }
>     : ^^^^^      ^^^^^^      ^^^^^^^^^^^      ^^^^^       ^^^
>{    a: "test",    ...partial,} : { a: string; b?: number; } | { a: string; c: boolean; }
>                                : ^^^^^      ^^^^^^      ^^^^^^^^^^^      ^^^^^       ^^^

    a: "test",
>a : string
>  : ^^^^^^
>"test" : "test"
>       : ^^^^^^

    ...partial,
>partial : Partial1 | Partial2
>        : ^^^^^^^^^^^^^^^^^^^

}; // Error - a is required in both types

// More complex union case
type A = { id: string; name: string };
>A : A
>  : ^
>id : string
>   : ^^^^^^
>name : string
>     : ^^^^^^

type B = { name: string; age: number };
>B : B
>  : ^
>name : string
>     : ^^^^^^
>age : number
>    : ^^^^^^

type C = { name: string };
>C : C
>  : ^
>name : string
>     : ^^^^^^

declare const abc: A | B | C;
>abc : A | B | C
>    : ^^^^^^^^^

const obj5 = {
>obj5 : { id: string; name: string; } | { name: string; age: number; id: string; } | { name: string; id: string; }
>     : ^^^^^^      ^^^^^^^^      ^^^^^^^^^^^^^^      ^^^^^^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^
>{    id: "123",    ...abc,} : { id: string; name: string; } | { name: string; age: number; id: string; } | { name: string; id: string; }
>                            : ^^^^^^      ^^^^^^^^      ^^^^^^^^^^^^^^      ^^^^^^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^

    id: "123",
>id : string
>   : ^^^^^^
>"123" : "123"
>      : ^^^^^

    ...abc,
>abc : A | B | C
>    : ^^^^^^^^^

}; // OK - id is only in A

const obj6 = {
>obj6 : { id: string; name: string; } | { name: string; age: number; } | { name: string; }
>     : ^^^^^^      ^^^^^^^^      ^^^^^^^^^^^^^^      ^^^^^^^      ^^^^^^^^^^^^^^      ^^^
>{    name: "test",    ...abc,} : { id: string; name: string; } | { name: string; age: number; } | { name: string; }
>                               : ^^^^^^      ^^^^^^^^      ^^^^^^^^^^^^^^      ^^^^^^^      ^^^^^^^^^^^^^^      ^^^

    name: "test",
>name : string
>     : ^^^^^^
>"test" : "test"
>       : ^^^^^^

    ...abc,
>abc : A | B | C
>    : ^^^^^^^^^

}; // Error - name is in all types

