=== tests/cases/compiler/switchCaseNarrowsMatchingClausesEvenWhenNonMatchingClausesExist.ts ===
export const narrowToLiterals = (str: string) => {
>narrowToLiterals : (str: string) => "abc" | "defaultValue"
>(str: string) => {    switch (str) {      case 'abc': {        // inferred type as `abc`        return str;      }      default:        return 'defaultValue';    }  } : (str: string) => "abc" | "defaultValue"
>str : string

    switch (str) {
>str : string

      case 'abc': {
>'abc' : "abc"

        // inferred type as `abc`
        return str;
>str : "abc"
      }
      default:
        return 'defaultValue';
>'defaultValue' : "defaultValue"
    }
  };
  
  export const narrowToString = (str: string, someOtherStr: string) => {
>narrowToString : (str: string, someOtherStr: string) => string
>(str: string, someOtherStr: string) => {    switch (str) {      case 'abc': {        // inferred type should be `abc`        return str;      }      case someOtherStr: {        // `string`        return str;      }      default:        return 'defaultValue';    }  } : (str: string, someOtherStr: string) => string
>str : string
>someOtherStr : string

    switch (str) {
>str : string

      case 'abc': {
>'abc' : "abc"

        // inferred type should be `abc`
        return str;
>str : "abc"
      }
      case someOtherStr: {
>someOtherStr : string

        // `string`
        return str;
>str : string
      }
      default:
        return 'defaultValue';
>'defaultValue' : "defaultValue"
    }
  };
  
  export const narrowToStringOrNumber = (str: string | number, someNumber: number) => {
>narrowToStringOrNumber : (str: string | number, someNumber: number) => number | "abc" | "defaultValue"
>(str: string | number, someNumber: number) => {    switch (str) {      case 'abc': {        // inferred type should be `abc`        return str;      }      case someNumber: {        // inferred type should be `number`        return str;      }      default:        return 'defaultValue';    }  } : (str: string | number, someNumber: number) => number | "abc" | "defaultValue"
>str : string | number
>someNumber : number

    switch (str) {
>str : string | number

      case 'abc': {
>'abc' : "abc"

        // inferred type should be `abc`
        return str;
>str : "abc"
      }
      case someNumber: {
>someNumber : number

        // inferred type should be `number`
        return str;
>str : number
      }
      default:
        return 'defaultValue';
>'defaultValue' : "defaultValue"
    }
  };
