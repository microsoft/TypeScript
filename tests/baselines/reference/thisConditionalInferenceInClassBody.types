=== tests/cases/compiler/thisConditionalInferenceInClassBody.ts ===
type Wrapped<T> = { ___secret: T };
>Wrapped : Wrapped<T>
>___secret : T

type Unwrap<T> = T extends Wrapped<infer U> ? U : T;
>Unwrap : Unwrap<T>

declare function set<T, K extends keyof T>(obj: T, key: K, value: Unwrap<T[K]>): Unwrap<T[K]>;
>set : <T, K extends keyof T>(obj: T, key: K, value: Unwrap<T[K]>) => Unwrap<T[K]>
>obj : T
>key : K
>value : Unwrap<T[K]>

class Foo {
>Foo : Foo

    prop: Wrapped<string>;
>prop : Wrapped<string>

    method() {
>method : () => void

        set(this, 'prop', 'hi'); // <-- type error
>set(this, 'prop', 'hi') : any
>set : <T, K extends keyof T>(obj: T, key: K, value: Unwrap<T[K]>) => Unwrap<T[K]>
>this : this
>'prop' : "prop"
>'hi' : "hi"
    }
}

set(new Foo(), 'prop', 'hi'); // <-- typechecks
>set(new Foo(), 'prop', 'hi') : string
>set : <T, K extends keyof T>(obj: T, key: K, value: Unwrap<T[K]>) => Unwrap<T[K]>
>new Foo() : Foo
>Foo : typeof Foo
>'prop' : "prop"
>'hi' : "hi"

type InferBecauseWhyNot<T> = T extends (p: infer P1) => any ? P1 | T : never;
>InferBecauseWhyNot : InferBecauseWhyNot<T>
>p : P1

function f<Q extends (arg: any) => any>(x: Q): InferBecauseWhyNot<Q> {
>f : <Q extends (arg: any) => any>(x: Q) => InferBecauseWhyNot<Q>
>arg : any
>x : Q

    return x;
>x : Q
}

