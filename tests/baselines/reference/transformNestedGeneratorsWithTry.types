//// [tests/cases/compiler/transformNestedGeneratorsWithTry.ts] ////

=== main.ts ===
// https://github.com/Microsoft/TypeScript/issues/11177
import * as Bluebird from 'bluebird';
>Bluebird : { default: PromiseConstructor; all<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>; all<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; race<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>>; race<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>>; prototype: Promise<any>; reject<T = never>(reason?: any): Promise<T>; resolve(): Promise<void>; resolve<T>(value: T): Promise<Awaited<T>>; resolve<T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; [Symbol.species]: PromiseConstructor; }
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^      ^^                            ^^^                     ^^^^^^ ^^^^^^^^^                       ^^      ^^ ^^^                                                     ^^^^^^^ ^^      ^^                            ^^^                   ^^^^^^^ ^^^^^^^^^                       ^^      ^^ ^^^                           ^^^^^^^^^^^^^            ^^^^^^^^^ ^^^^^^^^^^      ^^^   ^^^          ^^^^^^^^^^^^^             ^^^^^^^^^^ ^^     ^^ ^^^                   ^^^^^^^^^^ ^^     ^^                  ^^^                   ^^^^^^^^^^^^^^^^^^^^                  ^^^

async function a(): Bluebird<void> {
>a : () => Bluebird<void>
>  : ^^^^^^              

  try {
    const b = async function b(): Bluebird<void> {
>b : () => Bluebird<void>
>  : ^^^^^^              
>async function b(): Bluebird<void> {      try {        await Bluebird.resolve(); // -- remove this and it compiles      } catch (error) { }    } : () => Bluebird<void>
>                                                                                                                                                 : ^^^^^^              
>b : () => Bluebird<void>
>  : ^^^^^^              

      try {
        await Bluebird.resolve(); // -- remove this and it compiles
>await Bluebird.resolve() : void
>                         : ^^^^
>Bluebird.resolve() : Promise<void>
>                   : ^^^^^^^^^^^^^
>Bluebird.resolve : { (): Promise<void>; <T>(value: T): Promise<Awaited<T>>; <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; }
>                 : ^^^^^^             ^^^ ^^     ^^ ^^^                   ^^^ ^^     ^^                  ^^^                   ^^^
>Bluebird : { default: PromiseConstructor; all<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>; all<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; race<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>>; race<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>>; prototype: Promise<any>; reject<T = never>(reason?: any): Promise<T>; resolve(): Promise<void>; resolve<T>(value: T): Promise<Awaited<T>>; resolve<T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; [Symbol.species]: PromiseConstructor; }
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^      ^^                            ^^^                     ^^^^^^ ^^^^^^^^^                       ^^      ^^ ^^^                                                     ^^^^^^^ ^^      ^^                            ^^^                   ^^^^^^^ ^^^^^^^^^                       ^^      ^^ ^^^                           ^^^^^^^^^^^^^            ^^^^^^^^^ ^^^^^^^^^^      ^^^   ^^^          ^^^^^^^^^^^^^             ^^^^^^^^^^ ^^     ^^ ^^^                   ^^^^^^^^^^ ^^     ^^                  ^^^                   ^^^^^^^^^^^^^^^^^^^^                  ^^^
>resolve : { (): Promise<void>; <T>(value: T): Promise<Awaited<T>>; <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; }
>        : ^^^^^^             ^^^ ^^     ^^ ^^^                   ^^^ ^^     ^^                  ^^^                   ^^^

      } catch (error) { }
>error : any
>      : ^^^

    };

    await b(); // -- or remove this and it compiles
>await b() : void
>          : ^^^^
>b() : Bluebird<void>
>    : ^^^^^^^^^^^^^^
>b : () => Bluebird<void>
>  : ^^^^^^              

  } catch (error) { }
>error : any
>      : ^^^
}

=== bluebird.d.ts ===
declare module "bluebird" {
>"bluebird" : typeof import("bluebird")
>           : ^^^^^^^^^^^^^^^^^^^^^^^^^

    type Bluebird<T> = Promise<T>;
>Bluebird : Bluebird<T>
>         : ^^^^^^^^^^^

    const Bluebird: typeof Promise;
>Bluebird : PromiseConstructor
>         : ^^^^^^^^^^^^^^^^^^
>Promise : PromiseConstructor
>        : ^^^^^^^^^^^^^^^^^^

    export = Bluebird;
>Bluebird : Bluebird<T>
>         : ^^^^^^^^^^^
}
