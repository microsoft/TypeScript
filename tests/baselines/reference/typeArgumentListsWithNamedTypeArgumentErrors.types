=== tests/cases/conformance/types/typeParameters/typeArgumentLists/typeArgumentListsWithNamedTypeArguments/typeArgumentListsWithNamedTypeArgumentErrors.tsx ===
declare module JSX {
>JSX : any

    interface Element {}
>Element : Element
}
declare namespace React {
>React : typeof React

    export function createElement(x: any, p: any, ...children: any[]): JSX.Element;
>createElement : (x: any, p: any, ...children: any[]) => JSX.Element
>x : any
>p : any
>children : any[]
>JSX : any
>Element : JSX.Element
}

class Foo<T, U> {
>Foo : Foo<T, U>
>T : T
>U : U

    constructor(public prop1: T, public prop2: U) {}
>prop1 : T
>T : T
>prop2 : U
>U : U
}

function foo<T, U>(x: T, y: U): [T, U] { return [x, y]; }
>foo : <T, U>(x: T, y: U) => [T, U]
>T : T
>U : U
>x : T
>T : T
>y : U
>U : U
>T : T
>U : U
>[x, y] : [T, U]
>x : T
>y : U

function tag<T, U>(x: TemplateStringsArray, ...args: (T | U)[]) { return args; }
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>T : T
>U : U
>x : TemplateStringsArray
>TemplateStringsArray : TemplateStringsArray
>args : (T | U)[]
>T : T
>U : U
>args : (T | U)[]

interface ComponentProps<T, U> {
>ComponentProps : ComponentProps<T, U>
>T : T
>U : U

    x: T;
>x : T
>T : T

    y: U;
>y : U
>U : U

    cb(props: this): void;
>cb : (props: this) => void
>props : this
}

function Component<T, U>(x: ComponentProps<T, U>) {
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>T : T
>U : U
>x : ComponentProps<T, U>
>ComponentProps : ComponentProps<T, U>
>T : T
>U : U

    return <h></h>;
><h></h> : JSX.Element
>h : any
>h : any
}

// Does not reference valid param

const instance1 = new Foo<number, Q = string>(0, "");
>instance1 : any
>new Foo<number, Q = string>(0, "") : any
>Foo : typeof Foo
>Q : any
>0 : 0
>"" : ""

const result1 = foo<number, Q = string>(0, "");
>result1 : any
>foo<number, Q = string>(0, "") : any
>foo : <T, U>(x: T, y: U) => [T, U]
>Q : any
>0 : 0
>"" : ""

const tagged1 = tag<number, Q = string>`tags ${12} ${""}`;
>tagged1 : any
>tag<number, Q = string>`tags ${12} ${""}` : any
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>Q : any
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx1 = <Component<number, Q = string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx1 : JSX.Element
><Component<number, Q = string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>Q : any
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

type A = Foo<number, Q = string>;
>A : Foo<number, {}>
>Foo : Foo<T, U>
>Q : any

// Duplicates positional

const instance2 = new Foo<number, T = string>(0, "");
>instance2 : any
>new Foo<number, T = string>(0, "") : any
>Foo : typeof Foo
>T : any
>0 : 0
>"" : ""

const result2 = foo<number, T = string>(0, "");
>result2 : any
>foo<number, T = string>(0, "") : any
>foo : <T, U>(x: T, y: U) => [T, U]
>T : any
>0 : 0
>"" : ""

const tagged2 = tag<number, T = string>`tags ${12} ${""}`;
>tagged2 : any
>tag<number, T = string>`tags ${12} ${""}` : any
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>T : any
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx2 = <Component<number, T = string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx2 : JSX.Element
><Component<number, T = string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>T : any
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

type B = Foo<number, T = string>;
>B : Foo<number, {}>
>Foo : Foo<T, U>
>T : any

// Duplicates other named

const instance3 = new Foo<T = number, T = string>(0, "");
>instance3 : any
>new Foo<T = number, T = string>(0, "") : any
>Foo : typeof Foo
>T : any
>T : any
>0 : 0
>"" : ""

const result3 = foo<T = number, T = string>(0, "");
>result3 : any
>foo<T = number, T = string>(0, "") : any
>foo : <T, U>(x: T, y: U) => [T, U]
>T : any
>T : any
>0 : 0
>"" : ""

const tagged3 = tag<T = number, T = string>`tags ${12} ${""}`;
>tagged3 : (string | number)[]
>tag<T = number, T = string>`tags ${12} ${""}` : (string | number)[]
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>T : any
>T : any
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx3 = <Component<T = number, T = string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx3 : JSX.Element
><Component<T = number, T = string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>T : any
>T : any
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<string, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<string, string>) => any
>props : ComponentProps<string, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : any
>props.x.toFixed : any
>props.x : string
>props : ComponentProps<string, string>
>x : string
>toFixed : any
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<string, string>
>y : string
>toUpperCase : () => string

type C = Foo<T = number, T = string>;
>C : Foo<string, {}>
>Foo : Foo<T, U>
>T : any
>T : any

// Too many arguments

const instance4 = new Foo<T = number, U = string, W = never>(0, "");
>instance4 : any
>new Foo<T = number, U = string, W = never>(0, "") : any
>Foo : typeof Foo
>T : any
>U : any
>W : any
>0 : 0
>"" : ""

const result4 = foo<T = number, U = string, W = never>(0, "");
>result4 : any
>foo<T = number, U = string, W = never>(0, "") : any
>foo : <T, U>(x: T, y: U) => [T, U]
>T : any
>U : any
>W : any
>0 : 0
>"" : ""

const tagged4 = tag<T = number, U = string, W = never>`tags ${12} ${""}`;
>tagged4 : any
>tag<T = number, U = string, W = never>`tags ${12} ${""}` : any
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>T : any
>U : any
>W : any
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx4 = <Component<T = number, U = string, W = never> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx4 : JSX.Element
><Component<T = number, U = string, W = never> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>T : any
>U : any
>W : any
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

type D = Foo<T = number, U = string, W = never>;
>D : any
>Foo : Foo<T, U>
>T : any
>U : any
>W : any

// Positional after named

const instance5 = new Foo<U = string, number>(0, "");
>instance5 : Foo<number, string>
>new Foo<U = string, number>(0, "") : Foo<number, string>
>Foo : typeof Foo
>U : any
>0 : 0
>"" : ""

const result5 = foo<U = string, number>(0, "");
>result5 : [number, string]
>foo<U = string, number>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>U : any
>0 : 0
>"" : ""

const tagged5 = tag<U = string, number>`tags ${12} ${""}`;
>tagged5 : (string | number)[]
>tag<U = string, number>`tags ${12} ${""}` : (string | number)[]
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>U : any
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx5 = <Component<U = string, number> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx5 : JSX.Element
><Component<U = string, number> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>U : any
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

type E = Foo<U = string, number>;
>E : Foo<number, string>
>Foo : Foo<T, U>
>U : any

// Typespace only - does not provide enough arguments
type F = Foo<U = number>;
>F : any
>Foo : Foo<T, U>
>U : any

