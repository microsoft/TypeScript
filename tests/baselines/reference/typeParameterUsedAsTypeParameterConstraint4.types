//// [tests/cases/conformance/types/objectTypeLiteral/callSignatures/typeParameterUsedAsTypeParameterConstraint4.ts] ////

=== typeParameterUsedAsTypeParameterConstraint4.ts ===
// Type parameters are in scope in their own and other type parameter lists
// Some negative cases

class C<T, U extends T, V extends U> {
>C : C<T, U, V>
>  : ^^^^^^^^^^

    z: W; // error
>z : W
>  : ^

    foo<W extends V>(x: W): T {
>foo : <W extends V>(x: W) => T
>    : ^ ^^^^^^^^^ ^^ ^^ ^^^^^ 
>x : W
>  : ^

        var r: T;
>r : T
>  : ^

        return x;
>x : W
>  : ^
    }
}

interface I<T, U extends T, V extends U> {
    x: T;
>x : T
>  : ^

    y: U;
>y : U
>  : ^

    z: W; // error
>z : W
>  : ^

    foo<W extends V>(x: W): T;
>foo : <W extends V>(x: W) => T
>    : ^ ^^^^^^^^^ ^^ ^^ ^^^^^ 
>x : W
>  : ^
}

function foo<T, U extends T>(x: T, y: U): V { // error
>foo : <T, U extends T>(x: T, y: U) => V
>    : ^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^ 
>x : T
>  : ^
>y : U
>  : ^

    function bar<V extends T, W extends U>(): X { // error
>bar : <V extends T, W extends U>() => X
>    : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^^^^^^ 

        function baz<X extends W, Y extends V>(a: X, b: Y): T {
>baz : <X extends W, Y extends V>(a: X, b: Y) => T
>    : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^ 
>a : X
>  : ^
>b : Y
>  : ^

            x = y;
>x = y : U
>      : ^
>x : T
>  : ^
>y : U
>  : ^

            return y;
>y : U
>  : ^
        }
    }
}

function foo2<U extends T, T>(x: T, y: U): W { // error
>foo2 : <U extends T, T>(x: T, y: U) => W
>     : ^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^ ^^^^^ 
>x : T
>  : ^
>y : U
>  : ^

    function bar<V extends T, W extends U>(): Y { // error
>bar : <V extends T, W extends U>() => Y
>    : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^^^^^^ 

        function baz<X extends W, Y extends V>(a: X, b: Y): T {
>baz : <X extends W, Y extends V>(a: X, b: Y) => T
>    : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^ 
>a : X
>  : ^
>b : Y
>  : ^

            x = y;
>x = y : U
>      : ^
>x : T
>  : ^
>y : U
>  : ^

            return y;
>y : U
>  : ^
        }
    }
}

var f3 = <T, U extends T>(x: T, y: U) => {
>f3 : <T, U extends T>(x: T, y: U) => void
>   : ^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^^^^^
><T, U extends T>(x: T, y: U) => {    function bar<V extends T, W extends U>(r: X, s: Y) { // error        var g = <X extends W, Y extends V>(a: X, b: Y): T => {            x = y;            return y;        }    }} : <T, U extends T>(x: T, y: U) => void
>                                                                                                                                                                                                                       : ^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^^^^^
>x : T
>  : ^
>y : U
>  : ^

    function bar<V extends T, W extends U>(r: X, s: Y) { // error
>bar : <V extends T, W extends U>(r: X, s: Y) => void
>    : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^^^^^
>r : X
>  : ^
>s : Y
>  : ^

        var g = <X extends W, Y extends V>(a: X, b: Y): T => {
>g : <X extends W, Y extends V>(a: X, b: Y) => T
>  : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^ 
><X extends W, Y extends V>(a: X, b: Y): T => {            x = y;            return y;        } : <X extends W, Y extends V>(a: X, b: Y) => T
>                                                                                               : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^ 
>a : X
>  : ^
>b : Y
>  : ^

            x = y;
>x = y : U
>      : ^
>x : T
>  : ^
>y : U
>  : ^

            return y;
>y : U
>  : ^
        }
    }
}

var f4 = <U extends T, T>(x: V, y: X) => { // error
>f4 : <U extends T, T>(x: V, y: X) => void
>   : ^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^ ^^^^^^^^^
><U extends T, T>(x: V, y: X) => { // error    function bar<V extends T, W extends U>() {        var g = <X extends W, Y extends V>(a: X, b: Y): T => {            x = y;            return y;        }    }} : <U extends T, T>(x: V, y: X) => void
>                                                                                                                                                                                                             : ^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^ ^^^^^^^^^
>x : V
>  : ^
>y : X
>  : ^

    function bar<V extends T, W extends U>() {
>bar : <V extends T, W extends U>() => void
>    : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^^^^^^^^^^

        var g = <X extends W, Y extends V>(a: X, b: Y): T => {
>g : <X extends W, Y extends V>(a: X, b: Y) => T
>  : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^ 
><X extends W, Y extends V>(a: X, b: Y): T => {            x = y;            return y;        } : <X extends W, Y extends V>(a: X, b: Y) => T
>                                                                                               : ^ ^^^^^^^^^ ^^ ^^^^^^^^^ ^^ ^^ ^^ ^^ ^^^^^ 
>a : X
>  : ^
>b : Y
>  : ^

            x = y;
>x = y : X
>      : ^
>x : V
>  : ^
>y : X
>  : ^

            return y;
>y : X
>  : ^
        }
    }
}
