//// [tests/cases/compiler/uniqueSymbolReassignment.ts] ////

=== uniqueSymbolReassignment.ts ===
// -------------------------
// Explicit unique symbols (should emit `const` / `typeof` when exported)
// -------------------------
const mySymbol = Symbol('Symbols.mySymbol');
>mySymbol : Symbol(mySymbol, Decl(uniqueSymbolReassignment.ts, 3, 5))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))

const anotherUnique = Symbol('symbols.anotherUnique');
>anotherUnique : Symbol(anotherUnique, Decl(uniqueSymbolReassignment.ts, 4, 5))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))

function myFunction() {}
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 4, 54), Decl(uniqueSymbolReassignment.ts, 6, 24), Decl(uniqueSymbolReassignment.ts, 9, 31), Decl(uniqueSymbolReassignment.ts, 16, 38), Decl(uniqueSymbolReassignment.ts, 18, 35) ... and 2 more)

// Attach the unique ones
myFunction.mySymbol = mySymbol;
>myFunction.mySymbol : Symbol(myFunction.mySymbol, Decl(uniqueSymbolReassignment.ts, 6, 24))
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 4, 54), Decl(uniqueSymbolReassignment.ts, 6, 24), Decl(uniqueSymbolReassignment.ts, 9, 31), Decl(uniqueSymbolReassignment.ts, 16, 38), Decl(uniqueSymbolReassignment.ts, 18, 35) ... and 2 more)
>mySymbol : Symbol(myFunction.mySymbol, Decl(uniqueSymbolReassignment.ts, 6, 24))
>mySymbol : Symbol(mySymbol, Decl(uniqueSymbolReassignment.ts, 3, 5))

myFunction.anotherUnique = anotherUnique;
>myFunction.anotherUnique : Symbol(myFunction.anotherUnique, Decl(uniqueSymbolReassignment.ts, 9, 31))
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 4, 54), Decl(uniqueSymbolReassignment.ts, 6, 24), Decl(uniqueSymbolReassignment.ts, 9, 31), Decl(uniqueSymbolReassignment.ts, 16, 38), Decl(uniqueSymbolReassignment.ts, 18, 35) ... and 2 more)
>anotherUnique : Symbol(myFunction.anotherUnique, Decl(uniqueSymbolReassignment.ts, 9, 31))
>anotherUnique : Symbol(anotherUnique, Decl(uniqueSymbolReassignment.ts, 4, 5))

// -------------------------
// Non-unique symbols (should stay `var`)
// -------------------------
let nonUnique1 = Symbol('nonUnique1');
>nonUnique1 : Symbol(nonUnique1, Decl(uniqueSymbolReassignment.ts, 15, 3))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))

let nonUnique2 = Symbol('nonUnique2');
>nonUnique2 : Symbol(nonUnique2, Decl(uniqueSymbolReassignment.ts, 16, 3))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))

myFunction.nonUnique1 = nonUnique1;
>myFunction.nonUnique1 : Symbol(myFunction.nonUnique1, Decl(uniqueSymbolReassignment.ts, 16, 38))
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 4, 54), Decl(uniqueSymbolReassignment.ts, 6, 24), Decl(uniqueSymbolReassignment.ts, 9, 31), Decl(uniqueSymbolReassignment.ts, 16, 38), Decl(uniqueSymbolReassignment.ts, 18, 35) ... and 2 more)
>nonUnique1 : Symbol(myFunction.nonUnique1, Decl(uniqueSymbolReassignment.ts, 16, 38))
>nonUnique1 : Symbol(nonUnique1, Decl(uniqueSymbolReassignment.ts, 15, 3))

myFunction.nonUnique2 = nonUnique2;
>myFunction.nonUnique2 : Symbol(myFunction.nonUnique2, Decl(uniqueSymbolReassignment.ts, 18, 35))
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 4, 54), Decl(uniqueSymbolReassignment.ts, 6, 24), Decl(uniqueSymbolReassignment.ts, 9, 31), Decl(uniqueSymbolReassignment.ts, 16, 38), Decl(uniqueSymbolReassignment.ts, 18, 35) ... and 2 more)
>nonUnique2 : Symbol(myFunction.nonUnique2, Decl(uniqueSymbolReassignment.ts, 18, 35))
>nonUnique2 : Symbol(nonUnique2, Decl(uniqueSymbolReassignment.ts, 16, 3))

// -------------------------
// Normal variables (should stay `var`/string)
// -------------------------
const normalVar = "just a string";
>normalVar : Symbol(normalVar, Decl(uniqueSymbolReassignment.ts, 24, 5))

const symbolName = "this contains symbol but is not one";
>symbolName : Symbol(symbolName, Decl(uniqueSymbolReassignment.ts, 25, 5))

myFunction.normalVar = normalVar;
>myFunction.normalVar : Symbol(myFunction.normalVar, Decl(uniqueSymbolReassignment.ts, 25, 57))
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 4, 54), Decl(uniqueSymbolReassignment.ts, 6, 24), Decl(uniqueSymbolReassignment.ts, 9, 31), Decl(uniqueSymbolReassignment.ts, 16, 38), Decl(uniqueSymbolReassignment.ts, 18, 35) ... and 2 more)
>normalVar : Symbol(myFunction.normalVar, Decl(uniqueSymbolReassignment.ts, 25, 57))
>normalVar : Symbol(normalVar, Decl(uniqueSymbolReassignment.ts, 24, 5))

myFunction.symbolName = symbolName;
>myFunction.symbolName : Symbol(myFunction.symbolName, Decl(uniqueSymbolReassignment.ts, 27, 33))
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 4, 54), Decl(uniqueSymbolReassignment.ts, 6, 24), Decl(uniqueSymbolReassignment.ts, 9, 31), Decl(uniqueSymbolReassignment.ts, 16, 38), Decl(uniqueSymbolReassignment.ts, 18, 35) ... and 2 more)
>symbolName : Symbol(myFunction.symbolName, Decl(uniqueSymbolReassignment.ts, 27, 33))
>symbolName : Symbol(symbolName, Decl(uniqueSymbolReassignment.ts, 25, 5))

// -------------------------
// Export symbols along with function to test `typeof` behavior
// -------------------------
export { myFunction, anotherUnique };
>myFunction : Symbol(myFunction, Decl(uniqueSymbolReassignment.ts, 33, 8))
>anotherUnique : Symbol(anotherUnique, Decl(uniqueSymbolReassignment.ts, 33, 20))

