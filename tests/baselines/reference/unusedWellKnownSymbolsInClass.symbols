=== tests/cases/compiler/unusedWellKnownSymbolsInClass.ts ===
export class Polling {
>Polling : Symbol(Polling, Decl(unusedWellKnownSymbolsInClass.ts, 0, 0))

  private async *[Symbol.asyncIterator]() {}
>[Symbol.asyncIterator] : Symbol(Polling[Symbol.asyncIterator], Decl(unusedWellKnownSymbolsInClass.ts, 0, 22))
>Symbol.asyncIterator : Symbol(SymbolConstructor.asyncIterator, Decl(lib.es2018.asynciterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>asyncIterator : Symbol(SymbolConstructor.asyncIterator, Decl(lib.es2018.asynciterable.d.ts, --, --))

  private *[Symbol.iterator]() {}
>[Symbol.iterator] : Symbol(Polling[Symbol.iterator], Decl(unusedWellKnownSymbolsInClass.ts, 1, 44))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))

  async loop() {
>loop : Symbol(Polling.loop, Decl(unusedWellKnownSymbolsInClass.ts, 2, 33))

    for await (const updates of this) {
>updates : Symbol(updates, Decl(unusedWellKnownSymbolsInClass.ts, 5, 20))
>this : Symbol(Polling, Decl(unusedWellKnownSymbolsInClass.ts, 0, 0))

      void updates
>updates : Symbol(updates, Decl(unusedWellKnownSymbolsInClass.ts, 5, 20))
    }
  }
  syncLoop() {
>syncLoop : Symbol(Polling.syncLoop, Decl(unusedWellKnownSymbolsInClass.ts, 8, 3))

    for (const updates of this) {
>updates : Symbol(updates, Decl(unusedWellKnownSymbolsInClass.ts, 10, 14))
>this : Symbol(Polling, Decl(unusedWellKnownSymbolsInClass.ts, 0, 0))

      void updates
>updates : Symbol(updates, Decl(unusedWellKnownSymbolsInClass.ts, 10, 14))
    }
  }
}

export class WellknownSymbolMethods {
>WellknownSymbolMethods : Symbol(WellknownSymbolMethods, Decl(unusedWellKnownSymbolsInClass.ts, 14, 1))

  private async *[Symbol.asyncIterator]() {
>[Symbol.asyncIterator] : Symbol(WellknownSymbolMethods[Symbol.asyncIterator], Decl(unusedWellKnownSymbolsInClass.ts, 16, 37))
>Symbol.asyncIterator : Symbol(SymbolConstructor.asyncIterator, Decl(lib.es2018.asynciterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>asyncIterator : Symbol(SymbolConstructor.asyncIterator, Decl(lib.es2018.asynciterable.d.ts, --, --))

    yield "hello";
  }

  private static [Symbol.hasInstance](instance: unknown) {
>[Symbol.hasInstance] : Symbol(WellknownSymbolMethods[Symbol.hasInstance], Decl(unusedWellKnownSymbolsInClass.ts, 19, 3))
>Symbol.hasInstance : Symbol(SymbolConstructor.hasInstance, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>hasInstance : Symbol(SymbolConstructor.hasInstance, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>instance : Symbol(instance, Decl(unusedWellKnownSymbolsInClass.ts, 21, 38))

    return Array.isArray(instance);
>Array.isArray : Symbol(ArrayConstructor.isArray, Decl(lib.es5.d.ts, --, --))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --) ... and 3 more)
>isArray : Symbol(ArrayConstructor.isArray, Decl(lib.es5.d.ts, --, --))
>instance : Symbol(instance, Decl(unusedWellKnownSymbolsInClass.ts, 21, 38))
  }

  private get [Symbol.isConcatSpreadable]() {
>[Symbol.isConcatSpreadable] : Symbol(WellknownSymbolMethods[Symbol.isConcatSpreadable], Decl(unusedWellKnownSymbolsInClass.ts, 23, 3))
>Symbol.isConcatSpreadable : Symbol(SymbolConstructor.isConcatSpreadable, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>isConcatSpreadable : Symbol(SymbolConstructor.isConcatSpreadable, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    return false
  }
  
  private *[Symbol.iterator]() {
>[Symbol.iterator] : Symbol(WellknownSymbolMethods[Symbol.iterator], Decl(unusedWellKnownSymbolsInClass.ts, 27, 3))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))

    yield "hello";
  }

  private get [Symbol.match]() {
>[Symbol.match] : Symbol(WellknownSymbolMethods[Symbol.match], Decl(unusedWellKnownSymbolsInClass.ts, 31, 3))
>Symbol.match : Symbol(SymbolConstructor.match, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>match : Symbol(SymbolConstructor.match, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    return false;
  }

  private *[Symbol.matchAll](str: string) {
>[Symbol.matchAll] : Symbol(WellknownSymbolMethods[Symbol.matchAll], Decl(unusedWellKnownSymbolsInClass.ts, 35, 3))
>Symbol.matchAll : Symbol(SymbolConstructor.matchAll, Decl(lib.es2020.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>matchAll : Symbol(SymbolConstructor.matchAll, Decl(lib.es2020.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 37, 29))

    for (const n of str.matchAll(/[0-9]+/g))
>n : Symbol(n, Decl(unusedWellKnownSymbolsInClass.ts, 38, 14))
>str.matchAll : Symbol(String.matchAll, Decl(lib.es2020.string.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 37, 29))
>matchAll : Symbol(String.matchAll, Decl(lib.es2020.string.d.ts, --, --))

      yield n[0];
>n : Symbol(n, Decl(unusedWellKnownSymbolsInClass.ts, 38, 14))
  }

  private [Symbol.replace](str: string) {
>[Symbol.replace] : Symbol(WellknownSymbolMethods[Symbol.replace], Decl(unusedWellKnownSymbolsInClass.ts, 40, 3))
>Symbol.replace : Symbol(SymbolConstructor.replace, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>replace : Symbol(SymbolConstructor.replace, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 42, 27))

    return `s/${str}/foo/g`;
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 42, 27))
  }

  private [Symbol.search](str: string) {
>[Symbol.search] : Symbol(WellknownSymbolMethods[Symbol.search], Decl(unusedWellKnownSymbolsInClass.ts, 44, 3))
>Symbol.search : Symbol(SymbolConstructor.search, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>search : Symbol(SymbolConstructor.search, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 46, 26))

    return str.indexOf('foo');
>str.indexOf : Symbol(String.indexOf, Decl(lib.es5.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 46, 26))
>indexOf : Symbol(String.indexOf, Decl(lib.es5.d.ts, --, --))
  }

  private [Symbol.split](str: string) {
>[Symbol.split] : Symbol(WellknownSymbolMethods[Symbol.split], Decl(unusedWellKnownSymbolsInClass.ts, 48, 3))
>Symbol.split : Symbol(SymbolConstructor.split, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>split : Symbol(SymbolConstructor.split, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 50, 25))

    return 'foo'
  }

  private static get [Symbol.species]() { return Array; }
>[Symbol.species] : Symbol(WellknownSymbolMethods[Symbol.species], Decl(unusedWellKnownSymbolsInClass.ts, 52, 3))
>Symbol.species : Symbol(SymbolConstructor.species, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>species : Symbol(SymbolConstructor.species, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --) ... and 3 more)

  private [Symbol.toPrimitive](hint: any) {
>[Symbol.toPrimitive] : Symbol(WellknownSymbolMethods[Symbol.toPrimitive], Decl(unusedWellKnownSymbolsInClass.ts, 54, 57))
>Symbol.toPrimitive : Symbol(SymbolConstructor.toPrimitive, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>toPrimitive : Symbol(SymbolConstructor.toPrimitive, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>hint : Symbol(hint, Decl(unusedWellKnownSymbolsInClass.ts, 56, 31))

    if (hint === 'number') {
>hint : Symbol(hint, Decl(unusedWellKnownSymbolsInClass.ts, 56, 31))

      return 42;
    }
    return null;
  }

  private get [Symbol.toStringTag]() {
>[Symbol.toStringTag] : Symbol(WellknownSymbolMethods[Symbol.toStringTag], Decl(unusedWellKnownSymbolsInClass.ts, 61, 3))
>Symbol.toStringTag : Symbol(SymbolConstructor.toStringTag, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>toStringTag : Symbol(SymbolConstructor.toStringTag, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    return 'foo';
  }

  private get [Symbol.unscopables]() {
>[Symbol.unscopables] : Symbol(WellknownSymbolMethods[Symbol.unscopables], Decl(unusedWellKnownSymbolsInClass.ts, 65, 3))
>Symbol.unscopables : Symbol(SymbolConstructor.unscopables, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>unscopables : Symbol(SymbolConstructor.unscopables, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

    return {};
  }
}

export class WellknownSymbolProperties {
>WellknownSymbolProperties : Symbol(WellknownSymbolProperties, Decl(unusedWellKnownSymbolsInClass.ts, 70, 1))

  private [Symbol.asyncIterator] = function*() {
>[Symbol.asyncIterator] : Symbol(WellknownSymbolProperties[Symbol.asyncIterator], Decl(unusedWellKnownSymbolsInClass.ts, 72, 40))
>Symbol.asyncIterator : Symbol(SymbolConstructor.asyncIterator, Decl(lib.es2018.asynciterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>asyncIterator : Symbol(SymbolConstructor.asyncIterator, Decl(lib.es2018.asynciterable.d.ts, --, --))

    yield "hello";
  }

  private static [Symbol.hasInstance] = (instance: unknown) => {
>[Symbol.hasInstance] : Symbol(WellknownSymbolProperties[Symbol.hasInstance], Decl(unusedWellKnownSymbolsInClass.ts, 75, 3))
>Symbol.hasInstance : Symbol(SymbolConstructor.hasInstance, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>hasInstance : Symbol(SymbolConstructor.hasInstance, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>instance : Symbol(instance, Decl(unusedWellKnownSymbolsInClass.ts, 77, 41))

    return Array.isArray(instance);
>Array.isArray : Symbol(ArrayConstructor.isArray, Decl(lib.es5.d.ts, --, --))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --) ... and 3 more)
>isArray : Symbol(ArrayConstructor.isArray, Decl(lib.es5.d.ts, --, --))
>instance : Symbol(instance, Decl(unusedWellKnownSymbolsInClass.ts, 77, 41))
  }

  private [Symbol.isConcatSpreadable] = false;
>[Symbol.isConcatSpreadable] : Symbol(WellknownSymbolProperties[Symbol.isConcatSpreadable], Decl(unusedWellKnownSymbolsInClass.ts, 79, 3))
>Symbol.isConcatSpreadable : Symbol(SymbolConstructor.isConcatSpreadable, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>isConcatSpreadable : Symbol(SymbolConstructor.isConcatSpreadable, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
  
  private [Symbol.iterator] = function*() {
>[Symbol.iterator] : Symbol(WellknownSymbolProperties[Symbol.iterator], Decl(unusedWellKnownSymbolsInClass.ts, 81, 46))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))

    yield "hello";
  }

  private [Symbol.match] = false;
>[Symbol.match] : Symbol(WellknownSymbolProperties[Symbol.match], Decl(unusedWellKnownSymbolsInClass.ts, 85, 3))
>Symbol.match : Symbol(SymbolConstructor.match, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>match : Symbol(SymbolConstructor.match, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

  private [Symbol.matchAll] = function*(str: string) {
>[Symbol.matchAll] : Symbol(WellknownSymbolProperties[Symbol.matchAll], Decl(unusedWellKnownSymbolsInClass.ts, 87, 33))
>Symbol.matchAll : Symbol(SymbolConstructor.matchAll, Decl(lib.es2020.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>matchAll : Symbol(SymbolConstructor.matchAll, Decl(lib.es2020.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 89, 40))

    for (const n of str.matchAll(/[0-9]+/g))
>n : Symbol(n, Decl(unusedWellKnownSymbolsInClass.ts, 90, 14))
>str.matchAll : Symbol(String.matchAll, Decl(lib.es2020.string.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 89, 40))
>matchAll : Symbol(String.matchAll, Decl(lib.es2020.string.d.ts, --, --))

      yield n[0];
>n : Symbol(n, Decl(unusedWellKnownSymbolsInClass.ts, 90, 14))
  }

  private [Symbol.replace] = (str: string) => {
>[Symbol.replace] : Symbol(WellknownSymbolProperties[Symbol.replace], Decl(unusedWellKnownSymbolsInClass.ts, 92, 3))
>Symbol.replace : Symbol(SymbolConstructor.replace, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>replace : Symbol(SymbolConstructor.replace, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 94, 30))

    return `s/${str}/foo/g`;
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 94, 30))
  }

  private [Symbol.search] = (str: string) => {
>[Symbol.search] : Symbol(WellknownSymbolProperties[Symbol.search], Decl(unusedWellKnownSymbolsInClass.ts, 96, 3))
>Symbol.search : Symbol(SymbolConstructor.search, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>search : Symbol(SymbolConstructor.search, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 98, 29))

    return str.indexOf('foo');
>str.indexOf : Symbol(String.indexOf, Decl(lib.es5.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 98, 29))
>indexOf : Symbol(String.indexOf, Decl(lib.es5.d.ts, --, --))
  }

  private [Symbol.split] = (str: string) => {
>[Symbol.split] : Symbol(WellknownSymbolProperties[Symbol.split], Decl(unusedWellKnownSymbolsInClass.ts, 100, 3))
>Symbol.split : Symbol(SymbolConstructor.split, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>split : Symbol(SymbolConstructor.split, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>str : Symbol(str, Decl(unusedWellKnownSymbolsInClass.ts, 102, 28))

    return 'foo'
  }

  private static [Symbol.species] = Array;
>[Symbol.species] : Symbol(WellknownSymbolProperties[Symbol.species], Decl(unusedWellKnownSymbolsInClass.ts, 104, 3))
>Symbol.species : Symbol(SymbolConstructor.species, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>species : Symbol(SymbolConstructor.species, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Array : Symbol(Array, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --) ... and 3 more)

  private [Symbol.toPrimitive] = (hint: any) => {
>[Symbol.toPrimitive] : Symbol(WellknownSymbolProperties[Symbol.toPrimitive], Decl(unusedWellKnownSymbolsInClass.ts, 106, 42))
>Symbol.toPrimitive : Symbol(SymbolConstructor.toPrimitive, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>toPrimitive : Symbol(SymbolConstructor.toPrimitive, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>hint : Symbol(hint, Decl(unusedWellKnownSymbolsInClass.ts, 108, 34))

    if (hint === 'number') {
>hint : Symbol(hint, Decl(unusedWellKnownSymbolsInClass.ts, 108, 34))

      return 42;
    }
    return null;
  }

  private [Symbol.toStringTag] = 'foo';
>[Symbol.toStringTag] : Symbol(WellknownSymbolProperties[Symbol.toStringTag], Decl(unusedWellKnownSymbolsInClass.ts, 113, 3))
>Symbol.toStringTag : Symbol(SymbolConstructor.toStringTag, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>toStringTag : Symbol(SymbolConstructor.toStringTag, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))

  private [Symbol.unscopables] = {};
>[Symbol.unscopables] : Symbol(WellknownSymbolProperties[Symbol.unscopables], Decl(unusedWellKnownSymbolsInClass.ts, 115, 39))
>Symbol.unscopables : Symbol(SymbolConstructor.unscopables, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>unscopables : Symbol(SymbolConstructor.unscopables, Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
}

const MyIterator = Symbol();
>MyIterator : Symbol(MyIterator, Decl(unusedWellKnownSymbolsInClass.ts, 120, 5))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))

export function testLocalSymbols() {
>testLocalSymbols : Symbol(testLocalSymbols, Decl(unusedWellKnownSymbolsInClass.ts, 120, 28))

  const Symbol = {
>Symbol : Symbol(Symbol, Decl(unusedWellKnownSymbolsInClass.ts, 122, 7))

    iterator: MyIterator
>iterator : Symbol(iterator, Decl(unusedWellKnownSymbolsInClass.ts, 122, 18))
>MyIterator : Symbol(MyIterator, Decl(unusedWellKnownSymbolsInClass.ts, 120, 5))

  };

  return class Foo{
>Foo : Symbol(Foo, Decl(unusedWellKnownSymbolsInClass.ts, 126, 8))

    private *[Symbol.iterator]() {
>[Symbol.iterator] : Symbol(Foo[Symbol.iterator], Decl(unusedWellKnownSymbolsInClass.ts, 126, 19))
>Symbol.iterator : Symbol(iterator, Decl(unusedWellKnownSymbolsInClass.ts, 122, 18))
>Symbol : Symbol(Symbol, Decl(unusedWellKnownSymbolsInClass.ts, 122, 7))
>iterator : Symbol(iterator, Decl(unusedWellKnownSymbolsInClass.ts, 122, 18))

      yield 1;
    }
  }
}

const iteratorSymbol = Symbol.iterator;
>iteratorSymbol : Symbol(iteratorSymbol, Decl(unusedWellKnownSymbolsInClass.ts, 133, 5))
>Symbol.iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))
>Symbol : Symbol(Symbol, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.symbol.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --), Decl(lib.es2019.symbol.d.ts, --, --))
>iterator : Symbol(SymbolConstructor.iterator, Decl(lib.es2015.iterable.d.ts, --, --))

export class C {
>C : Symbol(C, Decl(unusedWellKnownSymbolsInClass.ts, 133, 39))

  private *[iteratorSymbol]() {
>[iteratorSymbol] : Symbol(C[iteratorSymbol], Decl(unusedWellKnownSymbolsInClass.ts, 134, 16))
>iteratorSymbol : Symbol(iteratorSymbol, Decl(unusedWellKnownSymbolsInClass.ts, 133, 5))
    
  }
}
